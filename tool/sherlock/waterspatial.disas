
waterspatial:     file format elf32-littlearm


Disassembly of section .reset:

00000000 <_start>:
	.extern prefetch_abort_handler

.type   _start, %function

_start:
	b	reset_handler
   0:	ea000006 	b	20 <reset_handler>
	b undef_handler
   4:	ea00004d 	b	140 <undef_handler>
	b swi_handler
   8:	ea000084 	b	220 <swi_handler>
	b	prefetch_abort_handler
   c:	ea000027 	b	b0 <prefetch_abort_handler>
	b data_abort_handler
  10:	ea00004e 	b	150 <data_abort_handler>
	nop
  14:	e320f000 	nop	{0}
	b irq_handler
  18:	ea000057 	b	17c <irq_handler>
	b fiq_handler
  1c:	ea00004f 	b	160 <fiq_handler>

Disassembly of section .excep:

00000020 <reset_handler>:

.type   reset_handler, %function

reset_handler:
  @ Get the current cpuid
  mrc p15, 0, r0, c0, c0, 5
  20:	ee100fb0 	mrc	15, 0, r0, cr0, cr0, {5}
  mov r3, #0x400
  24:	e3a03b01 	mov	r3, #1024	; 0x400

  @ Compute the basic stack addresses
	ldr	r1, = CPU_SVC_STACK_ADDR
  28:	e59f1058 	ldr	r1, [pc, #88]	; 88 <_hell_pit+0x4>
  mul r2, r3, r0
  2c:	e0020093 	mul	r2, r3, r0
  sub r1, r1, r2
  30:	e0411002 	sub	r1, r1, r2

  # eight-byte stack alignment
  bic r1, r1, #7
  34:	e3c11007 	bic	r1, r1, #7

  @ Set the processor stack
	mov	r0, #FIQ_MODE
  38:	e3a000d1 	mov	r0, #209	; 0xd1
	msr	cpsr_c, r0
  3c:	e121f000 	msr	CPSR_c, r0
	mov	sp, r1
  40:	e1a0d001 	mov	sp, r1
	mov fp, sp
  44:	e1a0b00d 	mov	fp, sp

	mov	r0, #IRQ_MODE
  48:	e3a000d2 	mov	r0, #210	; 0xd2
	msr	cpsr_c, r0
  4c:	e121f000 	msr	CPSR_c, r0
	mov	sp, r1
  50:	e1a0d001 	mov	sp, r1
	mov fp, sp
  54:	e1a0b00d 	mov	fp, sp

	mov	r0,  #SVC_MODE
  58:	e3a000d3 	mov	r0, #211	; 0xd3
	msr cpsr_c, r0
  5c:	e121f000 	msr	CPSR_c, r0
	mov	sp, r1
  60:	e1a0d001 	mov	sp, r1
	mov fp, sp
  64:	e1a0b00d 	mov	fp, sp

	@ Enable CPU interrupts
	mrs r0, cpsr
  68:	e10f0000 	mrs	r0, CPSR
	bic r0, r0, #0xC0
  6c:	e3c000c0 	bic	r0, r0, #192	; 0xc0
	msr cpsr_c, r0
  70:	e121f000 	msr	CPSR_c, r0

	@ Call to system kickstart
	ldr	r0, = system_kickstart
  74:	e59f0010 	ldr	r0, [pc, #16]	; 8c <_hell_pit+0x8>
  blx r0
  78:	e12fff30 	blx	r0

  nop
  7c:	e320f000 	nop	{0}
  nop
  80:	e320f000 	nop	{0}

00000084 <_hell_pit>:

_hell_pit:
  b _hell_pit
  84:	eafffffe 	b	84 <_hell_pit>
  @ Get the current cpuid
  mrc p15, 0, r0, c0, c0, 5
  mov r3, #0x400

  @ Compute the basic stack addresses
	ldr	r1, = CPU_SVC_STACK_ADDR
  88:	0013e990 	.word	0x0013e990
	mrs r0, cpsr
	bic r0, r0, #0xC0
	msr cpsr_c, r0

	@ Call to system kickstart
	ldr	r0, = system_kickstart
  8c:	000143f0 	.word	0x000143f0

00000090 <cpu_context_save>:
.section .excep,#alloc,#execinstr
	.align 4
	.global cpu_context_save

cpu_context_save:
	stmia r0!, {r0 - r10, fp, ip, sp}
  90:	e8a03fff 	stmia	r0!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp}
  str r1, [r0], #4
  94:	e4801004 	str	r1, [r0], #4
	mrs r1, cpsr
  98:	e10f1000 	mrs	r1, CPSR
	str	r1, [r0]
  9c:	e5801000 	str	r1, [r0]
	mov pc, lr
  a0:	e1a0f00e 	mov	pc, lr
  nop
  a4:	e320f000 	nop	{0}
  nop
  a8:	e320f000 	nop	{0}
  ac:	e320f000 	nop	{0}

000000b0 <prefetch_abort_handler>:
.section .excep,#alloc,#execinstr
	.align 4
	.global prefetch_abort_handler

prefetch_abort_handler:
	b prefetch_abort_handler
  b0:	eafffffe 	b	b0 <prefetch_abort_handler>
  b4:	e320f000 	nop	{0}
  b8:	e320f000 	nop	{0}
  bc:	e320f000 	nop	{0}

000000c0 <cpu_context_init>:
# r2: stack_size
# r3: bootstrap
# [sp, #12]: signature

cpu_context_init:
	push {r4, r5, lr}
  c0:	e92d4030 	push	{r4, r5, lr}
	ldr r4, [sp, #12]
  c4:	e59d400c 	ldr	r4, [sp, #12]
	str r4, [r0], #4
  c8:	e4804004 	str	r4, [r0], #4
	stmia r0!, {r1-r10, fp, ip}
  cc:	e8a01ffe 	stmia	r0!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
	add r5, r1, r2 
  d0:	e0815002 	add	r5, r1, r2
	sub r5, r5, #4
  d4:	e2455004 	sub	r5, r5, #4

  # eight-byte stack alignment	
  bic r5, r5, #7
  d8:	e3c55007 	bic	r5, r5, #7

  str r5, [r0], #4
  dc:	e4805004 	str	r5, [r0], #4
	str r3, [r0], #4
  e0:	e4803004 	str	r3, [r0], #4
	mrs r5, cpsr
  e4:	e10f5000 	mrs	r5, CPSR
	orr r5, r5, #0xC0
  e8:	e38550c0 	orr	r5, r5, #192	; 0xc0
	str r5, [r0]
  ec:	e5805000 	str	r5, [r0]
	pop {r4, r5, pc}
  f0:	e8bd8030 	pop	{r4, r5, pc}
  nop
  f4:	e320f000 	nop	{0}
  nop
  f8:	e320f000 	nop	{0}
  fc:	e320f000 	nop	{0}

00000100 <cpu_context_load>:
	.global cpu_context_load

cpu_context_load:

  @ We restore the common registers
  add r0, r0, #8
 100:	e2800008 	add	r0, r0, #8
	ldmia	r0, {r2 - r10, fp, ip, sp}
 104:	e8903ffc 	ldm	r0, {r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp}

  @ We get the new r0, r1 and pc values and push them
  sub r0, r0, #8
 108:	e2400008 	sub	r0, r0, #8
  ldr r1, [r0, #56]
 10c:	e5901038 	ldr	r1, [r0, #56]	; 0x38
  push {r1}
 110:	e52d1004 	push	{r1}		; (str r1, [sp, #-4]!)
  ldr r1, [r0, #4]
 114:	e5901004 	ldr	r1, [r0, #4]
  push {r1}
 118:	e52d1004 	push	{r1}		; (str r1, [sp, #-4]!)
  ldr r1, [r0]
 11c:	e5901000 	ldr	r1, [r0]
  push {r1}
 120:	e52d1004 	push	{r1}		; (str r1, [sp, #-4]!)

  @ We load the cpsr and spsr
    ldr	r1, [r0, #60]
 124:	e590103c 	ldr	r1, [r0, #60]	; 0x3c
	msr	cpsr, r1
 128:	e129f001 	msr	CPSR_fc, r1

  @ And now we restore the registers
  pop {r0, r1, pc}
 12c:	e8bd8003 	pop	{r0, r1, pc}
  nop
 130:	e320f000 	nop	{0}
  nop
 134:	e320f000 	nop	{0}
 138:	e320f000 	nop	{0}
 13c:	e320f000 	nop	{0}

00000140 <undef_handler>:
.section .excep,#alloc,#execinstr
	.align 4
	.global undef_handler

undef_handler:
	b undef_handler
 140:	eafffffe 	b	140 <undef_handler>
 144:	e320f000 	nop	{0}
 148:	e320f000 	nop	{0}
 14c:	e320f000 	nop	{0}

00000150 <data_abort_handler>:
.section .excep,#alloc,#execinstr
	.align 4
	.global data_abort_handler

data_abort_handler:
  b data_abort_handler
 150:	eafffffe 	b	150 <data_abort_handler>
 154:	e320f000 	nop	{0}
 158:	e320f000 	nop	{0}
 15c:	e320f000 	nop	{0}

00000160 <fiq_handler>:
	.align 4
	.global fiq_handler

fiq_handler:
	@ Not Handled
	subs pc, lr, #0x4
 160:	e25ef004 	subs	pc, lr, #4
  nop
 164:	e320f000 	nop	{0}
  nop
 168:	e320f000 	nop	{0}
 16c:	e320f000 	nop	{0}

00000170 <irq_registers>:
	...

0000017c <irq_handler>:
  .word 0x0 @ LR
  .word 0x0 @ CPSR

irq_handler:
	@ Save scratch registers and SPSR
	push {r0}
 17c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
  ldr r0, =irq_registers
 180:	e59f0088 	ldr	r0, [pc, #136]	; 210 <irq_handler+0x94>
  stmia r0!, {r1, lr}
 184:	e8a04002 	stmia	r0!, {r1, lr}
	mrs	lr, spsr
 188:	e14fe000 	mrs	lr, SPSR
  str lr, [r0]
 18c:	e580e000 	str	lr, [r0]
  pop {r0}
 190:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)

	@ Move to SVC mode
	mrs lr, cpsr
 194:	e10fe000 	mrs	lr, CPSR
	orr lr, lr, #0xC3
 198:	e38ee0c3 	orr	lr, lr, #195	; 0xc3
	msr cpsr, lr 
 19c:	e129f00e 	msr	CPSR_fc, lr

  @ Save the context
  push {r0-r3, r9-r12, lr}
 1a0:	e92d5e0f 	push	{r0, r1, r2, r3, r9, sl, fp, ip, lr}
  ldr r0, =irq_registers
 1a4:	e59f0064 	ldr	r0, [pc, #100]	; 210 <irq_handler+0x94>
  ldmia r0, {r1, r2, r3}
 1a8:	e890000e 	ldm	r0, {r1, r2, r3}
  push {r1, r2, r3}
 1ac:	e92d000e 	push	{r1, r2, r3}

	@ Fetch the current interruption source
	@ Branch to IRQ handler

	ldr r1, =PLATFORM_AICU_BASE
 1b0:	e59f105c 	ldr	r1, [pc, #92]	; 214 <irq_handler+0x98>
	ldr r1, [r1]
 1b4:	e5911000 	ldr	r1, [r1]
  mrc p15,0,r2,c0,c0,5
 1b8:	ee102fb0 	mrc	15, 0, r2, cr0, cr0, {5}
  add r1, r1, #0x100
 1bc:	e2811c01 	add	r1, r1, #256	; 0x100
  add r1, r1, r2, lsl #0x4
 1c0:	e0811202 	add	r1, r1, r2, lsl #4

	ldr r0, [r1, #0xC]
 1c4:	e591000c 	ldr	r0, [r1, #12]
	ldr r1, [r1, #0x8]
 1c8:	e5911008 	ldr	r1, [r1, #8]
	blx r1
 1cc:	e12fff31 	blx	r1

	@ Restore the context
  ldr r0, =irq_registers
 1d0:	e59f0038 	ldr	r0, [pc, #56]	; 210 <irq_handler+0x94>
  pop {r1, r2, r3}
 1d4:	e8bd000e 	pop	{r1, r2, r3}
  stmia r0, {r1, r2, r3}
 1d8:	e880000e 	stm	r0, {r1, r2, r3}
  pop {r0-r3, r9-r12, lr}
 1dc:	e8bd5e0f 	pop	{r0, r1, r2, r3, r9, sl, fp, ip, lr}
  
	@ Move back to IRQ mode
	mrs r1, cpsr
 1e0:	e10f1000 	mrs	r1, CPSR
	bic r1, r1, #0x1
 1e4:	e3c11001 	bic	r1, r1, #1
	msr cpsr, r1
 1e8:	e129f001 	msr	CPSR_fc, r1

	@ Restore registers
  push {r0, r2}
 1ec:	e92d0005 	push	{r0, r2}
  ldr r0, =irq_registers
 1f0:	e59f0018 	ldr	r0, [pc, #24]	; 210 <irq_handler+0x94>
  ldmia r0!, {r1, lr}
 1f4:	e8b04002 	ldm	r0!, {r1, lr}
  ldr r2, [r0]
 1f8:	e5902000 	ldr	r2, [r0]
	msr	spsr, r2
 1fc:	e169f002 	msr	SPSR_fc, r2
  pop {r0, r2}
 200:	e8bd0005 	pop	{r0, r2}

	@ Return
	subs pc, lr, #0x4
 204:	e25ef004 	subs	pc, lr, #4
  nop
 208:	e320f000 	nop	{0}
  nop
 20c:	e320f000 	nop	{0}
  .word 0x0 @ CPSR

irq_handler:
	@ Save scratch registers and SPSR
	push {r0}
  ldr r0, =irq_registers
 210:	00000170 	.word	0x00000170
  push {r1, r2, r3}

	@ Fetch the current interruption source
	@ Branch to IRQ handler

	ldr r1, =PLATFORM_AICU_BASE
 214:	0003e964 	.word	0x0003e964
 218:	e320f000 	nop	{0}
 21c:	e320f000 	nop	{0}

00000220 <swi_handler>:
.section .excep,#alloc,#execinstr
	.align 4
	.global swi_handler

swi_handler:
	b swi_handler
 220:	eafffffe 	b	220 <swi_handler>
 224:	e320f000 	nop	{0}
 228:	e320f000 	nop	{0}
 22c:	e320f000 	nop	{0}

Disassembly of section .init:

00000238 <_init>:
 238:	e1a0c00d 	mov	ip, sp
 23c:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
 240:	e24cb004 	sub	fp, ip, #4

00000244 <__frame_dummy_init_array_entry>:
 244:	00000324 e24bd028 e89d6ff0 e12fff1e     $...(.K..o..../.

Disassembly of section .fini:

00000258 <_fini>:
 258:	e1a0c00d 	mov	ip, sp
 25c:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
 260:	e24cb004 	sub	fp, ip, #4

00000264 <__do_global_dtors_aux_fini_array_entry>:
 264:	000002e0 e24bd028 e89d6ff0 e12fff1e     ....(.K..o..../.

Disassembly of section .text:

00000278 <deregister_tm_clones>:
     278:	e59f301c 	ldr	r3, [pc, #28]	; 29c <deregister_tm_clones+0x24>
     27c:	e59f001c 	ldr	r0, [pc, #28]	; 2a0 <deregister_tm_clones+0x28>
     280:	e0603003 	rsb	r3, r0, r3
     284:	e3530006 	cmp	r3, #6
     288:	912fff1e 	bxls	lr
     28c:	e59f3010 	ldr	r3, [pc, #16]	; 2a4 <deregister_tm_clones+0x2c>
     290:	e3530000 	cmp	r3, #0
     294:	012fff1e 	bxeq	lr
     298:	e12fff13 	bx	r3
     29c:	0003e90f 	.word	0x0003e90f
     2a0:	0003e90c 	.word	0x0003e90c
     2a4:	00000000 	.word	0x00000000

000002a8 <register_tm_clones>:
     2a8:	e59f1024 	ldr	r1, [pc, #36]	; 2d4 <register_tm_clones+0x2c>
     2ac:	e59f0024 	ldr	r0, [pc, #36]	; 2d8 <register_tm_clones+0x30>
     2b0:	e0601001 	rsb	r1, r0, r1
     2b4:	e1a01141 	asr	r1, r1, #2
     2b8:	e0811fa1 	add	r1, r1, r1, lsr #31
     2bc:	e1b010c1 	asrs	r1, r1, #1
     2c0:	012fff1e 	bxeq	lr
     2c4:	e59f3010 	ldr	r3, [pc, #16]	; 2dc <register_tm_clones+0x34>
     2c8:	e3530000 	cmp	r3, #0
     2cc:	012fff1e 	bxeq	lr
     2d0:	e12fff13 	bx	r3
     2d4:	0003e90c 	.word	0x0003e90c
     2d8:	0003e90c 	.word	0x0003e90c
     2dc:	00000000 	.word	0x00000000

000002e0 <__do_global_dtors_aux>:
     2e0:	e92d4010 	push	{r4, lr}
     2e4:	e59f402c 	ldr	r4, [pc, #44]	; 318 <__do_global_dtors_aux+0x38>
     2e8:	e5d43000 	ldrb	r3, [r4]
     2ec:	e3530000 	cmp	r3, #0
     2f0:	1a000006 	bne	310 <__do_global_dtors_aux+0x30>
     2f4:	ebffffdf 	bl	278 <deregister_tm_clones>
     2f8:	e59f301c 	ldr	r3, [pc, #28]	; 31c <__do_global_dtors_aux+0x3c>
     2fc:	e3530000 	cmp	r3, #0
     300:	159f0018 	ldrne	r0, [pc, #24]	; 320 <__do_global_dtors_aux+0x40>
     304:	11a00000 	movne	r0, r0
     308:	e3a03001 	mov	r3, #1
     30c:	e5c43000 	strb	r3, [r4]
     310:	e8bd4010 	pop	{r4, lr}
     314:	e12fff1e 	bx	lr
     318:	0013e998 	.word	0x0013e998
     31c:	00000000 	.word	0x00000000
     320:	000338c8 	.word	0x000338c8

00000324 <frame_dummy>:
     324:	e92d4008 	push	{r3, lr}
     328:	e59f3034 	ldr	r3, [pc, #52]	; 364 <frame_dummy+0x40>
     32c:	e3530000 	cmp	r3, #0
     330:	159f0030 	ldrne	r0, [pc, #48]	; 368 <frame_dummy+0x44>
     334:	159f1030 	ldrne	r1, [pc, #48]	; 36c <frame_dummy+0x48>
     338:	11a00000 	movne	r0, r0
     33c:	e59f002c 	ldr	r0, [pc, #44]	; 370 <frame_dummy+0x4c>
     340:	e5903000 	ldr	r3, [r0]
     344:	e3530000 	cmp	r3, #0
     348:	0a000003 	beq	35c <frame_dummy+0x38>
     34c:	e59f3020 	ldr	r3, [pc, #32]	; 374 <frame_dummy+0x50>
     350:	e3530000 	cmp	r3, #0
     354:	11a0e00f 	movne	lr, pc
     358:	112fff13 	bxne	r3
     35c:	e8bd4008 	pop	{r3, lr}
     360:	eaffffd0 	b	2a8 <register_tm_clones>
     364:	00000000 	.word	0x00000000
     368:	000338c8 	.word	0x000338c8
     36c:	0013e99c 	.word	0x0013e99c
     370:	00000230 	.word	0x00000230
     374:	00000000 	.word	0x00000000

00000378 <_main>:
extern int __libthread_start (void);
extern void _init(void);
extern void _fini(void);

int _main(void)
{
     378:	e92d4800 	push	{fp, lr}
     37c:	e28db004 	add	fp, sp, #4
     380:	e24dd008 	sub	sp, sp, #8

	/*
	 * Create the sanity check semaphore
	 */

	semaphore_create ("libc_sanity_sem", 1, &__sanity_sem);
     384:	e59f002c 	ldr	r0, [pc, #44]	; 3b8 <_main+0x40>
     388:	e3a01001 	mov	r1, #1
     38c:	e59f2028 	ldr	r2, [pc, #40]	; 3bc <_main+0x44>
     390:	eb004b12 	bl	12fe0 <semaphore_create>

	/*
	 * Call all init functions before calling main()
	 */
	_init();
     394:	ebffffa7 	bl	238 <_init>

	/*
	 * Return from the application's call
	 */

	return_value = __libthread_start ();
     398:	eb000385 	bl	11b4 <__libthread_start>
     39c:	e50b0008 	str	r0, [fp, #-8]

	/*
	 * Call all fini functions after main() retruns
	 */
	_fini();
     3a0:	ebffffac 	bl	258 <_fini>

	return return_value;
     3a4:	e51b3008 	ldr	r3, [fp, #-8]
}
     3a8:	e1a00003 	mov	r0, r3
     3ac:	e24bd004 	sub	sp, fp, #4
     3b0:	e8bd4800 	pop	{fp, lr}
     3b4:	e12fff1e 	bx	lr
     3b8:	00031980 	.word	0x00031980
     3bc:	0003e464 	.word	0x0003e464

000003c0 <kpn_channel_create>:
#include <DnaTools/DnaTools.h>
#include <KahnProcessNetwork/KahnProcessNetwork.h>

kpn_status_t kpn_channel_create (char * name,
    int32_t buffer_size, kpn_channel_t * channel)
{
     3c0:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
     3c4:	e1a06000 	mov	r6, r0
  kpn_channel_t c = NULL;
  
  watch (kpn_status_t)
  {
    c = malloc (sizeof (struct _kpn_channel));
     3c8:	e3a00018 	mov	r0, #24
#include <DnaTools/DnaTools.h>
#include <KahnProcessNetwork/KahnProcessNetwork.h>

kpn_status_t kpn_channel_create (char * name,
    int32_t buffer_size, kpn_channel_t * channel)
{
     3cc:	e1a05001 	mov	r5, r1
     3d0:	e1a08002 	mov	r8, r2
  kpn_channel_t c = NULL;
  
  watch (kpn_status_t)
  {
    c = malloc (sizeof (struct _kpn_channel));
     3d4:	eb005caa 	bl	17684 <malloc>
    ensure (c != NULL, KPN_OUT_OF_MEM);
     3d8:	e2504000 	subs	r4, r0, #0
     3dc:	0a00001a 	beq	44c <kpn_channel_create+0x8c>

    c -> fd = open (name, O_RDWR);
     3e0:	e1a00006 	mov	r0, r6
     3e4:	e3a01002 	mov	r1, #2
     3e8:	eb00616c 	bl	189a0 <open>
     3ec:	e6ff0070 	uxth	r0, r0
    check (vfs_error, c -> fd != -1, KPN_NO_ENTRY);
     3f0:	e6bf7070 	sxth	r7, r0
     3f4:	e3770001 	cmn	r7, #1
  watch (kpn_status_t)
  {
    c = malloc (sizeof (struct _kpn_channel));
    ensure (c != NULL, KPN_OUT_OF_MEM);

    c -> fd = open (name, O_RDWR);
     3f8:	e1c400b4 	strh	r0, [r4, #4]
    check (vfs_error, c -> fd != -1, KPN_NO_ENTRY);
     3fc:	0a00002c 	beq	4b4 <kpn_channel_create+0xf4>

    if (buffer_size != 0)
     400:	e3550000 	cmp	r5, #0
     404:	1a000012 	bne	454 <kpn_channel_create+0x94>

      c -> size = buffer_size;
    }
    else
    {
      c -> data = NULL;
     408:	e5845014 	str	r5, [r4, #20]
      c -> size = 0;
     40c:	e5845008 	str	r5, [r4, #8]
    }

    c -> name = malloc (strlen (name) + 1);
     410:	e1a00006 	mov	r0, r6
     414:	eb0063a5 	bl	192b0 <strlen>
     418:	e2800001 	add	r0, r0, #1
     41c:	eb005c98 	bl	17684 <malloc>
    check (name_error, c -> name != NULL, KPN_OUT_OF_MEM);
     420:	e3500000 	cmp	r0, #0
    {
      c -> data = NULL;
      c -> size = 0;
    }

    c -> name = malloc (strlen (name) + 1);
     424:	e5840000 	str	r0, [r4]
    check (name_error, c -> name != NULL, KPN_OUT_OF_MEM);
     428:	0a00001a 	beq	498 <kpn_channel_create+0xd8>

    c -> level = 0;
     42c:	e3a05000 	mov	r5, #0
    c -> position = 0;
    strcpy (c -> name, name);
     430:	e1a01006 	mov	r1, r6
    }

    c -> name = malloc (strlen (name) + 1);
    check (name_error, c -> name != NULL, KPN_OUT_OF_MEM);

    c -> level = 0;
     434:	e584500c 	str	r5, [r4, #12]
    c -> position = 0;
     438:	e5845010 	str	r5, [r4, #16]
    strcpy (c -> name, name);
     43c:	eb00635e 	bl	191bc <strcpy>

    *channel = c;
    return KPN_OK;
     440:	e1a00005 	mov	r0, r5

    c -> level = 0;
    c -> position = 0;
    strcpy (c -> name, name);

    *channel = c;
     444:	e5884000 	str	r4, [r8]
    return KPN_OK;
     448:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  kpn_channel_t c = NULL;
  
  watch (kpn_status_t)
  {
    c = malloc (sizeof (struct _kpn_channel));
    ensure (c != NULL, KPN_OUT_OF_MEM);
     44c:	e3a00002 	mov	r0, #2
  rescue (vfs_error)
  {
    free (c);
    leave;
  }
}
     450:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
    c -> fd = open (name, O_RDWR);
    check (vfs_error, c -> fd != -1, KPN_NO_ENTRY);

    if (buffer_size != 0)
    {
      c -> data = malloc (buffer_size);
     454:	e1a00005 	mov	r0, r5
     458:	eb005c89 	bl	17684 <malloc>
      check (data_error, c -> data != NULL, KPN_OUT_OF_MEM);
     45c:	e3500000 	cmp	r0, #0
    c -> fd = open (name, O_RDWR);
    check (vfs_error, c -> fd != -1, KPN_NO_ENTRY);

    if (buffer_size != 0)
    {
      c -> data = malloc (buffer_size);
     460:	e1a09000 	mov	r9, r0
     464:	e5840014 	str	r0, [r4, #20]
      check (data_error, c -> data != NULL, KPN_OUT_OF_MEM);
     468:	0a00000a 	beq	498 <kpn_channel_create+0xd8>

      c -> size = buffer_size;
     46c:	e5845008 	str	r5, [r4, #8]
    {
      c -> data = NULL;
      c -> size = 0;
    }

    c -> name = malloc (strlen (name) + 1);
     470:	e1a00006 	mov	r0, r6
     474:	eb00638d 	bl	192b0 <strlen>
     478:	e2800001 	add	r0, r0, #1
     47c:	eb005c80 	bl	17684 <malloc>
    check (name_error, c -> name != NULL, KPN_OUT_OF_MEM);
     480:	e3500000 	cmp	r0, #0
    {
      c -> data = NULL;
      c -> size = 0;
    }

    c -> name = malloc (strlen (name) + 1);
     484:	e5840000 	str	r0, [r4]
    check (name_error, c -> name != NULL, KPN_OUT_OF_MEM);
     488:	1affffe7 	bne	42c <kpn_channel_create+0x6c>
    return KPN_OK;
  }

  rescue (name_error)
  {
    if (buffer_size != 0) free (c -> data);
     48c:	e1a00009 	mov	r0, r9
     490:	eb005c8a 	bl	176c0 <free>
     494:	e1d470f4 	ldrsh	r7, [r4, #4]
  }

  rescue (data_error)
  {
    close (c -> fd);
     498:	e1a00007 	mov	r0, r7
     49c:	eb0055c6 	bl	15bbc <close>
     4a0:	e3a05002 	mov	r5, #2
  }

  rescue (vfs_error)
  {
    free (c);
     4a4:	e1a00004 	mov	r0, r4
     4a8:	eb005c84 	bl	176c0 <free>
    leave;
     4ac:	e1a00005 	mov	r0, r5
     4b0:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  {
    c = malloc (sizeof (struct _kpn_channel));
    ensure (c != NULL, KPN_OUT_OF_MEM);

    c -> fd = open (name, O_RDWR);
    check (vfs_error, c -> fd != -1, KPN_NO_ENTRY);
     4b4:	e3a05003 	mov	r5, #3
     4b8:	eafffff9 	b	4a4 <kpn_channel_create+0xe4>

000004bc <kpn_channel_skip>:
  int32_t bytes_to_transfer = 0;
  uint8_t * waste;

  watch (kpn_status_t)
  {
    if (c -> data == NULL)
     4bc:	e5903014 	ldr	r3, [r0, #20]

#include <DnaTools/DnaTools.h>
#include <KahnProcessNetwork/KahnProcessNetwork.h>

kpn_status_t kpn_channel_skip (kpn_channel_t c, int32_t size)
{
     4c0:	e92d4070 	push	{r4, r5, r6, lr}
  int32_t bytes_to_transfer = 0;
  uint8_t * waste;

  watch (kpn_status_t)
  {
    if (c -> data == NULL)
     4c4:	e3530000 	cmp	r3, #0

#include <DnaTools/DnaTools.h>
#include <KahnProcessNetwork/KahnProcessNetwork.h>

kpn_status_t kpn_channel_skip (kpn_channel_t c, int32_t size)
{
     4c8:	e1a06000 	mov	r6, r0
     4cc:	e1a05001 	mov	r5, r1
  int32_t bytes_to_transfer = 0;
  uint8_t * waste;

  watch (kpn_status_t)
  {
    if (c -> data == NULL)
     4d0:	0a000018 	beq	538 <kpn_channel_skip+0x7c>

      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     4d4:	e3510000 	cmp	r1, #0
     4d8:	1590400c 	ldrne	r4, [r0, #12]
     4dc:	1a00000a 	bne	50c <kpn_channel_skip+0x50>
     4e0:	ea000012 	b	530 <kpn_channel_skip+0x74>
     4e4:	e5962010 	ldr	r2, [r6, #16]
          res = read (c -> fd, c -> data, c -> size);
          c -> level = c -> size;
          c -> position = 0;
        }

        bytes_to_transfer = (counter <= c -> level) ?
     4e8:	e1540005 	cmp	r4, r5
     4ec:	b1a03004 	movlt	r3, r4
     4f0:	a1a03005 	movge	r3, r5
          counter : c -> level;

        c -> position += bytes_to_transfer;
     4f4:	e0832002 	add	r2, r3, r2
        c -> level -= bytes_to_transfer;
     4f8:	e0634004 	rsb	r4, r3, r4

      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     4fc:	e0555003 	subs	r5, r5, r3
        }

        bytes_to_transfer = (counter <= c -> level) ?
          counter : c -> level;

        c -> position += bytes_to_transfer;
     500:	e5862010 	str	r2, [r6, #16]
        c -> level -= bytes_to_transfer;
     504:	e586400c 	str	r4, [r6, #12]

      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     508:	0a000008 	beq	530 <kpn_channel_skip+0x74>
      {
        if (c -> level == 0)
     50c:	e3540000 	cmp	r4, #0
     510:	1afffff3 	bne	4e4 <kpn_channel_skip+0x28>
        {
          res = read (c -> fd, c -> data, c -> size);
     514:	e5962008 	ldr	r2, [r6, #8]
     518:	e1d600f4 	ldrsh	r0, [r6, #4]
     51c:	e5961014 	ldr	r1, [r6, #20]
     520:	eb006207 	bl	18d44 <read>
          c -> level = c -> size;
     524:	e1a02004 	mov	r2, r4
     528:	e5964008 	ldr	r4, [r6, #8]
     52c:	eaffffed 	b	4e8 <kpn_channel_skip+0x2c>
        c -> level -= bytes_to_transfer;
        counter -= bytes_to_transfer;
      }
    }

    return KPN_OK;
     530:	e3a00000 	mov	r0, #0
     534:	e8bd8070 	pop	{r4, r5, r6, pc}

  watch (kpn_status_t)
  {
    if (c -> data == NULL)
    {
      waste = malloc (size);
     538:	e1a00001 	mov	r0, r1
     53c:	eb005c50 	bl	17684 <malloc>
      ensure (waste != NULL, KPN_OUT_OF_MEM);
     540:	e2504000 	subs	r4, r0, #0
     544:	0a00000a 	beq	574 <kpn_channel_skip+0xb8>

      res = read (c -> fd, waste, size);
     548:	e1a02005 	mov	r2, r5
     54c:	e1a01004 	mov	r1, r4
     550:	e1d600f4 	ldrsh	r0, [r6, #4]
     554:	eb0061fa 	bl	18d44 <read>
     558:	e1a05000 	mov	r5, r0
      free (waste);
     55c:	e1a00004 	mov	r0, r4
     560:	eb005c56 	bl	176c0 <free>
  watch (kpn_status_t)
  {
    if (c -> data == NULL)
    {
      waste = malloc (size);
      ensure (waste != NULL, KPN_OUT_OF_MEM);
     564:	e3750001 	cmn	r5, #1
     568:	13a00000 	movne	r0, #0
     56c:	03a00001 	moveq	r0, #1
     570:	e8bd8070 	pop	{r4, r5, r6, pc}
     574:	e3a00002 	mov	r0, #2
      }
    }

    return KPN_OK;
  }
}
     578:	e8bd8070 	pop	{r4, r5, r6, pc}

0000057c <kpn_channel_purge>:

#include <DnaTools/DnaTools.h>
#include <KahnProcessNetwork/KahnProcessNetwork.h>

kpn_status_t kpn_channel_purge (kpn_channel_t c, bool flush)
{
     57c:	e92d4010 	push	{r4, lr}
  int32_t res = 0;

  watch (kpn_status_t)
  {
    ensure (c != NULL, KPN_ERROR);
     580:	e2504000 	subs	r4, r0, #0
     584:	0a00000b 	beq	5b8 <kpn_channel_purge+0x3c>

    if (flush)
     588:	e3510000 	cmp	r1, #0
     58c:	1a000003 	bne	5a0 <kpn_channel_purge+0x24>
    {
      res = write (c -> fd, c -> data, c -> size);
      ensure (res != -1, KPN_ERROR);
    }

    c -> level = 0;
     590:	e3a00000 	mov	r0, #0
     594:	e584000c 	str	r0, [r4, #12]
    c -> position = 0;
     598:	e5840010 	str	r0, [r4, #16]

    return KPN_OK;
     59c:	e8bd8010 	pop	{r4, pc}
  {
    ensure (c != NULL, KPN_ERROR);

    if (flush)
    {
      res = write (c -> fd, c -> data, c -> size);
     5a0:	e1d400f4 	ldrsh	r0, [r4, #4]
     5a4:	e5941014 	ldr	r1, [r4, #20]
     5a8:	e5942008 	ldr	r2, [r4, #8]
     5ac:	eb007b6f 	bl	1f370 <write>
      ensure (res != -1, KPN_ERROR);
     5b0:	e3700001 	cmn	r0, #1
     5b4:	1afffff5 	bne	590 <kpn_channel_purge+0x14>
{
  int32_t res = 0;

  watch (kpn_status_t)
  {
    ensure (c != NULL, KPN_ERROR);
     5b8:	e3a00001 	mov	r0, #1
     5bc:	e8bd8010 	pop	{r4, pc}

000005c0 <kpn_channel_write>:
#include <DnaTools/DnaTools.h>
#include <KahnProcessNetwork/KahnProcessNetwork.h>
#include <VirtualFileSystem/VirtualFileSystem.h>

kpn_status_t kpn_channel_write (kpn_channel_t c, void * data, int32_t size)
{
     5c0:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
     5c4:	e1a04000 	mov	r4, r0
  int32_t counter = size, res = 0, position_in_data = 0;
  int32_t bytes_to_transfer = 0;

  watch (kpn_status_t)
  {
    if (c -> data == NULL)
     5c8:	e5900014 	ldr	r0, [r0, #20]
     5cc:	e3500000 	cmp	r0, #0
     5d0:	0a00002c 	beq	688 <kpn_channel_write+0xc8>
      res = write (c -> fd, data, size);
      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     5d4:	e3520000 	cmp	r2, #0
     5d8:	e1a06002 	mov	r6, r2
     5dc:	0a000025 	beq	678 <kpn_channel_write+0xb8>
     5e0:	e3a07000 	mov	r7, #0
     5e4:	e1a08001 	mov	r8, r1
        if (c -> level == c -> size)
        {
          res = write (c -> fd, c -> data, c -> size);
          ensure (res != -1, KPN_ERROR);

          c -> level = 0;
     5e8:	e1a09007 	mov	r9, r7
     5ec:	e594200c 	ldr	r2, [r4, #12]
     5f0:	e5943010 	ldr	r3, [r4, #16]
     5f4:	ea000002 	b	604 <kpn_channel_write+0x44>
      res = write (c -> fd, data, size);
      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     5f8:	e3560000 	cmp	r6, #0
     5fc:	0a00001d 	beq	678 <kpn_channel_write+0xb8>
     600:	e5940014 	ldr	r0, [r4, #20]
      {
        bytes_to_transfer = (counter <= c -> size - c -> level) ?
          counter : c -> size - c -> level;
     604:	e5945008 	ldr	r5, [r4, #8]

        memcpy ((void *)(c -> data + c -> position),
     608:	e0881007 	add	r1, r8, r7
    else
    {
      while (counter != 0)
      {
        bytes_to_transfer = (counter <= c -> size - c -> level) ?
          counter : c -> size - c -> level;
     60c:	e0625005 	rsb	r5, r2, r5
    }
    else
    {
      while (counter != 0)
      {
        bytes_to_transfer = (counter <= c -> size - c -> level) ?
     610:	e1560005 	cmp	r6, r5
     614:	b1a05006 	movlt	r5, r6
          counter : c -> size - c -> level;

        memcpy ((void *)(c -> data + c -> position),
     618:	e0800003 	add	r0, r0, r3
     61c:	e1a02005 	mov	r2, r5
     620:	eb005fea 	bl	185d0 <memcpy>
            (void *)((char *)data + position_in_data),
            bytes_to_transfer);

        c -> position += bytes_to_transfer;
     624:	e2841008 	add	r1, r4, #8
     628:	e891000e 	ldm	r1, {r1, r2, r3}
        c -> level += bytes_to_transfer;
     62c:	e0852002 	add	r2, r5, r2

        memcpy ((void *)(c -> data + c -> position),
            (void *)((char *)data + position_in_data),
            bytes_to_transfer);

        c -> position += bytes_to_transfer;
     630:	e0853003 	add	r3, r5, r3
        c -> level += bytes_to_transfer;

        position_in_data += bytes_to_transfer;
        counter -= bytes_to_transfer;

        if (c -> level == c -> size)
     634:	e1520001 	cmp	r2, r1

        c -> position += bytes_to_transfer;
        c -> level += bytes_to_transfer;

        position_in_data += bytes_to_transfer;
        counter -= bytes_to_transfer;
     638:	e0656006 	rsb	r6, r5, r6
            bytes_to_transfer);

        c -> position += bytes_to_transfer;
        c -> level += bytes_to_transfer;

        position_in_data += bytes_to_transfer;
     63c:	e0877005 	add	r7, r7, r5
        memcpy ((void *)(c -> data + c -> position),
            (void *)((char *)data + position_in_data),
            bytes_to_transfer);

        c -> position += bytes_to_transfer;
        c -> level += bytes_to_transfer;
     640:	e584200c 	str	r2, [r4, #12]

        memcpy ((void *)(c -> data + c -> position),
            (void *)((char *)data + position_in_data),
            bytes_to_transfer);

        c -> position += bytes_to_transfer;
     644:	e5843010 	str	r3, [r4, #16]
        c -> level += bytes_to_transfer;

        position_in_data += bytes_to_transfer;
        counter -= bytes_to_transfer;

        if (c -> level == c -> size)
     648:	1affffea 	bne	5f8 <kpn_channel_write+0x38>
        {
          res = write (c -> fd, c -> data, c -> size);
     64c:	e1d400f4 	ldrsh	r0, [r4, #4]
     650:	e5941014 	ldr	r1, [r4, #20]
     654:	eb007b45 	bl	1f370 <write>
          ensure (res != -1, KPN_ERROR);
     658:	e3700001 	cmn	r0, #1
     65c:	0a000007 	beq	680 <kpn_channel_write+0xc0>

          c -> level = 0;
          c -> position = 0;
     660:	e3a03000 	mov	r3, #0
      res = write (c -> fd, data, size);
      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     664:	e3560000 	cmp	r6, #0
        {
          res = write (c -> fd, c -> data, c -> size);
          ensure (res != -1, KPN_ERROR);

          c -> level = 0;
          c -> position = 0;
     668:	e1a02003 	mov	r2, r3
        if (c -> level == c -> size)
        {
          res = write (c -> fd, c -> data, c -> size);
          ensure (res != -1, KPN_ERROR);

          c -> level = 0;
     66c:	e584900c 	str	r9, [r4, #12]
          c -> position = 0;
     670:	e5849010 	str	r9, [r4, #16]
      res = write (c -> fd, data, size);
      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     674:	1affffe1 	bne	600 <kpn_channel_write+0x40>
          c -> position = 0;
        }
      }
    }

    return KPN_OK;
     678:	e3a00000 	mov	r0, #0
     67c:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
        counter -= bytes_to_transfer;

        if (c -> level == c -> size)
        {
          res = write (c -> fd, c -> data, c -> size);
          ensure (res != -1, KPN_ERROR);
     680:	e3a00001 	mov	r0, #1
      }
    }

    return KPN_OK;
  }
}
     684:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

  watch (kpn_status_t)
  {
    if (c -> data == NULL)
    {
      res = write (c -> fd, data, size);
     688:	e1d400f4 	ldrsh	r0, [r4, #4]
     68c:	eb007b37 	bl	1f370 <write>
      ensure (res != -1, KPN_ERROR);
     690:	e3700001 	cmn	r0, #1
     694:	13a00000 	movne	r0, #0
     698:	03a00001 	moveq	r0, #1
     69c:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

000006a0 <kpn_channel_read>:

#include <DnaTools/DnaTools.h>
#include <KahnProcessNetwork/KahnProcessNetwork.h>

kpn_status_t kpn_channel_read (kpn_channel_t c, void * data, int32_t size)
{
     6a0:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
     6a4:	e1a04000 	mov	r4, r0
  int32_t counter = size, res = 0, position_in_data = 0;
  int32_t bytes_to_transfer = 0;

  watch (kpn_status_t)
  {
    if (c -> data == NULL)
     6a8:	e5900014 	ldr	r0, [r0, #20]
     6ac:	e3500000 	cmp	r0, #0
     6b0:	0a00002b 	beq	764 <kpn_channel_read+0xc4>
      res = read (c -> fd, data, size);
      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     6b4:	e3520000 	cmp	r2, #0
     6b8:	e1a06002 	mov	r6, r2
     6bc:	0a000024 	beq	754 <kpn_channel_read+0xb4>
     6c0:	e3a07000 	mov	r7, #0
     6c4:	e1a08001 	mov	r8, r1
        { 
          res = read (c -> fd, c -> data, c -> size);
          ensure (res != -1, KPN_ERROR);

          c -> level = c -> size;
          c -> position = 0;
     6c8:	e1a09007 	mov	r9, r7
     6cc:	e594300c 	ldr	r3, [r4, #12]
     6d0:	ea000011 	b	71c <kpn_channel_read+0x7c>
     6d4:	e5941010 	ldr	r1, [r4, #16]
        }

        bytes_to_transfer = (counter <= c -> level) ?
     6d8:	e1530006 	cmp	r3, r6
     6dc:	b1a05003 	movlt	r5, r3
     6e0:	a1a05006 	movge	r5, r6
          counter : c -> level;

        memcpy ((void *)((char *)data + position_in_data),
     6e4:	e0801001 	add	r1, r0, r1
     6e8:	e1a02005 	mov	r2, r5
     6ec:	e0880007 	add	r0, r8, r7
     6f0:	eb005fb6 	bl	185d0 <memcpy>
            (void *)(c -> data + c -> position),
            bytes_to_transfer);

        position_in_data += bytes_to_transfer;
        c -> position += bytes_to_transfer;
     6f4:	e5942010 	ldr	r2, [r4, #16]

        c -> level -= bytes_to_transfer;
     6f8:	e594300c 	ldr	r3, [r4, #12]
        memcpy ((void *)((char *)data + position_in_data),
            (void *)(c -> data + c -> position),
            bytes_to_transfer);

        position_in_data += bytes_to_transfer;
        c -> position += bytes_to_transfer;
     6fc:	e0822005 	add	r2, r2, r5

        c -> level -= bytes_to_transfer;
     700:	e0653003 	rsb	r3, r5, r3
      res = read (c -> fd, data, size);
      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     704:	e0566005 	subs	r6, r6, r5

        memcpy ((void *)((char *)data + position_in_data),
            (void *)(c -> data + c -> position),
            bytes_to_transfer);

        position_in_data += bytes_to_transfer;
     708:	e0877005 	add	r7, r7, r5
        c -> position += bytes_to_transfer;
     70c:	e5842010 	str	r2, [r4, #16]

        c -> level -= bytes_to_transfer;
     710:	e584300c 	str	r3, [r4, #12]
      res = read (c -> fd, data, size);
      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     714:	0a00000e 	beq	754 <kpn_channel_read+0xb4>
     718:	e5940014 	ldr	r0, [r4, #20]
      {
        if (c -> level == 0)
     71c:	e3530000 	cmp	r3, #0
     720:	1affffeb 	bne	6d4 <kpn_channel_read+0x34>
        { 
          res = read (c -> fd, c -> data, c -> size);
     724:	e1a01000 	mov	r1, r0
     728:	e5942008 	ldr	r2, [r4, #8]
     72c:	e1d400f4 	ldrsh	r0, [r4, #4]
     730:	eb006183 	bl	18d44 <read>
          ensure (res != -1, KPN_ERROR);
     734:	e3700001 	cmn	r0, #1
     738:	0a000007 	beq	75c <kpn_channel_read+0xbc>

          c -> level = c -> size;
     73c:	e5943008 	ldr	r3, [r4, #8]
          c -> position = 0;
     740:	e3a01000 	mov	r1, #0
     744:	e5940014 	ldr	r0, [r4, #20]
     748:	e5849010 	str	r9, [r4, #16]
        if (c -> level == 0)
        { 
          res = read (c -> fd, c -> data, c -> size);
          ensure (res != -1, KPN_ERROR);

          c -> level = c -> size;
     74c:	e584300c 	str	r3, [r4, #12]
     750:	eaffffe0 	b	6d8 <kpn_channel_read+0x38>
        c -> level -= bytes_to_transfer;
        counter -= bytes_to_transfer;
      }
    }

    return KPN_OK;
     754:	e3a00000 	mov	r0, #0
     758:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
      while (counter != 0)
      {
        if (c -> level == 0)
        { 
          res = read (c -> fd, c -> data, c -> size);
          ensure (res != -1, KPN_ERROR);
     75c:	e3a00001 	mov	r0, #1
      }
    }

    return KPN_OK;
  }
}
     760:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

  watch (kpn_status_t)
  {
    if (c -> data == NULL)
    {
      res = read (c -> fd, data, size);
     764:	e1d400f4 	ldrsh	r0, [r4, #4]
     768:	eb006175 	bl	18d44 <read>
      ensure (res != -1, KPN_ERROR);
     76c:	e3700001 	cmn	r0, #1
     770:	13a00000 	movne	r0, #0
     774:	03a00001 	moveq	r0, #1
     778:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

0000077c <pthread_barrier_init>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count)
{
  ASSERT_RETURN(!count,EINVAL);
     77c:	e3520000 	cmp	r2, #0
     780:	0a000005 	beq	79c <pthread_barrier_init+0x20>
     784:	e1a03000 	mov	r3, r0

  barrier -> count = 0;
     788:	e3a01000 	mov	r1, #0
     78c:	e5831004 	str	r1, [r3, #4]
  barrier -> threshold = count;

  return 0;
     790:	e1a00001 	mov	r0, r1
int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count)
{
  ASSERT_RETURN(!count,EINVAL);

  barrier -> count = 0;
  barrier -> threshold = count;
     794:	e5832000 	str	r2, [r3]

  return 0;
     798:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count)
{
     79c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!count,EINVAL);
     7a0:	e59f3024 	ldr	r3, [pc, #36]	; 7cc <pthread_barrier_init+0x50>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count)
{
     7a4:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!count,EINVAL);
     7a8:	e58d3000 	str	r3, [sp]
     7ac:	e59f101c 	ldr	r1, [pc, #28]	; 7d0 <pthread_barrier_init+0x54>
     7b0:	e59f201c 	ldr	r2, [pc, #28]	; 7d4 <pthread_barrier_init+0x58>
     7b4:	e59f301c 	ldr	r3, [pc, #28]	; 7d8 <pthread_barrier_init+0x5c>
     7b8:	e59f001c 	ldr	r0, [pc, #28]	; 7dc <pthread_barrier_init+0x60>
     7bc:	eb0060a4 	bl	18a54 <printf>
     7c0:	e3a00016 	mov	r0, #22

  barrier -> count = 0;
  barrier -> threshold = count;

  return 0;
}
     7c4:	e28dd00c 	add	sp, sp, #12
     7c8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     7cc:	00031a50 	.word	0x00031a50
     7d0:	000319d4 	.word	0x000319d4
     7d4:	00031990 	.word	0x00031990
     7d8:	00031a48 	.word	0x00031a48
     7dc:	000319a8 	.word	0x000319a8

000007e0 <pthread_cond_destroy>:
#include <Private/PosixThreads.h>

int pthread_cond_destroy(pthread_cond_t *cond)
{
     7e0:	e92d4008 	push	{r3, lr}
  semaphore_destroy (cond -> semaphore);
     7e4:	e5900000 	ldr	r0, [r0]
     7e8:	eb0040f0 	bl	10bb0 <semaphore_destroy>
  return 0;
}
     7ec:	e3a00000 	mov	r0, #0
     7f0:	e8bd8008 	pop	{r3, pc}

000007f4 <pthread_mutex_lock>:
#include <Private/PosixThreads.h>

int pthread_mutex_lock(pthread_mutex_t *mutex)
{
     7f4:	e92d4010 	push	{r4, lr}
     7f8:	e1a04000 	mov	r4, r0
  status_t status = DNA_OK;

  if (mutex -> lock == -1)
     7fc:	e5900008 	ldr	r0, [r0, #8]
#include <Private/PosixThreads.h>

int pthread_mutex_lock(pthread_mutex_t *mutex)
{
     800:	e24dd008 	sub	sp, sp, #8
  status_t status = DNA_OK;

  if (mutex -> lock == -1)
     804:	e3700001 	cmn	r0, #1
     808:	0a000009 	beq	834 <pthread_mutex_lock+0x40>
  {
    status = semaphore_create ("pthread_mutex", 1, & mutex -> lock);
    if (status != DNA_OK) return EINVAL;
  }

  semaphore_acquire (mutex -> lock, 1, 0, 0);
     80c:	e3a03000 	mov	r3, #0
     810:	e3a02000 	mov	r2, #0
     814:	e3a01001 	mov	r1, #1
     818:	e1cd20f0 	strd	r2, [sp]
     81c:	eb0045ce 	bl	11f5c <semaphore_acquire>

  mutex -> status = MUTEX_LOCKED;
     820:	e3a03001 	mov	r3, #1
  return 0;
     824:	e3a00000 	mov	r0, #0
    if (status != DNA_OK) return EINVAL;
  }

  semaphore_acquire (mutex -> lock, 1, 0, 0);

  mutex -> status = MUTEX_LOCKED;
     828:	e5843004 	str	r3, [r4, #4]
  return 0;
}
     82c:	e28dd008 	add	sp, sp, #8
     830:	e8bd8010 	pop	{r4, pc}
{
  status_t status = DNA_OK;

  if (mutex -> lock == -1)
  {
    status = semaphore_create ("pthread_mutex", 1, & mutex -> lock);
     834:	e59f001c 	ldr	r0, [pc, #28]	; 858 <pthread_mutex_lock+0x64>
     838:	e3a01001 	mov	r1, #1
     83c:	e2842008 	add	r2, r4, #8
     840:	eb0049e6 	bl	12fe0 <semaphore_create>
    if (status != DNA_OK) return EINVAL;
     844:	e3500000 	cmp	r0, #0
     848:	13a00016 	movne	r0, #22
     84c:	1afffff6 	bne	82c <pthread_mutex_lock+0x38>
     850:	e5940008 	ldr	r0, [r4, #8]
     854:	eaffffec 	b	80c <pthread_mutex_lock+0x18>
     858:	00031a58 	.word	0x00031a58

0000085c <pthread_attr_getschedparam>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getschedparam(const pthread_attr_t *attr, sched_param_t *param)
{
  ASSERT_RETURN (! attr || ! param, EINVAL);
     85c:	e3510000 	cmp	r1, #0
     860:	13500000 	cmpne	r0, #0
     864:	03a02001 	moveq	r2, #1
     868:	13a02000 	movne	r2, #0
     86c:	1a00000b 	bne	8a0 <pthread_attr_getschedparam+0x44>
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getschedparam(const pthread_attr_t *attr, sched_param_t *param)
{
     870:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN (! attr || ! param, EINVAL);
     874:	e59f3048 	ldr	r3, [pc, #72]	; 8c4 <pthread_attr_getschedparam+0x68>
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getschedparam(const pthread_attr_t *attr, sched_param_t *param)
{
     878:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN (! attr || ! param, EINVAL);
     87c:	e58d3000 	str	r3, [sp]
     880:	e59f1040 	ldr	r1, [pc, #64]	; 8c8 <pthread_attr_getschedparam+0x6c>
     884:	e59f2040 	ldr	r2, [pc, #64]	; 8cc <pthread_attr_getschedparam+0x70>
     888:	e59f3040 	ldr	r3, [pc, #64]	; 8d0 <pthread_attr_getschedparam+0x74>
     88c:	e59f0040 	ldr	r0, [pc, #64]	; 8d4 <pthread_attr_getschedparam+0x78>
     890:	eb00606f 	bl	18a54 <printf>
     894:	e3a00016 	mov	r0, #22

  memcpy(param, & attr -> schedparam, sizeof (*param));
  return 0;
}
     898:	e28dd00c 	add	sp, sp, #12
     89c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

int pthread_attr_getschedparam(const pthread_attr_t *attr, sched_param_t *param)
{
  ASSERT_RETURN (! attr || ! param, EINVAL);

  memcpy(param, & attr -> schedparam, sizeof (*param));
     8a0:	e1a03000 	mov	r3, r0
     8a4:	e5b3c018 	ldr	ip, [r3, #24]!
  return 0;
     8a8:	e1a00002 	mov	r0, r2

int pthread_attr_getschedparam(const pthread_attr_t *attr, sched_param_t *param)
{
  ASSERT_RETURN (! attr || ! param, EINVAL);

  memcpy(param, & attr -> schedparam, sizeof (*param));
     8ac:	e5932004 	ldr	r2, [r3, #4]
     8b0:	e5933008 	ldr	r3, [r3, #8]
     8b4:	e581c000 	str	ip, [r1]
     8b8:	e5812004 	str	r2, [r1, #4]
     8bc:	e5813008 	str	r3, [r1, #8]
  return 0;
     8c0:	e12fff1e 	bx	lr
     8c4:	00031a50 	.word	0x00031a50
     8c8:	00031a84 	.word	0x00031a84
     8cc:	00031a68 	.word	0x00031a68
     8d0:	00031afc 	.word	0x00031afc
     8d4:	000319a8 	.word	0x000319a8

000008d8 <pthread_cond_broadcast>:

int pthread_cond_broadcast(pthread_cond_t *condition)
{
  status_t status = DNA_OK;

  if (condition -> count > 0)
     8d8:	e5901004 	ldr	r1, [r0, #4]
     8dc:	e3510000 	cmp	r1, #0
     8e0:	da000008 	ble	908 <pthread_cond_broadcast+0x30>
#include <Private/PosixThreads.h>

int pthread_cond_broadcast(pthread_cond_t *condition)
{
     8e4:	e92d4008 	push	{r3, lr}
  status_t status = DNA_OK;

  if (condition -> count > 0)
  {
    status = semaphore_release (condition -> semaphore,
     8e8:	e3a02000 	mov	r2, #0
     8ec:	e5900000 	ldr	r0, [r0]
     8f0:	eb004a5d 	bl	1326c <semaphore_release>
        condition -> count, 0);
    if (status == DNA_BAD_SEM_ID) return EINVAL;
     8f4:	e59f3014 	ldr	r3, [pc, #20]	; 910 <pthread_cond_broadcast+0x38>
  }

  return 0;
     8f8:	e1500003 	cmp	r0, r3
     8fc:	03a00016 	moveq	r0, #22
     900:	13a00000 	movne	r0, #0
     904:	e8bd8008 	pop	{r3, pc}
     908:	e3a00000 	mov	r0, #0
     90c:	e12fff1e 	bx	lr
     910:	0000fdff 	.word	0x0000fdff

00000914 <pthread_attr_getinheritsched>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *h)
{
  ASSERT_RETURN(!attr || !h,EINVAL);
     914:	e3510000 	cmp	r1, #0
     918:	13500000 	cmpne	r0, #0
     91c:	e1a03000 	mov	r3, r0
     920:	03a00001 	moveq	r0, #1
     924:	13a00000 	movne	r0, #0
     928:	0a000002 	beq	938 <pthread_attr_getinheritsched+0x24>

  *h = attr -> schedinherited;
     92c:	e593300c 	ldr	r3, [r3, #12]
     930:	e5813000 	str	r3, [r1]
  return 0;
     934:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *h)
{
     938:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!attr || !h,EINVAL);
     93c:	e59f3024 	ldr	r3, [pc, #36]	; 968 <pthread_attr_getinheritsched+0x54>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *h)
{
     940:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!attr || !h,EINVAL);
     944:	e58d3000 	str	r3, [sp]
     948:	e59f101c 	ldr	r1, [pc, #28]	; 96c <pthread_attr_getinheritsched+0x58>
     94c:	e59f201c 	ldr	r2, [pc, #28]	; 970 <pthread_attr_getinheritsched+0x5c>
     950:	e59f301c 	ldr	r3, [pc, #28]	; 974 <pthread_attr_getinheritsched+0x60>
     954:	e59f001c 	ldr	r0, [pc, #28]	; 978 <pthread_attr_getinheritsched+0x64>
     958:	eb00603d 	bl	18a54 <printf>
     95c:	e3a00016 	mov	r0, #22

  *h = attr -> schedinherited;
  return 0;
}
     960:	e28dd00c 	add	sp, sp, #12
     964:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     968:	00031a50 	.word	0x00031a50
     96c:	00031b30 	.word	0x00031b30
     970:	00031b10 	.word	0x00031b10
     974:	00031bac 	.word	0x00031bac
     978:	000319a8 	.word	0x000319a8

0000097c <pthread_attr_getstacksize>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *size)
{
  ASSERT_RETURN(!attr || !size,EINVAL);
     97c:	e3510000 	cmp	r1, #0
     980:	13500000 	cmpne	r0, #0
     984:	e1a03000 	mov	r3, r0
     988:	03a00001 	moveq	r0, #1
     98c:	13a00000 	movne	r0, #0
     990:	0a000002 	beq	9a0 <pthread_attr_getstacksize+0x24>

  *size = attr->stacksize;
     994:	e5933004 	ldr	r3, [r3, #4]
     998:	e5813000 	str	r3, [r1]
  return 0;
     99c:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *size)
{
     9a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!attr || !size,EINVAL);
     9a4:	e59f3024 	ldr	r3, [pc, #36]	; 9d0 <pthread_attr_getstacksize+0x54>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *size)
{
     9a8:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!attr || !size,EINVAL);
     9ac:	e58d3000 	str	r3, [sp]
     9b0:	e59f101c 	ldr	r1, [pc, #28]	; 9d4 <pthread_attr_getstacksize+0x58>
     9b4:	e59f201c 	ldr	r2, [pc, #28]	; 9d8 <pthread_attr_getstacksize+0x5c>
     9b8:	e59f301c 	ldr	r3, [pc, #28]	; 9dc <pthread_attr_getstacksize+0x60>
     9bc:	e59f001c 	ldr	r0, [pc, #28]	; 9e0 <pthread_attr_getstacksize+0x64>
     9c0:	eb006023 	bl	18a54 <printf>
     9c4:	e3a00016 	mov	r0, #22

  *size = attr->stacksize;
  return 0;
}
     9c8:	e28dd00c 	add	sp, sp, #12
     9cc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     9d0:	00031a50 	.word	0x00031a50
     9d4:	00031bd4 	.word	0x00031bd4
     9d8:	00031bb8 	.word	0x00031bb8
     9dc:	00031c4c 	.word	0x00031c4c
     9e0:	000319a8 	.word	0x000319a8

000009e4 <pthread_cancel>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_cancel(pthread_t thread)
{
     9e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN (thread == NULL, ESRCH);
     9e8:	e2503000 	subs	r3, r0, #0
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_cancel(pthread_t thread)
{
     9ec:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN (thread == NULL, ESRCH);
     9f0:	0a000021 	beq	a7c <pthread_cancel+0x98>
  ASSERT_RETURN (thread -> cancel_state != PTHREAD_CANCEL_DISABLE
     9f4:	e5d30019 	ldrb	r0, [r3, #25]
     9f8:	e3500001 	cmp	r0, #1
     9fc:	9a000009 	bls	a28 <pthread_cancel+0x44>
     a00:	e59f309c 	ldr	r3, [pc, #156]	; aa4 <pthread_cancel+0xc0>
     a04:	e59f009c 	ldr	r0, [pc, #156]	; aa8 <pthread_cancel+0xc4>
     a08:	e58d3000 	str	r3, [sp]
     a0c:	e59f1098 	ldr	r1, [pc, #152]	; aac <pthread_cancel+0xc8>
     a10:	e59f2098 	ldr	r2, [pc, #152]	; ab0 <pthread_cancel+0xcc>
     a14:	e59f3098 	ldr	r3, [pc, #152]	; ab4 <pthread_cancel+0xd0>
     a18:	eb00600d 	bl	18a54 <printf>
     a1c:	e3a00016 	mov	r0, #22
  }

  // FIXME : Not implemented. We need to decide
  // wether if cancel means exit or smtgh else
  return 0;
}
     a20:	e28dd00c 	add	sp, sp, #12
     a24:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
{
  ASSERT_RETURN (thread == NULL, ESRCH);
  ASSERT_RETURN (thread -> cancel_state != PTHREAD_CANCEL_DISABLE
      && thread -> cancel_state != PTHREAD_CANCEL_ENABLE, EINVAL);

  ASSERT_RETURN (thread -> cancel_type != PTHREAD_CANCEL_DEFERRED
     a28:	e5d32018 	ldrb	r2, [r3, #24]
     a2c:	e3520001 	cmp	r2, #1
     a30:	9a000009 	bls	a5c <pthread_cancel+0x78>
     a34:	e59f3068 	ldr	r3, [pc, #104]	; aa4 <pthread_cancel+0xc0>
     a38:	e59f106c 	ldr	r1, [pc, #108]	; aac <pthread_cancel+0xc8>
     a3c:	e58d3000 	str	r3, [sp]
     a40:	e59f2068 	ldr	r2, [pc, #104]	; ab0 <pthread_cancel+0xcc>
     a44:	e59f306c 	ldr	r3, [pc, #108]	; ab8 <pthread_cancel+0xd4>
     a48:	e59f0058 	ldr	r0, [pc, #88]	; aa8 <pthread_cancel+0xc4>
     a4c:	eb006000 	bl	18a54 <printf>
     a50:	e3a00016 	mov	r0, #22
  }

  // FIXME : Not implemented. We need to decide
  // wether if cancel means exit or smtgh else
  return 0;
}
     a54:	e28dd00c 	add	sp, sp, #12
     a58:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
      && thread -> cancel_state != PTHREAD_CANCEL_ENABLE, EINVAL);

  ASSERT_RETURN (thread -> cancel_type != PTHREAD_CANCEL_DEFERRED
      && thread -> cancel_type != PTHREAD_CANCEL_ASYNCHRONOUS, EINVAL);

  if (thread -> cancel_state == PTHREAD_CANCEL_DISABLE) return 0;
     a5c:	e3500000 	cmp	r0, #0
     a60:	0affffee 	beq	a20 <pthread_cancel+0x3c>
  if (thread -> cancel_type == PTHREAD_CANCEL_DEFERRED) {
     a64:	e3520000 	cmp	r2, #0
    thread -> cancel_bool = true;
     a68:	03a01001 	moveq	r1, #1
    return 0;
     a6c:	01a00002 	moveq	r0, r2
  ASSERT_RETURN (thread -> cancel_type != PTHREAD_CANCEL_DEFERRED
      && thread -> cancel_type != PTHREAD_CANCEL_ASYNCHRONOUS, EINVAL);

  if (thread -> cancel_state == PTHREAD_CANCEL_DISABLE) return 0;
  if (thread -> cancel_type == PTHREAD_CANCEL_DEFERRED) {
    thread -> cancel_bool = true;
     a70:	05c3101a 	strbeq	r1, [r3, #26]
      && thread -> cancel_state != PTHREAD_CANCEL_ENABLE, EINVAL);

  ASSERT_RETURN (thread -> cancel_type != PTHREAD_CANCEL_DEFERRED
      && thread -> cancel_type != PTHREAD_CANCEL_ASYNCHRONOUS, EINVAL);

  if (thread -> cancel_state == PTHREAD_CANCEL_DISABLE) return 0;
     a74:	13a00000 	movne	r0, #0
     a78:	eaffffe8 	b	a20 <pthread_cancel+0x3c>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_cancel(pthread_t thread)
{
  ASSERT_RETURN (thread == NULL, ESRCH);
     a7c:	e59f3038 	ldr	r3, [pc, #56]	; abc <pthread_cancel+0xd8>
     a80:	e59f1024 	ldr	r1, [pc, #36]	; aac <pthread_cancel+0xc8>
     a84:	e58d3000 	str	r3, [sp]
     a88:	e59f2020 	ldr	r2, [pc, #32]	; ab0 <pthread_cancel+0xcc>
     a8c:	e59f302c 	ldr	r3, [pc, #44]	; ac0 <pthread_cancel+0xdc>
     a90:	e59f0010 	ldr	r0, [pc, #16]	; aa8 <pthread_cancel+0xc4>
     a94:	eb005fee 	bl	18a54 <printf>
     a98:	e3a00003 	mov	r0, #3
  }

  // FIXME : Not implemented. We need to decide
  // wether if cancel means exit or smtgh else
  return 0;
}
     a9c:	e28dd00c 	add	sp, sp, #12
     aa0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     aa4:	00031a50 	.word	0x00031a50
     aa8:	000319a8 	.word	0x000319a8
     aac:	00031c6c 	.word	0x00031c6c
     ab0:	00031c5c 	.word	0x00031c5c
     ab4:	00031cf0 	.word	0x00031cf0
     ab8:	00031d54 	.word	0x00031d54
     abc:	00031ce8 	.word	0x00031ce8
     ac0:	00031cd8 	.word	0x00031cd8

00000ac4 <pthread_attr_init>:
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_init(pthread_attr_t *attr)
{
     ac4:	e92d4010 	push	{r4, lr}
  ASSERT_RETURN(!attr,EINVAL);
     ac8:	e2504000 	subs	r4, r0, #0
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_init(pthread_attr_t *attr)
{
     acc:	e24dd008 	sub	sp, sp, #8
  ASSERT_RETURN(!attr,EINVAL);
     ad0:	0a00000c 	beq	b08 <pthread_attr_init+0x44>

  memset(attr, 0, sizeof(*attr));
     ad4:	e3a01000 	mov	r1, #0
     ad8:	e3a02028 	mov	r2, #40	; 0x28
     adc:	eb005f25 	bl	18778 <memset>

  attr->detachstate    = PTHREAD_CREATE_JOINABLE;
     ae0:	e3a02000 	mov	r2, #0
  attr->schedpolicy    = SCHED_FIFO;
     ae4:	e3a03001 	mov	r3, #1
  attr->schedinherited = PTHREAD_EXPLICIT_SCHED;
  attr->procid         = PTHREAD_NOPROCID;
     ae8:	e3e01000 	mvn	r1, #0

  return 0;
     aec:	e1a00002 	mov	r0, r2
{
  ASSERT_RETURN(!attr,EINVAL);

  memset(attr, 0, sizeof(*attr));

  attr->detachstate    = PTHREAD_CREATE_JOINABLE;
     af0:	e5842008 	str	r2, [r4, #8]
  attr->schedpolicy    = SCHED_FIFO;
     af4:	e5843010 	str	r3, [r4, #16]
  attr->schedinherited = PTHREAD_EXPLICIT_SCHED;
     af8:	e584300c 	str	r3, [r4, #12]
  attr->procid         = PTHREAD_NOPROCID;
     afc:	e5841014 	str	r1, [r4, #20]

  return 0;
}
     b00:	e28dd008 	add	sp, sp, #8
     b04:	e8bd8010 	pop	{r4, pc}
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_init(pthread_attr_t *attr)
{
  ASSERT_RETURN(!attr,EINVAL);
     b08:	e59f3020 	ldr	r3, [pc, #32]	; b30 <pthread_attr_init+0x6c>
     b0c:	e59f1020 	ldr	r1, [pc, #32]	; b34 <pthread_attr_init+0x70>
     b10:	e58d3000 	str	r3, [sp]
     b14:	e59f201c 	ldr	r2, [pc, #28]	; b38 <pthread_attr_init+0x74>
     b18:	e59f301c 	ldr	r3, [pc, #28]	; b3c <pthread_attr_init+0x78>
     b1c:	e59f001c 	ldr	r0, [pc, #28]	; b40 <pthread_attr_init+0x7c>
     b20:	eb005fcb 	bl	18a54 <printf>
     b24:	e3a00016 	mov	r0, #22
  attr->schedpolicy    = SCHED_FIFO;
  attr->schedinherited = PTHREAD_EXPLICIT_SCHED;
  attr->procid         = PTHREAD_NOPROCID;

  return 0;
}
     b28:	e28dd008 	add	sp, sp, #8
     b2c:	e8bd8010 	pop	{r4, pc}
     b30:	00031a50 	.word	0x00031a50
     b34:	00031dd4 	.word	0x00031dd4
     b38:	00031dc0 	.word	0x00031dc0
     b3c:	00031e44 	.word	0x00031e44
     b40:	000319a8 	.word	0x000319a8

00000b44 <pthread_setcanceltype>:
  if (oldtype != NULL) *oldtype = self -> cancel_type;
  self -> cancel_type = type;
#endif

  return 0;
}
     b44:	e3a00000 	mov	r0, #0
     b48:	e12fff1e 	bx	lr

00000b4c <pthread_lock_acquire>:

int pthread_lock_acquire(pthread_spinlock_t *spin)
{

  return 0;
}
     b4c:	e3a00000 	mov	r0, #0
     b50:	e12fff1e 	bx	lr

00000b54 <pthread_mutex_destroy>:
#include <Private/PosixThreads.h>

int pthread_mutex_destroy(pthread_mutex_t *mutex)
{
     b54:	e92d4008 	push	{r3, lr}
  semaphore_destroy (mutex -> lock);
     b58:	e5900008 	ldr	r0, [r0, #8]
     b5c:	eb004013 	bl	10bb0 <semaphore_destroy>
  return 0;
}
     b60:	e3a00000 	mov	r0, #0
     b64:	e8bd8008 	pop	{r3, pc}

00000b68 <pthread_attr_setdetachstate>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setdetachstate(pthread_attr_t *attr, int state)
{
  ASSERT_RETURN(!attr,EINVAL);
     b68:	e2503000 	subs	r3, r0, #0
     b6c:	0a000002 	beq	b7c <pthread_attr_setdetachstate+0x14>

  attr->detachstate = state;
  return 0;
     b70:	e3a00000 	mov	r0, #0

int pthread_attr_setdetachstate(pthread_attr_t *attr, int state)
{
  ASSERT_RETURN(!attr,EINVAL);

  attr->detachstate = state;
     b74:	e5831008 	str	r1, [r3, #8]
  return 0;
     b78:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setdetachstate(pthread_attr_t *attr, int state)
{
     b7c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!attr,EINVAL);
     b80:	e59f3024 	ldr	r3, [pc, #36]	; bac <pthread_attr_setdetachstate+0x44>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setdetachstate(pthread_attr_t *attr, int state)
{
     b84:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!attr,EINVAL);
     b88:	e58d3000 	str	r3, [sp]
     b8c:	e59f101c 	ldr	r1, [pc, #28]	; bb0 <pthread_attr_setdetachstate+0x48>
     b90:	e59f201c 	ldr	r2, [pc, #28]	; bb4 <pthread_attr_setdetachstate+0x4c>
     b94:	e59f301c 	ldr	r3, [pc, #28]	; bb8 <pthread_attr_setdetachstate+0x50>
     b98:	e59f001c 	ldr	r0, [pc, #28]	; bbc <pthread_attr_setdetachstate+0x54>
     b9c:	eb005fac 	bl	18a54 <printf>
     ba0:	e3a00016 	mov	r0, #22

  attr->detachstate = state;
  return 0;
}
     ba4:	e28dd00c 	add	sp, sp, #12
     ba8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     bac:	00031a50 	.word	0x00031a50
     bb0:	00031e68 	.word	0x00031e68
     bb4:	00031e4c 	.word	0x00031e4c
     bb8:	00031e44 	.word	0x00031e44
     bbc:	000319a8 	.word	0x000319a8

00000bc0 <pthread_create>:
#include <stdio.h>
#include <string.h>

int pthread_create (pthread_t *thread, pthread_attr_t *attr,
    pthread_func_t start, void *arg)
{
     bc0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  pthread_t new;
  char * default_name = "pthread";
  void * stack_base;
  thread_info_t thread_info;

  ASSERT_RETURN( (thread == NULL), EINVAL );
     bc4:	e2508000 	subs	r8, r0, #0
#include <stdio.h>
#include <string.h>

int pthread_create (pthread_t *thread, pthread_attr_t *attr,
    pthread_func_t start, void *arg)
{
     bc8:	e24dd0b4 	sub	sp, sp, #180	; 0xb4
  pthread_t new;
  char * default_name = "pthread";
  void * stack_base;
  thread_info_t thread_info;

  ASSERT_RETURN( (thread == NULL), EINVAL );
     bcc:	0a00005d 	beq	d48 <pthread_create+0x188>

  new = malloc (sizeof(struct pthread));
     bd0:	e3a00020 	mov	r0, #32
     bd4:	e1a04001 	mov	r4, r1
     bd8:	e1a0a002 	mov	sl, r2
     bdc:	e1a09003 	mov	r9, r3
     be0:	eb005aa7 	bl	17684 <malloc>
  ASSERT_RETURN (!new, ENOMEM);
     be4:	e2506000 	subs	r6, r0, #0
     be8:	0a000069 	beq	d94 <pthread_create+0x1d4>

  new -> attributs = malloc (sizeof (pthread_attr_t));
     bec:	e3a00028 	mov	r0, #40	; 0x28
     bf0:	eb005aa3 	bl	17684 <malloc>
  ASSERT_RETURN(!new->attributs, ENOMEM);
     bf4:	e3500000 	cmp	r0, #0
  ASSERT_RETURN( (thread == NULL), EINVAL );

  new = malloc (sizeof(struct pthread));
  ASSERT_RETURN (!new, ENOMEM);

  new -> attributs = malloc (sizeof (pthread_attr_t));
     bf8:	e1a05000 	mov	r5, r0
     bfc:	e5860008 	str	r0, [r6, #8]
  ASSERT_RETURN(!new->attributs, ENOMEM);
     c00:	0a00005a 	beq	d70 <pthread_create+0x1b0>

  new -> father = NULL;
     c04:	e3a03000 	mov	r3, #0
  new -> children = 0;
  new -> cancel_type = PTHREAD_CANCEL_ASYNCHRONOUS;
     c08:	e3a02001 	mov	r2, #1
  new -> cancel_state = PTHREAD_CANCEL_ENABLE;
  new -> cancel_bool = false;

  if (attr == NULL)
     c0c:	e1540003 	cmp	r4, r3
  ASSERT_RETURN (!new, ENOMEM);

  new -> attributs = malloc (sizeof (pthread_attr_t));
  ASSERT_RETURN(!new->attributs, ENOMEM);

  new -> father = NULL;
     c10:	e5863010 	str	r3, [r6, #16]
  new -> children = 0;
     c14:	e5863014 	str	r3, [r6, #20]
  new -> cancel_type = PTHREAD_CANCEL_ASYNCHRONOUS;
  new -> cancel_state = PTHREAD_CANCEL_ENABLE;
  new -> cancel_bool = false;
     c18:	e5c6301a 	strb	r3, [r6, #26]
  new -> attributs = malloc (sizeof (pthread_attr_t));
  ASSERT_RETURN(!new->attributs, ENOMEM);

  new -> father = NULL;
  new -> children = 0;
  new -> cancel_type = PTHREAD_CANCEL_ASYNCHRONOUS;
     c1c:	e5c62018 	strb	r2, [r6, #24]
  new -> cancel_state = PTHREAD_CANCEL_ENABLE;
     c20:	e5c62019 	strb	r2, [r6, #25]
    new -> attributs -> stacksize = 0x8000;
    new -> attributs -> stackaddr = malloc (0x8000);
  }
  else
  {
    memcpy (new -> attributs, attr, sizeof (pthread_attr_t));
     c24:	11a0c004 	movne	ip, r4
     c28:	11a07000 	movne	r7, r0
     c2c:	1284b020 	addne	fp, r4, #32
  new -> children = 0;
  new -> cancel_type = PTHREAD_CANCEL_ASYNCHRONOUS;
  new -> cancel_state = PTHREAD_CANCEL_ENABLE;
  new -> cancel_bool = false;

  if (attr == NULL)
     c30:	0a000061 	beq	dbc <pthread_create+0x1fc>
    new -> attributs -> stacksize = 0x8000;
    new -> attributs -> stackaddr = malloc (0x8000);
  }
  else
  {
    memcpy (new -> attributs, attr, sizeof (pthread_attr_t));
     c34:	e1a0e007 	mov	lr, r7
     c38:	e59c0000 	ldr	r0, [ip]
     c3c:	e59c1004 	ldr	r1, [ip, #4]
     c40:	e59c2008 	ldr	r2, [ip, #8]
     c44:	e59c300c 	ldr	r3, [ip, #12]
     c48:	e28cc010 	add	ip, ip, #16
     c4c:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
     c50:	e15c000b 	cmp	ip, fp
     c54:	e1a0700e 	mov	r7, lr
     c58:	1afffff5 	bne	c34 <pthread_create+0x74>

    if (attr -> name == NULL)
     c5c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
    new -> attributs -> stacksize = 0x8000;
    new -> attributs -> stackaddr = malloc (0x8000);
  }
  else
  {
    memcpy (new -> attributs, attr, sizeof (pthread_attr_t));
     c60:	e59c0000 	ldr	r0, [ip]
     c64:	e59c1004 	ldr	r1, [ip, #4]

    if (attr -> name == NULL)
     c68:	e3530000 	cmp	r3, #0
    new -> attributs -> stacksize = 0x8000;
    new -> attributs -> stackaddr = malloc (0x8000);
  }
  else
  {
    memcpy (new -> attributs, attr, sizeof (pthread_attr_t));
     c6c:	e8a70003 	stmia	r7!, {r0, r1}

    if (attr -> name == NULL)
     c70:	0a000075 	beq	e4c <pthread_create+0x28c>
     {
      new -> attributs -> name = (char *) malloc (32);
      sprintf (new -> attributs -> name, "%s_%ld", default_name, index ++);
    }

    if (attr -> stackaddr == NULL)
     c74:	e5943000 	ldr	r3, [r4]
     c78:	e3530000 	cmp	r3, #0
     c7c:	0a000065 	beq	e18 <pthread_create+0x258>

  /*
   * Create the thread.
   */

  DNA_THREAD_SET_DEFAULTS (thread_info);
     c80:	e28db060 	add	fp, sp, #96	; 0x60
     c84:	e1a0000b 	mov	r0, fp
     c88:	e59f11e8 	ldr	r1, [pc, #488]	; e78 <pthread_create+0x2b8>
     c8c:	eb003cf9 	bl	10078 <dna_strcpy>
     c90:	e3a07000 	mov	r7, #0
     c94:	e3e02000 	mvn	r2, #0
     c98:	e3a04000 	mov	r4, #0
     c9c:	e3a05000 	mov	r5, #0
     ca0:	e3a0e902 	mov	lr, #32768	; 0x8000

  strcpy (thread_info . name, new -> attributs -> name);
     ca4:	e5963008 	ldr	r3, [r6, #8]

  /*
   * Create the thread.
   */

  DNA_THREAD_SET_DEFAULTS (thread_info);
     ca8:	e59fc1cc 	ldr	ip, [pc, #460]	; e7c <pthread_create+0x2bc>

  strcpy (thread_info . name, new -> attributs -> name);
     cac:	e5931024 	ldr	r1, [r3, #36]	; 0x24
     cb0:	e1a0000b 	mov	r0, fp

  /*
   * Create the thread.
   */

  DNA_THREAD_SET_DEFAULTS (thread_info);
     cb4:	e58d2088 	str	r2, [sp, #136]	; 0x88
     cb8:	e58d2094 	str	r2, [sp, #148]	; 0x94
     cbc:	e1cd49f8 	strd	r4, [sp, #152]	; 0x98
     cc0:	e1cd4af0 	strd	r4, [sp, #160]	; 0xa0
     cc4:	e58de0ac 	str	lr, [sp, #172]	; 0xac
     cc8:	e1cdc9b0 	strh	ip, [sp, #144]	; 0x90

  strcpy (thread_info . name, new -> attributs -> name);
     ccc:	e58d3054 	str	r3, [sp, #84]	; 0x54

  /*
   * Create the thread.
   */

  DNA_THREAD_SET_DEFAULTS (thread_info);
     cd0:	e58d7080 	str	r7, [sp, #128]	; 0x80
     cd4:	e58d7084 	str	r7, [sp, #132]	; 0x84
     cd8:	e58d708c 	str	r7, [sp, #140]	; 0x8c
     cdc:	e5cd7092 	strb	r7, [sp, #146]	; 0x92
     ce0:	e58d70a8 	str	r7, [sp, #168]	; 0xa8

  strcpy (thread_info . name, new -> attributs -> name);
     ce4:	eb006134 	bl	191bc <strcpy>
  thread_info . affinity = new -> attributs -> procid;
     ce8:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
  thread_info . stack_base = new -> attributs -> stackaddr;
  thread_info . stack_size = new -> attributs -> stacksize;

  thread_create ((thread_handler_t)start, (void *) arg, thread_info, & t_new);
     cec:	e28d1068 	add	r1, sp, #104	; 0x68

  DNA_THREAD_SET_DEFAULTS (thread_info);

  strcpy (thread_info . name, new -> attributs -> name);
  thread_info . affinity = new -> attributs -> procid;
  thread_info . stack_base = new -> attributs -> stackaddr;
     cf0:	e593e000 	ldr	lr, [r3]
  thread_info . stack_size = new -> attributs -> stacksize;
     cf4:	e593c004 	ldr	ip, [r3, #4]
   */

  DNA_THREAD_SET_DEFAULTS (thread_info);

  strcpy (thread_info . name, new -> attributs -> name);
  thread_info . affinity = new -> attributs -> procid;
     cf8:	e5934014 	ldr	r4, [r3, #20]
  thread_info . stack_base = new -> attributs -> stackaddr;
  thread_info . stack_size = new -> attributs -> stacksize;

  thread_create ((thread_handler_t)start, (void *) arg, thread_info, & t_new);
     cfc:	e1a0000d 	mov	r0, sp
     d00:	e28d305c 	add	r3, sp, #92	; 0x5c
     d04:	e3a02048 	mov	r2, #72	; 0x48

  DNA_THREAD_SET_DEFAULTS (thread_info);

  strcpy (thread_info . name, new -> attributs -> name);
  thread_info . affinity = new -> attributs -> procid;
  thread_info . stack_base = new -> attributs -> stackaddr;
     d08:	e58de0a8 	str	lr, [sp, #168]	; 0xa8
  thread_info . stack_size = new -> attributs -> stacksize;
     d0c:	e58dc0ac 	str	ip, [sp, #172]	; 0xac

  thread_create ((thread_handler_t)start, (void *) arg, thread_info, & t_new);
     d10:	e58d3048 	str	r3, [sp, #72]	; 0x48
   */

  DNA_THREAD_SET_DEFAULTS (thread_info);

  strcpy (thread_info . name, new -> attributs -> name);
  thread_info . affinity = new -> attributs -> procid;
     d14:	e58d4088 	str	r4, [sp, #136]	; 0x88
  thread_info . stack_base = new -> attributs -> stackaddr;
  thread_info . stack_size = new -> attributs -> stacksize;

  thread_create ((thread_handler_t)start, (void *) arg, thread_info, & t_new);
     d18:	eb005e2c 	bl	185d0 <memcpy>
     d1c:	e89b000c 	ldm	fp, {r2, r3}
     d20:	e1a01009 	mov	r1, r9
     d24:	e1a0000a 	mov	r0, sl
     d28:	eb0042fc 	bl	11920 <thread_create>

  new -> tid = t_new;
     d2c:	e59d005c 	ldr	r0, [sp, #92]	; 0x5c
     d30:	e586000c 	str	r0, [r6, #12]
  thread_resume (t_new);
     d34:	eb003ee6 	bl	108d4 <thread_resume>

  *thread = new;
  return 0;
     d38:	e1a00007 	mov	r0, r7
  thread_create ((thread_handler_t)start, (void *) arg, thread_info, & t_new);

  new -> tid = t_new;
  thread_resume (t_new);

  *thread = new;
     d3c:	e5886000 	str	r6, [r8]
  return 0;
}
     d40:	e28dd0b4 	add	sp, sp, #180	; 0xb4
     d44:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  pthread_t new;
  char * default_name = "pthread";
  void * stack_base;
  thread_info_t thread_info;

  ASSERT_RETURN( (thread == NULL), EINVAL );
     d48:	e59f3130 	ldr	r3, [pc, #304]	; e80 <pthread_create+0x2c0>
     d4c:	e59f0130 	ldr	r0, [pc, #304]	; e84 <pthread_create+0x2c4>
     d50:	e58d3000 	str	r3, [sp]
     d54:	e59f112c 	ldr	r1, [pc, #300]	; e88 <pthread_create+0x2c8>
     d58:	e59f212c 	ldr	r2, [pc, #300]	; e8c <pthread_create+0x2cc>
     d5c:	e59f312c 	ldr	r3, [pc, #300]	; e90 <pthread_create+0x2d0>
     d60:	eb005f3b 	bl	18a54 <printf>
     d64:	e3a00016 	mov	r0, #22
  new -> tid = t_new;
  thread_resume (t_new);

  *thread = new;
  return 0;
}
     d68:	e28dd0b4 	add	sp, sp, #180	; 0xb4
     d6c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

  new = malloc (sizeof(struct pthread));
  ASSERT_RETURN (!new, ENOMEM);

  new -> attributs = malloc (sizeof (pthread_attr_t));
  ASSERT_RETURN(!new->attributs, ENOMEM);
     d70:	e59f311c 	ldr	r3, [pc, #284]	; e94 <pthread_create+0x2d4>
     d74:	e59f0108 	ldr	r0, [pc, #264]	; e84 <pthread_create+0x2c4>
     d78:	e58d3000 	str	r3, [sp]
     d7c:	e59f1104 	ldr	r1, [pc, #260]	; e88 <pthread_create+0x2c8>
     d80:	e59f2104 	ldr	r2, [pc, #260]	; e8c <pthread_create+0x2cc>
     d84:	e59f310c 	ldr	r3, [pc, #268]	; e98 <pthread_create+0x2d8>
     d88:	eb005f31 	bl	18a54 <printf>
     d8c:	e3a0000c 	mov	r0, #12
     d90:	eafffff4 	b	d68 <pthread_create+0x1a8>
  thread_info_t thread_info;

  ASSERT_RETURN( (thread == NULL), EINVAL );

  new = malloc (sizeof(struct pthread));
  ASSERT_RETURN (!new, ENOMEM);
     d94:	e59f30f8 	ldr	r3, [pc, #248]	; e94 <pthread_create+0x2d4>
     d98:	e59f10e8 	ldr	r1, [pc, #232]	; e88 <pthread_create+0x2c8>
     d9c:	e58d3000 	str	r3, [sp]
     da0:	e59f20e4 	ldr	r2, [pc, #228]	; e8c <pthread_create+0x2cc>
     da4:	e59f30f0 	ldr	r3, [pc, #240]	; e9c <pthread_create+0x2dc>
     da8:	e59f00d4 	ldr	r0, [pc, #212]	; e84 <pthread_create+0x2c4>
     dac:	eb005f28 	bl	18a54 <printf>
     db0:	e3a0000c 	mov	r0, #12
  new -> tid = t_new;
  thread_resume (t_new);

  *thread = new;
  return 0;
}
     db4:	e28dd0b4 	add	sp, sp, #180	; 0xb4
     db8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  new -> cancel_state = PTHREAD_CANCEL_ENABLE;
  new -> cancel_bool = false;

  if (attr == NULL)
  {
    new -> attributs -> stacksize = 0x8000;
     dbc:	e3a07902 	mov	r7, #32768	; 0x8000
    new -> attributs -> detachstate = PTHREAD_CREATE_JOINABLE;
    new -> attributs -> schedinherited = PTHREAD_EXPLICIT_SCHED;
    new -> attributs -> schedpolicy = SCHED_FIFO;
    new -> attributs -> procid = PTHREAD_NOPROCID;
     dc0:	e3e03000 	mvn	r3, #0
  new -> cancel_bool = false;

  if (attr == NULL)
  {
    new -> attributs -> stacksize = 0x8000;
    new -> attributs -> detachstate = PTHREAD_CREATE_JOINABLE;
     dc4:	e5854008 	str	r4, [r5, #8]
    new -> attributs -> schedinherited = PTHREAD_EXPLICIT_SCHED;
     dc8:	e585200c 	str	r2, [r5, #12]
    new -> attributs -> schedpolicy = SCHED_FIFO;
     dcc:	e5852010 	str	r2, [r5, #16]
    new -> attributs -> procid = PTHREAD_NOPROCID;
     dd0:	e5853014 	str	r3, [r5, #20]
    new -> attributs -> name = (char *) malloc (32);
     dd4:	e3a00020 	mov	r0, #32
  new -> cancel_state = PTHREAD_CANCEL_ENABLE;
  new -> cancel_bool = false;

  if (attr == NULL)
  {
    new -> attributs -> stacksize = 0x8000;
     dd8:	e5857004 	str	r7, [r5, #4]
    new -> attributs -> detachstate = PTHREAD_CREATE_JOINABLE;
    new -> attributs -> schedinherited = PTHREAD_EXPLICIT_SCHED;
    new -> attributs -> schedpolicy = SCHED_FIFO;
    new -> attributs -> procid = PTHREAD_NOPROCID;
    new -> attributs -> name = (char *) malloc (32);
     ddc:	eb005a28 	bl	17684 <malloc>

    sprintf (new -> attributs -> name, "%s_%ld", default_name, index ++);
     de0:	e59fc0b8 	ldr	ip, [pc, #184]	; ea0 <pthread_create+0x2e0>
     de4:	e59f10b8 	ldr	r1, [pc, #184]	; ea4 <pthread_create+0x2e4>
     de8:	e59c3000 	ldr	r3, [ip]
     dec:	e59f20b4 	ldr	r2, [pc, #180]	; ea8 <pthread_create+0x2e8>
     df0:	e283e001 	add	lr, r3, #1
    new -> attributs -> stacksize = 0x8000;
    new -> attributs -> detachstate = PTHREAD_CREATE_JOINABLE;
    new -> attributs -> schedinherited = PTHREAD_EXPLICIT_SCHED;
    new -> attributs -> schedpolicy = SCHED_FIFO;
    new -> attributs -> procid = PTHREAD_NOPROCID;
    new -> attributs -> name = (char *) malloc (32);
     df4:	e5850024 	str	r0, [r5, #36]	; 0x24

    sprintf (new -> attributs -> name, "%s_%ld", default_name, index ++);
     df8:	e58ce000 	str	lr, [ip]
     dfc:	eb00602b 	bl	18eb0 <sprintf>

    new -> attributs -> stacksize = 0x8000;
     e00:	e5964008 	ldr	r4, [r6, #8]
    new -> attributs -> stackaddr = malloc (0x8000);
     e04:	e1a00007 	mov	r0, r7
    new -> attributs -> procid = PTHREAD_NOPROCID;
    new -> attributs -> name = (char *) malloc (32);

    sprintf (new -> attributs -> name, "%s_%ld", default_name, index ++);

    new -> attributs -> stacksize = 0x8000;
     e08:	e5847004 	str	r7, [r4, #4]
    new -> attributs -> stackaddr = malloc (0x8000);
     e0c:	eb005a1c 	bl	17684 <malloc>
     e10:	e5840000 	str	r0, [r4]
     e14:	eaffff99 	b	c80 <pthread_create+0xc0>
      sprintf (new -> attributs -> name, "%s_%ld", default_name, index ++);
    }

    if (attr -> stackaddr == NULL)
    {
      if (attr -> stacksize == 0)
     e18:	e5940004 	ldr	r0, [r4, #4]
     e1c:	e3500000 	cmp	r0, #0
     e20:	0a000003 	beq	e34 <pthread_create+0x274>
        stack_base = malloc (0x8000);
        new -> attributs -> stacksize = 0x8000;
      }
      else
      {
        stack_base = malloc (attr -> stacksize);
     e24:	eb005a16 	bl	17684 <malloc>
     e28:	e5963008 	ldr	r3, [r6, #8]
      }

      new -> attributs -> stackaddr = stack_base;
     e2c:	e5830000 	str	r0, [r3]
     e30:	eaffff92 	b	c80 <pthread_create+0xc0>

    if (attr -> stackaddr == NULL)
    {
      if (attr -> stacksize == 0)
      {
        stack_base = malloc (0x8000);
     e34:	e3a00902 	mov	r0, #32768	; 0x8000
     e38:	eb005a11 	bl	17684 <malloc>
        new -> attributs -> stacksize = 0x8000;
     e3c:	e3a02902 	mov	r2, #32768	; 0x8000
     e40:	e5963008 	ldr	r3, [r6, #8]
     e44:	e5832004 	str	r2, [r3, #4]
     e48:	eafffff7 	b	e2c <pthread_create+0x26c>
  {
    memcpy (new -> attributs, attr, sizeof (pthread_attr_t));

    if (attr -> name == NULL)
     {
      new -> attributs -> name = (char *) malloc (32);
     e4c:	e3a00020 	mov	r0, #32
     e50:	eb005a0b 	bl	17684 <malloc>
      sprintf (new -> attributs -> name, "%s_%ld", default_name, index ++);
     e54:	e59fc044 	ldr	ip, [pc, #68]	; ea0 <pthread_create+0x2e0>
     e58:	e59f1044 	ldr	r1, [pc, #68]	; ea4 <pthread_create+0x2e4>
     e5c:	e59c3000 	ldr	r3, [ip]
     e60:	e59f2040 	ldr	r2, [pc, #64]	; ea8 <pthread_create+0x2e8>
     e64:	e283e001 	add	lr, r3, #1
  {
    memcpy (new -> attributs, attr, sizeof (pthread_attr_t));

    if (attr -> name == NULL)
     {
      new -> attributs -> name = (char *) malloc (32);
     e68:	e5850024 	str	r0, [r5, #36]	; 0x24
      sprintf (new -> attributs -> name, "%s_%ld", default_name, index ++);
     e6c:	e58ce000 	str	lr, [ip]
     e70:	eb00600e 	bl	18eb0 <sprintf>
     e74:	eaffff7e 	b	c74 <pthread_create+0xb4>
     e78:	00031fa4 	.word	0x00031fa4
     e7c:	ffffd15a 	.word	0xffffd15a
     e80:	00031a50 	.word	0x00031a50
     e84:	000319a8 	.word	0x000319a8
     e88:	00031ef4 	.word	0x00031ef4
     e8c:	00031ee4 	.word	0x00031ee4
     e90:	00031f60 	.word	0x00031f60
     e94:	00031f7c 	.word	0x00031f7c
     e98:	00031f84 	.word	0x00031f84
     e9c:	00031f74 	.word	0x00031f74
     ea0:	0013e9b4 	.word	0x0013e9b4
     ea4:	00031f94 	.word	0x00031f94
     ea8:	00031f9c 	.word	0x00031f9c

00000eac <pthread_attr_destroy>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_destroy(pthread_attr_t *attr)
{
  ASSERT_RETURN (!attr, EINVAL);
     eac:	e3500000 	cmp	r0, #0
     eb0:	0a000001 	beq	ebc <pthread_attr_destroy+0x10>

  return 0;
     eb4:	e3a00000 	mov	r0, #0
     eb8:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_destroy(pthread_attr_t *attr)
{
     ebc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN (!attr, EINVAL);
     ec0:	e59f3024 	ldr	r3, [pc, #36]	; eec <pthread_attr_destroy+0x40>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_destroy(pthread_attr_t *attr)
{
     ec4:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN (!attr, EINVAL);
     ec8:	e58d3000 	str	r3, [sp]
     ecc:	e59f101c 	ldr	r1, [pc, #28]	; ef0 <pthread_attr_destroy+0x44>
     ed0:	e59f201c 	ldr	r2, [pc, #28]	; ef4 <pthread_attr_destroy+0x48>
     ed4:	e59f301c 	ldr	r3, [pc, #28]	; ef8 <pthread_attr_destroy+0x4c>
     ed8:	e59f001c 	ldr	r0, [pc, #28]	; efc <pthread_attr_destroy+0x50>
     edc:	eb005edc 	bl	18a54 <printf>
     ee0:	e3a00016 	mov	r0, #22

  return 0;
}
     ee4:	e28dd00c 	add	sp, sp, #12
     ee8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     eec:	00031a50 	.word	0x00031a50
     ef0:	00031fc4 	.word	0x00031fc4
     ef4:	00031fac 	.word	0x00031fac
     ef8:	00031e44 	.word	0x00031e44
     efc:	000319a8 	.word	0x000319a8

00000f00 <pthread_self>:

  return pself;
#endif

  return NULL;
}
     f00:	e3a00000 	mov	r0, #0
     f04:	e12fff1e 	bx	lr

00000f08 <pthread_spin_init>:
#include <Private/Macros.h>

int pthread_spin_init(pthread_spinlock_t *spin, int pshared)
{
  return 0;
}
     f08:	e3a00000 	mov	r0, #0
     f0c:	e12fff1e 	bx	lr

00000f10 <pthread_join>:
#include <stdio.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_join(pthread_t thread, void **value_ptr)
{
     f10:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  unsigned int status = 0;

  ASSERT_RETURN (thread == NULL, EINVAL);
     f14:	e3500000 	cmp	r0, #0
#include <stdio.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_join(pthread_t thread, void **value_ptr)
{
     f18:	e24dd00c 	sub	sp, sp, #12
  unsigned int status = 0;

  ASSERT_RETURN (thread == NULL, EINVAL);
     f1c:	0a000004 	beq	f34 <pthread_join+0x24>

  thread_wait (thread -> tid, (int32_t *) value_ptr);
     f20:	e590000c 	ldr	r0, [r0, #12]
     f24:	eb003de7 	bl	106c8 <thread_wait>
  return status;
     f28:	e3a00000 	mov	r0, #0
}
     f2c:	e28dd00c 	add	sp, sp, #12
     f30:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

int pthread_join(pthread_t thread, void **value_ptr)
{
  unsigned int status = 0;

  ASSERT_RETURN (thread == NULL, EINVAL);
     f34:	e59f3020 	ldr	r3, [pc, #32]	; f5c <pthread_join+0x4c>
     f38:	e59f1020 	ldr	r1, [pc, #32]	; f60 <pthread_join+0x50>
     f3c:	e58d3000 	str	r3, [sp]
     f40:	e59f201c 	ldr	r2, [pc, #28]	; f64 <pthread_join+0x54>
     f44:	e59f301c 	ldr	r3, [pc, #28]	; f68 <pthread_join+0x58>
     f48:	e59f001c 	ldr	r0, [pc, #28]	; f6c <pthread_join+0x5c>
     f4c:	eb005ec0 	bl	18a54 <printf>
     f50:	e3a00016 	mov	r0, #22

  thread_wait (thread -> tid, (int32_t *) value_ptr);
  return status;
}
     f54:	e28dd00c 	add	sp, sp, #12
     f58:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     f5c:	00031a50 	.word	0x00031a50
     f60:	00032048 	.word	0x00032048
     f64:	00032038 	.word	0x00032038
     f68:	00031cd8 	.word	0x00031cd8
     f6c:	000319a8 	.word	0x000319a8

00000f70 <pthread_mutex_trylock>:
#include <Private/PosixThreads.h>

int pthread_mutex_trylock(pthread_mutex_t *mutex)
{
     f70:	e92d4010 	push	{r4, lr}
  if (mutex == NULL) return EFAULT;
     f74:	e2504000 	subs	r4, r0, #0
#include <Private/PosixThreads.h>

int pthread_mutex_trylock(pthread_mutex_t *mutex)
{
     f78:	e24dd008 	sub	sp, sp, #8
  if (mutex == NULL) return EFAULT;
     f7c:	03a0000e 	moveq	r0, #14
     f80:	0a000003 	beq	f94 <pthread_mutex_trylock+0x24>
  if (mutex -> lock == -1) return EINVAL;
     f84:	e5940008 	ldr	r0, [r4, #8]
     f88:	e3700001 	cmn	r0, #1
     f8c:	03a00016 	moveq	r0, #22
     f90:	1a000001 	bne	f9c <pthread_mutex_trylock+0x2c>
    default :
      return EINVAL;
  }

  return 0;
}
     f94:	e28dd008 	add	sp, sp, #8
     f98:	e8bd8010 	pop	{r4, pc}
int pthread_mutex_trylock(pthread_mutex_t *mutex)
{
  if (mutex == NULL) return EFAULT;
  if (mutex -> lock == -1) return EINVAL;

  switch (semaphore_acquire (mutex -> lock, 1, DNA_RELATIVE_TIMEOUT, 0))
     f9c:	e3a02000 	mov	r2, #0
     fa0:	e3a03000 	mov	r3, #0
     fa4:	e3a01001 	mov	r1, #1
     fa8:	e1cd20f0 	strd	r2, [sp]
     fac:	e3a02002 	mov	r2, #2
     fb0:	eb0043e9 	bl	11f5c <semaphore_acquire>
     fb4:	e3500000 	cmp	r0, #0
     fb8:	0a000005 	beq	fd4 <pthread_mutex_trylock+0x64>
     fbc:	e59f301c 	ldr	r3, [pc, #28]	; fe0 <pthread_mutex_trylock+0x70>
    case DNA_OK :
      mutex -> status = MUTEX_LOCKED;
      return 0;

    default :
      return EINVAL;
     fc0:	e1500003 	cmp	r0, r3
     fc4:	03a00010 	moveq	r0, #16
     fc8:	13a00016 	movne	r0, #22
  }

  return 0;
}
     fcc:	e28dd008 	add	sp, sp, #8
     fd0:	e8bd8010 	pop	{r4, pc}
  {
    case DNA_WOULD_BLOCK :
      return EBUSY;

    case DNA_OK :
      mutex -> status = MUTEX_LOCKED;
     fd4:	e3a03001 	mov	r3, #1
     fd8:	e5843004 	str	r3, [r4, #4]
      return 0;
     fdc:	eaffffec 	b	f94 <pthread_mutex_trylock+0x24>
     fe0:	0000fdfd 	.word	0x0000fdfd

00000fe4 <pthread_mutex_init>:
#include <Private/PosixThreads.h>

int pthread_mutex_init (pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)
{
     fe4:	e92d4010 	push	{r4, lr}
  static int32_t index = 0;
  char name[32];
  status_t status = DNA_OK;

//  printf("MUTEX=%x\n", mutex);
  if (mutex == NULL) return EFAULT;
     fe8:	e2504000 	subs	r4, r0, #0
#include <Private/PosixThreads.h>

int pthread_mutex_init (pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)
{
     fec:	e24dd020 	sub	sp, sp, #32
  static int32_t index = 0;
  char name[32];
  status_t status = DNA_OK;

//  printf("MUTEX=%x\n", mutex);
  if (mutex == NULL) return EFAULT;
     ff0:	03a0000e 	moveq	r0, #14
     ff4:	0a000010 	beq	103c <pthread_mutex_init+0x58>

  sprintf (name, "pthread_mutex_%ld", index ++);
     ff8:	e59f3054 	ldr	r3, [pc, #84]	; 1054 <pthread_mutex_init+0x70>
     ffc:	e59f1054 	ldr	r1, [pc, #84]	; 1058 <pthread_mutex_init+0x74>
    1000:	e5932000 	ldr	r2, [r3]
    1004:	e1a0000d 	mov	r0, sp
    1008:	e282c001 	add	ip, r2, #1
    100c:	e583c000 	str	ip, [r3]
    1010:	eb005fa6 	bl	18eb0 <sprintf>
  status = semaphore_create (name, 1, & mutex -> lock);
    1014:	e1a0000d 	mov	r0, sp
    1018:	e2842008 	add	r2, r4, #8
    101c:	e3a01001 	mov	r1, #1
    1020:	eb0047ee 	bl	12fe0 <semaphore_create>

  if(status == DNA_NO_MORE_SEM) dna_printf("No more semaphores\n");
    1024:	e59f3030 	ldr	r3, [pc, #48]	; 105c <pthread_mutex_init+0x78>
    1028:	e1500003 	cmp	r0, r3
    102c:	0a000004 	beq	1044 <pthread_mutex_init+0x60>

  if (status != DNA_OK) return EINVAL;
  return 0;
    1030:	e3500000 	cmp	r0, #0
    1034:	13a00016 	movne	r0, #22
    1038:	03a00000 	moveq	r0, #0
}
    103c:	e28dd020 	add	sp, sp, #32
    1040:	e8bd8010 	pop	{r4, pc}
  if (mutex == NULL) return EFAULT;

  sprintf (name, "pthread_mutex_%ld", index ++);
  status = semaphore_create (name, 1, & mutex -> lock);

  if(status == DNA_NO_MORE_SEM) dna_printf("No more semaphores\n");
    1044:	e59f0014 	ldr	r0, [pc, #20]	; 1060 <pthread_mutex_init+0x7c>
    1048:	eb003933 	bl	f51c <dna_printf>

  if (status != DNA_OK) return EINVAL;
    104c:	e3a00016 	mov	r0, #22
    1050:	eafffff9 	b	103c <pthread_mutex_init+0x58>
    1054:	0013e9b8 	.word	0x0013e9b8
    1058:	000320b4 	.word	0x000320b4
    105c:	0000fdfe 	.word	0x0000fdfe
    1060:	000320c8 	.word	0x000320c8

00001064 <pthread_attr_setschedparam>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setschedparam(pthread_attr_t *attr, const sched_param_t *param)
{
  ASSERT_RETURN(!attr || !param,EINVAL);
    1064:	e3510000 	cmp	r1, #0
    1068:	13500000 	cmpne	r0, #0
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setschedparam(pthread_attr_t *attr, const sched_param_t *param)
{
    106c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!attr || !param,EINVAL);
    1070:	e1a03000 	mov	r3, r0
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setschedparam(pthread_attr_t *attr, const sched_param_t *param)
{
    1074:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!attr || !param,EINVAL);
    1078:	03a00001 	moveq	r0, #1
    107c:	13a00000 	movne	r0, #0
    1080:	1a000009 	bne	10ac <pthread_attr_setschedparam+0x48>
    1084:	e59f3040 	ldr	r3, [pc, #64]	; 10cc <pthread_attr_setschedparam+0x68>
    1088:	e59f1040 	ldr	r1, [pc, #64]	; 10d0 <pthread_attr_setschedparam+0x6c>
    108c:	e58d3000 	str	r3, [sp]
    1090:	e59f203c 	ldr	r2, [pc, #60]	; 10d4 <pthread_attr_setschedparam+0x70>
    1094:	e59f303c 	ldr	r3, [pc, #60]	; 10d8 <pthread_attr_setschedparam+0x74>
    1098:	e59f003c 	ldr	r0, [pc, #60]	; 10dc <pthread_attr_setschedparam+0x78>
    109c:	eb005e6c 	bl	18a54 <printf>
    10a0:	e3a00016 	mov	r0, #22

  memcpy(&attr->schedparam, param, sizeof(*param));
  return 0;
}
    10a4:	e28dd00c 	add	sp, sp, #12
    10a8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

int pthread_attr_setschedparam(pthread_attr_t *attr, const sched_param_t *param)
{
  ASSERT_RETURN(!attr || !param,EINVAL);

  memcpy(&attr->schedparam, param, sizeof(*param));
    10ac:	e591e000 	ldr	lr, [r1]
    10b0:	e591c004 	ldr	ip, [r1, #4]
    10b4:	e5911008 	ldr	r1, [r1, #8]
    10b8:	e583e018 	str	lr, [r3, #24]
    10bc:	e583c01c 	str	ip, [r3, #28]
    10c0:	e5831020 	str	r1, [r3, #32]
  return 0;
}
    10c4:	e28dd00c 	add	sp, sp, #12
    10c8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    10cc:	00031a50 	.word	0x00031a50
    10d0:	000320f8 	.word	0x000320f8
    10d4:	000320dc 	.word	0x000320dc
    10d8:	00032170 	.word	0x00032170
    10dc:	000319a8 	.word	0x000319a8

000010e0 <pthread_attr_getschedpolicy>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy)
{
  ASSERT_RETURN (! attr || ! policy, EINVAL);
    10e0:	e3510000 	cmp	r1, #0
    10e4:	13500000 	cmpne	r0, #0
    10e8:	e1a03000 	mov	r3, r0
    10ec:	03a00001 	moveq	r0, #1
    10f0:	13a00000 	movne	r0, #0
    10f4:	0a000002 	beq	1104 <pthread_attr_getschedpolicy+0x24>

  *policy = attr -> schedpolicy;
    10f8:	e5933010 	ldr	r3, [r3, #16]
    10fc:	e5813000 	str	r3, [r1]
  return 0;
    1100:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy)
{
    1104:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN (! attr || ! policy, EINVAL);
    1108:	e59f3024 	ldr	r3, [pc, #36]	; 1134 <pthread_attr_getschedpolicy+0x54>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy)
{
    110c:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN (! attr || ! policy, EINVAL);
    1110:	e58d3000 	str	r3, [sp]
    1114:	e59f101c 	ldr	r1, [pc, #28]	; 1138 <pthread_attr_getschedpolicy+0x58>
    1118:	e59f201c 	ldr	r2, [pc, #28]	; 113c <pthread_attr_getschedpolicy+0x5c>
    111c:	e59f301c 	ldr	r3, [pc, #28]	; 1140 <pthread_attr_getschedpolicy+0x60>
    1120:	e59f001c 	ldr	r0, [pc, #28]	; 1144 <pthread_attr_getschedpolicy+0x64>
    1124:	eb005e4a 	bl	18a54 <printf>
    1128:	e3a00016 	mov	r0, #22

  *policy = attr -> schedpolicy;
  return 0;
}
    112c:	e28dd00c 	add	sp, sp, #12
    1130:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    1134:	00031a50 	.word	0x00031a50
    1138:	0003219c 	.word	0x0003219c
    113c:	00032180 	.word	0x00032180
    1140:	00032218 	.word	0x00032218
    1144:	000319a8 	.word	0x000319a8

00001148 <pthread_exit>:
#include <Private/PosixThreads.h>

void pthread_exit(void *retval)
{
    1148:	e12fff1e 	bx	lr

0000114c <pthread_attr_setschedpolicy>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
{
  ASSERT_RETURN(!attr,EINVAL);
    114c:	e2503000 	subs	r3, r0, #0
    1150:	0a000002 	beq	1160 <pthread_attr_setschedpolicy+0x14>

  attr->schedpolicy = policy;
  return 0;
    1154:	e3a00000 	mov	r0, #0

int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
{
  ASSERT_RETURN(!attr,EINVAL);

  attr->schedpolicy = policy;
    1158:	e5831010 	str	r1, [r3, #16]
  return 0;
    115c:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
{
    1160:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!attr,EINVAL);
    1164:	e59f3024 	ldr	r3, [pc, #36]	; 1190 <pthread_attr_setschedpolicy+0x44>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
{
    1168:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!attr,EINVAL);
    116c:	e58d3000 	str	r3, [sp]
    1170:	e59f101c 	ldr	r1, [pc, #28]	; 1194 <pthread_attr_setschedpolicy+0x48>
    1174:	e59f201c 	ldr	r2, [pc, #28]	; 1198 <pthread_attr_setschedpolicy+0x4c>
    1178:	e59f301c 	ldr	r3, [pc, #28]	; 119c <pthread_attr_setschedpolicy+0x50>
    117c:	e59f001c 	ldr	r0, [pc, #28]	; 11a0 <pthread_attr_setschedpolicy+0x54>
    1180:	eb005e33 	bl	18a54 <printf>
    1184:	e3a00016 	mov	r0, #22

  attr->schedpolicy = policy;
  return 0;
}
    1188:	e28dd00c 	add	sp, sp, #12
    118c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    1190:	00031a50 	.word	0x00031a50
    1194:	00032248 	.word	0x00032248
    1198:	0003222c 	.word	0x0003222c
    119c:	00031e44 	.word	0x00031e44
    11a0:	000319a8 	.word	0x000319a8

000011a4 <pthread_equal>:
#include <Private/PosixThreads.h>

int pthread_equal(pthread_t thread1, pthread_t thread2)
{
  return thread1 == thread2;
}
    11a4:	e0600001 	rsb	r0, r0, r1
    11a8:	e16f0f10 	clz	r0, r0
    11ac:	e1a002a0 	lsr	r0, r0, #5
    11b0:	e12fff1e 	bx	lr

000011b4 <__libthread_start>:
#include <Private/Macros.h>

extern int main (void);

int __libthread_start (void)
{
    11b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    11b8:	e24dd00c 	sub	sp, sp, #12
  int32_t my_id;
  pthread_t wrapper = malloc (sizeof (struct pthread));

  thread_find (NULL, & my_id);
    11bc:	e28d1004 	add	r1, sp, #4
    11c0:	e3a00000 	mov	r0, #0
    11c4:	eb0049f4 	bl	1399c <thread_find>
  wrapper -> attributs -> detachstate = PTHREAD_CREATE_JOINABLE;
  wrapper -> attributs -> schedinherited = PTHREAD_EXPLICIT_SCHED;
  wrapper -> attributs -> schedpolicy = SCHED_FIFO;
  wrapper -> attributs -> procid = PTHREAD_NOPROCID;

  return main ();
    11c8:	eb0014bd 	bl	64c4 <main>
}
    11cc:	e28dd00c 	add	sp, sp, #12
    11d0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

000011d4 <pthread_cond_init>:
#include <Private/PosixThreads.h>

int pthread_cond_init(pthread_cond_t *condition, pthread_condattr_t *condattr)
{
    11d4:	e92d4010 	push	{r4, lr}
  static int32_t index = 0;
  char name[32];
  status_t status = DNA_OK;

  sprintf (name, "pthread_cond_%ld", index ++);
    11d8:	e59f3060 	ldr	r3, [pc, #96]	; 1240 <pthread_cond_init+0x6c>
#include <Private/PosixThreads.h>

int pthread_cond_init(pthread_cond_t *condition, pthread_condattr_t *condattr)
{
    11dc:	e24dd020 	sub	sp, sp, #32
  static int32_t index = 0;
  char name[32];
  status_t status = DNA_OK;

  sprintf (name, "pthread_cond_%ld", index ++);
    11e0:	e5932000 	ldr	r2, [r3]
#include <Private/PosixThreads.h>

int pthread_cond_init(pthread_cond_t *condition, pthread_condattr_t *condattr)
{
    11e4:	e1a04000 	mov	r4, r0
  static int32_t index = 0;
  char name[32];
  status_t status = DNA_OK;

  sprintf (name, "pthread_cond_%ld", index ++);
    11e8:	e282c001 	add	ip, r2, #1
    11ec:	e59f1050 	ldr	r1, [pc, #80]	; 1244 <pthread_cond_init+0x70>
    11f0:	e1a0000d 	mov	r0, sp
    11f4:	e583c000 	str	ip, [r3]
    11f8:	eb005f2c 	bl	18eb0 <sprintf>
  condition -> count = 0;
    11fc:	e3a01000 	mov	r1, #0
  status = semaphore_create (name, 0, & condition -> semaphore);
    1200:	e1a0000d 	mov	r0, sp
  static int32_t index = 0;
  char name[32];
  status_t status = DNA_OK;

  sprintf (name, "pthread_cond_%ld", index ++);
  condition -> count = 0;
    1204:	e5841004 	str	r1, [r4, #4]
  status = semaphore_create (name, 0, & condition -> semaphore);
    1208:	e1a02004 	mov	r2, r4
    120c:	eb004773 	bl	12fe0 <semaphore_create>

  if (status != DNA_OK)
    1210:	e3500000 	cmp	r0, #0
    1214:	0a000007 	beq	1238 <pthread_cond_init+0x64>
  {
    switch (status)
    1218:	e59f3028 	ldr	r3, [pc, #40]	; 1248 <pthread_cond_init+0x74>
    121c:	e1500003 	cmp	r0, r3
    {
      case DNA_NO_MORE_SEM :
        return EAGAIN;
    1220:	03a0000b 	moveq	r0, #11
  condition -> count = 0;
  status = semaphore_create (name, 0, & condition -> semaphore);

  if (status != DNA_OK)
  {
    switch (status)
    1224:	0a000003 	beq	1238 <pthread_cond_init+0x64>
    1228:	e59f301c 	ldr	r3, [pc, #28]	; 124c <pthread_cond_init+0x78>
      case DNA_NO_MORE_SEM :
        return EAGAIN;
      case DNA_OUT_OF_MEM :
        return ENOMEM;
      default :
        return EINVAL;
    122c:	e1500003 	cmp	r0, r3
    1230:	03a0000c 	moveq	r0, #12
    1234:	13a00016 	movne	r0, #22
    }
  }

  return 0;
}
    1238:	e28dd020 	add	sp, sp, #32
    123c:	e8bd8010 	pop	{r4, pc}
    1240:	0013e9bc 	.word	0x0013e9bc
    1244:	000322c4 	.word	0x000322c4
    1248:	0000fdfe 	.word	0x0000fdfe
    124c:	0000fffd 	.word	0x0000fffd

00001250 <pthread_getschedparam>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_getschedparam(pthread_t t, int *p, struct sched_param *sp)
{
  ASSERT_RETURN (!t || !sp, EINVAL);
    1250:	e3520000 	cmp	r2, #0
    1254:	13500000 	cmpne	r0, #0
    1258:	03a03001 	moveq	r3, #1
    125c:	13a03000 	movne	r3, #0
    1260:	1a00000b 	bne	1294 <pthread_getschedparam+0x44>
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_getschedparam(pthread_t t, int *p, struct sched_param *sp)
{
    1264:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN (!t || !sp, EINVAL);
    1268:	e59f3054 	ldr	r3, [pc, #84]	; 12c4 <pthread_getschedparam+0x74>
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_getschedparam(pthread_t t, int *p, struct sched_param *sp)
{
    126c:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN (!t || !sp, EINVAL);
    1270:	e58d3000 	str	r3, [sp]
    1274:	e59f104c 	ldr	r1, [pc, #76]	; 12c8 <pthread_getschedparam+0x78>
    1278:	e59f204c 	ldr	r2, [pc, #76]	; 12cc <pthread_getschedparam+0x7c>
    127c:	e59f304c 	ldr	r3, [pc, #76]	; 12d0 <pthread_getschedparam+0x80>
    1280:	e59f004c 	ldr	r0, [pc, #76]	; 12d4 <pthread_getschedparam+0x84>
    1284:	eb005df2 	bl	18a54 <printf>
    1288:	e3a00016 	mov	r0, #22

  *p = t -> attributs -> schedpolicy;
  memcpy (sp, & t -> attributs -> schedparam, sizeof (*sp));
  return 0;
}
    128c:	e28dd00c 	add	sp, sp, #12
    1290:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

int pthread_getschedparam(pthread_t t, int *p, struct sched_param *sp)
{
  ASSERT_RETURN (!t || !sp, EINVAL);

  *p = t -> attributs -> schedpolicy;
    1294:	e590c008 	ldr	ip, [r0, #8]
  memcpy (sp, & t -> attributs -> schedparam, sizeof (*sp));
  return 0;
    1298:	e1a00003 	mov	r0, r3
int pthread_getschedparam(pthread_t t, int *p, struct sched_param *sp)
{
  ASSERT_RETURN (!t || !sp, EINVAL);

  *p = t -> attributs -> schedpolicy;
  memcpy (sp, & t -> attributs -> schedparam, sizeof (*sp));
    129c:	e1a0300c 	mov	r3, ip

int pthread_getschedparam(pthread_t t, int *p, struct sched_param *sp)
{
  ASSERT_RETURN (!t || !sp, EINVAL);

  *p = t -> attributs -> schedpolicy;
    12a0:	e59cc010 	ldr	ip, [ip, #16]
    12a4:	e581c000 	str	ip, [r1]
  memcpy (sp, & t -> attributs -> schedparam, sizeof (*sp));
    12a8:	e5b3c018 	ldr	ip, [r3, #24]!
    12ac:	e5931004 	ldr	r1, [r3, #4]
    12b0:	e5933008 	ldr	r3, [r3, #8]
    12b4:	e582c000 	str	ip, [r2]
    12b8:	e5821004 	str	r1, [r2, #4]
    12bc:	e5823008 	str	r3, [r2, #8]
  return 0;
    12c0:	e12fff1e 	bx	lr
    12c4:	00031a50 	.word	0x00031a50
    12c8:	000322f0 	.word	0x000322f0
    12cc:	000322d8 	.word	0x000322d8
    12d0:	00032364 	.word	0x00032364
    12d4:	000319a8 	.word	0x000319a8

000012d8 <pthread_setschedparam>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_setschedparam(pthread_t t, int p, const struct sched_param *sp)
{
  ASSERT_RETURN(!t || !sp,EINVAL);
    12d8:	e3520000 	cmp	r2, #0
    12dc:	13500000 	cmpne	r0, #0
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_setschedparam(pthread_t t, int p, const struct sched_param *sp)
{
    12e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!t || !sp,EINVAL);
    12e4:	e1a03000 	mov	r3, r0
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_setschedparam(pthread_t t, int p, const struct sched_param *sp)
{
    12e8:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!t || !sp,EINVAL);
    12ec:	03a00001 	moveq	r0, #1
    12f0:	13a00000 	movne	r0, #0
    12f4:	1a000009 	bne	1320 <pthread_setschedparam+0x48>
    12f8:	e59f3048 	ldr	r3, [pc, #72]	; 1348 <pthread_setschedparam+0x70>
    12fc:	e59f1048 	ldr	r1, [pc, #72]	; 134c <pthread_setschedparam+0x74>
    1300:	e58d3000 	str	r3, [sp]
    1304:	e59f2044 	ldr	r2, [pc, #68]	; 1350 <pthread_setschedparam+0x78>
    1308:	e59f3044 	ldr	r3, [pc, #68]	; 1354 <pthread_setschedparam+0x7c>
    130c:	e59f0044 	ldr	r0, [pc, #68]	; 1358 <pthread_setschedparam+0x80>
    1310:	eb005dcf 	bl	18a54 <printf>
    1314:	e3a00016 	mov	r0, #22

  t -> attributs -> schedpolicy = p;
  memcpy (& t -> attributs -> schedparam, sp, sizeof(*sp));

  return 0;
}
    1318:	e28dd00c 	add	sp, sp, #12
    131c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  // FIXME : we need to find out if
  // the thread is still in scheduled
  // => core_search ?
  // It's the same for the _getschedparam counterpart

  t -> attributs -> schedpolicy = p;
    1320:	e5933008 	ldr	r3, [r3, #8]
    1324:	e5831010 	str	r1, [r3, #16]
  memcpy (& t -> attributs -> schedparam, sp, sizeof(*sp));
    1328:	e592e000 	ldr	lr, [r2]
    132c:	e592c004 	ldr	ip, [r2, #4]
    1330:	e5921008 	ldr	r1, [r2, #8]
    1334:	e583e018 	str	lr, [r3, #24]
    1338:	e583c01c 	str	ip, [r3, #28]
    133c:	e5831020 	str	r1, [r3, #32]

  return 0;
}
    1340:	e28dd00c 	add	sp, sp, #12
    1344:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    1348:	00031a50 	.word	0x00031a50
    134c:	00032388 	.word	0x00032388
    1350:	00032370 	.word	0x00032370
    1354:	00032364 	.word	0x00032364
    1358:	000319a8 	.word	0x000319a8

0000135c <pthread_mutex_unlock>:
#include <Private/PosixThreads.h>

int pthread_mutex_unlock (pthread_mutex_t *mutex)
{
  if (mutex == NULL) return EFAULT;
    135c:	e2503000 	subs	r3, r0, #0
    1360:	0a00000c 	beq	1398 <pthread_mutex_unlock+0x3c>
  if (mutex -> lock == -1) return EINVAL;
    1364:	e5930008 	ldr	r0, [r3, #8]
    1368:	e3700001 	cmn	r0, #1
    136c:	1a000001 	bne	1378 <pthread_mutex_unlock+0x1c>
    1370:	e3a00016 	mov	r0, #22
    1374:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>

int pthread_mutex_unlock (pthread_mutex_t *mutex)
{
    1378:	e92d4010 	push	{r4, lr}
  if (mutex == NULL) return EFAULT;
  if (mutex -> lock == -1) return EINVAL;

  mutex -> status = MUTEX_UNLOCKED;
    137c:	e3a04000 	mov	r4, #0
  semaphore_release (mutex -> lock, 1, 0);
    1380:	e3a01001 	mov	r1, #1
int pthread_mutex_unlock (pthread_mutex_t *mutex)
{
  if (mutex == NULL) return EFAULT;
  if (mutex -> lock == -1) return EINVAL;

  mutex -> status = MUTEX_UNLOCKED;
    1384:	e5834004 	str	r4, [r3, #4]
  semaphore_release (mutex -> lock, 1, 0);
    1388:	e1a02004 	mov	r2, r4
    138c:	eb0047b6 	bl	1326c <semaphore_release>

  return 0;
    1390:	e1a00004 	mov	r0, r4
    1394:	e8bd8010 	pop	{r4, pc}
#include <Private/PosixThreads.h>

int pthread_mutex_unlock (pthread_mutex_t *mutex)
{
  if (mutex == NULL) return EFAULT;
    1398:	e3a0000e 	mov	r0, #14
    139c:	e12fff1e 	bx	lr

000013a0 <pthread_attr_setinheritsched>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setinheritsched(pthread_attr_t *attr, int h)
{
  ASSERT_RETURN(!attr,EINVAL);
    13a0:	e2503000 	subs	r3, r0, #0
    13a4:	0a000002 	beq	13b4 <pthread_attr_setinheritsched+0x14>

  attr->schedinherited = h;
  return 0;
    13a8:	e3a00000 	mov	r0, #0

int pthread_attr_setinheritsched(pthread_attr_t *attr, int h)
{
  ASSERT_RETURN(!attr,EINVAL);

  attr->schedinherited = h;
    13ac:	e583100c 	str	r1, [r3, #12]
  return 0;
    13b0:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setinheritsched(pthread_attr_t *attr, int h)
{
    13b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!attr,EINVAL);
    13b8:	e59f3024 	ldr	r3, [pc, #36]	; 13e4 <pthread_attr_setinheritsched+0x44>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setinheritsched(pthread_attr_t *attr, int h)
{
    13bc:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!attr,EINVAL);
    13c0:	e58d3000 	str	r3, [sp]
    13c4:	e59f101c 	ldr	r1, [pc, #28]	; 13e8 <pthread_attr_setinheritsched+0x48>
    13c8:	e59f201c 	ldr	r2, [pc, #28]	; 13ec <pthread_attr_setinheritsched+0x4c>
    13cc:	e59f301c 	ldr	r3, [pc, #28]	; 13f0 <pthread_attr_setinheritsched+0x50>
    13d0:	e59f001c 	ldr	r0, [pc, #28]	; 13f4 <pthread_attr_setinheritsched+0x54>
    13d4:	eb005d9e 	bl	18a54 <printf>
    13d8:	e3a00016 	mov	r0, #22

  attr->schedinherited = h;
  return 0;
}
    13dc:	e28dd00c 	add	sp, sp, #12
    13e0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    13e4:	00031a50 	.word	0x00031a50
    13e8:	0003241c 	.word	0x0003241c
    13ec:	000323fc 	.word	0x000323fc
    13f0:	00031e44 	.word	0x00031e44
    13f4:	000319a8 	.word	0x000319a8

000013f8 <pthread_setcancelstate>:
  if (oldstate != NULL) *oldstate = self -> cancel_state;
  self -> cancel_state = state;
#endif

  return 0;
}
    13f8:	e3a00000 	mov	r0, #0
    13fc:	e12fff1e 	bx	lr

00001400 <pthread_attr_setstacksize>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size)
{
  ASSERT_RETURN(!attr || size == 0,EINVAL);
    1400:	e3510000 	cmp	r1, #0
    1404:	13500000 	cmpne	r0, #0
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size)
{
    1408:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!attr || size == 0,EINVAL);
    140c:	e1a03000 	mov	r3, r0
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size)
{
    1410:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!attr || size == 0,EINVAL);
    1414:	0a00000e 	beq	1454 <pthread_attr_setstacksize+0x54>
  ASSERT_RETURN(size%4,EINVAL);
    1418:	e2110003 	ands	r0, r1, #3
  attr->stacksize = size;
    141c:	05831004 	streq	r1, [r3, #4]
#include <Private/Macros.h>

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size)
{
  ASSERT_RETURN(!attr || size == 0,EINVAL);
  ASSERT_RETURN(size%4,EINVAL);
    1420:	1a000001 	bne	142c <pthread_attr_setstacksize+0x2c>
  attr->stacksize = size;
  return 0;
}
    1424:	e28dd00c 	add	sp, sp, #12
    1428:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
#include <Private/Macros.h>

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size)
{
  ASSERT_RETURN(!attr || size == 0,EINVAL);
  ASSERT_RETURN(size%4,EINVAL);
    142c:	e59f3048 	ldr	r3, [pc, #72]	; 147c <pthread_attr_setstacksize+0x7c>
    1430:	e59f1048 	ldr	r1, [pc, #72]	; 1480 <pthread_attr_setstacksize+0x80>
    1434:	e58d3000 	str	r3, [sp]
    1438:	e59f2044 	ldr	r2, [pc, #68]	; 1484 <pthread_attr_setstacksize+0x84>
    143c:	e59f3044 	ldr	r3, [pc, #68]	; 1488 <pthread_attr_setstacksize+0x88>
    1440:	e59f0044 	ldr	r0, [pc, #68]	; 148c <pthread_attr_setstacksize+0x8c>
    1444:	eb005d82 	bl	18a54 <printf>
    1448:	e3a00016 	mov	r0, #22
  attr->stacksize = size;
  return 0;
}
    144c:	e28dd00c 	add	sp, sp, #12
    1450:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size)
{
  ASSERT_RETURN(!attr || size == 0,EINVAL);
    1454:	e59f3020 	ldr	r3, [pc, #32]	; 147c <pthread_attr_setstacksize+0x7c>
    1458:	e59f1020 	ldr	r1, [pc, #32]	; 1480 <pthread_attr_setstacksize+0x80>
    145c:	e58d3000 	str	r3, [sp]
    1460:	e59f201c 	ldr	r2, [pc, #28]	; 1484 <pthread_attr_setstacksize+0x84>
    1464:	e59f3024 	ldr	r3, [pc, #36]	; 1490 <pthread_attr_setstacksize+0x90>
    1468:	e59f001c 	ldr	r0, [pc, #28]	; 148c <pthread_attr_setstacksize+0x8c>
    146c:	eb005d78 	bl	18a54 <printf>
    1470:	e3a00016 	mov	r0, #22
  ASSERT_RETURN(size%4,EINVAL);
  attr->stacksize = size;
  return 0;
}
    1474:	e28dd00c 	add	sp, sp, #12
    1478:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    147c:	00031a50 	.word	0x00031a50
    1480:	000324b4 	.word	0x000324b4
    1484:	00032498 	.word	0x00032498
    1488:	00032540 	.word	0x00032540
    148c:	000319a8 	.word	0x000319a8
    1490:	0003252c 	.word	0x0003252c

00001494 <pthread_cond_timedwait>:
#include <Private/PosixThreads.h>

int pthread_cond_timedwait(pthread_cond_t *condition, pthread_mutex_t *mutex, const struct timespec *abstime)
{
  return 0;
}
    1494:	e3a00000 	mov	r0, #0
    1498:	e12fff1e 	bx	lr

0000149c <pthread_attr_getdetachstate>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *state)
{
  ASSERT_RETURN (!attr || !state,EINVAL);
    149c:	e3510000 	cmp	r1, #0
    14a0:	13500000 	cmpne	r0, #0
    14a4:	e1a03000 	mov	r3, r0
    14a8:	03a00001 	moveq	r0, #1
    14ac:	13a00000 	movne	r0, #0
    14b0:	0a000002 	beq	14c0 <pthread_attr_getdetachstate+0x24>
  *state = attr -> detachstate;
    14b4:	e5933008 	ldr	r3, [r3, #8]
    14b8:	e5813000 	str	r3, [r1]

  return 0;
    14bc:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *state)
{
    14c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN (!attr || !state,EINVAL);
    14c4:	e59f3024 	ldr	r3, [pc, #36]	; 14f0 <pthread_attr_getdetachstate+0x54>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *state)
{
    14c8:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN (!attr || !state,EINVAL);
    14cc:	e58d3000 	str	r3, [sp]
    14d0:	e59f101c 	ldr	r1, [pc, #28]	; 14f4 <pthread_attr_getdetachstate+0x58>
    14d4:	e59f201c 	ldr	r2, [pc, #28]	; 14f8 <pthread_attr_getdetachstate+0x5c>
    14d8:	e59f301c 	ldr	r3, [pc, #28]	; 14fc <pthread_attr_getdetachstate+0x60>
    14dc:	e59f001c 	ldr	r0, [pc, #28]	; 1500 <pthread_attr_getdetachstate+0x64>
    14e0:	eb005d5b 	bl	18a54 <printf>
    14e4:	e3a00016 	mov	r0, #22
  *state = attr -> detachstate;

  return 0;
}
    14e8:	e28dd00c 	add	sp, sp, #12
    14ec:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    14f0:	00031a50 	.word	0x00031a50
    14f4:	00032564 	.word	0x00032564
    14f8:	00032548 	.word	0x00032548
    14fc:	000325e0 	.word	0x000325e0
    1500:	000319a8 	.word	0x000319a8

00001504 <pthread_barrier_wait>:
  }

  lock_release(barrier -> sem);
#endif
  return res;
}
    1504:	e3a00000 	mov	r0, #0
    1508:	e12fff1e 	bx	lr

0000150c <pthread_cond_signal>:
#include <Private/PosixThreads.h>

int pthread_cond_signal(pthread_cond_t *condition)
{
    150c:	e92d4008 	push	{r3, lr}
  status_t status = DNA_OK;

  if (condition -> count > 0)
    1510:	e5903004 	ldr	r3, [r0, #4]
    1514:	e3530000 	cmp	r3, #0
    1518:	da000008 	ble	1540 <pthread_cond_signal+0x34>
  {
    status = semaphore_release (condition -> semaphore, 1, 0);
    151c:	e3a01001 	mov	r1, #1
    1520:	e3a02000 	mov	r2, #0
    1524:	e5900000 	ldr	r0, [r0]
    1528:	eb00474f 	bl	1326c <semaphore_release>
    if (status == DNA_BAD_SEM_ID) return EINVAL;
    152c:	e59f3014 	ldr	r3, [pc, #20]	; 1548 <pthread_cond_signal+0x3c>
  }

  return 0;
    1530:	e1500003 	cmp	r0, r3
    1534:	03a00016 	moveq	r0, #22
    1538:	13a00000 	movne	r0, #0
    153c:	e8bd8008 	pop	{r3, pc}
    1540:	e3a00000 	mov	r0, #0
}
    1544:	e8bd8008 	pop	{r3, pc}
    1548:	0000fdff 	.word	0x0000fdff

0000154c <pthread_attr_setstackaddr>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setstackaddr(pthread_attr_t *attr, void *addr)
{
  ASSERT_RETURN(!attr || addr == NULL,EINVAL);
    154c:	e3510000 	cmp	r1, #0
    1550:	13500000 	cmpne	r0, #0
    1554:	e1a03000 	mov	r3, r0
    1558:	03a00001 	moveq	r0, #1
    155c:	13a00000 	movne	r0, #0
    1560:	0a000001 	beq	156c <pthread_attr_setstackaddr+0x20>

  attr->stackaddr = addr;
    1564:	e5831000 	str	r1, [r3]
  return 0;
    1568:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setstackaddr(pthread_attr_t *attr, void *addr)
{
    156c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!attr || addr == NULL,EINVAL);
    1570:	e59f3024 	ldr	r3, [pc, #36]	; 159c <pthread_attr_setstackaddr+0x50>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setstackaddr(pthread_attr_t *attr, void *addr)
{
    1574:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!attr || addr == NULL,EINVAL);
    1578:	e58d3000 	str	r3, [sp]
    157c:	e59f101c 	ldr	r1, [pc, #28]	; 15a0 <pthread_attr_setstackaddr+0x54>
    1580:	e59f201c 	ldr	r2, [pc, #28]	; 15a4 <pthread_attr_setstackaddr+0x58>
    1584:	e59f301c 	ldr	r3, [pc, #28]	; 15a8 <pthread_attr_setstackaddr+0x5c>
    1588:	e59f001c 	ldr	r0, [pc, #28]	; 15ac <pthread_attr_setstackaddr+0x60>
    158c:	eb005d30 	bl	18a54 <printf>
    1590:	e3a00016 	mov	r0, #22

  attr->stackaddr = addr;
  return 0;
}
    1594:	e28dd00c 	add	sp, sp, #12
    1598:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    159c:	00031a50 	.word	0x00031a50
    15a0:	0003260c 	.word	0x0003260c
    15a4:	000325f0 	.word	0x000325f0
    15a8:	00032684 	.word	0x00032684
    15ac:	000319a8 	.word	0x000319a8

000015b0 <pthread_cond_wait>:

int pthread_cond_wait (pthread_cond_t *condition, pthread_mutex_t *mutex)
{
  status_t status = DNA_OK;

  status = semaphore_acquire (condition -> semaphore, 1, DNA_RELATIVE_TIMEOUT, 0);
    15b0:	e3a03000 	mov	r3, #0
    15b4:	e3a02000 	mov	r2, #0
#include <Private/PosixThreads.h>

int pthread_cond_wait (pthread_cond_t *condition, pthread_mutex_t *mutex)
{
    15b8:	e92d4070 	push	{r4, r5, r6, lr}
    15bc:	e24dd008 	sub	sp, sp, #8
    15c0:	e1a04000 	mov	r4, r0
    15c4:	e1a05001 	mov	r5, r1
  status_t status = DNA_OK;

  status = semaphore_acquire (condition -> semaphore, 1, DNA_RELATIVE_TIMEOUT, 0);
    15c8:	e5900000 	ldr	r0, [r0]
    15cc:	e3a01001 	mov	r1, #1
    15d0:	e1cd20f0 	strd	r2, [sp]
    15d4:	e3a02002 	mov	r2, #2
    15d8:	eb00425f 	bl	11f5c <semaphore_acquire>

  if (status == DNA_WOULD_BLOCK)
    15dc:	e59f307c 	ldr	r3, [pc, #124]	; 1660 <pthread_cond_wait+0xb0>
    15e0:	e1500003 	cmp	r0, r3
    15e4:	0a000002 	beq	15f4 <pthread_cond_wait+0x44>
    cpu_dcache_invalidate((void*)&condition->count,sizeof(uint32_t));
    condition -> count -= 1;
  }

  return 0;
}
    15e8:	e3a00000 	mov	r0, #0
    15ec:	e28dd008 	add	sp, sp, #8
    15f0:	e8bd8070 	pop	{r4, r5, r6, pc}

  status = semaphore_acquire (condition -> semaphore, 1, DNA_RELATIVE_TIMEOUT, 0);

  if (status == DNA_WOULD_BLOCK)
  {
    cpu_dcache_invalidate((void*)&condition->count,sizeof(uint32_t));
    15f4:	e2846004 	add	r6, r4, #4
    15f8:	e1a00006 	mov	r0, r6
    15fc:	e3a01004 	mov	r1, #4
    1600:	eb003c0e 	bl	10640 <cpu_dcache_invalidate>
    condition -> count += 1;
    1604:	e5943004 	ldr	r3, [r4, #4]
    pthread_mutex_unlock (mutex);
    1608:	e1a00005 	mov	r0, r5
  status = semaphore_acquire (condition -> semaphore, 1, DNA_RELATIVE_TIMEOUT, 0);

  if (status == DNA_WOULD_BLOCK)
  {
    cpu_dcache_invalidate((void*)&condition->count,sizeof(uint32_t));
    condition -> count += 1;
    160c:	e2833001 	add	r3, r3, #1
    1610:	e5843004 	str	r3, [r4, #4]
    pthread_mutex_unlock (mutex);
    1614:	ebffff50 	bl	135c <pthread_mutex_unlock>

    status = semaphore_acquire (condition -> semaphore, 1, 0, -1);
    1618:	e3e03000 	mvn	r3, #0
    161c:	e3e02000 	mvn	r2, #0
    1620:	e5940000 	ldr	r0, [r4]
    1624:	e3a01001 	mov	r1, #1
    1628:	e1cd20f0 	strd	r2, [sp]
    162c:	e3a02000 	mov	r2, #0
    1630:	eb004249 	bl	11f5c <semaphore_acquire>
    pthread_mutex_lock (mutex);
    1634:	e1a00005 	mov	r0, r5
    1638:	ebfffc6d 	bl	7f4 <pthread_mutex_lock>
    cpu_dcache_invalidate((void*)&condition->count,sizeof(uint32_t));
    163c:	e1a00006 	mov	r0, r6
    1640:	e3a01004 	mov	r1, #4
    1644:	eb003bfd 	bl	10640 <cpu_dcache_invalidate>
    condition -> count -= 1;
  }

  return 0;
}
    1648:	e3a00000 	mov	r0, #0
    pthread_mutex_unlock (mutex);

    status = semaphore_acquire (condition -> semaphore, 1, 0, -1);
    pthread_mutex_lock (mutex);
    cpu_dcache_invalidate((void*)&condition->count,sizeof(uint32_t));
    condition -> count -= 1;
    164c:	e5943004 	ldr	r3, [r4, #4]
    1650:	e2433001 	sub	r3, r3, #1
    1654:	e5843004 	str	r3, [r4, #4]
  }

  return 0;
}
    1658:	e28dd008 	add	sp, sp, #8
    165c:	e8bd8070 	pop	{r4, r5, r6, pc}
    1660:	0000fdfd 	.word	0x0000fdfd

00001664 <pthread_spin_destroy>:

int pthread_spin_destroy(pthread_spinlock_t *spin)
{
  /* Quite bright indeed */
  return 0;
}
    1664:	e3a00000 	mov	r0, #0
    1668:	e12fff1e 	bx	lr

0000166c <pthread_attr_getstackaddr>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getstackaddr(const pthread_attr_t *attr, void **addr)
{
  ASSERT_RETURN (! attr || ! addr,EINVAL);
    166c:	e3510000 	cmp	r1, #0
    1670:	13500000 	cmpne	r0, #0
    1674:	e1a03000 	mov	r3, r0
    1678:	03a00001 	moveq	r0, #1
    167c:	13a00000 	movne	r0, #0
    1680:	0a000002 	beq	1690 <pthread_attr_getstackaddr+0x24>

  *addr = attr -> stackaddr;
    1684:	e5933000 	ldr	r3, [r3]
    1688:	e5813000 	str	r3, [r1]
  return 0;
    168c:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getstackaddr(const pthread_attr_t *attr, void **addr)
{
    1690:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN (! attr || ! addr,EINVAL);
    1694:	e59f3024 	ldr	r3, [pc, #36]	; 16c0 <pthread_attr_getstackaddr+0x54>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getstackaddr(const pthread_attr_t *attr, void **addr)
{
    1698:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN (! attr || ! addr,EINVAL);
    169c:	e58d3000 	str	r3, [sp]
    16a0:	e59f101c 	ldr	r1, [pc, #28]	; 16c4 <pthread_attr_getstackaddr+0x58>
    16a4:	e59f201c 	ldr	r2, [pc, #28]	; 16c8 <pthread_attr_getstackaddr+0x5c>
    16a8:	e59f301c 	ldr	r3, [pc, #28]	; 16cc <pthread_attr_getstackaddr+0x60>
    16ac:	e59f001c 	ldr	r0, [pc, #28]	; 16d0 <pthread_attr_getstackaddr+0x64>
    16b0:	eb005ce7 	bl	18a54 <printf>
    16b4:	e3a00016 	mov	r0, #22

  *addr = attr -> stackaddr;
  return 0;
}
    16b8:	e28dd00c 	add	sp, sp, #12
    16bc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    16c0:	00031a50 	.word	0x00031a50
    16c4:	000326b8 	.word	0x000326b8
    16c8:	0003269c 	.word	0x0003269c
    16cc:	00032730 	.word	0x00032730
    16d0:	000319a8 	.word	0x000319a8

000016d4 <__libthread_errno>:

  return & pself -> errorno;
#endif

  return & p_errno;
}
    16d4:	e59f0000 	ldr	r0, [pc]	; 16dc <__libthread_errno+0x8>
    16d8:	e12fff1e 	bx	lr
    16dc:	0013e9c0 	.word	0x0013e9c0

000016e0 <pthread_lock_release>:
#include <Private/Macros.h>

int pthread_lock_release(pthread_spinlock_t *spin)
{
   return 0;
}
    16e0:	e3a00000 	mov	r0, #0
    16e4:	e12fff1e 	bx	lr

000016e8 <soclib_tty_write>:
#include <Processor/Processor.h>
#include <Processor/Cache.h>

status_t soclib_tty_write (void * handler, void * source,
    int64_t offset, int32_t * p_count)
{
    16e8:	e92d4070 	push	{r4, r5, r6, lr}
    16ec:	e1a05001 	mov	r5, r1
    16f0:	e59d4010 	ldr	r4, [sp, #16]
    16f4:	e1a06000 	mov	r6, r0
  soclib_tty_t * tty = (soclib_tty_t *) handler;

  cpu_dcache_invalidate((void*)source,sizeof(char)*(*p_count));
    16f8:	e5941000 	ldr	r1, [r4]
    16fc:	e1a00005 	mov	r0, r5
    1700:	eb003bce 	bl	10640 <cpu_dcache_invalidate>
  for (uint32_t i = 0; i < * p_count; i++)  
    1704:	e5943000 	ldr	r3, [r4]
    1708:	e3530000 	cmp	r3, #0
    170c:	0a000007 	beq	1730 <soclib_tty_write+0x48>
    1710:	e3a03000 	mov	r3, #0
  {
    cpu_write (UINT8, (& tty -> port -> write), ((char *)source)[i]);
    1714:	e596200c 	ldr	r2, [r6, #12]
    1718:	e7d5c003 	ldrb	ip, [r5, r3]
    int64_t offset, int32_t * p_count)
{
  soclib_tty_t * tty = (soclib_tty_t *) handler;

  cpu_dcache_invalidate((void*)source,sizeof(char)*(*p_count));
  for (uint32_t i = 0; i < * p_count; i++)  
    171c:	e2833001 	add	r3, r3, #1
  {
    cpu_write (UINT8, (& tty -> port -> write), ((char *)source)[i]);
    1720:	e5c2c000 	strb	ip, [r2]
    int64_t offset, int32_t * p_count)
{
  soclib_tty_t * tty = (soclib_tty_t *) handler;

  cpu_dcache_invalidate((void*)source,sizeof(char)*(*p_count));
  for (uint32_t i = 0; i < * p_count; i++)  
    1724:	e5942000 	ldr	r2, [r4]
    1728:	e1520003 	cmp	r2, r3
    172c:	8afffff8 	bhi	1714 <soclib_tty_write+0x2c>
  {
    cpu_write (UINT8, (& tty -> port -> write), ((char *)source)[i]);
  }

  return DNA_OK;
}
    1730:	e3a00000 	mov	r0, #0
    1734:	e8bd8070 	pop	{r4, r5, r6, pc}

00001738 <soclib_platform_prepare_devices>:
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

soclib_tty_t * TTY = NULL;

status_t soclib_platform_prepare_devices(void) {
    1738:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  char * base_path = "serial/soclib/", * device_base, alpha_index[8];

  watch (status_t)
  {
    if (soclib_platform_devices != NULL)
    173c:	e59f615c 	ldr	r6, [pc, #348]	; 18a0 <soclib_platform_prepare_devices+0x168>
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

soclib_tty_t * TTY = NULL;

status_t soclib_platform_prepare_devices(void) {
    1740:	e24dd008 	sub	sp, sp, #8
  char * base_path = "serial/soclib/", * device_base, alpha_index[8];

  watch (status_t)
  {
    if (soclib_platform_devices != NULL)
    1744:	e5963000 	ldr	r3, [r6]
    1748:	e3530000 	cmp	r3, #0
    174c:	0a00000d 	beq	1788 <soclib_platform_prepare_devices+0x50>
    {
      for (int32_t i = 0; soclib_platform_devices[i] != NULL; i += 1)
    1750:	e5930000 	ldr	r0, [r3]
    1754:	e3500000 	cmp	r0, #0
    1758:	0a000006 	beq	1778 <soclib_platform_prepare_devices+0x40>
    175c:	e3a04004 	mov	r4, #4
      {
        kernel_free (soclib_platform_devices[i]);
    1760:	eb004a7f 	bl	14164 <kernel_free>

  watch (status_t)
  {
    if (soclib_platform_devices != NULL)
    {
      for (int32_t i = 0; soclib_platform_devices[i] != NULL; i += 1)
    1764:	e5963000 	ldr	r3, [r6]
    1768:	e7930004 	ldr	r0, [r3, r4]
    176c:	e2844004 	add	r4, r4, #4
    1770:	e3500000 	cmp	r0, #0
    1774:	1afffff9 	bne	1760 <soclib_platform_prepare_devices+0x28>
      {
        kernel_free (soclib_platform_devices[i]);
      }

      kernel_free (soclib_platform_devices);
    1778:	e1a00003 	mov	r0, r3
    177c:	eb004a78 	bl	14164 <kernel_free>
      soclib_platform_devices = NULL;
    1780:	e3a03000 	mov	r3, #0
    1784:	e5863000 	str	r3, [r6]
    /*
     * Generate the name database.
     */

    soclib_platform_devices = kernel_malloc
      ((SOCLIB_TTY_NDEV + 2) * sizeof (char *), true);
    1788:	e59f8114 	ldr	r8, [pc, #276]	; 18a4 <soclib_platform_prepare_devices+0x16c>
    178c:	e3a01001 	mov	r1, #1
    1790:	e5980000 	ldr	r0, [r8]
    1794:	e2800002 	add	r0, r0, #2
    1798:	e1a00100 	lsl	r0, r0, #2
    179c:	eb004a3b 	bl	14090 <kernel_malloc>
    ensure (soclib_platform_devices != NULL, DNA_ERROR);
    17a0:	e3500000 	cmp	r0, #0

    /*
     * Generate the name database.
     */

    soclib_platform_devices = kernel_malloc
    17a4:	e5860000 	str	r0, [r6]
      ((SOCLIB_TTY_NDEV + 2) * sizeof (char *), true);
    ensure (soclib_platform_devices != NULL, DNA_ERROR);
    17a8:	0a000039 	beq	1894 <soclib_platform_prepare_devices+0x15c>

    for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
    17ac:	e5983000 	ldr	r3, [r8]
    17b0:	e3530000 	cmp	r3, #0
    17b4:	0a000029 	beq	1860 <soclib_platform_prepare_devices+0x128>
    17b8:	e3a07000 	mov	r7, #0
    17bc:	e1a04007 	mov	r4, r7
    17c0:	ea00000f 	b	1804 <soclib_platform_prepare_devices+0xcc>
    {
      device_base = kernel_malloc (DNA_PATH_LENGTH, false);
      check (no_memory, device_base != NULL, DNA_ERROR);

      dna_itoa (i, alpha_index);
    17c4:	e1a00004 	mov	r0, r4
    17c8:	e1a0100d 	mov	r1, sp
    17cc:	eb003a9a 	bl	1023c <dna_itoa>
      dna_strcpy (device_base, base_path);
    17d0:	e59f10d0 	ldr	r1, [pc, #208]	; 18a8 <soclib_platform_prepare_devices+0x170>
    17d4:	e1a00005 	mov	r0, r5
    17d8:	eb003a26 	bl	10078 <dna_strcpy>
      dna_strcat (device_base, alpha_index);
    17dc:	e1a00005 	mov	r0, r5
    17e0:	e1a0100d 	mov	r1, sp
    17e4:	eb0039a4 	bl	fe7c <dna_strcat>

    soclib_platform_devices = kernel_malloc
      ((SOCLIB_TTY_NDEV + 2) * sizeof (char *), true);
    ensure (soclib_platform_devices != NULL, DNA_ERROR);

    for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
    17e8:	e5982000 	ldr	r2, [r8]
    17ec:	e2844001 	add	r4, r4, #1
      check (no_memory, device_base != NULL, DNA_ERROR);

      dna_itoa (i, alpha_index);
      dna_strcpy (device_base, base_path);
      dna_strcat (device_base, alpha_index);
      soclib_platform_devices[i] = device_base;
    17f0:	e5963000 	ldr	r3, [r6]

    soclib_platform_devices = kernel_malloc
      ((SOCLIB_TTY_NDEV + 2) * sizeof (char *), true);
    ensure (soclib_platform_devices != NULL, DNA_ERROR);

    for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
    17f4:	e1540002 	cmp	r4, r2
      check (no_memory, device_base != NULL, DNA_ERROR);

      dna_itoa (i, alpha_index);
      dna_strcpy (device_base, base_path);
      dna_strcat (device_base, alpha_index);
      soclib_platform_devices[i] = device_base;
    17f8:	e7835107 	str	r5, [r3, r7, lsl #2]

    soclib_platform_devices = kernel_malloc
      ((SOCLIB_TTY_NDEV + 2) * sizeof (char *), true);
    ensure (soclib_platform_devices != NULL, DNA_ERROR);

    for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
    17fc:	e1a07004 	mov	r7, r4
    1800:	2a000016 	bcs	1860 <soclib_platform_prepare_devices+0x128>
    {
      device_base = kernel_malloc (DNA_PATH_LENGTH, false);
    1804:	e3a00b01 	mov	r0, #1024	; 0x400
    1808:	e3a01000 	mov	r1, #0
    180c:	eb004a1f 	bl	14090 <kernel_malloc>
      check (no_memory, device_base != NULL, DNA_ERROR);
    1810:	e2505000 	subs	r5, r0, #0
    1814:	1affffea 	bne	17c4 <soclib_platform_prepare_devices+0x8c>
    return DNA_OK;
  }

  rescue (no_memory)
  {
    for (int32_t i = 0; soclib_platform_devices[i] != NULL; i += 1)
    1818:	e5963000 	ldr	r3, [r6]
    181c:	e5930000 	ldr	r0, [r3]
    1820:	e3500000 	cmp	r0, #0
    1824:	0a000006 	beq	1844 <soclib_platform_prepare_devices+0x10c>
    1828:	e3a04004 	mov	r4, #4
    {
      kernel_free (soclib_platform_devices[i]);
    182c:	eb004a4c 	bl	14164 <kernel_free>
    return DNA_OK;
  }

  rescue (no_memory)
  {
    for (int32_t i = 0; soclib_platform_devices[i] != NULL; i += 1)
    1830:	e5963000 	ldr	r3, [r6]
    1834:	e7930004 	ldr	r0, [r3, r4]
    1838:	e2844004 	add	r4, r4, #4
    183c:	e3500000 	cmp	r0, #0
    1840:	1afffff9 	bne	182c <soclib_platform_prepare_devices+0xf4>
    {
      kernel_free (soclib_platform_devices[i]);
    }

    kernel_free (soclib_platform_devices);
    1844:	e1a00003 	mov	r0, r3
    1848:	eb004a45 	bl	14164 <kernel_free>
    soclib_platform_devices = NULL;
    184c:	e3a03000 	mov	r3, #0

    leave;
    1850:	e59f0054 	ldr	r0, [pc, #84]	; 18ac <soclib_platform_prepare_devices+0x174>
    {
      kernel_free (soclib_platform_devices[i]);
    }

    kernel_free (soclib_platform_devices);
    soclib_platform_devices = NULL;
    1854:	e5863000 	str	r3, [r6]

    leave;
  }
}
    1858:	e28dd008 	add	sp, sp, #8
    185c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    /*
     * Add the kernel serial devices.
     * TODO find a better way to do that => pass this info as a parameter.
     */

    device_base = kernel_malloc (DNA_PATH_LENGTH, false);
    1860:	e3a00b01 	mov	r0, #1024	; 0x400
    1864:	e3a01000 	mov	r1, #0
    1868:	eb004a08 	bl	14090 <kernel_malloc>
    check (no_memory, device_base != NULL, DNA_ERROR);
    186c:	e2504000 	subs	r4, r0, #0
    1870:	0affffe8 	beq	1818 <soclib_platform_prepare_devices+0xe0>

    dna_strcpy (device_base, "serial/kernel/console");
    1874:	e59f1034 	ldr	r1, [pc, #52]	; 18b0 <soclib_platform_prepare_devices+0x178>
    1878:	eb0039fe 	bl	10078 <dna_strcpy>
    soclib_platform_devices[SOCLIB_TTY_NDEV] = device_base;

    return DNA_OK;
    187c:	e3a00000 	mov	r0, #0

    device_base = kernel_malloc (DNA_PATH_LENGTH, false);
    check (no_memory, device_base != NULL, DNA_ERROR);

    dna_strcpy (device_base, "serial/kernel/console");
    soclib_platform_devices[SOCLIB_TTY_NDEV] = device_base;
    1880:	e5982000 	ldr	r2, [r8]
    1884:	e5963000 	ldr	r3, [r6]
    1888:	e7834102 	str	r4, [r3, r2, lsl #2]
    kernel_free (soclib_platform_devices);
    soclib_platform_devices = NULL;

    leave;
  }
}
    188c:	e28dd008 	add	sp, sp, #8
    1890:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
     * Generate the name database.
     */

    soclib_platform_devices = kernel_malloc
      ((SOCLIB_TTY_NDEV + 2) * sizeof (char *), true);
    ensure (soclib_platform_devices != NULL, DNA_ERROR);
    1894:	e59f0010 	ldr	r0, [pc, #16]	; 18ac <soclib_platform_prepare_devices+0x174>
    kernel_free (soclib_platform_devices);
    soclib_platform_devices = NULL;

    leave;
  }
}
    1898:	e28dd008 	add	sp, sp, #8
    189c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    18a0:	0013e9c8 	.word	0x0013e9c8
    18a4:	0003e968 	.word	0x0003e968
    18a8:	00032744 	.word	0x00032744
    18ac:	0000ffff 	.word	0x0000ffff
    18b0:	00032754 	.word	0x00032754

000018b4 <soclib_platform_init_driver>:

status_t soclib_platform_init_driver (void)
{
    18b4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

  /*
   * Connect the TIMER and IPI ISRs.
   */

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
    18b8:	e3a04000 	mov	r4, #0
    leave;
  }
}

status_t soclib_platform_init_driver (void)
{
    18bc:	e24dd054 	sub	sp, sp, #84	; 0x54
   * Connect the TIMER and IPI ISRs.
   */

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
  {
    interrupt_attach (i, 0, 0x0, soclib_ipi_isr, true);
    18c0:	e3a06001 	mov	r6, #1
    18c4:	e1a05004 	mov	r5, r4

  /*
   * Connect the TIMER and IPI ISRs.
   */

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
    18c8:	ea00000b 	b	18fc <soclib_platform_init_driver+0x48>
  {
    interrupt_attach (i, 0, 0x0, soclib_ipi_isr, true);
    18cc:	e3a01000 	mov	r1, #0
    18d0:	e1a00004 	mov	r0, r4
    18d4:	e1a02001 	mov	r2, r1
    18d8:	e58d6000 	str	r6, [sp]
    18dc:	eb0046f3 	bl	134b0 <interrupt_attach>
    interrupt_attach (i, 1, 0x0, soclib_timer_isr, false);
    18e0:	e1a00004 	mov	r0, r4
    18e4:	e58d5000 	str	r5, [sp]
    18e8:	e3a01001 	mov	r1, #1
    18ec:	e3a02000 	mov	r2, #0
    18f0:	e59f312c 	ldr	r3, [pc, #300]	; 1a24 <soclib_platform_init_driver+0x170>
    18f4:	eb0046ed 	bl	134b0 <interrupt_attach>

  /*
   * Connect the TIMER and IPI ISRs.
   */

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
    18f8:	e2844001 	add	r4, r4, #1
    18fc:	eb003b6c 	bl	106b4 <cpu_mp_count>
    1900:	e1540000 	cmp	r4, r0
  {
    interrupt_attach (i, 0, 0x0, soclib_ipi_isr, true);
    1904:	e59f311c 	ldr	r3, [pc, #284]	; 1a28 <soclib_platform_init_driver+0x174>

  /*
   * Connect the TIMER and IPI ISRs.
   */

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
    1908:	baffffef 	blt	18cc <soclib_platform_init_driver+0x18>

  /*
   * Instantiate the TTY devices.
   */

  TTY = kernel_malloc (sizeof (soclib_tty_t) * SOCLIB_TTY_NDEV, true);
    190c:	e59fb118 	ldr	fp, [pc, #280]	; 1a2c <soclib_platform_init_driver+0x178>
    1910:	e3a01001 	mov	r1, #1
    1914:	e59b3000 	ldr	r3, [fp]
    1918:	e59f7110 	ldr	r7, [pc, #272]	; 1a30 <soclib_platform_init_driver+0x17c>
    191c:	e0830103 	add	r0, r3, r3, lsl #2
    1920:	e1a00100 	lsl	r0, r0, #2
    1924:	eb0049d9 	bl	14090 <kernel_malloc>
  if (TTY == NULL) return DNA_OUT_OF_MEM;
    1928:	e3500000 	cmp	r0, #0

  /*
   * Instantiate the TTY devices.
   */

  TTY = kernel_malloc (sizeof (soclib_tty_t) * SOCLIB_TTY_NDEV, true);
    192c:	e5870000 	str	r0, [r7]
  if (TTY == NULL) return DNA_OUT_OF_MEM;
    1930:	0a000038 	beq	1a18 <soclib_platform_init_driver+0x164>

  for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
    1934:	e59b3000 	ldr	r3, [fp]
    1938:	e3530000 	cmp	r3, #0
    193c:	0a000031 	beq	1a08 <soclib_platform_init_driver+0x154>
    1940:	e3a05000 	mov	r5, #0
    dna_strcpy (sem_name, "soclib_tty_");
    dna_strcat (sem_name, alpha_index);
    dna_strcat (sem_name, "_sem");

    semaphore_create (sem_name, 0, & TTY[i] . sem_id);
    TTY[i] . buffer . empty = true;
    1944:	e3a09001 	mov	r9, #1
   */

  TTY = kernel_malloc (sizeof (soclib_tty_t) * SOCLIB_TTY_NDEV, true);
  if (TTY == NULL) return DNA_OUT_OF_MEM;

  for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
    1948:	e1a06005 	mov	r6, r5
    194c:	e1a04005 	mov	r4, r5
    dna_itoa (i, alpha_index);
    dna_strcpy (sem_name, "soclib_tty_");
    dna_strcat (sem_name, alpha_index);
    dna_strcat (sem_name, "_sem");

    semaphore_create (sem_name, 0, & TTY[i] . sem_id);
    1950:	e1a0a005 	mov	sl, r5
    1954:	e59f80d8 	ldr	r8, [pc, #216]	; 1a34 <soclib_platform_init_driver+0x180>
    1958:	ea000001 	b	1964 <soclib_platform_init_driver+0xb0>
    195c:	e59f30cc 	ldr	r3, [pc, #204]	; 1a30 <soclib_platform_init_driver+0x17c>
    1960:	e5930000 	ldr	r0, [r3]
  TTY = kernel_malloc (sizeof (soclib_tty_t) * SOCLIB_TTY_NDEV, true);
  if (TTY == NULL) return DNA_OUT_OF_MEM;

  for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
  {
    TTY[i] . irq = SOCLIB_TTY_DEVICES[i] . irq;
    1964:	e0883005 	add	r3, r8, r5
    1968:	e0866106 	add	r6, r6, r6, lsl #2
    196c:	e7982005 	ldr	r2, [r8, r5]
    TTY[i] . port = SOCLIB_TTY_DEVICES[i] . port;
    1970:	e5933004 	ldr	r3, [r3, #4]
  TTY = kernel_malloc (sizeof (soclib_tty_t) * SOCLIB_TTY_NDEV, true);
  if (TTY == NULL) return DNA_OUT_OF_MEM;

  for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
  {
    TTY[i] . irq = SOCLIB_TTY_DEVICES[i] . irq;
    1974:	e1a06106 	lsl	r6, r6, #2
    1978:	e0800006 	add	r0, r0, r6
    TTY[i] . port = SOCLIB_TTY_DEVICES[i] . port;
    197c:	e580300c 	str	r3, [r0, #12]
  TTY = kernel_malloc (sizeof (soclib_tty_t) * SOCLIB_TTY_NDEV, true);
  if (TTY == NULL) return DNA_OUT_OF_MEM;

  for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
  {
    TTY[i] . irq = SOCLIB_TTY_DEVICES[i] . irq;
    1980:	e5802008 	str	r2, [r0, #8]
    TTY[i] . port = SOCLIB_TTY_DEVICES[i] . port;

    dna_itoa (i, alpha_index);
    1984:	e28d1008 	add	r1, sp, #8
    1988:	e1a00004 	mov	r0, r4
    198c:	eb003a2a 	bl	1023c <dna_itoa>
    dna_strcpy (sem_name, "soclib_tty_");
    1990:	e59f10a0 	ldr	r1, [pc, #160]	; 1a38 <soclib_platform_init_driver+0x184>
    1994:	e28d0010 	add	r0, sp, #16
    1998:	eb0039b6 	bl	10078 <dna_strcpy>
    dna_strcat (sem_name, alpha_index);
    199c:	e28d1008 	add	r1, sp, #8
    19a0:	e28d0010 	add	r0, sp, #16
    19a4:	eb003934 	bl	fe7c <dna_strcat>
    dna_strcat (sem_name, "_sem");
    19a8:	e59f108c 	ldr	r1, [pc, #140]	; 1a3c <soclib_platform_init_driver+0x188>
    19ac:	e28d0010 	add	r0, sp, #16
    19b0:	eb003931 	bl	fe7c <dna_strcat>

    semaphore_create (sem_name, 0, & TTY[i] . sem_id);
    19b4:	e5972000 	ldr	r2, [r7]
    19b8:	e3a01000 	mov	r1, #0
    19bc:	e0822006 	add	r2, r2, r6
    19c0:	e2822010 	add	r2, r2, #16
    19c4:	e28d0010 	add	r0, sp, #16
    19c8:	eb004584 	bl	12fe0 <semaphore_create>
    TTY[i] . buffer . empty = true;

    interrupt_attach (0, TTY[i] . irq, 0x0, soclib_tty_isr, false);
    19cc:	e3a00000 	mov	r0, #0
    dna_strcpy (sem_name, "soclib_tty_");
    dna_strcat (sem_name, alpha_index);
    dna_strcat (sem_name, "_sem");

    semaphore_create (sem_name, 0, & TTY[i] . sem_id);
    TTY[i] . buffer . empty = true;
    19d0:	e5973000 	ldr	r3, [r7]

    interrupt_attach (0, TTY[i] . irq, 0x0, soclib_tty_isr, false);
    19d4:	e1a02000 	mov	r2, r0
    dna_strcpy (sem_name, "soclib_tty_");
    dna_strcat (sem_name, alpha_index);
    dna_strcat (sem_name, "_sem");

    semaphore_create (sem_name, 0, & TTY[i] . sem_id);
    TTY[i] . buffer . empty = true;
    19d8:	e0836006 	add	r6, r3, r6

    interrupt_attach (0, TTY[i] . irq, 0x0, soclib_tty_isr, false);
    19dc:	e5961008 	ldr	r1, [r6, #8]
    dna_strcpy (sem_name, "soclib_tty_");
    dna_strcat (sem_name, alpha_index);
    dna_strcat (sem_name, "_sem");

    semaphore_create (sem_name, 0, & TTY[i] . sem_id);
    TTY[i] . buffer . empty = true;
    19e0:	e5c69004 	strb	r9, [r6, #4]

    interrupt_attach (0, TTY[i] . irq, 0x0, soclib_tty_isr, false);
    19e4:	e59f3054 	ldr	r3, [pc, #84]	; 1a40 <soclib_platform_init_driver+0x18c>
    19e8:	e58da000 	str	sl, [sp]
    19ec:	eb0046af 	bl	134b0 <interrupt_attach>
   */

  TTY = kernel_malloc (sizeof (soclib_tty_t) * SOCLIB_TTY_NDEV, true);
  if (TTY == NULL) return DNA_OUT_OF_MEM;

  for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
    19f0:	e59b3000 	ldr	r3, [fp]
    19f4:	e2844001 	add	r4, r4, #1
    19f8:	e1540003 	cmp	r4, r3
    19fc:	e2855008 	add	r5, r5, #8
    1a00:	e1a06004 	mov	r6, r4
    1a04:	3affffd4 	bcc	195c <soclib_platform_init_driver+0xa8>
    TTY[i] . buffer . empty = true;

    interrupt_attach (0, TTY[i] . irq, 0x0, soclib_tty_isr, false);
  }

  soclib_platform_prepare_devices();
    1a08:	ebffff4a 	bl	1738 <soclib_platform_prepare_devices>

  return DNA_OK;
    1a0c:	e3a00000 	mov	r0, #0
}
    1a10:	e28dd054 	add	sp, sp, #84	; 0x54
    1a14:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  /*
   * Instantiate the TTY devices.
   */

  TTY = kernel_malloc (sizeof (soclib_tty_t) * SOCLIB_TTY_NDEV, true);
  if (TTY == NULL) return DNA_OUT_OF_MEM;
    1a18:	e59f0024 	ldr	r0, [pc, #36]	; 1a44 <soclib_platform_init_driver+0x190>
  }

  soclib_platform_prepare_devices();

  return DNA_OK;
}
    1a1c:	e28dd054 	add	sp, sp, #84	; 0x54
    1a20:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1a24:	00001bb8 	.word	0x00001bb8
    1a28:	00001b50 	.word	0x00001b50
    1a2c:	0003e968 	.word	0x0003e968
    1a30:	0013e9c4 	.word	0x0013e9c4
    1a34:	0003e96c 	.word	0x0003e96c
    1a38:	0003276c 	.word	0x0003276c
    1a3c:	00032778 	.word	0x00032778
    1a40:	00001c7c 	.word	0x00001c7c
    1a44:	0000fffd 	.word	0x0000fffd

00001a48 <soclib_tty_open>:
#include <Private/Driver.h>
#include <Processor/Processor.h>
#include <DnaTools/DnaTools.h>

status_t soclib_tty_open (char * name, int32_t mode, void ** data)
{
    1a48:	e92d4010 	push	{r4, lr}
  watch (status_t)
  {
    ensure (data != NULL, DNA_ERROR);
    1a4c:	e2524000 	subs	r4, r2, #0
    1a50:	0a000003 	beq	1a64 <soclib_tty_open+0x1c>

    if (dna_strcmp (name, "serial/kernel/console") == 0)
    1a54:	e59f1020 	ldr	r1, [pc, #32]	; 1a7c <soclib_tty_open+0x34>
    1a58:	eb003918 	bl	fec0 <dna_strcmp>
    1a5c:	e3500000 	cmp	r0, #0
    1a60:	0a000001 	beq	1a6c <soclib_tty_open+0x24>

status_t soclib_tty_open (char * name, int32_t mode, void ** data)
{
  watch (status_t)
  {
    ensure (data != NULL, DNA_ERROR);
    1a64:	e59f0014 	ldr	r0, [pc, #20]	; 1a80 <soclib_tty_open+0x38>
    1a68:	e8bd8010 	pop	{r4, pc}

    if (dna_strcmp (name, "serial/kernel/console") == 0)
    {
      *data = (void *) & TTY[0];
    1a6c:	e59f3010 	ldr	r3, [pc, #16]	; 1a84 <soclib_tty_open+0x3c>
    1a70:	e5933000 	ldr	r3, [r3]
    1a74:	e5843000 	str	r3, [r4]
    }
#endif

    return DNA_ERROR;
  }
}
    1a78:	e8bd8010 	pop	{r4, pc}
    1a7c:	00032754 	.word	0x00032754
    1a80:	0000ffff 	.word	0x0000ffff
    1a84:	0013e9c4 	.word	0x0013e9c4

00001a88 <soclib_tty_control>:
#include <Processor/Processor.h>

status_t soclib_tty_control (void * handler, int32_t function,
    va_list arguments, int32_t * p_ret)
{
  switch (function)
    1a88:	e3510006 	cmp	r1, #6
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>

status_t soclib_tty_control (void * handler, int32_t function,
    va_list arguments, int32_t * p_ret)
{
    1a8c:	e92d4038 	push	{r3, r4, r5, lr}
    1a90:	e1a04003 	mov	r4, r3
      }

    default :
      {
        dna_log(INFO_LEVEL, "Unsupported control code 0x%x.", function);
        *p_ret = -1;
    1a94:	13e03000 	mvnne	r3, #0
    1a98:	15843000 	strne	r3, [r4]
#include <Processor/Processor.h>

status_t soclib_tty_control (void * handler, int32_t function,
    va_list arguments, int32_t * p_ret)
{
  switch (function)
    1a9c:	0a000001 	beq	1aa8 <soclib_tty_control+0x20>
        break;
      }
  }

  return DNA_OK;
}
    1aa0:	e3a00000 	mov	r0, #0
    1aa4:	e8bd8038 	pop	{r3, r4, r5, pc}
{
  switch (function)
  {
    case DNA_GET_INFO :
      {
        device_info_t * info = va_arg (arguments, device_info_t *);
    1aa8:	e5925000 	ldr	r5, [r2]

        dna_memset (info, 0, sizeof (device_info_t));
    1aac:	e3a01000 	mov	r1, #0
    1ab0:	e1a00005 	mov	r0, r5
    1ab4:	e3a02010 	mov	r2, #16
    1ab8:	eb00366d 	bl	f474 <dna_memset>
        info -> type = DNA_CHARACTER_DEVICE;
    1abc:	e3a03000 	mov	r3, #0
        break;
      }
  }

  return DNA_OK;
}
    1ac0:	e3a00000 	mov	r0, #0
    case DNA_GET_INFO :
      {
        device_info_t * info = va_arg (arguments, device_info_t *);

        dna_memset (info, 0, sizeof (device_info_t));
        info -> type = DNA_CHARACTER_DEVICE;
    1ac4:	e5853000 	str	r3, [r5]

        *p_ret = 0;
    1ac8:	e5843000 	str	r3, [r4]
        break;
      }
  }

  return DNA_OK;
}
    1acc:	e8bd8038 	pop	{r3, r4, r5, pc}

00001ad0 <soclib_tty_read>:
#include <Private/Driver.h>
#include <DnaTools/DnaTools.h>

status_t soclib_tty_read (void * handler, void * destination,
    int64_t offset, int32_t * p_count)
{
    1ad0:	e92d4070 	push	{r4, r5, r6, lr}
  soclib_tty_t * tty = (soclib_tty_t *) handler;

  if (tty -> buffer . empty) semaphore_acquire (tty -> sem_id, 1, 0, -1);
    1ad4:	e5d03004 	ldrb	r3, [r0, #4]
#include <Private/Driver.h>
#include <DnaTools/DnaTools.h>

status_t soclib_tty_read (void * handler, void * destination,
    int64_t offset, int32_t * p_count)
{
    1ad8:	e24dd008 	sub	sp, sp, #8
  soclib_tty_t * tty = (soclib_tty_t *) handler;

  if (tty -> buffer . empty) semaphore_acquire (tty -> sem_id, 1, 0, -1);
    1adc:	e3530000 	cmp	r3, #0
#include <Private/Driver.h>
#include <DnaTools/DnaTools.h>

status_t soclib_tty_read (void * handler, void * destination,
    int64_t offset, int32_t * p_count)
{
    1ae0:	e1a04000 	mov	r4, r0
    1ae4:	e1a06001 	mov	r6, r1
    1ae8:	e59d5018 	ldr	r5, [sp, #24]
  soclib_tty_t * tty = (soclib_tty_t *) handler;

  if (tty -> buffer . empty) semaphore_acquire (tty -> sem_id, 1, 0, -1);
    1aec:	0a000006 	beq	1b0c <soclib_tty_read+0x3c>
    1af0:	e3e02000 	mvn	r2, #0
    1af4:	e3e03000 	mvn	r3, #0
    1af8:	e5900010 	ldr	r0, [r0, #16]
    1afc:	e3a01001 	mov	r1, #1
    1b00:	e1cd20f0 	strd	r2, [sp]
    1b04:	e3a02000 	mov	r2, #0
    1b08:	eb004113 	bl	11f5c <semaphore_acquire>

  *((char *)destination) = tty -> buffer . data;
  tty -> buffer . empty = true;
    1b0c:	e3a03001 	mov	r3, #1

  cpu_write (UINT8, (& tty -> port -> write), tty -> buffer . data); // echoing typed character

  *p_count = 1;
  return DNA_OK;
}
    1b10:	e3a00000 	mov	r0, #0
{
  soclib_tty_t * tty = (soclib_tty_t *) handler;

  if (tty -> buffer . empty) semaphore_acquire (tty -> sem_id, 1, 0, -1);

  *((char *)destination) = tty -> buffer . data;
    1b14:	e5d42005 	ldrb	r2, [r4, #5]
    1b18:	e5c62000 	strb	r2, [r6]
  tty -> buffer . empty = true;

  cpu_write (UINT8, (& tty -> port -> write), tty -> buffer . data); // echoing typed character
    1b1c:	e594200c 	ldr	r2, [r4, #12]
    1b20:	e5d41005 	ldrb	r1, [r4, #5]
  soclib_tty_t * tty = (soclib_tty_t *) handler;

  if (tty -> buffer . empty) semaphore_acquire (tty -> sem_id, 1, 0, -1);

  *((char *)destination) = tty -> buffer . data;
  tty -> buffer . empty = true;
    1b24:	e5c43004 	strb	r3, [r4, #4]

  cpu_write (UINT8, (& tty -> port -> write), tty -> buffer . data); // echoing typed character
    1b28:	e5c21000 	strb	r1, [r2]

  *p_count = 1;
    1b2c:	e5853000 	str	r3, [r5]
  return DNA_OK;
}
    1b30:	e28dd008 	add	sp, sp, #8
    1b34:	e8bd8070 	pop	{r4, r5, r6, pc}

00001b38 <soclib_platform_uninit_driver>:

#include <Private/Driver.h>
#include <DnaTools/DnaTools.h>

void  soclib_platform_uninit_driver (void)
{
    1b38:	e12fff1e 	bx	lr

00001b3c <soclib_platform_find_device>:
#include <DnaTools/DnaTools.h>

device_cmd_t * soclib_platform_find_device (const char * name)
{
  return & soclib_tty_commands;
}
    1b3c:	e59f0000 	ldr	r0, [pc]	; 1b44 <soclib_platform_find_device+0x8>
    1b40:	e12fff1e 	bx	lr
    1b44:	000338d4 	.word	0x000338d4

00001b48 <soclib_tty_close>:

status_t soclib_tty_close (void * data)
{

  return DNA_OK;
}
    1b48:	e3a00000 	mov	r0, #0
    1b4c:	e12fff1e 	bx	lr

00001b50 <soclib_ipi_isr>:
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>
#include <Platform/Platform.h>

int32_t soclib_ipi_isr (void * data)
{
    1b50:	e92d4008 	push	{r3, lr}
  int32_t value, command, status;
  int32_t current_cpuid = cpu_mp_id ();
    1b54:	eb003aa3 	bl	105e8 <cpu_mp_id>

  cpu_read (UINT32, & (PLATFORM_IPI_BASE[current_cpuid] . data), value);
    1b58:	e59f304c 	ldr	r3, [pc, #76]	; 1bac <soclib_ipi_isr+0x5c>
    1b5c:	e5932000 	ldr	r2, [r3]
    1b60:	e0823200 	add	r3, r2, r0, lsl #4
    1b64:	e5931004 	ldr	r1, [r3, #4]
  cpu_read (UINT32, & (PLATFORM_IPI_BASE[current_cpuid] . command), command);
    1b68:	e7920200 	ldr	r0, [r2, r0, lsl #4]

  cpu_read (UINT32, & (PLATFORM_IPI_BASE[current_cpuid] . reset), status);
    1b6c:	e593200c 	ldr	r2, [r3, #12]
  
  if (status != 0)
    1b70:	e3520000 	cmp	r2, #0
    1b74:	1a000001 	bne	1b80 <soclib_ipi_isr+0x30>
      default :
        return DNA_UNHANDLED_INTERRUPT;
    }
  }

  return DNA_UNHANDLED_INTERRUPT;
    1b78:	e3a00004 	mov	r0, #4
    1b7c:	e8bd8008 	pop	{r3, pc}

  cpu_read (UINT32, & (PLATFORM_IPI_BASE[current_cpuid] . reset), status);
  
  if (status != 0)
  {
    cpu_write (UINT32, & (PLATFORM_IPI_BASE[current_cpuid] . reset), 0);
    1b80:	e3a02000 	mov	r2, #0
    1b84:	e583200c 	str	r2, [r3, #12]

    switch (ipi_handler (command, (void *)value))
    1b88:	eb003c5f 	bl	10d0c <ipi_handler>
    1b8c:	e3500000 	cmp	r0, #0
    1b90:	0a000003 	beq	1ba4 <soclib_ipi_isr+0x54>

      case DNA_INVOKE_SCHEDULER :
        return DNA_INVOKE_SCHEDULER;

      default :
        return DNA_UNHANDLED_INTERRUPT;
    1b94:	e3500003 	cmp	r0, #3
    1b98:	03a00003 	moveq	r0, #3
    1b9c:	13a00004 	movne	r0, #4
    1ba0:	e8bd8008 	pop	{r3, pc}
    cpu_write (UINT32, & (PLATFORM_IPI_BASE[current_cpuid] . reset), 0);

    switch (ipi_handler (command, (void *)value))
    {
      case DNA_OK :
        return DNA_HANDLED_INTERRUPT;
    1ba4:	e3a00005 	mov	r0, #5
        return DNA_UNHANDLED_INTERRUPT;
    }
  }

  return DNA_UNHANDLED_INTERRUPT;
}
    1ba8:	e8bd8008 	pop	{r3, pc}
    1bac:	0003e960 	.word	0x0003e960

00001bb0 <soclib_tty_free>:
#include <DnaTools/DnaTools.h>

status_t soclib_tty_free (void * data) {

  return DNA_OK;
}
    1bb0:	e3a00000 	mov	r0, #0
    1bb4:	e12fff1e 	bx	lr

00001bb8 <soclib_timer_isr>:
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>
#include <Platform/Platform.h>

int32_t soclib_timer_isr (void * data)
{
    1bb8:	e92d4008 	push	{r3, lr}
  int32_t is_irq = 0, current_cpuid = cpu_mp_id ();
    1bbc:	eb003a89 	bl	105e8 <cpu_mp_id>
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[current_cpuid];
    1bc0:	e59f304c 	ldr	r3, [pc, #76]	; 1c14 <soclib_timer_isr+0x5c>
    1bc4:	e5933000 	ldr	r3, [r3]
    1bc8:	e0830200 	add	r0, r3, r0, lsl #4

  cpu_read (UINT32, & (timer -> irq_ack), is_irq);
    1bcc:	e590300c 	ldr	r3, [r0, #12]

  if (is_irq != 0)
    1bd0:	e3530000 	cmp	r3, #0
    1bd4:	1a000001 	bne	1be0 <soclib_timer_isr+0x28>
      default :
        return DNA_UNHANDLED_INTERRUPT;
    }
  }

  return DNA_UNHANDLED_INTERRUPT;
    1bd8:	e3a00004 	mov	r0, #4
    1bdc:	e8bd8008 	pop	{r3, pc}

  cpu_read (UINT32, & (timer -> irq_ack), is_irq);

  if (is_irq != 0)
  {
    cpu_write(UINT32, & (timer -> irq_ack), 0);
    1be0:	e3a02000 	mov	r2, #0
    cpu_write(UINT32, & (timer -> mode), 1);
    1be4:	e3a03001 	mov	r3, #1

  cpu_read (UINT32, & (timer -> irq_ack), is_irq);

  if (is_irq != 0)
  {
    cpu_write(UINT32, & (timer -> irq_ack), 0);
    1be8:	e580200c 	str	r2, [r0, #12]
    cpu_write(UINT32, & (timer -> mode), 1);
    1bec:	e5803004 	str	r3, [r0, #4]

    switch (alarm_handler ())
    1bf0:	eb003ff6 	bl	11bd0 <alarm_handler>
    1bf4:	e3500000 	cmp	r0, #0
    1bf8:	0a000003 	beq	1c0c <soclib_timer_isr+0x54>

      case DNA_INVOKE_SCHEDULER :
        return DNA_INVOKE_SCHEDULER;

      default :
        return DNA_UNHANDLED_INTERRUPT;
    1bfc:	e3500003 	cmp	r0, #3
    1c00:	03a00003 	moveq	r0, #3
    1c04:	13a00004 	movne	r0, #4
    1c08:	e8bd8008 	pop	{r3, pc}
    cpu_write(UINT32, & (timer -> mode), 1);

    switch (alarm_handler ())
    {
      case DNA_OK :
        return DNA_HANDLED_INTERRUPT;
    1c0c:	e3a00005 	mov	r0, #5
        return DNA_UNHANDLED_INTERRUPT;
    }
  }

  return DNA_UNHANDLED_INTERRUPT;
}
    1c10:	e8bd8008 	pop	{r3, pc}
    1c14:	0003e95c 	.word	0x0003e95c

00001c18 <soclib_platform_init_hardware>:

status_t soclib_platform_init_hardware (void)
{
  soclib_timer_port_t timer;

  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);
    1c18:	e3a03001 	mov	r3, #1

#include <Private/Driver.h>
#include <DnaTools/DnaTools.h>

status_t soclib_platform_init_hardware (void)
{
    1c1c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  soclib_timer_port_t timer;

  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);
    1c20:	e59f804c 	ldr	r8, [pc, #76]	; 1c74 <soclib_platform_init_hardware+0x5c>

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
  {
    timer = & PLATFORM_TIMER_BASE[i];
    cpu_write(UINT32, & (timer -> mode), 1); 
    1c24:	e1a07003 	mov	r7, r3

status_t soclib_platform_init_hardware (void)
{
  soclib_timer_port_t timer;

  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);
    1c28:	e5982000 	ldr	r2, [r8]

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
    1c2c:	e3a04000 	mov	r4, #0

status_t soclib_platform_init_hardware (void)
{
  soclib_timer_port_t timer;

  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);
    1c30:	e5823000 	str	r3, [r2]

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
  {
    timer = & PLATFORM_TIMER_BASE[i];
    1c34:	e59f603c 	ldr	r6, [pc, #60]	; 1c78 <soclib_platform_init_hardware+0x60>
    cpu_write(UINT32, & (timer -> mode), 1); 
    cpu_write (UINT32, & (PLATFORM_AICU_BASE -> slot[i] . mask), 0x3);
    1c38:	e3a05003 	mov	r5, #3
{
  soclib_timer_port_t timer;

  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
    1c3c:	ea000007 	b	1c60 <soclib_platform_init_hardware+0x48>
  {
    timer = & PLATFORM_TIMER_BASE[i];
    1c40:	e5962000 	ldr	r2, [r6]
    cpu_write(UINT32, & (timer -> mode), 1); 
    cpu_write (UINT32, & (PLATFORM_AICU_BASE -> slot[i] . mask), 0x3);
    1c44:	e5983000 	ldr	r3, [r8]
    1c48:	e2841010 	add	r1, r4, #16

  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
  {
    timer = & PLATFORM_TIMER_BASE[i];
    1c4c:	e0822204 	add	r2, r2, r4, lsl #4
    cpu_write(UINT32, & (timer -> mode), 1); 
    cpu_write (UINT32, & (PLATFORM_AICU_BASE -> slot[i] . mask), 0x3);
    1c50:	e0833201 	add	r3, r3, r1, lsl #4
  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
  {
    timer = & PLATFORM_TIMER_BASE[i];
    cpu_write(UINT32, & (timer -> mode), 1); 
    1c54:	e5827004 	str	r7, [r2, #4]
{
  soclib_timer_port_t timer;

  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
    1c58:	e2844001 	add	r4, r4, #1
  {
    timer = & PLATFORM_TIMER_BASE[i];
    cpu_write(UINT32, & (timer -> mode), 1); 
    cpu_write (UINT32, & (PLATFORM_AICU_BASE -> slot[i] . mask), 0x3);
    1c5c:	e5835004 	str	r5, [r3, #4]
{
  soclib_timer_port_t timer;

  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
    1c60:	eb003a93 	bl	106b4 <cpu_mp_count>
    1c64:	e1540000 	cmp	r4, r0
    1c68:	bafffff4 	blt	1c40 <soclib_platform_init_hardware+0x28>
    cpu_write(UINT32, & (timer -> mode), 1); 
    cpu_write (UINT32, & (PLATFORM_AICU_BASE -> slot[i] . mask), 0x3);
  }

  return DNA_OK;
}
    1c6c:	e3a00000 	mov	r0, #0
    1c70:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    1c74:	0003e964 	.word	0x0003e964
    1c78:	0003e95c 	.word	0x0003e95c

00001c7c <soclib_tty_isr>:

#include <Private/Driver.h>
#include <DnaTools/DnaTools.h>

int32_t soclib_tty_isr (void * data)
{
    1c7c:	e92d4008 	push	{r3, lr}
  int32_t index = 0, status, c;

  for (index = 0; index < SOCLIB_TTY_NDEV; index += 1)
    1c80:	e59f3084 	ldr	r3, [pc, #132]	; 1d0c <soclib_tty_isr+0x90>
    1c84:	e593e000 	ldr	lr, [r3]
    1c88:	e35e0000 	cmp	lr, #0
    1c8c:	0a000010 	beq	1cd4 <soclib_tty_isr+0x58>
  {
    cpu_read (UINT32, & (TTY[index] . port -> status), status);
    1c90:	e59f3078 	ldr	r3, [pc, #120]	; 1d10 <soclib_tty_isr+0x94>
    1c94:	e593c000 	ldr	ip, [r3]
    1c98:	e59c100c 	ldr	r1, [ip, #12]
    1c9c:	e5912004 	ldr	r2, [r1, #4]

    if (status != 0)
    1ca0:	e3520000 	cmp	r2, #0
    1ca4:	028c3014 	addeq	r3, ip, #20
    1ca8:	0a000006 	beq	1cc8 <soclib_tty_isr+0x4c>
    1cac:	ea00000a 	b	1cdc <soclib_tty_isr+0x60>
{
  int32_t index = 0, status, c;

  for (index = 0; index < SOCLIB_TTY_NDEV; index += 1)
  {
    cpu_read (UINT32, & (TTY[index] . port -> status), status);
    1cb0:	e593100c 	ldr	r1, [r3, #12]
    1cb4:	e1a0c003 	mov	ip, r3
    1cb8:	e5910004 	ldr	r0, [r1, #4]
    1cbc:	e2833014 	add	r3, r3, #20

    if (status != 0)
    1cc0:	e3500000 	cmp	r0, #0
    1cc4:	1a000004 	bne	1cdc <soclib_tty_isr+0x60>

int32_t soclib_tty_isr (void * data)
{
  int32_t index = 0, status, c;

  for (index = 0; index < SOCLIB_TTY_NDEV; index += 1)
    1cc8:	e2822001 	add	r2, r2, #1
    1ccc:	e152000e 	cmp	r2, lr
    1cd0:	1afffff6 	bne	1cb0 <soclib_tty_isr+0x34>
      semaphore_release (TTY[index] . sem_id, 1, DNA_NO_RESCHEDULE);
      return DNA_INVOKE_SCHEDULER;
    }
  }

  return DNA_UNHANDLED_INTERRUPT;
    1cd4:	e3a00004 	mov	r0, #4
}
    1cd8:	e8bd8008 	pop	{r3, pc}

    if (status != 0)
    {
      cpu_read (UINT32, & (TTY[index] . port -> read), c);

      if (TTY[index] . buffer . empty)
    1cdc:	e5dc2004 	ldrb	r2, [ip, #4]
  {
    cpu_read (UINT32, & (TTY[index] . port -> status), status);

    if (status != 0)
    {
      cpu_read (UINT32, & (TTY[index] . port -> read), c);
    1ce0:	e5913008 	ldr	r3, [r1, #8]

      if (TTY[index] . buffer . empty)
    1ce4:	e3520000 	cmp	r2, #0
      {
        TTY[index] . buffer . empty = false;
    1ce8:	13a02000 	movne	r2, #0
      }

      TTY[index] . buffer . data = c;

      semaphore_release (TTY[index] . sem_id, 1, DNA_NO_RESCHEDULE);
    1cec:	e3a01001 	mov	r1, #1
    {
      cpu_read (UINT32, & (TTY[index] . port -> read), c);

      if (TTY[index] . buffer . empty)
      {
        TTY[index] . buffer . empty = false;
    1cf0:	15cc2004 	strbne	r2, [ip, #4]
      }

      TTY[index] . buffer . data = c;
    1cf4:	e5cc3005 	strb	r3, [ip, #5]

      semaphore_release (TTY[index] . sem_id, 1, DNA_NO_RESCHEDULE);
    1cf8:	e59c0010 	ldr	r0, [ip, #16]
    1cfc:	e1a02001 	mov	r2, r1
    1d00:	eb004559 	bl	1326c <semaphore_release>
      return DNA_INVOKE_SCHEDULER;
    1d04:	e3a00003 	mov	r0, #3
    1d08:	e8bd8008 	pop	{r3, pc}
    1d0c:	0003e968 	.word	0x0003e968
    1d10:	0013e9c4 	.word	0x0013e9c4

00001d14 <soclib_platform_publish_devices>:



const char ** soclib_platform_publish_devices (void)
{
	 return (const char **)soclib_platform_devices;
    1d14:	e59f3004 	ldr	r3, [pc, #4]	; 1d20 <soclib_platform_publish_devices+0xc>
}
    1d18:	e5930000 	ldr	r0, [r3]
    1d1c:	e12fff1e 	bx	lr
    1d20:	0013e9c8 	.word	0x0013e9c8

00001d24 <soclib_fb_isr>:

int32_t soclib_fb_isr (int32_t itn)
{

  return DNA_UNHANDLED_INTERRUPT;
}
    1d24:	e3a00004 	mov	r0, #4
    1d28:	e12fff1e 	bx	lr

00001d2c <soclib_fb_init_driver>:

  /*
   * Create the device name array
   */

  soclib_fb_devices = kernel_malloc (sizeof (char *) *
    1d2c:	e3a01001 	mov	r1, #1
#include <MemoryManager/MemoryManager.h>
#include <Processor/Processor.h>
#include <DnaTools/DnaTools.h>

status_t soclib_fb_init_driver (void)
{
    1d30:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

  /*
   * Create the device name array
   */

  soclib_fb_devices = kernel_malloc (sizeof (char *) *
    1d34:	e59fb0e4 	ldr	fp, [pc, #228]	; 1e20 <soclib_fb_init_driver+0xf4>
#include <MemoryManager/MemoryManager.h>
#include <Processor/Processor.h>
#include <DnaTools/DnaTools.h>

status_t soclib_fb_init_driver (void)
{
    1d38:	e24dd00c 	sub	sp, sp, #12

  /*
   * Create the device name array
   */

  soclib_fb_devices = kernel_malloc (sizeof (char *) *
    1d3c:	e59b0000 	ldr	r0, [fp]
    1d40:	e59f80dc 	ldr	r8, [pc, #220]	; 1e24 <soclib_fb_init_driver+0xf8>
    1d44:	e1a00100 	lsl	r0, r0, #2
    1d48:	e0800001 	add	r0, r0, r1
    1d4c:	eb0048cf 	bl	14090 <kernel_malloc>

  /*
   * Create the FBs
   */

  FB = kernel_malloc (sizeof (soclib_framebuffer_t) * SOCLIB_FB_NDEV, true);
    1d50:	e59b3000 	ldr	r3, [fp]

  /*
   * Create the device name array
   */

  soclib_fb_devices = kernel_malloc (sizeof (char *) *
    1d54:	e5880000 	str	r0, [r8]

  /*
   * Create the FBs
   */

  FB = kernel_malloc (sizeof (soclib_framebuffer_t) * SOCLIB_FB_NDEV, true);
    1d58:	e0830083 	add	r0, r3, r3, lsl #1
    1d5c:	e1a00200 	lsl	r0, r0, #4
    1d60:	e3a01001 	mov	r1, #1
    1d64:	eb0048c9 	bl	14090 <kernel_malloc>
    1d68:	e59f60b8 	ldr	r6, [pc, #184]	; 1e28 <soclib_fb_init_driver+0xfc>
  if (FB == NULL) return DNA_OUT_OF_MEM;
    1d6c:	e3500000 	cmp	r0, #0

  /*
   * Create the FBs
   */

  FB = kernel_malloc (sizeof (soclib_framebuffer_t) * SOCLIB_FB_NDEV, true);
    1d70:	e5860000 	str	r0, [r6]
  if (FB == NULL) return DNA_OUT_OF_MEM;
    1d74:	0a000026 	beq	1e14 <soclib_fb_init_driver+0xe8>

  for (int32_t i = 0; i < SOCLIB_FB_NDEV; i += 1)
    1d78:	e59b3000 	ldr	r3, [fp]
    1d7c:	e3530000 	cmp	r3, #0
    1d80:	0a000020 	beq	1e08 <soclib_fb_init_driver+0xdc>
    1d84:	e3a0a000 	mov	sl, #0
    1d88:	e1a0700a 	mov	r7, sl
    1d8c:	e1a0400a 	mov	r4, sl
    1d90:	e59f9094 	ldr	r9, [pc, #148]	; 1e2c <soclib_fb_init_driver+0x100>
  {
    dna_itoa (i, alpha_index);
    1d94:	e1a00004 	mov	r0, r4
    1d98:	e1a0100d 	mov	r1, sp
    1d9c:	eb003926 	bl	1023c <dna_itoa>
    dna_strcpy (FB[i] . name, "video/simulator/");
    1da0:	e0875087 	add	r5, r7, r7, lsl #1
    1da4:	e5960000 	ldr	r0, [r6]
    1da8:	e1a05205 	lsl	r5, r5, #4
    1dac:	e0800005 	add	r0, r0, r5
    1db0:	e59f1078 	ldr	r1, [pc, #120]	; 1e30 <soclib_fb_init_driver+0x104>
    1db4:	eb0038af 	bl	10078 <dna_strcpy>
    dna_strcat (FB[i] . name, alpha_index);
    1db8:	e5960000 	ldr	r0, [r6]
    1dbc:	e1a0100d 	mov	r1, sp
    1dc0:	e0800005 	add	r0, r0, r5
    1dc4:	eb00382c 	bl	fe7c <dna_strcat>
    soclib_fb_devices[i] = FB[i] . name;
    1dc8:	e5962000 	ldr	r2, [r6]
    1dcc:	e5983000 	ldr	r3, [r8]
    1dd0:	e0822005 	add	r2, r2, r5
    1dd4:	e7832107 	str	r2, [r3, r7, lsl #2]
    FB[i] . config = SOCLIB_FB_DEVICES[i];
    1dd8:	e5962000 	ldr	r2, [r6]
   */

  FB = kernel_malloc (sizeof (soclib_framebuffer_t) * SOCLIB_FB_NDEV, true);
  if (FB == NULL) return DNA_OUT_OF_MEM;

  for (int32_t i = 0; i < SOCLIB_FB_NDEV; i += 1)
    1ddc:	e59b3000 	ldr	r3, [fp]
    1de0:	e2844001 	add	r4, r4, #1
  {
    dna_itoa (i, alpha_index);
    dna_strcpy (FB[i] . name, "video/simulator/");
    dna_strcat (FB[i] . name, alpha_index);
    soclib_fb_devices[i] = FB[i] . name;
    FB[i] . config = SOCLIB_FB_DEVICES[i];
    1de4:	e0825005 	add	r5, r2, r5
   */

  FB = kernel_malloc (sizeof (soclib_framebuffer_t) * SOCLIB_FB_NDEV, true);
  if (FB == NULL) return DNA_OUT_OF_MEM;

  for (int32_t i = 0; i < SOCLIB_FB_NDEV; i += 1)
    1de8:	e1540003 	cmp	r4, r3
  {
    dna_itoa (i, alpha_index);
    dna_strcpy (FB[i] . name, "video/simulator/");
    dna_strcat (FB[i] . name, alpha_index);
    soclib_fb_devices[i] = FB[i] . name;
    FB[i] . config = SOCLIB_FB_DEVICES[i];
    1dec:	e2855020 	add	r5, r5, #32
    1df0:	e089300a 	add	r3, r9, sl
    1df4:	e8930007 	ldm	r3, {r0, r1, r2}
    1df8:	e28aa00c 	add	sl, sl, #12
    1dfc:	e8850007 	stm	r5, {r0, r1, r2}
   */

  FB = kernel_malloc (sizeof (soclib_framebuffer_t) * SOCLIB_FB_NDEV, true);
  if (FB == NULL) return DNA_OUT_OF_MEM;

  for (int32_t i = 0; i < SOCLIB_FB_NDEV; i += 1)
    1e00:	e1a07004 	mov	r7, r4
    1e04:	3affffe2 	bcc	1d94 <soclib_fb_init_driver+0x68>
    dna_strcat (FB[i] . name, alpha_index);
    soclib_fb_devices[i] = FB[i] . name;
    FB[i] . config = SOCLIB_FB_DEVICES[i];
  }

  return DNA_OK;
    1e08:	e3a00000 	mov	r0, #0
}
    1e0c:	e28dd00c 	add	sp, sp, #12
    1e10:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  /*
   * Create the FBs
   */

  FB = kernel_malloc (sizeof (soclib_framebuffer_t) * SOCLIB_FB_NDEV, true);
  if (FB == NULL) return DNA_OUT_OF_MEM;
    1e14:	e59f0018 	ldr	r0, [pc, #24]	; 1e34 <soclib_fb_init_driver+0x108>
    soclib_fb_devices[i] = FB[i] . name;
    FB[i] . config = SOCLIB_FB_DEVICES[i];
  }

  return DNA_OK;
}
    1e18:	e28dd00c 	add	sp, sp, #12
    1e1c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1e20:	0003e984 	.word	0x0003e984
    1e24:	0013e9cc 	.word	0x0013e9cc
    1e28:	0013e9d0 	.word	0x0013e9d0
    1e2c:	0003e988 	.word	0x0003e988
    1e30:	00032790 	.word	0x00032790
    1e34:	0000fffd 	.word	0x0000fffd

00001e38 <soclib_fb_find_device>:
#include <DnaTools/DnaTools.h>

device_cmd_t * soclib_fb_find_device (const char * name)
{
  return & soclib_fb_commands;
}
    1e38:	e59f0000 	ldr	r0, [pc]	; 1e40 <soclib_fb_find_device+0x8>
    1e3c:	e12fff1e 	bx	lr
    1e40:	0003391c 	.word	0x0003391c

00001e44 <soclib_fb_open>:
#include <Private/Driver.h>
#include <Processor/Processor.h>
#include <DnaTools/DnaTools.h>

status_t soclib_fb_open (char * name, int32_t mode, void ** data)
{
    1e44:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}

  for (int32_t index = 0; FB[index] . name != NULL; index += 1)
    1e48:	e59f505c 	ldr	r5, [pc, #92]	; 1eac <soclib_fb_open+0x68>
    1e4c:	e5951000 	ldr	r1, [r5]
    1e50:	e3510000 	cmp	r1, #0
    1e54:	0a000012 	beq	1ea4 <soclib_fb_open+0x60>
    1e58:	e1a06000 	mov	r6, r0
    1e5c:	e1a08002 	mov	r8, r2
    1e60:	e3a04030 	mov	r4, #48	; 0x30
    1e64:	e3a07000 	mov	r7, #0
    1e68:	ea000005 	b	1e84 <soclib_fb_open+0x40>
    1e6c:	e5951000 	ldr	r1, [r5]
    1e70:	e2843030 	add	r3, r4, #48	; 0x30
    1e74:	e0911004 	adds	r1, r1, r4
    1e78:	0a000009 	beq	1ea4 <soclib_fb_open+0x60>
    1e7c:	e1a07004 	mov	r7, r4
    1e80:	e1a04003 	mov	r4, r3
  {
    if (dna_strcmp (name, FB[index] . name) == 0)
    1e84:	e1a00006 	mov	r0, r6
    1e88:	eb00380c 	bl	fec0 <dna_strcmp>
    1e8c:	e3500000 	cmp	r0, #0
    1e90:	1afffff5 	bne	1e6c <soclib_fb_open+0x28>
    {
      *data = & FB[index];
    1e94:	e5953000 	ldr	r3, [r5]
    1e98:	e0837007 	add	r7, r3, r7
    1e9c:	e5887000 	str	r7, [r8]
      return DNA_OK;
    1ea0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }
  }

  return DNA_ERROR;
    1ea4:	e59f0004 	ldr	r0, [pc, #4]	; 1eb0 <soclib_fb_open+0x6c>
}
    1ea8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    1eac:	0013e9d0 	.word	0x0013e9d0
    1eb0:	0000ffff 	.word	0x0000ffff

00001eb4 <soclib_fb_init_hardware>:
#include <DnaTools/DnaTools.h>

status_t soclib_fb_init_hardware (void)
{
  return DNA_OK;
}
    1eb4:	e3a00000 	mov	r0, #0
    1eb8:	e12fff1e 	bx	lr

00001ebc <soclib_fb_free>:
#include <DnaTools/DnaTools.h>

status_t soclib_fb_free (void * data)
{
  return DNA_OK;
}
    1ebc:	e3a00000 	mov	r0, #0
    1ec0:	e12fff1e 	bx	lr

00001ec4 <soclib_fb_read>:
#include <Private/Driver.h>
#include <DnaTools/DnaTools.h>

status_t soclib_fb_read (void * handler, void * destination,
    int64_t offset, int32_t * p_count)
{
    1ec4:	e92d4008 	push	{r3, lr}
    1ec8:	e59d3008 	ldr	r3, [sp, #8]
  soclib_framebuffer_t * fb = handler;
  uint8_t * source = fb -> config . buffer + offset;
    1ecc:	e5900028 	ldr	r0, [r0, #40]	; 0x28


  cpu_vector_read (UINT8, destination, source, *p_count);
    1ed0:	e0800002 	add	r0, r0, r2
    1ed4:	e5932000 	ldr	r2, [r3]
    1ed8:	eb003924 	bl	10370 <cpu_vector_transfer>
  return DNA_OK;
}
    1edc:	e3a00000 	mov	r0, #0
    1ee0:	e8bd8008 	pop	{r3, pc}

00001ee4 <soclib_fb_publish_devices>:

#include <Private/Driver.h>

const char ** soclib_fb_publish_devices (void)
{
  return (const char **) soclib_fb_devices;
    1ee4:	e59f3004 	ldr	r3, [pc, #4]	; 1ef0 <soclib_fb_publish_devices+0xc>
}
    1ee8:	e5930000 	ldr	r0, [r3]
    1eec:	e12fff1e 	bx	lr
    1ef0:	0013e9cc 	.word	0x0013e9cc

00001ef4 <soclib_fb_write>:
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>

status_t soclib_fb_write (void * handler, void * source,
    int64_t offset, int32_t * p_count)
{
    1ef4:	e92d4070 	push	{r4, r5, r6, lr}
    1ef8:	e1a04000 	mov	r4, r0
  soclib_framebuffer_t * fb = handler;
  uint8_t * destination = NULL;

  if (fb -> autorewind)
    1efc:	e5d0002c 	ldrb	r0, [r0, #44]	; 0x2c
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>

status_t soclib_fb_write (void * handler, void * source,
    int64_t offset, int32_t * p_count)
{
    1f00:	e1a06001 	mov	r6, r1
  soclib_framebuffer_t * fb = handler;
  uint8_t * destination = NULL;

  if (fb -> autorewind)
    1f04:	e3500000 	cmp	r0, #0
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>

status_t soclib_fb_write (void * handler, void * source,
    int64_t offset, int32_t * p_count)
{
    1f08:	e59d5010 	ldr	r5, [sp, #16]
  soclib_framebuffer_t * fb = handler;
  uint8_t * destination = NULL;

  if (fb -> autorewind)
    1f0c:	0a000007 	beq	1f30 <soclib_fb_write+0x3c>
  {
    offset = offset % (fb -> config . width * fb -> config . height * 2);
    1f10:	e5941020 	ldr	r1, [r4, #32]
    1f14:	e594c024 	ldr	ip, [r4, #36]	; 0x24
    1f18:	e1a00002 	mov	r0, r2
    1f1c:	e002019c 	mul	r2, ip, r1
    1f20:	e1a01003 	mov	r1, r3
    1f24:	e1a02082 	lsl	r2, r2, #1
    1f28:	e3a03000 	mov	r3, #0
    1f2c:	eb004c82 	bl	1513c <__aeabi_ldivmod>
  }

  destination = fb -> config . buffer + offset;
    1f30:	e5941028 	ldr	r1, [r4, #40]	; 0x28

  dna_log(VERBOSE_LEVEL, "FB: %d bytes @ 0x%x offset to 0x%x",
      *p_count, (int32_t)offset, destination);

  cpu_vector_write (UINT8, destination, source, *p_count);
    1f34:	e1a00006 	mov	r0, r6
    1f38:	e0811002 	add	r1, r1, r2
    1f3c:	e5952000 	ldr	r2, [r5]
    1f40:	eb00390a 	bl	10370 <cpu_vector_transfer>
  return DNA_OK;
}
    1f44:	e3a00000 	mov	r0, #0
    1f48:	e8bd8070 	pop	{r4, r5, r6, pc}

00001f4c <soclib_fb_control>:
    va_list arguments, int32_t * p_ret)
{
  soclib_framebuffer_t * fb = (soclib_framebuffer_t *) handler;
  bool value = va_arg(arguments, int32_t);

  switch (function)
    1f4c:	e59fc02c 	ldr	ip, [pc, #44]	; 1f80 <soclib_fb_control+0x34>

status_t soclib_fb_control (void * handler, int32_t function,
    va_list arguments, int32_t * p_ret)
{
  soclib_framebuffer_t * fb = (soclib_framebuffer_t *) handler;
  bool value = va_arg(arguments, int32_t);
    1f50:	e5922000 	ldr	r2, [r2]

  switch (function)
    1f54:	e151000c 	cmp	r1, ip
    1f58:	0a000001 	beq	1f64 <soclib_fb_control+0x18>
      fb -> autorewind = value;
      *p_ret = 0;
      break;

    default:
      return DNA_ERROR;
    1f5c:	e59f0020 	ldr	r0, [pc, #32]	; 1f84 <soclib_fb_control+0x38>
  }

  return DNA_OK;
}
    1f60:	e12fff1e 	bx	lr

status_t soclib_fb_control (void * handler, int32_t function,
    va_list arguments, int32_t * p_ret)
{
  soclib_framebuffer_t * fb = (soclib_framebuffer_t *) handler;
  bool value = va_arg(arguments, int32_t);
    1f64:	e2922000 	adds	r2, r2, #0
  {
    case FB_SET_AUTOREWIND:
      dna_log(INFO_LEVEL, "Setting autorewind to 0x%x", value);

      fb -> autorewind = value;
      *p_ret = 0;
    1f68:	e3a01000 	mov	r1, #0

status_t soclib_fb_control (void * handler, int32_t function,
    va_list arguments, int32_t * p_ret)
{
  soclib_framebuffer_t * fb = (soclib_framebuffer_t *) handler;
  bool value = va_arg(arguments, int32_t);
    1f6c:	13a02001 	movne	r2, #1
    1f70:	e5c0202c 	strb	r2, [r0, #44]	; 0x2c

    default:
      return DNA_ERROR;
  }

  return DNA_OK;
    1f74:	e1a00001 	mov	r0, r1
  {
    case FB_SET_AUTOREWIND:
      dna_log(INFO_LEVEL, "Setting autorewind to 0x%x", value);

      fb -> autorewind = value;
      *p_ret = 0;
    1f78:	e5831000 	str	r1, [r3]

    default:
      return DNA_ERROR;
  }

  return DNA_OK;
    1f7c:	e12fff1e 	bx	lr
    1f80:	00000fff 	.word	0x00000fff
    1f84:	0000ffff 	.word	0x0000ffff

00001f88 <soclib_fb_uninit_driver>:

#include <Private/Driver.h>
#include <DnaTools/DnaTools.h>

void  soclib_fb_uninit_driver (void)
{
    1f88:	e12fff1e 	bx	lr

00001f8c <soclib_fb_close>:

status_t soclib_fb_close (void * data)
{

  return DNA_OK;
}
    1f8c:	e3a00000 	mov	r0, #0
    1f90:	e12fff1e 	bx	lr

00001f94 <block_device_init_driver>:
#include <DnaTools/DnaTools.h>

block_device_control_t * block_device_controls ;

status_t block_device_init_driver (void)
{
    1f94:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
  char alpha_num[8], semaphore_name_buffer[64], * semaphore_prefix = "block_device_" ;
  char isr_semaphore_name[64] ;
  
  watch (status_t)
  {
    block_device_controls = kernel_malloc (sizeof (block_device_control_t) * 
    1f98:	e59f8144 	ldr	r8, [pc, #324]	; 20e4 <block_device_init_driver+0x150>
#include <DnaTools/DnaTools.h>

block_device_control_t * block_device_controls ;

status_t block_device_init_driver (void)
{
    1f9c:	e24dd090 	sub	sp, sp, #144	; 0x90
  char alpha_num[8], semaphore_name_buffer[64], * semaphore_prefix = "block_device_" ;
  char isr_semaphore_name[64] ;
  
  watch (status_t)
  {
    block_device_controls = kernel_malloc (sizeof (block_device_control_t) * 
    1fa0:	e5983000 	ldr	r3, [r8]
    1fa4:	e3a01001 	mov	r1, #1
    1fa8:	e0630183 	rsb	r0, r3, r3, lsl #3
    1fac:	e1a00100 	lsl	r0, r0, #2
    1fb0:	eb004836 	bl	14090 <kernel_malloc>
    1fb4:	e59f712c 	ldr	r7, [pc, #300]	; 20e8 <block_device_init_driver+0x154>
        SOCLIB_BLOCK_DEVICES_NDEV, true) ;
    ensure (block_device_controls != NULL, DNA_OUT_OF_MEM) ;
    1fb8:	e3500000 	cmp	r0, #0
  char alpha_num[8], semaphore_name_buffer[64], * semaphore_prefix = "block_device_" ;
  char isr_semaphore_name[64] ;
  
  watch (status_t)
  {
    block_device_controls = kernel_malloc (sizeof (block_device_control_t) * 
    1fbc:	e5870000 	str	r0, [r7]
        SOCLIB_BLOCK_DEVICES_NDEV, true) ;
    ensure (block_device_controls != NULL, DNA_OUT_OF_MEM) ;
    1fc0:	0a000044 	beq	20d8 <block_device_init_driver+0x144>
    

    for (i = 0 ; i < SOCLIB_BLOCK_DEVICES_NDEV ; i++)
    1fc4:	e5983000 	ldr	r3, [r8]
    1fc8:	e3530000 	cmp	r3, #0
    1fcc:	da00003e 	ble	20cc <block_device_init_driver+0x138>
    1fd0:	e3a04000 	mov	r4, #0
      dna_strcpy (semaphore_name_buffer, semaphore_prefix) ;
      dna_strcat (semaphore_name_buffer, alpha_num) ;
      dna_strcat (semaphore_name_buffer, "_sem") ;

      semaphore_create (semaphore_name_buffer, 1, 
          &block_device_controls[i] . semaphore_id) ;
    1fd4:	e1a09007 	mov	r9, r7
    block_device_controls = kernel_malloc (sizeof (block_device_control_t) * 
        SOCLIB_BLOCK_DEVICES_NDEV, true) ;
    ensure (block_device_controls != NULL, DNA_OUT_OF_MEM) ;
    

    for (i = 0 ; i < SOCLIB_BLOCK_DEVICES_NDEV ; i++)
    1fd8:	e1a06004 	mov	r6, r4
    1fdc:	e59f5108 	ldr	r5, [pc, #264]	; 20ec <block_device_init_driver+0x158>
    1fe0:	ea000004 	b	1ff8 <block_device_init_driver+0x64>
    1fe4:	e5983000 	ldr	r3, [r8]
    1fe8:	e284401c 	add	r4, r4, #28
    1fec:	e1530006 	cmp	r3, r6
    1ff0:	e285500c 	add	r5, r5, #12
    1ff4:	da000034 	ble	20cc <block_device_init_driver+0x138>
    {
      dna_itoa (i, alpha_num) ;
    1ff8:	e1a00006 	mov	r0, r6
    1ffc:	e28d1008 	add	r1, sp, #8
    2000:	eb00388d 	bl	1023c <dna_itoa>
      dna_strcpy (semaphore_name_buffer, semaphore_prefix) ;
    2004:	e59f10e4 	ldr	r1, [pc, #228]	; 20f0 <block_device_init_driver+0x15c>
    2008:	e28d0010 	add	r0, sp, #16
    200c:	eb003819 	bl	10078 <dna_strcpy>
      dna_strcat (semaphore_name_buffer, alpha_num) ;
    2010:	e28d1008 	add	r1, sp, #8
    2014:	e28d0010 	add	r0, sp, #16
    2018:	eb003797 	bl	fe7c <dna_strcat>
      dna_strcat (semaphore_name_buffer, "_sem") ;
    201c:	e59f10d0 	ldr	r1, [pc, #208]	; 20f4 <block_device_init_driver+0x160>
    2020:	e28d0010 	add	r0, sp, #16
    2024:	eb003794 	bl	fe7c <dna_strcat>

      semaphore_create (semaphore_name_buffer, 1, 
          &block_device_controls[i] . semaphore_id) ;
    2028:	e5972000 	ldr	r2, [r7]
      dna_itoa (i, alpha_num) ;
      dna_strcpy (semaphore_name_buffer, semaphore_prefix) ;
      dna_strcat (semaphore_name_buffer, alpha_num) ;
      dna_strcat (semaphore_name_buffer, "_sem") ;

      semaphore_create (semaphore_name_buffer, 1, 
    202c:	e3a01001 	mov	r1, #1
    2030:	e0822004 	add	r2, r2, r4
    2034:	e28d0010 	add	r0, sp, #16
    2038:	eb0043e8 	bl	12fe0 <semaphore_create>
          &block_device_controls[i] . semaphore_id) ;

      block_device_controls[i] . should_enable_irq = 
        (bool) SOCLIB_BLOCK_DEVICES[i] . should_enable_irq ;
    203c:	e5151008 	ldr	r1, [r5, #-8]
      block_device_controls[i] . port = 
        (block_device_register_map_t) SOCLIB_BLOCK_DEVICES[i] . base_address ;
    2040:	e5952000 	ldr	r2, [r5]

      semaphore_create (semaphore_name_buffer, 1, 
          &block_device_controls[i] . semaphore_id) ;

      block_device_controls[i] . should_enable_irq = 
        (bool) SOCLIB_BLOCK_DEVICES[i] . should_enable_irq ;
    2044:	e2911000 	adds	r1, r1, #0
    2048:	13a01001 	movne	r1, #1
      dna_strcat (semaphore_name_buffer, "_sem") ;

      semaphore_create (semaphore_name_buffer, 1, 
          &block_device_controls[i] . semaphore_id) ;

      block_device_controls[i] . should_enable_irq = 
    204c:	e5973000 	ldr	r3, [r7]
        (bool) SOCLIB_BLOCK_DEVICES[i] . should_enable_irq ;
      block_device_controls[i] . port = 
        (block_device_register_map_t) SOCLIB_BLOCK_DEVICES[i] . base_address ;

      cpu_read (UINT32, 
    2050:	e5920018 	ldr	r0, [r2, #24]
      dna_strcat (semaphore_name_buffer, "_sem") ;

      semaphore_create (semaphore_name_buffer, 1, 
          &block_device_controls[i] . semaphore_id) ;

      block_device_controls[i] . should_enable_irq = 
    2054:	e0833004 	add	r3, r3, r4
        (bool) SOCLIB_BLOCK_DEVICES[i] . should_enable_irq ;
      block_device_controls[i] . port = 
        (block_device_register_map_t) SOCLIB_BLOCK_DEVICES[i] . base_address ;

      cpu_read (UINT32, 
    2058:	e5830010 	str	r0, [r3, #16]
          & (block_device_controls[i] . port -> BLOCK_DEVICE_SIZE), 
          block_device_controls[i] . block_count) ;
      cpu_read (UINT32, 
    205c:	e592001c 	ldr	r0, [r2, #28]
          & (block_device_controls[i] . port -> BLOCK_DEVICE_BLOCK_SIZE), 
          block_device_controls[i] . block_size) ;

      if (block_device_controls[i] . should_enable_irq) {
    2060:	e3510000 	cmp	r1, #0
    block_device_controls = kernel_malloc (sizeof (block_device_control_t) * 
        SOCLIB_BLOCK_DEVICES_NDEV, true) ;
    ensure (block_device_controls != NULL, DNA_OUT_OF_MEM) ;
    

    for (i = 0 ; i < SOCLIB_BLOCK_DEVICES_NDEV ; i++)
    2064:	e2866001 	add	r6, r6, #1
      semaphore_create (semaphore_name_buffer, 1, 
          &block_device_controls[i] . semaphore_id) ;

      block_device_controls[i] . should_enable_irq = 
        (bool) SOCLIB_BLOCK_DEVICES[i] . should_enable_irq ;
      block_device_controls[i] . port = 
    2068:	e5832018 	str	r2, [r3, #24]
        (block_device_register_map_t) SOCLIB_BLOCK_DEVICES[i] . base_address ;

      cpu_read (UINT32, 
          & (block_device_controls[i] . port -> BLOCK_DEVICE_SIZE), 
          block_device_controls[i] . block_count) ;
      cpu_read (UINT32, 
    206c:	e5830014 	str	r0, [r3, #20]
      dna_strcat (semaphore_name_buffer, "_sem") ;

      semaphore_create (semaphore_name_buffer, 1, 
          &block_device_controls[i] . semaphore_id) ;

      block_device_controls[i] . should_enable_irq = 
    2070:	e5c31008 	strb	r1, [r3, #8]
          block_device_controls[i] . block_count) ;
      cpu_read (UINT32, 
          & (block_device_controls[i] . port -> BLOCK_DEVICE_BLOCK_SIZE), 
          block_device_controls[i] . block_size) ;

      if (block_device_controls[i] . should_enable_irq) {
    2074:	0affffda 	beq	1fe4 <block_device_init_driver+0x50>
        block_device_controls[i] . irq = SOCLIB_BLOCK_DEVICES[i] . irq ;
        interrupt_attach (0, SOCLIB_BLOCK_DEVICES[i] . irq, 0x0, 
    2078:	e3a0a000 	mov	sl, #0
      cpu_read (UINT32, 
          & (block_device_controls[i] . port -> BLOCK_DEVICE_BLOCK_SIZE), 
          block_device_controls[i] . block_size) ;

      if (block_device_controls[i] . should_enable_irq) {
        block_device_controls[i] . irq = SOCLIB_BLOCK_DEVICES[i] . irq ;
    207c:	e5151004 	ldr	r1, [r5, #-4]
        interrupt_attach (0, SOCLIB_BLOCK_DEVICES[i] . irq, 0x0, 
    2080:	e1a0200a 	mov	r2, sl
      cpu_read (UINT32, 
          & (block_device_controls[i] . port -> BLOCK_DEVICE_BLOCK_SIZE), 
          block_device_controls[i] . block_size) ;

      if (block_device_controls[i] . should_enable_irq) {
        block_device_controls[i] . irq = SOCLIB_BLOCK_DEVICES[i] . irq ;
    2084:	e583100c 	str	r1, [r3, #12]
        interrupt_attach (0, SOCLIB_BLOCK_DEVICES[i] . irq, 0x0, 
    2088:	e1a0000a 	mov	r0, sl
    208c:	e59f3064 	ldr	r3, [pc, #100]	; 20f8 <block_device_init_driver+0x164>
    2090:	e58da000 	str	sl, [sp]
    2094:	eb004505 	bl	134b0 <interrupt_attach>
            block_device_isr, false) ;
        dna_strcpy (isr_semaphore_name, semaphore_name_buffer) ;
    2098:	e28d1010 	add	r1, sp, #16
    209c:	e28d0050 	add	r0, sp, #80	; 0x50
    20a0:	eb0037f4 	bl	10078 <dna_strcpy>
        dna_strcat (isr_semaphore_name, "_isr") ;
    20a4:	e28d0050 	add	r0, sp, #80	; 0x50
    20a8:	e59f104c 	ldr	r1, [pc, #76]	; 20fc <block_device_init_driver+0x168>
    20ac:	eb003772 	bl	fe7c <dna_strcat>
        semaphore_create (isr_semaphore_name, 0, 
            &block_device_controls[i] . isr_semaphore_id) ;
    20b0:	e5992000 	ldr	r2, [r9]
        block_device_controls[i] . irq = SOCLIB_BLOCK_DEVICES[i] . irq ;
        interrupt_attach (0, SOCLIB_BLOCK_DEVICES[i] . irq, 0x0, 
            block_device_isr, false) ;
        dna_strcpy (isr_semaphore_name, semaphore_name_buffer) ;
        dna_strcat (isr_semaphore_name, "_isr") ;
        semaphore_create (isr_semaphore_name, 0, 
    20b4:	e28d0050 	add	r0, sp, #80	; 0x50
            &block_device_controls[i] . isr_semaphore_id) ;
    20b8:	e0822004 	add	r2, r2, r4
        block_device_controls[i] . irq = SOCLIB_BLOCK_DEVICES[i] . irq ;
        interrupt_attach (0, SOCLIB_BLOCK_DEVICES[i] . irq, 0x0, 
            block_device_isr, false) ;
        dna_strcpy (isr_semaphore_name, semaphore_name_buffer) ;
        dna_strcat (isr_semaphore_name, "_isr") ;
        semaphore_create (isr_semaphore_name, 0, 
    20bc:	e1a0100a 	mov	r1, sl
    20c0:	e2822004 	add	r2, r2, #4
    20c4:	eb0043c5 	bl	12fe0 <semaphore_create>
    20c8:	eaffffc5 	b	1fe4 <block_device_init_driver+0x50>
            &block_device_controls[i] . isr_semaphore_id) ;
      }

    }

    return DNA_OK ;
    20cc:	e3a00000 	mov	r0, #0
  }
}
    20d0:	e28dd090 	add	sp, sp, #144	; 0x90
    20d4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
  
  watch (status_t)
  {
    block_device_controls = kernel_malloc (sizeof (block_device_control_t) * 
        SOCLIB_BLOCK_DEVICES_NDEV, true) ;
    ensure (block_device_controls != NULL, DNA_OUT_OF_MEM) ;
    20d8:	e59f0020 	ldr	r0, [pc, #32]	; 2100 <block_device_init_driver+0x16c>

    }

    return DNA_OK ;
  }
}
    20dc:	e28dd090 	add	sp, sp, #144	; 0x90
    20e0:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    20e4:	0003e974 	.word	0x0003e974
    20e8:	0013ea24 	.word	0x0013ea24
    20ec:	0003e980 	.word	0x0003e980
    20f0:	000327b0 	.word	0x000327b0
    20f4:	00032778 	.word	0x00032778
    20f8:	0000211c 	.word	0x0000211c
    20fc:	000327c0 	.word	0x000327c0
    2100:	0000fffd 	.word	0x0000fffd

00002104 <block_device_open>:


status_t block_device_open (char * name, int32_t mode, void ** data)
{
  
  block_device_control_t * block_device_p = block_device_controls ;
    2104:	e59f300c 	ldr	r3, [pc, #12]	; 2118 <block_device_open+0x14>
  *data = (void *) block_device_p ;
  return DNA_OK ;
}
    2108:	e3a00000 	mov	r0, #0


status_t block_device_open (char * name, int32_t mode, void ** data)
{
  
  block_device_control_t * block_device_p = block_device_controls ;
    210c:	e5933000 	ldr	r3, [r3]
  *data = (void *) block_device_p ;
    2110:	e5823000 	str	r3, [r2]
  return DNA_OK ;
}
    2114:	e12fff1e 	bx	lr
    2118:	0013ea24 	.word	0x0013ea24

0000211c <block_device_isr>:
#include <Private/SoclibBlockDeviceDriver.h>
#include <Core/Core.h>
#include <DnaTools/DnaTools.h>

int32_t block_device_isr (void * data)
{
    211c:	e92d4008 	push	{r3, lr}
  uint32_t operation_status ;
  
  block_device_control_t block_device = block_device_controls[0] ;
    2120:	e59f3034 	ldr	r3, [pc, #52]	; 215c <block_device_isr+0x40>
    2124:	e5933000 	ldr	r3, [r3]
    2128:	e5932018 	ldr	r2, [r3, #24]
    212c:	e5930004 	ldr	r0, [r3, #4]
  dna_log(VERBOSE_LEVEL, "Entering ISR") ;

  watch (status_t)
  {
    // ISR ACK
    cpu_read (UINT32, & (block_device . port -> BLOCK_DEVICE_STATUS), operation_status) ;
    2130:	e5923010 	ldr	r3, [r2, #16]
    ensure (operation_status == BLOCK_DEVICE_READ_SUCCESS || operation_status == BLOCK_DEVICE_WRITE_SUCCESS, DNA_ERROR) ;
    2134:	e2433002 	sub	r3, r3, #2
    2138:	e3530001 	cmp	r3, #1
    213c:	9a000001 	bls	2148 <block_device_isr+0x2c>
    2140:	e59f0018 	ldr	r0, [pc, #24]	; 2160 <block_device_isr+0x44>
    dna_log(VERBOSE_LEVEL, "Operation succeeded.") ;

    semaphore_release (block_device . isr_semaphore_id, 1, DNA_NO_RESCHEDULE) ;
    return DNA_INVOKE_SCHEDULER ;
  }
}
    2144:	e8bd8008 	pop	{r3, pc}
    cpu_read (UINT32, & (block_device . port -> BLOCK_DEVICE_STATUS), operation_status) ;
    ensure (operation_status == BLOCK_DEVICE_READ_SUCCESS || operation_status == BLOCK_DEVICE_WRITE_SUCCESS, DNA_ERROR) ;

    dna_log(VERBOSE_LEVEL, "Operation succeeded.") ;

    semaphore_release (block_device . isr_semaphore_id, 1, DNA_NO_RESCHEDULE) ;
    2148:	e3a01001 	mov	r1, #1
    214c:	e1a02001 	mov	r2, r1
    2150:	eb004445 	bl	1326c <semaphore_release>
    return DNA_INVOKE_SCHEDULER ;
    2154:	e3a00003 	mov	r0, #3
    2158:	e8bd8008 	pop	{r3, pc}
    215c:	0013ea24 	.word	0x0013ea24
    2160:	0000ffff 	.word	0x0000ffff

00002164 <block_device_write>:
#include <DnaTools/DnaTools.h>


status_t block_device_write (void * handler, void * source, 
        int64_t offset, int32_t * p_count)
{
    2164:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

  dna_log(VERBOSE_LEVEL, "Writing %d bytes with offset %d from source 0x%x",
      *p_count, offset, source) ;
  watch (status_t)
  {
    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;
    2168:	e3e06000 	mvn	r6, #0
    216c:	e3e07000 	mvn	r7, #0
#include <DnaTools/DnaTools.h>


status_t block_device_write (void * handler, void * source, 
        int64_t offset, int32_t * p_count)
{
    2170:	e1a08000 	mov	r8, r0
    2174:	e1a04002 	mov	r4, r2
    2178:	e1a05003 	mov	r5, r3
    217c:	e24dd014 	sub	sp, sp, #20

  dna_log(VERBOSE_LEVEL, "Writing %d bytes with offset %d from source 0x%x",
      *p_count, offset, source) ;
  watch (status_t)
  {
    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;
    2180:	e5900000 	ldr	r0, [r0]
    2184:	e3a02000 	mov	r2, #0
    2188:	e1cd60f0 	strd	r6, [sp]
#include <DnaTools/DnaTools.h>


status_t block_device_write (void * handler, void * source, 
        int64_t offset, int32_t * p_count)
{
    218c:	e1a09001 	mov	r9, r1

  dna_log(VERBOSE_LEVEL, "Writing %d bytes with offset %d from source 0x%x",
      *p_count, offset, source) ;
  watch (status_t)
  {
    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;
    2190:	e3a01001 	mov	r1, #1
    2194:	eb003f70 	bl	11f5c <semaphore_acquire>

    block_start = offset / block_device -> block_size ;
    2198:	e598b014 	ldr	fp, [r8, #20]
    219c:	e1a00004 	mov	r0, r4
    21a0:	e1a07fcb 	asr	r7, fp, #31
    21a4:	e1a03007 	mov	r3, r7
    21a8:	e1a0200b 	mov	r2, fp
    21ac:	e1a01005 	mov	r1, r5
    21b0:	eb004be1 	bl	1513c <__aeabi_ldivmod>
    block_end = (offset + *p_count) / block_device -> block_size ;
    21b4:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
      *p_count, offset, source) ;
  watch (status_t)
  {
    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;

    block_start = offset / block_device -> block_size ;
    21b8:	e1a0a000 	mov	sl, r0
    block_end = (offset + *p_count) / block_device -> block_size ;
    21bc:	e5930000 	ldr	r0, [r3]
    21c0:	e1a03007 	mov	r3, r7
    21c4:	e0946000 	adds	r6, r4, r0
    21c8:	e0a57fc0 	adc	r7, r5, r0, asr #31
    21cc:	e1a0200b 	mov	r2, fp
    21d0:	e1a00006 	mov	r0, r6
    21d4:	e1a01007 	mov	r1, r7
    21d8:	eb004bd7 	bl	1513c <__aeabi_ldivmod>
    nb_blocks = block_end - block_start + 1 ;
    21dc:	e06a0000 	rsb	r0, sl, r0
    21e0:	e2806001 	add	r6, r0, #1

    bulk_buffer = kernel_malloc (nb_blocks *
    21e4:	e0000b96 	mul	r0, r6, fp
    21e8:	e3a01000 	mov	r1, #0
    21ec:	eb0047a7 	bl	14090 <kernel_malloc>
        block_device -> block_size, false) ;
    bulk_buffer_base_address = bulk_buffer ;
    ensure (bulk_buffer != NULL, DNA_OUT_OF_MEM) ;
    21f0:	e2507000 	subs	r7, r0, #0
    21f4:	059f4174 	ldreq	r4, [pc, #372]	; 2370 <block_device_write+0x20c>
    21f8:	0a00000f 	beq	223c <block_device_write+0xd8>

    ensure (
    21fc:	e5982014 	ldr	r2, [r8, #20]
    2200:	e1a00004 	mov	r0, r4
    2204:	e1a03fc2 	asr	r3, r2, #31
    2208:	e1a01005 	mov	r1, r5
    220c:	eb004bca 	bl	1513c <__aeabi_ldivmod>
    2210:	e1a03001 	mov	r3, r1
    2214:	e3a01000 	mov	r1, #0
    2218:	e1a02000 	mov	r2, r0
    221c:	e58d1004 	str	r1, [sp, #4]
    2220:	e58d6000 	str	r6, [sp]
    2224:	e1a00008 	mov	r0, r8
    2228:	e1a01007 	mov	r1, r7
    222c:	eb000121 	bl	26b8 <access_device_blocks>
    2230:	e3500000 	cmp	r0, #0
    2234:	0a000003 	beq	2248 <block_device_write+0xe4>
    2238:	e59f4134 	ldr	r4, [pc, #308]	; 2374 <block_device_write+0x210>
    semaphore_release (block_device -> semaphore_id, 1, DNA_NO_RESCHEDULE) ;
    return DNA_OK ;
  }

  return DNA_NOT_IMPLEMENTED ;
}
    223c:	e1a00004 	mov	r0, r4
    2240:	e28dd014 	add	sp, sp, #20
    2244:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                           offset / block_device -> block_size, 
                           nb_blocks,
                           READ) 
        == DNA_OK, DNA_ERROR) ;

    cpu_cache_invalidate (CPU_CACHE_DATA, bulk_buffer, 
    2248:	e5982014 	ldr	r2, [r8, #20]
    224c:	e3a00001 	mov	r0, #1
    2250:	e0020692 	mul	r2, r2, r6
    2254:	e1a01007 	mov	r1, r7
    2258:	eb003864 	bl	103f0 <cpu_cache_invalidate>
        block_device -> block_size * nb_blocks) ;

    local_offset = offset % block_device -> block_size ;
    225c:	e598c014 	ldr	ip, [r8, #20]
    2260:	e1a00004 	mov	r0, r4
    2264:	e1a01005 	mov	r1, r5
    2268:	e1a0200c 	mov	r2, ip
    226c:	e1a03fcc 	asr	r3, ip, #31
    2270:	e58dc00c 	str	ip, [sp, #12]
    2274:	eb004bb0 	bl	1513c <__aeabi_ldivmod>
    bulk_buffer += local_offset ;
    remaining_bytes = *p_count ;
    2278:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
    source_buffer = source ;

    local_count = remaining_bytes > block_device -> block_size - local_offset ? block_device -> block_size - local_offset : remaining_bytes ;
    227c:	e59dc00c 	ldr	ip, [sp, #12]
    cpu_cache_invalidate (CPU_CACHE_DATA, bulk_buffer, 
        block_device -> block_size * nb_blocks) ;

    local_offset = offset % block_device -> block_size ;
    bulk_buffer += local_offset ;
    remaining_bytes = *p_count ;
    2280:	e593b000 	ldr	fp, [r3]
    source_buffer = source ;

    local_count = remaining_bytes > block_device -> block_size - local_offset ? block_device -> block_size - local_offset : remaining_bytes ;
    2284:	e062500c 	rsb	r5, r2, ip
    2288:	e155000b 	cmp	r5, fp
    228c:	a1a0500b 	movge	r5, fp
    
    if (local_count > 0) {
    2290:	e3550000 	cmp	r5, #0

    cpu_cache_invalidate (CPU_CACHE_DATA, bulk_buffer, 
        block_device -> block_size * nb_blocks) ;

    local_offset = offset % block_device -> block_size ;
    bulk_buffer += local_offset ;
    2294:	e0874002 	add	r4, r7, r2
    remaining_bytes = *p_count ;
    source_buffer = source ;

    local_count = remaining_bytes > block_device -> block_size - local_offset ? block_device -> block_size - local_offset : remaining_bytes ;
    
    if (local_count > 0) {
    2298:	da000007 	ble	22bc <block_device_write+0x158>
      dna_memcpy (bulk_buffer, source_buffer, local_count) ;
    229c:	e1a00004 	mov	r0, r4
    22a0:	e1a01009 	mov	r1, r9
    22a4:	e1a02005 	mov	r2, r5
    22a8:	eb003779 	bl	10094 <dna_memcpy>
    22ac:	e598c014 	ldr	ip, [r8, #20]
      bulk_buffer += local_count ;
      source_buffer += local_count ;
      remaining_bytes -= local_count ;
    22b0:	e065b00b 	rsb	fp, r5, fp

    local_count = remaining_bytes > block_device -> block_size - local_offset ? block_device -> block_size - local_offset : remaining_bytes ;
    
    if (local_count > 0) {
      dna_memcpy (bulk_buffer, source_buffer, local_count) ;
      bulk_buffer += local_count ;
    22b4:	e0844005 	add	r4, r4, r5
      source_buffer += local_count ;
    22b8:	e0899005 	add	r9, r9, r5
      remaining_bytes -= local_count ;
    }

    quot = remaining_bytes / block_device -> block_size ;
    22bc:	e1a0100c 	mov	r1, ip
    22c0:	e1a0000b 	mov	r0, fp
    22c4:	e58dc00c 	str	ip, [sp, #12]
    22c8:	eb0048b2 	bl	14598 <__aeabi_idiv>
    while (quot > 0)
    22cc:	e2505000 	subs	r5, r0, #0
    22d0:	e59dc00c 	ldr	ip, [sp, #12]
    22d4:	da000009 	ble	2300 <block_device_write+0x19c>
    {
      dna_memcpy (bulk_buffer, source_buffer, block_device -> block_size) ;
    22d8:	e1a0200c 	mov	r2, ip
    22dc:	e1a00004 	mov	r0, r4
    22e0:	e1a01009 	mov	r1, r9
    22e4:	eb00376a 	bl	10094 <dna_memcpy>
      bulk_buffer += block_device -> block_size ;
    22e8:	e598c014 	ldr	ip, [r8, #20]
      source_buffer += local_count ;
      remaining_bytes -= local_count ;
    }

    quot = remaining_bytes / block_device -> block_size ;
    while (quot > 0)
    22ec:	e2555001 	subs	r5, r5, #1
    {
      dna_memcpy (bulk_buffer, source_buffer, block_device -> block_size) ;
      bulk_buffer += block_device -> block_size ;
    22f0:	e084400c 	add	r4, r4, ip
      source_buffer += block_device -> block_size ;
    22f4:	e089900c 	add	r9, r9, ip
      remaining_bytes -= block_device -> block_size ;
    22f8:	e06cb00b 	rsb	fp, ip, fp
      source_buffer += local_count ;
      remaining_bytes -= local_count ;
    }

    quot = remaining_bytes / block_device -> block_size ;
    while (quot > 0)
    22fc:	1afffff5 	bne	22d8 <block_device_write+0x174>
      source_buffer += block_device -> block_size ;
      remaining_bytes -= block_device -> block_size ;
      quot-- ;
    }

    if (remaining_bytes > 0)
    2300:	e35b0000 	cmp	fp, #0
    2304:	da000004 	ble	231c <block_device_write+0x1b8>
    {
      dna_memcpy (bulk_buffer, source_buffer, remaining_bytes) ;
    2308:	e1a00004 	mov	r0, r4
    230c:	e1a01009 	mov	r1, r9
    2310:	e1a0200b 	mov	r2, fp
    2314:	eb00375e 	bl	10094 <dna_memcpy>
    2318:	e598c014 	ldr	ip, [r8, #20]
    }

    cpu_cache_invalidate (CPU_CACHE_DATA, bulk_buffer_base_address, 
        block_device -> block_size * nb_blocks) ;

    ensure (access_device_blocks (block_device, 
    231c:	e3a05001 	mov	r5, #1
    if (remaining_bytes > 0)
    {
      dna_memcpy (bulk_buffer, source_buffer, remaining_bytes) ;
    }

    cpu_cache_invalidate (CPU_CACHE_DATA, bulk_buffer_base_address, 
    2320:	e002069c 	mul	r2, ip, r6
    2324:	e1a00005 	mov	r0, r5
    2328:	e1a01007 	mov	r1, r7
    232c:	eb00382f 	bl	103f0 <cpu_cache_invalidate>
        block_device -> block_size * nb_blocks) ;

    ensure (access_device_blocks (block_device, 
    2330:	e58d6000 	str	r6, [sp]
    2334:	e58d5004 	str	r5, [sp, #4]
    2338:	e1a00008 	mov	r0, r8
    233c:	e1a01007 	mov	r1, r7
    2340:	e1a0200a 	mov	r2, sl
    2344:	e1a03fca 	asr	r3, sl, #31
    2348:	eb0000da 	bl	26b8 <access_device_blocks>
    234c:	e2504000 	subs	r4, r0, #0
    2350:	1affffb8 	bne	2238 <block_device_write+0xd4>
        == DNA_OK, DNA_ERROR) ;

    dna_log(VERBOSE_LEVEL, "Wrote %d block(s) from block %d, using 0x%x as a source address", 
        nb_blocks, block_start, bulk_buffer_base_address) ;
    
    kernel_free (bulk_buffer_base_address) ;
    2354:	e1a00007 	mov	r0, r7
    2358:	eb004781 	bl	14164 <kernel_free>
    semaphore_release (block_device -> semaphore_id, 1, DNA_NO_RESCHEDULE) ;
    235c:	e1a01005 	mov	r1, r5
    2360:	e5980000 	ldr	r0, [r8]
    2364:	e1a02005 	mov	r2, r5
    2368:	eb0043bf 	bl	1326c <semaphore_release>
    return DNA_OK ;
    236c:	eaffffb2 	b	223c <block_device_write+0xd8>
    2370:	0000fffd 	.word	0x0000fffd
    2374:	0000ffff 	.word	0x0000ffff

00002378 <block_device_read>:
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t block_device_read (void * handler, void * destination,
    int64_t offset, int32_t * p_count) 
{
    2378:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    237c:	e1a04002 	mov	r4, r2
    2380:	e1a05003 	mov	r5, r3
    2384:	e24dd01c 	sub	sp, sp, #28
  dna_log(VERBOSE_LEVEL, "Reading %d bytes with offset %d at destination 0x%x", 
      *p_count, (uint32_t) offset, destination) ;
  watch (status_t)
  {

    ensure (offset + *p_count <= 
    2388:	e590b014 	ldr	fp, [r0, #20]
    238c:	e5908010 	ldr	r8, [r0, #16]
    2390:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
    2394:	e0080b98 	mul	r8, r8, fp
    2398:	e5923000 	ldr	r3, [r2]
    239c:	e1a09fc8 	asr	r9, r8, #31
    23a0:	e0946003 	adds	r6, r4, r3
    23a4:	e0a57fc3 	adc	r7, r5, r3, asr #31
    23a8:	e1580006 	cmp	r8, r6
    23ac:	e0d93007 	sbcs	r3, r9, r7
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t block_device_read (void * handler, void * destination,
    int64_t offset, int32_t * p_count) 
{
    23b0:	e1a0a000 	mov	sl, r0
  dna_log(VERBOSE_LEVEL, "Reading %d bytes with offset %d at destination 0x%x", 
      *p_count, (uint32_t) offset, destination) ;
  watch (status_t)
  {

    ensure (offset + *p_count <= 
    23b4:	b59f9214 	ldrlt	r9, [pc, #532]	; 25d0 <block_device_read+0x258>
    23b8:	aa000002 	bge	23c8 <block_device_read+0x50>

    kernel_free (read_buffer_base_address) ;
    semaphore_release (block_device -> semaphore_id, 1, DNA_NO_RESCHEDULE) ;
    return DNA_OK ;
  }
}
    23bc:	e1a00009 	mov	r0, r9
    23c0:	e28dd01c 	add	sp, sp, #28
    23c4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ensure (offset + *p_count <= 
        block_device -> block_count * block_device -> block_size, 
        DNA_BAD_ARGUMENT) ;
    block_size = block_device -> block_size ;

    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;
    23c8:	e3e03000 	mvn	r3, #0
    23cc:	e3e02000 	mvn	r2, #0
    23d0:	e5900000 	ldr	r0, [r0]
    23d4:	e1a08001 	mov	r8, r1
    23d8:	e1cd20f0 	strd	r2, [sp]
    23dc:	e3a01001 	mov	r1, #1
    23e0:	e3a02000 	mov	r2, #0
    23e4:	eb003edc 	bl	11f5c <semaphore_acquire>

    nb_blocks = ((*p_count / block_size + 1) +
    23e8:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
    23ec:	e5910000 	ldr	r0, [r1]
    23f0:	e1a0100b 	mov	r1, fp
        ((offset + *p_count) / block_size > 0 &&
    23f4:	e0946000 	adds	r6, r4, r0
    23f8:	e0a57fc0 	adc	r7, r5, r0, asr #31
        DNA_BAD_ARGUMENT) ;
    block_size = block_device -> block_size ;

    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;

    nb_blocks = ((*p_count / block_size + 1) +
    23fc:	eb004820 	bl	14484 <__aeabi_uidiv>
        ((offset + *p_count) / block_size > 0 &&
    2400:	e1a0200b 	mov	r2, fp
    2404:	e3a03000 	mov	r3, #0
        DNA_BAD_ARGUMENT) ;
    block_size = block_device -> block_size ;

    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;

    nb_blocks = ((*p_count / block_size + 1) +
    2408:	e1a09000 	mov	r9, r0
        ((offset + *p_count) / block_size > 0 &&
    240c:	e1a01007 	mov	r1, r7
    2410:	e1a00006 	mov	r0, r6
    2414:	eb004b48 	bl	1513c <__aeabi_ldivmod>
        DNA_BAD_ARGUMENT) ;
    block_size = block_device -> block_size ;

    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;

    nb_blocks = ((*p_count / block_size + 1) +
    2418:	e3500001 	cmp	r0, #1
    241c:	e2d12000 	sbcs	r2, r1, #0
    2420:	b3a03000 	movlt	r3, #0
    2424:	ba000008 	blt	244c <block_device_read+0xd4>
        ((offset + *p_count) / block_size > 0 &&
         (offset + *p_count) % block_size > 0 ?
    2428:	e1a00006 	mov	r0, r6
    242c:	e1a01007 	mov	r1, r7
    2430:	e1a0200b 	mov	r2, fp
    2434:	e3a03000 	mov	r3, #0
    2438:	eb004b3f 	bl	1513c <__aeabi_ldivmod>
    block_size = block_device -> block_size ;

    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;

    nb_blocks = ((*p_count / block_size + 1) +
        ((offset + *p_count) / block_size > 0 &&
    243c:	e3520001 	cmp	r2, #1
    2440:	e2d31000 	sbcs	r1, r3, #0
    2444:	a3a03001 	movge	r3, #1
    2448:	b3a03000 	movlt	r3, #0
        DNA_BAD_ARGUMENT) ;
    block_size = block_device -> block_size ;

    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;

    nb_blocks = ((*p_count / block_size + 1) +
    244c:	e2899001 	add	r9, r9, #1
    2450:	e0899003 	add	r9, r9, r3
         (offset + *p_count) % block_size > 0 ?
         1 :
         0)) ;
    lba = offset / block_size ;

    read_buffer = kernel_malloc (nb_blocks * block_size, true) ;
    2454:	e006099b 	mul	r6, fp, r9
    2458:	e3a01001 	mov	r1, #1
    245c:	e1a00006 	mov	r0, r6
    2460:	eb00470a 	bl	14090 <kernel_malloc>
    read_buffer_base_address = read_buffer ;
    ensure (read_buffer != NULL, DNA_OUT_OF_MEM) ;
    2464:	e2507000 	subs	r7, r0, #0
    2468:	059f9164 	ldreq	r9, [pc, #356]	; 25d4 <block_device_read+0x25c>
    246c:	0affffd2 	beq	23bc <block_device_read+0x44>
    nb_blocks = ((*p_count / block_size + 1) +
        ((offset + *p_count) / block_size > 0 &&
         (offset + *p_count) % block_size > 0 ?
         1 :
         0)) ;
    lba = offset / block_size ;
    2470:	e1a0200b 	mov	r2, fp
    2474:	e3a03000 	mov	r3, #0
    2478:	e1a00004 	mov	r0, r4
    247c:	e1a01005 	mov	r1, r5
    2480:	eb004b2d 	bl	1513c <__aeabi_ldivmod>

    read_buffer = kernel_malloc (nb_blocks * block_size, true) ;
    read_buffer_base_address = read_buffer ;
    ensure (read_buffer != NULL, DNA_OUT_OF_MEM) ;
    
    ensure (access_device_blocks(block_device, 
    2484:	e3a01000 	mov	r1, #0
    2488:	e1a02000 	mov	r2, r0
    248c:	e58d9000 	str	r9, [sp]
    2490:	e58d1004 	str	r1, [sp, #4]
    2494:	e3a03000 	mov	r3, #0
    2498:	e1a0000a 	mov	r0, sl
    249c:	e1a01007 	mov	r1, r7
    24a0:	eb000084 	bl	26b8 <access_device_blocks>
    24a4:	e2509000 	subs	r9, r0, #0
    24a8:	159f9128 	ldrne	r9, [pc, #296]	; 25d8 <block_device_read+0x260>
    24ac:	1affffc2 	bne	23bc <block_device_read+0x44>
                                 nb_blocks,
                                 READ) 
        == DNA_OK,
        DNA_ERROR) ;

    cpu_cache_invalidate (CPU_CACHE_DATA, read_buffer,
    24b0:	e1a02006 	mov	r2, r6
    24b4:	e3a00001 	mov	r0, #1
    24b8:	e1a01007 	mov	r1, r7
    24bc:	eb0037cb 	bl	103f0 <cpu_cache_invalidate>

    // Trimming the blocks to fit the p_count size and the block offset
    remaining_bytes = *p_count ;

    // Remainder from first block
    local_offset = offset % block_size ;
    24c0:	e1a00004 	mov	r0, r4
    24c4:	e1a01005 	mov	r1, r5
    24c8:	e1a0200b 	mov	r2, fp
    24cc:	e1a03009 	mov	r3, r9
    24d0:	eb004b19 	bl	1513c <__aeabi_ldivmod>

    cpu_cache_invalidate (CPU_CACHE_DATA, read_buffer,
        block_size * nb_blocks) ;

    // Trimming the blocks to fit the p_count size and the block offset
    remaining_bytes = *p_count ;
    24d4:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
    24d8:	e5913000 	ldr	r3, [r1]

    // Remainder from first block
    local_offset = offset % block_size ;
    local_p_count = remaining_bytes > (block_size - local_offset) ?
    24dc:	e062100b 	rsb	r1, r2, fp
      remaining_bytes - (block_size - local_offset) :
    24e0:	e1530001 	cmp	r3, r1
    24e4:	9a00002f 	bls	25a8 <block_device_read+0x230>
    24e8:	e06b5002 	rsb	r5, fp, r2
    24ec:	e0854003 	add	r4, r5, r3
      remaining_bytes ;
    read_buffer += local_offset ;
    24f0:	e0876002 	add	r6, r7, r2
    dna_memcpy (destination, read_buffer, local_p_count) ;
    24f4:	e1a01006 	mov	r1, r6
    24f8:	e1a02004 	mov	r2, r4
    24fc:	e1a00008 	mov	r0, r8
    2500:	e2655000 	rsb	r5, r5, #0
    2504:	eb0036e2 	bl	10094 <dna_memcpy>
    remaining_bytes -= local_p_count ;
    destination += local_p_count ;
    read_buffer += local_p_count ;

    // Block transfers
    quot = remaining_bytes / block_size ;
    2508:	e1a00005 	mov	r0, r5
    250c:	e1a0100b 	mov	r1, fp
    2510:	eb0047db 	bl	14484 <__aeabi_uidiv>
    read_buffer += local_offset ;
    dna_memcpy (destination, read_buffer, local_p_count) ;

    remaining_bytes -= local_p_count ;
    destination += local_p_count ;
    read_buffer += local_p_count ;
    2514:	e0866004 	add	r6, r6, r4

    // Block transfers
    quot = remaining_bytes / block_size ;
    while (quot > 0)
    2518:	e3500000 	cmp	r0, #0
      remaining_bytes ;
    read_buffer += local_offset ;
    dna_memcpy (destination, read_buffer, local_p_count) ;

    remaining_bytes -= local_p_count ;
    destination += local_p_count ;
    251c:	e0888004 	add	r8, r8, r4
    read_buffer += local_p_count ;

    // Block transfers
    quot = remaining_bytes / block_size ;
    while (quot > 0)
    2520:	e58d0014 	str	r0, [sp, #20]
    read_buffer += local_offset ;
    dna_memcpy (destination, read_buffer, local_p_count) ;

    remaining_bytes -= local_p_count ;
    destination += local_p_count ;
    read_buffer += local_p_count ;
    2524:	e58d6010 	str	r6, [sp, #16]
      remaining_bytes ;
    read_buffer += local_offset ;
    dna_memcpy (destination, read_buffer, local_p_count) ;

    remaining_bytes -= local_p_count ;
    destination += local_p_count ;
    2528:	e58d800c 	str	r8, [sp, #12]
    read_buffer += local_p_count ;

    // Block transfers
    quot = remaining_bytes / block_size ;
    while (quot > 0)
    252c:	0a000014 	beq	2584 <block_device_read+0x20c>
    2530:	e1a04008 	mov	r4, r8
    remaining_bytes -= local_p_count ;
    destination += local_p_count ;
    read_buffer += local_p_count ;

    // Block transfers
    quot = remaining_bytes / block_size ;
    2534:	e1a08000 	mov	r8, r0
    while (quot > 0)
    {
      dna_memcpy (destination, read_buffer, block_size) ;
    2538:	e1a00004 	mov	r0, r4
    253c:	e1a01006 	mov	r1, r6
    2540:	e1a0200b 	mov	r2, fp
    2544:	eb0036d2 	bl	10094 <dna_memcpy>
    destination += local_p_count ;
    read_buffer += local_p_count ;

    // Block transfers
    quot = remaining_bytes / block_size ;
    while (quot > 0)
    2548:	e2588001 	subs	r8, r8, #1
    {
      dna_memcpy (destination, read_buffer, block_size) ;
      remaining_bytes -= block_size ;
      destination += block_size ;
    254c:	e084400b 	add	r4, r4, fp
      read_buffer += block_size ;
    2550:	e086600b 	add	r6, r6, fp
    destination += local_p_count ;
    read_buffer += local_p_count ;

    // Block transfers
    quot = remaining_bytes / block_size ;
    while (quot > 0)
    2554:	1afffff7 	bne	2538 <block_device_read+0x1c0>
    2558:	e59d3014 	ldr	r3, [sp, #20]
    255c:	e06b5005 	rsb	r5, fp, r5
    2560:	e2632001 	rsb	r2, r3, #1
    2564:	e003039b 	mul	r3, fp, r3
    2568:	e59d100c 	ldr	r1, [sp, #12]
    256c:	e025529b 	mla	r5, fp, r2, r5
    2570:	e59d2010 	ldr	r2, [sp, #16]
    2574:	e0811003 	add	r1, r1, r3
    2578:	e0822003 	add	r2, r2, r3
    257c:	e58d100c 	str	r1, [sp, #12]
    2580:	e58d2010 	str	r2, [sp, #16]
      read_buffer += block_size ;
      quot-- ;
    }

    // Remainder from last block
    if (remaining_bytes > 0)
    2584:	e3550000 	cmp	r5, #0
    2588:	1a00000b 	bne	25bc <block_device_read+0x244>
    {
      dna_memcpy (destination, read_buffer, remaining_bytes) ;
    }

    kernel_free (read_buffer_base_address) ;
    258c:	e1a00007 	mov	r0, r7
    2590:	eb0046f3 	bl	14164 <kernel_free>
    semaphore_release (block_device -> semaphore_id, 1, DNA_NO_RESCHEDULE) ;
    2594:	e3a01001 	mov	r1, #1
    2598:	e59a0000 	ldr	r0, [sl]
    259c:	e1a02001 	mov	r2, r1
    25a0:	eb004331 	bl	1326c <semaphore_release>
    return DNA_OK ;
    25a4:	eaffff84 	b	23bc <block_device_read+0x44>
    local_offset = offset % block_size ;
    local_p_count = remaining_bytes > (block_size - local_offset) ?
      remaining_bytes - (block_size - local_offset) :
      remaining_bytes ;
    read_buffer += local_offset ;
    dna_memcpy (destination, read_buffer, local_p_count) ;
    25a8:	e0871002 	add	r1, r7, r2
    25ac:	e1a00008 	mov	r0, r8
    25b0:	e1a02003 	mov	r2, r3
    25b4:	eb0036b6 	bl	10094 <dna_memcpy>
    25b8:	eafffff3 	b	258c <block_device_read+0x214>
    }

    // Remainder from last block
    if (remaining_bytes > 0)
    {
      dna_memcpy (destination, read_buffer, remaining_bytes) ;
    25bc:	e59d000c 	ldr	r0, [sp, #12]
    25c0:	e59d1010 	ldr	r1, [sp, #16]
    25c4:	e1a02005 	mov	r2, r5
    25c8:	eb0036b1 	bl	10094 <dna_memcpy>
    25cc:	eaffffee 	b	258c <block_device_read+0x214>
    25d0:	0000fffc 	.word	0x0000fffc
    25d4:	0000fffd 	.word	0x0000fffd
    25d8:	0000ffff 	.word	0x0000ffff

000025dc <block_device_find_device>:


device_cmd_t * block_device_find_device (const char * name)
{
  return & block_device_commands ;
}
    25dc:	e59f0000 	ldr	r0, [pc]	; 25e4 <block_device_find_device+0x8>
    25e0:	e12fff1e 	bx	lr
    25e4:	0003393c 	.word	0x0003393c

000025e8 <block_device_publish_devices>:


const char ** block_device_publish_devices (void)
{
  return block_devices ;
}
    25e8:	e59f0000 	ldr	r0, [pc]	; 25f0 <block_device_publish_devices+0x8>
    25ec:	e12fff1e 	bx	lr
    25f0:	00033934 	.word	0x00033934

000025f4 <block_device_free>:


status_t block_device_free (void * data)
{
  return DNA_OK ;
}
    25f4:	e3a00000 	mov	r0, #0
    25f8:	e12fff1e 	bx	lr

000025fc <block_device_close>:


status_t block_device_close (void * data)
{
  return DNA_OK ;
}
    25fc:	e3a00000 	mov	r0, #0
    2600:	e12fff1e 	bx	lr

00002604 <block_device_control>:
#include <Private/SoclibBlockDeviceDriver.h>
#include <DnaTools/DnaTools.h>

status_t block_device_control (void * handler, int32_t function,
    va_list arguments, int32_t * p_ret)
{
    2604:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  interrupt_status_t it_status;
  block_device_control_t * block_device = (block_device_control_t *)handler;

  watch (status_t)
  {
    ensure (block_device != NULL, DNA_ERROR);
    2608:	e2507000 	subs	r7, r0, #0
    260c:	0a000014 	beq	2664 <block_device_control+0x60>
    2610:	e1a04001 	mov	r4, r1
    2614:	e1a06002 	mov	r6, r2
    2618:	e1a05003 	mov	r5, r3

    it_status = cpu_trap_mask_and_backup ();
    261c:	eb00379b 	bl	10490 <cpu_trap_mask_and_backup>

    switch (function)
    2620:	e3540000 	cmp	r4, #0

  watch (status_t)
  {
    ensure (block_device != NULL, DNA_ERROR);

    it_status = cpu_trap_mask_and_backup ();
    2624:	e1a08000 	mov	r8, r0

    switch (function)
    2628:	0a000015 	beq	2684 <block_device_control+0x80>
    262c:	e3540006 	cmp	r4, #6
    2630:	1a00000d 	bne	266c <block_device_control+0x68>
          break;
        }

      case DNA_GET_INFO:
        {
          device_info_t * info = va_arg (arguments, device_info_t *);
    2634:	e5964000 	ldr	r4, [r6]
          ensure (info != NULL, DNA_ERROR);
    2638:	e3540000 	cmp	r4, #0
    263c:	0a000008 	beq	2664 <block_device_control+0x60>

          dna_memset (info, 0, sizeof (device_info_t));
    2640:	e3a02010 	mov	r2, #16
    2644:	e1a00004 	mov	r0, r4
    2648:	e3a01000 	mov	r1, #0
    264c:	eb003388 	bl	f474 <dna_memset>
          info->type = DNA_DISK_DEVICE;
    2650:	e3a02001 	mov	r2, #1

          *p_ret = 0;
    2654:	e3a03000 	mov	r3, #0
        {
          device_info_t * info = va_arg (arguments, device_info_t *);
          ensure (info != NULL, DNA_ERROR);

          dna_memset (info, 0, sizeof (device_info_t));
          info->type = DNA_DISK_DEVICE;
    2658:	e5842000 	str	r2, [r4]

          *p_ret = 0;
    265c:	e5853000 	str	r3, [r5]
          break;
    2660:	ea000003 	b	2674 <block_device_control+0x70>
  interrupt_status_t it_status;
  block_device_control_t * block_device = (block_device_control_t *)handler;

  watch (status_t)
  {
    ensure (block_device != NULL, DNA_ERROR);
    2664:	e59f0040 	ldr	r0, [pc, #64]	; 26ac <block_device_control+0xa8>
    2668:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        }

      default:
        {
          dna_log(INFO_LEVEL, "Unsupported control code 0x%x.", function);
          *p_ret = -1;
    266c:	e3e03000 	mvn	r3, #0
    2670:	e5853000 	str	r3, [r5]
          break;
        }
    }

    cpu_trap_restore (it_status);
    2674:	e1a00008 	mov	r0, r8
    2678:	eb0037bd 	bl	10574 <cpu_trap_restore>
    return DNA_OK;
    267c:	e3a00000 	mov	r0, #0
  }
}
    2680:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

    switch (function)
    {
      case DNA_GET_DEVICE_SIZE:
        {
          int64_t * p_size = va_arg(arguments, int64_t *);
    2684:	e5961000 	ldr	r1, [r6]
//          p_size = (int64_t *)arguments;
          ensure (p_size != NULL, DNA_ERROR);
    2688:	e3510000 	cmp	r1, #0
    268c:	0afffff4 	beq	2664 <block_device_control+0x60>

          *p_size = block_device->block_count * block_device->block_size;
    2690:	e5973010 	ldr	r3, [r7, #16]
    2694:	e5972014 	ldr	r2, [r7, #20]
    2698:	e0020392 	mul	r2, r2, r3
    269c:	e1a03fc2 	asr	r3, r2, #31
    26a0:	e1c120f0 	strd	r2, [r1]

          *p_ret = 0;
    26a4:	e5854000 	str	r4, [r5]
          break;
    26a8:	eafffff1 	b	2674 <block_device_control+0x70>
    26ac:	0000ffff 	.word	0x0000ffff

000026b0 <block_device_init_hardware>:
#include <DnaTools/DnaTools.h>

status_t block_device_init_hardware (void)
{
  return DNA_OK ;
}
    26b0:	e3a00000 	mov	r0, #0
    26b4:	e12fff1e 	bx	lr

000026b8 <access_device_blocks>:
#include <DnaTools/DnaTools.h>

status_t access_device_blocks(block_device_control_t * block_device, 
    void * access, int64_t block_offset, int32_t block_count,
    block_device_access_t read_or_write) 
{
    26b8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    26bc:	e1a04000 	mov	r4, r0
    26c0:	e1a06001 	mov	r6, r1
    26c4:	e1a08002 	mov	r8, r2
    26c8:	e24dd008 	sub	sp, sp, #8
    26cc:	e59d5020 	ldr	r5, [sp, #32]
    26d0:	e5dd7024 	ldrb	r7, [sp, #36]	; 0x24
  uint32_t operation_status ;
  interrupt_status_t it_status ;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup() ;
    26d4:	eb00376d 	bl	10490 <cpu_trap_mask_and_backup>

    cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_LBA),
        block_offset) ;
    dna_log(VERBOSE_LEVEL, "Wrote block offset (LBA): %d", block_offset) ;

    if (block_device -> should_enable_irq)
    26d8:	e5d4c008 	ldrb	ip, [r4, #8]
  interrupt_status_t it_status ;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup() ;
    cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_BUFFER),
    26dc:	e5943018 	ldr	r3, [r4, #24]

    cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_LBA),
        block_offset) ;
    dna_log(VERBOSE_LEVEL, "Wrote block offset (LBA): %d", block_offset) ;

    if (block_device -> should_enable_irq)
    26e0:	e35c0000 	cmp	ip, #0
  interrupt_status_t it_status ;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup() ;
    cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_BUFFER),
    26e4:	e5836000 	str	r6, [r3]
        access) ;
    dna_log(VERBOSE_LEVEL, "Wrote destination buffer address: 0x%x", 
        access) ;
    
    cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_COUNT),
    26e8:	e5835008 	str	r5, [r3, #8]
        block_count) ;
    dna_log(VERBOSE_LEVEL, "Wrote block count: %d", block_count) ;

    cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_LBA),
    26ec:	e5838004 	str	r8, [r3, #4]
        block_offset) ;
    dna_log(VERBOSE_LEVEL, "Wrote block offset (LBA): %d", block_offset) ;

    if (block_device -> should_enable_irq)
    26f0:	0a000010 	beq	2738 <access_device_blocks+0x80>
    {
      cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_IRQ_ENABLE),
          (uint32_t) true) ;
      cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_OP), 
    26f4:	e3570000 	cmp	r7, #0
    26f8:	03a07001 	moveq	r7, #1
    26fc:	13a07002 	movne	r7, #2
        block_offset) ;
    dna_log(VERBOSE_LEVEL, "Wrote block offset (LBA): %d", block_offset) ;

    if (block_device -> should_enable_irq)
    {
      cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_IRQ_ENABLE),
    2700:	e3a05001 	mov	r5, #1
    2704:	e5835014 	str	r5, [r3, #20]
          (uint32_t) true) ;
      cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_OP), 
    2708:	e583700c 	str	r7, [r3, #12]
          read_or_write == READ ? BLOCK_DEVICE_READ : BLOCK_DEVICE_WRITE) ;


      cpu_trap_restore (it_status) ;
    270c:	eb003798 	bl	10574 <cpu_trap_restore>
      semaphore_acquire (block_device -> isr_semaphore_id, 1, 0, -1) ;
    2710:	e3e03000 	mvn	r3, #0
    2714:	e3e02000 	mvn	r2, #0
    2718:	e5940004 	ldr	r0, [r4, #4]
    271c:	e1a01005 	mov	r1, r5
    2720:	e1cd20f0 	strd	r2, [sp]
    2724:	e3a02000 	mov	r2, #0
    2728:	eb003e0b 	bl	11f5c <semaphore_acquire>

      cpu_trap_restore (it_status) ;
      ensure (operation_status == BLOCK_DEVICE_READ_SUCCESS ||
          operation_status == BLOCK_DEVICE_WRITE_SUCCESS, DNA_ERROR) ;
    }
    return DNA_OK ;
    272c:	e3a00000 	mov	r0, #0
  }
}
    2730:	e28dd008 	add	sp, sp, #8
    2734:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }
    else
    {
      cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_IRQ_ENABLE),
          (uint32_t) false) ;
      cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_OP), 
    2738:	e3570000 	cmp	r7, #0
    273c:	03a07001 	moveq	r7, #1
    2740:	13a07002 	movne	r7, #2
    2744:	e1a02000 	mov	r2, r0
      cpu_trap_restore (it_status) ;
      semaphore_acquire (block_device -> isr_semaphore_id, 1, 0, -1) ;
    }
    else
    {
      cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_IRQ_ENABLE),
    2748:	e583c014 	str	ip, [r3, #20]
          (uint32_t) false) ;
      cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_OP), 
    274c:	e583700c 	str	r7, [r3, #12]
          read_or_write == READ ? BLOCK_DEVICE_READ : BLOCK_DEVICE_WRITE) ;

      do {
        cpu_read (UINT32, & (block_device -> port -> BLOCK_DEVICE_STATUS), 
    2750:	e5934010 	ldr	r4, [r3, #16]
            operation_status) ;
        dna_log(VERBOSE_LEVEL, "Op status is %d.", operation_status) ;
      } while (operation_status == BLOCK_DEVICE_BUSY) ;
    2754:	e3540001 	cmp	r4, #1
    2758:	0afffffc 	beq	2750 <access_device_blocks+0x98>

      cpu_trap_restore (it_status) ;
    275c:	e1a00002 	mov	r0, r2
    2760:	eb003783 	bl	10574 <cpu_trap_restore>
      ensure (operation_status == BLOCK_DEVICE_READ_SUCCESS ||
    2764:	e2440002 	sub	r0, r4, #2
    2768:	e3500001 	cmp	r0, #1
    276c:	93a00000 	movls	r0, #0
    2770:	83e00000 	mvnhi	r0, #0
    2774:	e6ff0070 	uxth	r0, r0
          operation_status == BLOCK_DEVICE_WRITE_SUCCESS, DNA_ERROR) ;
    }
    return DNA_OK ;
  }
}
    2778:	e28dd008 	add	sp, sp, #8
    277c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

00002780 <block_device_uninit_driver>:
#include <Core/Core.h>
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

void block_device_uninit_driver (void)
{
    2780:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
  int32_t idx ;
  block_device_control_t block_device ;
  
  for (idx = 0 ; idx < SOCLIB_BLOCK_DEVICES_NDEV ; idx++)
    2784:	e59f6074 	ldr	r6, [pc, #116]	; 2800 <block_device_uninit_driver+0x80>
    2788:	e596c000 	ldr	ip, [r6]
    278c:	e35c0000 	cmp	ip, #0
    2790:	da000017 	ble	27f4 <block_device_uninit_driver+0x74>
    2794:	e3a04000 	mov	r4, #0
    2798:	e59f7064 	ldr	r7, [pc, #100]	; 2804 <block_device_uninit_driver+0x84>
    279c:	e1a05004 	mov	r5, r4
    27a0:	e5970000 	ldr	r0, [r7]
    27a4:	ea000002 	b	27b4 <block_device_uninit_driver+0x34>
    27a8:	e155000c 	cmp	r5, ip
    27ac:	e284401c 	add	r4, r4, #28
    27b0:	aa00000d 	bge	27ec <block_device_uninit_driver+0x6c>
  {
    block_device = block_device_controls[idx] ;
    27b4:	e0803004 	add	r3, r0, r4
    if (block_device . should_enable_irq) {
    27b8:	e5d32008 	ldrb	r2, [r3, #8]
void block_device_uninit_driver (void)
{
  int32_t idx ;
  block_device_control_t block_device ;
  
  for (idx = 0 ; idx < SOCLIB_BLOCK_DEVICES_NDEV ; idx++)
    27bc:	e2855001 	add	r5, r5, #1
  {
    block_device = block_device_controls[idx] ;
    if (block_device . should_enable_irq) {
    27c0:	e3520000 	cmp	r2, #0
  int32_t idx ;
  block_device_control_t block_device ;
  
  for (idx = 0 ; idx < SOCLIB_BLOCK_DEVICES_NDEV ; idx++)
  {
    block_device = block_device_controls[idx] ;
    27c4:	e593100c 	ldr	r1, [r3, #12]
    if (block_device . should_enable_irq) {
    27c8:	0afffff6 	beq	27a8 <block_device_uninit_driver+0x28>
      interrupt_detach (0, block_device . irq, block_device_isr) ;
    27cc:	e3a00000 	mov	r0, #0
    27d0:	e59f2030 	ldr	r2, [pc, #48]	; 2808 <block_device_uninit_driver+0x88>
    27d4:	eb0043c9 	bl	13700 <interrupt_detach>
    27d8:	e596c000 	ldr	ip, [r6]
    27dc:	e5970000 	ldr	r0, [r7]
void block_device_uninit_driver (void)
{
  int32_t idx ;
  block_device_control_t block_device ;
  
  for (idx = 0 ; idx < SOCLIB_BLOCK_DEVICES_NDEV ; idx++)
    27e0:	e155000c 	cmp	r5, ip
    27e4:	e284401c 	add	r4, r4, #28
    27e8:	bafffff1 	blt	27b4 <block_device_uninit_driver+0x34>
    }
  }

  kernel_free (block_device_controls) ;

}
    27ec:	e8bd40f8 	pop	{r3, r4, r5, r6, r7, lr}
    if (block_device . should_enable_irq) {
      interrupt_detach (0, block_device . irq, block_device_isr) ;
    }
  }

  kernel_free (block_device_controls) ;
    27f0:	ea00465b 	b	14164 <kernel_free>
    27f4:	e59f3008 	ldr	r3, [pc, #8]	; 2804 <block_device_uninit_driver+0x84>
    27f8:	e5930000 	ldr	r0, [r3]
    27fc:	eafffffa 	b	27ec <block_device_uninit_driver+0x6c>
    2800:	0003e974 	.word	0x0003e974
    2804:	0013ea24 	.word	0x0013ea24
    2808:	0000211c 	.word	0x0000211c

0000280c <rdv_uninit_driver>:

#include <Private/Driver.h>
#include <MemoryManager/MemoryManager.h>

void rdv_uninit_driver (void)
{
    280c:	e92d4070 	push	{r4, r5, r6, lr}
  for (int32_t i = 0; i < CHANNEL_RDV_NDEV; i++)
    2810:	e59f503c 	ldr	r5, [pc, #60]	; 2854 <rdv_uninit_driver+0x48>
    2814:	e5953000 	ldr	r3, [r5]
    2818:	e3530000 	cmp	r3, #0
    281c:	d59f6034 	ldrle	r6, [pc, #52]	; 2858 <rdv_uninit_driver+0x4c>
    2820:	da000008 	ble	2848 <rdv_uninit_driver+0x3c>
    2824:	e3a04000 	mov	r4, #0
    2828:	e59f6028 	ldr	r6, [pc, #40]	; 2858 <rdv_uninit_driver+0x4c>
  {
    kernel_free ((void *)rdv_devices[i]);
    282c:	e5963000 	ldr	r3, [r6]
    2830:	e7930104 	ldr	r0, [r3, r4, lsl #2]
    2834:	eb00464a 	bl	14164 <kernel_free>
#include <Private/Driver.h>
#include <MemoryManager/MemoryManager.h>

void rdv_uninit_driver (void)
{
  for (int32_t i = 0; i < CHANNEL_RDV_NDEV; i++)
    2838:	e5953000 	ldr	r3, [r5]
    283c:	e2844001 	add	r4, r4, #1
    2840:	e1530004 	cmp	r3, r4
    2844:	cafffff8 	bgt	282c <rdv_uninit_driver+0x20>
  {
    kernel_free ((void *)rdv_devices[i]);
  }

  kernel_free (rdv_devices);
    2848:	e5960000 	ldr	r0, [r6]
}
    284c:	e8bd4070 	pop	{r4, r5, r6, lr}
  for (int32_t i = 0; i < CHANNEL_RDV_NDEV; i++)
  {
    kernel_free ((void *)rdv_devices[i]);
  }

  kernel_free (rdv_devices);
    2850:	ea004643 	b	14164 <kernel_free>
    2854:	0003e994 	.word	0x0003e994
    2858:	0013ea28 	.word	0x0013ea28

0000285c <rdv_read>:
#include <Processor/Processor.h>
#include <DnaTools/DnaTools.h>

status_t rdv_read (void * handler, void * destination,
    int64_t offset, int32_t * p_count)
{
    285c:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    2860:	e24dd00c 	sub	sp, sp, #12
    2864:	e1a06000 	mov	r6, r0
  channel_rdv_t * rdv = handler;
  interrupt_status_t it_status = 0;

  it_status = cpu_trap_mask_and_backup();
  lock_acquire (& rdv -> lock);
    2868:	e2804004 	add	r4, r0, #4
#include <Processor/Processor.h>
#include <DnaTools/DnaTools.h>

status_t rdv_read (void * handler, void * destination,
    int64_t offset, int32_t * p_count)
{
    286c:	e1a05001 	mov	r5, r1
  channel_rdv_t * rdv = handler;
  interrupt_status_t it_status = 0;

  it_status = cpu_trap_mask_and_backup();
    2870:	eb003706 	bl	10490 <cpu_trap_mask_and_backup>
    2874:	e1a07000 	mov	r7, r0
  lock_acquire (& rdv -> lock);
    2878:	e1a00004 	mov	r0, r4
    287c:	eb00384f 	bl	109c0 <lock_acquire>
    
  if (! rdv -> setter . ready)
    2880:	e5d6200c 	ldrb	r2, [r6, #12]
    2884:	e21280ff 	ands	r8, r2, #255	; 0xff
    2888:	0a000012 	beq	28d8 <rdv_read+0x7c>
    lock_release (& rdv -> lock);
    semaphore_acquire (rdv -> sem, 1, 0, -1);
  }
  else
  {
    rdv -> setter . ready = false;
    288c:	e3a03000 	mov	r3, #0
    2890:	e5c6300c 	strb	r3, [r6, #12]
    rdv -> getter . ready = false;
    2894:	e5c63014 	strb	r3, [r6, #20]
    dna_memcpy ((void *)destination, (void *)rdv -> setter . buffer, *p_count);
    2898:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
    289c:	e5961008 	ldr	r1, [r6, #8]
    28a0:	e5932000 	ldr	r2, [r3]
    28a4:	e1a00005 	mov	r0, r5
    28a8:	eb0035f9 	bl	10094 <dna_memcpy>

    lock_release (& rdv -> lock);
    28ac:	e1a00004 	mov	r0, r4
    28b0:	eb0042f6 	bl	13490 <lock_release>
    semaphore_release (rdv -> sem, 1, DNA_NO_RESCHEDULE);
    28b4:	e3a01001 	mov	r1, #1
    28b8:	e5960000 	ldr	r0, [r6]
    28bc:	e1a02001 	mov	r2, r1
    28c0:	eb004269 	bl	1326c <semaphore_release>
  }

  cpu_trap_restore(it_status);
    28c4:	e1a00007 	mov	r0, r7
    28c8:	eb003729 	bl	10574 <cpu_trap_restore>
  return DNA_OK;
}
    28cc:	e3a00000 	mov	r0, #0
    28d0:	e28dd00c 	add	sp, sp, #12
    28d4:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  it_status = cpu_trap_mask_and_backup();
  lock_acquire (& rdv -> lock);
    
  if (! rdv -> setter . ready)
  {
    rdv -> getter . ready = true;
    28d8:	e3a09001 	mov	r9, #1
    rdv -> getter . buffer = destination;
    28dc:	e5865010 	str	r5, [r6, #16]

    lock_release (& rdv -> lock);
    28e0:	e1a00004 	mov	r0, r4
    semaphore_acquire (rdv -> sem, 1, 0, -1);
    28e4:	e3e05000 	mvn	r5, #0
    28e8:	e3e04000 	mvn	r4, #0
  it_status = cpu_trap_mask_and_backup();
  lock_acquire (& rdv -> lock);
    
  if (! rdv -> setter . ready)
  {
    rdv -> getter . ready = true;
    28ec:	e5c69014 	strb	r9, [r6, #20]
    rdv -> getter . buffer = destination;

    lock_release (& rdv -> lock);
    28f0:	eb0042e6 	bl	13490 <lock_release>
    semaphore_acquire (rdv -> sem, 1, 0, -1);
    28f4:	e5960000 	ldr	r0, [r6]
    28f8:	e1a01009 	mov	r1, r9
    28fc:	e1a02008 	mov	r2, r8
    2900:	e1cd40f0 	strd	r4, [sp]
    2904:	eb003d94 	bl	11f5c <semaphore_acquire>
    2908:	eaffffed 	b	28c4 <rdv_read+0x68>

0000290c <rdv_close>:
#include <DnaTools/DnaTools.h>

status_t rdv_close (void * data)
{
  return DNA_NOT_IMPLEMENTED;
}
    290c:	e59f0000 	ldr	r0, [pc]	; 2914 <rdv_close+0x8>
    2910:	e12fff1e 	bx	lr
    2914:	0000fffe 	.word	0x0000fffe

00002918 <rdv_write>:
#include <Processor/Processor.h>
#include <DnaTools/DnaTools.h>

status_t rdv_write (void * handler, void * source,
    int64_t offset, int32_t * p_count)
{
    2918:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    291c:	e24dd00c 	sub	sp, sp, #12
    2920:	e1a06000 	mov	r6, r0
  channel_rdv_t * rdv = handler;
  interrupt_status_t it_status = 0;

  it_status = cpu_trap_mask_and_backup();
  lock_acquire (& rdv -> lock);
    2924:	e2804004 	add	r4, r0, #4
#include <Processor/Processor.h>
#include <DnaTools/DnaTools.h>

status_t rdv_write (void * handler, void * source,
    int64_t offset, int32_t * p_count)
{
    2928:	e1a05001 	mov	r5, r1
  channel_rdv_t * rdv = handler;
  interrupt_status_t it_status = 0;

  it_status = cpu_trap_mask_and_backup();
    292c:	eb0036d7 	bl	10490 <cpu_trap_mask_and_backup>
    2930:	e1a07000 	mov	r7, r0
  lock_acquire (& rdv -> lock);
    2934:	e1a00004 	mov	r0, r4
    2938:	eb003820 	bl	109c0 <lock_acquire>

  if (! rdv -> getter . ready)
    293c:	e5d62014 	ldrb	r2, [r6, #20]
    2940:	e21280ff 	ands	r8, r2, #255	; 0xff
    2944:	0a000012 	beq	2994 <rdv_write+0x7c>
    lock_release (& rdv -> lock);
    semaphore_acquire (rdv -> sem, 1, 0, -1);
  }
  else
  {
    rdv -> getter . ready = false;
    2948:	e3a03000 	mov	r3, #0
    294c:	e5c63014 	strb	r3, [r6, #20]
    rdv -> setter . ready = false;
    2950:	e5c6300c 	strb	r3, [r6, #12]
    dna_memcpy ((void *)rdv -> getter . buffer, (void *)source, *p_count);
    2954:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
    2958:	e1a01005 	mov	r1, r5
    295c:	e5932000 	ldr	r2, [r3]
    2960:	e5960010 	ldr	r0, [r6, #16]
    2964:	eb0035ca 	bl	10094 <dna_memcpy>

    lock_release (& rdv -> lock);
    2968:	e1a00004 	mov	r0, r4
    296c:	eb0042c7 	bl	13490 <lock_release>
    semaphore_release (rdv -> sem, 1, DNA_NO_RESCHEDULE);
    2970:	e3a01001 	mov	r1, #1
    2974:	e5960000 	ldr	r0, [r6]
    2978:	e1a02001 	mov	r2, r1
    297c:	eb00423a 	bl	1326c <semaphore_release>
  }

  cpu_trap_restore(it_status);
    2980:	e1a00007 	mov	r0, r7
    2984:	eb0036fa 	bl	10574 <cpu_trap_restore>
  return DNA_OK;
}
    2988:	e3a00000 	mov	r0, #0
    298c:	e28dd00c 	add	sp, sp, #12
    2990:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  it_status = cpu_trap_mask_and_backup();
  lock_acquire (& rdv -> lock);

  if (! rdv -> getter . ready)
  {
    rdv -> setter . ready = true;
    2994:	e3a09001 	mov	r9, #1
    rdv -> setter . buffer = source;
    2998:	e5865008 	str	r5, [r6, #8]

    lock_release (& rdv -> lock);
    299c:	e1a00004 	mov	r0, r4
    semaphore_acquire (rdv -> sem, 1, 0, -1);
    29a0:	e3e05000 	mvn	r5, #0
    29a4:	e3e04000 	mvn	r4, #0
  it_status = cpu_trap_mask_and_backup();
  lock_acquire (& rdv -> lock);

  if (! rdv -> getter . ready)
  {
    rdv -> setter . ready = true;
    29a8:	e5c6900c 	strb	r9, [r6, #12]
    rdv -> setter . buffer = source;

    lock_release (& rdv -> lock);
    29ac:	eb0042b7 	bl	13490 <lock_release>
    semaphore_acquire (rdv -> sem, 1, 0, -1);
    29b0:	e5960000 	ldr	r0, [r6]
    29b4:	e1a01009 	mov	r1, r9
    29b8:	e1a02008 	mov	r2, r8
    29bc:	e1cd40f0 	strd	r4, [sp]
    29c0:	eb003d65 	bl	11f5c <semaphore_acquire>
    29c4:	eaffffed 	b	2980 <rdv_write+0x68>

000029c8 <rdv_find_device>:
};

device_cmd_t * rdv_find_device (const char * name)
{
  return & rdv_commands;
}
    29c8:	e59f0000 	ldr	r0, [pc]	; 29d0 <rdv_find_device+0x8>
    29cc:	e12fff1e 	bx	lr
    29d0:	00033984 	.word	0x00033984

000029d4 <rdv_publish_devices>:

#include <Private/Driver.h>

const char ** rdv_publish_devices (void)
{
  return rdv_devices;
    29d4:	e59f3004 	ldr	r3, [pc, #4]	; 29e0 <rdv_publish_devices+0xc>
}
    29d8:	e5930000 	ldr	r0, [r3]
    29dc:	e12fff1e 	bx	lr
    29e0:	0013ea28 	.word	0x0013ea28

000029e4 <rdv_init_driver>:
  int32_t i = 0;
  status_t status;

  watch (status_t)
  {
    rdv_devices = kernel_malloc (sizeof (const char *)
    29e4:	e3a01001 	mov	r1, #1
#include <Private/Driver.h>
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rdv_init_driver (void)
{
    29e8:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  status_t status;

  watch (status_t)
  {
    rdv_devices = kernel_malloc (sizeof (const char *)
        * (CHANNEL_RDV_NDEV + 1), true);
    29ec:	e59f7144 	ldr	r7, [pc, #324]	; 2b38 <rdv_init_driver+0x154>
#include <Private/Driver.h>
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rdv_init_driver (void)
{
    29f0:	e24dd044 	sub	sp, sp, #68	; 0x44
  status_t status;

  watch (status_t)
  {
    rdv_devices = kernel_malloc (sizeof (const char *)
        * (CHANNEL_RDV_NDEV + 1), true);
    29f4:	e5970000 	ldr	r0, [r7]
  int32_t i = 0;
  status_t status;

  watch (status_t)
  {
    rdv_devices = kernel_malloc (sizeof (const char *)
    29f8:	e59f813c 	ldr	r8, [pc, #316]	; 2b3c <rdv_init_driver+0x158>
        * (CHANNEL_RDV_NDEV + 1), true);
    29fc:	e0800001 	add	r0, r0, r1
  int32_t i = 0;
  status_t status;

  watch (status_t)
  {
    rdv_devices = kernel_malloc (sizeof (const char *)
    2a00:	e1a00100 	lsl	r0, r0, #2
    2a04:	eb0045a1 	bl	14090 <kernel_malloc>
        * (CHANNEL_RDV_NDEV + 1), true);
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);
    2a08:	e3500000 	cmp	r0, #0
  int32_t i = 0;
  status_t status;

  watch (status_t)
  {
    rdv_devices = kernel_malloc (sizeof (const char *)
    2a0c:	e5880000 	str	r0, [r8]
        * (CHANNEL_RDV_NDEV + 1), true);
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);
    2a10:	0a00003b 	beq	2b04 <rdv_init_driver+0x120>

    rdv = kernel_malloc (sizeof (channel_rdv_t) * (CHANNEL_RDV_NDEV), true);
    2a14:	e5973000 	ldr	r3, [r7]
    2a18:	e3a01001 	mov	r1, #1
    2a1c:	e0830083 	add	r0, r3, r3, lsl #1
    2a20:	e1a00180 	lsl	r0, r0, #3
    2a24:	eb004599 	bl	14090 <kernel_malloc>
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);
    2a28:	e5983000 	ldr	r3, [r8]
  {
    rdv_devices = kernel_malloc (sizeof (const char *)
        * (CHANNEL_RDV_NDEV + 1), true);
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);

    rdv = kernel_malloc (sizeof (channel_rdv_t) * (CHANNEL_RDV_NDEV), true);
    2a2c:	e59f910c 	ldr	r9, [pc, #268]	; 2b40 <rdv_init_driver+0x15c>
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);
    2a30:	e3530000 	cmp	r3, #0
  {
    rdv_devices = kernel_malloc (sizeof (const char *)
        * (CHANNEL_RDV_NDEV + 1), true);
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);

    rdv = kernel_malloc (sizeof (channel_rdv_t) * (CHANNEL_RDV_NDEV), true);
    2a34:	e5890000 	str	r0, [r9]
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);
    2a38:	0a000031 	beq	2b04 <rdv_init_driver+0x120>

    for (i = 0; i < CHANNEL_RDV_NDEV; i++)
    2a3c:	e5972000 	ldr	r2, [r7]
    2a40:	e3520000 	cmp	r2, #0
    2a44:	da000039 	ble	2b30 <rdv_init_driver+0x14c>
    2a48:	e3a06000 	mov	r6, #0
    2a4c:	e1a04006 	mov	r4, r6
    2a50:	ea000017 	b	2ab4 <rdv_init_driver+0xd0>
       */

      buffer = kernel_malloc (DNA_FILENAME_LENGTH, false);
      check (invalid_buffer, buffer != NULL, DNA_OUT_OF_MEM);
      
      dna_itoa (i, ascii);
    2a54:	e1a00004 	mov	r0, r4
    2a58:	e1a0100d 	mov	r1, sp
    2a5c:	eb0035f6 	bl	1023c <dna_itoa>
      dna_strcpy (buffer, base);
    2a60:	e59f10dc 	ldr	r1, [pc, #220]	; 2b44 <rdv_init_driver+0x160>
    2a64:	e1a00005 	mov	r0, r5
    2a68:	eb003582 	bl	10078 <dna_strcpy>
      dna_strcat (buffer, ascii);
    2a6c:	e1a0100d 	mov	r1, sp
    2a70:	e1a00005 	mov	r0, r5
    2a74:	eb003500 	bl	fe7c <dna_strcat>
      rdv_devices[i] = buffer;
    2a78:	e5983000 	ldr	r3, [r8]

      /*
       * Create the channel semaphore
       */

      status = semaphore_create (buffer, 0, & rdv[i] . sem);
    2a7c:	e1a00005 	mov	r0, r5
      check (invalid_buffer, buffer != NULL, DNA_OUT_OF_MEM);
      
      dna_itoa (i, ascii);
      dna_strcpy (buffer, base);
      dna_strcat (buffer, ascii);
      rdv_devices[i] = buffer;
    2a80:	e7835104 	str	r5, [r3, r4, lsl #2]

      /*
       * Create the channel semaphore
       */

      status = semaphore_create (buffer, 0, & rdv[i] . sem);
    2a84:	e5992000 	ldr	r2, [r9]
    2a88:	e3a01000 	mov	r1, #0
    2a8c:	e0822006 	add	r2, r2, r6
    2a90:	eb004152 	bl	12fe0 <semaphore_create>
      ensure (status == DNA_OK, status);
    2a94:	e3500000 	cmp	r0, #0
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);

    rdv = kernel_malloc (sizeof (channel_rdv_t) * (CHANNEL_RDV_NDEV), true);
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);

    for (i = 0; i < CHANNEL_RDV_NDEV; i++)
    2a98:	e2844001 	add	r4, r4, #1
      check (invalid_buffer, buffer != NULL, DNA_OUT_OF_MEM);
      
      dna_itoa (i, ascii);
      dna_strcpy (buffer, base);
      dna_strcat (buffer, ascii);
      rdv_devices[i] = buffer;
    2a9c:	e59f2098 	ldr	r2, [pc, #152]	; 2b3c <rdv_init_driver+0x158>
      /*
       * Create the channel semaphore
       */

      status = semaphore_create (buffer, 0, & rdv[i] . sem);
      ensure (status == DNA_OK, status);
    2aa0:	1a000018 	bne	2b08 <rdv_init_driver+0x124>
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);

    rdv = kernel_malloc (sizeof (channel_rdv_t) * (CHANNEL_RDV_NDEV), true);
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);

    for (i = 0; i < CHANNEL_RDV_NDEV; i++)
    2aa4:	e5973000 	ldr	r3, [r7]
    2aa8:	e2866018 	add	r6, r6, #24
    2aac:	e1530004 	cmp	r3, r4
    2ab0:	da000016 	ble	2b10 <rdv_init_driver+0x12c>
    {
      /*
       * Create the channel name
       */

      buffer = kernel_malloc (DNA_FILENAME_LENGTH, false);
    2ab4:	e3a00c01 	mov	r0, #256	; 0x100
    2ab8:	e3a01000 	mov	r1, #0
    2abc:	eb004573 	bl	14090 <kernel_malloc>
      check (invalid_buffer, buffer != NULL, DNA_OUT_OF_MEM);
    2ac0:	e2505000 	subs	r5, r0, #0
    2ac4:	1affffe2 	bne	2a54 <rdv_init_driver+0x70>
    return DNA_OK;
  }

  rescue (invalid_buffer)
  {
    for (i = 0; i < CHANNEL_RDV_NDEV; i++)
    2ac8:	e5973000 	ldr	r3, [r7]
    2acc:	e3530000 	cmp	r3, #0
    2ad0:	c5982000 	ldrgt	r2, [r8]
    2ad4:	da000013 	ble	2b28 <rdv_init_driver+0x144>
    {
      if (rdv_devices[i] != NULL) kernel_free ((void *)rdv_devices[i]);
    2ad8:	e7920105 	ldr	r0, [r2, r5, lsl #2]
    return DNA_OK;
  }

  rescue (invalid_buffer)
  {
    for (i = 0; i < CHANNEL_RDV_NDEV; i++)
    2adc:	e2855001 	add	r5, r5, #1
    {
      if (rdv_devices[i] != NULL) kernel_free ((void *)rdv_devices[i]);
    2ae0:	e3500000 	cmp	r0, #0
    2ae4:	0a000002 	beq	2af4 <rdv_init_driver+0x110>
    2ae8:	eb00459d 	bl	14164 <kernel_free>
    2aec:	e5982000 	ldr	r2, [r8]
    2af0:	e5973000 	ldr	r3, [r7]
    return DNA_OK;
  }

  rescue (invalid_buffer)
  {
    for (i = 0; i < CHANNEL_RDV_NDEV; i++)
    2af4:	e1550003 	cmp	r5, r3
    2af8:	bafffff6 	blt	2ad8 <rdv_init_driver+0xf4>
    {
      if (rdv_devices[i] != NULL) kernel_free ((void *)rdv_devices[i]);
    }

    kernel_free (rdv_devices);
    2afc:	e1a00002 	mov	r0, r2
    2b00:	eb004597 	bl	14164 <kernel_free>
    leave;
    2b04:	e59f003c 	ldr	r0, [pc, #60]	; 2b48 <rdv_init_driver+0x164>
  }
}
    2b08:	e28dd044 	add	sp, sp, #68	; 0x44
    2b0c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
    2b10:	e5923000 	ldr	r3, [r2]
    2b14:	e1a04104 	lsl	r4, r4, #2

      status = semaphore_create (buffer, 0, & rdv[i] . sem);
      ensure (status == DNA_OK, status);
    }

    rdv_devices[i] = NULL;
    2b18:	e3a00000 	mov	r0, #0
    2b1c:	e7830004 	str	r0, [r3, r4]
    }

    kernel_free (rdv_devices);
    leave;
  }
}
    2b20:	e28dd044 	add	sp, sp, #68	; 0x44
    2b24:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
    2b28:	e5982000 	ldr	r2, [r8]
    2b2c:	eafffff2 	b	2afc <rdv_init_driver+0x118>
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);

    rdv = kernel_malloc (sizeof (channel_rdv_t) * (CHANNEL_RDV_NDEV), true);
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);

    for (i = 0; i < CHANNEL_RDV_NDEV; i++)
    2b30:	e3a04000 	mov	r4, #0
    2b34:	eafffff7 	b	2b18 <rdv_init_driver+0x134>
    2b38:	0003e994 	.word	0x0003e994
    2b3c:	0013ea28 	.word	0x0013ea28
    2b40:	0013ea2c 	.word	0x0013ea2c
    2b44:	000327f4 	.word	0x000327f4
    2b48:	0000fffd 	.word	0x0000fffd

00002b4c <rdv_open>:
{
  int32_t id;

  watch (status_t)
  {
    ensure (name != NULL, DNA_ERROR);
    2b4c:	e3500000 	cmp	r0, #0
    2b50:	0a00000b 	beq	2b84 <rdv_open+0x38>
#include <Private/Driver.h>
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rdv_open (char * name, int32_t mode, void ** data)
{
    2b54:	e92d4010 	push	{r4, lr}
    /*
     * Get the channel ID from the beginning
     * of the path.
     */

    id = dna_atoi (& name[19]);
    2b58:	e2800013 	add	r0, r0, #19
    2b5c:	e1a04002 	mov	r4, r2
    2b60:	eb003582 	bl	10170 <dna_atoi>
    ensure (id >= 0 && id < CHANNEL_RDV_NDEV, DNA_ERROR);
    2b64:	e2503000 	subs	r3, r0, #0
    2b68:	ba000003 	blt	2b7c <rdv_open+0x30>
    2b6c:	e59f2034 	ldr	r2, [pc, #52]	; 2ba8 <rdv_open+0x5c>
    2b70:	e5922000 	ldr	r2, [r2]
    2b74:	e1530002 	cmp	r3, r2
    2b78:	ba000003 	blt	2b8c <rdv_open+0x40>
{
  int32_t id;

  watch (status_t)
  {
    ensure (name != NULL, DNA_ERROR);
    2b7c:	e59f0028 	ldr	r0, [pc, #40]	; 2bac <rdv_open+0x60>
    2b80:	e8bd8010 	pop	{r4, pc}
    2b84:	e59f0020 	ldr	r0, [pc, #32]	; 2bac <rdv_open+0x60>
     */

    *data = (void *) & rdv[id];
    return DNA_OK;
  }
}
    2b88:	e12fff1e 	bx	lr

    /*
     * Return the device
     */

    *data = (void *) & rdv[id];
    2b8c:	e59f201c 	ldr	r2, [pc, #28]	; 2bb0 <rdv_open+0x64>
    2b90:	e0833083 	add	r3, r3, r3, lsl #1
    2b94:	e5922000 	ldr	r2, [r2]
    return DNA_OK;
    2b98:	e3a00000 	mov	r0, #0

    /*
     * Return the device
     */

    *data = (void *) & rdv[id];
    2b9c:	e0823183 	add	r3, r2, r3, lsl #3
    2ba0:	e5843000 	str	r3, [r4]
    return DNA_OK;
  }
}
    2ba4:	e8bd8010 	pop	{r4, pc}
    2ba8:	0003e994 	.word	0x0003e994
    2bac:	0000ffff 	.word	0x0000ffff
    2bb0:	0013ea2c 	.word	0x0013ea2c

00002bb4 <rdv_init_hardware>:
#include <DnaTools/DnaTools.h>

status_t rdv_init_hardware (void)
{
  return DNA_OK;
}
    2bb4:	e3a00000 	mov	r0, #0
    2bb8:	e12fff1e 	bx	lr

00002bbc <rdv_free>:
#include <DnaTools/DnaTools.h>

status_t rdv_free (void * data)
{
  return DNA_NOT_IMPLEMENTED;
}
    2bbc:	e59f0000 	ldr	r0, [pc]	; 2bc4 <rdv_free+0x8>
    2bc0:	e12fff1e 	bx	lr
    2bc4:	0000fffe 	.word	0x0000fffe

00002bc8 <rdv_control>:

#include <Private/Driver.h>

status_t rdv_control (void * handler, int32_t operation,
    va_list arguments, int32_t * p_res)
{
    2bc8:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
    2bcc:	e1a05001 	mov	r5, r1
  bool * result = NULL;
  status_t status = DNA_OK;
  interrupt_status_t it_status;

  it_status = cpu_trap_mask_and_backup ();
  lock_acquire (& rdv -> lock);
    2bd0:	e2806004 	add	r6, r0, #4

#include <Private/Driver.h>

status_t rdv_control (void * handler, int32_t operation,
    va_list arguments, int32_t * p_res)
{
    2bd4:	e1a09002 	mov	r9, r2
    2bd8:	e1a08003 	mov	r8, r3
    2bdc:	e1a04000 	mov	r4, r0
  channel_rdv_t * rdv = (channel_rdv_t *)handler;
  bool * result = NULL;
  status_t status = DNA_OK;
  interrupt_status_t it_status;

  it_status = cpu_trap_mask_and_backup ();
    2be0:	eb00362a 	bl	10490 <cpu_trap_mask_and_backup>
    2be4:	e1a07000 	mov	r7, r0
  lock_acquire (& rdv -> lock);
    2be8:	e1a00006 	mov	r0, r6
    2bec:	eb003773 	bl	109c0 <lock_acquire>
  
  switch (operation)
    2bf0:	e3550a01 	cmp	r5, #4096	; 0x1000
    2bf4:	0a000017 	beq	2c58 <rdv_control+0x90>
    2bf8:	e59f30c4 	ldr	r3, [pc, #196]	; 2cc4 <rdv_control+0xfc>
    2bfc:	e1550003 	cmp	r5, r3
    2c00:	0a00001c 	beq	2c78 <rdv_control+0xb0>
    2c04:	e2433002 	sub	r3, r3, #2
    2c08:	e1550003 	cmp	r5, r3
    2c0c:	0a000008 	beq	2c34 <rdv_control+0x6c>
      }

      break;

    default :
      *p_res = -1;
    2c10:	e3e03000 	mvn	r3, #0
      status = DNA_ERROR;
    2c14:	e59f40ac 	ldr	r4, [pc, #172]	; 2cc8 <rdv_control+0x100>
      }

      break;

    default :
      *p_res = -1;
    2c18:	e5883000 	str	r3, [r8]
      status = DNA_ERROR;
      break;
  }

  lock_release (& rdv -> lock);
    2c1c:	e1a00006 	mov	r0, r6
    2c20:	eb00421a 	bl	13490 <lock_release>
  cpu_trap_restore (it_status);
    2c24:	e1a00007 	mov	r0, r7
    2c28:	eb003651 	bl	10574 <cpu_trap_restore>
 
  return status;
}
    2c2c:	e1a00004 	mov	r0, r4
    2c30:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  switch (operation)
  {
    case RDV_RTEST :
      result = va_arg (arguments, bool *);

      if (rdv -> setter . ready)
    2c34:	e5d4300c 	ldrb	r3, [r4, #12]
  lock_acquire (& rdv -> lock);
  
  switch (operation)
  {
    case RDV_RTEST :
      result = va_arg (arguments, bool *);
    2c38:	e5992000 	ldr	r2, [r9]

      if (rdv -> setter . ready)
    2c3c:	e21330ff 	ands	r3, r3, #255	; 0xff
    2c40:	0a000008 	beq	2c68 <rdv_control+0xa0>
    case RDV_WTEST :
      result = va_arg (arguments, bool *);

      if (rdv -> getter . ready)
      {
        *result = true;
    2c44:	e3a03001 	mov	r3, #1
status_t rdv_control (void * handler, int32_t operation,
    va_list arguments, int32_t * p_res)
{
  channel_rdv_t * rdv = (channel_rdv_t *)handler;
  bool * result = NULL;
  status_t status = DNA_OK;
    2c48:	e3a04000 	mov	r4, #0
    case RDV_WTEST :
      result = va_arg (arguments, bool *);

      if (rdv -> getter . ready)
      {
        *result = true;
    2c4c:	e5c23000 	strb	r3, [r2]
        *p_res = 1;
    2c50:	e5883000 	str	r3, [r8]
    2c54:	eafffff0 	b	2c1c <rdv_control+0x54>
      break;

    case RDV_WTEST :
      result = va_arg (arguments, bool *);

      if (rdv -> getter . ready)
    2c58:	e5d43014 	ldrb	r3, [r4, #20]
      }

      break;

    case RDV_WTEST :
      result = va_arg (arguments, bool *);
    2c5c:	e5992000 	ldr	r2, [r9]

      if (rdv -> getter . ready)
    2c60:	e21330ff 	ands	r3, r3, #255	; 0xff
    2c64:	1afffff6 	bne	2c44 <rdv_control+0x7c>
        *result = true;
        *p_res = 1;
      }
      else
      {
        *result = false;
    2c68:	e5c23000 	strb	r3, [r2]
status_t rdv_control (void * handler, int32_t operation,
    va_list arguments, int32_t * p_res)
{
  channel_rdv_t * rdv = (channel_rdv_t *)handler;
  bool * result = NULL;
  status_t status = DNA_OK;
    2c6c:	e1a04003 	mov	r4, r3
        *p_res = 1;
      }
      else
      {
        *result = false;
        *p_res = 0;
    2c70:	e5883000 	str	r3, [r8]
    2c74:	eaffffe8 	b	2c1c <rdv_control+0x54>
      }

      break;

    case RDV_RESET :
      if (rdv -> getter . ready || rdv -> setter . ready)
    2c78:	e5d43014 	ldrb	r3, [r4, #20]
    2c7c:	e3530000 	cmp	r3, #0
    2c80:	1a000004 	bne	2c98 <rdv_control+0xd0>
    2c84:	e5d4300c 	ldrb	r3, [r4, #12]
    2c88:	e21330ff 	ands	r3, r3, #255	; 0xff
        semaphore_release (rdv -> sem, 1, DNA_NO_RESCHEDULE);
        *p_res = 1;
      }
      else
      {
        *p_res = 0;
    2c8c:	05883000 	streq	r3, [r8]
status_t rdv_control (void * handler, int32_t operation,
    va_list arguments, int32_t * p_res)
{
  channel_rdv_t * rdv = (channel_rdv_t *)handler;
  bool * result = NULL;
  status_t status = DNA_OK;
    2c90:	01a04003 	moveq	r4, r3
      }

      break;

    case RDV_RESET :
      if (rdv -> getter . ready || rdv -> setter . ready)
    2c94:	0affffe0 	beq	2c1c <rdv_control+0x54>
      {
        rdv -> getter . ready = false;
    2c98:	e3a05000 	mov	r5, #0
        rdv -> setter . ready = false;
        semaphore_release (rdv -> sem, 1, DNA_NO_RESCHEDULE);
    2c9c:	e3a01001 	mov	r1, #1
      break;

    case RDV_RESET :
      if (rdv -> getter . ready || rdv -> setter . ready)
      {
        rdv -> getter . ready = false;
    2ca0:	e5c45014 	strb	r5, [r4, #20]
        rdv -> setter . ready = false;
        semaphore_release (rdv -> sem, 1, DNA_NO_RESCHEDULE);
    2ca4:	e5940000 	ldr	r0, [r4]

    case RDV_RESET :
      if (rdv -> getter . ready || rdv -> setter . ready)
      {
        rdv -> getter . ready = false;
        rdv -> setter . ready = false;
    2ca8:	e5c4500c 	strb	r5, [r4, #12]
        semaphore_release (rdv -> sem, 1, DNA_NO_RESCHEDULE);
    2cac:	e1a02001 	mov	r2, r1
    2cb0:	eb00416d 	bl	1326c <semaphore_release>
        *p_res = 1;
    2cb4:	e3a03001 	mov	r3, #1
status_t rdv_control (void * handler, int32_t operation,
    va_list arguments, int32_t * p_res)
{
  channel_rdv_t * rdv = (channel_rdv_t *)handler;
  bool * result = NULL;
  status_t status = DNA_OK;
    2cb8:	e1a04005 	mov	r4, r5
      if (rdv -> getter . ready || rdv -> setter . ready)
      {
        rdv -> getter . ready = false;
        rdv -> setter . ready = false;
        semaphore_release (rdv -> sem, 1, DNA_NO_RESCHEDULE);
        *p_res = 1;
    2cbc:	e5883000 	str	r3, [r8]
    2cc0:	eaffffd5 	b	2c1c <rdv_control+0x54>
    2cc4:	00001001 	.word	0x00001001
    2cc8:	0000ffff 	.word	0x0000ffff

00002ccc <devfs_read_vnode>:

#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_read_vnode (void * ns, int64_t vnid, void ** data)
{
    2ccc:	e92d4010 	push	{r4, lr}
  devfs_inode_t inode = NULL;
  devfs_entry_t entry = NULL;

  watch (status_t)
  {
    inode = queue_lookup (& devfs -> inode_list,
    2cd0:	e2800014 	add	r0, r0, #20
    2cd4:	e59f1054 	ldr	r1, [pc, #84]	; 2d30 <devfs_read_vnode+0x64>
    2cd8:	eb003484 	bl	fef0 <queue_lookup>
        devfs_inode_id_inspector, vnid);
    ensure (inode != NULL, DNA_NO_VNODE);
    2cdc:	e2504000 	subs	r4, r0, #0
    2ce0:	0a00000e 	beq	2d20 <devfs_read_vnode+0x54>

    dna_log(VERBOSE_LEVEL, "Read inode [%s].", inode -> name);

    if (inode -> parent != NULL)
    2ce4:	e5940014 	ldr	r0, [r4, #20]
    2ce8:	e3500000 	cmp	r0, #0
    2cec:	0a000007 	beq	2d10 <devfs_read_vnode+0x44>
    {
      entry = queue_lookup (& inode -> parent -> entry_list,
    2cf0:	e2800f4b 	add	r0, r0, #300	; 0x12c
    2cf4:	e59f1038 	ldr	r1, [pc, #56]	; 2d34 <devfs_read_vnode+0x68>
    2cf8:	e2842018 	add	r2, r4, #24
    2cfc:	eb00347b 	bl	fef0 <queue_lookup>
          devfs_entry_name_inspector, inode -> name);
      ensure (entry != NULL, DNA_NO_ENTRY);
    2d00:	e3500000 	cmp	r0, #0
    2d04:	0a000007 	beq	2d28 <devfs_read_vnode+0x5c>

      entry -> loaded = true;
    2d08:	e3a03001 	mov	r3, #1
    2d0c:	e5c03010 	strb	r3, [r0, #16]
    }

    *data = inode;
    2d10:	e59d3008 	ldr	r3, [sp, #8]
    return DNA_OK;
    2d14:	e3a00000 	mov	r0, #0
      ensure (entry != NULL, DNA_NO_ENTRY);

      entry -> loaded = true;
    }

    *data = inode;
    2d18:	e5834000 	str	r4, [r3]
    return DNA_OK;
    2d1c:	e8bd8010 	pop	{r4, pc}

  watch (status_t)
  {
    inode = queue_lookup (& devfs -> inode_list,
        devfs_inode_id_inspector, vnid);
    ensure (inode != NULL, DNA_NO_VNODE);
    2d20:	e59f0010 	ldr	r0, [pc, #16]	; 2d38 <devfs_read_vnode+0x6c>
    2d24:	e8bd8010 	pop	{r4, pc}

    if (inode -> parent != NULL)
    {
      entry = queue_lookup (& inode -> parent -> entry_list,
          devfs_entry_name_inspector, inode -> name);
      ensure (entry != NULL, DNA_NO_ENTRY);
    2d28:	e59f000c 	ldr	r0, [pc, #12]	; 2d3c <devfs_read_vnode+0x70>
    }

    *data = inode;
    return DNA_OK;
  }
}
    2d2c:	e8bd8010 	pop	{r4, pc}
    2d30:	00003ca4 	.word	0x00003ca4
    2d34:	00003c70 	.word	0x00003c70
    2d38:	0000fefd 	.word	0x0000fefd
    2d3c:	0000feff 	.word	0x0000feff

00002d40 <devfs_ioctl>:
{
  devfs_inode_t inode = node;

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    2d40:	e5d1c010 	ldrb	ip, [r1, #16]
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_ioctl (void * ns, void * node, void * data,
    int32_t function, va_list arguments, int32_t * p_ret)
{
    2d44:	e92d4010 	push	{r4, lr}
  devfs_inode_t inode = node;

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    2d48:	e35c0000 	cmp	ip, #0
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_ioctl (void * ns, void * node, void * data,
    int32_t function, va_list arguments, int32_t * p_ret)
{
    2d4c:	e59d4008 	ldr	r4, [sp, #8]
    2d50:	e59de00c 	ldr	lr, [sp, #12]
  devfs_inode_t inode = node;

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    2d54:	1a00000b 	bne	2d88 <devfs_ioctl+0x48>
    {
      ensure (inode -> dev_cmd -> control != NULL, DNA_ERROR);
    2d58:	e5911128 	ldr	r1, [r1, #296]	; 0x128
    2d5c:	e591c014 	ldr	ip, [r1, #20]
    2d60:	e35c0000 	cmp	ip, #0
    2d64:	0a000005 	beq	2d80 <devfs_ioctl+0x40>
      return inode -> dev_cmd -> control (data, function, arguments, p_ret);
    2d68:	e1a00002 	mov	r0, r2
    2d6c:	e1a01003 	mov	r1, r3
    2d70:	e1a02004 	mov	r2, r4
    2d74:	e1a0300e 	mov	r3, lr
    }

    return DNA_OK;
  }
}
    2d78:	e8bd4010 	pop	{r4, lr}
  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    {
      ensure (inode -> dev_cmd -> control != NULL, DNA_ERROR);
      return inode -> dev_cmd -> control (data, function, arguments, p_ret);
    2d7c:	e12fff1c 	bx	ip

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    {
      ensure (inode -> dev_cmd -> control != NULL, DNA_ERROR);
    2d80:	e59f0008 	ldr	r0, [pc, #8]	; 2d90 <devfs_ioctl+0x50>
      return inode -> dev_cmd -> control (data, function, arguments, p_ret);
    }

    return DNA_OK;
  }
}
    2d84:	e8bd8010 	pop	{r4, pc}
    {
      ensure (inode -> dev_cmd -> control != NULL, DNA_ERROR);
      return inode -> dev_cmd -> control (data, function, arguments, p_ret);
    }

    return DNA_OK;
    2d88:	e3a00000 	mov	r0, #0
    2d8c:	e8bd8010 	pop	{r4, pc}
    2d90:	0000ffff 	.word	0x0000ffff

00002d94 <devfs_read>:
{
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (inode -> dev_cmd -> read != NULL, DNA_ERROR);
    2d94:	e5911128 	ldr	r1, [r1, #296]	; 0x128
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_read (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
    2d98:	e92d0030 	push	{r4, r5}
    2d9c:	e1cd40d8 	ldrd	r4, [sp, #8]
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (inode -> dev_cmd -> read != NULL, DNA_ERROR);
    2da0:	e591c00c 	ldr	ip, [r1, #12]
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_read (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
    2da4:	e59d1010 	ldr	r1, [sp, #16]
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (inode -> dev_cmd -> read != NULL, DNA_ERROR);
    2da8:	e35c0000 	cmp	ip, #0
    2dac:	0a000006 	beq	2dcc <devfs_read+0x38>
    return inode -> dev_cmd -> read (file, data, offset, p_count);
    2db0:	e58d1008 	str	r1, [sp, #8]
    2db4:	e1a00002 	mov	r0, r2
    2db8:	e1a01003 	mov	r1, r3
    2dbc:	e1a02004 	mov	r2, r4
    2dc0:	e1a03005 	mov	r3, r5
  }
}
    2dc4:	e8bd0030 	pop	{r4, r5}
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (inode -> dev_cmd -> read != NULL, DNA_ERROR);
    return inode -> dev_cmd -> read (file, data, offset, p_count);
    2dc8:	e12fff1c 	bx	ip
  }
}
    2dcc:	e59f0004 	ldr	r0, [pc, #4]	; 2dd8 <devfs_read+0x44>
    2dd0:	e8bd0030 	pop	{r4, r5}
    2dd4:	e12fff1e 	bx	lr
    2dd8:	0000ffff 	.word	0x0000ffff

00002ddc <devfs_entry_unused_inspector>:

#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

bool devfs_entry_unused_inspector (void * entry, va_list list)
{
    2ddc:	e92d4070 	push	{r4, r5, r6, lr}
  bool is_dot, is_dotdot;
  devfs_entry_t e = entry;

  watch (bool)
  {
    ensure (e != NULL, false);
    2de0:	e2504000 	subs	r4, r0, #0
    2de4:	0a00000e 	beq	2e24 <devfs_entry_unused_inspector+0x48>

    is_dot = dna_strcmp (e -> name, ".") == 0;
    2de8:	e2846011 	add	r6, r4, #17
    2dec:	e1a00006 	mov	r0, r6
    2df0:	e59f1034 	ldr	r1, [pc, #52]	; 2e2c <devfs_entry_unused_inspector+0x50>
    2df4:	eb003431 	bl	fec0 <dna_strcmp>
    is_dotdot = dna_strcmp (e -> name, "..") == 0;
    2df8:	e59f1030 	ldr	r1, [pc, #48]	; 2e30 <devfs_entry_unused_inspector+0x54>

  watch (bool)
  {
    ensure (e != NULL, false);

    is_dot = dna_strcmp (e -> name, ".") == 0;
    2dfc:	e1a05000 	mov	r5, r0
    is_dotdot = dna_strcmp (e -> name, "..") == 0;
    2e00:	e1a00006 	mov	r0, r6
    2e04:	eb00342d 	bl	fec0 <dna_strcmp>

    return  ! is_dot && ! is_dotdot && ! e -> loaded;
    2e08:	e3500000 	cmp	r0, #0
    2e0c:	13550000 	cmpne	r5, #0
    2e10:	13a00001 	movne	r0, #1
    2e14:	03a00000 	moveq	r0, #0
    2e18:	15d40010 	ldrbne	r0, [r4, #16]
    2e1c:	12200001 	eorne	r0, r0, #1
    2e20:	e8bd8070 	pop	{r4, r5, r6, pc}
  bool is_dot, is_dotdot;
  devfs_entry_t e = entry;

  watch (bool)
  {
    ensure (e != NULL, false);
    2e24:	e1a00004 	mov	r0, r4
    is_dot = dna_strcmp (e -> name, ".") == 0;
    is_dotdot = dna_strcmp (e -> name, "..") == 0;

    return  ! is_dot && ! is_dotdot && ! e -> loaded;
  }
}
    2e28:	e8bd8070 	pop	{r4, r5, r6, pc}
    2e2c:	00032c70 	.word	0x00032c70
    2e30:	00032808 	.word	0x00032808

00002e34 <devfs_inode_create>:
#include <MemoryManager/MemoryManager.h>

status_t devfs_inode_create (devfs_t fs, devfs_inode_t parent,
    devfs_inode_class_t class, char * name, int64_t vnid,
    device_cmd_t * commands, devfs_inode_t * p_inode)
{
    2e34:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int32_t path_length = 0;
  devfs_inode_t inode;

  watch (status_t)
  {
    ensure (name != NULL, DNA_BAD_ARGUMENT);
    2e38:	e253a000 	subs	sl, r3, #0
    2e3c:	0a000039 	beq	2f28 <devfs_inode_create+0xf4>

    if (parent != NULL && parent -> id != fs -> root_vnid)
    2e40:	e3510000 	cmp	r1, #0
    2e44:	e1a08000 	mov	r8, r0
    2e48:	e1a09001 	mov	r9, r1
    2e4c:	e1a0b002 	mov	fp, r2
    2e50:	01a04001 	moveq	r4, r1
    2e54:	0a000008 	beq	2e7c <devfs_inode_create+0x48>
    2e58:	e1c040d8 	ldrd	r4, [r0, #8]
    2e5c:	e1c160d8 	ldrd	r6, [r1, #8]
    2e60:	e1570005 	cmp	r7, r5
    2e64:	01560004 	cmpeq	r6, r4
    2e68:	03a04000 	moveq	r4, #0
    2e6c:	0a000002 	beq	2e7c <devfs_inode_create+0x48>
    {
      path_length = dna_strlen (parent -> path);
    2e70:	e2810f4f 	add	r0, r1, #316	; 0x13c
    2e74:	eb00344a 	bl	ffa4 <dna_strlen>
    2e78:	e1a04000 	mov	r4, r0
    }

    path_length += dna_strlen (name);
    2e7c:	e1a0000a 	mov	r0, sl
    2e80:	eb003447 	bl	ffa4 <dna_strlen>
    2e84:	e0800004 	add	r0, r0, r4
    inode = kernel_malloc (sizeof (struct _devfs_inode) + path_length, true);
    2e88:	e2800d05 	add	r0, r0, #320	; 0x140
    2e8c:	e3a01001 	mov	r1, #1
    2e90:	eb00447e 	bl	14090 <kernel_malloc>
    ensure (inode != NULL, DNA_OUT_OF_MEM);
    2e94:	e2506000 	subs	r6, r0, #0
    2e98:	0a000020 	beq	2f20 <devfs_inode_create+0xec>

    inode -> id = vnid;
    2e9c:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
    2ea0:	e1c620f8 	strd	r2, [r6, #8]
    inode -> class = class;
    inode -> parent = parent;
    inode -> dev_cmd = commands;
    2ea4:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
    path_length += dna_strlen (name);
    inode = kernel_malloc (sizeof (struct _devfs_inode) + path_length, true);
    ensure (inode != NULL, DNA_OUT_OF_MEM);

    inode -> id = vnid;
    inode -> class = class;
    2ea8:	e5c6b010 	strb	fp, [r6, #16]
    inode -> parent = parent;
    2eac:	e5869014 	str	r9, [r6, #20]
    inode -> dev_cmd = commands;
    2eb0:	e5863128 	str	r3, [r6, #296]	; 0x128
    dna_strcpy (inode -> name, name);
    2eb4:	e2860018 	add	r0, r6, #24
    2eb8:	e1a0100a 	mov	r1, sl
    2ebc:	eb00346d 	bl	10078 <dna_strcpy>
    
    if (parent != NULL && parent -> id != fs -> root_vnid)
    2ec0:	e3590000 	cmp	r9, #0
    2ec4:	0a000019 	beq	2f30 <devfs_inode_create+0xfc>
    2ec8:	e1c940d8 	ldrd	r4, [r9, #8]
    2ecc:	e1c820d8 	ldrd	r2, [r8, #8]
    2ed0:	e1550003 	cmp	r5, r3
    2ed4:	01540002 	cmpeq	r4, r2
    {
      dna_strcpy (inode -> path, parent -> path);
    2ed8:	e2864f4f 	add	r4, r6, #316	; 0x13c
    inode -> class = class;
    inode -> parent = parent;
    inode -> dev_cmd = commands;
    dna_strcpy (inode -> name, name);
    
    if (parent != NULL && parent -> id != fs -> root_vnid)
    2edc:	0a000005 	beq	2ef8 <devfs_inode_create+0xc4>
    {
      dna_strcpy (inode -> path, parent -> path);
    2ee0:	e2891f4f 	add	r1, r9, #316	; 0x13c
    2ee4:	e1a00004 	mov	r0, r4
    2ee8:	eb003462 	bl	10078 <dna_strcpy>
      dna_strcat (inode -> path, "/");
    2eec:	e1a00004 	mov	r0, r4
    2ef0:	e59f1050 	ldr	r1, [pc, #80]	; 2f48 <devfs_inode_create+0x114>
    2ef4:	eb0033e0 	bl	fe7c <dna_strcat>
    }

    dna_strcat (inode -> path, name);
    2ef8:	e1a00004 	mov	r0, r4
    2efc:	e1a0100a 	mov	r1, sl
    2f00:	eb0033dd 	bl	fe7c <dna_strcat>

    if (fs != NULL)
    {
      queue_add (& fs -> inode_list, inode);
    2f04:	e2880014 	add	r0, r8, #20
    2f08:	e1a01006 	mov	r1, r6
    2f0c:	eb0033c0 	bl	fe14 <queue_add>
    }

    *p_inode = inode;
    2f10:	e59d4034 	ldr	r4, [sp, #52]	; 0x34
    return DNA_OK;
    2f14:	e3a00000 	mov	r0, #0
    if (fs != NULL)
    {
      queue_add (& fs -> inode_list, inode);
    }

    *p_inode = inode;
    2f18:	e5846000 	str	r6, [r4]
    return DNA_OK;
    2f1c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      path_length = dna_strlen (parent -> path);
    }

    path_length += dna_strlen (name);
    inode = kernel_malloc (sizeof (struct _devfs_inode) + path_length, true);
    ensure (inode != NULL, DNA_OUT_OF_MEM);
    2f20:	e59f0024 	ldr	r0, [pc, #36]	; 2f4c <devfs_inode_create+0x118>
    2f24:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  int32_t path_length = 0;
  devfs_inode_t inode;

  watch (status_t)
  {
    ensure (name != NULL, DNA_BAD_ARGUMENT);
    2f28:	e59f0020 	ldr	r0, [pc, #32]	; 2f50 <devfs_inode_create+0x11c>
    2f2c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    {
      dna_strcpy (inode -> path, parent -> path);
      dna_strcat (inode -> path, "/");
    }

    dna_strcat (inode -> path, name);
    2f30:	e1a0100a 	mov	r1, sl
    2f34:	e2860f4f 	add	r0, r6, #316	; 0x13c
    2f38:	eb0033cf 	bl	fe7c <dna_strcat>

    if (fs != NULL)
    2f3c:	e3580000 	cmp	r8, #0
    2f40:	0afffff2 	beq	2f10 <devfs_inode_create+0xdc>
    2f44:	eaffffee 	b	2f04 <devfs_inode_create+0xd0>
    2f48:	0003280c 	.word	0x0003280c
    2f4c:	0000fffd 	.word	0x0000fffd
    2f50:	0000fffc 	.word	0x0000fffc

00002f54 <devfs_free>:
{
  devfs_inode_t inode = node;

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    2f54:	e5d13010 	ldrb	r3, [r1, #16]
    2f58:	e3530000 	cmp	r3, #0
    2f5c:	1a000007 	bne	2f80 <devfs_free+0x2c>
    {
      ensure (inode -> dev_cmd -> free != NULL, DNA_ERROR);
    2f60:	e5913128 	ldr	r3, [r1, #296]	; 0x128
    2f64:	e5933008 	ldr	r3, [r3, #8]
    2f68:	e3530000 	cmp	r3, #0
    2f6c:	0a000001 	beq	2f78 <devfs_free+0x24>
      return inode -> dev_cmd -> free (data);
    2f70:	e1a00002 	mov	r0, r2
    2f74:	e12fff13 	bx	r3

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    {
      ensure (inode -> dev_cmd -> free != NULL, DNA_ERROR);
    2f78:	e59f0008 	ldr	r0, [pc, #8]	; 2f88 <devfs_free+0x34>
      return inode -> dev_cmd -> free (data);
    }

    return DNA_OK;
  }
}
    2f7c:	e12fff1e 	bx	lr
    {
      ensure (inode -> dev_cmd -> free != NULL, DNA_ERROR);
      return inode -> dev_cmd -> free (data);
    }

    return DNA_OK;
    2f80:	e3a00000 	mov	r0, #0
    2f84:	e12fff1e 	bx	lr
    2f88:	0000ffff 	.word	0x0000ffff

00002f8c <devfs_write>:
{
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (inode -> dev_cmd -> write != NULL, DNA_ERROR);
    2f8c:	e5911128 	ldr	r1, [r1, #296]	; 0x128
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_write (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
    2f90:	e92d0030 	push	{r4, r5}
    2f94:	e1cd40d8 	ldrd	r4, [sp, #8]
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (inode -> dev_cmd -> write != NULL, DNA_ERROR);
    2f98:	e591c010 	ldr	ip, [r1, #16]
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_write (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
    2f9c:	e59d1010 	ldr	r1, [sp, #16]
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (inode -> dev_cmd -> write != NULL, DNA_ERROR);
    2fa0:	e35c0000 	cmp	ip, #0
    2fa4:	0a000006 	beq	2fc4 <devfs_write+0x38>
    return inode -> dev_cmd -> write (file, data, offset, p_count);
    2fa8:	e58d1008 	str	r1, [sp, #8]
    2fac:	e1a00002 	mov	r0, r2
    2fb0:	e1a01003 	mov	r1, r3
    2fb4:	e1a02004 	mov	r2, r4
    2fb8:	e1a03005 	mov	r3, r5
  }
}
    2fbc:	e8bd0030 	pop	{r4, r5}
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (inode -> dev_cmd -> write != NULL, DNA_ERROR);
    return inode -> dev_cmd -> write (file, data, offset, p_count);
    2fc0:	e12fff1c 	bx	ip
  }
}
    2fc4:	e59f0004 	ldr	r0, [pc, #4]	; 2fd0 <devfs_write+0x44>
    2fc8:	e8bd0030 	pop	{r4, r5}
    2fcc:	e12fff1e 	bx	lr
    2fd0:	0000ffff 	.word	0x0000ffff

00002fd4 <devfs_open>:
{
  devfs_inode_t inode = node;

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    2fd4:	e5d10010 	ldrb	r0, [r1, #16]
    2fd8:	e3500000 	cmp	r0, #0
    2fdc:	1a000009 	bne	3008 <devfs_open+0x34>
    {
      ensure (inode -> dev_cmd -> open != NULL, DNA_ERROR);
    2fe0:	e5910128 	ldr	r0, [r1, #296]	; 0x128
    2fe4:	e590c000 	ldr	ip, [r0]
    2fe8:	e35c0000 	cmp	ip, #0
    2fec:	0a000003 	beq	3000 <devfs_open+0x2c>
      return inode -> dev_cmd -> open (inode -> path, mode, data);
    2ff0:	e2810f4f 	add	r0, r1, #316	; 0x13c
    2ff4:	e1a01002 	mov	r1, r2
    2ff8:	e1a02003 	mov	r2, r3
    2ffc:	e12fff1c 	bx	ip

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    {
      ensure (inode -> dev_cmd -> open != NULL, DNA_ERROR);
    3000:	e59f0008 	ldr	r0, [pc, #8]	; 3010 <devfs_open+0x3c>
      return inode -> dev_cmd -> open (inode -> path, mode, data);
    }

    return DNA_OK;
  }
}
    3004:	e12fff1e 	bx	lr
    {
      ensure (inode -> dev_cmd -> open != NULL, DNA_ERROR);
      return inode -> dev_cmd -> open (inode -> path, mode, data);
    }

    return DNA_OK;
    3008:	e3a00000 	mov	r0, #0
    300c:	e12fff1e 	bx	lr
    3010:	0000ffff 	.word	0x0000ffff

00003014 <devfs_create>:
  /*
   * Oops! We don't authorize mkdir on this FS !
   */

  return DNA_ERROR;
}
    3014:	e59f0000 	ldr	r0, [pc]	; 301c <devfs_create+0x8>
    3018:	e12fff1e 	bx	lr
    301c:	0000ffff 	.word	0x0000ffff

00003020 <devfs_set_info>:
status_t devfs_set_info (void * ns, void * node, void * data,
    file_info_t info, int32_t mask)
{

  return DNA_OK;
}
    3020:	e3a00000 	mov	r0, #0
    3024:	e12fff1e 	bx	lr

00003028 <_va_call.4683.constprop.0>:
      case DNA_DEVFS_FILE :
        {
          int32_t ret;
          device_info_t dev_info;

          va_call (list,
    3028:	e92d000f 	push	{r0, r1, r2, r3}
    302c:	e1a0300c 	mov	r3, ip
    3030:	e92d4010 	push	{r4, lr}
    3034:	e59c2008 	ldr	r2, [ip, #8]
    3038:	e24dd008 	sub	sp, sp, #8
    303c:	e5922128 	ldr	r2, [r2, #296]	; 0x128
    3040:	e28dc014 	add	ip, sp, #20
    3044:	e5924014 	ldr	r4, [r2, #20]
    3048:	e4930004 	ldr	r0, [r3], #4
    304c:	e1a0200c 	mov	r2, ip
    3050:	e3a01006 	mov	r1, #6
    3054:	e58dc004 	str	ip, [sp, #4]
    3058:	e12fff34 	blx	r4
    305c:	e28dd008 	add	sp, sp, #8
    3060:	e8bd4010 	pop	{r4, lr}
    3064:	e28dd010 	add	sp, sp, #16
    3068:	e12fff1e 	bx	lr

0000306c <devfs_get_info>:
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_get_info (void * ns, void * node,
    void * data, file_info_t * p_info)
{
    306c:	e92d4030 	push	{r4, r5, lr}
  devfs_t devfs = ns;
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (devfs != NULL, DNA_BAD_ARGUMENT);
    3070:	e2505000 	subs	r5, r0, #0
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_get_info (void * ns, void * node,
    void * data, file_info_t * p_info)
{
    3074:	e24dd024 	sub	sp, sp, #36	; 0x24
  devfs_t devfs = ns;
  devfs_inode_t inode = node;
    3078:	e58d100c 	str	r1, [sp, #12]
 */

#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_get_info (void * ns, void * node,
    307c:	e58d2004 	str	r2, [sp, #4]
  devfs_t devfs = ns;
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (devfs != NULL, DNA_BAD_ARGUMENT);
    3080:	0a000017 	beq	30e4 <devfs_get_info+0x78>
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    3084:	e3510000 	cmp	r1, #0
    3088:	0a000015 	beq	30e4 <devfs_get_info+0x78>
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);
    308c:	e3530000 	cmp	r3, #0
    3090:	e1a04003 	mov	r4, r3
    3094:	0a000012 	beq	30e4 <devfs_get_info+0x78>

    dna_memset (p_info, 0, sizeof (file_info_t));
    3098:	e1a00003 	mov	r0, r3
    309c:	e3a01000 	mov	r1, #0
    30a0:	e3a02040 	mov	r2, #64	; 0x40
    30a4:	eb0030f2 	bl	f474 <dna_memset>

    p_info -> volume = devfs -> vid;
    p_info -> vnode = inode -> id;
    30a8:	e59d300c 	ldr	r3, [sp, #12]
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);

    dna_memset (p_info, 0, sizeof (file_info_t));

    p_info -> volume = devfs -> vid;
    30ac:	e5952010 	ldr	r2, [r5, #16]
    p_info -> vnode = inode -> id;

    switch (inode -> class)
    30b0:	e5d31010 	ldrb	r1, [r3, #16]
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);

    dna_memset (p_info, 0, sizeof (file_info_t));

    p_info -> volume = devfs -> vid;
    30b4:	e5842000 	str	r2, [r4]
    p_info -> vnode = inode -> id;

    switch (inode -> class)
    30b8:	e3510001 	cmp	r1, #1
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);

    dna_memset (p_info, 0, sizeof (file_info_t));

    p_info -> volume = devfs -> vid;
    p_info -> vnode = inode -> id;
    30bc:	e1c320d8 	ldrd	r2, [r3, #8]
    30c0:	e1c420f8 	strd	r2, [r4, #8]

    switch (inode -> class)
    30c4:	0a000002 	beq	30d4 <devfs_get_info+0x68>
    30c8:	3a000008 	bcc	30f0 <devfs_get_info+0x84>
    30cc:	e3510002 	cmp	r1, #2
    30d0:	1a000015 	bne	312c <devfs_get_info+0xc0>
          p_info -> type = DNA_FILE_SYMBOLIC_LINK;
          break;
        }
    }

    return DNA_OK;
    30d4:	e3a00000 	mov	r0, #0
          break;
        }

      case DNA_DEVFS_SYMLINK :
        {
          p_info -> type = DNA_FILE_SYMBOLIC_LINK;
    30d8:	e5c41010 	strb	r1, [r4, #16]
        }
    }

    return DNA_OK;
  }
}
    30dc:	e28dd024 	add	sp, sp, #36	; 0x24
    30e0:	e8bd8030 	pop	{r4, r5, pc}
  devfs_t devfs = ns;
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (devfs != NULL, DNA_BAD_ARGUMENT);
    30e4:	e59f0064 	ldr	r0, [pc, #100]	; 3150 <devfs_get_info+0xe4>
        }
    }

    return DNA_OK;
  }
}
    30e8:	e28dd024 	add	sp, sp, #36	; 0x24
    30ec:	e8bd8030 	pop	{r4, r5, pc}
      case DNA_DEVFS_FILE :
        {
          int32_t ret;
          device_info_t dev_info;

          va_call (list,
    30f0:	e28dc004 	add	ip, sp, #4
    30f4:	e59f0058 	ldr	r0, [pc, #88]	; 3154 <devfs_get_info+0xe8>
    30f8:	e28d1010 	add	r1, sp, #16
    30fc:	ebffffc9 	bl	3028 <_va_call.4683.constprop.0>
              {
                inode -> dev_cmd -> control (data, DNA_GET_INFO, list, & ret);
              },
              & dev_info);

          switch (dev_info . type)
    3100:	e59d3010 	ldr	r3, [sp, #16]
    3104:	e3530004 	cmp	r3, #4
    3108:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    310c:	ea000004 	b	3124 <devfs_get_info+0xb8>
    3110:	00003144 	.word	0x00003144
    3114:	00003138 	.word	0x00003138
    3118:	00003138 	.word	0x00003138
    311c:	00003138 	.word	0x00003138
    3120:	00003144 	.word	0x00003144
            case DNA_CD_DEVICE :
              p_info -> type = DNA_FILE_SPECIAL_BLOCK;
              break;

            default :
              p_info -> type = DNA_FILE_REGULAR;
    3124:	e3a03000 	mov	r3, #0
    3128:	e5c43010 	strb	r3, [r4, #16]
          p_info -> type = DNA_FILE_SYMBOLIC_LINK;
          break;
        }
    }

    return DNA_OK;
    312c:	e3a00000 	mov	r0, #0
  }
}
    3130:	e28dd024 	add	sp, sp, #36	; 0x24
    3134:	e8bd8030 	pop	{r4, r5, pc}
              break;

            case DNA_DISK_DEVICE :
            case DNA_WORM_DEVICE :
            case DNA_CD_DEVICE :
              p_info -> type = DNA_FILE_SPECIAL_BLOCK;
    3138:	e3a03004 	mov	r3, #4
    313c:	e5c43010 	strb	r3, [r4, #16]
              break;
    3140:	eafffff9 	b	312c <devfs_get_info+0xc0>

          switch (dev_info . type)
          {
            case DNA_NETWORK_DEVICE :
            case DNA_CHARACTER_DEVICE :
              p_info -> type = DNA_FILE_SPECIAL_CHARACTER;
    3144:	e3a03003 	mov	r3, #3
    3148:	e5c43010 	strb	r3, [r4, #16]
              break;
    314c:	eafffff6 	b	312c <devfs_get_info+0xc0>
    3150:	0000fffc 	.word	0x0000fffc
    3154:	00032810 	.word	0x00032810

00003158 <devfs_walk>:
  char ** devices = NULL, * a_path = NULL;
  int32_t driver_index = 0;

  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    3158:	e3510000 	cmp	r1, #0
    315c:	13500000 	cmpne	r0, #0
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_walk (void * ns, void * base, char * path,
    char ** new_path, int64_t * p_vnid)
{
    3160:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  char ** devices = NULL, * a_path = NULL;
  int32_t driver_index = 0;

  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    3164:	e1a0a000 	mov	sl, r0
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_walk (void * ns, void * base, char * path,
    char ** new_path, int64_t * p_vnid)
{
    3168:	e24dd00c 	sub	sp, sp, #12
  char ** devices = NULL, * a_path = NULL;
  int32_t driver_index = 0;

  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    316c:	e1a08001 	mov	r8, r1
    3170:	03a04001 	moveq	r4, #1
    3174:	13a04000 	movne	r4, #0
    3178:	059f0160 	ldreq	r0, [pc, #352]	; 32e0 <devfs_walk+0x188>
    317c:	1a000001 	bne	3188 <devfs_walk+0x30>
    ensure (entry != NULL, DNA_NO_ENTRY);

    *p_vnid = entry -> id;
    return DNA_OK;
  }
}
    3180:	e28dd00c 	add	sp, sp, #12
    3184:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    dna_log(VERBOSE_LEVEL, "Analyzing \"%s\" on vnode %lld", path, inode -> id);

    if (inode -> id == devfs -> root_vnid)
    3188:	e1c160d8 	ldrd	r6, [r1, #8]
    318c:	e1a09002 	mov	r9, r2
    3190:	e1ca20d8 	ldrd	r2, [sl, #8]
    3194:	e1570003 	cmp	r7, r3
    3198:	01560002 	cmpeq	r6, r2
    319c:	0a00000d 	beq	31d8 <devfs_walk+0x80>
    /*
     * Check whether the dummy inode is empty or not.
     * If everything is fine, get the path vnid.
     */

    entry = queue_lookup (& inode -> entry_list,
    31a0:	e2880f4b 	add	r0, r8, #300	; 0x12c
    31a4:	e1a02009 	mov	r2, r9
    31a8:	e59f1134 	ldr	r1, [pc, #308]	; 32e4 <devfs_walk+0x18c>
    31ac:	eb00334f 	bl	fef0 <queue_lookup>
        devfs_entry_name_inspector, path);
    ensure (entry != NULL, DNA_NO_ENTRY);
    31b0:	e3500000 	cmp	r0, #0
    31b4:	0a000005 	beq	31d0 <devfs_walk+0x78>

    *p_vnid = entry -> id;
    31b8:	e1c020d8 	ldrd	r2, [r0, #8]
    return DNA_OK;
    31bc:	e3a00000 	mov	r0, #0

    entry = queue_lookup (& inode -> entry_list,
        devfs_entry_name_inspector, path);
    ensure (entry != NULL, DNA_NO_ENTRY);

    *p_vnid = entry -> id;
    31c0:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
    31c4:	e1c120f0 	strd	r2, [r1]
    return DNA_OK;
  }
}
    31c8:	e28dd00c 	add	sp, sp, #12
    31cc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
     * If everything is fine, get the path vnid.
     */

    entry = queue_lookup (& inode -> entry_list,
        devfs_entry_name_inspector, path);
    ensure (entry != NULL, DNA_NO_ENTRY);
    31d0:	e59f0110 	ldr	r0, [pc, #272]	; 32e8 <devfs_walk+0x190>
    31d4:	eaffffe9 	b	3180 <devfs_walk+0x28>
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    dna_log(VERBOSE_LEVEL, "Analyzing \"%s\" on vnode %lld", path, inode -> id);

    if (inode -> id == devfs -> root_vnid)
    {
      ensure (dna_strcmp (path, "..") != 0, DNA_ALREADY_AT_ROOT);
    31d8:	e1a00009 	mov	r0, r9
    31dc:	e59f1108 	ldr	r1, [pc, #264]	; 32ec <devfs_walk+0x194>
    31e0:	eb003336 	bl	fec0 <dna_strcmp>
    31e4:	e3500000 	cmp	r0, #0
    31e8:	03a00002 	moveq	r0, #2
    31ec:	0affffe3 	beq	3180 <devfs_walk+0x28>

     /*
      * Parse the publish_devices.
      */

      a_path = kernel_malloc (DNA_PATH_LENGTH, false);
    31f0:	e3a00b01 	mov	r0, #1024	; 0x400
    31f4:	e1a01004 	mov	r1, r4
    31f8:	eb0043a4 	bl	14090 <kernel_malloc>
      ensure (a_path != NULL, DNA_OUT_OF_MEM);
    31fc:	e2505000 	subs	r5, r0, #0
    3200:	0a000034 	beq	32d8 <devfs_walk+0x180>

      for (driver_index = 0; driver_index < OS_N_DRIVERS; driver_index ++)
    3204:	e59f10e4 	ldr	r1, [pc, #228]	; 32f0 <devfs_walk+0x198>
    3208:	e5912000 	ldr	r2, [r1]
    320c:	e3520000 	cmp	r2, #0
    3210:	da00002d 	ble	32cc <devfs_walk+0x174>
    3214:	e59f60d8 	ldr	r6, [pc, #216]	; 32f4 <devfs_walk+0x19c>
    3218:	e58d4004 	str	r4, [sp, #4]
      {
        devices = (char **) OS_DRIVERS_LIST[driver_index] -> publish_devices ();
    321c:	e4963004 	ldr	r3, [r6], #4
    3220:	e5933010 	ldr	r3, [r3, #16]
    3224:	e12fff33 	blx	r3

        for (int32_t j = 0; devices[j] != NULL; j ++)
    3228:	e5907000 	ldr	r7, [r0]
    322c:	e3570000 	cmp	r7, #0
    3230:	0a00001e 	beq	32b0 <devfs_walk+0x158>
    3234:	e1a04000 	mov	r4, r0
    3238:	e280b004 	add	fp, r0, #4
    323c:	ea000003 	b	3250 <devfs_walk+0xf8>
    3240:	e1a0400b 	mov	r4, fp
    3244:	e49b7004 	ldr	r7, [fp], #4
    3248:	e3570000 	cmp	r7, #0
    324c:	0a000017 	beq	32b0 <devfs_walk+0x158>
        {
          if (dna_memcmp (path, devices[j], dna_strlen(path)) == 0)
    3250:	e1a00009 	mov	r0, r9
    3254:	eb003352 	bl	ffa4 <dna_strlen>
    3258:	e1a01007 	mov	r1, r7
    325c:	e1a02000 	mov	r2, r0
    3260:	e1a00009 	mov	r0, r9
    3264:	eb003095 	bl	f4c0 <dna_memcmp>
    3268:	e3500000 	cmp	r0, #0
    326c:	1afffff3 	bne	3240 <devfs_walk+0xe8>
          {
            dna_strcpy (a_path, devices[j]);
    3270:	e5941000 	ldr	r1, [r4]
    3274:	e1a00005 	mov	r0, r5
    3278:	eb00337e 	bl	10078 <dna_strcpy>
            commands = OS_DRIVERS_LIST[driver_index] -> find_device (a_path);
    327c:	e5163004 	ldr	r3, [r6, #-4]
    3280:	e1a00005 	mov	r0, r5
    3284:	e5933014 	ldr	r3, [r3, #20]
    3288:	e12fff33 	blx	r3
            devfs_inode_insert (devfs, inode, a_path, commands);
    328c:	e1a01008 	mov	r1, r8
        for (int32_t j = 0; devices[j] != NULL; j ++)
        {
          if (dna_memcmp (path, devices[j], dna_strlen(path)) == 0)
          {
            dna_strcpy (a_path, devices[j]);
            commands = OS_DRIVERS_LIST[driver_index] -> find_device (a_path);
    3290:	e1a03000 	mov	r3, r0
            devfs_inode_insert (devfs, inode, a_path, commands);
    3294:	e1a02005 	mov	r2, r5
    3298:	e1a0000a 	mov	r0, sl
    329c:	eb0001ca 	bl	39cc <devfs_inode_insert>

      for (driver_index = 0; driver_index < OS_N_DRIVERS; driver_index ++)
      {
        devices = (char **) OS_DRIVERS_LIST[driver_index] -> publish_devices ();

        for (int32_t j = 0; devices[j] != NULL; j ++)
    32a0:	e1a0400b 	mov	r4, fp
    32a4:	e49b7004 	ldr	r7, [fp], #4
    32a8:	e3570000 	cmp	r7, #0
    32ac:	1affffe7 	bne	3250 <devfs_walk+0xf8>
      */

      a_path = kernel_malloc (DNA_PATH_LENGTH, false);
      ensure (a_path != NULL, DNA_OUT_OF_MEM);

      for (driver_index = 0; driver_index < OS_N_DRIVERS; driver_index ++)
    32b0:	e59f2038 	ldr	r2, [pc, #56]	; 32f0 <devfs_walk+0x198>
    32b4:	e59d1004 	ldr	r1, [sp, #4]
    32b8:	e5923000 	ldr	r3, [r2]
    32bc:	e2811001 	add	r1, r1, #1
    32c0:	e1530001 	cmp	r3, r1
    32c4:	e58d1004 	str	r1, [sp, #4]
    32c8:	caffffd3 	bgt	321c <devfs_walk+0xc4>
            devfs_inode_insert (devfs, inode, a_path, commands);
          }
        }
      }

      kernel_free (a_path);
    32cc:	e1a00005 	mov	r0, r5
    32d0:	eb0043a3 	bl	14164 <kernel_free>
    32d4:	eaffffb1 	b	31a0 <devfs_walk+0x48>
     /*
      * Parse the publish_devices.
      */

      a_path = kernel_malloc (DNA_PATH_LENGTH, false);
      ensure (a_path != NULL, DNA_OUT_OF_MEM);
    32d8:	e59f0018 	ldr	r0, [pc, #24]	; 32f8 <devfs_walk+0x1a0>
    32dc:	eaffffa7 	b	3180 <devfs_walk+0x28>
    32e0:	0000ffff 	.word	0x0000ffff
    32e4:	00003c70 	.word	0x00003c70
    32e8:	0000feff 	.word	0x0000feff
    32ec:	00032808 	.word	0x00032808
    32f0:	0003e910 	.word	0x0003e910
    32f4:	0003e914 	.word	0x0003e914
    32f8:	0000fffd 	.word	0x0000fffd

000032fc <devfs_destroy_vnode>:
#include <DnaTools/DnaTools.h>

status_t devfs_destroy_vnode (void * ns, void * node)
{
  return DNA_OK;
}
    32fc:	e3a00000 	mov	r0, #0
    3300:	e12fff1e 	bx	lr

00003304 <devfs_inode_destroy>:
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_inode_destroy (devfs_t fs, devfs_inode_t inode)
{
    3304:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  devfs_entry_t entry;
  devfs_inode_t next_inode = NULL;

  watch (status_t)
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    3308:	e2512000 	subs	r2, r1, #0
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_inode_destroy (devfs_t fs, devfs_inode_t inode)
{
    330c:	e24dd05c 	sub	sp, sp, #92	; 0x5c
  devfs_entry_t entry;
  devfs_inode_t next_inode = NULL;

  watch (status_t)
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    3310:	e58d204c 	str	r2, [sp, #76]	; 0x4c
    3314:	059f04d8 	ldreq	r0, [pc, #1240]	; 37f4 <devfs_inode_destroy+0x4f0>
    3318:	0a00000a 	beq	3348 <devfs_inode_destroy+0x44>

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    331c:	e280b014 	add	fp, r0, #20
    3320:	e1a0a000 	mov	sl, r0
    3324:	e1a0000b 	mov	r0, fp
    3328:	eb002fae 	bl	f1e8 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    332c:	e59d104c 	ldr	r1, [sp, #76]	; 0x4c
    3330:	e5d13010 	ldrb	r3, [r1, #16]
    3334:	e3530001 	cmp	r3, #1
    3338:	0a000004 	beq	3350 <devfs_inode_destroy+0x4c>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    333c:	e59d004c 	ldr	r0, [sp, #76]	; 0x4c
    3340:	eb004387 	bl	14164 <kernel_free>
    return DNA_OK;
    3344:	e3a00000 	mov	r0, #0
  }
}
    3348:	e28dd05c 	add	sp, sp, #92	; 0x5c
    334c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    queue_extract (& fs -> inode_list, inode);
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
    3350:	e1a00001 	mov	r0, r1
    3354:	e59f149c 	ldr	r1, [pc, #1180]	; 37f8 <devfs_inode_destroy+0x4f4>
    3358:	eb0002eb 	bl	3f0c <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");
    335c:	e59d004c 	ldr	r0, [sp, #76]	; 0x4c
    3360:	e59f1494 	ldr	r1, [pc, #1172]	; 37fc <devfs_inode_destroy+0x4f8>

      entry = queue_rem (& inode -> entry_list);
    3364:	e2802f4b 	add	r2, r0, #300	; 0x12c
    3368:	e58d2054 	str	r2, [sp, #84]	; 0x54
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    336c:	eb0002e6 	bl	3f0c <devfs_entry_remove_by_name>
    3370:	ea000003 	b	3384 <devfs_inode_destroy+0x80>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    3374:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
    3378:	eb004379 	bl	14164 <kernel_free>
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
        ensure (status == DNA_OK, status);

        kernel_free (entry);
    337c:	e59d0044 	ldr	r0, [sp, #68]	; 0x44
    3380:	eb004377 	bl	14164 <kernel_free>
    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
    3384:	e59d0054 	ldr	r0, [sp, #84]	; 0x54
    3388:	eb002fd8 	bl	f2f0 <queue_rem>
      while (entry != NULL)
    338c:	e3500000 	cmp	r0, #0
    3390:	e58d0044 	str	r0, [sp, #68]	; 0x44
    3394:	0affffe8 	beq	333c <devfs_inode_destroy+0x38>
      {
        next_inode = queue_lookup (& fs -> inode_list,
    3398:	e59d1044 	ldr	r1, [sp, #68]	; 0x44
    339c:	e1a0000b 	mov	r0, fp
    33a0:	e1c120d8 	ldrd	r2, [r1, #8]
    33a4:	e59f1454 	ldr	r1, [pc, #1108]	; 3800 <devfs_inode_destroy+0x4fc>
    33a8:	eb0032d0 	bl	fef0 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    33ac:	e3500000 	cmp	r0, #0
    33b0:	e58d0038 	str	r0, [sp, #56]	; 0x38
    33b4:	0a0000e8 	beq	375c <devfs_inode_destroy+0x458>
    33b8:	e1a01000 	mov	r1, r0
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    33bc:	e1a0000b 	mov	r0, fp
    33c0:	eb002f88 	bl	f1e8 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    33c4:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
    33c8:	e5d23010 	ldrb	r3, [r2, #16]
    33cc:	e3530001 	cmp	r3, #1
    33d0:	1affffe7 	bne	3374 <devfs_inode_destroy+0x70>
    {
      devfs_entry_remove_by_name (inode, ".");
    33d4:	e1a00002 	mov	r0, r2
    33d8:	e59f1418 	ldr	r1, [pc, #1048]	; 37f8 <devfs_inode_destroy+0x4f4>
    33dc:	eb0002ca 	bl	3f0c <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");
    33e0:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
    33e4:	e59f1410 	ldr	r1, [pc, #1040]	; 37fc <devfs_inode_destroy+0x4f8>

      entry = queue_rem (& inode -> entry_list);
    33e8:	e2803f4b 	add	r3, r0, #300	; 0x12c
    33ec:	e58d3050 	str	r3, [sp, #80]	; 0x50
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    33f0:	eb0002c5 	bl	3f0c <devfs_entry_remove_by_name>
    33f4:	ea000003 	b	3408 <devfs_inode_destroy+0x104>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    33f8:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    33fc:	eb004358 	bl	14164 <kernel_free>
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
        ensure (status == DNA_OK, status);

        kernel_free (entry);
    3400:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
    3404:	eb004356 	bl	14164 <kernel_free>
    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
    3408:	e59d0050 	ldr	r0, [sp, #80]	; 0x50
    340c:	eb002fb7 	bl	f2f0 <queue_rem>
      while (entry != NULL)
    3410:	e3500000 	cmp	r0, #0
    3414:	e58d0034 	str	r0, [sp, #52]	; 0x34
    3418:	0affffd5 	beq	3374 <devfs_inode_destroy+0x70>
      {
        next_inode = queue_lookup (& fs -> inode_list,
    341c:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
    3420:	e1a0000b 	mov	r0, fp
    3424:	e1c120d8 	ldrd	r2, [r1, #8]
    3428:	e59f13d0 	ldr	r1, [pc, #976]	; 3800 <devfs_inode_destroy+0x4fc>
    342c:	eb0032af 	bl	fef0 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    3430:	e3500000 	cmp	r0, #0
    3434:	e58d002c 	str	r0, [sp, #44]	; 0x2c
    3438:	0a0000c7 	beq	375c <devfs_inode_destroy+0x458>
    343c:	e1a01000 	mov	r1, r0
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    3440:	e1a0000b 	mov	r0, fp
    3444:	eb002f67 	bl	f1e8 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    3448:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    344c:	e5d23010 	ldrb	r3, [r2, #16]
    3450:	e3530001 	cmp	r3, #1
    3454:	1affffe7 	bne	33f8 <devfs_inode_destroy+0xf4>
    {
      devfs_entry_remove_by_name (inode, ".");
    3458:	e1a00002 	mov	r0, r2
    345c:	e59f1394 	ldr	r1, [pc, #916]	; 37f8 <devfs_inode_destroy+0x4f4>
    3460:	eb0002a9 	bl	3f0c <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");
    3464:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    3468:	e59f138c 	ldr	r1, [pc, #908]	; 37fc <devfs_inode_destroy+0x4f8>

      entry = queue_rem (& inode -> entry_list);
    346c:	e2803f4b 	add	r3, r0, #300	; 0x12c
    3470:	e58d3048 	str	r3, [sp, #72]	; 0x48
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    3474:	eb0002a4 	bl	3f0c <devfs_entry_remove_by_name>
    3478:	ea000003 	b	348c <devfs_inode_destroy+0x188>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    347c:	e59d0020 	ldr	r0, [sp, #32]
    3480:	eb004337 	bl	14164 <kernel_free>
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
        ensure (status == DNA_OK, status);

        kernel_free (entry);
    3484:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    3488:	eb004335 	bl	14164 <kernel_free>
    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
    348c:	e59d0048 	ldr	r0, [sp, #72]	; 0x48
    3490:	eb002f96 	bl	f2f0 <queue_rem>
      while (entry != NULL)
    3494:	e3500000 	cmp	r0, #0
    3498:	e58d0028 	str	r0, [sp, #40]	; 0x28
    349c:	0affffd5 	beq	33f8 <devfs_inode_destroy+0xf4>
      {
        next_inode = queue_lookup (& fs -> inode_list,
    34a0:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
    34a4:	e1a0000b 	mov	r0, fp
    34a8:	e1c120d8 	ldrd	r2, [r1, #8]
    34ac:	e59f134c 	ldr	r1, [pc, #844]	; 3800 <devfs_inode_destroy+0x4fc>
    34b0:	eb00328e 	bl	fef0 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    34b4:	e3500000 	cmp	r0, #0
    34b8:	e58d0020 	str	r0, [sp, #32]
    34bc:	0a0000a6 	beq	375c <devfs_inode_destroy+0x458>
    34c0:	e1a01000 	mov	r1, r0
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    34c4:	e1a0000b 	mov	r0, fp
    34c8:	eb002f46 	bl	f1e8 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    34cc:	e59d2020 	ldr	r2, [sp, #32]
    34d0:	e5d23010 	ldrb	r3, [r2, #16]
    34d4:	e3530001 	cmp	r3, #1
    34d8:	1affffe7 	bne	347c <devfs_inode_destroy+0x178>
    {
      devfs_entry_remove_by_name (inode, ".");
    34dc:	e1a00002 	mov	r0, r2
    34e0:	e59f1310 	ldr	r1, [pc, #784]	; 37f8 <devfs_inode_destroy+0x4f4>
    34e4:	eb000288 	bl	3f0c <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");
    34e8:	e59d0020 	ldr	r0, [sp, #32]
    34ec:	e59f1308 	ldr	r1, [pc, #776]	; 37fc <devfs_inode_destroy+0x4f8>

      entry = queue_rem (& inode -> entry_list);
    34f0:	e2803f4b 	add	r3, r0, #300	; 0x12c
    34f4:	e58d3040 	str	r3, [sp, #64]	; 0x40
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    34f8:	eb000283 	bl	3f0c <devfs_entry_remove_by_name>
    34fc:	ea000003 	b	3510 <devfs_inode_destroy+0x20c>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    3500:	e59d0014 	ldr	r0, [sp, #20]
    3504:	eb004316 	bl	14164 <kernel_free>
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
        ensure (status == DNA_OK, status);

        kernel_free (entry);
    3508:	e59d001c 	ldr	r0, [sp, #28]
    350c:	eb004314 	bl	14164 <kernel_free>
    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
    3510:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
    3514:	eb002f75 	bl	f2f0 <queue_rem>
      while (entry != NULL)
    3518:	e3500000 	cmp	r0, #0
    351c:	e58d001c 	str	r0, [sp, #28]
    3520:	0affffd5 	beq	347c <devfs_inode_destroy+0x178>
      {
        next_inode = queue_lookup (& fs -> inode_list,
    3524:	e59d101c 	ldr	r1, [sp, #28]
    3528:	e1a0000b 	mov	r0, fp
    352c:	e1c120d8 	ldrd	r2, [r1, #8]
    3530:	e59f12c8 	ldr	r1, [pc, #712]	; 3800 <devfs_inode_destroy+0x4fc>
    3534:	eb00326d 	bl	fef0 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    3538:	e3500000 	cmp	r0, #0
    353c:	e58d0014 	str	r0, [sp, #20]
    3540:	0a000085 	beq	375c <devfs_inode_destroy+0x458>
    3544:	e1a01000 	mov	r1, r0
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    3548:	e1a0000b 	mov	r0, fp
    354c:	eb002f25 	bl	f1e8 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    3550:	e59d2014 	ldr	r2, [sp, #20]
    3554:	e5d23010 	ldrb	r3, [r2, #16]
    3558:	e3530001 	cmp	r3, #1
    355c:	1affffe7 	bne	3500 <devfs_inode_destroy+0x1fc>
    {
      devfs_entry_remove_by_name (inode, ".");
    3560:	e1a00002 	mov	r0, r2
    3564:	e59f128c 	ldr	r1, [pc, #652]	; 37f8 <devfs_inode_destroy+0x4f4>
    3568:	eb000267 	bl	3f0c <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");
    356c:	e59d0014 	ldr	r0, [sp, #20]
    3570:	e59f1284 	ldr	r1, [pc, #644]	; 37fc <devfs_inode_destroy+0x4f8>

      entry = queue_rem (& inode -> entry_list);
    3574:	e2803f4b 	add	r3, r0, #300	; 0x12c
    3578:	e58d3030 	str	r3, [sp, #48]	; 0x30
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    357c:	eb000262 	bl	3f0c <devfs_entry_remove_by_name>
    3580:	ea000003 	b	3594 <devfs_inode_destroy+0x290>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    3584:	e59d000c 	ldr	r0, [sp, #12]
    3588:	eb0042f5 	bl	14164 <kernel_free>
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
        ensure (status == DNA_OK, status);

        kernel_free (entry);
    358c:	e59d0010 	ldr	r0, [sp, #16]
    3590:	eb0042f3 	bl	14164 <kernel_free>
    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
    3594:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
    3598:	eb002f54 	bl	f2f0 <queue_rem>
      while (entry != NULL)
    359c:	e3500000 	cmp	r0, #0
    35a0:	e58d0010 	str	r0, [sp, #16]
    35a4:	0affffd5 	beq	3500 <devfs_inode_destroy+0x1fc>
      {
        next_inode = queue_lookup (& fs -> inode_list,
    35a8:	e59d1010 	ldr	r1, [sp, #16]
    35ac:	e1a0000b 	mov	r0, fp
    35b0:	e1c120d8 	ldrd	r2, [r1, #8]
    35b4:	e59f1244 	ldr	r1, [pc, #580]	; 3800 <devfs_inode_destroy+0x4fc>
    35b8:	eb00324c 	bl	fef0 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    35bc:	e3500000 	cmp	r0, #0
    35c0:	e58d000c 	str	r0, [sp, #12]
    35c4:	0a000064 	beq	375c <devfs_inode_destroy+0x458>
    35c8:	e1a01000 	mov	r1, r0
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    35cc:	e1a0000b 	mov	r0, fp
    35d0:	eb002f04 	bl	f1e8 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    35d4:	e59d200c 	ldr	r2, [sp, #12]
    35d8:	e5d23010 	ldrb	r3, [r2, #16]
    35dc:	e3530001 	cmp	r3, #1
    35e0:	1affffe7 	bne	3584 <devfs_inode_destroy+0x280>
    {
      devfs_entry_remove_by_name (inode, ".");
    35e4:	e1a00002 	mov	r0, r2
    35e8:	e59f1208 	ldr	r1, [pc, #520]	; 37f8 <devfs_inode_destroy+0x4f4>
    35ec:	eb000246 	bl	3f0c <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");
    35f0:	e59d000c 	ldr	r0, [sp, #12]
    35f4:	e59f1200 	ldr	r1, [pc, #512]	; 37fc <devfs_inode_destroy+0x4f8>

      entry = queue_rem (& inode -> entry_list);
    35f8:	e2803f4b 	add	r3, r0, #300	; 0x12c
    35fc:	e58d3024 	str	r3, [sp, #36]	; 0x24
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    3600:	eb000241 	bl	3f0c <devfs_entry_remove_by_name>
    3604:	ea000003 	b	3618 <devfs_inode_destroy+0x314>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    3608:	e59d0004 	ldr	r0, [sp, #4]
    360c:	eb0042d4 	bl	14164 <kernel_free>
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
        ensure (status == DNA_OK, status);

        kernel_free (entry);
    3610:	e59d0008 	ldr	r0, [sp, #8]
    3614:	eb0042d2 	bl	14164 <kernel_free>
    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
    3618:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
    361c:	eb002f33 	bl	f2f0 <queue_rem>
      while (entry != NULL)
    3620:	e3500000 	cmp	r0, #0
    3624:	e58d0008 	str	r0, [sp, #8]
    3628:	0affffd5 	beq	3584 <devfs_inode_destroy+0x280>
      {
        next_inode = queue_lookup (& fs -> inode_list,
    362c:	e59d1008 	ldr	r1, [sp, #8]
    3630:	e1a0000b 	mov	r0, fp
    3634:	e1c120d8 	ldrd	r2, [r1, #8]
    3638:	e59f11c0 	ldr	r1, [pc, #448]	; 3800 <devfs_inode_destroy+0x4fc>
    363c:	eb00322b 	bl	fef0 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    3640:	e3500000 	cmp	r0, #0
    3644:	e58d0004 	str	r0, [sp, #4]
    3648:	0a000043 	beq	375c <devfs_inode_destroy+0x458>
    364c:	e1a01000 	mov	r1, r0
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    3650:	e1a0000b 	mov	r0, fp
    3654:	eb002ee3 	bl	f1e8 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    3658:	e59d2004 	ldr	r2, [sp, #4]
    365c:	e5d23010 	ldrb	r3, [r2, #16]
    3660:	e3530001 	cmp	r3, #1
    3664:	1affffe7 	bne	3608 <devfs_inode_destroy+0x304>
    {
      devfs_entry_remove_by_name (inode, ".");
    3668:	e1a00002 	mov	r0, r2
    366c:	e59f1184 	ldr	r1, [pc, #388]	; 37f8 <devfs_inode_destroy+0x4f4>
    3670:	eb000225 	bl	3f0c <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");
    3674:	e59d0004 	ldr	r0, [sp, #4]
    3678:	e59f117c 	ldr	r1, [pc, #380]	; 37fc <devfs_inode_destroy+0x4f8>

      entry = queue_rem (& inode -> entry_list);
    367c:	e2803f4b 	add	r3, r0, #300	; 0x12c
    3680:	e58d3018 	str	r3, [sp, #24]
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    3684:	eb000220 	bl	3f0c <devfs_entry_remove_by_name>

      entry = queue_rem (& inode -> entry_list);
    3688:	e59d0018 	ldr	r0, [sp, #24]
    368c:	eb002f17 	bl	f2f0 <queue_rem>
      while (entry != NULL)
    3690:	e2509000 	subs	r9, r0, #0
    3694:	0affffdb 	beq	3608 <devfs_inode_destroy+0x304>
      {
        next_inode = queue_lookup (& fs -> inode_list,
    3698:	e1c920d8 	ldrd	r2, [r9, #8]
    369c:	e1a0000b 	mov	r0, fp
    36a0:	e59f1158 	ldr	r1, [pc, #344]	; 3800 <devfs_inode_destroy+0x4fc>
    36a4:	eb003211 	bl	fef0 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    36a8:	e2508000 	subs	r8, r0, #0
    36ac:	0a00002a 	beq	375c <devfs_inode_destroy+0x458>
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    36b0:	e1a0000b 	mov	r0, fp
    36b4:	e1a01008 	mov	r1, r8
    36b8:	eb002eca 	bl	f1e8 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    36bc:	e5d83010 	ldrb	r3, [r8, #16]
    36c0:	e3530001 	cmp	r3, #1
    36c4:	0a000027 	beq	3768 <devfs_inode_destroy+0x464>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    36c8:	e1a00008 	mov	r0, r8
    36cc:	eb0042a4 	bl	14164 <kernel_free>
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
        ensure (status == DNA_OK, status);

        kernel_free (entry);
    36d0:	e1a00009 	mov	r0, r9
    36d4:	eb0042a2 	bl	14164 <kernel_free>
        entry = queue_rem (& inode -> entry_list);
    36d8:	e59d0018 	ldr	r0, [sp, #24]
    36dc:	eb002f03 	bl	f2f0 <queue_rem>
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
      while (entry != NULL)
    36e0:	e2509000 	subs	r9, r0, #0
    36e4:	1affffeb 	bne	3698 <devfs_inode_destroy+0x394>
    36e8:	eaffffc6 	b	3608 <devfs_inode_destroy+0x304>
    queue_extract (& fs -> inode_list, inode);
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
    36ec:	e59f1104 	ldr	r1, [pc, #260]	; 37f8 <devfs_inode_destroy+0x4f4>
    36f0:	e1a00005 	mov	r0, r5
    36f4:	eb000204 	bl	3f0c <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
    36f8:	e2857f4b 	add	r7, r5, #300	; 0x12c
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    36fc:	e59f10f8 	ldr	r1, [pc, #248]	; 37fc <devfs_inode_destroy+0x4f8>
    3700:	e1a00005 	mov	r0, r5
    3704:	eb000200 	bl	3f0c <devfs_entry_remove_by_name>

      entry = queue_rem (& inode -> entry_list);
    3708:	e1a00007 	mov	r0, r7
    370c:	eb002ef7 	bl	f2f0 <queue_rem>
      while (entry != NULL)
    3710:	e2504000 	subs	r4, r0, #0
    3714:	1a00000a 	bne	3744 <devfs_inode_destroy+0x440>
    3718:	ea00002b 	b	37cc <devfs_inode_destroy+0x4c8>
      {
        next_inode = queue_lookup (& fs -> inode_list,
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
    371c:	e1a0000a 	mov	r0, sl
    3720:	ebfffef7 	bl	3304 <devfs_inode_destroy>
        ensure (status == DNA_OK, status);
    3724:	e3500000 	cmp	r0, #0
    3728:	1affff06 	bne	3348 <devfs_inode_destroy+0x44>

        kernel_free (entry);
    372c:	e1a00004 	mov	r0, r4
    3730:	eb00428b 	bl	14164 <kernel_free>
        entry = queue_rem (& inode -> entry_list);
    3734:	e1a00007 	mov	r0, r7
    3738:	eb002eec 	bl	f2f0 <queue_rem>
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
      while (entry != NULL)
    373c:	e2504000 	subs	r4, r0, #0
    3740:	0a000021 	beq	37cc <devfs_inode_destroy+0x4c8>
      {
        next_inode = queue_lookup (& fs -> inode_list,
    3744:	e1c420d8 	ldrd	r2, [r4, #8]
    3748:	e59f10b0 	ldr	r1, [pc, #176]	; 3800 <devfs_inode_destroy+0x4fc>
    374c:	e1a0000b 	mov	r0, fp
    3750:	eb0031e6 	bl	fef0 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    3754:	e2501000 	subs	r1, r0, #0
    3758:	1affffef 	bne	371c <devfs_inode_destroy+0x418>
    375c:	e59f00a0 	ldr	r0, [pc, #160]	; 3804 <devfs_inode_destroy+0x500>
    }

    kernel_free (inode);
    return DNA_OK;
  }
}
    3760:	e28dd05c 	add	sp, sp, #92	; 0x5c
    3764:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    queue_extract (& fs -> inode_list, inode);
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
    3768:	e59f1088 	ldr	r1, [pc, #136]	; 37f8 <devfs_inode_destroy+0x4f4>
    376c:	e1a00008 	mov	r0, r8
    3770:	eb0001e5 	bl	3f0c <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
    3774:	e2884f4b 	add	r4, r8, #300	; 0x12c
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    3778:	e59f107c 	ldr	r1, [pc, #124]	; 37fc <devfs_inode_destroy+0x4f8>
    377c:	e1a00008 	mov	r0, r8
    3780:	eb0001e1 	bl	3f0c <devfs_entry_remove_by_name>

      entry = queue_rem (& inode -> entry_list);
    3784:	e1a00004 	mov	r0, r4
    3788:	eb002ed8 	bl	f2f0 <queue_rem>
      while (entry != NULL)
    378c:	e2506000 	subs	r6, r0, #0
    3790:	0affffcc 	beq	36c8 <devfs_inode_destroy+0x3c4>
    3794:	e58d803c 	str	r8, [sp, #60]	; 0x3c
    3798:	e1a08004 	mov	r8, r4
      {
        next_inode = queue_lookup (& fs -> inode_list,
    379c:	e1c620d8 	ldrd	r2, [r6, #8]
    37a0:	e1a0000b 	mov	r0, fp
    37a4:	e59f1054 	ldr	r1, [pc, #84]	; 3800 <devfs_inode_destroy+0x4fc>
    37a8:	eb0031d0 	bl	fef0 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    37ac:	e2505000 	subs	r5, r0, #0
    37b0:	0affffe9 	beq	375c <devfs_inode_destroy+0x458>
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    37b4:	e1a0000b 	mov	r0, fp
    37b8:	e1a01005 	mov	r1, r5
    37bc:	eb002e89 	bl	f1e8 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    37c0:	e5d53010 	ldrb	r3, [r5, #16]
    37c4:	e3530001 	cmp	r3, #1
    37c8:	0affffc7 	beq	36ec <devfs_inode_destroy+0x3e8>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    37cc:	e1a00005 	mov	r0, r5
    37d0:	eb004263 	bl	14164 <kernel_free>
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
        ensure (status == DNA_OK, status);

        kernel_free (entry);
    37d4:	e1a00006 	mov	r0, r6
    37d8:	eb004261 	bl	14164 <kernel_free>
        entry = queue_rem (& inode -> entry_list);
    37dc:	e1a00008 	mov	r0, r8
    37e0:	eb002ec2 	bl	f2f0 <queue_rem>
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
      while (entry != NULL)
    37e4:	e2506000 	subs	r6, r0, #0
    37e8:	1affffeb 	bne	379c <devfs_inode_destroy+0x498>
    37ec:	e59d803c 	ldr	r8, [sp, #60]	; 0x3c
    37f0:	eaffffb4 	b	36c8 <devfs_inode_destroy+0x3c4>
    37f4:	0000fffc 	.word	0x0000fffc
    37f8:	00032c70 	.word	0x00032c70
    37fc:	00032808 	.word	0x00032808
    3800:	00003ca4 	.word	0x00003ca4
    3804:	0000fefd 	.word	0x0000fefd

00003808 <devfs_mount>:
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t devfs_mount (int32_t vid, const char * dev_path, uint32_t flags,
    void * params, void ** data, int64_t * vnid)
{
    3808:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  status_t status = DNA_OK;
  devfs_t devfs = NULL;
  devfs_inode_t root_inode = NULL;
    380c:	e3a07000 	mov	r7, #0
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t devfs_mount (int32_t vid, const char * dev_path, uint32_t flags,
    void * params, void ** data, int64_t * vnid)
{
    3810:	e24dd01c 	sub	sp, sp, #28
    3814:	e1a08000 	mov	r8, r0
  {
    /*
     * Initialize the DevFS structure.
     */

    devfs = kernel_malloc (sizeof (struct devfs), true);
    3818:	e3a01001 	mov	r1, #1
    381c:	e3a00028 	mov	r0, #40	; 0x28
status_t devfs_mount (int32_t vid, const char * dev_path, uint32_t flags,
    void * params, void ** data, int64_t * vnid)
{
  status_t status = DNA_OK;
  devfs_t devfs = NULL;
  devfs_inode_t root_inode = NULL;
    3820:	e58d7014 	str	r7, [sp, #20]
  {
    /*
     * Initialize the DevFS structure.
     */

    devfs = kernel_malloc (sizeof (struct devfs), true);
    3824:	eb004219 	bl	14090 <kernel_malloc>
    ensure (devfs != NULL, DNA_OUT_OF_MEM);
    3828:	e2506000 	subs	r6, r0, #0
    382c:	059f0148 	ldreq	r0, [pc, #328]	; 397c <devfs_mount+0x174>
    3830:	0a000012 	beq	3880 <devfs_mount+0x78>

    devfs -> inode_index = 1;
    devfs -> vid = vid;
    devfs -> root_vnid = devfs -> inode_index ++;
    3834:	e3a02001 	mov	r2, #1
    3838:	e3a03000 	mov	r3, #0
    383c:	e3a04002 	mov	r4, #2
    3840:	e3a05000 	mov	r5, #0

    /*
     * Initialize the root inode structure.
     */

    status = devfs_inode_create (devfs, NULL, DNA_DEVFS_DIRECTORY,
    3844:	e28dc014 	add	ip, sp, #20
    devfs = kernel_malloc (sizeof (struct devfs), true);
    ensure (devfs != NULL, DNA_OUT_OF_MEM);

    devfs -> inode_index = 1;
    devfs -> vid = vid;
    devfs -> root_vnid = devfs -> inode_index ++;
    3848:	e1c640f0 	strd	r4, [r6]
    384c:	e1c620f8 	strd	r2, [r6, #8]

    devfs = kernel_malloc (sizeof (struct devfs), true);
    ensure (devfs != NULL, DNA_OUT_OF_MEM);

    devfs -> inode_index = 1;
    devfs -> vid = vid;
    3850:	e5868010 	str	r8, [r6, #16]

    /*
     * Initialize the root inode structure.
     */

    status = devfs_inode_create (devfs, NULL, DNA_DEVFS_DIRECTORY,
    3854:	e1a01007 	mov	r1, r7
    3858:	e1cd20f0 	strd	r2, [sp]
    385c:	e58d7008 	str	r7, [sp, #8]
    3860:	e58dc00c 	str	ip, [sp, #12]
    3864:	e59f3114 	ldr	r3, [pc, #276]	; 3980 <devfs_mount+0x178>
    3868:	ebfffd71 	bl	2e34 <devfs_inode_create>
        "", devfs -> root_vnid, NULL, & root_inode);
    check (inode_error, status == DNA_OK, status);
    386c:	e2504000 	subs	r4, r0, #0
    3870:	0a000004 	beq	3888 <devfs_mount+0x80>
    devfs_inode_destroy (devfs, root_inode);
  }

  rescue (inode_error)
  {
    kernel_free (devfs);
    3874:	e1a00006 	mov	r0, r6
    3878:	eb004239 	bl	14164 <kernel_free>
    leave;
    387c:	e1a00004 	mov	r0, r4
  }
}
    3880:	e28dd01c 	add	sp, sp, #28
    3884:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}

    status = devfs_inode_create (devfs, NULL, DNA_DEVFS_DIRECTORY,
        "", devfs -> root_vnid, NULL, & root_inode);
    check (inode_error, status == DNA_OK, status);

    status = devfs_entry_add (root_inode, ".", root_inode -> id);
    3888:	e59d0014 	ldr	r0, [sp, #20]
    388c:	e59f10f0 	ldr	r1, [pc, #240]	; 3984 <devfs_mount+0x17c>
    3890:	e1c020d8 	ldrd	r2, [r0, #8]
    3894:	eb000180 	bl	3e9c <devfs_entry_add>
    check (entry_error, status == DNA_OK, status);
    3898:	e2504000 	subs	r4, r0, #0
    389c:	1a000028 	bne	3944 <devfs_mount+0x13c>

    status = devfs_entry_add (root_inode, "..", root_inode -> id);
    38a0:	e59d0014 	ldr	r0, [sp, #20]
    38a4:	e59f10dc 	ldr	r1, [pc, #220]	; 3988 <devfs_mount+0x180>
    38a8:	e1c020d8 	ldrd	r2, [r0, #8]
    38ac:	eb00017a 	bl	3e9c <devfs_entry_add>
    check (entry_error, status == DNA_OK, status);
    38b0:	e2504000 	subs	r4, r0, #0
    38b4:	1a000022 	bne	3944 <devfs_mount+0x13c>

    /*
     * Load the in-kernel drivers and check if they are consistent.
     */

    for (driver_index = 0; driver_index < OS_N_DRIVERS; driver_index ++)
    38b8:	e59f90cc 	ldr	r9, [pc, #204]	; 398c <devfs_mount+0x184>
    38bc:	e5993000 	ldr	r3, [r9]
    38c0:	e1530007 	cmp	r3, r7
    38c4:	da000022 	ble	3954 <devfs_mount+0x14c>
    38c8:	e59f80c0 	ldr	r8, [pc, #192]	; 3990 <devfs_mount+0x188>
    38cc:	e1a05004 	mov	r5, r4
    38d0:	e1a07008 	mov	r7, r8
    38d4:	ea000008 	b	38fc <devfs_mount+0xf4>
    {
      status = OS_DRIVERS_LIST[driver_index] -> init_hardware ();
      check (bad_driver, status == DNA_OK, status);

      status = OS_DRIVERS_LIST[driver_index] -> init_driver ();
    38d8:	e5b73004 	ldr	r3, [r7, #4]!
    38dc:	e5933008 	ldr	r3, [r3, #8]
    38e0:	e12fff33 	blx	r3
      check (bad_driver, status == DNA_OK, status);
    38e4:	e2504000 	subs	r4, r0, #0
    38e8:	1a000008 	bne	3910 <devfs_mount+0x108>

    /*
     * Load the in-kernel drivers and check if they are consistent.
     */

    for (driver_index = 0; driver_index < OS_N_DRIVERS; driver_index ++)
    38ec:	e5993000 	ldr	r3, [r9]
    38f0:	e2855001 	add	r5, r5, #1
    38f4:	e1530005 	cmp	r3, r5
    38f8:	da000015 	ble	3954 <devfs_mount+0x14c>
    {
      status = OS_DRIVERS_LIST[driver_index] -> init_hardware ();
    38fc:	e5973004 	ldr	r3, [r7, #4]
    3900:	e5933004 	ldr	r3, [r3, #4]
    3904:	e12fff33 	blx	r3
      check (bad_driver, status == DNA_OK, status);
    3908:	e2504000 	subs	r4, r0, #0
    390c:	0afffff1 	beq	38d8 <devfs_mount+0xd0>
    return vnode_create (root_inode -> id, devfs -> vid, (void *) root_inode);
  }

  rescue (bad_driver)
  {
    for (int32_t i = 0; i < driver_index; i += 1)
    3910:	e3550000 	cmp	r5, #0
    3914:	0a000006 	beq	3934 <devfs_mount+0x12c>
    3918:	e3a07000 	mov	r7, #0
    {
      OS_DRIVERS_LIST[i] -> uninit_driver ();
    391c:	e5b83004 	ldr	r3, [r8, #4]!
    return vnode_create (root_inode -> id, devfs -> vid, (void *) root_inode);
  }

  rescue (bad_driver)
  {
    for (int32_t i = 0; i < driver_index; i += 1)
    3920:	e2877001 	add	r7, r7, #1
    {
      OS_DRIVERS_LIST[i] -> uninit_driver ();
    3924:	e593300c 	ldr	r3, [r3, #12]
    3928:	e12fff33 	blx	r3
    return vnode_create (root_inode -> id, devfs -> vid, (void *) root_inode);
  }

  rescue (bad_driver)
  {
    for (int32_t i = 0; i < driver_index; i += 1)
    392c:	e1570005 	cmp	r7, r5
    3930:	1afffff9 	bne	391c <devfs_mount+0x114>
    {
      OS_DRIVERS_LIST[i] -> uninit_driver ();
    }

    devfs_entry_t entry = queue_rem (& root_inode -> entry_list);
    3934:	e59d0014 	ldr	r0, [sp, #20]
    3938:	e2800f4b 	add	r0, r0, #300	; 0x12c
    393c:	eb002e6b 	bl	f2f0 <queue_rem>
    kernel_free (entry);
    3940:	eb004207 	bl	14164 <kernel_free>
  }

  rescue (entry_error)
  {
    devfs_inode_destroy (devfs, root_inode);
    3944:	e1a00006 	mov	r0, r6
    3948:	e59d1014 	ldr	r1, [sp, #20]
    394c:	ebfffe6c 	bl	3304 <devfs_inode_destroy>
    3950:	eaffffc7 	b	3874 <devfs_mount+0x6c>

    /*
     * Add the root vnode to the system
     */

    *data = devfs;
    3954:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
    *vnid = root_inode -> id;
    3958:	e59d3014 	ldr	r3, [sp, #20]

    /*
     * Add the root vnode to the system
     */

    *data = devfs;
    395c:	e5826000 	str	r6, [r2]
    *vnid = root_inode -> id;
    3960:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
    3964:	e1c300d8 	ldrd	r0, [r3, #8]
    3968:	e1c200f0 	strd	r0, [r2]

    dna_log(VERBOSE_LEVEL, "DevFS mount succeeded.");
    return vnode_create (root_inode -> id, devfs -> vid, (void *) root_inode);
    396c:	e5962010 	ldr	r2, [r6, #16]
    3970:	e1c300d8 	ldrd	r0, [r3, #8]
    3974:	eb0027d2 	bl	d8c4 <vnode_create>
    3978:	eaffffc0 	b	3880 <devfs_mount+0x78>
    397c:	0000fffd 	.word	0x0000fffd
    3980:	00032ca0 	.word	0x00032ca0
    3984:	00032c70 	.word	0x00032c70
    3988:	00032808 	.word	0x00032808
    398c:	0003e910 	.word	0x0003e910
    3990:	0003e910 	.word	0x0003e910

00003994 <devfs_close>:
{
  devfs_inode_t inode = node;

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    3994:	e5d13010 	ldrb	r3, [r1, #16]
    3998:	e3530000 	cmp	r3, #0
    399c:	1a000007 	bne	39c0 <devfs_close+0x2c>
    {
      ensure (inode -> dev_cmd -> close != NULL, DNA_ERROR);
    39a0:	e5913128 	ldr	r3, [r1, #296]	; 0x128
    39a4:	e5933004 	ldr	r3, [r3, #4]
    39a8:	e3530000 	cmp	r3, #0
    39ac:	0a000001 	beq	39b8 <devfs_close+0x24>
      return inode -> dev_cmd -> close (data);
    39b0:	e1a00002 	mov	r0, r2
    39b4:	e12fff13 	bx	r3

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    {
      ensure (inode -> dev_cmd -> close != NULL, DNA_ERROR);
    39b8:	e59f0008 	ldr	r0, [pc, #8]	; 39c8 <devfs_close+0x34>
      return inode -> dev_cmd -> close (data);
    }

    return DNA_OK;
  }
}
    39bc:	e12fff1e 	bx	lr
    {
      ensure (inode -> dev_cmd -> close != NULL, DNA_ERROR);
      return inode -> dev_cmd -> close (data);
    }

    return DNA_OK;
    39c0:	e3a00000 	mov	r0, #0
    39c4:	e12fff1e 	bx	lr
    39c8:	0000ffff 	.word	0x0000ffff

000039cc <devfs_inode_insert>:

status_t devfs_inode_insert (devfs_t fs, devfs_inode_t inode,
    char * path, device_cmd_t * commands)
{
  devfs_entry_t entry = NULL;
  devfs_inode_t next_inode = NULL;
    39cc:	e3a0c000 	mov	ip, #0
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_inode_insert (devfs_t fs, devfs_inode_t inode,
    char * path, device_cmd_t * commands)
{
    39d0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  char token[DNA_FILENAME_LENGTH];
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (path != NULL, DNA_BAD_ARGUMENT);
    39d4:	e152000c 	cmp	r2, ip
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_inode_insert (devfs_t fs, devfs_inode_t inode,
    char * path, device_cmd_t * commands)
{
    39d8:	e24ddf49 	sub	sp, sp, #292	; 0x124
    39dc:	e58d2014 	str	r2, [sp, #20]
  devfs_entry_t entry = NULL;
  devfs_inode_t next_inode = NULL;
    39e0:	e58dc01c 	str	ip, [sp, #28]
  char token[DNA_FILENAME_LENGTH];
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (path != NULL, DNA_BAD_ARGUMENT);
    39e4:	059f015c 	ldreq	r0, [pc, #348]	; 3b48 <devfs_inode_insert+0x17c>
    39e8:	0a000010 	beq	3a30 <devfs_inode_insert+0x64>
    39ec:	e1a06001 	mov	r6, r1
    39f0:	e1a07000 	mov	r7, r0

    path_get_next_entry (& path, token);
    39f4:	e28d1020 	add	r1, sp, #32
    39f8:	e28d0014 	add	r0, sp, #20
    39fc:	e1a08003 	mov	r8, r3
    3a00:	eb002e56 	bl	f360 <path_get_next_entry>
    entry = queue_lookup (& inode -> entry_list,
    3a04:	e28d2020 	add	r2, sp, #32
    3a08:	e2860f4b 	add	r0, r6, #300	; 0x12c
    3a0c:	e59f1138 	ldr	r1, [pc, #312]	; 3b4c <devfs_inode_insert+0x180>
    3a10:	eb003136 	bl	fef0 <queue_lookup>
        devfs_entry_name_inspector, token);

    if (entry == NULL)
    3a14:	e2509000 	subs	r9, r0, #0
    {
      if (dna_strlen (path) != 0)
    3a18:	e59d0014 	ldr	r0, [sp, #20]

    path_get_next_entry (& path, token);
    entry = queue_lookup (& inode -> entry_list,
        devfs_entry_name_inspector, token);

    if (entry == NULL)
    3a1c:	0a000005 	beq	3a38 <devfs_inode_insert+0x6c>
      devfs_entry_add (inode, token, next_inode -> id);
      dna_log(VERBOSE_LEVEL, "inode %s created", token);
    }
    else
    {
      ensure (dna_strlen (path) != 0, DNA_INODE_EXISTS);
    3a20:	eb00315f 	bl	ffa4 <dna_strlen>
    3a24:	e3500000 	cmp	r0, #0
    3a28:	059f0120 	ldreq	r0, [pc, #288]	; 3b50 <devfs_inode_insert+0x184>
    3a2c:	1a000017 	bne	3a90 <devfs_inode_insert+0xc4>
      status = devfs_inode_insert (fs, next_inode, path, commands);
    }

    return status;
  }
}
    3a30:	e28ddf49 	add	sp, sp, #292	; 0x124
    3a34:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    entry = queue_lookup (& inode -> entry_list,
        devfs_entry_name_inspector, token);

    if (entry == NULL)
    {
      if (dna_strlen (path) != 0)
    3a38:	eb003159 	bl	ffa4 <dna_strlen>
    3a3c:	e2502000 	subs	r2, r0, #0
    3a40:	1a000023 	bne	3ad4 <devfs_inode_insert+0x108>
        devfs_inode_insert (fs, next_inode, path, commands);
      }
      else
      {
        devfs_inode_create (fs, inode, DNA_DEVFS_FILE, token,
            fs -> inode_index ++, commands, & next_inode);
    3a44:	e1c740d0 	ldrd	r4, [r7]

        devfs_inode_insert (fs, next_inode, path, commands);
      }
      else
      {
        devfs_inode_create (fs, inode, DNA_DEVFS_FILE, token,
    3a48:	e294a001 	adds	sl, r4, #1
    3a4c:	e28d301c 	add	r3, sp, #28
    3a50:	e2a5b000 	adc	fp, r5, #0
    3a54:	e58d8008 	str	r8, [sp, #8]
    3a58:	e1cd40f0 	strd	r4, [sp]
    3a5c:	e1a00007 	mov	r0, r7
    3a60:	e1c7a0f0 	strd	sl, [r7]
    3a64:	e1a01006 	mov	r1, r6
    3a68:	e58d300c 	str	r3, [sp, #12]
    3a6c:	e28d3020 	add	r3, sp, #32
    3a70:	ebfffcef 	bl	2e34 <devfs_inode_create>
            fs -> inode_index ++, commands, & next_inode);
      }

      devfs_entry_add (inode, token, next_inode -> id);
    3a74:	e59d301c 	ldr	r3, [sp, #28]
    3a78:	e1a00006 	mov	r0, r6
    3a7c:	e1c320d8 	ldrd	r2, [r3, #8]
    3a80:	e28d1020 	add	r1, sp, #32
    3a84:	eb000104 	bl	3e9c <devfs_entry_add>
    char * path, device_cmd_t * commands)
{
  devfs_entry_t entry = NULL;
  devfs_inode_t next_inode = NULL;
  char token[DNA_FILENAME_LENGTH];
  status_t status = DNA_OK;
    3a88:	e3a00000 	mov	r0, #0
    3a8c:	eaffffe7 	b	3a30 <devfs_inode_insert+0x64>

      /*
       * Load the corresponding inode.
       */

      next_inode = queue_lookup (& fs -> inode_list,
    3a90:	e59f10bc 	ldr	r1, [pc, #188]	; 3b54 <devfs_inode_insert+0x188>
    3a94:	e1c920d8 	ldrd	r2, [r9, #8]
    3a98:	e2870014 	add	r0, r7, #20
    3a9c:	eb003113 	bl	fef0 <queue_lookup>
          devfs_inode_id_inspector, entry -> id);
      ensure (next_inode != NULL, DNA_NO_VNODE);
    3aa0:	e3500000 	cmp	r0, #0

      /*
       * Load the corresponding inode.
       */

      next_inode = queue_lookup (& fs -> inode_list,
    3aa4:	e1a01000 	mov	r1, r0
    3aa8:	e58d001c 	str	r0, [sp, #28]
          devfs_inode_id_inspector, entry -> id);
      ensure (next_inode != NULL, DNA_NO_VNODE);
    3aac:	0a000023 	beq	3b40 <devfs_inode_insert+0x174>
      ensure (next_inode -> class == DNA_DEVFS_DIRECTORY, DNA_BAD_INODE_TYPE);
    3ab0:	e5d03010 	ldrb	r3, [r0, #16]
    3ab4:	e3530001 	cmp	r3, #1
    3ab8:	159f0098 	ldrne	r0, [pc, #152]	; 3b58 <devfs_inode_insert+0x18c>
    3abc:	1affffdb 	bne	3a30 <devfs_inode_insert+0x64>

      /*
       * Parse the rest of the path.
       */

      status = devfs_inode_insert (fs, next_inode, path, commands);
    3ac0:	e1a00007 	mov	r0, r7
    3ac4:	e1a03008 	mov	r3, r8
    3ac8:	e59d2014 	ldr	r2, [sp, #20]
    3acc:	ebffffbe 	bl	39cc <devfs_inode_insert>
    3ad0:	eaffffd6 	b	3a30 <devfs_inode_insert+0x64>
    if (entry == NULL)
    {
      if (dna_strlen (path) != 0)
      {
        devfs_inode_create (fs, inode, DNA_DEVFS_DIRECTORY,
            token, fs -> inode_index ++, NULL, & next_inode);
    3ad4:	e1c720d0 	ldrd	r2, [r7]

    if (entry == NULL)
    {
      if (dna_strlen (path) != 0)
      {
        devfs_inode_create (fs, inode, DNA_DEVFS_DIRECTORY,
    3ad8:	e2924001 	adds	r4, r2, #1
    3adc:	e2a35000 	adc	r5, r3, #0
    3ae0:	e28d101c 	add	r1, sp, #28
    3ae4:	e1cd20f0 	strd	r2, [sp]
    3ae8:	e58d9008 	str	r9, [sp, #8]
    3aec:	e28d3020 	add	r3, sp, #32
    3af0:	e1c740f0 	strd	r4, [r7]
    3af4:	e1a00007 	mov	r0, r7
    3af8:	e58d100c 	str	r1, [sp, #12]
    3afc:	e3a02001 	mov	r2, #1
    3b00:	e1a01006 	mov	r1, r6
    3b04:	ebfffcca 	bl	2e34 <devfs_inode_create>
            token, fs -> inode_index ++, NULL, & next_inode);

        devfs_entry_add (next_inode, ".", next_inode -> id);
    3b08:	e59d001c 	ldr	r0, [sp, #28]
    3b0c:	e59f1048 	ldr	r1, [pc, #72]	; 3b5c <devfs_inode_insert+0x190>
    3b10:	e1c020d8 	ldrd	r2, [r0, #8]
    3b14:	eb0000e0 	bl	3e9c <devfs_entry_add>
        devfs_entry_add (next_inode, "..", inode -> id);
    3b18:	e1c620d8 	ldrd	r2, [r6, #8]
    3b1c:	e59d001c 	ldr	r0, [sp, #28]
    3b20:	e59f1038 	ldr	r1, [pc, #56]	; 3b60 <devfs_inode_insert+0x194>
    3b24:	eb0000dc 	bl	3e9c <devfs_entry_add>

        devfs_inode_insert (fs, next_inode, path, commands);
    3b28:	e1a00007 	mov	r0, r7
    3b2c:	e1a03008 	mov	r3, r8
    3b30:	e59d101c 	ldr	r1, [sp, #28]
    3b34:	e59d2014 	ldr	r2, [sp, #20]
    3b38:	ebffffa3 	bl	39cc <devfs_inode_insert>
    3b3c:	eaffffcc 	b	3a74 <devfs_inode_insert+0xa8>
       * Load the corresponding inode.
       */

      next_inode = queue_lookup (& fs -> inode_list,
          devfs_inode_id_inspector, entry -> id);
      ensure (next_inode != NULL, DNA_NO_VNODE);
    3b40:	e59f001c 	ldr	r0, [pc, #28]	; 3b64 <devfs_inode_insert+0x198>
    3b44:	eaffffb9 	b	3a30 <devfs_inode_insert+0x64>
    3b48:	0000fffc 	.word	0x0000fffc
    3b4c:	00003c70 	.word	0x00003c70
    3b50:	0000fef4 	.word	0x0000fef4
    3b54:	00003ca4 	.word	0x00003ca4
    3b58:	0000fef7 	.word	0x0000fef7
    3b5c:	00032c70 	.word	0x00032c70
    3b60:	00032808 	.word	0x00032808
    3b64:	0000fefd 	.word	0x0000fefd

00003b68 <devfs_readdir>:
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_readdir (void * ns, void * node, void * data,
    void * entry_array, int64_t * offset, int32_t * p_count)
{
    3b68:	e92d43b0 	push	{r4, r5, r7, r8, r9, lr}
  int64_t pos = 0;
  directory_entry_t * p_entry = entry_array;

  watch (status_t)
  {
    ensure (ns != NULL && node != NULL
    3b6c:	e3510000 	cmp	r1, #0
    3b70:	13500000 	cmpne	r0, #0
{
  devfs_t devfs = ns;
  devfs_inode_t inode = node;
  devfs_entry_t entry = NULL;
  status_t status = DNA_OK;
  int64_t pos = 0;
    3b74:	e3a04000 	mov	r4, #0
    3b78:	e3a05000 	mov	r5, #0
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_readdir (void * ns, void * node, void * data,
    void * entry_array, int64_t * offset, int32_t * p_count)
{
    3b7c:	e24dd010 	sub	sp, sp, #16
  int64_t pos = 0;
  directory_entry_t * p_entry = entry_array;

  watch (status_t)
  {
    ensure (ns != NULL && node != NULL
    3b80:	e1a08000 	mov	r8, r0
{
  devfs_t devfs = ns;
  devfs_inode_t inode = node;
  devfs_entry_t entry = NULL;
  status_t status = DNA_OK;
  int64_t pos = 0;
    3b84:	e1cd40f8 	strd	r4, [sp, #8]
  directory_entry_t * p_entry = entry_array;

  watch (status_t)
  {
    ensure (ns != NULL && node != NULL
    3b88:	1a000002 	bne	3b98 <devfs_readdir+0x30>
    3b8c:	e59f00d0 	ldr	r0, [pc, #208]	; 3c64 <devfs_readdir+0xfc>
      }
    }

    return status;
  }
}
    3b90:	e28dd010 	add	sp, sp, #16
    3b94:	e8bd83b0 	pop	{r4, r5, r7, r8, r9, pc}
  int64_t pos = 0;
  directory_entry_t * p_entry = entry_array;

  watch (status_t)
  {
    ensure (ns != NULL && node != NULL
    3b98:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    3b9c:	e3500000 	cmp	r0, #0
    3ba0:	13530000 	cmpne	r3, #0
    3ba4:	03a07001 	moveq	r7, #1
    3ba8:	13a07000 	movne	r7, #0
    3bac:	0afffff6 	beq	3b8c <devfs_readdir+0x24>
        && entry_array != NULL && p_count != NULL, DNA_ERROR);
    ensure (inode -> class == DNA_DEVFS_DIRECTORY, DNA_BAD_INODE_TYPE);
    3bb0:	e5d12010 	ldrb	r2, [r1, #16]
    3bb4:	e3520001 	cmp	r2, #1
    3bb8:	159f00a8 	ldrne	r0, [pc, #168]	; 3c68 <devfs_readdir+0x100>
    3bbc:	1afffff3 	bne	3b90 <devfs_readdir+0x28>

    if (inode -> entry_list . status == 0)
    3bc0:	e5910138 	ldr	r0, [r1, #312]	; 0x138
    3bc4:	e3500000 	cmp	r0, #0
    3bc8:	1a000002 	bne	3bd8 <devfs_readdir+0x70>
      entry = queue_lookup (& inode -> entry_list,
          devfs_entry_index_inspector, & pos);

      if (entry == NULL)
      {
        *p_count = 0;
    3bcc:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    3bd0:	e5820000 	str	r0, [r2]
    3bd4:	eaffffed 	b	3b90 <devfs_readdir+0x28>
    {
      *p_count = 0;
    }
    else
    {
      pos = * offset;
    3bd8:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    3bdc:	e28d2010 	add	r2, sp, #16
    3be0:	e1c040d0 	ldrd	r4, [r0]
      entry = queue_lookup (& inode -> entry_list,
    3be4:	e2810f4b 	add	r0, r1, #300	; 0x12c
    {
      *p_count = 0;
    }
    else
    {
      pos = * offset;
    3be8:	e16240f8 	strd	r4, [r2, #-8]!
      entry = queue_lookup (& inode -> entry_list,
    3bec:	e59f1078 	ldr	r1, [pc, #120]	; 3c6c <devfs_readdir+0x104>
    3bf0:	e58d3004 	str	r3, [sp, #4]
    3bf4:	eb0030bd 	bl	fef0 <queue_lookup>
          devfs_entry_index_inspector, & pos);

      if (entry == NULL)
    3bf8:	e3500000 	cmp	r0, #0
    3bfc:	e59d3004 	ldr	r3, [sp, #4]
    3c00:	0afffff1 	beq	3bcc <devfs_readdir+0x64>
        *p_count = 0;
      }
      else
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = devfs -> vid;
    3c04:	e5982010 	ldr	r2, [r8, #16]
        dna_strcpy (p_entry -> d_name, entry -> name);
    3c08:	e2804011 	add	r4, r0, #17
      {
        *p_count = 0;
      }
      else
      {
        p_entry -> vnid = entry -> id;
    3c0c:	e1c080d8 	ldrd	r8, [r0, #8]
        p_entry -> vid = devfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);
    3c10:	e1a01004 	mov	r1, r4
        *p_count = 0;
      }
      else
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = devfs -> vid;
    3c14:	e5832008 	str	r2, [r3, #8]
      {
        *p_count = 0;
      }
      else
      {
        p_entry -> vnid = entry -> id;
    3c18:	e1c380f0 	strd	r8, [r3]
        p_entry -> vid = devfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);
    3c1c:	e283000e 	add	r0, r3, #14
    3c20:	e58d3004 	str	r3, [sp, #4]
    3c24:	eb003113 	bl	10078 <dna_strcpy>

        p_entry -> d_reclen = sizeof (struct _directory_entry)
          + dna_strlen (entry -> name);
    3c28:	e1a00004 	mov	r0, r4
    3c2c:	eb0030dc 	bl	ffa4 <dna_strlen>
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = devfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
    3c30:	e59d3004 	ldr	r3, [sp, #4]
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
        *offset += 1;
    3c34:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = devfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
    3c38:	e2800010 	add	r0, r0, #16
    3c3c:	e6ff1070 	uxth	r1, r0
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
        *offset += 1;
    3c40:	e1c240d0 	ldrd	r4, [r2]
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = devfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
    3c44:	e1c310bc 	strh	r1, [r3, #12]
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
        *offset += 1;
    3c48:	e2944001 	adds	r4, r4, #1
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
    3c4c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
        *offset += 1;
    3c50:	e2a55000 	adc	r5, r5, #0
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
    3c54:	e5831000 	str	r1, [r3]
        *offset += 1;
      }
    }

    return status;
    3c58:	e1a00007 	mov	r0, r7

        p_entry -> d_reclen = sizeof (struct _directory_entry)
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
        *offset += 1;
    3c5c:	e1c240f0 	strd	r4, [r2]
    3c60:	eaffffca 	b	3b90 <devfs_readdir+0x28>
    3c64:	0000ffff 	.word	0x0000ffff
    3c68:	0000fef7 	.word	0x0000fef7
    3c6c:	00003e4c 	.word	0x00003e4c

00003c70 <devfs_entry_name_inspector>:
  devfs_entry_t e = entry;
  char * name = va_arg (list, char *);
  
  watch (bool)
  {
    ensure (e != NULL, false);
    3c70:	e3500000 	cmp	r0, #0
#include <DnaTools/DnaTools.h>

bool devfs_entry_name_inspector (void * entry, va_list list)
{
  devfs_entry_t e = entry;
  char * name = va_arg (list, char *);
    3c74:	e5911000 	ldr	r1, [r1]
  
  watch (bool)
  {
    ensure (e != NULL, false);
    3c78:	012fff1e 	bxeq	lr
    ensure (name != NULL, false);
    3c7c:	e3510000 	cmp	r1, #0
    3c80:	0a000005 	beq	3c9c <devfs_entry_name_inspector+0x2c>

#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

bool devfs_entry_name_inspector (void * entry, va_list list)
{
    3c84:	e92d4008 	push	{r3, lr}
  watch (bool)
  {
    ensure (e != NULL, false);
    ensure (name != NULL, false);

    return dna_strcmp (e -> name, name) == 0;
    3c88:	e2800011 	add	r0, r0, #17
    3c8c:	eb00308b 	bl	fec0 <dna_strcmp>
    3c90:	e16f0f10 	clz	r0, r0
    3c94:	e1a002a0 	lsr	r0, r0, #5
    3c98:	e8bd8008 	pop	{r3, pc}
  devfs_entry_t e = entry;
  char * name = va_arg (list, char *);
  
  watch (bool)
  {
    ensure (e != NULL, false);
    3c9c:	e1a00001 	mov	r0, r1
    3ca0:	e12fff1e 	bx	lr

00003ca4 <devfs_inode_id_inspector>:
#include <DnaTools/DnaTools.h>

bool devfs_inode_id_inspector (void * inode, va_list list)
{
  devfs_inode_t i = inode;
  int64_t id = va_arg (list, int64_t);
    3ca4:	e2811007 	add	r1, r1, #7
    3ca8:	e3c11007 	bic	r1, r1, #7

  watch (bool)
  {
    ensure (i != NULL, false);
    3cac:	e3500000 	cmp	r0, #0
#include <DnaTools/DnaTools.h>

bool devfs_inode_id_inspector (void * inode, va_list list)
{
  devfs_inode_t i = inode;
  int64_t id = va_arg (list, int64_t);
    3cb0:	e1c120d0 	ldrd	r2, [r1]

  watch (bool)
  {
    ensure (i != NULL, false);
    3cb4:	012fff1e 	bxeq	lr
    return i -> id == id;
    3cb8:	e1c000d8 	ldrd	r0, [r0, #8]
    3cbc:	e1510003 	cmp	r1, r3
    3cc0:	01500002 	cmpeq	r0, r2
    3cc4:	03a00001 	moveq	r0, #1
    3cc8:	13a00000 	movne	r0, #0
  }
}
    3ccc:	e12fff1e 	bx	lr

00003cd0 <devfs_inode_clean>:
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_inode_clean (devfs_t fs, devfs_inode_t inode)
{
    3cd0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    3cd4:	e1a06000 	mov	r6, r0
    3cd8:	e1a05001 	mov	r5, r1
    3cdc:	e2808014 	add	r8, r0, #20

  watch (status_t)
  {
    dna_log(VERBOSE_LEVEL, "Clean inode [%s] forward.", inode -> name);

    entry = queue_lookup (& inode -> entry_list, devfs_entry_unused_inspector);
    3ce0:	e2857f4b 	add	r7, r5, #300	; 0x12c
    3ce4:	e1a00007 	mov	r0, r7
    3ce8:	e59f10dc 	ldr	r1, [pc, #220]	; 3dcc <devfs_inode_clean+0xfc>
    3cec:	eb00307f 	bl	fef0 <queue_lookup>
    while (entry != NULL)
    3cf0:	e2503000 	subs	r3, r0, #0
    3cf4:	1a00000f 	bne	3d38 <devfs_inode_clean+0x68>
    3cf8:	ea000016 	b	3d58 <devfs_inode_clean+0x88>

      next_inode = queue_lookup (& fs -> inode_list,
          devfs_inode_id_inspector, entry -> id);
      ensure (next_inode != NULL, DNA_NO_VNODE);

      status = devfs_inode_destroy (fs, next_inode);
    3cfc:	e1a01004 	mov	r1, r4
    3d00:	e1a00006 	mov	r0, r6
    3d04:	ebfffd7e 	bl	3304 <devfs_inode_destroy>
      ensure (status == DNA_OK, status);
    3d08:	e3500000 	cmp	r0, #0

      status = devfs_entry_remove_by_name (inode, next_inode -> name);
    3d0c:	e2841018 	add	r1, r4, #24
      next_inode = queue_lookup (& fs -> inode_list,
          devfs_inode_id_inspector, entry -> id);
      ensure (next_inode != NULL, DNA_NO_VNODE);

      status = devfs_inode_destroy (fs, next_inode);
      ensure (status == DNA_OK, status);
    3d10:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}

      status = devfs_entry_remove_by_name (inode, next_inode -> name);
    3d14:	e1a00005 	mov	r0, r5
    3d18:	eb00007b 	bl	3f0c <devfs_entry_remove_by_name>
      ensure (status == DNA_OK, status);
    3d1c:	e3500000 	cmp	r0, #0

      entry = queue_lookup (& inode -> entry_list,
    3d20:	e59f10a4 	ldr	r1, [pc, #164]	; 3dcc <devfs_inode_clean+0xfc>

      status = devfs_inode_destroy (fs, next_inode);
      ensure (status == DNA_OK, status);

      status = devfs_entry_remove_by_name (inode, next_inode -> name);
      ensure (status == DNA_OK, status);
    3d24:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}

      entry = queue_lookup (& inode -> entry_list,
    3d28:	e1a00007 	mov	r0, r7
    3d2c:	eb00306f 	bl	fef0 <queue_lookup>
  watch (status_t)
  {
    dna_log(VERBOSE_LEVEL, "Clean inode [%s] forward.", inode -> name);

    entry = queue_lookup (& inode -> entry_list, devfs_entry_unused_inspector);
    while (entry != NULL)
    3d30:	e2503000 	subs	r3, r0, #0
    3d34:	0a000007 	beq	3d58 <devfs_inode_clean+0x88>
    {
      dna_log(VERBOSE_LEVEL, "Unused entry [%s].", entry -> name);

      next_inode = queue_lookup (& fs -> inode_list,
    3d38:	e1c320d8 	ldrd	r2, [r3, #8]
    3d3c:	e1a00008 	mov	r0, r8
    3d40:	e59f1088 	ldr	r1, [pc, #136]	; 3dd0 <devfs_inode_clean+0x100>
    3d44:	eb003069 	bl	fef0 <queue_lookup>
          devfs_inode_id_inspector, entry -> id);
      ensure (next_inode != NULL, DNA_NO_VNODE);
    3d48:	e2504000 	subs	r4, r0, #0
    3d4c:	1affffea 	bne	3cfc <devfs_inode_clean+0x2c>
    3d50:	e59f007c 	ldr	r0, [pc, #124]	; 3dd4 <devfs_inode_clean+0x104>
    3d54:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
          devfs_entry_unused_inspector);
    }

    dna_log(VERBOSE_LEVEL, "Clean inode [%s] backward.", inode -> name);

    if (inode -> entry_list . status == 0 && inode -> parent != NULL)
    3d58:	e5953138 	ldr	r3, [r5, #312]	; 0x138
    3d5c:	e3530000 	cmp	r3, #0
    3d60:	1a000015 	bne	3dbc <devfs_inode_clean+0xec>
    3d64:	e5950014 	ldr	r0, [r5, #20]
    3d68:	e3500000 	cmp	r0, #0
    3d6c:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
    {
      entry = queue_lookup (& inode -> parent -> entry_list,
          devfs_entry_name_inspector, inode -> name);
    3d70:	e2854018 	add	r4, r5, #24

    dna_log(VERBOSE_LEVEL, "Clean inode [%s] backward.", inode -> name);

    if (inode -> entry_list . status == 0 && inode -> parent != NULL)
    {
      entry = queue_lookup (& inode -> parent -> entry_list,
    3d74:	e2800f4b 	add	r0, r0, #300	; 0x12c
    3d78:	e1a02004 	mov	r2, r4
    3d7c:	e59f1054 	ldr	r1, [pc, #84]	; 3dd8 <devfs_inode_clean+0x108>
    3d80:	eb00305a 	bl	fef0 <queue_lookup>
          devfs_entry_name_inspector, inode -> name);
      ensure (entry != NULL, DNA_NO_ENTRY);
    3d84:	e3500000 	cmp	r0, #0
    3d88:	0a00000d 	beq	3dc4 <devfs_inode_clean+0xf4>

      status = devfs_entry_remove_by_name (inode -> parent, inode -> name);
    3d8c:	e1a01004 	mov	r1, r4
    3d90:	e5950014 	ldr	r0, [r5, #20]
    3d94:	eb00005c 	bl	3f0c <devfs_entry_remove_by_name>
      ensure (status == DNA_OK, status);
    3d98:	e3500000 	cmp	r0, #0
    3d9c:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}

      status = devfs_inode_destroy (fs, inode);
    3da0:	e1a00006 	mov	r0, r6
    3da4:	e1a01005 	mov	r1, r5
    3da8:	ebfffd55 	bl	3304 <devfs_inode_destroy>
      ensure (status == DNA_OK, status);
    3dac:	e3500000 	cmp	r0, #0
    3db0:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}

      status = devfs_inode_clean (fs, inode -> parent);
    3db4:	e5955014 	ldr	r5, [r5, #20]
    3db8:	eaffffc8 	b	3ce0 <devfs_inode_clean+0x10>
      ensure (status == DNA_OK, status);
    }

    return DNA_OK;
    3dbc:	e3a00000 	mov	r0, #0
    3dc0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

    if (inode -> entry_list . status == 0 && inode -> parent != NULL)
    {
      entry = queue_lookup (& inode -> parent -> entry_list,
          devfs_entry_name_inspector, inode -> name);
      ensure (entry != NULL, DNA_NO_ENTRY);
    3dc4:	e59f0010 	ldr	r0, [pc, #16]	; 3ddc <devfs_inode_clean+0x10c>
      ensure (status == DNA_OK, status);
    }

    return DNA_OK;
  }
}
    3dc8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    3dcc:	00002ddc 	.word	0x00002ddc
    3dd0:	00003ca4 	.word	0x00003ca4
    3dd4:	0000fefd 	.word	0x0000fefd
    3dd8:	00003c70 	.word	0x00003c70
    3ddc:	0000feff 	.word	0x0000feff

00003de0 <devfs_entry_remove_by_index>:
  devfs_entry_t entry;
  status_t status;

  watch (status_t)
  {
    ensure (node != NULL, DNA_BAD_ARGUMENT);
    3de0:	e3500000 	cmp	r0, #0
    3de4:	0a00000e 	beq	3e24 <devfs_entry_remove_by_index+0x44>
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_entry_remove_by_index (devfs_inode_t node, int32_t index)
{
    3de8:	e92d4038 	push	{r3, r4, r5, lr}

  watch (status_t)
  {
    ensure (node != NULL, DNA_BAD_ARGUMENT);

    entry = queue_lookup (& node -> entry_list,
    3dec:	e2804f4b 	add	r4, r0, #300	; 0x12c
    3df0:	e1a02001 	mov	r2, r1
    3df4:	e1a00004 	mov	r0, r4
    3df8:	e59f103c 	ldr	r1, [pc, #60]	; 3e3c <devfs_entry_remove_by_index+0x5c>
    3dfc:	eb00303b 	bl	fef0 <queue_lookup>
        devfs_entry_index_inspector, index);
    ensure (entry != NULL, DNA_NO_ENTRY);
    3e00:	e2505000 	subs	r5, r0, #0
    3e04:	0a000004 	beq	3e1c <devfs_entry_remove_by_index+0x3c>

    status = queue_extract (& node -> entry_list, entry);
    3e08:	e1a00004 	mov	r0, r4
    3e0c:	e1a01005 	mov	r1, r5
    3e10:	eb002cf4 	bl	f1e8 <queue_extract>
    ensure (status == DNA_OK, DNA_NO_ENTRY);
    3e14:	e2504000 	subs	r4, r0, #0
    3e18:	0a000003 	beq	3e2c <devfs_entry_remove_by_index+0x4c>
  {
    ensure (node != NULL, DNA_BAD_ARGUMENT);

    entry = queue_lookup (& node -> entry_list,
        devfs_entry_index_inspector, index);
    ensure (entry != NULL, DNA_NO_ENTRY);
    3e1c:	e59f001c 	ldr	r0, [pc, #28]	; 3e40 <devfs_entry_remove_by_index+0x60>
    3e20:	e8bd8038 	pop	{r3, r4, r5, pc}
  devfs_entry_t entry;
  status_t status;

  watch (status_t)
  {
    ensure (node != NULL, DNA_BAD_ARGUMENT);
    3e24:	e59f0018 	ldr	r0, [pc, #24]	; 3e44 <devfs_entry_remove_by_index+0x64>
    3e28:	e12fff1e 	bx	lr
    ensure (entry != NULL, DNA_NO_ENTRY);

    status = queue_extract (& node -> entry_list, entry);
    ensure (status == DNA_OK, DNA_NO_ENTRY);
 
    kernel_free (entry);
    3e2c:	e1a00005 	mov	r0, r5
    3e30:	eb0040cb 	bl	14164 <kernel_free>
    return DNA_OK;
    3e34:	e1a00004 	mov	r0, r4
    3e38:	e8bd8038 	pop	{r3, r4, r5, pc}
    3e3c:	00003e4c 	.word	0x00003e4c
    3e40:	0000feff 	.word	0x0000feff
    3e44:	0000fffc 	.word	0x0000fffc

00003e48 <devfs_write_vnode>:

  watch (status_t)
  {
    dna_log(VERBOSE_LEVEL, "Write inode [%s].", inode -> name);

    status = devfs_inode_clean (devfs, inode);
    3e48:	eaffffa0 	b	3cd0 <devfs_inode_clean>

00003e4c <devfs_entry_index_inspector>:
  devfs_entry_t e = entry;
  int64_t * index = va_arg (list, int64_t *);

  watch (bool)
  {
    ensure (e != NULL, false);
    3e4c:	e3500000 	cmp	r0, #0
#include <DnaTools/DnaTools.h>

bool devfs_entry_index_inspector (void * entry, va_list list)
{
  devfs_entry_t e = entry;
  int64_t * index = va_arg (list, int64_t *);
    3e50:	e5911000 	ldr	r1, [r1]

  watch (bool)
  {
    ensure (e != NULL, false);
    3e54:	012fff1e 	bxeq	lr
    ensure (index != NULL, false);
    3e58:	e3510000 	cmp	r1, #0
    3e5c:	0a000009 	beq	3e88 <devfs_entry_index_inspector+0x3c>

    if (*index == 0) return true;
    3e60:	e1c120d0 	ldrd	r2, [r1]
    3e64:	e1920003 	orrs	r0, r2, r3
    3e68:	0a000004 	beq	3e80 <devfs_entry_index_inspector+0x34>

    *index = *index - 1;
    3e6c:	e2522001 	subs	r2, r2, #1
    3e70:	e2c33000 	sbc	r3, r3, #0
    return false;
    3e74:	e3a00000 	mov	r0, #0
    ensure (e != NULL, false);
    ensure (index != NULL, false);

    if (*index == 0) return true;

    *index = *index - 1;
    3e78:	e1c120f0 	strd	r2, [r1]
    return false;
    3e7c:	e12fff1e 	bx	lr
  watch (bool)
  {
    ensure (e != NULL, false);
    ensure (index != NULL, false);

    if (*index == 0) return true;
    3e80:	e3a00001 	mov	r0, #1

    *index = *index - 1;
    return false;
  }
}
    3e84:	e12fff1e 	bx	lr
  devfs_entry_t e = entry;
  int64_t * index = va_arg (list, int64_t *);

  watch (bool)
  {
    ensure (e != NULL, false);
    3e88:	e1a00001 	mov	r0, r1
    3e8c:	e12fff1e 	bx	lr

00003e90 <devfs_mkdir>:
  /*
   * Oops! We don't authorize mkdir on this FS !
   */

  return DNA_ERROR;
}
    3e90:	e59f0000 	ldr	r0, [pc]	; 3e98 <devfs_mkdir+0x8>
    3e94:	e12fff1e 	bx	lr
    3e98:	0000ffff 	.word	0x0000ffff

00003e9c <devfs_entry_add>:
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_entry_add (devfs_inode_t inode, char * name, int64_t vnid)
{
    3e9c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  devfs_entry_t entry;

  watch (status_t)
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    3ea0:	e2507000 	subs	r7, r0, #0
    3ea4:	0a000012 	beq	3ef4 <devfs_entry_add+0x58>
    ensure (name != NULL, DNA_BAD_ARGUMENT);
    3ea8:	e3510000 	cmp	r1, #0
    3eac:	e1a06001 	mov	r6, r1
    3eb0:	0a00000f 	beq	3ef4 <devfs_entry_add+0x58>

    entry = kernel_malloc (sizeof (struct devfs_entry), true);
    3eb4:	e3a00f46 	mov	r0, #280	; 0x118
    3eb8:	e3a01001 	mov	r1, #1
    3ebc:	e1a04002 	mov	r4, r2
    3ec0:	e1a05003 	mov	r5, r3
    3ec4:	eb004071 	bl	14090 <kernel_malloc>
    ensure (entry != NULL, DNA_OUT_OF_MEM);
    3ec8:	e2508000 	subs	r8, r0, #0
    3ecc:	0a00000a 	beq	3efc <devfs_entry_add+0x60>

    entry -> id = vnid;
    dna_strcpy (entry -> name, name);
    3ed0:	e1a01006 	mov	r1, r6
    ensure (name != NULL, DNA_BAD_ARGUMENT);

    entry = kernel_malloc (sizeof (struct devfs_entry), true);
    ensure (entry != NULL, DNA_OUT_OF_MEM);

    entry -> id = vnid;
    3ed4:	e1c840f8 	strd	r4, [r8, #8]
    dna_strcpy (entry -> name, name);
    3ed8:	e2880011 	add	r0, r8, #17
    3edc:	eb003065 	bl	10078 <dna_strcpy>
    queue_add (& inode -> entry_list, entry);
    3ee0:	e2870f4b 	add	r0, r7, #300	; 0x12c
    3ee4:	e1a01008 	mov	r1, r8
    3ee8:	eb002fc9 	bl	fe14 <queue_add>

    return DNA_OK;
    3eec:	e3a00000 	mov	r0, #0
    3ef0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
{
  devfs_entry_t entry;

  watch (status_t)
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    3ef4:	e59f0008 	ldr	r0, [pc, #8]	; 3f04 <devfs_entry_add+0x68>
    3ef8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    ensure (name != NULL, DNA_BAD_ARGUMENT);

    entry = kernel_malloc (sizeof (struct devfs_entry), true);
    ensure (entry != NULL, DNA_OUT_OF_MEM);
    3efc:	e59f0004 	ldr	r0, [pc, #4]	; 3f08 <devfs_entry_add+0x6c>
    dna_strcpy (entry -> name, name);
    queue_add (& inode -> entry_list, entry);

    return DNA_OK;
  }
}
    3f00:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    3f04:	0000fffc 	.word	0x0000fffc
    3f08:	0000fffd 	.word	0x0000fffd

00003f0c <devfs_entry_remove_by_name>:
  devfs_entry_t entry;
  status_t status;

  watch (status_t)
  {
    ensure (node != NULL, DNA_BAD_ARGUMENT);
    3f0c:	e3500000 	cmp	r0, #0
    3f10:	0a000010 	beq	3f58 <devfs_entry_remove_by_name+0x4c>
    ensure (name != NULL, DNA_BAD_ARGUMENT);
    3f14:	e3510000 	cmp	r1, #0
    3f18:	0a00000e 	beq	3f58 <devfs_entry_remove_by_name+0x4c>
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_entry_remove_by_name (devfs_inode_t node, char * name)
{
    3f1c:	e92d4038 	push	{r3, r4, r5, lr}
  watch (status_t)
  {
    ensure (node != NULL, DNA_BAD_ARGUMENT);
    ensure (name != NULL, DNA_BAD_ARGUMENT);

    entry = queue_lookup (& node -> entry_list,
    3f20:	e2804f4b 	add	r4, r0, #300	; 0x12c
    3f24:	e1a02001 	mov	r2, r1
    3f28:	e1a00004 	mov	r0, r4
    3f2c:	e59f103c 	ldr	r1, [pc, #60]	; 3f70 <devfs_entry_remove_by_name+0x64>
    3f30:	eb002fee 	bl	fef0 <queue_lookup>
        devfs_entry_name_inspector, name);
    ensure (entry != NULL, DNA_NO_ENTRY);
    3f34:	e2505000 	subs	r5, r0, #0
    3f38:	0a000004 	beq	3f50 <devfs_entry_remove_by_name+0x44>

    status = queue_extract (& node -> entry_list, entry);
    3f3c:	e1a00004 	mov	r0, r4
    3f40:	e1a01005 	mov	r1, r5
    3f44:	eb002ca7 	bl	f1e8 <queue_extract>
    ensure (status == DNA_OK, DNA_NO_ENTRY);
    3f48:	e2504000 	subs	r4, r0, #0
    3f4c:	0a000003 	beq	3f60 <devfs_entry_remove_by_name+0x54>
    ensure (node != NULL, DNA_BAD_ARGUMENT);
    ensure (name != NULL, DNA_BAD_ARGUMENT);

    entry = queue_lookup (& node -> entry_list,
        devfs_entry_name_inspector, name);
    ensure (entry != NULL, DNA_NO_ENTRY);
    3f50:	e59f001c 	ldr	r0, [pc, #28]	; 3f74 <devfs_entry_remove_by_name+0x68>
    3f54:	e8bd8038 	pop	{r3, r4, r5, pc}
  devfs_entry_t entry;
  status_t status;

  watch (status_t)
  {
    ensure (node != NULL, DNA_BAD_ARGUMENT);
    3f58:	e59f0018 	ldr	r0, [pc, #24]	; 3f78 <devfs_entry_remove_by_name+0x6c>
    3f5c:	e12fff1e 	bx	lr
    ensure (entry != NULL, DNA_NO_ENTRY);

    status = queue_extract (& node -> entry_list, entry);
    ensure (status == DNA_OK, DNA_NO_ENTRY);
 
    kernel_free (entry);
    3f60:	e1a00005 	mov	r0, r5
    3f64:	eb00407e 	bl	14164 <kernel_free>
    return DNA_OK;
    3f68:	e1a00004 	mov	r0, r4
    3f6c:	e8bd8038 	pop	{r3, r4, r5, pc}
    3f70:	00003c70 	.word	0x00003c70
    3f74:	0000feff 	.word	0x0000feff
    3f78:	0000fffc 	.word	0x0000fffc

00003f7c <rootfs_read_vnode>:

#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_read_vnode (void * ns, int64_t vnid, void ** data)
{
    3f7c:	e92d4010 	push	{r4, lr}
  rootfs_t rootfs = ns;
  rootfs_inode_t inode = NULL;

  inode = queue_lookup (& rootfs -> inode_list, rootfs_inode_inspector, vnid);
    3f80:	e59f1014 	ldr	r1, [pc, #20]	; 3f9c <rootfs_read_vnode+0x20>
    3f84:	e2800014 	add	r0, r0, #20

#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_read_vnode (void * ns, int64_t vnid, void ** data)
{
    3f88:	e59d4008 	ldr	r4, [sp, #8]
  rootfs_t rootfs = ns;
  rootfs_inode_t inode = NULL;

  inode = queue_lookup (& rootfs -> inode_list, rootfs_inode_inspector, vnid);
    3f8c:	eb002fd7 	bl	fef0 <queue_lookup>

  dna_log(VERBOSE_LEVEL, "NS = 0x%x, VNID = %lld, DATA = 0x%x",
      ns, vnid, inode);

  *data = inode;
    3f90:	e5840000 	str	r0, [r4]
  return DNA_OK;
}
    3f94:	e3a00000 	mov	r0, #0
    3f98:	e8bd8010 	pop	{r4, pc}
    3f9c:	00004374 	.word	0x00004374

00003fa0 <rootfs_readdir>:
#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_readdir (void * ns, void * node, void * data,
    void * entry_array, int64_t * offset, int32_t * p_count)
{
    3fa0:	e92d43b0 	push	{r4, r5, r7, r8, r9, lr}
  int64_t pos = 0;
  directory_entry_t * p_entry = entry_array;

  watch (status_t)
  {
    ensure (ns != NULL && node != NULL && entry_array
    3fa4:	e3510000 	cmp	r1, #0
    3fa8:	13500000 	cmpne	r0, #0
    void * entry_array, int64_t * offset, int32_t * p_count)
{
  rootfs_t rootfs = ns;
  rootfs_inode_t inode = node;
  rootfs_entry_t entry = NULL;
  int64_t pos = 0;
    3fac:	e3a04000 	mov	r4, #0
    3fb0:	e3a05000 	mov	r5, #0
#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_readdir (void * ns, void * node, void * data,
    void * entry_array, int64_t * offset, int32_t * p_count)
{
    3fb4:	e24dd010 	sub	sp, sp, #16
  int64_t pos = 0;
  directory_entry_t * p_entry = entry_array;

  watch (status_t)
  {
    ensure (ns != NULL && node != NULL && entry_array
    3fb8:	e1a08000 	mov	r8, r0
    void * entry_array, int64_t * offset, int32_t * p_count)
{
  rootfs_t rootfs = ns;
  rootfs_inode_t inode = node;
  rootfs_entry_t entry = NULL;
  int64_t pos = 0;
    3fbc:	e1cd40f8 	strd	r4, [sp, #8]
  directory_entry_t * p_entry = entry_array;

  watch (status_t)
  {
    ensure (ns != NULL && node != NULL && entry_array
    3fc0:	1a000002 	bne	3fd0 <rootfs_readdir+0x30>
    3fc4:	e59f00d0 	ldr	r0, [pc, #208]	; 409c <rootfs_readdir+0xfc>
      }
    }

    return DNA_OK;
  }
}
    3fc8:	e28dd010 	add	sp, sp, #16
    3fcc:	e8bd83b0 	pop	{r4, r5, r7, r8, r9, pc}
  int64_t pos = 0;
  directory_entry_t * p_entry = entry_array;

  watch (status_t)
  {
    ensure (ns != NULL && node != NULL && entry_array
    3fd0:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    3fd4:	e3500000 	cmp	r0, #0
    3fd8:	13530000 	cmpne	r3, #0
    3fdc:	03a07001 	moveq	r7, #1
    3fe0:	13a07000 	movne	r7, #0
    3fe4:	0afffff6 	beq	3fc4 <rootfs_readdir+0x24>
        && p_count != NULL, DNA_ERROR);
    ensure (inode -> class == DNA_ROOTFS_DIRECTORY, DNA_BAD_INODE_TYPE);
    3fe8:	e5d12110 	ldrb	r2, [r1, #272]	; 0x110
    3fec:	e3520001 	cmp	r2, #1
    3ff0:	159f00a8 	ldrne	r0, [pc, #168]	; 40a0 <rootfs_readdir+0x100>
    3ff4:	1afffff3 	bne	3fc8 <rootfs_readdir+0x28>

    if (inode -> entry_list . status == 0)
    3ff8:	e5910134 	ldr	r0, [r1, #308]	; 0x134
    3ffc:	e3500000 	cmp	r0, #0
    4000:	1a000002 	bne	4010 <rootfs_readdir+0x70>
      entry = queue_lookup (& inode -> entry_list,
          rootfs_entry_index_inspector, & pos);

      if (entry == NULL)
      {
        *p_count = 0;
    4004:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    4008:	e5820000 	str	r0, [r2]
    400c:	eaffffed 	b	3fc8 <rootfs_readdir+0x28>
    {
      *p_count = 0;
    }
    else
    {
      pos = *offset;
    4010:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    4014:	e28d2010 	add	r2, sp, #16
    4018:	e1c040d0 	ldrd	r4, [r0]
      entry = queue_lookup (& inode -> entry_list,
    401c:	e2810f4a 	add	r0, r1, #296	; 0x128
    {
      *p_count = 0;
    }
    else
    {
      pos = *offset;
    4020:	e16240f8 	strd	r4, [r2, #-8]!
      entry = queue_lookup (& inode -> entry_list,
    4024:	e59f1078 	ldr	r1, [pc, #120]	; 40a4 <rootfs_readdir+0x104>
    4028:	e58d3004 	str	r3, [sp, #4]
    402c:	eb002faf 	bl	fef0 <queue_lookup>
          rootfs_entry_index_inspector, & pos);

      if (entry == NULL)
    4030:	e3500000 	cmp	r0, #0
    4034:	e59d3004 	ldr	r3, [sp, #4]
    4038:	0afffff1 	beq	4004 <rootfs_readdir+0x64>
        *p_count = 0;
      }
      else
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = rootfs -> vid;
    403c:	e5982010 	ldr	r2, [r8, #16]
        dna_strcpy (p_entry -> d_name, entry -> name);
    4040:	e2804010 	add	r4, r0, #16
      {
        *p_count = 0;
      }
      else
      {
        p_entry -> vnid = entry -> id;
    4044:	e1c080d8 	ldrd	r8, [r0, #8]
        p_entry -> vid = rootfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);
    4048:	e1a01004 	mov	r1, r4
        *p_count = 0;
      }
      else
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = rootfs -> vid;
    404c:	e5832008 	str	r2, [r3, #8]
      {
        *p_count = 0;
      }
      else
      {
        p_entry -> vnid = entry -> id;
    4050:	e1c380f0 	strd	r8, [r3]
        p_entry -> vid = rootfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);
    4054:	e283000e 	add	r0, r3, #14
    4058:	e58d3004 	str	r3, [sp, #4]
    405c:	eb003005 	bl	10078 <dna_strcpy>

        p_entry -> d_reclen = sizeof (struct _directory_entry)
          + dna_strlen (entry -> name);
    4060:	e1a00004 	mov	r0, r4
    4064:	eb002fce 	bl	ffa4 <dna_strlen>
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = rootfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
    4068:	e59d3004 	ldr	r3, [sp, #4]
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
        *offset += 1;
    406c:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = rootfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
    4070:	e2800010 	add	r0, r0, #16
    4074:	e6ff1070 	uxth	r1, r0
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
        *offset += 1;
    4078:	e1c240d0 	ldrd	r4, [r2]
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = rootfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
    407c:	e1c310bc 	strh	r1, [r3, #12]
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
        *offset += 1;
    4080:	e2944001 	adds	r4, r4, #1
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
    4084:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
        *offset += 1;
    4088:	e2a55000 	adc	r5, r5, #0
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
    408c:	e5831000 	str	r1, [r3]
        *offset += 1;
      }
    }

    return DNA_OK;
    4090:	e1a00007 	mov	r0, r7

        p_entry -> d_reclen = sizeof (struct _directory_entry)
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
        *offset += 1;
    4094:	e1c240f0 	strd	r4, [r2]
    4098:	eaffffca 	b	3fc8 <rootfs_readdir+0x28>
    409c:	0000ffff 	.word	0x0000ffff
    40a0:	0000fef7 	.word	0x0000fef7
    40a4:	000041f4 	.word	0x000041f4

000040a8 <rootfs_ioctl>:
status_t rootfs_ioctl (void * ns, void * node, void * data,
    int32_t function, va_list arguments, int32_t * p_ret)
{

  return DNA_ERROR;
}
    40a8:	e59f0000 	ldr	r0, [pc]	; 40b0 <rootfs_ioctl+0x8>
    40ac:	e12fff1e 	bx	lr
    40b0:	0000ffff 	.word	0x0000ffff

000040b4 <rootfs_mount>:
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_mount (int32_t vid, const char * dev_path, uint32_t flags,
    void * params, void ** data, int64_t * vnid)
{
    40b4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  rootfs_t rootfs = NULL;
  rootfs_inode_t root_inode = NULL;
  rootfs_entry_t entry = NULL;
  char * entry_name[] = { ".", "..", "devices", "volumes", "system" };
    40b8:	e59fe128 	ldr	lr, [pc, #296]	; 41e8 <rootfs_mount+0x134>
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_mount (int32_t vid, const char * dev_path, uint32_t flags,
    void * params, void ** data, int64_t * vnid)
{
    40bc:	e24dd01c 	sub	sp, sp, #28
  rootfs_t rootfs = NULL;
  rootfs_inode_t root_inode = NULL;
  rootfs_entry_t entry = NULL;
  char * entry_name[] = { ".", "..", "devices", "volumes", "system" };
    40c0:	e28dc004 	add	ip, sp, #4
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_mount (int32_t vid, const char * dev_path, uint32_t flags,
    void * params, void ** data, int64_t * vnid)
{
    40c4:	e1a07000 	mov	r7, r0
  rootfs_t rootfs = NULL;
  rootfs_inode_t root_inode = NULL;
  rootfs_entry_t entry = NULL;
  char * entry_name[] = { ".", "..", "devices", "volumes", "system" };
    40c8:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    40cc:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    40d0:	e59e3000 	ldr	r3, [lr]

   rootfs = kernel_malloc (sizeof (struct rootfs), true);
    40d4:	e3a00028 	mov	r0, #40	; 0x28
    40d8:	e3a01001 	mov	r1, #1
    void * params, void ** data, int64_t * vnid)
{
  rootfs_t rootfs = NULL;
  rootfs_inode_t root_inode = NULL;
  rootfs_entry_t entry = NULL;
  char * entry_name[] = { ".", "..", "devices", "volumes", "system" };
    40dc:	e58c3000 	str	r3, [ip]
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_mount (int32_t vid, const char * dev_path, uint32_t flags,
    void * params, void ** data, int64_t * vnid)
{
    40e0:	e59d8040 	ldr	r8, [sp, #64]	; 0x40
    40e4:	e59d9044 	ldr	r9, [sp, #68]	; 0x44
  rootfs_t rootfs = NULL;
  rootfs_inode_t root_inode = NULL;
  rootfs_entry_t entry = NULL;
  char * entry_name[] = { ".", "..", "devices", "volumes", "system" };

   rootfs = kernel_malloc (sizeof (struct rootfs), true);
    40e8:	eb003fe8 	bl	14090 <kernel_malloc>
  if (rootfs == NULL) return DNA_OUT_OF_MEM;
    40ec:	e2506000 	subs	r6, r0, #0
    40f0:	0a000039 	beq	41dc <rootfs_mount+0x128>

   root_inode = kernel_malloc (sizeof (struct rootfs_inode), true);
    40f4:	e3a00f4e 	mov	r0, #312	; 0x138
    40f8:	e3a01001 	mov	r1, #1
    40fc:	eb003fe3 	bl	14090 <kernel_malloc>
  if (root_inode == NULL) return DNA_OUT_OF_MEM;
    4100:	e250a000 	subs	sl, r0, #0
    4104:	0a000034 	beq	41dc <rootfs_mount+0x128>

  rootfs -> inode_index = 1;
  rootfs -> vid = vid;

  root_inode -> id = rootfs -> inode_index ++;
    4108:	e3a02001 	mov	r2, #1
    410c:	e3a03000 	mov	r3, #0
    4110:	e3a04002 	mov	r4, #2
    4114:	e3a05000 	mov	r5, #0
    4118:	e1a0b006 	mov	fp, r6

   root_inode = kernel_malloc (sizeof (struct rootfs_inode), true);
  if (root_inode == NULL) return DNA_OUT_OF_MEM;

  rootfs -> inode_index = 1;
  rootfs -> vid = vid;
    411c:	e5867010 	str	r7, [r6, #16]

  root_inode -> id = rootfs -> inode_index ++;
  dna_strcpy (root_inode -> name, "");
    4120:	e59f10c4 	ldr	r1, [pc, #196]	; 41ec <rootfs_mount+0x138>
  if (root_inode == NULL) return DNA_OUT_OF_MEM;

  rootfs -> inode_index = 1;
  rootfs -> vid = vid;

  root_inode -> id = rootfs -> inode_index ++;
    4124:	e0cb41f4 	strd	r4, [fp], #20
  dna_strcpy (root_inode -> name, "");
    4128:	e28a0010 	add	r0, sl, #16
  if (root_inode == NULL) return DNA_OUT_OF_MEM;

  rootfs -> inode_index = 1;
  rootfs -> vid = vid;

  root_inode -> id = rootfs -> inode_index ++;
    412c:	e1ca20f8 	strd	r2, [sl, #8]
  dna_strcpy (root_inode -> name, "");
    4130:	eb002fd0 	bl	10078 <dna_strcpy>
  root_inode -> class = DNA_ROOTFS_DIRECTORY;
    4134:	e3a03001 	mov	r3, #1
    4138:	e1a0400d 	mov	r4, sp
    413c:	e5ca3110 	strb	r3, [sl, #272]	; 0x110
  queue_add (& rootfs -> inode_list, root_inode);
    4140:	e1a0000b 	mov	r0, fp
    4144:	e1a0100a 	mov	r1, sl
    4148:	eb002f31 	bl	fe14 <queue_add>

  rootfs -> root_vnid = root_inode -> id;
    414c:	e1ca20d8 	ldrd	r2, [sl, #8]
    4150:	e1c620f8 	strd	r2, [r6, #8]
    4154:	e28d7008 	add	r7, sp, #8
    entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    if (entry == NULL) return DNA_OUT_OF_MEM;

    entry -> id = root_inode -> id;
    dna_strcpy (entry -> name, entry_name[i]);
    queue_add (& root_inode -> entry_list, entry);
    4158:	e28a5f4a 	add	r5, sl, #296	; 0x128
   * Add the "." and ".." entry
   */

  for (int32_t i = 0; i < 2; i ++)
  {
    entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    415c:	e3a00e11 	mov	r0, #272	; 0x110
    4160:	e3a01001 	mov	r1, #1
    4164:	eb003fc9 	bl	14090 <kernel_malloc>
    if (entry == NULL) return DNA_OUT_OF_MEM;
    4168:	e250b000 	subs	fp, r0, #0

    entry -> id = root_inode -> id;
    dna_strcpy (entry -> name, entry_name[i]);
    416c:	e28b0010 	add	r0, fp, #16
   */

  for (int32_t i = 0; i < 2; i ++)
  {
    entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    if (entry == NULL) return DNA_OUT_OF_MEM;
    4170:	0a000019 	beq	41dc <rootfs_mount+0x128>

    entry -> id = root_inode -> id;
    4174:	e1ca20d8 	ldrd	r2, [sl, #8]
    dna_strcpy (entry -> name, entry_name[i]);
    4178:	e5b41004 	ldr	r1, [r4, #4]!
  for (int32_t i = 0; i < 2; i ++)
  {
    entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    if (entry == NULL) return DNA_OUT_OF_MEM;

    entry -> id = root_inode -> id;
    417c:	e1cb20f8 	strd	r2, [fp, #8]
    dna_strcpy (entry -> name, entry_name[i]);
    4180:	eb002fbc 	bl	10078 <dna_strcpy>
    queue_add (& root_inode -> entry_list, entry);
    4184:	e1a00005 	mov	r0, r5
    4188:	e1a0100b 	mov	r1, fp
    418c:	eb002f20 	bl	fe14 <queue_add>

  /*
   * Add the "." and ".." entry
   */

  for (int32_t i = 0; i < 2; i ++)
    4190:	e1540007 	cmp	r4, r7
    4194:	1afffff0 	bne	415c <rootfs_mount+0xa8>
    4198:	e28d5014 	add	r5, sp, #20
   * Create the standard directories
   */

  for (int32_t i = 2; i < 5; i++)
  {
    rootfs_mkdir (rootfs, root_inode, entry_name[i], 0);
    419c:	e5b42004 	ldr	r2, [r4, #4]!
    41a0:	e1a00006 	mov	r0, r6
    41a4:	e1a0100a 	mov	r1, sl
    41a8:	e3a03000 	mov	r3, #0
    41ac:	eb0000d7 	bl	4510 <rootfs_mkdir>

  /*
   * Create the standard directories
   */

  for (int32_t i = 2; i < 5; i++)
    41b0:	e1540005 	cmp	r4, r5
    41b4:	1afffff8 	bne	419c <rootfs_mount+0xe8>
  /*
   * Add the root vnode to the system
   */

  *data = rootfs;
  *vnid = root_inode -> id;
    41b8:	e1ca20d8 	ldrd	r2, [sl, #8]

  /*
   * Add the root vnode to the system
   */

  *data = rootfs;
    41bc:	e5886000 	str	r6, [r8]
  *vnid = root_inode -> id;
    41c0:	e1c920f0 	strd	r2, [r9]

  dna_log(VERBOSE_LEVEL, "VNODE CREATE ID 0x%x, VID 0x%x",
      root_inode -> id, rootfs -> vid);

  return vnode_create (root_inode -> id, rootfs -> vid, (void *) root_inode);
    41c4:	e1a0300a 	mov	r3, sl
    41c8:	e1ca00d8 	ldrd	r0, [sl, #8]
    41cc:	e5962010 	ldr	r2, [r6, #16]
}
    41d0:	e28dd01c 	add	sp, sp, #28
    41d4:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  *vnid = root_inode -> id;

  dna_log(VERBOSE_LEVEL, "VNODE CREATE ID 0x%x, VID 0x%x",
      root_inode -> id, rootfs -> vid);

  return vnode_create (root_inode -> id, rootfs -> vid, (void *) root_inode);
    41d8:	ea0025b9 	b	d8c4 <vnode_create>
}
    41dc:	e59f000c 	ldr	r0, [pc, #12]	; 41f0 <rootfs_mount+0x13c>
    41e0:	e28dd01c 	add	sp, sp, #28
    41e4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    41e8:	00032820 	.word	0x00032820
    41ec:	00032ca0 	.word	0x00032ca0
    41f0:	0000fffd 	.word	0x0000fffd

000041f4 <rootfs_entry_index_inspector>:
  rootfs_entry_t e = entry;
  int64_t * index = va_arg (list, int64_t *);

  watch (bool)
  {
    ensure (e != NULL, false);
    41f4:	e3500000 	cmp	r0, #0
#include <DnaTools/DnaTools.h>

bool rootfs_entry_index_inspector (void * entry, va_list list)
{
  rootfs_entry_t e = entry;
  int64_t * index = va_arg (list, int64_t *);
    41f8:	e5911000 	ldr	r1, [r1]

  watch (bool)
  {
    ensure (e != NULL, false);
    41fc:	012fff1e 	bxeq	lr
    ensure (index != NULL, false);
    4200:	e3510000 	cmp	r1, #0
    4204:	0a000009 	beq	4230 <rootfs_entry_index_inspector+0x3c>

    if (*index == 0) return true;
    4208:	e1c120d0 	ldrd	r2, [r1]
    420c:	e1920003 	orrs	r0, r2, r3
    4210:	0a000004 	beq	4228 <rootfs_entry_index_inspector+0x34>
    
    *index = * index - 1;
    4214:	e2522001 	subs	r2, r2, #1
    4218:	e2c33000 	sbc	r3, r3, #0
    return false;
    421c:	e3a00000 	mov	r0, #0
    ensure (e != NULL, false);
    ensure (index != NULL, false);

    if (*index == 0) return true;
    
    *index = * index - 1;
    4220:	e1c120f0 	strd	r2, [r1]
    return false;
    4224:	e12fff1e 	bx	lr
  watch (bool)
  {
    ensure (e != NULL, false);
    ensure (index != NULL, false);

    if (*index == 0) return true;
    4228:	e3a00001 	mov	r0, #1
    
    *index = * index - 1;
    return false;
  }
}
    422c:	e12fff1e 	bx	lr
  rootfs_entry_t e = entry;
  int64_t * index = va_arg (list, int64_t *);

  watch (bool)
  {
    ensure (e != NULL, false);
    4230:	e1a00001 	mov	r0, r1
    4234:	e12fff1e 	bx	lr

00004238 <rootfs_write>:
status_t rootfs_write (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
  status_t status = DNA_OK;

  * p_count = 0;
    4238:	e3a03000 	mov	r3, #0
#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_write (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
    423c:	e59d2008 	ldr	r2, [sp, #8]
  status_t status = DNA_OK;

  * p_count = 0;
  return status;
}
    4240:	e1a00003 	mov	r0, r3
status_t rootfs_write (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
  status_t status = DNA_OK;

  * p_count = 0;
    4244:	e5823000 	str	r3, [r2]
  return status;
}
    4248:	e12fff1e 	bx	lr

0000424c <rootfs_get_info>:
#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_get_info (void * ns, void * node,
    void * data, file_info_t * p_info)
{
    424c:	e92d4070 	push	{r4, r5, r6, lr}
  rootfs_t rootfs = ns;
  rootfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (rootfs != NULL, DNA_BAD_ARGUMENT);
    4250:	e2506000 	subs	r6, r0, #0
    4254:	0a000015 	beq	42b0 <rootfs_get_info+0x64>
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    4258:	e3510000 	cmp	r1, #0
    425c:	e1a05001 	mov	r5, r1
    4260:	0a000012 	beq	42b0 <rootfs_get_info+0x64>
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);
    4264:	e3530000 	cmp	r3, #0
    4268:	e1a04003 	mov	r4, r3
    426c:	0a00000f 	beq	42b0 <rootfs_get_info+0x64>

    dna_memset (p_info, 0, sizeof (file_info_t));
    4270:	e1a00003 	mov	r0, r3
    4274:	e3a01000 	mov	r1, #0
    4278:	e3a02040 	mov	r2, #64	; 0x40
    427c:	eb002c7c 	bl	f474 <dna_memset>

    p_info -> volume = rootfs -> vid;
    p_info -> vnode = inode -> id;
    4280:	e1c520d8 	ldrd	r2, [r5, #8]

    switch (inode -> class)
    4284:	e5d51110 	ldrb	r1, [r5, #272]	; 0x110
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);

    dna_memset (p_info, 0, sizeof (file_info_t));

    p_info -> volume = rootfs -> vid;
    4288:	e5960010 	ldr	r0, [r6, #16]
    p_info -> vnode = inode -> id;

    switch (inode -> class)
    428c:	e3510001 	cmp	r1, #1
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);

    dna_memset (p_info, 0, sizeof (file_info_t));

    p_info -> volume = rootfs -> vid;
    4290:	e5840000 	str	r0, [r4]
    p_info -> vnode = inode -> id;
    4294:	e1c420f8 	strd	r2, [r4, #8]

    switch (inode -> class)
    4298:	0a000009 	beq	42c4 <rootfs_get_info+0x78>
    429c:	3a000005 	bcc	42b8 <rootfs_get_info+0x6c>
    42a0:	e3510002 	cmp	r1, #2
    42a4:	0a000006 	beq	42c4 <rootfs_get_info+0x78>
          p_info -> type = DNA_FILE_SYMBOLIC_LINK;
          break;
        }
    }

    return DNA_OK;
    42a8:	e3a00000 	mov	r0, #0
  }
}
    42ac:	e8bd8070 	pop	{r4, r5, r6, pc}
  rootfs_t rootfs = ns;
  rootfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (rootfs != NULL, DNA_BAD_ARGUMENT);
    42b0:	e59f0018 	ldr	r0, [pc, #24]	; 42d0 <rootfs_get_info+0x84>
    42b4:	e8bd8070 	pop	{r4, r5, r6, pc}

    switch (inode -> class)
    {
      case DNA_ROOTFS_FILE :
        {
          p_info -> type = DNA_FILE_REGULAR;
    42b8:	e3a00000 	mov	r0, #0
    42bc:	e5c40010 	strb	r0, [r4, #16]
          break;
    42c0:	e8bd8070 	pop	{r4, r5, r6, pc}
          break;
        }

      case DNA_ROOTFS_SYMLINK :
        {
          p_info -> type = DNA_FILE_SYMBOLIC_LINK;
    42c4:	e5c41010 	strb	r1, [r4, #16]
          break;
        }
    }

    return DNA_OK;
    42c8:	e3a00000 	mov	r0, #0
        }

      case DNA_ROOTFS_SYMLINK :
        {
          p_info -> type = DNA_FILE_SYMBOLIC_LINK;
          break;
    42cc:	e8bd8070 	pop	{r4, r5, r6, pc}
    42d0:	0000fffc 	.word	0x0000fffc

000042d4 <rootfs_walk>:
  rootfs_entry_t entry = NULL;
  int64_t vnid = -1;

  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    42d4:	e3510000 	cmp	r1, #0
    42d8:	13500000 	cmpne	r0, #0
#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_walk (void * ns, void * base, char * restrict path,
    char ** new_path, int64_t * p_vnid)
{
    42dc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  rootfs_entry_t entry = NULL;
  int64_t vnid = -1;

  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    42e0:	059f007c 	ldreq	r0, [pc, #124]	; 4364 <rootfs_walk+0x90>
#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_walk (void * ns, void * base, char * restrict path,
    char ** new_path, int64_t * p_vnid)
{
    42e4:	e24dd008 	sub	sp, sp, #8
  rootfs_entry_t entry = NULL;
  int64_t vnid = -1;

  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    42e8:	e1a08001 	mov	r8, r1
    42ec:	1a000001 	bne	42f8 <rootfs_walk+0x24>
    vnid = entry -> id;
    *p_vnid = vnid;

    return DNA_OK;
  }
}
    42f0:	e28dd008 	add	sp, sp, #8
    42f4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  int64_t vnid = -1;

  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    ensure (base_inode -> id != rootfs -> root_vnid ||
    42f8:	e1c140d8 	ldrd	r4, [r1, #8]
    42fc:	e1c060d8 	ldrd	r6, [r0, #8]
    4300:	e1550007 	cmp	r5, r7
    4304:	01540006 	cmpeq	r4, r6
    4308:	0a00000c 	beq	4340 <rootfs_walk+0x6c>
        dna_strcmp (path, "..") != 0, DNA_ALREADY_AT_ROOT);

    entry = queue_lookup (& base_inode -> entry_list,
    430c:	e2880f4a 	add	r0, r8, #296	; 0x128
    4310:	e59f1050 	ldr	r1, [pc, #80]	; 4368 <rootfs_walk+0x94>
    4314:	eb002ef5 	bl	fef0 <queue_lookup>
        rootfs_entry_name_inspector, path);
    ensure (entry != NULL, DNA_NO_ENTRY);
    4318:	e3500000 	cmp	r0, #0
    431c:	0a000005 	beq	4338 <rootfs_walk+0x64>

    vnid = entry -> id;
    4320:	e1c020d8 	ldrd	r2, [r0, #8]
    *p_vnid = vnid;

    return DNA_OK;
    4324:	e3a00000 	mov	r0, #0
    entry = queue_lookup (& base_inode -> entry_list,
        rootfs_entry_name_inspector, path);
    ensure (entry != NULL, DNA_NO_ENTRY);

    vnid = entry -> id;
    *p_vnid = vnid;
    4328:	e59d1020 	ldr	r1, [sp, #32]
    432c:	e1c120f0 	strd	r2, [r1]

    return DNA_OK;
  }
}
    4330:	e28dd008 	add	sp, sp, #8
    4334:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    ensure (base_inode -> id != rootfs -> root_vnid ||
        dna_strcmp (path, "..") != 0, DNA_ALREADY_AT_ROOT);

    entry = queue_lookup (& base_inode -> entry_list,
        rootfs_entry_name_inspector, path);
    ensure (entry != NULL, DNA_NO_ENTRY);
    4338:	e59f002c 	ldr	r0, [pc, #44]	; 436c <rootfs_walk+0x98>
    433c:	eaffffeb 	b	42f0 <rootfs_walk+0x1c>
  int64_t vnid = -1;

  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    ensure (base_inode -> id != rootfs -> root_vnid ||
    4340:	e1a00002 	mov	r0, r2
    4344:	e59f1024 	ldr	r1, [pc, #36]	; 4370 <rootfs_walk+0x9c>
    4348:	e58d2004 	str	r2, [sp, #4]
    434c:	eb002edb 	bl	fec0 <dna_strcmp>
    4350:	e3500000 	cmp	r0, #0
    4354:	e59d2004 	ldr	r2, [sp, #4]
    4358:	03a00002 	moveq	r0, #2
    435c:	0affffe3 	beq	42f0 <rootfs_walk+0x1c>
    4360:	eaffffe9 	b	430c <rootfs_walk+0x38>
    4364:	0000ffff 	.word	0x0000ffff
    4368:	000043a8 	.word	0x000043a8
    436c:	0000feff 	.word	0x0000feff
    4370:	00032808 	.word	0x00032808

00004374 <rootfs_inode_inspector>:
#include <DnaTools/DnaTools.h>

bool rootfs_inode_inspector (void * inode, va_list list)
{
  rootfs_inode_t i = inode;
  int64_t id = va_arg (list, int64_t);
    4374:	e2811007 	add	r1, r1, #7
    4378:	e3c11007 	bic	r1, r1, #7

  watch (bool)
  {
    ensure (i != NULL, false);
    437c:	e3500000 	cmp	r0, #0
#include <DnaTools/DnaTools.h>

bool rootfs_inode_inspector (void * inode, va_list list)
{
  rootfs_inode_t i = inode;
  int64_t id = va_arg (list, int64_t);
    4380:	e1c120d0 	ldrd	r2, [r1]

  watch (bool)
  {
    ensure (i != NULL, false);
    4384:	012fff1e 	bxeq	lr
    return i -> id == id;
    4388:	e1c000d8 	ldrd	r0, [r0, #8]
    438c:	e1510003 	cmp	r1, r3
    4390:	01500002 	cmpeq	r0, r2
    4394:	03a00001 	moveq	r0, #1
    4398:	13a00000 	movne	r0, #0
  }
}
    439c:	e12fff1e 	bx	lr

000043a0 <rootfs_free>:

status_t rootfs_free (void * ns, void * node, void * data)
{

  return DNA_OK;
}
    43a0:	e3a00000 	mov	r0, #0
    43a4:	e12fff1e 	bx	lr

000043a8 <rootfs_entry_name_inspector>:
  rootfs_entry_t e = entry;
  char * name = va_arg (list, char *);

  watch (bool)
  {
    ensure (e != NULL, false);
    43a8:	e3500000 	cmp	r0, #0
#include <DnaTools/DnaTools.h>

bool rootfs_entry_name_inspector (void * entry, va_list list)
{
  rootfs_entry_t e = entry;
  char * name = va_arg (list, char *);
    43ac:	e5911000 	ldr	r1, [r1]

  watch (bool)
  {
    ensure (e != NULL, false);
    43b0:	012fff1e 	bxeq	lr
    ensure (name != NULL, false);
    43b4:	e3510000 	cmp	r1, #0
    43b8:	0a000005 	beq	43d4 <rootfs_entry_name_inspector+0x2c>

#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

bool rootfs_entry_name_inspector (void * entry, va_list list)
{
    43bc:	e92d4008 	push	{r3, lr}
  watch (bool)
  {
    ensure (e != NULL, false);
    ensure (name != NULL, false);

    return dna_strcmp (e -> name, name) == 0;
    43c0:	e2800010 	add	r0, r0, #16
    43c4:	eb002ebd 	bl	fec0 <dna_strcmp>
    43c8:	e16f0f10 	clz	r0, r0
    43cc:	e1a002a0 	lsr	r0, r0, #5
    43d0:	e8bd8008 	pop	{r3, pc}
  rootfs_entry_t e = entry;
  char * name = va_arg (list, char *);

  watch (bool)
  {
    ensure (e != NULL, false);
    43d4:	e1a00001 	mov	r0, r1
    43d8:	e12fff1e 	bx	lr

000043dc <rootfs_read>:
status_t rootfs_read (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
  status_t status = DNA_OK;

  * p_count = 0;
    43dc:	e3a03000 	mov	r3, #0
#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_read (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
    43e0:	e59d2008 	ldr	r2, [sp, #8]
  status_t status = DNA_OK;

  * p_count = 0;
  return status;
}
    43e4:	e1a00003 	mov	r0, r3
status_t rootfs_read (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
  status_t status = DNA_OK;

  * p_count = 0;
    43e8:	e5823000 	str	r3, [r2]
  return status;
}
    43ec:	e12fff1e 	bx	lr

000043f0 <rootfs_close>:

status_t rootfs_close (void * ns, void * node, void * data)
{

  return DNA_OK;
}
    43f0:	e3a00000 	mov	r0, #0
    43f4:	e12fff1e 	bx	lr

000043f8 <rootfs_create>:
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_create (void * ns, void * node, char * restrict path,
    int32_t mode, int32_t perms, int64_t * vnid, void ** data)
{
    43f8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    43fc:	e24dd014 	sub	sp, sp, #20
    4400:	e1a08003 	mov	r8, r3
    4404:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
    4408:	e58d1004 	str	r1, [sp, #4]
    440c:	e58d3008 	str	r3, [sp, #8]
    4410:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
    4414:	e1a06000 	mov	r6, r0
  rootfs_t rootfs = ns;
  rootfs_inode_t root_inode = node, inode = NULL;
  rootfs_entry_t entry = NULL;

  inode = kernel_malloc (sizeof (struct rootfs_inode), true);
    4418:	e3a01001 	mov	r1, #1
    441c:	e3a00f4e 	mov	r0, #312	; 0x138
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_create (void * ns, void * node, char * restrict path,
    int32_t mode, int32_t perms, int64_t * vnid, void ** data)
{
    4420:	e1a07002 	mov	r7, r2
    4424:	e59d9038 	ldr	r9, [sp, #56]	; 0x38
    4428:	e58d300c 	str	r3, [sp, #12]
  rootfs_t rootfs = ns;
  rootfs_inode_t root_inode = node, inode = NULL;
  rootfs_entry_t entry = NULL;

  inode = kernel_malloc (sizeof (struct rootfs_inode), true);
    442c:	eb003f17 	bl	14090 <kernel_malloc>
  if (inode == NULL) return DNA_OUT_OF_MEM;
    4430:	e250b000 	subs	fp, r0, #0
    4434:	0a00002a 	beq	44e4 <rootfs_create+0xec>
  inode -> id = rootfs -> inode_index ++;
    4438:	e1c640d0 	ldrd	r4, [r6]
    443c:	e1a0c006 	mov	ip, r6
  dna_strcpy (inode -> name, path);
  inode -> class = DNA_ROOTFS_FILE;
    4440:	e3a0a000 	mov	sl, #0
  rootfs_inode_t root_inode = node, inode = NULL;
  rootfs_entry_t entry = NULL;

  inode = kernel_malloc (sizeof (struct rootfs_inode), true);
  if (inode == NULL) return DNA_OUT_OF_MEM;
  inode -> id = rootfs -> inode_index ++;
    4444:	e2942001 	adds	r2, r4, #1
    4448:	e2a53000 	adc	r3, r5, #0
    444c:	e0cc21f4 	strd	r2, [ip], #20
  dna_strcpy (inode -> name, path);
    4450:	e1a01007 	mov	r1, r7
  rootfs_inode_t root_inode = node, inode = NULL;
  rootfs_entry_t entry = NULL;

  inode = kernel_malloc (sizeof (struct rootfs_inode), true);
  if (inode == NULL) return DNA_OUT_OF_MEM;
  inode -> id = rootfs -> inode_index ++;
    4454:	e1cb40f8 	strd	r4, [fp, #8]
  dna_strcpy (inode -> name, path);
    4458:	e28b0010 	add	r0, fp, #16
    445c:	e58dc000 	str	ip, [sp]
    4460:	eb002f04 	bl	10078 <dna_strcpy>
  inode -> class = DNA_ROOTFS_FILE;
  inode -> perms = perms;
  inode -> mode = mode;
  queue_add (& rootfs -> inode_list, inode);
    4464:	e59dc000 	ldr	ip, [sp]
    4468:	e1a0100b 	mov	r1, fp
    446c:	e1a0000c 	mov	r0, ip
  inode = kernel_malloc (sizeof (struct rootfs_inode), true);
  if (inode == NULL) return DNA_OUT_OF_MEM;
  inode -> id = rootfs -> inode_index ++;
  dna_strcpy (inode -> name, path);
  inode -> class = DNA_ROOTFS_FILE;
  inode -> perms = perms;
    4470:	e58b9124 	str	r9, [fp, #292]	; 0x124
  inode -> mode = mode;
    4474:	e58b8120 	str	r8, [fp, #288]	; 0x120

  inode = kernel_malloc (sizeof (struct rootfs_inode), true);
  if (inode == NULL) return DNA_OUT_OF_MEM;
  inode -> id = rootfs -> inode_index ++;
  dna_strcpy (inode -> name, path);
  inode -> class = DNA_ROOTFS_FILE;
    4478:	e5cba110 	strb	sl, [fp, #272]	; 0x110
  inode -> perms = perms;
  inode -> mode = mode;
  queue_add (& rootfs -> inode_list, inode);
    447c:	eb002e64 	bl	fe14 <queue_add>

  /*
   * Add the new directory as an entry to its parent
   */

  entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    4480:	e3a00e11 	mov	r0, #272	; 0x110
    4484:	e3a01001 	mov	r1, #1
    4488:	eb003f00 	bl	14090 <kernel_malloc>
  if (entry == NULL) return DNA_OUT_OF_MEM;
    448c:	e2504000 	subs	r4, r0, #0
    4490:	0a000013 	beq	44e4 <rootfs_create+0xec>
  entry -> id = inode -> id;
    4494:	e1cb20d8 	ldrd	r2, [fp, #8]
  dna_strcpy (entry -> name, path);
    4498:	e1a01007 	mov	r1, r7
   * Add the new directory as an entry to its parent
   */

  entry = kernel_malloc (sizeof (struct rootfs_entry), true);
  if (entry == NULL) return DNA_OUT_OF_MEM;
  entry -> id = inode -> id;
    449c:	e1c420f8 	strd	r2, [r4, #8]
  dna_strcpy (entry -> name, path);
    44a0:	e2840010 	add	r0, r4, #16
    44a4:	eb002ef3 	bl	10078 <dna_strcpy>
  queue_add (& root_inode -> entry_list, entry);
    44a8:	e59d1004 	ldr	r1, [sp, #4]
    44ac:	e2810f4a 	add	r0, r1, #296	; 0x128
    44b0:	e1a01004 	mov	r1, r4
    44b4:	eb002e56 	bl	fe14 <queue_add>

  /*
   * Add the root vnode to the system
   */

  *vnid = inode -> id;
    44b8:	e1cb20d8 	ldrd	r2, [fp, #8]
    44bc:	e59d1008 	ldr	r1, [sp, #8]
    44c0:	e1c120f0 	strd	r2, [r1]
  *data = NULL;

  return vnode_create (inode -> id, rootfs -> vid, (void *) inode);
    44c4:	e1cb00d8 	ldrd	r0, [fp, #8]
  /*
   * Add the root vnode to the system
   */

  *vnid = inode -> id;
  *data = NULL;
    44c8:	e59d300c 	ldr	r3, [sp, #12]

  return vnode_create (inode -> id, rootfs -> vid, (void *) inode);
    44cc:	e5962010 	ldr	r2, [r6, #16]
  /*
   * Add the root vnode to the system
   */

  *vnid = inode -> id;
  *data = NULL;
    44d0:	e583a000 	str	sl, [r3]

  return vnode_create (inode -> id, rootfs -> vid, (void *) inode);
    44d4:	e1a0300b 	mov	r3, fp
}
    44d8:	e28dd014 	add	sp, sp, #20
    44dc:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   */

  *vnid = inode -> id;
  *data = NULL;

  return vnode_create (inode -> id, rootfs -> vid, (void *) inode);
    44e0:	ea0024f7 	b	d8c4 <vnode_create>
}
    44e4:	e59f0004 	ldr	r0, [pc, #4]	; 44f0 <rootfs_create+0xf8>
    44e8:	e28dd014 	add	sp, sp, #20
    44ec:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    44f0:	0000fffd 	.word	0x0000fffd

000044f4 <rootfs_open>:
#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_open (void * ns, void * node, int32_t mode, void ** data)
{
  *data = NULL;
    44f4:	e3a00000 	mov	r0, #0
    44f8:	e5830000 	str	r0, [r3]
  return DNA_OK;
}
    44fc:	e12fff1e 	bx	lr

00004500 <rootfs_write_vnode>:

status_t rootfs_write_vnode (void * ns, void * node)
{

  return DNA_OK;
}
    4500:	e3a00000 	mov	r0, #0
    4504:	e12fff1e 	bx	lr

00004508 <rootfs_destroy_vnode>:

status_t rootfs_destroy_vnode (void * ns, void * node)
{

  return DNA_OK;
}
    4508:	e3a00000 	mov	r0, #0
    450c:	e12fff1e 	bx	lr

00004510 <rootfs_mkdir>:
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_mkdir (void * ns, void * node,
    char * restrict name, int32_t mode)
{
    4510:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  rootfs_entry_t dot_entry = NULL, dotdot_entry = NULL, root_entry = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (ns != NULL, DNA_ERROR);
    4514:	e2507000 	subs	r7, r0, #0
    4518:	0a000044 	beq	4630 <rootfs_mkdir+0x120>
    ensure (node != NULL, DNA_ERROR);
    451c:	e3510000 	cmp	r1, #0
    4520:	e1a06001 	mov	r6, r1
    4524:	0a000041 	beq	4630 <rootfs_mkdir+0x120>
    ensure (name != NULL, DNA_ERROR);
    4528:	e3520000 	cmp	r2, #0
    452c:	e1a08002 	mov	r8, r2
    4530:	0a00003e 	beq	4630 <rootfs_mkdir+0x120>

    inode = kernel_malloc (sizeof (struct rootfs_inode), true);
    4534:	e3a00f4e 	mov	r0, #312	; 0x138
    4538:	e3a01001 	mov	r1, #1
    453c:	e1a09003 	mov	r9, r3
    4540:	eb003ed2 	bl	14090 <kernel_malloc>
    ensure (inode != NULL, DNA_OUT_OF_MEM);
    4544:	e250a000 	subs	sl, r0, #0
    4548:	0a00003a 	beq	4638 <rootfs_mkdir+0x128>

    inode -> id = rootfs -> inode_index ++;
    454c:	e1c740d0 	ldrd	r4, [r7]
    4550:	e1a0b007 	mov	fp, r7
    dna_strcpy (inode -> name, name);
    inode -> class = DNA_ROOTFS_DIRECTORY;
    4554:	e3a07001 	mov	r7, #1
    ensure (name != NULL, DNA_ERROR);

    inode = kernel_malloc (sizeof (struct rootfs_inode), true);
    ensure (inode != NULL, DNA_OUT_OF_MEM);

    inode -> id = rootfs -> inode_index ++;
    4558:	e2942001 	adds	r2, r4, #1
    455c:	e2a53000 	adc	r3, r5, #0
    4560:	e0cb21f4 	strd	r2, [fp], #20
    dna_strcpy (inode -> name, name);
    4564:	e1a01008 	mov	r1, r8
    4568:	e28a0010 	add	r0, sl, #16
    ensure (name != NULL, DNA_ERROR);

    inode = kernel_malloc (sizeof (struct rootfs_inode), true);
    ensure (inode != NULL, DNA_OUT_OF_MEM);

    inode -> id = rootfs -> inode_index ++;
    456c:	e1ca40f8 	strd	r4, [sl, #8]
    dna_strcpy (inode -> name, name);
    4570:	eb002ec0 	bl	10078 <dna_strcpy>
    inode -> class = DNA_ROOTFS_DIRECTORY;
    inode -> mode = mode;
    4574:	e58a9120 	str	r9, [sl, #288]	; 0x120
    queue_add (& rootfs -> inode_list, inode);
    4578:	e1a0100a 	mov	r1, sl
    457c:	e1a0000b 	mov	r0, fp
    inode = kernel_malloc (sizeof (struct rootfs_inode), true);
    ensure (inode != NULL, DNA_OUT_OF_MEM);

    inode -> id = rootfs -> inode_index ++;
    dna_strcpy (inode -> name, name);
    inode -> class = DNA_ROOTFS_DIRECTORY;
    4580:	e5ca7110 	strb	r7, [sl, #272]	; 0x110
    inode -> mode = mode;
    queue_add (& rootfs -> inode_list, inode);
    4584:	eb002e22 	bl	fe14 <queue_add>

    /*
     * Add the "." entry
     */

    dot_entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    4588:	e1a01007 	mov	r1, r7
    458c:	e3a00e11 	mov	r0, #272	; 0x110
    4590:	eb003ebe 	bl	14090 <kernel_malloc>
    check (invalid_dot_entry, dot_entry != NULL, DNA_OUT_OF_MEM);
    4594:	e2509000 	subs	r9, r0, #0
    4598:	0a00002c 	beq	4650 <rootfs_mkdir+0x140>

    dot_entry -> id = inode -> id;
    459c:	e1ca40d8 	ldrd	r4, [sl, #8]
    dna_strcpy (dot_entry -> name, ".");
    45a0:	e59f10b8 	ldr	r1, [pc, #184]	; 4660 <rootfs_mkdir+0x150>
     */

    dot_entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    check (invalid_dot_entry, dot_entry != NULL, DNA_OUT_OF_MEM);

    dot_entry -> id = inode -> id;
    45a4:	e1c940f8 	strd	r4, [r9, #8]
    dna_strcpy (dot_entry -> name, ".");
    45a8:	e2890010 	add	r0, r9, #16
    queue_add (& inode -> entry_list, dot_entry);
    45ac:	e28abf4a 	add	fp, sl, #296	; 0x128

    dot_entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    check (invalid_dot_entry, dot_entry != NULL, DNA_OUT_OF_MEM);

    dot_entry -> id = inode -> id;
    dna_strcpy (dot_entry -> name, ".");
    45b0:	eb002eb0 	bl	10078 <dna_strcpy>
    queue_add (& inode -> entry_list, dot_entry);
    45b4:	e1a01009 	mov	r1, r9
    45b8:	e1a0000b 	mov	r0, fp
    45bc:	eb002e14 	bl	fe14 <queue_add>

    /*
     * Add the ".." entry
     */

    dotdot_entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    45c0:	e3a00e11 	mov	r0, #272	; 0x110
    45c4:	e1a01007 	mov	r1, r7
    45c8:	eb003eb0 	bl	14090 <kernel_malloc>
    check (invalid_dotdot_entry, dotdot_entry != NULL, DNA_OUT_OF_MEM);
    45cc:	e2505000 	subs	r5, r0, #0
    45d0:	0a00001c 	beq	4648 <rootfs_mkdir+0x138>

    dotdot_entry -> id = root_inode -> id;
    45d4:	e1c620d8 	ldrd	r2, [r6, #8]
    dna_strcpy (dotdot_entry -> name, "..");
    45d8:	e59f1084 	ldr	r1, [pc, #132]	; 4664 <rootfs_mkdir+0x154>
     */

    dotdot_entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    check (invalid_dotdot_entry, dotdot_entry != NULL, DNA_OUT_OF_MEM);

    dotdot_entry -> id = root_inode -> id;
    45dc:	e1c520f8 	strd	r2, [r5, #8]
    dna_strcpy (dotdot_entry -> name, "..");
    45e0:	e2850010 	add	r0, r5, #16
    45e4:	eb002ea3 	bl	10078 <dna_strcpy>
    queue_add (& inode -> entry_list, dotdot_entry);
    45e8:	e1a01005 	mov	r1, r5
    45ec:	e1a0000b 	mov	r0, fp
    45f0:	eb002e07 	bl	fe14 <queue_add>

    /*
     * Add the new directory as an entry to its parent
     */

    root_entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    45f4:	e1a01007 	mov	r1, r7
    45f8:	e3a00e11 	mov	r0, #272	; 0x110
    45fc:	eb003ea3 	bl	14090 <kernel_malloc>
    check (invalid_root_entry, root_entry != NULL, DNA_OUT_OF_MEM);
    4600:	e2504000 	subs	r4, r0, #0
    4604:	0a00000d 	beq	4640 <rootfs_mkdir+0x130>

    root_entry -> id = inode -> id;
    4608:	e1ca20d8 	ldrd	r2, [sl, #8]
    dna_strcpy (root_entry -> name, name);
    460c:	e1a01008 	mov	r1, r8
     */

    root_entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    check (invalid_root_entry, root_entry != NULL, DNA_OUT_OF_MEM);

    root_entry -> id = inode -> id;
    4610:	e1c420f8 	strd	r2, [r4, #8]
    dna_strcpy (root_entry -> name, name);
    4614:	e2840010 	add	r0, r4, #16
    4618:	eb002e96 	bl	10078 <dna_strcpy>
    queue_add (& root_inode -> entry_list, root_entry);
    461c:	e2860f4a 	add	r0, r6, #296	; 0x128
    4620:	e1a01004 	mov	r1, r4
    4624:	eb002dfa 	bl	fe14 <queue_add>

    return status;
    4628:	e3a00000 	mov	r0, #0
    462c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  rootfs_entry_t dot_entry = NULL, dotdot_entry = NULL, root_entry = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (ns != NULL, DNA_ERROR);
    4630:	e59f0030 	ldr	r0, [pc, #48]	; 4668 <rootfs_mkdir+0x158>
    4634:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ensure (node != NULL, DNA_ERROR);
    ensure (name != NULL, DNA_ERROR);

    inode = kernel_malloc (sizeof (struct rootfs_inode), true);
    ensure (inode != NULL, DNA_OUT_OF_MEM);
    4638:	e59f002c 	ldr	r0, [pc, #44]	; 466c <rootfs_mkdir+0x15c>
  rescue (invalid_dot_entry)
  {
    kernel_free (inode);
    leave;
  }
}
    463c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return status;
  }

  rescue (invalid_root_entry)
  {
    kernel_free (dotdot_entry);
    4640:	e1a00005 	mov	r0, r5
    4644:	eb003ec6 	bl	14164 <kernel_free>
  }

  rescue (invalid_dotdot_entry)
  {
    kernel_free (dot_entry);
    4648:	e1a00009 	mov	r0, r9
    464c:	eb003ec4 	bl	14164 <kernel_free>
  }

  rescue (invalid_dot_entry)
  {
    kernel_free (inode);
    4650:	e1a0000a 	mov	r0, sl
    4654:	eb003ec2 	bl	14164 <kernel_free>
    leave;
    4658:	e59f000c 	ldr	r0, [pc, #12]	; 466c <rootfs_mkdir+0x15c>
    465c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4660:	00032c70 	.word	0x00032c70
    4664:	00032808 	.word	0x00032808
    4668:	0000ffff 	.word	0x0000ffff
    466c:	0000fffd 	.word	0x0000fffd

00004670 <rootfs_set_info>:
status_t rootfs_set_info (void * ns, void * node, void * data,
    file_info_t info, int32_t mask)
{

  return DNA_OK;
}
    4670:	e3a00000 	mov	r0, #0
    4674:	e12fff1e 	bx	lr

00004678 <CSHIFT>:
     this routine. If they are greater than the cutoff radius, compute
     these distances as if one of the particles were at its mirror image
     (periodic boundary conditions).
     Used by the intermolecular interactions routines */
void CSHIFT(double *XA, double *XB, double XMA, double XMB, double *XL, double BOXH, double BOXL)
{
    4678:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    467c:	e1a09003 	mov	r9, r3
    4680:	e1a08002 	mov	r8, r2
    4684:	e24dd014 	sub	sp, sp, #20
    4688:	e1a04001 	mov	r4, r1
    468c:	e1cda3d8 	ldrd	sl, [sp, #56]	; 0x38
    4690:	e1a05000 	mov	r5, r0
    long I;

    /* Compute some intermolecular distances */

    XL[0] = XMA-XMB;
    4694:	e1a0200a 	mov	r2, sl
    4698:	e1a0300b 	mov	r3, fp
    469c:	e1a01009 	mov	r1, r9
    46a0:	e1a00008 	mov	r0, r8
    46a4:	eb004010 	bl	146ec <__aeabi_dsub>
     this routine. If they are greater than the cutoff radius, compute
     these distances as if one of the particles were at its mirror image
     (periodic boundary conditions).
     Used by the intermolecular interactions routines */
void CSHIFT(double *XA, double *XB, double XMA, double XMB, double *XL, double BOXH, double BOXL)
{
    46a8:	e59d6040 	ldr	r6, [sp, #64]	; 0x40
    46ac:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
    long I;

    /* Compute some intermolecular distances */

    XL[0] = XMA-XMB;
    46b0:	e1c600f0 	strd	r0, [r6]
     this routine. If they are greater than the cutoff radius, compute
     these distances as if one of the particles were at its mirror image
     (periodic boundary conditions).
     Used by the intermolecular interactions routines */
void CSHIFT(double *XA, double *XB, double XMA, double XMB, double *XL, double BOXH, double BOXL)
{
    46b4:	e58d2004 	str	r2, [sp, #4]
    long I;

    /* Compute some intermolecular distances */

    XL[0] = XMA-XMB;
    XL[1] = XMA-XB[0];
    46b8:	e1a01009 	mov	r1, r9
    46bc:	e1c420d0 	ldrd	r2, [r4]
    46c0:	e1a00008 	mov	r0, r8
    46c4:	eb004008 	bl	146ec <__aeabi_dsub>
    46c8:	e1c600f8 	strd	r0, [r6, #8]
    XL[2] = XMA-XB[2];
    46cc:	e1a01009 	mov	r1, r9
    46d0:	e1c421d0 	ldrd	r2, [r4, #16]
    46d4:	e1a00008 	mov	r0, r8
    46d8:	eb004003 	bl	146ec <__aeabi_dsub>
    46dc:	e1c601f0 	strd	r0, [r6, #16]
    XL[3] = XA[0]-XMB;
    46e0:	e1a0200a 	mov	r2, sl
    46e4:	e1c500d0 	ldrd	r0, [r5]
    46e8:	e1a0300b 	mov	r3, fp
    46ec:	eb003ffe 	bl	146ec <__aeabi_dsub>
    46f0:	e1c601f8 	strd	r0, [r6, #24]
    XL[4] = XA[2]-XMB;
    46f4:	e1a0200a 	mov	r2, sl
    46f8:	e1c501d0 	ldrd	r0, [r5, #16]
    46fc:	e1a0300b 	mov	r3, fp
    4700:	eb003ff9 	bl	146ec <__aeabi_dsub>
    4704:	e1c602f0 	strd	r0, [r6, #32]
    XL[5] = XA[0]-XB[0];
    4708:	e1c420d0 	ldrd	r2, [r4]
    470c:	e1c500d0 	ldrd	r0, [r5]
    4710:	eb003ff5 	bl	146ec <__aeabi_dsub>
    4714:	e1c602f8 	strd	r0, [r6, #40]	; 0x28
    XL[6] = XA[0]-XB[2];
    4718:	e1c421d0 	ldrd	r2, [r4, #16]
    471c:	e1c500d0 	ldrd	r0, [r5]
    4720:	eb003ff1 	bl	146ec <__aeabi_dsub>
    4724:	e1c603f0 	strd	r0, [r6, #48]	; 0x30
    XL[7] = XA[2]-XB[0];
    4728:	e1c420d0 	ldrd	r2, [r4]
    472c:	e1c501d0 	ldrd	r0, [r5, #16]
    4730:	eb003fed 	bl	146ec <__aeabi_dsub>
    4734:	e1c603f8 	strd	r0, [r6, #56]	; 0x38
    XL[8] = XA[2]-XB[2];
    4738:	e1c421d0 	ldrd	r2, [r4, #16]
    473c:	e1c501d0 	ldrd	r0, [r5, #16]
    4740:	eb003fe9 	bl	146ec <__aeabi_dsub>
    4744:	e1c604f0 	strd	r0, [r6, #64]	; 0x40
    XL[9] = XA[1]-XB[1];
    4748:	e1c420d8 	ldrd	r2, [r4, #8]
    474c:	e1c500d8 	ldrd	r0, [r5, #8]
    4750:	eb003fe5 	bl	146ec <__aeabi_dsub>
    4754:	e1c604f8 	strd	r0, [r6, #72]	; 0x48
    XL[10] = XA[1]-XB[0];
    4758:	e1c420d0 	ldrd	r2, [r4]
    475c:	e1c500d8 	ldrd	r0, [r5, #8]
    4760:	eb003fe1 	bl	146ec <__aeabi_dsub>
    4764:	e1c605f0 	strd	r0, [r6, #80]	; 0x50
     this routine. If they are greater than the cutoff radius, compute
     these distances as if one of the particles were at its mirror image
     (periodic boundary conditions).
     Used by the intermolecular interactions routines */
void CSHIFT(double *XA, double *XB, double XMA, double XMB, double *XL, double BOXH, double BOXL)
{
    4768:	e59d9054 	ldr	r9, [sp, #84]	; 0x54
    XL[6] = XA[0]-XB[2];
    XL[7] = XA[2]-XB[0];
    XL[8] = XA[2]-XB[2];
    XL[9] = XA[1]-XB[1];
    XL[10] = XA[1]-XB[0];
    XL[11] = XA[1]-XB[2];
    476c:	e1c500d8 	ldrd	r0, [r5, #8]
    4770:	e1c421d0 	ldrd	r2, [r4, #16]
    4774:	eb003fdc 	bl	146ec <__aeabi_dsub>
    4778:	e1c605f8 	strd	r0, [r6, #88]	; 0x58
    XL[12] = XA[0]-XB[1];
    477c:	e1c420d8 	ldrd	r2, [r4, #8]
    4780:	e1c500d0 	ldrd	r0, [r5]
    4784:	eb003fd8 	bl	146ec <__aeabi_dsub>
    4788:	e1c606f0 	strd	r0, [r6, #96]	; 0x60
    XL[13] = XA[2]-XB[1];
    478c:	e1c420d8 	ldrd	r2, [r4, #8]
    4790:	e1c501d0 	ldrd	r0, [r5, #16]
    4794:	eb003fd4 	bl	146ec <__aeabi_dsub>
    4798:	e59d4004 	ldr	r4, [sp, #4]
    479c:	e1c606f8 	strd	r0, [r6, #104]	; 0x68
    47a0:	e3a02000 	mov	r2, #0
    47a4:	e3a03000 	mov	r3, #0
    47a8:	e1a00004 	mov	r0, r4
    47ac:	e1a01009 	mov	r1, r9
    47b0:	eb004232 	bl	15080 <__aeabi_dcmplt>
    47b4:	e3500000 	cmp	r0, #0

    /* go through all 14 distances computed */
    for (I = 0; I <  14; I++) {
        /* if the value is greater than the cutoff radius */
        if (fabs(XL[I]) > BOXH) {
            XL[I]  =  XL[I] -(sign(BOXL,XL[I]));
    47b8:	e289b102 	add	fp, r9, #-2147483648	; 0x80000000
    47bc:	1286a070 	addne	sl, r6, #112	; 0x70
    47c0:	1a000020 	bne	4848 <CSHIFT+0x1d0>
    47c4:	e2868070 	add	r8, r6, #112	; 0x70
    47c8:	e58d9008 	str	r9, [sp, #8]
    47cc:	e58db00c 	str	fp, [sp, #12]
    47d0:	e1cda4d8 	ldrd	sl, [sp, #72]	; 0x48
    XL[13] = XA[2]-XB[1];

    /* go through all 14 distances computed */
    for (I = 0; I <  14; I++) {
        /* if the value is greater than the cutoff radius */
        if (fabs(XL[I]) > BOXH) {
    47d4:	e5969000 	ldr	r9, [r6]
    47d8:	e5967004 	ldr	r7, [r6, #4]
    47dc:	e1a02009 	mov	r2, r9
    47e0:	e1a0000a 	mov	r0, sl
    47e4:	e1a0100b 	mov	r1, fp
    47e8:	e3c73102 	bic	r3, r7, #-2147483648	; 0x80000000
    47ec:	eb004223 	bl	15080 <__aeabi_dcmplt>
    47f0:	e3500000 	cmp	r0, #0
    47f4:	e2866008 	add	r6, r6, #8
    47f8:	0a00000e 	beq	4838 <CSHIFT+0x1c0>
            XL[I]  =  XL[I] -(sign(BOXL,XL[I]));
    47fc:	e3a02000 	mov	r2, #0
    4800:	e3a03000 	mov	r3, #0
    4804:	e1a01007 	mov	r1, r7
    4808:	e1a00009 	mov	r0, r9
    480c:	eb00421b 	bl	15080 <__aeabi_dcmplt>
    4810:	e3500000 	cmp	r0, #0
    4814:	e59d0008 	ldr	r0, [sp, #8]
    4818:	e59d100c 	ldr	r1, [sp, #12]
    481c:	01a01000 	moveq	r1, r0
    4820:	e59d2004 	ldr	r2, [sp, #4]
    4824:	e1a03001 	mov	r3, r1
    4828:	e1a00009 	mov	r0, r9
    482c:	e1a01007 	mov	r1, r7
    4830:	eb003fad 	bl	146ec <__aeabi_dsub>
    4834:	e14600f8 	strd	r0, [r6, #-8]
    XL[11] = XA[1]-XB[2];
    XL[12] = XA[0]-XB[1];
    XL[13] = XA[2]-XB[1];

    /* go through all 14 distances computed */
    for (I = 0; I <  14; I++) {
    4838:	e1560008 	cmp	r6, r8
    483c:	1affffe4 	bne	47d4 <CSHIFT+0x15c>
        if (fabs(XL[I]) > BOXH) {
            XL[I]  =  XL[I] -(sign(BOXL,XL[I]));
        }
    } /* for */

} /* end of subroutine CSHIFT */
    4840:	e28dd014 	add	sp, sp, #20
    4844:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    XL[13] = XA[2]-XB[1];

    /* go through all 14 distances computed */
    for (I = 0; I <  14; I++) {
        /* if the value is greater than the cutoff radius */
        if (fabs(XL[I]) > BOXH) {
    4848:	e5968000 	ldr	r8, [r6]
    484c:	e5967004 	ldr	r7, [r6, #4]
    4850:	e1a00008 	mov	r0, r8
    4854:	e1cd24d8 	ldrd	r2, [sp, #72]	; 0x48
    4858:	e3c71102 	bic	r1, r7, #-2147483648	; 0x80000000
    485c:	eb004219 	bl	150c8 <__aeabi_dcmpgt>
    4860:	e3500000 	cmp	r0, #0
    4864:	e2866008 	add	r6, r6, #8
    4868:	0a00000d 	beq	48a4 <CSHIFT+0x22c>
            XL[I]  =  XL[I] -(sign(BOXL,XL[I]));
    486c:	e1a01007 	mov	r1, r7
    4870:	e3a02000 	mov	r2, #0
    4874:	e3a03000 	mov	r3, #0
    4878:	e1a00008 	mov	r0, r8
    487c:	eb0041ff 	bl	15080 <__aeabi_dcmplt>
    4880:	e3500000 	cmp	r0, #0
    4884:	11a01009 	movne	r1, r9
    4888:	01a0100b 	moveq	r1, fp
    488c:	e59d2004 	ldr	r2, [sp, #4]
    4890:	e1a03001 	mov	r3, r1
    4894:	e1a00008 	mov	r0, r8
    4898:	e1a01007 	mov	r1, r7
    489c:	eb003f92 	bl	146ec <__aeabi_dsub>
    48a0:	e14600f8 	strd	r0, [r6, #-8]
    XL[11] = XA[1]-XB[2];
    XL[12] = XA[0]-XB[1];
    XL[13] = XA[2]-XB[1];

    /* go through all 14 distances computed */
    for (I = 0; I <  14; I++) {
    48a4:	e156000a 	cmp	r6, sl
    48a8:	1affffe6 	bne	4848 <CSHIFT+0x1d0>
        if (fabs(XL[I]) > BOXH) {
            XL[I]  =  XL[I] -(sign(BOXL,XL[I]));
        }
    } /* for */

} /* end of subroutine CSHIFT */
    48ac:	e28dd014 	add	sp, sp, #20
    48b0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

000048b4 <MDMAIN>:
#include "global.h"

/************************************************************************/

double MDMAIN(long NSTEP, long NPRINT, long NSAVE, long NORD1, long ProcID)
{
    48b4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    long i,j,k;
    double POTA,POTR,POTRF;
    double XVIR,AVGT,TEN;
    struct list_of_boxes *new_box, *curr_box;

    for (i=start_end[ProcID]->box[XDIR][FIRST]; i<=start_end[ProcID]->box[XDIR][LAST]; i++) {
    48b8:	e59f9be8 	ldr	r9, [pc, #3048]	; 54a8 <MDMAIN+0xbf4>
#include "global.h"

/************************************************************************/

double MDMAIN(long NSTEP, long NPRINT, long NSAVE, long NORD1, long ProcID)
{
    48bc:	e24dd0a4 	sub	sp, sp, #164	; 0xa4
    long i,j,k;
    double POTA,POTR,POTRF;
    double XVIR,AVGT,TEN;
    struct list_of_boxes *new_box, *curr_box;

    for (i=start_end[ProcID]->box[XDIR][FIRST]; i<=start_end[ProcID]->box[XDIR][LAST]; i++) {
    48c0:	e59da0c8 	ldr	sl, [sp, #200]	; 0xc8
    48c4:	e5995000 	ldr	r5, [r9]
#include "global.h"

/************************************************************************/

double MDMAIN(long NSTEP, long NPRINT, long NSAVE, long NORD1, long ProcID)
{
    48c8:	e58d007c 	str	r0, [sp, #124]	; 0x7c
    long i,j,k;
    double POTA,POTR,POTRF;
    double XVIR,AVGT,TEN;
    struct list_of_boxes *new_box, *curr_box;

    for (i=start_end[ProcID]->box[XDIR][FIRST]; i<=start_end[ProcID]->box[XDIR][LAST]; i++) {
    48cc:	e795010a 	ldr	r0, [r5, sl, lsl #2]
#include "global.h"

/************************************************************************/

double MDMAIN(long NSTEP, long NPRINT, long NSAVE, long NORD1, long ProcID)
{
    48d0:	e58d1088 	str	r1, [sp, #136]	; 0x88
    long i,j,k;
    double POTA,POTR,POTRF;
    double XVIR,AVGT,TEN;
    struct list_of_boxes *new_box, *curr_box;

    for (i=start_end[ProcID]->box[XDIR][FIRST]; i<=start_end[ProcID]->box[XDIR][LAST]; i++) {
    48d4:	e5906000 	ldr	r6, [r0]
    48d8:	e5901004 	ldr	r1, [r0, #4]
#include "global.h"

/************************************************************************/

double MDMAIN(long NSTEP, long NPRINT, long NSAVE, long NORD1, long ProcID)
{
    48dc:	e58d208c 	str	r2, [sp, #140]	; 0x8c
    long i,j,k;
    double POTA,POTR,POTRF;
    double XVIR,AVGT,TEN;
    struct list_of_boxes *new_box, *curr_box;

    for (i=start_end[ProcID]->box[XDIR][FIRST]; i<=start_end[ProcID]->box[XDIR][LAST]; i++) {
    48e0:	e1560001 	cmp	r6, r1
#include "global.h"

/************************************************************************/

double MDMAIN(long NSTEP, long NPRINT, long NSAVE, long NORD1, long ProcID)
{
    48e4:	e58d304c 	str	r3, [sp, #76]	; 0x4c
    long i,j,k;
    double POTA,POTR,POTRF;
    double XVIR,AVGT,TEN;
    struct list_of_boxes *new_box, *curr_box;

    for (i=start_end[ProcID]->box[XDIR][FIRST]; i<=start_end[ProcID]->box[XDIR][LAST]; i++) {
    48e8:	e1a0b10a 	lsl	fp, sl, #2
    48ec:	ca000025 	bgt	4988 <MDMAIN+0xd4>
            for (k=start_end[ProcID]->box[ZDIR][FIRST]; k<=start_end[ProcID]->box[ZDIR][LAST]; k++) {
                new_box = (box_list *) G_MALLOC(sizeof(box_list));
                new_box->coord[XDIR] = i;
                new_box->coord[YDIR] = j;
                new_box->coord[ZDIR] = k;
                new_box->next_box = NULL;
    48f0:	e3a08000 	mov	r8, #0
    48f4:	e59f7bb0 	ldr	r7, [pc, #2992]	; 54ac <MDMAIN+0xbf8>
    double POTA,POTR,POTRF;
    double XVIR,AVGT,TEN;
    struct list_of_boxes *new_box, *curr_box;

    for (i=start_end[ProcID]->box[XDIR][FIRST]; i<=start_end[ProcID]->box[XDIR][LAST]; i++) {
        for (j=start_end[ProcID]->box[YDIR][FIRST]; j<=start_end[ProcID]->box[YDIR][LAST]; j++) {
    48f8:	e5904008 	ldr	r4, [r0, #8]
    48fc:	e590300c 	ldr	r3, [r0, #12]
    4900:	e1540003 	cmp	r4, r3
    4904:	ca00001b 	bgt	4978 <MDMAIN+0xc4>
            for (k=start_end[ProcID]->box[ZDIR][FIRST]; k<=start_end[ProcID]->box[ZDIR][LAST]; k++) {
    4908:	e590a010 	ldr	sl, [r0, #16]
    490c:	e5903014 	ldr	r3, [r0, #20]
    4910:	e15a0003 	cmp	sl, r3
    4914:	ca000013 	bgt	4968 <MDMAIN+0xb4>
                new_box = (box_list *) G_MALLOC(sizeof(box_list));
    4918:	e3a00010 	mov	r0, #16
    491c:	eb004b58 	bl	17684 <malloc>
                new_box->coord[XDIR] = i;
                new_box->coord[YDIR] = j;
                new_box->coord[ZDIR] = k;
                new_box->next_box = NULL;
                curr_box = my_boxes[ProcID];
    4920:	e5973000 	ldr	r3, [r7]
            for (k=start_end[ProcID]->box[ZDIR][FIRST]; k<=start_end[ProcID]->box[ZDIR][LAST]; k++) {
                new_box = (box_list *) G_MALLOC(sizeof(box_list));
                new_box->coord[XDIR] = i;
                new_box->coord[YDIR] = j;
                new_box->coord[ZDIR] = k;
                new_box->next_box = NULL;
    4924:	e580800c 	str	r8, [r0, #12]
                curr_box = my_boxes[ProcID];
    4928:	e793200b 	ldr	r2, [r3, fp]

    for (i=start_end[ProcID]->box[XDIR][FIRST]; i<=start_end[ProcID]->box[XDIR][LAST]; i++) {
        for (j=start_end[ProcID]->box[YDIR][FIRST]; j<=start_end[ProcID]->box[YDIR][LAST]; j++) {
            for (k=start_end[ProcID]->box[ZDIR][FIRST]; k<=start_end[ProcID]->box[ZDIR][LAST]; k++) {
                new_box = (box_list *) G_MALLOC(sizeof(box_list));
                new_box->coord[XDIR] = i;
    492c:	e5806000 	str	r6, [r0]
                new_box->coord[YDIR] = j;
                new_box->coord[ZDIR] = k;
                new_box->next_box = NULL;
                curr_box = my_boxes[ProcID];
                if (curr_box == NULL)
    4930:	e3520000 	cmp	r2, #0
        for (j=start_end[ProcID]->box[YDIR][FIRST]; j<=start_end[ProcID]->box[YDIR][LAST]; j++) {
            for (k=start_end[ProcID]->box[ZDIR][FIRST]; k<=start_end[ProcID]->box[ZDIR][LAST]; k++) {
                new_box = (box_list *) G_MALLOC(sizeof(box_list));
                new_box->coord[XDIR] = i;
                new_box->coord[YDIR] = j;
                new_box->coord[ZDIR] = k;
    4934:	e9800410 	stmib	r0, {r4, sl}
                new_box->next_box = NULL;
                curr_box = my_boxes[ProcID];
                if (curr_box == NULL)
    4938:	1a000001 	bne	4944 <MDMAIN+0x90>
    493c:	ea0001c8 	b	5064 <MDMAIN+0x7b0>
                    my_boxes[ProcID] = new_box;
                else {
                    while (curr_box->next_box != NULL)
                        curr_box = curr_box->next_box;
    4940:	e1a02003 	mov	r2, r3
                new_box->next_box = NULL;
                curr_box = my_boxes[ProcID];
                if (curr_box == NULL)
                    my_boxes[ProcID] = new_box;
                else {
                    while (curr_box->next_box != NULL)
    4944:	e592300c 	ldr	r3, [r2, #12]
    4948:	e3530000 	cmp	r3, #0
    494c:	1afffffb 	bne	4940 <MDMAIN+0x8c>
                        curr_box = curr_box->next_box;
                    curr_box->next_box = new_box;
    4950:	e582000c 	str	r0, [r2, #12]
    double XVIR,AVGT,TEN;
    struct list_of_boxes *new_box, *curr_box;

    for (i=start_end[ProcID]->box[XDIR][FIRST]; i<=start_end[ProcID]->box[XDIR][LAST]; i++) {
        for (j=start_end[ProcID]->box[YDIR][FIRST]; j<=start_end[ProcID]->box[YDIR][LAST]; j++) {
            for (k=start_end[ProcID]->box[ZDIR][FIRST]; k<=start_end[ProcID]->box[ZDIR][LAST]; k++) {
    4954:	e795000b 	ldr	r0, [r5, fp]
    4958:	e28aa001 	add	sl, sl, #1
    495c:	e5903014 	ldr	r3, [r0, #20]
    4960:	e153000a 	cmp	r3, sl
    4964:	aaffffeb 	bge	4918 <MDMAIN+0x64>
    double POTA,POTR,POTRF;
    double XVIR,AVGT,TEN;
    struct list_of_boxes *new_box, *curr_box;

    for (i=start_end[ProcID]->box[XDIR][FIRST]; i<=start_end[ProcID]->box[XDIR][LAST]; i++) {
        for (j=start_end[ProcID]->box[YDIR][FIRST]; j<=start_end[ProcID]->box[YDIR][LAST]; j++) {
    4968:	e590300c 	ldr	r3, [r0, #12]
    496c:	e2844001 	add	r4, r4, #1
    4970:	e1530004 	cmp	r3, r4
    4974:	aaffffe3 	bge	4908 <MDMAIN+0x54>
    long i,j,k;
    double POTA,POTR,POTRF;
    double XVIR,AVGT,TEN;
    struct list_of_boxes *new_box, *curr_box;

    for (i=start_end[ProcID]->box[XDIR][FIRST]; i<=start_end[ProcID]->box[XDIR][LAST]; i++) {
    4978:	e5903004 	ldr	r3, [r0, #4]
    497c:	e2866001 	add	r6, r6, #1
    4980:	e1530006 	cmp	r3, r6
    4984:	aaffffdb 	bge	48f8 <MDMAIN+0x44>
        }
    }

    /* calculate initial value for acceleration */

    INTRAF(&gl->VIR,ProcID);
    4988:	e59f9b20 	ldr	r9, [pc, #2848]	; 54b0 <MDMAIN+0xbfc>
    498c:	e59d10c8 	ldr	r1, [sp, #200]	; 0xc8
    4990:	e5990000 	ldr	r0, [r9]
    4994:	e28000a0 	add	r0, r0, #160	; 0xa0
    4998:	eb001116 	bl	8df8 <INTRAF>

    BARRIER(gl->start,NumProcs);
    499c:	e5990000 	ldr	r0, [r9]
    49a0:	e2800048 	add	r0, r0, #72	; 0x48
    49a4:	ebffef92 	bl	7f4 <pthread_mutex_lock>
    49a8:	e2501000 	subs	r1, r0, #0
    49ac:	1a0001b6 	bne	508c <MDMAIN+0x7d8>
    49b0:	e5993000 	ldr	r3, [r9]
    49b4:	e59f8af8 	ldr	r8, [pc, #2808]	; 54b4 <MDMAIN+0xc00>
    49b8:	e593205c 	ldr	r2, [r3, #92]	; 0x5c
    49bc:	e598c000 	ldr	ip, [r8]
    49c0:	e2822001 	add	r2, r2, #1
    49c4:	e152000c 	cmp	r2, ip
    49c8:	e583205c 	str	r2, [r3, #92]	; 0x5c
    49cc:	e5934060 	ldr	r4, [r3, #96]	; 0x60
    49d0:	0a0001a6 	beq	5070 <MDMAIN+0x7bc>
    49d4:	e28d1094 	add	r1, sp, #148	; 0x94
    49d8:	ebfff286 	bl	13f8 <pthread_setcancelstate>
    49dc:	ea000004 	b	49f4 <MDMAIN+0x140>
    49e0:	e2810054 	add	r0, r1, #84	; 0x54
    49e4:	e2811048 	add	r1, r1, #72	; 0x48
    49e8:	ebfff2f0 	bl	15b0 <pthread_cond_wait>
    49ec:	e3500000 	cmp	r0, #0
    49f0:	1a000003 	bne	4a04 <MDMAIN+0x150>
    49f4:	e5991000 	ldr	r1, [r9]
    49f8:	e5913060 	ldr	r3, [r1, #96]	; 0x60
    49fc:	e1530004 	cmp	r3, r4
    4a00:	0afffff6 	beq	49e0 <MDMAIN+0x12c>
    4a04:	e59d0094 	ldr	r0, [sp, #148]	; 0x94
    4a08:	e28d1098 	add	r1, sp, #152	; 0x98
    4a0c:	ebfff279 	bl	13f8 <pthread_setcancelstate>
    4a10:	e5990000 	ldr	r0, [r9]
    4a14:	e2800048 	add	r0, r0, #72	; 0x48
    4a18:	ebfff24f 	bl	135c <pthread_mutex_unlock>
#ifdef SIM_SOCLIB
    if (ProcID==0) printf("---[%s: B0 ok \n",__func__);
    4a1c:	e59dc0c8 	ldr	ip, [sp, #200]	; 0xc8
    4a20:	e35c0000 	cmp	ip, #0
    4a24:	0a00029b 	beq	5498 <MDMAIN+0xbe4>
#endif

    INTERF(ACC,&gl->VIR,ProcID);
    4a28:	e5991000 	ldr	r1, [r9]
    4a2c:	e3a00002 	mov	r0, #2
    4a30:	e28110a0 	add	r1, r1, #160	; 0xa0
    4a34:	e59d20c8 	ldr	r2, [sp, #200]	; 0xc8
    4a38:	eb000b19 	bl	76a4 <INTERF>

    BARRIER(gl->start, NumProcs);
    4a3c:	e5990000 	ldr	r0, [r9]
    BARRIER(gl->start,NumProcs);
#ifdef SIM_SOCLIB
    if (ProcID==0) printf("---[%s: B0 ok \n",__func__);
#endif

    INTERF(ACC,&gl->VIR,ProcID);
    4a40:	e59f4a68 	ldr	r4, [pc, #2664]	; 54b0 <MDMAIN+0xbfc>

    BARRIER(gl->start, NumProcs);
    4a44:	e2800048 	add	r0, r0, #72	; 0x48
    4a48:	ebffef69 	bl	7f4 <pthread_mutex_lock>
    4a4c:	e2501000 	subs	r1, r0, #0
    4a50:	1a00018d 	bne	508c <MDMAIN+0x7d8>
    4a54:	e5943000 	ldr	r3, [r4]
    4a58:	e598c000 	ldr	ip, [r8]
    4a5c:	e593205c 	ldr	r2, [r3, #92]	; 0x5c
    4a60:	e5934060 	ldr	r4, [r3, #96]	; 0x60
    4a64:	e2822001 	add	r2, r2, #1
    4a68:	e152000c 	cmp	r2, ip
    4a6c:	e583205c 	str	r2, [r3, #92]	; 0x5c
    4a70:	0a000281 	beq	547c <MDMAIN+0xbc8>
    4a74:	e28d1094 	add	r1, sp, #148	; 0x94
    4a78:	ebfff25e 	bl	13f8 <pthread_setcancelstate>
    4a7c:	ea000004 	b	4a94 <MDMAIN+0x1e0>
    4a80:	e2810054 	add	r0, r1, #84	; 0x54
    4a84:	e2811048 	add	r1, r1, #72	; 0x48
    4a88:	ebfff2c8 	bl	15b0 <pthread_cond_wait>
    4a8c:	e3500000 	cmp	r0, #0
    4a90:	1a000003 	bne	4aa4 <MDMAIN+0x1f0>
    4a94:	e5991000 	ldr	r1, [r9]
    4a98:	e5913060 	ldr	r3, [r1, #96]	; 0x60
    4a9c:	e1530004 	cmp	r3, r4
    4aa0:	0afffff6 	beq	4a80 <MDMAIN+0x1cc>
    4aa4:	e59d0094 	ldr	r0, [sp, #148]	; 0x94
    4aa8:	e28d1098 	add	r1, sp, #152	; 0x98
    4aac:	ebfff251 	bl	13f8 <pthread_setcancelstate>
    4ab0:	e5990000 	ldr	r0, [r9]
    4ab4:	e2800048 	add	r0, r0, #72	; 0x48
    4ab8:	ebfff227 	bl	135c <pthread_mutex_unlock>
#ifdef SIM_SOCLIB
    if (ProcID==0) printf("---[%s: B1 ok \n",__func__);
    4abc:	e59da0c8 	ldr	sl, [sp, #200]	; 0xc8
    4ac0:	e35a0000 	cmp	sl, #0
    4ac4:	0a000268 	beq	546c <MDMAIN+0xbb8>
#endif

    /* MOLECULAR DYNAMICS LOOP */

    for (i=1;i <= NSTEP; i++) {
    4ac8:	e59db07c 	ldr	fp, [sp, #124]	; 0x7c
{
    double TVIR = 0.0;
    double TTMV = 0.0;
    double TKIN = 0.0;
//    double XTT;
    double XTT  = 0.0;
    4acc:	e3a0a000 	mov	sl, #0
    if (ProcID==0) printf("---[%s: B1 ok \n",__func__);
#endif

    /* MOLECULAR DYNAMICS LOOP */

    for (i=1;i <= NSTEP; i++) {
    4ad0:	e35b0000 	cmp	fp, #0
{
    double TVIR = 0.0;
    double TTMV = 0.0;
    double TKIN = 0.0;
//    double XTT;
    double XTT  = 0.0;
    4ad4:	e3a0b000 	mov	fp, #0
    4ad8:	e1cda2f8 	strd	sl, [sp, #40]	; 0x28
    if (ProcID==0) printf("---[%s: B1 ok \n",__func__);
#endif

    /* MOLECULAR DYNAMICS LOOP */

    for (i=1;i <= NSTEP; i++) {
    4adc:	da00025e 	ble	545c <MDMAIN+0xba8>
    4ae0:	e59dc0c8 	ldr	ip, [sp, #200]	; 0xc8
    4ae4:	e3a07001 	mov	r7, #1
    4ae8:	e16f6f1c 	clz	r6, ip
    4aec:	e1a0500c 	mov	r5, ip

double MDMAIN(long NSTEP, long NPRINT, long NSAVE, long NORD1, long ProcID)
{
    double TVIR = 0.0;
    double TTMV = 0.0;
    double TKIN = 0.0;
    4af0:	e1cda3f8 	strd	sl, [sp, #56]	; 0x38
/************************************************************************/

double MDMAIN(long NSTEP, long NPRINT, long NSAVE, long NORD1, long ProcID)
{
    double TVIR = 0.0;
    double TTMV = 0.0;
    4af4:	e1cda3f0 	strd	sl, [sp, #48]	; 0x30

/************************************************************************/

double MDMAIN(long NSTEP, long NPRINT, long NSAVE, long NORD1, long ProcID)
{
    double TVIR = 0.0;
    4af8:	e1cda4f0 	strd	sl, [sp, #64]	; 0x40
    4afc:	e1a062a6 	lsr	r6, r6, #5
#endif

    /* MOLECULAR DYNAMICS LOOP */

    for (i=1;i <= NSTEP; i++) {
        TTMV=TTMV+1.00;
    4b00:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
    4b04:	e3a02000 	mov	r2, #0
    4b08:	e59f39a8 	ldr	r3, [pc, #2472]	; 54b8 <MDMAIN+0xc04>
    4b0c:	eb003ef7 	bl	146f0 <__adddf3>
        /* POSSIBLE ENHANCEMENT:  Here's where one start measurements to avoid
           cold-start effects.  Recommended to do this at the beginning of the
           second timestep; i.e. if (i == 2).
           */
#ifdef SIM_SOCLIB
        printf("---[%s: Step : %d\n",__func__,i);
    4b10:	e1a02007 	mov	r2, r7
#endif

    /* MOLECULAR DYNAMICS LOOP */

    for (i=1;i <= NSTEP; i++) {
        TTMV=TTMV+1.00;
    4b14:	e1cd03f0 	strd	r0, [sp, #48]	; 0x30
        /* POSSIBLE ENHANCEMENT:  Here's where one start measurements to avoid
           cold-start effects.  Recommended to do this at the beginning of the
           second timestep; i.e. if (i == 2).
           */
#ifdef SIM_SOCLIB
        printf("---[%s: Step : %d\n",__func__,i);
    4b18:	e59f099c 	ldr	r0, [pc, #2460]	; 54bc <MDMAIN+0xc08>
    4b1c:	e59f199c 	ldr	r1, [pc, #2460]	; 54c0 <MDMAIN+0xc0c>
    4b20:	eb004fcb 	bl	18a54 <printf>
#endif

        /* initialize various shared sums */
        if (ProcID == 0) {
    4b24:	e3560000 	cmp	r6, #0
    4b28:	0a00015b 	beq	509c <MDMAIN+0x7e8>
            long dir;
            if (i >= 2) {
    4b2c:	e3570001 	cmp	r7, #1
    4b30:	0a00023c 	beq	5428 <MDMAIN+0xb74>
                CLOCK(gl->trackstart);
    4b34:	e28da098 	add	sl, sp, #152	; 0x98
    4b38:	e1a0000a 	mov	r0, sl
    4b3c:	e3a01000 	mov	r1, #0
            }
            gl->VIR = 0.0;
    4b40:	e3a0b000 	mov	fp, #0
            gl->POTRF = 0.0;
            for (dir = XDIR; dir <= ZDIR; dir++)
                gl->SUM[dir] = 0.0;
        }

        if ((ProcID == 0) && (i >= 2)) {
    4b44:	e58d6048 	str	r6, [sp, #72]	; 0x48

        /* initialize various shared sums */
        if (ProcID == 0) {
            long dir;
            if (i >= 2) {
                CLOCK(gl->trackstart);
    4b48:	eb0049ed 	bl	17304 <gettimeofday>
            for (dir = XDIR; dir <= ZDIR; dir++)
                gl->SUM[dir] = 0.0;
        }

        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->intrastart);
    4b4c:	e1a0000a 	mov	r0, sl
        if (ProcID == 0) {
            long dir;
            if (i >= 2) {
                CLOCK(gl->trackstart);
            }
            gl->VIR = 0.0;
    4b50:	e3a0a000 	mov	sl, #0

        /* initialize various shared sums */
        if (ProcID == 0) {
            long dir;
            if (i >= 2) {
                CLOCK(gl->trackstart);
    4b54:	e59d309c 	ldr	r3, [sp, #156]	; 0x9c
    4b58:	e59d2098 	ldr	r2, [sp, #152]	; 0x98
    4b5c:	e59f4960 	ldr	r4, [pc, #2400]	; 54c4 <MDMAIN+0xc10>
    4b60:	e5991000 	ldr	r1, [r9]
    4b64:	e0223294 	mla	r2, r4, r2, r3
            }
            gl->VIR = 0.0;
    4b68:	e1c1aaf0 	strd	sl, [r1, #160]	; 0xa0

        /* initialize various shared sums */
        if (ProcID == 0) {
            long dir;
            if (i >= 2) {
                CLOCK(gl->trackstart);
    4b6c:	e58120e0 	str	r2, [r1, #224]	; 0xe0
            }
            gl->VIR = 0.0;
            gl->POTA = 0.0;
    4b70:	e1c1acf0 	strd	sl, [r1, #192]	; 0xc0
            gl->POTR = 0.0;
    4b74:	e1c1acf8 	strd	sl, [r1, #200]	; 0xc8
            gl->POTRF = 0.0;
    4b78:	e1c1adf0 	strd	sl, [r1, #208]	; 0xd0
            for (dir = XDIR; dir <= ZDIR; dir++)
                gl->SUM[dir] = 0.0;
    4b7c:	e1c1aaf8 	strd	sl, [r1, #168]	; 0xa8
    4b80:	e1c1abf0 	strd	sl, [r1, #176]	; 0xb0
    4b84:	e1c1abf8 	strd	sl, [r1, #184]	; 0xb8
        }

        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->intrastart);
    4b88:	e3a01000 	mov	r1, #0
    4b8c:	eb0049dc 	bl	17304 <gettimeofday>
    4b90:	e59d2098 	ldr	r2, [sp, #152]	; 0x98
    4b94:	e59d309c 	ldr	r3, [sp, #156]	; 0x9c
    4b98:	e5990000 	ldr	r0, [r9]
    4b9c:	e0243294 	mla	r4, r4, r2, r3
    4ba0:	e58040ec 	str	r4, [r0, #236]	; 0xec
        }

        BARRIER(gl->start, NumProcs);
    4ba4:	e2800048 	add	r0, r0, #72	; 0x48
    4ba8:	ebffef11 	bl	7f4 <pthread_mutex_lock>
    4bac:	e250c000 	subs	ip, r0, #0
    4bb0:	1a000135 	bne	508c <MDMAIN+0x7d8>
    4bb4:	e5993000 	ldr	r3, [r9]
    4bb8:	e5981000 	ldr	r1, [r8]
    4bbc:	e593205c 	ldr	r2, [r3, #92]	; 0x5c
    4bc0:	e5934060 	ldr	r4, [r3, #96]	; 0x60
    4bc4:	e2822001 	add	r2, r2, #1
    4bc8:	e1520001 	cmp	r2, r1
    4bcc:	e583205c 	str	r2, [r3, #92]	; 0x5c
    4bd0:	0a000181 	beq	51dc <MDMAIN+0x928>
    4bd4:	e28d1094 	add	r1, sp, #148	; 0x94
    4bd8:	ebfff206 	bl	13f8 <pthread_setcancelstate>
    4bdc:	e59db048 	ldr	fp, [sp, #72]	; 0x48
    4be0:	ea000004 	b	4bf8 <MDMAIN+0x344>
    4be4:	e2810054 	add	r0, r1, #84	; 0x54
    4be8:	e2811048 	add	r1, r1, #72	; 0x48
    4bec:	ebfff26f 	bl	15b0 <pthread_cond_wait>
    4bf0:	e3500000 	cmp	r0, #0
    4bf4:	1a000003 	bne	4c08 <MDMAIN+0x354>
    4bf8:	e5991000 	ldr	r1, [r9]
    4bfc:	e5913060 	ldr	r3, [r1, #96]	; 0x60
    4c00:	e1530004 	cmp	r3, r4
    4c04:	0afffff6 	beq	4be4 <MDMAIN+0x330>
    4c08:	e59d0094 	ldr	r0, [sp, #148]	; 0x94
    4c0c:	e28d1098 	add	r1, sp, #152	; 0x98
    4c10:	e58db048 	str	fp, [sp, #72]	; 0x48
    4c14:	ebfff1f7 	bl	13f8 <pthread_setcancelstate>
    4c18:	e5990000 	ldr	r0, [r9]
    4c1c:	e2800048 	add	r0, r0, #72	; 0x48
    4c20:	ebfff1cd 	bl	135c <pthread_mutex_unlock>
#ifdef SIM_SOCLIB
        if (ProcID==0) printf("---[%s: B2 ok \n",__func__);
    4c24:	e3560000 	cmp	r6, #0
    4c28:	1a000167 	bne	51cc <MDMAIN+0x918>
#endif
        PREDIC(TLC,NORD1,ProcID);
    4c2c:	e1a02005 	mov	r2, r5
    4c30:	e59f0890 	ldr	r0, [pc, #2192]	; 54c8 <MDMAIN+0xc14>
    4c34:	e59d104c 	ldr	r1, [sp, #76]	; 0x4c
    4c38:	eb000463 	bl	5dcc <PREDIC>
        INTRAF(&gl->VIR,ProcID);
    4c3c:	e5990000 	ldr	r0, [r9]
    4c40:	e1a01005 	mov	r1, r5
    4c44:	e28000a0 	add	r0, r0, #160	; 0xa0
    4c48:	eb00106a 	bl	8df8 <INTRAF>

        BARRIER(gl->start, NumProcs);
    4c4c:	e5990000 	ldr	r0, [r9]
        BARRIER(gl->start, NumProcs);
#ifdef SIM_SOCLIB
        if (ProcID==0) printf("---[%s: B2 ok \n",__func__);
#endif
        PREDIC(TLC,NORD1,ProcID);
        INTRAF(&gl->VIR,ProcID);
    4c50:	e59f4858 	ldr	r4, [pc, #2136]	; 54b0 <MDMAIN+0xbfc>

        BARRIER(gl->start, NumProcs);
    4c54:	e2800048 	add	r0, r0, #72	; 0x48
    4c58:	ebffeee5 	bl	7f4 <pthread_mutex_lock>
    4c5c:	e2501000 	subs	r1, r0, #0
    4c60:	1a000109 	bne	508c <MDMAIN+0x7d8>
    4c64:	e5943000 	ldr	r3, [r4]
    4c68:	e598c000 	ldr	ip, [r8]
    4c6c:	e593205c 	ldr	r2, [r3, #92]	; 0x5c
    4c70:	e5934060 	ldr	r4, [r3, #96]	; 0x60
    4c74:	e2822001 	add	r2, r2, #1
    4c78:	e152000c 	cmp	r2, ip
    4c7c:	e583205c 	str	r2, [r3, #92]	; 0x5c
    4c80:	0a000190 	beq	52c8 <MDMAIN+0xa14>
    4c84:	e28d1094 	add	r1, sp, #148	; 0x94
    4c88:	ebfff1da 	bl	13f8 <pthread_setcancelstate>
    4c8c:	e59db048 	ldr	fp, [sp, #72]	; 0x48
    4c90:	ea000004 	b	4ca8 <MDMAIN+0x3f4>
    4c94:	e2810054 	add	r0, r1, #84	; 0x54
    4c98:	e2811048 	add	r1, r1, #72	; 0x48
    4c9c:	ebfff243 	bl	15b0 <pthread_cond_wait>
    4ca0:	e3500000 	cmp	r0, #0
    4ca4:	1a000003 	bne	4cb8 <MDMAIN+0x404>
    4ca8:	e5991000 	ldr	r1, [r9]
    4cac:	e5913060 	ldr	r3, [r1, #96]	; 0x60
    4cb0:	e1530004 	cmp	r3, r4
    4cb4:	0afffff6 	beq	4c94 <MDMAIN+0x3e0>
    4cb8:	e59d0094 	ldr	r0, [sp, #148]	; 0x94
    4cbc:	e28d1098 	add	r1, sp, #152	; 0x98
    4cc0:	e58db048 	str	fp, [sp, #72]	; 0x48
    4cc4:	ebfff1cb 	bl	13f8 <pthread_setcancelstate>
    4cc8:	e5990000 	ldr	r0, [r9]
    4ccc:	e2800048 	add	r0, r0, #72	; 0x48
    4cd0:	ebfff1a1 	bl	135c <pthread_mutex_unlock>
#ifdef SIM_SOCLIB
        if (ProcID==0) printf("---[%s: B3 ok \n",__func__);
    4cd4:	e3560000 	cmp	r6, #0
    4cd8:	1a000176 	bne	52b8 <MDMAIN+0xa04>
#endif

        if ((ProcID == 0) && (i >= 2)) {
    4cdc:	e59dc048 	ldr	ip, [sp, #72]	; 0x48
    4ce0:	e35c0000 	cmp	ip, #0
    4ce4:	1a00014a 	bne	5214 <MDMAIN+0x960>

        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->interstart);
        }

        INTERF(FORCES,&gl->VIR,ProcID);
    4ce8:	e5991000 	ldr	r1, [r9]
    4cec:	e3a00007 	mov	r0, #7
    4cf0:	e28110a0 	add	r1, r1, #160	; 0xa0
    4cf4:	e1a02005 	mov	r2, r5
    4cf8:	eb000a69 	bl	76a4 <INTERF>
        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->interend);
            gl->intertime += gl->interend - gl->interstart;
        }

        CORREC(PCC,NORD1,ProcID);
    4cfc:	e59d104c 	ldr	r1, [sp, #76]	; 0x4c
    4d00:	e1a02005 	mov	r2, r5
    4d04:	e59f07c0 	ldr	r0, [pc, #1984]	; 54cc <MDMAIN+0xc18>
    4d08:	eb00051d 	bl	6184 <CORREC>

        BNDRY(ProcID);
    4d0c:	e1a00005 	mov	r0, r5
    4d10:	eb002080 	bl	cf18 <BNDRY>

        KINETI(gl->SUM,HMAS,OMAS,ProcID);
    4d14:	e599c000 	ldr	ip, [r9]
    4d18:	e59f17b0 	ldr	r1, [pc, #1968]	; 54d0 <MDMAIN+0xc1c>
    4d1c:	e59f37b0 	ldr	r3, [pc, #1968]	; 54d4 <MDMAIN+0xc20>
    4d20:	e58d5008 	str	r5, [sp, #8]
    4d24:	e1c3a0d0 	ldrd	sl, [r3]
    4d28:	e28c00a8 	add	r0, ip, #168	; 0xa8
    4d2c:	e1c120d0 	ldrd	r2, [r1]
    4d30:	e1cd20f0 	strd	r2, [sp]
    4d34:	e1a0200a 	mov	r2, sl
    4d38:	e1a0300b 	mov	r3, fp
    4d3c:	eb002007 	bl	cd60 <KINETI>

        BARRIER(gl->start, NumProcs);
    4d40:	e5990000 	ldr	r0, [r9]

        CORREC(PCC,NORD1,ProcID);

        BNDRY(ProcID);

        KINETI(gl->SUM,HMAS,OMAS,ProcID);
    4d44:	e59f4764 	ldr	r4, [pc, #1892]	; 54b0 <MDMAIN+0xbfc>

        BARRIER(gl->start, NumProcs);
    4d48:	e2800048 	add	r0, r0, #72	; 0x48
    4d4c:	ebffeea8 	bl	7f4 <pthread_mutex_lock>
    4d50:	e2501000 	subs	r1, r0, #0
    4d54:	1a0000cc 	bne	508c <MDMAIN+0x7d8>
    4d58:	e5943000 	ldr	r3, [r4]
    4d5c:	e598c000 	ldr	ip, [r8]
    4d60:	e593205c 	ldr	r2, [r3, #92]	; 0x5c
    4d64:	e5934060 	ldr	r4, [r3, #96]	; 0x60
    4d68:	e2822001 	add	r2, r2, #1
    4d6c:	e152000c 	cmp	r2, ip
    4d70:	e583205c 	str	r2, [r3, #92]	; 0x5c
    4d74:	0a00011f 	beq	51f8 <MDMAIN+0x944>
    4d78:	e28d1094 	add	r1, sp, #148	; 0x94
    4d7c:	ebfff19d 	bl	13f8 <pthread_setcancelstate>
    4d80:	e59db048 	ldr	fp, [sp, #72]	; 0x48
    4d84:	ea000004 	b	4d9c <MDMAIN+0x4e8>
    4d88:	e2810054 	add	r0, r1, #84	; 0x54
    4d8c:	e2811048 	add	r1, r1, #72	; 0x48
    4d90:	ebfff206 	bl	15b0 <pthread_cond_wait>
    4d94:	e3500000 	cmp	r0, #0
    4d98:	1a000003 	bne	4dac <MDMAIN+0x4f8>
    4d9c:	e5991000 	ldr	r1, [r9]
    4da0:	e5913060 	ldr	r3, [r1, #96]	; 0x60
    4da4:	e1530004 	cmp	r3, r4
    4da8:	0afffff6 	beq	4d88 <MDMAIN+0x4d4>
    4dac:	e59d0094 	ldr	r0, [sp, #148]	; 0x94
    4db0:	e28d1098 	add	r1, sp, #152	; 0x98
    4db4:	e58db048 	str	fp, [sp, #72]	; 0x48
    4db8:	ebfff18e 	bl	13f8 <pthread_setcancelstate>
    4dbc:	e5990000 	ldr	r0, [r9]
    4dc0:	e2800048 	add	r0, r0, #72	; 0x48
    4dc4:	ebfff164 	bl	135c <pthread_mutex_unlock>
#ifdef SIM_SOCLIB
        if (ProcID==0) printf("---[%s: B4 ok \n",__func__);
    4dc8:	e3560000 	cmp	r6, #0
    4dcc:	1a0000e7 	bne	5170 <MDMAIN+0x8bc>
#endif

        if ((ProcID == 0) && (i >= 2)) {
    4dd0:	e59da048 	ldr	sl, [sp, #72]	; 0x48
    4dd4:	e35a0000 	cmp	sl, #0
    4dd8:	1a0000b9 	bne	50c4 <MDMAIN+0x810>
            CLOCK(gl->intraend);
            gl->intratime += gl->intraend - gl->interend;
        }

        TKIN=TKIN+gl->SUM[0]+gl->SUM[1]+gl->SUM[2];
    4ddc:	e1cd03d8 	ldrd	r0, [sp, #56]	; 0x38
    4de0:	e5994000 	ldr	r4, [r9]
    4de4:	e1c42ad8 	ldrd	r2, [r4, #168]	; 0xa8
    4de8:	eb003e40 	bl	146f0 <__adddf3>
    4dec:	e1c42bd0 	ldrd	r2, [r4, #176]	; 0xb0
    4df0:	eb003e3e 	bl	146f0 <__adddf3>
    4df4:	e1c42bd8 	ldrd	r2, [r4, #184]	; 0xb8
    4df8:	eb003e3c 	bl	146f0 <__adddf3>
        TVIR=TVIR-gl->VIR;
    4dfc:	e1c42ad0 	ldrd	r2, [r4, #160]	; 0xa0
        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->intraend);
            gl->intratime += gl->intraend - gl->interend;
        }

        TKIN=TKIN+gl->SUM[0]+gl->SUM[1]+gl->SUM[2];
    4e00:	e1cd03f8 	strd	r0, [sp, #56]	; 0x38
        TVIR=TVIR-gl->VIR;
    4e04:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    4e08:	eb003e37 	bl	146ec <__aeabi_dsub>
    4e0c:	e1cd04f0 	strd	r0, [sp, #64]	; 0x40

        /* CHECK if  PRINTING AND/OR SAVING IS TO BE DONE */

        if ( ((i % NPRINT) == 0) || ((NSAVE > 0) && ((i % NSAVE) == 0))) {
    4e10:	e1a00007 	mov	r0, r7
    4e14:	e59d1088 	ldr	r1, [sp, #136]	; 0x88
    4e18:	eb003e28 	bl	146c0 <__aeabi_idivmod>
    4e1c:	e3510000 	cmp	r1, #0
    4e20:	e58d1078 	str	r1, [sp, #120]	; 0x78
    4e24:	0a00000a 	beq	4e54 <MDMAIN+0x5a0>
    4e28:	e59da08c 	ldr	sl, [sp, #140]	; 0x8c
    4e2c:	e35a0000 	cmp	sl, #0
    4e30:	da00005f 	ble	4fb4 <MDMAIN+0x700>
    4e34:	e1a00007 	mov	r0, r7
    4e38:	e1a0100a 	mov	r1, sl
    4e3c:	eb003e1f 	bl	146c0 <__aeabi_idivmod>
    4e40:	e3510000 	cmp	r1, #0
    4e44:	1a00005a 	bne	4fb4 <MDMAIN+0x700>

            /* if so, call poteng to compute potential energy.  Note
               that we are attributing all the time in poteng to intermolecular
               computation although some of it is intramolecular (see poteng.C) */

            if ((ProcID == 0) && (i >= 2)) {
    4e48:	e59dc048 	ldr	ip, [sp, #72]	; 0x48
    4e4c:	e35c0000 	cmp	ip, #0
    4e50:	1a00012a 	bne	5300 <MDMAIN+0xa4c>
                CLOCK(gl->interstart);
            }

            POTENG(&gl->POTA,&gl->POTR,&gl->POTRF,ProcID);
    4e54:	e28410c8 	add	r1, r4, #200	; 0xc8
    4e58:	e28400c0 	add	r0, r4, #192	; 0xc0
    4e5c:	e28420d0 	add	r2, r4, #208	; 0xd0
    4e60:	e1a03005 	mov	r3, r5
    4e64:	eb0018d1 	bl	b1b0 <POTENG>

            BARRIER(gl->start, NumProcs);
    4e68:	e5990000 	ldr	r0, [r9]
    4e6c:	e59f463c 	ldr	r4, [pc, #1596]	; 54b0 <MDMAIN+0xbfc>
    4e70:	e2800048 	add	r0, r0, #72	; 0x48
    4e74:	ebffee5e 	bl	7f4 <pthread_mutex_lock>
    4e78:	e2501000 	subs	r1, r0, #0
    4e7c:	1a000082 	bne	508c <MDMAIN+0x7d8>
    4e80:	e5943000 	ldr	r3, [r4]
    4e84:	e598c000 	ldr	ip, [r8]
    4e88:	e593205c 	ldr	r2, [r3, #92]	; 0x5c
    4e8c:	e5934060 	ldr	r4, [r3, #96]	; 0x60
    4e90:	e2822001 	add	r2, r2, #1
    4e94:	e152000c 	cmp	r2, ip
    4e98:	e583205c 	str	r2, [r3, #92]	; 0x5c
    4e9c:	0a000110 	beq	52e4 <MDMAIN+0xa30>
    4ea0:	e28d1094 	add	r1, sp, #148	; 0x94
    4ea4:	ebfff153 	bl	13f8 <pthread_setcancelstate>
    4ea8:	e59db048 	ldr	fp, [sp, #72]	; 0x48
    4eac:	ea000004 	b	4ec4 <MDMAIN+0x610>
    4eb0:	e2810054 	add	r0, r1, #84	; 0x54
    4eb4:	e2811048 	add	r1, r1, #72	; 0x48
    4eb8:	ebfff1bc 	bl	15b0 <pthread_cond_wait>
    4ebc:	e3500000 	cmp	r0, #0
    4ec0:	1a000003 	bne	4ed4 <MDMAIN+0x620>
    4ec4:	e5991000 	ldr	r1, [r9]
    4ec8:	e5913060 	ldr	r3, [r1, #96]	; 0x60
    4ecc:	e1530004 	cmp	r3, r4
    4ed0:	0afffff6 	beq	4eb0 <MDMAIN+0x5fc>
    4ed4:	e59d0094 	ldr	r0, [sp, #148]	; 0x94
    4ed8:	e28d1098 	add	r1, sp, #152	; 0x98
    4edc:	e58db048 	str	fp, [sp, #72]	; 0x48
    4ee0:	ebfff144 	bl	13f8 <pthread_setcancelstate>
    4ee4:	e5990000 	ldr	r0, [r9]
    4ee8:	e2800048 	add	r0, r0, #72	; 0x48
    4eec:	ebfff11a 	bl	135c <pthread_mutex_unlock>
#ifdef SIM_SOCLIB
            if (ProcID==0) printf("---[%s: B5 ok \n",__func__);
    4ef0:	e3560000 	cmp	r6, #0
    4ef4:	1a000147 	bne	5418 <MDMAIN+0xb64>
#endif

            if ((ProcID == 0) && (i >= 2)) {
    4ef8:	e59da048 	ldr	sl, [sp, #72]	; 0x48
    4efc:	e35a0000 	cmp	sl, #0
    4f00:	1a000135 	bne	53dc <MDMAIN+0xb28>
    4f04:	e5994000 	ldr	r4, [r9]
                CLOCK(gl->interend);
                gl->intertime += gl->interend - gl->interstart;
            }

            POTA=gl->POTA*FPOT;
    4f08:	e59fc5c8 	ldr	ip, [pc, #1480]	; 54d8 <MDMAIN+0xc24>
    4f0c:	e1c42cd0 	ldrd	r2, [r4, #192]	; 0xc0
    4f10:	e1cca0d0 	ldrd	sl, [ip]
    4f14:	e1a0000a 	mov	r0, sl
    4f18:	e1a0100b 	mov	r1, fp
    4f1c:	e1cda2f0 	strd	sl, [sp, #32]
    4f20:	eb003ef6 	bl	14b00 <__aeabi_dmul>
            POTR=gl->POTR*FPOT;
    4f24:	e1c42cd8 	ldrd	r2, [r4, #200]	; 0xc8
            if ((ProcID == 0) && (i >= 2)) {
                CLOCK(gl->interend);
                gl->intertime += gl->interend - gl->interstart;
            }

            POTA=gl->POTA*FPOT;
    4f28:	e1cd05f8 	strd	r0, [sp, #88]	; 0x58
            POTR=gl->POTR*FPOT;
    4f2c:	e1cd02d0 	ldrd	r0, [sp, #32]
    4f30:	eb003ef2 	bl	14b00 <__aeabi_dmul>
            POTRF=gl->POTRF*FPOT;
    4f34:	e1c42dd0 	ldrd	r2, [r4, #208]	; 0xd0
                CLOCK(gl->interend);
                gl->intertime += gl->interend - gl->interstart;
            }

            POTA=gl->POTA*FPOT;
            POTR=gl->POTR*FPOT;
    4f38:	e1cd06f0 	strd	r0, [sp, #96]	; 0x60
            POTRF=gl->POTRF*FPOT;
    4f3c:	e1cd02d0 	ldrd	r0, [sp, #32]
    4f40:	eb003eee 	bl	14b00 <__aeabi_dmul>
            XVIR=TVIR*FPOT*0.50/TTMV;
            AVGT=TKIN*FKIN*TEMP*2.00/(3.00*TTMV);
            TEN=(gl->SUM[0]+gl->SUM[1]+gl->SUM[2])*FKIN;
    4f44:	e1c42bd0 	ldrd	r2, [r4, #176]	; 0xb0

            POTA=gl->POTA*FPOT;
            POTR=gl->POTR*FPOT;
            POTRF=gl->POTRF*FPOT;
            XVIR=TVIR*FPOT*0.50/TTMV;
            AVGT=TKIN*FKIN*TEMP*2.00/(3.00*TTMV);
    4f48:	e59fe58c 	ldr	lr, [pc, #1420]	; 54dc <MDMAIN+0xc28>
    4f4c:	e59fc58c 	ldr	ip, [pc, #1420]	; 54e0 <MDMAIN+0xc2c>
                gl->intertime += gl->interend - gl->interstart;
            }

            POTA=gl->POTA*FPOT;
            POTR=gl->POTR*FPOT;
            POTRF=gl->POTRF*FPOT;
    4f50:	e1cd06f8 	strd	r0, [sp, #104]	; 0x68
            XVIR=TVIR*FPOT*0.50/TTMV;
            AVGT=TKIN*FKIN*TEMP*2.00/(3.00*TTMV);
            TEN=(gl->SUM[0]+gl->SUM[1]+gl->SUM[2])*FKIN;
    4f54:	e1c40ad8 	ldrd	r0, [r4, #168]	; 0xa8

            POTA=gl->POTA*FPOT;
            POTR=gl->POTR*FPOT;
            POTRF=gl->POTRF*FPOT;
            XVIR=TVIR*FPOT*0.50/TTMV;
            AVGT=TKIN*FKIN*TEMP*2.00/(3.00*TTMV);
    4f58:	e1cea0d0 	ldrd	sl, [lr]
    4f5c:	e1cda5f0 	strd	sl, [sp, #80]	; 0x50
    4f60:	e1cca0d0 	ldrd	sl, [ip]
    4f64:	e1cda8f0 	strd	sl, [sp, #128]	; 0x80
            TEN=(gl->SUM[0]+gl->SUM[1]+gl->SUM[2])*FKIN;
    4f68:	eb003de0 	bl	146f0 <__adddf3>
    4f6c:	e1c42bd8 	ldrd	r2, [r4, #184]	; 0xb8
    4f70:	eb003dde 	bl	146f0 <__adddf3>
    4f74:	e1a02000 	mov	r2, r0
    4f78:	e1a03001 	mov	r3, r1
    4f7c:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    4f80:	eb003ede 	bl	14b00 <__aeabi_dmul>
            XTT=POTA+POTR+POTRF+TEN;
    4f84:	e1cd26d0 	ldrd	r2, [sp, #96]	; 0x60
            POTA=gl->POTA*FPOT;
            POTR=gl->POTR*FPOT;
            POTRF=gl->POTRF*FPOT;
            XVIR=TVIR*FPOT*0.50/TTMV;
            AVGT=TKIN*FKIN*TEMP*2.00/(3.00*TTMV);
            TEN=(gl->SUM[0]+gl->SUM[1]+gl->SUM[2])*FKIN;
    4f88:	e1cd07f0 	strd	r0, [sp, #112]	; 0x70
            XTT=POTA+POTR+POTRF+TEN;
    4f8c:	e1cd05d8 	ldrd	r0, [sp, #88]	; 0x58
    4f90:	eb003dd6 	bl	146f0 <__adddf3>
    4f94:	e1cd26d8 	ldrd	r2, [sp, #104]	; 0x68
    4f98:	eb003dd4 	bl	146f0 <__adddf3>
    4f9c:	e1cd27d0 	ldrd	r2, [sp, #112]	; 0x70
    4fa0:	eb003dd2 	bl	146f0 <__adddf3>

            /* if it is time to print output as well ... */
            if ((i % NPRINT) == 0 && ProcID == 0) {
    4fa4:	e59db078 	ldr	fp, [sp, #120]	; 0x78
            POTR=gl->POTR*FPOT;
            POTRF=gl->POTRF*FPOT;
            XVIR=TVIR*FPOT*0.50/TTMV;
            AVGT=TKIN*FKIN*TEMP*2.00/(3.00*TTMV);
            TEN=(gl->SUM[0]+gl->SUM[1]+gl->SUM[2])*FKIN;
            XTT=POTA+POTR+POTRF+TEN;
    4fa8:	e1cd02f8 	strd	r0, [sp, #40]	; 0x28

            /* if it is time to print output as well ... */
            if ((i % NPRINT) == 0 && ProcID == 0) {
    4fac:	e19bb005 	orrs	fp, fp, r5
    4fb0:	0a0000d4 	beq	5308 <MDMAIN+0xa54>
                UNLOCK(gl->IOLock);
            }

        }

        BARRIER(gl->start, NumProcs);
    4fb4:	e2840048 	add	r0, r4, #72	; 0x48
    4fb8:	ebffee0d 	bl	7f4 <pthread_mutex_lock>
    4fbc:	e250c000 	subs	ip, r0, #0
    4fc0:	1a000031 	bne	508c <MDMAIN+0x7d8>
    4fc4:	e5993000 	ldr	r3, [r9]
    4fc8:	e5981000 	ldr	r1, [r8]
    4fcc:	e593205c 	ldr	r2, [r3, #92]	; 0x5c
    4fd0:	e5934060 	ldr	r4, [r3, #96]	; 0x60
    4fd4:	e2822001 	add	r2, r2, #1
    4fd8:	e1520001 	cmp	r2, r1
    4fdc:	e583205c 	str	r2, [r3, #92]	; 0x5c
    4fe0:	0a000030 	beq	50a8 <MDMAIN+0x7f4>
    4fe4:	e28d1094 	add	r1, sp, #148	; 0x94
    4fe8:	ebfff102 	bl	13f8 <pthread_setcancelstate>
    4fec:	e59db048 	ldr	fp, [sp, #72]	; 0x48
    4ff0:	ea000004 	b	5008 <MDMAIN+0x754>
    4ff4:	e2810054 	add	r0, r1, #84	; 0x54
    4ff8:	e2811048 	add	r1, r1, #72	; 0x48
    4ffc:	ebfff16b 	bl	15b0 <pthread_cond_wait>
    5000:	e3500000 	cmp	r0, #0
    5004:	1a000003 	bne	5018 <MDMAIN+0x764>
    5008:	e5991000 	ldr	r1, [r9]
    500c:	e5913060 	ldr	r3, [r1, #96]	; 0x60
    5010:	e1530004 	cmp	r3, r4
    5014:	0afffff6 	beq	4ff4 <MDMAIN+0x740>
    5018:	e59d0094 	ldr	r0, [sp, #148]	; 0x94
    501c:	e28d1098 	add	r1, sp, #152	; 0x98
    5020:	e58db048 	str	fp, [sp, #72]	; 0x48
    5024:	ebfff0f3 	bl	13f8 <pthread_setcancelstate>
    5028:	e5990000 	ldr	r0, [r9]
    502c:	e2800048 	add	r0, r0, #72	; 0x48
    5030:	ebfff0c9 	bl	135c <pthread_mutex_unlock>
#ifdef SIM_SOCLIB
        if (ProcID==0) printf("---[%s: B6 ok \n",__func__);
    5034:	e3560000 	cmp	r6, #0
    5038:	1a00005f 	bne	51bc <MDMAIN+0x908>
#endif
        if ((ProcID == 0) && (i >= 2)) {
    503c:	e59da048 	ldr	sl, [sp, #72]	; 0x48
    5040:	e35a0000 	cmp	sl, #0
    5044:	1a00004d 	bne	5180 <MDMAIN+0x8cc>
    if (ProcID==0) printf("---[%s: B1 ok \n",__func__);
#endif

    /* MOLECULAR DYNAMICS LOOP */

    for (i=1;i <= NSTEP; i++) {
    5048:	e59db07c 	ldr	fp, [sp, #124]	; 0x7c
    504c:	e2877001 	add	r7, r7, #1
    5050:	e15b0007 	cmp	fp, r7
    5054:	aafffea9 	bge	4b00 <MDMAIN+0x24c>
    5058:	e1cd02d8 	ldrd	r0, [sp, #40]	; 0x28

    } /* for i */

    return(XTT);

} /* mdmain.c */
    505c:	e28dd0a4 	add	sp, sp, #164	; 0xa4
    5060:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                new_box->coord[YDIR] = j;
                new_box->coord[ZDIR] = k;
                new_box->next_box = NULL;
                curr_box = my_boxes[ProcID];
                if (curr_box == NULL)
                    my_boxes[ProcID] = new_box;
    5064:	e783000b 	str	r0, [r3, fp]
    5068:	e5995000 	ldr	r5, [r9]
    506c:	eafffe38 	b	4954 <MDMAIN+0xa0>

    /* calculate initial value for acceleration */

    INTRAF(&gl->VIR,ProcID);

    BARRIER(gl->start,NumProcs);
    5070:	e16f4f14 	clz	r4, r4
    5074:	e1a042a4 	lsr	r4, r4, #5
    5078:	e5834060 	str	r4, [r3, #96]	; 0x60
    507c:	e583105c 	str	r1, [r3, #92]	; 0x5c
    5080:	e2830054 	add	r0, r3, #84	; 0x54
    5084:	ebffee13 	bl	8d8 <pthread_cond_broadcast>
    5088:	eafffe60 	b	4a10 <MDMAIN+0x15c>
    508c:	e59f0450 	ldr	r0, [pc, #1104]	; 54e4 <MDMAIN+0xc30>
    5090:	eb004ee7 	bl	18c34 <puts>
    5094:	e3e00000 	mvn	r0, #0
    5098:	eb0042e0 	bl	15c20 <exit>
    509c:	e5990000 	ldr	r0, [r9]
            gl->POTRF = 0.0;
            for (dir = XDIR; dir <= ZDIR; dir++)
                gl->SUM[dir] = 0.0;
        }

        if ((ProcID == 0) && (i >= 2)) {
    50a0:	e58d6048 	str	r6, [sp, #72]	; 0x48
    50a4:	eafffebe 	b	4ba4 <MDMAIN+0x2f0>
                UNLOCK(gl->IOLock);
            }

        }

        BARRIER(gl->start, NumProcs);
    50a8:	e16f4f14 	clz	r4, r4
    50ac:	e1a042a4 	lsr	r4, r4, #5
    50b0:	e5834060 	str	r4, [r3, #96]	; 0x60
    50b4:	e583c05c 	str	ip, [r3, #92]	; 0x5c
    50b8:	e2830054 	add	r0, r3, #84	; 0x54
    50bc:	ebffee05 	bl	8d8 <pthread_cond_broadcast>
    50c0:	eaffffd8 	b	5028 <MDMAIN+0x774>
#ifdef SIM_SOCLIB
        if (ProcID==0) printf("---[%s: B4 ok \n",__func__);
#endif

        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->intraend);
    50c4:	e28da098 	add	sl, sp, #152	; 0x98
    50c8:	e3a01000 	mov	r1, #0
    50cc:	e1a0000a 	mov	r0, sl
    50d0:	eb00488b 	bl	17304 <gettimeofday>
            gl->intratime += gl->intraend - gl->interend;
        }

        TKIN=TKIN+gl->SUM[0]+gl->SUM[1]+gl->SUM[2];
    50d4:	e1cd03d8 	ldrd	r0, [sp, #56]	; 0x38
#ifdef SIM_SOCLIB
        if (ProcID==0) printf("---[%s: B4 ok \n",__func__);
#endif

        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->intraend);
    50d8:	e59d2098 	ldr	r2, [sp, #152]	; 0x98
    50dc:	e59d309c 	ldr	r3, [sp, #156]	; 0x9c
    50e0:	e59fc3dc 	ldr	ip, [pc, #988]	; 54c4 <MDMAIN+0xc10>
    50e4:	e5994000 	ldr	r4, [r9]
    50e8:	e02c329c 	mla	ip, ip, r2, r3
            gl->intratime += gl->intraend - gl->interend;
        }

        TKIN=TKIN+gl->SUM[0]+gl->SUM[1]+gl->SUM[2];
    50ec:	e1c42ad8 	ldrd	r2, [r4, #168]	; 0xa8
        if (ProcID==0) printf("---[%s: B4 ok \n",__func__);
#endif

        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->intraend);
            gl->intratime += gl->intraend - gl->interend;
    50f0:	e594b0f4 	ldr	fp, [r4, #244]	; 0xf4
    50f4:	e594e0fc 	ldr	lr, [r4, #252]	; 0xfc
#ifdef SIM_SOCLIB
        if (ProcID==0) printf("---[%s: B4 ok \n",__func__);
#endif

        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->intraend);
    50f8:	e584c0f0 	str	ip, [r4, #240]	; 0xf0
            gl->intratime += gl->intraend - gl->interend;
    50fc:	e06eb00b 	rsb	fp, lr, fp
    5100:	e08be00c 	add	lr, fp, ip
    5104:	e584e0f4 	str	lr, [r4, #244]	; 0xf4
        }

        TKIN=TKIN+gl->SUM[0]+gl->SUM[1]+gl->SUM[2];
    5108:	eb003d78 	bl	146f0 <__adddf3>
    510c:	e1c42bd0 	ldrd	r2, [r4, #176]	; 0xb0
    5110:	eb003d76 	bl	146f0 <__adddf3>
    5114:	e1c42bd8 	ldrd	r2, [r4, #184]	; 0xb8
    5118:	eb003d74 	bl	146f0 <__adddf3>
        TVIR=TVIR-gl->VIR;
    511c:	e1c42ad0 	ldrd	r2, [r4, #160]	; 0xa0
        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->intraend);
            gl->intratime += gl->intraend - gl->interend;
        }

        TKIN=TKIN+gl->SUM[0]+gl->SUM[1]+gl->SUM[2];
    5120:	e1cd03f8 	strd	r0, [sp, #56]	; 0x38
        TVIR=TVIR-gl->VIR;
    5124:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    5128:	eb003d6f 	bl	146ec <__aeabi_dsub>
    512c:	e1cd04f0 	strd	r0, [sp, #64]	; 0x40

        /* CHECK if  PRINTING AND/OR SAVING IS TO BE DONE */

        if ( ((i % NPRINT) == 0) || ((NSAVE > 0) && ((i % NSAVE) == 0))) {
    5130:	e1a00007 	mov	r0, r7
    5134:	e59d1088 	ldr	r1, [sp, #136]	; 0x88
    5138:	eb003d60 	bl	146c0 <__aeabi_idivmod>
    513c:	e3510000 	cmp	r1, #0
    5140:	e58d1078 	str	r1, [sp, #120]	; 0x78
    5144:	1affff37 	bne	4e28 <MDMAIN+0x574>
            /* if so, call poteng to compute potential energy.  Note
               that we are attributing all the time in poteng to intermolecular
               computation although some of it is intramolecular (see poteng.C) */

            if ((ProcID == 0) && (i >= 2)) {
                CLOCK(gl->interstart);
    5148:	e3a01000 	mov	r1, #0
    514c:	e1a0000a 	mov	r0, sl
    5150:	eb00486b 	bl	17304 <gettimeofday>
    5154:	e59d3098 	ldr	r3, [sp, #152]	; 0x98
    5158:	e59d209c 	ldr	r2, [sp, #156]	; 0x9c
    515c:	e59f1360 	ldr	r1, [pc, #864]	; 54c4 <MDMAIN+0xc10>
    5160:	e5994000 	ldr	r4, [r9]
    5164:	e0232391 	mla	r3, r1, r3, r2
    5168:	e58430f8 	str	r3, [r4, #248]	; 0xf8
    516c:	eaffff38 	b	4e54 <MDMAIN+0x5a0>

        KINETI(gl->SUM,HMAS,OMAS,ProcID);

        BARRIER(gl->start, NumProcs);
#ifdef SIM_SOCLIB
        if (ProcID==0) printf("---[%s: B4 ok \n",__func__);
    5170:	e59f1348 	ldr	r1, [pc, #840]	; 54c0 <MDMAIN+0xc0c>
    5174:	e59f036c 	ldr	r0, [pc, #876]	; 54e8 <MDMAIN+0xc34>
    5178:	eb004e35 	bl	18a54 <printf>
    517c:	eaffff13 	b	4dd0 <MDMAIN+0x51c>
        BARRIER(gl->start, NumProcs);
#ifdef SIM_SOCLIB
        if (ProcID==0) printf("---[%s: B6 ok \n",__func__);
#endif
        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->trackend);
    5180:	e3a01000 	mov	r1, #0
    5184:	e28d0098 	add	r0, sp, #152	; 0x98
    5188:	eb00485d 	bl	17304 <gettimeofday>
    518c:	e59d109c 	ldr	r1, [sp, #156]	; 0x9c
    5190:	e59d2098 	ldr	r2, [sp, #152]	; 0x98
    5194:	e59f0328 	ldr	r0, [pc, #808]	; 54c4 <MDMAIN+0xc10>
    5198:	e5993000 	ldr	r3, [r9]
    519c:	e0221290 	mla	r2, r0, r2, r1
            gl->tracktime += gl->trackend - gl->trackstart;
    51a0:	e59300e8 	ldr	r0, [r3, #232]	; 0xe8
    51a4:	e59310e0 	ldr	r1, [r3, #224]	; 0xe0
        BARRIER(gl->start, NumProcs);
#ifdef SIM_SOCLIB
        if (ProcID==0) printf("---[%s: B6 ok \n",__func__);
#endif
        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->trackend);
    51a8:	e58320e4 	str	r2, [r3, #228]	; 0xe4
            gl->tracktime += gl->trackend - gl->trackstart;
    51ac:	e0611000 	rsb	r1, r1, r0
    51b0:	e0812002 	add	r2, r1, r2
    51b4:	e58320e8 	str	r2, [r3, #232]	; 0xe8
    51b8:	eaffffa2 	b	5048 <MDMAIN+0x794>

        }

        BARRIER(gl->start, NumProcs);
#ifdef SIM_SOCLIB
        if (ProcID==0) printf("---[%s: B6 ok \n",__func__);
    51bc:	e59f12fc 	ldr	r1, [pc, #764]	; 54c0 <MDMAIN+0xc0c>
    51c0:	e59f0324 	ldr	r0, [pc, #804]	; 54ec <MDMAIN+0xc38>
    51c4:	eb004e22 	bl	18a54 <printf>
    51c8:	eaffff9b 	b	503c <MDMAIN+0x788>
            CLOCK(gl->intrastart);
        }

        BARRIER(gl->start, NumProcs);
#ifdef SIM_SOCLIB
        if (ProcID==0) printf("---[%s: B2 ok \n",__func__);
    51cc:	e59f12ec 	ldr	r1, [pc, #748]	; 54c0 <MDMAIN+0xc0c>
    51d0:	e59f0318 	ldr	r0, [pc, #792]	; 54f0 <MDMAIN+0xc3c>
    51d4:	eb004e1e 	bl	18a54 <printf>
    51d8:	eafffe93 	b	4c2c <MDMAIN+0x378>

        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->intrastart);
        }

        BARRIER(gl->start, NumProcs);
    51dc:	e16f4f14 	clz	r4, r4
    51e0:	e1a042a4 	lsr	r4, r4, #5
    51e4:	e5834060 	str	r4, [r3, #96]	; 0x60
    51e8:	e583c05c 	str	ip, [r3, #92]	; 0x5c
    51ec:	e2830054 	add	r0, r3, #84	; 0x54
    51f0:	ebffedb8 	bl	8d8 <pthread_cond_broadcast>
    51f4:	eafffe87 	b	4c18 <MDMAIN+0x364>

        BNDRY(ProcID);

        KINETI(gl->SUM,HMAS,OMAS,ProcID);

        BARRIER(gl->start, NumProcs);
    51f8:	e16f4f14 	clz	r4, r4
    51fc:	e1a042a4 	lsr	r4, r4, #5
    5200:	e5834060 	str	r4, [r3, #96]	; 0x60
    5204:	e583105c 	str	r1, [r3, #92]	; 0x5c
    5208:	e2830054 	add	r0, r3, #84	; 0x54
    520c:	ebffedb1 	bl	8d8 <pthread_cond_broadcast>
    5210:	eafffee9 	b	4dbc <MDMAIN+0x508>
#ifdef SIM_SOCLIB
        if (ProcID==0) printf("---[%s: B3 ok \n",__func__);
#endif

        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->intraend);
    5214:	e28da098 	add	sl, sp, #152	; 0x98
    5218:	e3a01000 	mov	r1, #0
    521c:	e1a0000a 	mov	r0, sl
    5220:	eb004837 	bl	17304 <gettimeofday>
    5224:	e59f4298 	ldr	r4, [pc, #664]	; 54c4 <MDMAIN+0xc10>
    5228:	e59d1098 	ldr	r1, [sp, #152]	; 0x98
    522c:	e59d209c 	ldr	r2, [sp, #156]	; 0x9c
    5230:	e5993000 	ldr	r3, [r9]
    5234:	e0222194 	mla	r2, r4, r1, r2
            gl->intratime += gl->intraend - gl->intrastart;
    5238:	e59300f4 	ldr	r0, [r3, #244]	; 0xf4
    523c:	e59310ec 	ldr	r1, [r3, #236]	; 0xec
#ifdef SIM_SOCLIB
        if (ProcID==0) printf("---[%s: B3 ok \n",__func__);
#endif

        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->intraend);
    5240:	e58320f0 	str	r2, [r3, #240]	; 0xf0
            gl->intratime += gl->intraend - gl->intrastart;
    5244:	e0611000 	rsb	r1, r1, r0
    5248:	e0812002 	add	r2, r1, r2
    524c:	e58320f4 	str	r2, [r3, #244]	; 0xf4
        }

        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->interstart);
    5250:	e3a01000 	mov	r1, #0
    5254:	e1a0000a 	mov	r0, sl
    5258:	eb004829 	bl	17304 <gettimeofday>
    525c:	e59d1098 	ldr	r1, [sp, #152]	; 0x98
    5260:	e59d209c 	ldr	r2, [sp, #156]	; 0x9c
    5264:	e5993000 	ldr	r3, [r9]
    5268:	e0222194 	mla	r2, r4, r1, r2
        }

        INTERF(FORCES,&gl->VIR,ProcID);
    526c:	e3a00007 	mov	r0, #7
    5270:	e28310a0 	add	r1, r3, #160	; 0xa0
            CLOCK(gl->intraend);
            gl->intratime += gl->intraend - gl->intrastart;
        }

        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->interstart);
    5274:	e58320f8 	str	r2, [r3, #248]	; 0xf8
        }

        INTERF(FORCES,&gl->VIR,ProcID);
    5278:	e1a02005 	mov	r2, r5
    527c:	eb000908 	bl	76a4 <INTERF>

        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->interend);
    5280:	e3a01000 	mov	r1, #0
    5284:	e1a0000a 	mov	r0, sl
    5288:	eb00481d 	bl	17304 <gettimeofday>
    528c:	e59d1098 	ldr	r1, [sp, #152]	; 0x98
    5290:	e59d209c 	ldr	r2, [sp, #156]	; 0x9c
    5294:	e5993000 	ldr	r3, [r9]
    5298:	e0242194 	mla	r4, r4, r1, r2
            gl->intertime += gl->interend - gl->interstart;
    529c:	e5931100 	ldr	r1, [r3, #256]	; 0x100
    52a0:	e59320f8 	ldr	r2, [r3, #248]	; 0xf8
        }

        INTERF(FORCES,&gl->VIR,ProcID);

        if ((ProcID == 0) && (i >= 2)) {
            CLOCK(gl->interend);
    52a4:	e58340fc 	str	r4, [r3, #252]	; 0xfc
            gl->intertime += gl->interend - gl->interstart;
    52a8:	e0622001 	rsb	r2, r2, r1
    52ac:	e0824004 	add	r4, r2, r4
    52b0:	e5834100 	str	r4, [r3, #256]	; 0x100
    52b4:	eafffe90 	b	4cfc <MDMAIN+0x448>
        PREDIC(TLC,NORD1,ProcID);
        INTRAF(&gl->VIR,ProcID);

        BARRIER(gl->start, NumProcs);
#ifdef SIM_SOCLIB
        if (ProcID==0) printf("---[%s: B3 ok \n",__func__);
    52b8:	e59f1200 	ldr	r1, [pc, #512]	; 54c0 <MDMAIN+0xc0c>
    52bc:	e59f0230 	ldr	r0, [pc, #560]	; 54f4 <MDMAIN+0xc40>
    52c0:	eb004de3 	bl	18a54 <printf>
    52c4:	eafffe84 	b	4cdc <MDMAIN+0x428>
        if (ProcID==0) printf("---[%s: B2 ok \n",__func__);
#endif
        PREDIC(TLC,NORD1,ProcID);
        INTRAF(&gl->VIR,ProcID);

        BARRIER(gl->start, NumProcs);
    52c8:	e16f4f14 	clz	r4, r4
    52cc:	e1a042a4 	lsr	r4, r4, #5
    52d0:	e5834060 	str	r4, [r3, #96]	; 0x60
    52d4:	e583105c 	str	r1, [r3, #92]	; 0x5c
    52d8:	e2830054 	add	r0, r3, #84	; 0x54
    52dc:	ebffed7d 	bl	8d8 <pthread_cond_broadcast>
    52e0:	eafffe78 	b	4cc8 <MDMAIN+0x414>
                CLOCK(gl->interstart);
            }

            POTENG(&gl->POTA,&gl->POTR,&gl->POTRF,ProcID);

            BARRIER(gl->start, NumProcs);
    52e4:	e16f4f14 	clz	r4, r4
    52e8:	e1a042a4 	lsr	r4, r4, #5
    52ec:	e5834060 	str	r4, [r3, #96]	; 0x60
    52f0:	e583105c 	str	r1, [r3, #92]	; 0x5c
    52f4:	e2830054 	add	r0, r3, #84	; 0x54
    52f8:	ebffed76 	bl	8d8 <pthread_cond_broadcast>
    52fc:	eafffef8 	b	4ee4 <MDMAIN+0x630>
    5300:	e28da098 	add	sl, sp, #152	; 0x98
    5304:	eaffff8f 	b	5148 <MDMAIN+0x894>
            XTT=POTA+POTR+POTRF+TEN;

            /* if it is time to print output as well ... */
            if ((i % NPRINT) == 0 && ProcID == 0) {
                LOCK(gl->IOLock);
                fprintf(six,"     %5ld %14.5lf %12.5lf %12.5lf %12.5lf \n"
    5308:	e59fa1e8 	ldr	sl, [pc, #488]	; 54f8 <MDMAIN+0xc44>
            TEN=(gl->SUM[0]+gl->SUM[1]+gl->SUM[2])*FKIN;
            XTT=POTA+POTR+POTRF+TEN;

            /* if it is time to print output as well ... */
            if ((i % NPRINT) == 0 && ProcID == 0) {
                LOCK(gl->IOLock);
    530c:	e1a00004 	mov	r0, r4
    5310:	ebffed37 	bl	7f4 <pthread_mutex_lock>
                fprintf(six,"     %5ld %14.5lf %12.5lf %12.5lf %12.5lf \n"
    5314:	e1cd27d0 	ldrd	r2, [sp, #112]	; 0x70
    5318:	e59a0000 	ldr	r0, [sl]
    531c:	e59f11d8 	ldr	r1, [pc, #472]	; 54fc <MDMAIN+0xc48>
    5320:	e1cd20f0 	strd	r2, [sp]
    5324:	e1cd25d8 	ldrd	r2, [sp, #88]	; 0x58
    5328:	e1cd20f8 	strd	r2, [sp, #8]
    532c:	e1cd26d0 	ldrd	r2, [sp, #96]	; 0x60
    5330:	e1cd21f0 	strd	r2, [sp, #16]
    5334:	e1cd26d8 	ldrd	r2, [sp, #104]	; 0x68
    5338:	e1cd21f8 	strd	r2, [sp, #24]
    533c:	e1a02007 	mov	r2, r7
    5340:	eb00453c 	bl	16838 <fprintf>

            POTA=gl->POTA*FPOT;
            POTR=gl->POTR*FPOT;
            POTRF=gl->POTRF*FPOT;
            XVIR=TVIR*FPOT*0.50/TTMV;
            AVGT=TKIN*FKIN*TEMP*2.00/(3.00*TTMV);
    5344:	e1cd25d0 	ldrd	r2, [sp, #80]	; 0x50
    5348:	e1cd03d8 	ldrd	r0, [sp, #56]	; 0x38
    534c:	eb003deb 	bl	14b00 <__aeabi_dmul>
    5350:	e1cd28d0 	ldrd	r2, [sp, #128]	; 0x80
    5354:	eb003de9 	bl	14b00 <__aeabi_dmul>
    5358:	e1a02000 	mov	r2, r0
    535c:	e1a03001 	mov	r3, r1
    5360:	eb003ce2 	bl	146f0 <__adddf3>
    5364:	e3a02000 	mov	r2, #0
    5368:	e1cd05f0 	strd	r0, [sp, #80]	; 0x50
    536c:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
    5370:	e59f3188 	ldr	r3, [pc, #392]	; 5500 <MDMAIN+0xc4c>
    5374:	eb003de1 	bl	14b00 <__aeabi_dmul>
    5378:	e1a02000 	mov	r2, r0
    537c:	e1a03001 	mov	r3, r1
    5380:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    5384:	eb003e81 	bl	14d90 <__aeabi_ddiv>
            }

            POTA=gl->POTA*FPOT;
            POTR=gl->POTR*FPOT;
            POTRF=gl->POTRF*FPOT;
            XVIR=TVIR*FPOT*0.50/TTMV;
    5388:	e1cd22d0 	ldrd	r2, [sp, #32]
            /* if it is time to print output as well ... */
            if ((i % NPRINT) == 0 && ProcID == 0) {
                LOCK(gl->IOLock);
                fprintf(six,"     %5ld %14.5lf %12.5lf %12.5lf %12.5lf \n"
                        ,i,TEN,POTA,POTR,POTRF);
                fprintf(six," %16.3lf %16.5lf %16.5lf\n",XTT,AVGT,XVIR);
    538c:	e1cd00f0 	strd	r0, [sp]
            }

            POTA=gl->POTA*FPOT;
            POTR=gl->POTR*FPOT;
            POTRF=gl->POTRF*FPOT;
            XVIR=TVIR*FPOT*0.50/TTMV;
    5390:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    5394:	eb003dd9 	bl	14b00 <__aeabi_dmul>
    5398:	e3a02000 	mov	r2, #0
    539c:	e59f3160 	ldr	r3, [pc, #352]	; 5504 <MDMAIN+0xc50>
    53a0:	eb003dd6 	bl	14b00 <__aeabi_dmul>
    53a4:	e1cd23d0 	ldrd	r2, [sp, #48]	; 0x30
    53a8:	eb003e78 	bl	14d90 <__aeabi_ddiv>
            /* if it is time to print output as well ... */
            if ((i % NPRINT) == 0 && ProcID == 0) {
                LOCK(gl->IOLock);
                fprintf(six,"     %5ld %14.5lf %12.5lf %12.5lf %12.5lf \n"
                        ,i,TEN,POTA,POTR,POTRF);
                fprintf(six," %16.3lf %16.5lf %16.5lf\n",XTT,AVGT,XVIR);
    53ac:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
    53b0:	e59ae000 	ldr	lr, [sl]
    53b4:	e1cd00f8 	strd	r0, [sp, #8]
    53b8:	e1a0000e 	mov	r0, lr
    53bc:	e59f1144 	ldr	r1, [pc, #324]	; 5508 <MDMAIN+0xc54>
    53c0:	eb00451c 	bl	16838 <fprintf>
                fflush(six);
    53c4:	e59a0000 	ldr	r0, [sl]
    53c8:	eb004354 	bl	16120 <fflush>
                UNLOCK(gl->IOLock);
    53cc:	e5990000 	ldr	r0, [r9]
    53d0:	ebffefe1 	bl	135c <pthread_mutex_unlock>
    53d4:	e5994000 	ldr	r4, [r9]
    53d8:	eafffef5 	b	4fb4 <MDMAIN+0x700>
#ifdef SIM_SOCLIB
            if (ProcID==0) printf("---[%s: B5 ok \n",__func__);
#endif

            if ((ProcID == 0) && (i >= 2)) {
                CLOCK(gl->interend);
    53dc:	e3a01000 	mov	r1, #0
    53e0:	e28d0098 	add	r0, sp, #152	; 0x98
    53e4:	eb0047c6 	bl	17304 <gettimeofday>
    53e8:	e59d209c 	ldr	r2, [sp, #156]	; 0x9c
    53ec:	e59d3098 	ldr	r3, [sp, #152]	; 0x98
    53f0:	e59f10cc 	ldr	r1, [pc, #204]	; 54c4 <MDMAIN+0xc10>
    53f4:	e5994000 	ldr	r4, [r9]
    53f8:	e0232391 	mla	r3, r1, r3, r2
                gl->intertime += gl->interend - gl->interstart;
    53fc:	e5941100 	ldr	r1, [r4, #256]	; 0x100
    5400:	e59420f8 	ldr	r2, [r4, #248]	; 0xf8
#ifdef SIM_SOCLIB
            if (ProcID==0) printf("---[%s: B5 ok \n",__func__);
#endif

            if ((ProcID == 0) && (i >= 2)) {
                CLOCK(gl->interend);
    5404:	e58430fc 	str	r3, [r4, #252]	; 0xfc
                gl->intertime += gl->interend - gl->interstart;
    5408:	e0622001 	rsb	r2, r2, r1
    540c:	e0823003 	add	r3, r2, r3
    5410:	e5843100 	str	r3, [r4, #256]	; 0x100
    5414:	eafffebb 	b	4f08 <MDMAIN+0x654>

            POTENG(&gl->POTA,&gl->POTR,&gl->POTRF,ProcID);

            BARRIER(gl->start, NumProcs);
#ifdef SIM_SOCLIB
            if (ProcID==0) printf("---[%s: B5 ok \n",__func__);
    5418:	e59f10a0 	ldr	r1, [pc, #160]	; 54c0 <MDMAIN+0xc0c>
    541c:	e59f00e8 	ldr	r0, [pc, #232]	; 550c <MDMAIN+0xc58>
    5420:	eb004d8b 	bl	18a54 <printf>
    5424:	eafffeb3 	b	4ef8 <MDMAIN+0x644>
        if (ProcID == 0) {
            long dir;
            if (i >= 2) {
                CLOCK(gl->trackstart);
            }
            gl->VIR = 0.0;
    5428:	e3a02000 	mov	r2, #0
    542c:	e3a03000 	mov	r3, #0
            gl->POTRF = 0.0;
            for (dir = XDIR; dir <= ZDIR; dir++)
                gl->SUM[dir] = 0.0;
        }

        if ((ProcID == 0) && (i >= 2)) {
    5430:	e3a0a000 	mov	sl, #0
    5434:	e5990000 	ldr	r0, [r9]
    5438:	e58da048 	str	sl, [sp, #72]	; 0x48
        if (ProcID == 0) {
            long dir;
            if (i >= 2) {
                CLOCK(gl->trackstart);
            }
            gl->VIR = 0.0;
    543c:	e1c02af0 	strd	r2, [r0, #160]	; 0xa0
            gl->POTA = 0.0;
    5440:	e1c02cf0 	strd	r2, [r0, #192]	; 0xc0
            gl->POTR = 0.0;
    5444:	e1c02cf8 	strd	r2, [r0, #200]	; 0xc8
            gl->POTRF = 0.0;
    5448:	e1c02df0 	strd	r2, [r0, #208]	; 0xd0
            for (dir = XDIR; dir <= ZDIR; dir++)
                gl->SUM[dir] = 0.0;
    544c:	e1c02af8 	strd	r2, [r0, #168]	; 0xa8
    5450:	e1c02bf0 	strd	r2, [r0, #176]	; 0xb0
    5454:	e1c02bf8 	strd	r2, [r0, #184]	; 0xb8
    5458:	eafffdd1 	b	4ba4 <MDMAIN+0x2f0>
    545c:	e1a0000a 	mov	r0, sl
    5460:	e1a0100b 	mov	r1, fp

    } /* for i */

    return(XTT);

} /* mdmain.c */
    5464:	e28dd0a4 	add	sp, sp, #164	; 0xa4
    5468:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

    INTERF(ACC,&gl->VIR,ProcID);

    BARRIER(gl->start, NumProcs);
#ifdef SIM_SOCLIB
    if (ProcID==0) printf("---[%s: B1 ok \n",__func__);
    546c:	e59f104c 	ldr	r1, [pc, #76]	; 54c0 <MDMAIN+0xc0c>
    5470:	e59f0098 	ldr	r0, [pc, #152]	; 5510 <MDMAIN+0xc5c>
    5474:	eb004d76 	bl	18a54 <printf>
    5478:	eafffd92 	b	4ac8 <MDMAIN+0x214>
    if (ProcID==0) printf("---[%s: B0 ok \n",__func__);
#endif

    INTERF(ACC,&gl->VIR,ProcID);

    BARRIER(gl->start, NumProcs);
    547c:	e16f4f14 	clz	r4, r4
    5480:	e1a042a4 	lsr	r4, r4, #5
    5484:	e5834060 	str	r4, [r3, #96]	; 0x60
    5488:	e583105c 	str	r1, [r3, #92]	; 0x5c
    548c:	e2830054 	add	r0, r3, #84	; 0x54
    5490:	ebffed10 	bl	8d8 <pthread_cond_broadcast>
    5494:	eafffd85 	b	4ab0 <MDMAIN+0x1fc>

    INTRAF(&gl->VIR,ProcID);

    BARRIER(gl->start,NumProcs);
#ifdef SIM_SOCLIB
    if (ProcID==0) printf("---[%s: B0 ok \n",__func__);
    5498:	e59f1020 	ldr	r1, [pc, #32]	; 54c0 <MDMAIN+0xc0c>
    549c:	e59f0070 	ldr	r0, [pc, #112]	; 5514 <MDMAIN+0xc60>
    54a0:	eb004d6b 	bl	18a54 <printf>
    54a4:	eafffd5f 	b	4a28 <MDMAIN+0x174>
    54a8:	0013ef50 	.word	0x0013ef50
    54ac:	0013efcc 	.word	0x0013efcc
    54b0:	0013f3f0 	.word	0x0013f3f0
    54b4:	0013eec0 	.word	0x0013eec0
    54b8:	3ff00000 	.word	0x3ff00000
    54bc:	000328a8 	.word	0x000328a8
    54c0:	00032854 	.word	0x00032854
    54c4:	000f4240 	.word	0x000f4240
    54c8:	0013f0b0 	.word	0x0013f0b0
    54cc:	0013eef0 	.word	0x0013eef0
    54d0:	0013ef78 	.word	0x0013ef78
    54d4:	0013f418 	.word	0x0013f418
    54d8:	0013f510 	.word	0x0013f510
    54dc:	0013efb8 	.word	0x0013efb8
    54e0:	0013ef90 	.word	0x0013ef90
    54e4:	0003285c 	.word	0x0003285c
    54e8:	000328dc 	.word	0x000328dc
    54ec:	00032944 	.word	0x00032944
    54f0:	000328bc 	.word	0x000328bc
    54f4:	000328cc 	.word	0x000328cc
    54f8:	0013f3f4 	.word	0x0013f3f4
    54fc:	000328fc 	.word	0x000328fc
    5500:	40080000 	.word	0x40080000
    5504:	3fe00000 	.word	0x3fe00000
    5508:	00032928 	.word	0x00032928
    550c:	000328ec 	.word	0x000328ec
    5510:	00032898 	.word	0x00032898
    5514:	00032888 	.word	0x00032888

00005518 <CNSTNT>:
 *
 * N : NORDER + 1 = 7 for a sixth-order method
 * C : DIMENSION C(N,N)
 */
void CNSTNT(long N, double *C)
{
    5518:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    long NN,N1,K1;
    double TN,TK,CM;

    /* molecular constants for water in angstrom, radian, and a.m.u. */

    NATOMS = 3;
    551c:	e3a0e003 	mov	lr, #3
 *
 * N : NORDER + 1 = 7 for a sixth-order method
 * C : DIMENSION C(N,N)
 */
void CNSTNT(long N, double *C)
{
    5520:	e1a0c001 	mov	ip, r1
    long NN,N1,K1;
    double TN,TK,CM;

    /* molecular constants for water in angstrom, radian, and a.m.u. */

    NATOMS = 3;
    5524:	e59f15bc 	ldr	r1, [pc, #1468]	; 5ae8 <CNSTNT+0x5d0>
    ROH = 0.9572;
    5528:	e59f65bc 	ldr	r6, [pc, #1468]	; 5aec <CNSTNT+0x5d4>
    long NN,N1,K1;
    double TN,TK,CM;

    /* molecular constants for water in angstrom, radian, and a.m.u. */

    NATOMS = 3;
    552c:	e581e000 	str	lr, [r1]
    ROH = 0.9572;
    5530:	e59f75b8 	ldr	r7, [pc, #1464]	; 5af0 <CNSTNT+0x5d8>
    ROHI = ONE/ROH;
    5534:	e59f25b8 	ldr	r2, [pc, #1464]	; 5af4 <CNSTNT+0x5dc>
    5538:	e59f35b8 	ldr	r3, [pc, #1464]	; 5af8 <CNSTNT+0x5e0>
    double TN,TK,CM;

    /* molecular constants for water in angstrom, radian, and a.m.u. */

    NATOMS = 3;
    ROH = 0.9572;
    553c:	e59f15b8 	ldr	r1, [pc, #1464]	; 5afc <CNSTNT+0x5e4>
    ROHI = ONE/ROH;
    5540:	e59fe5b8 	ldr	lr, [pc, #1464]	; 5b00 <CNSTNT+0x5e8>
    double TN,TK,CM;

    /* molecular constants for water in angstrom, radian, and a.m.u. */

    NATOMS = 3;
    ROH = 0.9572;
    5544:	e1c160f0 	strd	r6, [r1]
    ROHI = ONE/ROH;
    5548:	e1ce20f0 	strd	r2, [lr]
    ROHI2 = ROHI*ROHI;
    554c:	e59f45b0 	ldr	r4, [pc, #1456]	; 5b04 <CNSTNT+0x5ec>
    5550:	e59f55b0 	ldr	r5, [pc, #1456]	; 5b08 <CNSTNT+0x5f0>
    ANGLE = 1.824218;
    5554:	e59fa5b0 	ldr	sl, [pc, #1456]	; 5b0c <CNSTNT+0x5f4>
    5558:	e59fb5b0 	ldr	fp, [pc, #1456]	; 5b10 <CNSTNT+0x5f8>
    /* molecular constants for water in angstrom, radian, and a.m.u. */

    NATOMS = 3;
    ROH = 0.9572;
    ROHI = ONE/ROH;
    ROHI2 = ROHI*ROHI;
    555c:	e59f15b0 	ldr	r1, [pc, #1456]	; 5b14 <CNSTNT+0x5fc>
    ANGLE = 1.824218;
    5560:	e59fe5b0 	ldr	lr, [pc, #1456]	; 5b18 <CNSTNT+0x600>
    /* molecular constants for water in angstrom, radian, and a.m.u. */

    NATOMS = 3;
    ROH = 0.9572;
    ROHI = ONE/ROH;
    ROHI2 = ROHI*ROHI;
    5564:	e1c140f0 	strd	r4, [r1]
    ANGLE = 1.824218;
    5568:	e1cea0f0 	strd	sl, [lr]
    OMAS = 15.99945;
    556c:	e59f15a8 	ldr	r1, [pc, #1448]	; 5b1c <CNSTNT+0x604>
    5570:	e59fa5a8 	ldr	sl, [pc, #1448]	; 5b20 <CNSTNT+0x608>
    5574:	e59fb5a8 	ldr	fp, [pc, #1448]	; 5b24 <CNSTNT+0x60c>
    HMAS = 1.007825;
    5578:	e59f25a8 	ldr	r2, [pc, #1448]	; 5b28 <CNSTNT+0x610>
    NATOMS = 3;
    ROH = 0.9572;
    ROHI = ONE/ROH;
    ROHI2 = ROHI*ROHI;
    ANGLE = 1.824218;
    OMAS = 15.99945;
    557c:	e1c1a0f0 	strd	sl, [r1]
    HMAS = 1.007825;
    5580:	e59f35a4 	ldr	r3, [pc, #1444]	; 5b2c <CNSTNT+0x614>
    WTMOL = OMAS+TWO*HMAS;
    5584:	e59f85a4 	ldr	r8, [pc, #1444]	; 5b30 <CNSTNT+0x618>
    5588:	e59f95a4 	ldr	r9, [pc, #1444]	; 5b34 <CNSTNT+0x61c>
    ROH = 0.9572;
    ROHI = ONE/ROH;
    ROHI2 = ROHI*ROHI;
    ANGLE = 1.824218;
    OMAS = 15.99945;
    HMAS = 1.007825;
    558c:	e59fe5a4 	ldr	lr, [pc, #1444]	; 5b38 <CNSTNT+0x620>
    WTMOL = OMAS+TWO*HMAS;
    5590:	e59f15a4 	ldr	r1, [pc, #1444]	; 5b3c <CNSTNT+0x624>
    ROH = 0.9572;
    ROHI = ONE/ROH;
    ROHI2 = ROHI*ROHI;
    ANGLE = 1.824218;
    OMAS = 15.99945;
    HMAS = 1.007825;
    5594:	e1ce20f0 	strd	r2, [lr]
    WTMOL = OMAS+TWO*HMAS;
    5598:	e1c180f0 	strd	r8, [r1]

    /* units used to scale variables (in c.g.s.) */

    UNITT = 1.0e-15;
    559c:	e59f659c 	ldr	r6, [pc, #1436]	; 5b40 <CNSTNT+0x628>
    55a0:	e59f759c 	ldr	r7, [pc, #1436]	; 5b44 <CNSTNT+0x62c>
    UNITL = 1.0e-8;
    55a4:	e59f459c 	ldr	r4, [pc, #1436]	; 5b48 <CNSTNT+0x630>
    55a8:	e59f559c 	ldr	r5, [pc, #1436]	; 5b4c <CNSTNT+0x634>
    HMAS = 1.007825;
    WTMOL = OMAS+TWO*HMAS;

    /* units used to scale variables (in c.g.s.) */

    UNITT = 1.0e-15;
    55ac:	e59fe59c 	ldr	lr, [pc, #1436]	; 5b50 <CNSTNT+0x638>
    UNITL = 1.0e-8;
    55b0:	e59f159c 	ldr	r1, [pc, #1436]	; 5b54 <CNSTNT+0x63c>
    HMAS = 1.007825;
    WTMOL = OMAS+TWO*HMAS;

    /* units used to scale variables (in c.g.s.) */

    UNITT = 1.0e-15;
    55b4:	e1ce60f0 	strd	r6, [lr]
    UNITL = 1.0e-8;
    55b8:	e1c140f0 	strd	r4, [r1]
    UNITM = 1.6605655e-24;
    55bc:	e59f2594 	ldr	r2, [pc, #1428]	; 5b58 <CNSTNT+0x640>
    55c0:	e59f3594 	ldr	r3, [pc, #1428]	; 5b5c <CNSTNT+0x644>
    BOLTZ = 1.380662e-16;
    55c4:	e59fa594 	ldr	sl, [pc, #1428]	; 5b60 <CNSTNT+0x648>
    55c8:	e59fb594 	ldr	fp, [pc, #1428]	; 5b64 <CNSTNT+0x64c>

    /* units used to scale variables (in c.g.s.) */

    UNITT = 1.0e-15;
    UNITL = 1.0e-8;
    UNITM = 1.6605655e-24;
    55cc:	e59fe594 	ldr	lr, [pc, #1428]	; 5b68 <CNSTNT+0x650>
    BOLTZ = 1.380662e-16;
    55d0:	e59f1594 	ldr	r1, [pc, #1428]	; 5b6c <CNSTNT+0x654>

    /* units used to scale variables (in c.g.s.) */

    UNITT = 1.0e-15;
    UNITL = 1.0e-8;
    UNITM = 1.6605655e-24;
    55d4:	e1ce20f0 	strd	r2, [lr]
    BOLTZ = 1.380662e-16;
    55d8:	e1c1a0f0 	strd	sl, [r1]
    AVGNO = 6.022045e23;
    55dc:	e59f658c 	ldr	r6, [pc, #1420]	; 5b70 <CNSTNT+0x658>
    55e0:	e59f758c 	ldr	r7, [pc, #1420]	; 5b74 <CNSTNT+0x65c>

    /* force constants scaled (divided) by (UNITM/UNITT**2) */

    FC11 =  0.512596;
    55e4:	e59f858c 	ldr	r8, [pc, #1420]	; 5b78 <CNSTNT+0x660>
    55e8:	e59f958c 	ldr	r9, [pc, #1420]	; 5b7c <CNSTNT+0x664>

    UNITT = 1.0e-15;
    UNITL = 1.0e-8;
    UNITM = 1.6605655e-24;
    BOLTZ = 1.380662e-16;
    AVGNO = 6.022045e23;
    55ec:	e59fe58c 	ldr	lr, [pc, #1420]	; 5b80 <CNSTNT+0x668>

    /* force constants scaled (divided) by (UNITM/UNITT**2) */

    FC11 =  0.512596;
    55f0:	e59f158c 	ldr	r1, [pc, #1420]	; 5b84 <CNSTNT+0x66c>

    UNITT = 1.0e-15;
    UNITL = 1.0e-8;
    UNITM = 1.6605655e-24;
    BOLTZ = 1.380662e-16;
    AVGNO = 6.022045e23;
    55f4:	e1ce60f0 	strd	r6, [lr]

    /* force constants scaled (divided) by (UNITM/UNITT**2) */

    FC11 =  0.512596;
    55f8:	e1c180f0 	strd	r8, [r1]
    FC33 =  0.048098;
    55fc:	e59f2584 	ldr	r2, [pc, #1412]	; 5b88 <CNSTNT+0x670>
    5600:	e59f3584 	ldr	r3, [pc, #1412]	; 5b8c <CNSTNT+0x674>
    FC12 = -0.005823;
    5604:	e59f4584 	ldr	r4, [pc, #1412]	; 5b90 <CNSTNT+0x678>
    5608:	e59f5584 	ldr	r5, [pc, #1412]	; 5b94 <CNSTNT+0x67c>
    AVGNO = 6.022045e23;

    /* force constants scaled (divided) by (UNITM/UNITT**2) */

    FC11 =  0.512596;
    FC33 =  0.048098;
    560c:	e59fe584 	ldr	lr, [pc, #1412]	; 5b98 <CNSTNT+0x680>
    FC12 = -0.005823;
    5610:	e59f1584 	ldr	r1, [pc, #1412]	; 5b9c <CNSTNT+0x684>
    AVGNO = 6.022045e23;

    /* force constants scaled (divided) by (UNITM/UNITT**2) */

    FC11 =  0.512596;
    FC33 =  0.048098;
    5614:	e1ce20f0 	strd	r2, [lr]
    FC12 = -0.005823;
    5618:	e1c140f0 	strd	r4, [r1]
    FC13 =  0.016452;
    561c:	e59f657c 	ldr	r6, [pc, #1404]	; 5ba0 <CNSTNT+0x688>
    5620:	e59f757c 	ldr	r7, [pc, #1404]	; 5ba4 <CNSTNT+0x68c>
    FC111 = -0.57191;
    5624:	e59fa57c 	ldr	sl, [pc, #1404]	; 5ba8 <CNSTNT+0x690>
    5628:	e59fb57c 	ldr	fp, [pc, #1404]	; 5bac <CNSTNT+0x694>
    /* force constants scaled (divided) by (UNITM/UNITT**2) */

    FC11 =  0.512596;
    FC33 =  0.048098;
    FC12 = -0.005823;
    FC13 =  0.016452;
    562c:	e59fe57c 	ldr	lr, [pc, #1404]	; 5bb0 <CNSTNT+0x698>
    FC111 = -0.57191;
    5630:	e59f157c 	ldr	r1, [pc, #1404]	; 5bb4 <CNSTNT+0x69c>
    /* force constants scaled (divided) by (UNITM/UNITT**2) */

    FC11 =  0.512596;
    FC33 =  0.048098;
    FC12 = -0.005823;
    FC13 =  0.016452;
    5634:	e1ce60f0 	strd	r6, [lr]
    FC111 = -0.57191;
    5638:	e1c1a0f0 	strd	sl, [r1]
    FC333 = -0.007636;
    563c:	e59f2574 	ldr	r2, [pc, #1396]	; 5bb8 <CNSTNT+0x6a0>
    5640:	e59f3574 	ldr	r3, [pc, #1396]	; 5bbc <CNSTNT+0x6a4>
    FC112 = -0.001867;
    5644:	e59f8574 	ldr	r8, [pc, #1396]	; 5bc0 <CNSTNT+0x6a8>
    5648:	e59f9574 	ldr	r9, [pc, #1396]	; 5bc4 <CNSTNT+0x6ac>
    FC11 =  0.512596;
    FC33 =  0.048098;
    FC12 = -0.005823;
    FC13 =  0.016452;
    FC111 = -0.57191;
    FC333 = -0.007636;
    564c:	e59fe574 	ldr	lr, [pc, #1396]	; 5bc8 <CNSTNT+0x6b0>
    FC112 = -0.001867;
    5650:	e59f1574 	ldr	r1, [pc, #1396]	; 5bcc <CNSTNT+0x6b4>
    FC11 =  0.512596;
    FC33 =  0.048098;
    FC12 = -0.005823;
    FC13 =  0.016452;
    FC111 = -0.57191;
    FC333 = -0.007636;
    5654:	e1ce20f0 	strd	r2, [lr]
    FC112 = -0.001867;
    5658:	e1c180f0 	strd	r8, [r1]
    FC113 = -0.002047;
    565c:	e59f456c 	ldr	r4, [pc, #1388]	; 5bd0 <CNSTNT+0x6b8>
    5660:	e59f556c 	ldr	r5, [pc, #1388]	; 5bd4 <CNSTNT+0x6bc>
    FC123 = -0.03083;
    5664:	e59f656c 	ldr	r6, [pc, #1388]	; 5bd8 <CNSTNT+0x6c0>
    5668:	e59f756c 	ldr	r7, [pc, #1388]	; 5bdc <CNSTNT+0x6c4>
    FC12 = -0.005823;
    FC13 =  0.016452;
    FC111 = -0.57191;
    FC333 = -0.007636;
    FC112 = -0.001867;
    FC113 = -0.002047;
    566c:	e59fe56c 	ldr	lr, [pc, #1388]	; 5be0 <CNSTNT+0x6c8>
    FC123 = -0.03083;
    5670:	e59f156c 	ldr	r1, [pc, #1388]	; 5be4 <CNSTNT+0x6cc>
    FC12 = -0.005823;
    FC13 =  0.016452;
    FC111 = -0.57191;
    FC333 = -0.007636;
    FC112 = -0.001867;
    FC113 = -0.002047;
    5674:	e1ce40f0 	strd	r4, [lr]
    FC123 = -0.03083;
    5678:	e1c160f0 	strd	r6, [r1]
    FC133 = -0.0094245;
    567c:	e59f2564 	ldr	r2, [pc, #1380]	; 5be8 <CNSTNT+0x6d0>
    5680:	e59f3564 	ldr	r3, [pc, #1380]	; 5bec <CNSTNT+0x6d4>
    FC1111 =  0.8431;
    5684:	e59fa564 	ldr	sl, [pc, #1380]	; 5bf0 <CNSTNT+0x6d8>
    5688:	e59fb564 	ldr	fp, [pc, #1380]	; 5bf4 <CNSTNT+0x6dc>
    FC111 = -0.57191;
    FC333 = -0.007636;
    FC112 = -0.001867;
    FC113 = -0.002047;
    FC123 = -0.03083;
    FC133 = -0.0094245;
    568c:	e59fe564 	ldr	lr, [pc, #1380]	; 5bf8 <CNSTNT+0x6e0>
    FC1111 =  0.8431;
    5690:	e59f1564 	ldr	r1, [pc, #1380]	; 5bfc <CNSTNT+0x6e4>
    FC111 = -0.57191;
    FC333 = -0.007636;
    FC112 = -0.001867;
    FC113 = -0.002047;
    FC123 = -0.03083;
    FC133 = -0.0094245;
    5694:	e1ce20f0 	strd	r2, [lr]
    FC1111 =  0.8431;
    5698:	e1c1a0f0 	strd	sl, [r1]
    FC3333 = -0.00193;
    569c:	e59f455c 	ldr	r4, [pc, #1372]	; 5c00 <CNSTNT+0x6e8>
    56a0:	e59f555c 	ldr	r5, [pc, #1372]	; 5c04 <CNSTNT+0x6ec>
    FC1112 = -0.0030;
    56a4:	e59f855c 	ldr	r8, [pc, #1372]	; 5c08 <CNSTNT+0x6f0>
    56a8:	e59f955c 	ldr	r9, [pc, #1372]	; 5c0c <CNSTNT+0x6f4>
    FC112 = -0.001867;
    FC113 = -0.002047;
    FC123 = -0.03083;
    FC133 = -0.0094245;
    FC1111 =  0.8431;
    FC3333 = -0.00193;
    56ac:	e59fe55c 	ldr	lr, [pc, #1372]	; 5c10 <CNSTNT+0x6f8>
    FC1112 = -0.0030;
    56b0:	e59f155c 	ldr	r1, [pc, #1372]	; 5c14 <CNSTNT+0x6fc>
    FC112 = -0.001867;
    FC113 = -0.002047;
    FC123 = -0.03083;
    FC133 = -0.0094245;
    FC1111 =  0.8431;
    FC3333 = -0.00193;
    56b4:	e1ce40f0 	strd	r4, [lr]
    FC1112 = -0.0030;
    56b8:	e1c180f0 	strd	r8, [r1]
    FC1122 =  0.0036;
    56bc:	e59f2554 	ldr	r2, [pc, #1364]	; 5c18 <CNSTNT+0x700>
    56c0:	e59f3554 	ldr	r3, [pc, #1364]	; 5c1c <CNSTNT+0x704>
    FC1113 = -0.012;
    56c4:	e59f653c 	ldr	r6, [pc, #1340]	; 5c08 <CNSTNT+0x6f0>
    56c8:	e59f7550 	ldr	r7, [pc, #1360]	; 5c20 <CNSTNT+0x708>
    FC123 = -0.03083;
    FC133 = -0.0094245;
    FC1111 =  0.8431;
    FC3333 = -0.00193;
    FC1112 = -0.0030;
    FC1122 =  0.0036;
    56cc:	e59fe550 	ldr	lr, [pc, #1360]	; 5c24 <CNSTNT+0x70c>
    FC1113 = -0.012;
    56d0:	e59f1550 	ldr	r1, [pc, #1360]	; 5c28 <CNSTNT+0x710>
    FC123 = -0.03083;
    FC133 = -0.0094245;
    FC1111 =  0.8431;
    FC3333 = -0.00193;
    FC1112 = -0.0030;
    FC1122 =  0.0036;
    56d4:	e1ce20f0 	strd	r2, [lr]
    FC1113 = -0.012;
    56d8:	e1c160f0 	strd	r6, [r1]
    FC1123 =  0.0060;
    56dc:	e59f4524 	ldr	r4, [pc, #1316]	; 5c08 <CNSTNT+0x6f0>
    56e0:	e59f5544 	ldr	r5, [pc, #1348]	; 5c2c <CNSTNT+0x714>
    FC1133 = -0.0048;
    56e4:	e59fa544 	ldr	sl, [pc, #1348]	; 5c30 <CNSTNT+0x718>
    56e8:	e59fb544 	ldr	fp, [pc, #1348]	; 5c34 <CNSTNT+0x71c>
    FC1111 =  0.8431;
    FC3333 = -0.00193;
    FC1112 = -0.0030;
    FC1122 =  0.0036;
    FC1113 = -0.012;
    FC1123 =  0.0060;
    56ec:	e59fe544 	ldr	lr, [pc, #1348]	; 5c38 <CNSTNT+0x720>
    FC1133 = -0.0048;
    56f0:	e59f1544 	ldr	r1, [pc, #1348]	; 5c3c <CNSTNT+0x724>
    FC1111 =  0.8431;
    FC3333 = -0.00193;
    FC1112 = -0.0030;
    FC1122 =  0.0036;
    FC1113 = -0.012;
    FC1123 =  0.0060;
    56f4:	e1ce40f0 	strd	r4, [lr]
    FC1133 = -0.0048;
    56f8:	e1c1a0f0 	strd	sl, [r1]
    FC1233 =  0.0211;
    56fc:	e59f253c 	ldr	r2, [pc, #1340]	; 5c40 <CNSTNT+0x728>
    5700:	e59f353c 	ldr	r3, [pc, #1340]	; 5c44 <CNSTNT+0x72c>
    FC1333 =  0.006263;
    5704:	e59f853c 	ldr	r8, [pc, #1340]	; 5c48 <CNSTNT+0x730>
    5708:	e59f953c 	ldr	r9, [pc, #1340]	; 5c4c <CNSTNT+0x734>
    FC1112 = -0.0030;
    FC1122 =  0.0036;
    FC1113 = -0.012;
    FC1123 =  0.0060;
    FC1133 = -0.0048;
    FC1233 =  0.0211;
    570c:	e59fe53c 	ldr	lr, [pc, #1340]	; 5c50 <CNSTNT+0x738>
    FC1333 =  0.006263;
    5710:	e59f153c 	ldr	r1, [pc, #1340]	; 5c54 <CNSTNT+0x73c>
    FC1112 = -0.0030;
    FC1122 =  0.0036;
    FC1113 = -0.012;
    FC1123 =  0.0060;
    FC1133 = -0.0048;
    FC1233 =  0.0211;
    5714:	e1ce20f0 	strd	r2, [lr]
    FC1333 =  0.006263;
    5718:	e1c180f0 	strd	r8, [r1]

    /* water-water interaction parameters */

    QQ = 0.07152158;
    571c:	e59f4534 	ldr	r4, [pc, #1332]	; 5c58 <CNSTNT+0x740>
    5720:	e59f5534 	ldr	r5, [pc, #1332]	; 5c5c <CNSTNT+0x744>
    A1 = 455.313100;
    5724:	e59f6534 	ldr	r6, [pc, #1332]	; 5c60 <CNSTNT+0x748>
    5728:	e59f7534 	ldr	r7, [pc, #1332]	; 5c64 <CNSTNT+0x74c>
    FC1233 =  0.0211;
    FC1333 =  0.006263;

    /* water-water interaction parameters */

    QQ = 0.07152158;
    572c:	e59fe534 	ldr	lr, [pc, #1332]	; 5c68 <CNSTNT+0x750>
    A1 = 455.313100;
    5730:	e59f1534 	ldr	r1, [pc, #1332]	; 5c6c <CNSTNT+0x754>
    FC1233 =  0.0211;
    FC1333 =  0.006263;

    /* water-water interaction parameters */

    QQ = 0.07152158;
    5734:	e1ce40f0 	strd	r4, [lr]
    A1 = 455.313100;
    5738:	e1c160f0 	strd	r6, [r1]

    /*  calculate the coefficients of taylor series expansion */
    /*     for F(X), F"(X), F""(X), ...... (with DELTAT**N/N] included) */
    /*     in C(1,1),..... C(1,2),..... C(1,3),....... */

    C[1] = ONE;
    573c:	e3a06000 	mov	r6, #0

    /* water-water interaction parameters */

    QQ = 0.07152158;
    A1 = 455.313100;
    B1 = 5.15271070;
    5740:	e59f2528 	ldr	r2, [pc, #1320]	; 5c70 <CNSTNT+0x758>
    5744:	e59f3528 	ldr	r3, [pc, #1320]	; 5c74 <CNSTNT+0x75c>
    A2 = 0.27879839;
    5748:	e59fa528 	ldr	sl, [pc, #1320]	; 5c78 <CNSTNT+0x760>
    574c:	e59fb528 	ldr	fp, [pc, #1320]	; 5c7c <CNSTNT+0x764>

    /* water-water interaction parameters */

    QQ = 0.07152158;
    A1 = 455.313100;
    B1 = 5.15271070;
    5750:	e59fe528 	ldr	lr, [pc, #1320]	; 5c80 <CNSTNT+0x768>
    A2 = 0.27879839;
    5754:	e59f1528 	ldr	r1, [pc, #1320]	; 5c84 <CNSTNT+0x76c>

    /* water-water interaction parameters */

    QQ = 0.07152158;
    A1 = 455.313100;
    B1 = 5.15271070;
    5758:	e1ce20f0 	strd	r2, [lr]
    A2 = 0.27879839;
    575c:	e1c1a0f0 	strd	sl, [r1]
    B2 = 2.76084370;
    5760:	e59f4520 	ldr	r4, [pc, #1312]	; 5c88 <CNSTNT+0x770>
    5764:	e59f5520 	ldr	r5, [pc, #1312]	; 5c8c <CNSTNT+0x774>
    A3 = 0.60895706;
    5768:	e59f8520 	ldr	r8, [pc, #1312]	; 5c90 <CNSTNT+0x778>
    576c:	e59f9520 	ldr	r9, [pc, #1312]	; 5c94 <CNSTNT+0x77c>

    /*  calculate the coefficients of taylor series expansion */
    /*     for F(X), F"(X), F""(X), ...... (with DELTAT**N/N] included) */
    /*     in C(1,1),..... C(1,2),..... C(1,3),....... */

    C[1] = ONE;
    5770:	e59f7520 	ldr	r7, [pc, #1312]	; 5c98 <CNSTNT+0x780>

    QQ = 0.07152158;
    A1 = 455.313100;
    B1 = 5.15271070;
    A2 = 0.27879839;
    B2 = 2.76084370;
    5774:	e59fe520 	ldr	lr, [pc, #1312]	; 5c9c <CNSTNT+0x784>
    A3 = 0.60895706;
    5778:	e59f1520 	ldr	r1, [pc, #1312]	; 5ca0 <CNSTNT+0x788>

    QQ = 0.07152158;
    A1 = 455.313100;
    B1 = 5.15271070;
    A2 = 0.27879839;
    B2 = 2.76084370;
    577c:	e1ce40f0 	strd	r4, [lr]
    A3 = 0.60895706;
    5780:	e1c180f0 	strd	r8, [r1]

    /*  calculate the coefficients of taylor series expansion */
    /*     for F(X), F"(X), F""(X), ...... (with DELTAT**N/N] included) */
    /*     in C(1,1),..... C(1,2),..... C(1,3),....... */

    C[1] = ONE;
    5784:	e1cc60f8 	strd	r6, [ip, #8]
    A1 = 455.313100;
    B1 = 5.15271070;
    A2 = 0.27879839;
    B2 = 2.76084370;
    A3 = 0.60895706;
    B3 = 2.96189550;
    5788:	e59f2514 	ldr	r2, [pc, #1300]	; 5ca4 <CNSTNT+0x78c>
    578c:	e59f3514 	ldr	r3, [pc, #1300]	; 5ca8 <CNSTNT+0x790>
    A4 = 0.11447336;
    5790:	e59f6514 	ldr	r6, [pc, #1300]	; 5cac <CNSTNT+0x794>
    5794:	e59f7514 	ldr	r7, [pc, #1300]	; 5cb0 <CNSTNT+0x798>
    A1 = 455.313100;
    B1 = 5.15271070;
    A2 = 0.27879839;
    B2 = 2.76084370;
    A3 = 0.60895706;
    B3 = 2.96189550;
    5798:	e59fe514 	ldr	lr, [pc, #1300]	; 5cb4 <CNSTNT+0x79c>
    A4 = 0.11447336;
    579c:	e59f1514 	ldr	r1, [pc, #1300]	; 5cb8 <CNSTNT+0x7a0>
    A1 = 455.313100;
    B1 = 5.15271070;
    A2 = 0.27879839;
    B2 = 2.76084370;
    A3 = 0.60895706;
    B3 = 2.96189550;
    57a0:	e1ce20f0 	strd	r2, [lr]
    A4 = 0.11447336;
    57a4:	e1c160f0 	strd	r6, [r1]
    B4 = 2.23326410;
    57a8:	e59f450c 	ldr	r4, [pc, #1292]	; 5cbc <CNSTNT+0x7a4>
    57ac:	e59f550c 	ldr	r5, [pc, #1292]	; 5cc0 <CNSTNT+0x7a8>
    CM = 0.45682590;
    AB1 = A1*B1;
    57b0:	e59fa50c 	ldr	sl, [pc, #1292]	; 5cc4 <CNSTNT+0x7ac>
    57b4:	e59fb50c 	ldr	fp, [pc, #1292]	; 5cc8 <CNSTNT+0x7b0>
    A2 = 0.27879839;
    B2 = 2.76084370;
    A3 = 0.60895706;
    B3 = 2.96189550;
    A4 = 0.11447336;
    B4 = 2.23326410;
    57b8:	e59fe50c 	ldr	lr, [pc, #1292]	; 5ccc <CNSTNT+0x7b4>
    CM = 0.45682590;
    AB1 = A1*B1;
    57bc:	e59f150c 	ldr	r1, [pc, #1292]	; 5cd0 <CNSTNT+0x7b8>
    A2 = 0.27879839;
    B2 = 2.76084370;
    A3 = 0.60895706;
    B3 = 2.96189550;
    A4 = 0.11447336;
    B4 = 2.23326410;
    57c0:	e1ce40f0 	strd	r4, [lr]
    CM = 0.45682590;
    AB1 = A1*B1;
    57c4:	e1c1a0f0 	strd	sl, [r1]
    AB2 = A2*B2;
    57c8:	e59f2504 	ldr	r2, [pc, #1284]	; 5cd4 <CNSTNT+0x7bc>
    57cc:	e59f3504 	ldr	r3, [pc, #1284]	; 5cd8 <CNSTNT+0x7c0>
    57d0:	e59fe504 	ldr	lr, [pc, #1284]	; 5cdc <CNSTNT+0x7c4>
    AB3 = A3*B3;
    57d4:	e59f1504 	ldr	r1, [pc, #1284]	; 5ce0 <CNSTNT+0x7c8>
    57d8:	e59fa504 	ldr	sl, [pc, #1284]	; 5ce4 <CNSTNT+0x7cc>
    57dc:	e59fb504 	ldr	fp, [pc, #1284]	; 5ce8 <CNSTNT+0x7d0>
    B3 = 2.96189550;
    A4 = 0.11447336;
    B4 = 2.23326410;
    CM = 0.45682590;
    AB1 = A1*B1;
    AB2 = A2*B2;
    57e0:	e1ce20f0 	strd	r2, [lr]
    AB3 = A3*B3;
    57e4:	e1c1a0f0 	strd	sl, [r1]
    AB4 = A4*B4;
    57e8:	e59f64fc 	ldr	r6, [pc, #1276]	; 5cec <CNSTNT+0x7d4>
    57ec:	e59f74fc 	ldr	r7, [pc, #1276]	; 5cf0 <CNSTNT+0x7d8>
    C1 = ONE-CM;
    57f0:	e59f44fc 	ldr	r4, [pc, #1276]	; 5cf4 <CNSTNT+0x7dc>
    B4 = 2.23326410;
    CM = 0.45682590;
    AB1 = A1*B1;
    AB2 = A2*B2;
    AB3 = A3*B3;
    AB4 = A4*B4;
    57f4:	e59fe4fc 	ldr	lr, [pc, #1276]	; 5cf8 <CNSTNT+0x7e0>
    C1 = ONE-CM;
    57f8:	e59f14fc 	ldr	r1, [pc, #1276]	; 5cfc <CNSTNT+0x7e4>
    57fc:	e59f54fc 	ldr	r5, [pc, #1276]	; 5d00 <CNSTNT+0x7e8>
    B4 = 2.23326410;
    CM = 0.45682590;
    AB1 = A1*B1;
    AB2 = A2*B2;
    AB3 = A3*B3;
    AB4 = A4*B4;
    5800:	e1ce60f0 	strd	r6, [lr]
    C1 = ONE-CM;
    5804:	e1c140f0 	strd	r4, [r1]
    /*  calculate the coefficients of taylor series expansion */
    /*     for F(X), F"(X), F""(X), ...... (with DELTAT**N/N] included) */
    /*     in C(1,1),..... C(1,2),..... C(1,3),....... */

    C[1] = ONE;
    for (N1=2;N1<=N;N1++) {
    5808:	e3500001 	cmp	r0, #1
    AB1 = A1*B1;
    AB2 = A2*B2;
    AB3 = A3*B3;
    AB4 = A4*B4;
    C1 = ONE-CM;
    C2 = 0.50*CM;
    580c:	e59f84f0 	ldr	r8, [pc, #1264]	; 5d04 <CNSTNT+0x7ec>
    5810:	e59f94f0 	ldr	r9, [pc, #1264]	; 5d08 <CNSTNT+0x7f0>
    QQ2 = 2.00*QQ;
    5814:	e59f243c 	ldr	r2, [pc, #1084]	; 5c58 <CNSTNT+0x740>
    5818:	e59f34ec 	ldr	r3, [pc, #1260]	; 5d0c <CNSTNT+0x7f4>
    QQ4 = 2.00*QQ2;
    581c:	e59f6434 	ldr	r6, [pc, #1076]	; 5c58 <CNSTNT+0x740>
    5820:	e59f74e8 	ldr	r7, [pc, #1256]	; 5d10 <CNSTNT+0x7f8>
    AB1 = A1*B1;
    AB2 = A2*B2;
    AB3 = A3*B3;
    AB4 = A4*B4;
    C1 = ONE-CM;
    C2 = 0.50*CM;
    5824:	e59fe4e8 	ldr	lr, [pc, #1256]	; 5d14 <CNSTNT+0x7fc>
    QQ2 = 2.00*QQ;
    5828:	e59f44e8 	ldr	r4, [pc, #1256]	; 5d18 <CNSTNT+0x800>
    QQ4 = 2.00*QQ2;
    582c:	e59f14e8 	ldr	r1, [pc, #1256]	; 5d1c <CNSTNT+0x804>
 *
 * N : NORDER + 1 = 7 for a sixth-order method
 * C : DIMENSION C(N,N)
 */
void CNSTNT(long N, double *C)
{
    5830:	e24dd01c 	sub	sp, sp, #28
    5834:	d2400001 	suble	r0, r0, #1
    AB1 = A1*B1;
    AB2 = A2*B2;
    AB3 = A3*B3;
    AB4 = A4*B4;
    C1 = ONE-CM;
    C2 = 0.50*CM;
    5838:	e1ce80f0 	strd	r8, [lr]
    QQ2 = 2.00*QQ;
    583c:	e1c420f0 	strd	r2, [r4]
    QQ4 = 2.00*QQ2;
    5840:	e1c160f0 	strd	r6, [r1]
    5844:	d58d0014 	strle	r0, [sp, #20]
    /*  calculate the coefficients of taylor series expansion */
    /*     for F(X), F"(X), F""(X), ...... (with DELTAT**N/N] included) */
    /*     in C(1,1),..... C(1,2),..... C(1,3),....... */

    C[1] = ONE;
    for (N1=2;N1<=N;N1++) {
    5848:	da000039 	ble	5934 <CNSTNT+0x41c>
    584c:	e3a0b002 	mov	fp, #2
    5850:	e2406001 	sub	r6, r0, #1
    5854:	e1a09186 	lsl	r9, r6, #3
    5858:	e060ae80 	rsb	sl, r0, r0, lsl #29
    585c:	e28cc008 	add	ip, ip, #8
    5860:	e2897008 	add	r7, r9, #8
    5864:	e2800001 	add	r0, r0, #1
    5868:	e58db004 	str	fp, [sp, #4]
    586c:	e58d6014 	str	r6, [sp, #20]
    5870:	e58dc008 	str	ip, [sp, #8]
    5874:	e58d7010 	str	r7, [sp, #16]
    5878:	e1a0a18a 	lsl	sl, sl, #3
    587c:	e58d000c 	str	r0, [sp, #12]
    5880:	e59db004 	ldr	fp, [sp, #4]
        NN = N1-1;
        TN = NN;
        C[N1] = ONE;
        TK = ONE;
    5884:	e3a04000 	mov	r4, #0
    5888:	e24b8001 	sub	r8, fp, #1
    /*     in C(1,1),..... C(1,2),..... C(1,3),....... */

    C[1] = ONE;
    for (N1=2;N1<=N;N1++) {
        NN = N1-1;
        TN = NN;
    588c:	e1a00008 	mov	r0, r8
    5890:	eb003c63 	bl	14a24 <__aeabi_i2d>
    5894:	e1a07001 	mov	r7, r1
        C[N1] = ONE;
    5898:	e59db008 	ldr	fp, [sp, #8]
        TK = ONE;
    589c:	e59f53f4 	ldr	r5, [pc, #1012]	; 5c98 <CNSTNT+0x780>
    /*     in C(1,1),..... C(1,2),..... C(1,3),....... */

    C[1] = ONE;
    for (N1=2;N1<=N;N1++) {
        NN = N1-1;
        TN = NN;
    58a0:	e1a06000 	mov	r6, r0
        C[N1] = ONE;
    58a4:	e1eb40f8 	strd	r4, [fp, #8]!
    58a8:	e59d0010 	ldr	r0, [sp, #16]
    58ac:	e58db008 	str	fp, [sp, #8]
    58b0:	e08bb000 	add	fp, fp, r0
        TK = ONE;
        for (K1=2;K1<=N1;K1++) {
            C[(K1-1)*N+NN] = C[(K1-2)*N+NN+1]*TN/TK;
    58b4:	e18b20da 	ldrd	r2, [fp, sl]
    58b8:	e1a00006 	mov	r0, r6
    58bc:	e1a01007 	mov	r1, r7
    58c0:	eb003c8e 	bl	14b00 <__aeabi_dmul>
    58c4:	e1a02004 	mov	r2, r4
    58c8:	e1a03005 	mov	r3, r5
    58cc:	eb003d2f 	bl	14d90 <__aeabi_ddiv>
            NN = NN-1;
            TN = TN-ONE;
    58d0:	e3a02000 	mov	r2, #0
        NN = N1-1;
        TN = NN;
        C[N1] = ONE;
        TK = ONE;
        for (K1=2;K1<=N1;K1++) {
            C[(K1-1)*N+NN] = C[(K1-2)*N+NN+1]*TN/TK;
    58d4:	e14b00f8 	strd	r0, [fp, #-8]
            NN = NN-1;
            TN = TN-ONE;
    58d8:	e59f33b8 	ldr	r3, [pc, #952]	; 5c98 <CNSTNT+0x780>
    58dc:	e1a00006 	mov	r0, r6
    58e0:	e1a01007 	mov	r1, r7
    58e4:	eb003b80 	bl	146ec <__aeabi_dsub>
            TK = TK+ONE;
    58e8:	e3a02000 	mov	r2, #0
        C[N1] = ONE;
        TK = ONE;
        for (K1=2;K1<=N1;K1++) {
            C[(K1-1)*N+NN] = C[(K1-2)*N+NN+1]*TN/TK;
            NN = NN-1;
            TN = TN-ONE;
    58ec:	e1a06000 	mov	r6, r0
    58f0:	e1a07001 	mov	r7, r1
            TK = TK+ONE;
    58f4:	e1a00004 	mov	r0, r4
    58f8:	e1a01005 	mov	r1, r5
    58fc:	e59f3394 	ldr	r3, [pc, #916]	; 5c98 <CNSTNT+0x780>
    5900:	eb003b7a 	bl	146f0 <__adddf3>
        TN = NN;
        C[N1] = ONE;
        TK = ONE;
        for (K1=2;K1<=N1;K1++) {
            C[(K1-1)*N+NN] = C[(K1-2)*N+NN+1]*TN/TK;
            NN = NN-1;
    5904:	e2488001 	sub	r8, r8, #1
    for (N1=2;N1<=N;N1++) {
        NN = N1-1;
        TN = NN;
        C[N1] = ONE;
        TK = ONE;
        for (K1=2;K1<=N1;K1++) {
    5908:	e3580000 	cmp	r8, #0
            C[(K1-1)*N+NN] = C[(K1-2)*N+NN+1]*TN/TK;
            NN = NN-1;
            TN = TN-ONE;
            TK = TK+ONE;
    590c:	e1a04000 	mov	r4, r0
    5910:	e1a05001 	mov	r5, r1
    5914:	e08bb009 	add	fp, fp, r9
    for (N1=2;N1<=N;N1++) {
        NN = N1-1;
        TN = NN;
        C[N1] = ONE;
        TK = ONE;
        for (K1=2;K1<=N1;K1++) {
    5918:	1affffe5 	bne	58b4 <CNSTNT+0x39c>
    /*  calculate the coefficients of taylor series expansion */
    /*     for F(X), F"(X), F""(X), ...... (with DELTAT**N/N] included) */
    /*     in C(1,1),..... C(1,2),..... C(1,3),....... */

    C[1] = ONE;
    for (N1=2;N1<=N;N1++) {
    591c:	e59d6004 	ldr	r6, [sp, #4]
    5920:	e59d700c 	ldr	r7, [sp, #12]
    5924:	e2866001 	add	r6, r6, #1
    5928:	e1560007 	cmp	r6, r7
    592c:	e58d6004 	str	r6, [sp, #4]
    5930:	1affffd2 	bne	5880 <CNSTNT+0x368>
    }


    /* predictor-corrector constants for 2nd order differential equation */

    PCC[2] = ONE;
    5934:	e3a02000 	mov	r2, #0
    N1 = N-1;
    switch(N1) {
    5938:	e59da014 	ldr	sl, [sp, #20]
    }


    /* predictor-corrector constants for 2nd order differential equation */

    PCC[2] = ONE;
    593c:	e59f3354 	ldr	r3, [pc, #852]	; 5c98 <CNSTNT+0x780>
    5940:	e59fc3d8 	ldr	ip, [pc, #984]	; 5d20 <CNSTNT+0x808>
    N1 = N-1;
    switch(N1) {
    5944:	e24a1001 	sub	r1, sl, #1
    }


    /* predictor-corrector constants for 2nd order differential equation */

    PCC[2] = ONE;
    5948:	e1cc21f0 	strd	r2, [ip, #16]
    N1 = N-1;
    switch(N1) {
    594c:	e3510006 	cmp	r1, #6
    5950:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
    5954:	ea00001b 	b	59c8 <CNSTNT+0x4b0>
    5958:	000059d0 	.word	0x000059d0
    595c:	000059d0 	.word	0x000059d0
    5960:	000059f0 	.word	0x000059f0
    5964:	00005a1c 	.word	0x00005a1c
    5968:	00005a54 	.word	0x00005a54
    596c:	00005a98 	.word	0x00005a98
    5970:	00005974 	.word	0x00005974
        break;
    case 7:
        PCC[0] = (double) 275.00/2016.00;
        PCC[1] = (double) 19087.00/30240.00;
        PCC[3] = (double) 137.00/180.00;
        PCC[4] = FIVE/16.00;
    5974:	e3a08000 	mov	r8, #0
        PCC[6] = ONE/360.00;
        break;
    case 7:
        PCC[0] = (double) 275.00/2016.00;
        PCC[1] = (double) 19087.00/30240.00;
        PCC[3] = (double) 137.00/180.00;
    5978:	e59f03a4 	ldr	r0, [pc, #932]	; 5d24 <CNSTNT+0x80c>
    597c:	e59f13a4 	ldr	r1, [pc, #932]	; 5d28 <CNSTNT+0x810>
        PCC[4] = FIVE/16.00;
    5980:	e59f93a4 	ldr	r9, [pc, #932]	; 5d2c <CNSTNT+0x814>
        PCC[6] = ONE/360.00;
        break;
    case 7:
        PCC[0] = (double) 275.00/2016.00;
        PCC[1] = (double) 19087.00/30240.00;
        PCC[3] = (double) 137.00/180.00;
    5984:	e1cc01f8 	strd	r0, [ip, #24]
        PCC[4] = (double) 35.00/144.00;
        PCC[5] = ONE/24.00;
        PCC[6] = ONE/360.00;
        break;
    case 7:
        PCC[0] = (double) 275.00/2016.00;
    5988:	e59f63a0 	ldr	r6, [pc, #928]	; 5d30 <CNSTNT+0x818>
    598c:	e59f73a0 	ldr	r7, [pc, #928]	; 5d34 <CNSTNT+0x81c>
        PCC[1] = (double) 19087.00/30240.00;
    5990:	e59f43a0 	ldr	r4, [pc, #928]	; 5d38 <CNSTNT+0x820>
    5994:	e59f53a0 	ldr	r5, [pc, #928]	; 5d3c <CNSTNT+0x824>
        PCC[3] = (double) 137.00/180.00;
        PCC[4] = FIVE/16.00;
        PCC[5] = (double) 17.00/240.00;
    5998:	e59f23a0 	ldr	r2, [pc, #928]	; 5d40 <CNSTNT+0x828>
    599c:	e59f33a0 	ldr	r3, [pc, #928]	; 5d44 <CNSTNT+0x82c>
        PCC[6] = ONE/120.00;
    59a0:	e59fa3a0 	ldr	sl, [pc, #928]	; 5d48 <CNSTNT+0x830>
    59a4:	e59fb3a0 	ldr	fp, [pc, #928]	; 5d4c <CNSTNT+0x834>
        PCC[7] = ONE/2520.00;
    59a8:	e59f03a0 	ldr	r0, [pc, #928]	; 5d50 <CNSTNT+0x838>
    59ac:	e59f13a0 	ldr	r1, [pc, #928]	; 5d54 <CNSTNT+0x83c>
        break;
    case 7:
        PCC[0] = (double) 275.00/2016.00;
        PCC[1] = (double) 19087.00/30240.00;
        PCC[3] = (double) 137.00/180.00;
        PCC[4] = FIVE/16.00;
    59b0:	e1cc82f0 	strd	r8, [ip, #32]
        PCC[4] = (double) 35.00/144.00;
        PCC[5] = ONE/24.00;
        PCC[6] = ONE/360.00;
        break;
    case 7:
        PCC[0] = (double) 275.00/2016.00;
    59b4:	e1cc60f0 	strd	r6, [ip]
        PCC[1] = (double) 19087.00/30240.00;
    59b8:	e1cc40f8 	strd	r4, [ip, #8]
        PCC[3] = (double) 137.00/180.00;
        PCC[4] = FIVE/16.00;
        PCC[5] = (double) 17.00/240.00;
    59bc:	e1cc22f8 	strd	r2, [ip, #40]	; 0x28
        PCC[6] = ONE/120.00;
    59c0:	e1cca3f0 	strd	sl, [ip, #48]	; 0x30
        PCC[7] = ONE/2520.00;
    59c4:	e1cc03f8 	strd	r0, [ip, #56]	; 0x38
        break;
    default:
        break;
    }
}           /* end of subroutine CNSTNT */
    59c8:	e28dd01c 	add	sp, sp, #28
    59cc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    PCC[2] = ONE;
    N1 = N-1;
    switch(N1) {
    case 1:
    case 2:
        fprintf(six,"***** ERROR: THE ORDER HAS TO BE GREATER THAN 2 ****");
    59d0:	e3a01001 	mov	r1, #1
    59d4:	e3a02034 	mov	r2, #52	; 0x34
    59d8:	e59f3378 	ldr	r3, [pc, #888]	; 5d58 <CNSTNT+0x840>
    59dc:	e59f0378 	ldr	r0, [pc, #888]	; 5d5c <CNSTNT+0x844>
    59e0:	e5933000 	ldr	r3, [r3]
        PCC[7] = ONE/2520.00;
        break;
    default:
        break;
    }
}           /* end of subroutine CNSTNT */
    59e4:	e28dd01c 	add	sp, sp, #28
    59e8:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    PCC[2] = ONE;
    N1 = N-1;
    switch(N1) {
    case 1:
    case 2:
        fprintf(six,"***** ERROR: THE ORDER HAS TO BE GREATER THAN 2 ****");
    59ec:	ea00462e 	b	172ac <fwrite>
        break;
    case 3:
        PCC[0] = ONE/6.00;
    59f0:	e59f2368 	ldr	r2, [pc, #872]	; 5d60 <CNSTNT+0x848>
    59f4:	e59f3368 	ldr	r3, [pc, #872]	; 5d64 <CNSTNT+0x84c>
        PCC[1] = FIVE/6.00;
    59f8:	e59f0368 	ldr	r0, [pc, #872]	; 5d68 <CNSTNT+0x850>
    case 1:
    case 2:
        fprintf(six,"***** ERROR: THE ORDER HAS TO BE GREATER THAN 2 ****");
        break;
    case 3:
        PCC[0] = ONE/6.00;
    59fc:	e1cc20f0 	strd	r2, [ip]
        PCC[1] = FIVE/6.00;
    5a00:	e59f1364 	ldr	r1, [pc, #868]	; 5d6c <CNSTNT+0x854>
        PCC[3] = ONE/3.00;
    5a04:	e59f2354 	ldr	r2, [pc, #852]	; 5d60 <CNSTNT+0x848>
    5a08:	e59f3360 	ldr	r3, [pc, #864]	; 5d70 <CNSTNT+0x858>
    case 2:
        fprintf(six,"***** ERROR: THE ORDER HAS TO BE GREATER THAN 2 ****");
        break;
    case 3:
        PCC[0] = ONE/6.00;
        PCC[1] = FIVE/6.00;
    5a0c:	e1cc00f8 	strd	r0, [ip, #8]
        PCC[3] = ONE/3.00;
    5a10:	e1cc21f8 	strd	r2, [ip, #24]
        PCC[7] = ONE/2520.00;
        break;
    default:
        break;
    }
}           /* end of subroutine CNSTNT */
    5a14:	e28dd01c 	add	sp, sp, #28
    5a18:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        PCC[1] = FIVE/6.00;
        PCC[3] = ONE/3.00;
        break;
    case 4:
        PCC[0] = (double) 19.00/120.00;
        PCC[1] = (double) 3.00/4.00;
    5a1c:	e3a06000 	mov	r6, #0
        PCC[3] = ONE/2.00;
    5a20:	e3a04000 	mov	r4, #0
        PCC[1] = FIVE/6.00;
        PCC[3] = ONE/3.00;
        break;
    case 4:
        PCC[0] = (double) 19.00/120.00;
        PCC[1] = (double) 3.00/4.00;
    5a24:	e59f7348 	ldr	r7, [pc, #840]	; 5d74 <CNSTNT+0x85c>
        PCC[0] = ONE/6.00;
        PCC[1] = FIVE/6.00;
        PCC[3] = ONE/3.00;
        break;
    case 4:
        PCC[0] = (double) 19.00/120.00;
    5a28:	e59f0348 	ldr	r0, [pc, #840]	; 5d78 <CNSTNT+0x860>
    5a2c:	e59f1348 	ldr	r1, [pc, #840]	; 5d7c <CNSTNT+0x864>
        PCC[1] = (double) 3.00/4.00;
        PCC[3] = ONE/2.00;
        PCC[4] = ONE/12.00;
    5a30:	e59f2328 	ldr	r2, [pc, #808]	; 5d60 <CNSTNT+0x848>
    5a34:	e59f3344 	ldr	r3, [pc, #836]	; 5d80 <CNSTNT+0x868>
        PCC[3] = ONE/3.00;
        break;
    case 4:
        PCC[0] = (double) 19.00/120.00;
        PCC[1] = (double) 3.00/4.00;
        PCC[3] = ONE/2.00;
    5a38:	e59f5344 	ldr	r5, [pc, #836]	; 5d84 <CNSTNT+0x86c>
        PCC[1] = FIVE/6.00;
        PCC[3] = ONE/3.00;
        break;
    case 4:
        PCC[0] = (double) 19.00/120.00;
        PCC[1] = (double) 3.00/4.00;
    5a3c:	e1cc60f8 	strd	r6, [ip, #8]
        PCC[3] = ONE/2.00;
    5a40:	e1cc41f8 	strd	r4, [ip, #24]
        PCC[0] = ONE/6.00;
        PCC[1] = FIVE/6.00;
        PCC[3] = ONE/3.00;
        break;
    case 4:
        PCC[0] = (double) 19.00/120.00;
    5a44:	e1cc00f0 	strd	r0, [ip]
        PCC[1] = (double) 3.00/4.00;
        PCC[3] = ONE/2.00;
        PCC[4] = ONE/12.00;
    5a48:	e1cc22f0 	strd	r2, [ip, #32]
        PCC[7] = ONE/2520.00;
        break;
    default:
        break;
    }
}           /* end of subroutine CNSTNT */
    5a4c:	e28dd01c 	add	sp, sp, #28
    5a50:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        PCC[1] = (double) 3.00/4.00;
        PCC[3] = ONE/2.00;
        PCC[4] = ONE/12.00;
        break;
    case 5:
        PCC[0] = (double) 3.00/20.00;
    5a54:	e59f032c 	ldr	r0, [pc, #812]	; 5d88 <CNSTNT+0x870>
    5a58:	e59f132c 	ldr	r1, [pc, #812]	; 5d8c <CNSTNT+0x874>
        PCC[1] = (double) 251.00/360.00;
    5a5c:	e59f232c 	ldr	r2, [pc, #812]	; 5d90 <CNSTNT+0x878>
    5a60:	e59f332c 	ldr	r3, [pc, #812]	; 5d94 <CNSTNT+0x87c>
        PCC[1] = (double) 3.00/4.00;
        PCC[3] = ONE/2.00;
        PCC[4] = ONE/12.00;
        break;
    case 5:
        PCC[0] = (double) 3.00/20.00;
    5a64:	e1cc00f0 	strd	r0, [ip]
        PCC[1] = (double) 251.00/360.00;
    5a68:	e1cc20f8 	strd	r2, [ip, #8]
        PCC[3] = (double) 11.00/18.00;
    5a6c:	e59f4324 	ldr	r4, [pc, #804]	; 5d98 <CNSTNT+0x880>
    5a70:	e59f5324 	ldr	r5, [pc, #804]	; 5d9c <CNSTNT+0x884>
        PCC[4] = ONE/6.00;
    5a74:	e59f02e4 	ldr	r0, [pc, #740]	; 5d60 <CNSTNT+0x848>
    5a78:	e59f12e4 	ldr	r1, [pc, #740]	; 5d64 <CNSTNT+0x84c>
        PCC[5] = ONE/60.00;
    5a7c:	e59f22c4 	ldr	r2, [pc, #708]	; 5d48 <CNSTNT+0x830>
    5a80:	e59f3318 	ldr	r3, [pc, #792]	; 5da0 <CNSTNT+0x888>
        PCC[4] = ONE/12.00;
        break;
    case 5:
        PCC[0] = (double) 3.00/20.00;
        PCC[1] = (double) 251.00/360.00;
        PCC[3] = (double) 11.00/18.00;
    5a84:	e1cc41f8 	strd	r4, [ip, #24]
        PCC[4] = ONE/6.00;
    5a88:	e1cc02f0 	strd	r0, [ip, #32]
        PCC[5] = ONE/60.00;
    5a8c:	e1cc22f8 	strd	r2, [ip, #40]	; 0x28
        PCC[7] = ONE/2520.00;
        break;
    default:
        break;
    }
}           /* end of subroutine CNSTNT */
    5a90:	e28dd01c 	add	sp, sp, #28
    5a94:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        PCC[3] = (double) 11.00/18.00;
        PCC[4] = ONE/6.00;
        PCC[5] = ONE/60.00;
        break;
    case 6:
        PCC[0] = (double) 863.00/6048.00;
    5a98:	e59f0304 	ldr	r0, [pc, #772]	; 5da4 <CNSTNT+0x88c>
    5a9c:	e59f1304 	ldr	r1, [pc, #772]	; 5da8 <CNSTNT+0x890>
        PCC[1] = (double) 665.00/1008.00;
    5aa0:	e59f2304 	ldr	r2, [pc, #772]	; 5dac <CNSTNT+0x894>
    5aa4:	e59f3304 	ldr	r3, [pc, #772]	; 5db0 <CNSTNT+0x898>
        PCC[3] = (double) 11.00/18.00;
        PCC[4] = ONE/6.00;
        PCC[5] = ONE/60.00;
        break;
    case 6:
        PCC[0] = (double) 863.00/6048.00;
    5aa8:	e1cc00f0 	strd	r0, [ip]
        PCC[1] = (double) 665.00/1008.00;
    5aac:	e1cc20f8 	strd	r2, [ip, #8]
        PCC[3] = (double) 25.00/36.00;
    5ab0:	e59f62fc 	ldr	r6, [pc, #764]	; 5db4 <CNSTNT+0x89c>
    5ab4:	e59f72fc 	ldr	r7, [pc, #764]	; 5db8 <CNSTNT+0x8a0>
        PCC[4] = (double) 35.00/144.00;
    5ab8:	e59f42ec 	ldr	r4, [pc, #748]	; 5dac <CNSTNT+0x894>
    5abc:	e59f52f8 	ldr	r5, [pc, #760]	; 5dbc <CNSTNT+0x8a4>
        PCC[5] = ONE/24.00;
    5ac0:	e59f0298 	ldr	r0, [pc, #664]	; 5d60 <CNSTNT+0x848>
    5ac4:	e59f12f4 	ldr	r1, [pc, #756]	; 5dc0 <CNSTNT+0x8a8>
        PCC[6] = ONE/360.00;
    5ac8:	e59f22f4 	ldr	r2, [pc, #756]	; 5dc4 <CNSTNT+0x8ac>
    5acc:	e59f32f4 	ldr	r3, [pc, #756]	; 5dc8 <CNSTNT+0x8b0>
        PCC[5] = ONE/60.00;
        break;
    case 6:
        PCC[0] = (double) 863.00/6048.00;
        PCC[1] = (double) 665.00/1008.00;
        PCC[3] = (double) 25.00/36.00;
    5ad0:	e1cc61f8 	strd	r6, [ip, #24]
        PCC[4] = (double) 35.00/144.00;
    5ad4:	e1cc42f0 	strd	r4, [ip, #32]
        PCC[5] = ONE/24.00;
    5ad8:	e1cc02f8 	strd	r0, [ip, #40]	; 0x28
        PCC[6] = ONE/360.00;
    5adc:	e1cc23f0 	strd	r2, [ip, #48]	; 0x30
        PCC[7] = ONE/2520.00;
        break;
    default:
        break;
    }
}           /* end of subroutine CNSTNT */
    5ae0:	e28dd01c 	add	sp, sp, #28
    5ae4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5ae8:	0013ea74 	.word	0x0013ea74
    5aec:	e4f765fe 	.word	0xe4f765fe
    5af0:	3feea161 	.word	0x3feea161
    5af4:	c373374f 	.word	0xc373374f
    5af8:	3ff0b725 	.word	0x3ff0b725
    5afc:	0013eee8 	.word	0x0013eee8
    5b00:	0013ea80 	.word	0x0013ea80
    5b04:	f7167b78 	.word	0xf7167b78
    5b08:	3ff1767b 	.word	0x3ff1767b
    5b0c:	36ac6477 	.word	0x36ac6477
    5b10:	3ffd2fff 	.word	0x3ffd2fff
    5b14:	0013ea30 	.word	0x0013ea30
    5b18:	0013f3f8 	.word	0x0013f3f8
    5b1c:	0013ef78 	.word	0x0013ef78
    5b20:	e90ff972 	.word	0xe90ff972
    5b24:	402fffb7 	.word	0x402fffb7
    5b28:	1b71758e 	.word	0x1b71758e
    5b2c:	3ff0200d 	.word	0x3ff0200d
    5b30:	97f62b6b 	.word	0x97f62b6b
    5b34:	403203dd 	.word	0x403203dd
    5b38:	0013f418 	.word	0x0013f418
    5b3c:	0013ea78 	.word	0x0013ea78
    5b40:	9ee75616 	.word	0x9ee75616
    5b44:	3cd203af 	.word	0x3cd203af
    5b48:	e2308c3a 	.word	0xe2308c3a
    5b4c:	3e45798e 	.word	0x3e45798e
    5b50:	0013f508 	.word	0x0013f508
    5b54:	0013f460 	.word	0x0013f460
    5b58:	6d28549d 	.word	0x6d28549d
    5b5c:	3b000f5c 	.word	0x3b000f5c
    5b60:	63fdfdd9 	.word	0x63fdfdd9
    5b64:	3ca3e5be 	.word	0x3ca3e5be
    5b68:	0013f3d0 	.word	0x0013f3d0
    5b6c:	0013efc0 	.word	0x0013efc0
    5b70:	9125742f 	.word	0x9125742f
    5b74:	44dfe164 	.word	0x44dfe164
    5b78:	ba01eeee 	.word	0xba01eeee
    5b7c:	3fe0672f 	.word	0x3fe0672f
    5b80:	0013ea38 	.word	0x0013ea38
    5b84:	0013ef60 	.word	0x0013ef60
    5b88:	12018a44 	.word	0x12018a44
    5b8c:	3fa8a04d 	.word	0x3fa8a04d
    5b90:	a908a266 	.word	0xa908a266
    5b94:	bf77d9db 	.word	0xbf77d9db
    5b98:	0013efd0 	.word	0x0013efd0
    5b9c:	0013ef98 	.word	0x0013ef98
    5ba0:	07d0aeda 	.word	0x07d0aeda
    5ba4:	3f90d8cb 	.word	0x3f90d8cb
    5ba8:	33482be9 	.word	0x33482be9
    5bac:	bfe24d16 	.word	0xbfe24d16
    5bb0:	0013ea68 	.word	0x0013ea68
    5bb4:	0013f518 	.word	0x0013f518
    5bb8:	245b291c 	.word	0x245b291c
    5bbc:	bf7f46ed 	.word	0xbf7f46ed
    5bc0:	fc43b2dd 	.word	0xfc43b2dd
    5bc4:	bf5e96c3 	.word	0xbf5e96c3
    5bc8:	0013eeb0 	.word	0x0013eeb0
    5bcc:	0013f4e8 	.word	0x0013f4e8
    5bd0:	c1c1d6d0 	.word	0xc1c1d6d0
    5bd4:	bf60c4de 	.word	0xbf60c4de
    5bd8:	46f15619 	.word	0x46f15619
    5bdc:	bf9f91e6 	.word	0xbf9f91e6
    5be0:	0013eea0 	.word	0x0013eea0
    5be4:	0013ee98 	.word	0x0013ee98
    5be8:	fa3fcc9f 	.word	0xfa3fcc9f
    5bec:	bf834d26 	.word	0xbf834d26
    5bf0:	d9e83e42 	.word	0xd9e83e42
    5bf4:	3feafaac 	.word	0x3feafaac
    5bf8:	0013f408 	.word	0x0013f408
    5bfc:	0013eff8 	.word	0x0013eff8
    5c00:	b866e43b 	.word	0xb866e43b
    5c04:	bf5f9f01 	.word	0xbf5f9f01
    5c08:	bc6a7efa 	.word	0xbc6a7efa
    5c0c:	bf689374 	.word	0xbf689374
    5c10:	0013eea8 	.word	0x0013eea8
    5c14:	0013f420 	.word	0x0013f420
    5c18:	487fcb92 	.word	0x487fcb92
    5c1c:	3f6d7dbf 	.word	0x3f6d7dbf
    5c20:	bf889374 	.word	0xbf889374
    5c24:	0013f548 	.word	0x0013f548
    5c28:	0013ef80 	.word	0x0013ef80
    5c2c:	3f789374 	.word	0x3f789374
    5c30:	30553261 	.word	0x30553261
    5c34:	bf73a92a 	.word	0xbf73a92a
    5c38:	0013f090 	.word	0x0013f090
    5c3c:	0013ef88 	.word	0x0013ef88
    5c40:	07c84b5e 	.word	0x07c84b5e
    5c44:	3f959b3d 	.word	0x3f959b3d
    5c48:	42cc2d6b 	.word	0x42cc2d6b
    5c4c:	3f79a73b 	.word	0x3f79a73b
    5c50:	0013eeb8 	.word	0x0013eeb8
    5c54:	0013f440 	.word	0x0013f440
    5c58:	ff0ee952 	.word	0xff0ee952
    5c5c:	3fb24f3c 	.word	0x3fb24f3c
    5c60:	7525460b 	.word	0x7525460b
    5c64:	407c7502 	.word	0x407c7502
    5c68:	0013f448 	.word	0x0013f448
    5c6c:	0013f540 	.word	0x0013f540
    5c70:	3198ff40 	.word	0x3198ff40
    5c74:	40149c60 	.word	0x40149c60
    5c78:	33ce8e99 	.word	0x33ce8e99
    5c7c:	3fd1d7d5 	.word	0x3fd1d7d5
    5c80:	0013f4f8 	.word	0x0013f4f8
    5c84:	0013f3e0 	.word	0x0013f3e0
    5c88:	38c6f0eb 	.word	0x38c6f0eb
    5c8c:	40061635 	.word	0x40061635
    5c90:	842bc932 	.word	0x842bc932
    5c94:	3fe37c93 	.word	0x3fe37c93
    5c98:	3ff00000 	.word	0x3ff00000
    5c9c:	0013f0a0 	.word	0x0013f0a0
    5ca0:	0013eec8 	.word	0x0013eec8
    5ca4:	44955b46 	.word	0x44955b46
    5ca8:	4007b1f6 	.word	0x4007b1f6
    5cac:	4976968a 	.word	0x4976968a
    5cb0:	3fbd4e20 	.word	0x3fbd4e20
    5cb4:	0013f560 	.word	0x0013f560
    5cb8:	0013f088 	.word	0x0013f088
    5cbc:	9186a5a1 	.word	0x9186a5a1
    5cc0:	4001ddb9 	.word	0x4001ddb9
    5cc4:	8054fb79 	.word	0x8054fb79
    5cc8:	40a25431 	.word	0x40a25431
    5ccc:	0013f430 	.word	0x0013f430
    5cd0:	0013ea88 	.word	0x0013ea88
    5cd4:	46a6c182 	.word	0x46a6c182
    5cd8:	3fe8a189 	.word	0x3fe8a189
    5cdc:	0013f550 	.word	0x0013f550
    5ce0:	0013f3e8 	.word	0x0013f3e8
    5ce4:	1cc87ff4 	.word	0x1cc87ff4
    5ce8:	3ffcdbd2 	.word	0x3ffcdbd2
    5cec:	a6f254d1 	.word	0xa6f254d1
    5cf0:	3fd05c8e 	.word	0x3fd05c8e
    5cf4:	a6711871 	.word	0xa6711871
    5cf8:	0013ef48 	.word	0x0013ef48
    5cfc:	0013ea48 	.word	0x0013ea48
    5d00:	3fe161ae 	.word	0x3fe161ae
    5d04:	b31dcf1e 	.word	0xb31dcf1e
    5d08:	3fcd3ca2 	.word	0x3fcd3ca2
    5d0c:	3fc24f3c 	.word	0x3fc24f3c
    5d10:	3fd24f3c 	.word	0x3fd24f3c
    5d14:	0013efa0 	.word	0x0013efa0
    5d18:	0013eee0 	.word	0x0013eee0
    5d1c:	0013f538 	.word	0x0013f538
    5d20:	0013eef0 	.word	0x0013eef0
    5d24:	b05b05b0 	.word	0xb05b05b0
    5d28:	3fe85b05 	.word	0x3fe85b05
    5d2c:	3fd40000 	.word	0x3fd40000
    5d30:	5d75d75d 	.word	0x5d75d75d
    5d34:	3fc175d7 	.word	0x3fc175d7
    5d38:	7fdd532b 	.word	0x7fdd532b
    5d3c:	3fe432a8 	.word	0x3fe432a8
    5d40:	22222222 	.word	0x22222222
    5d44:	3fb22222 	.word	0x3fb22222
    5d48:	11111111 	.word	0x11111111
    5d4c:	3f811111 	.word	0x3f811111
    5d50:	1a01a01a 	.word	0x1a01a01a
    5d54:	3f3a01a0 	.word	0x3f3a01a0
    5d58:	0013f3f4 	.word	0x0013f3f4
    5d5c:	00032954 	.word	0x00032954
    5d60:	55555555 	.word	0x55555555
    5d64:	3fc55555 	.word	0x3fc55555
    5d68:	aaaaaaab 	.word	0xaaaaaaab
    5d6c:	3feaaaaa 	.word	0x3feaaaaa
    5d70:	3fd55555 	.word	0x3fd55555
    5d74:	3fe80000 	.word	0x3fe80000
    5d78:	44444444 	.word	0x44444444
    5d7c:	3fc44444 	.word	0x3fc44444
    5d80:	3fb55555 	.word	0x3fb55555
    5d84:	3fe00000 	.word	0x3fe00000
    5d88:	33333333 	.word	0x33333333
    5d8c:	3fc33333 	.word	0x3fc33333
    5d90:	fa4fa4fa 	.word	0xfa4fa4fa
    5d94:	3fe64fa4 	.word	0x3fe64fa4
    5d98:	e38e38e4 	.word	0xe38e38e4
    5d9c:	3fe38e38 	.word	0x3fe38e38
    5da0:	3f911111 	.word	0x3f911111
    5da4:	90ee643c 	.word	0x90ee643c
    5da8:	3fc243b9 	.word	0x3fc243b9
    5dac:	c71c71c7 	.word	0xc71c71c7
    5db0:	3fe51c71 	.word	0x3fe51c71
    5db4:	8e38e38e 	.word	0x8e38e38e
    5db8:	3fe638e3 	.word	0x3fe638e3
    5dbc:	3fcf1c71 	.word	0x3fcf1c71
    5dc0:	3fa55555 	.word	0x3fa55555
    5dc4:	16c16c17 	.word	0x16c16c17
    5dc8:	3f66c16c 	.word	0x3f66c16c

00005dcc <PREDIC>:
    long func, i, j, k, dir, atom;
    double S;
    struct link *curr_ptr;
    struct list_of_boxes *curr_box;

    curr_box = my_boxes[ProcID];
    5dcc:	e59f33a4 	ldr	r3, [pc, #932]	; 6178 <PREDIC+0x3ac>
 *  using Gear's sixth-order predictor-corrector method
 *
 * NOR1 : NOR1 = NORDER + 1 = 7 (for a sixth-order method)
 */
void PREDIC(double *C, long NOR1, long ProcID)
{
    5dd0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    long func, i, j, k, dir, atom;
    double S;
    struct link *curr_ptr;
    struct list_of_boxes *curr_box;

    curr_box = my_boxes[ProcID];
    5dd4:	e5933000 	ldr	r3, [r3]
 *  using Gear's sixth-order predictor-corrector method
 *
 * NOR1 : NOR1 = NORDER + 1 = 7 (for a sixth-order method)
 */
void PREDIC(double *C, long NOR1, long ProcID)
{
    5dd8:	e24dd05c 	sub	sp, sp, #92	; 0x5c
    long func, i, j, k, dir, atom;
    double S;
    struct link *curr_ptr;
    struct list_of_boxes *curr_box;

    curr_box = my_boxes[ProcID];
    5ddc:	e7933102 	ldr	r3, [r3, r2, lsl #2]
 *  using Gear's sixth-order predictor-corrector method
 *
 * NOR1 : NOR1 = NORDER + 1 = 7 (for a sixth-order method)
 */
void PREDIC(double *C, long NOR1, long ProcID)
{
    5de0:	e58d0054 	str	r0, [sp, #84]	; 0x54
    struct link *curr_ptr;
    struct list_of_boxes *curr_box;

    curr_box = my_boxes[ProcID];

    while (curr_box) {
    5de4:	e3530000 	cmp	r3, #0
    long func, i, j, k, dir, atom;
    double S;
    struct link *curr_ptr;
    struct list_of_boxes *curr_box;

    curr_box = my_boxes[ProcID];
    5de8:	e58d3048 	str	r3, [sp, #72]	; 0x48

    while (curr_box) {
    5dec:	0a0000df 	beq	6170 <PREDIC+0x3a4>
    5df0:	e59f2384 	ldr	r2, [pc, #900]	; 617c <PREDIC+0x3b0>
    5df4:	e59f3384 	ldr	r3, [pc, #900]	; 6180 <PREDIC+0x3b4>
    5df8:	e5922000 	ldr	r2, [r2]
    5dfc:	e1a01181 	lsl	r1, r1, #3
    5e00:	e593b000 	ldr	fp, [r3]
    5e04:	e59d0048 	ldr	r0, [sp, #72]	; 0x48
    5e08:	e58d2050 	str	r2, [sp, #80]	; 0x50
    5e0c:	e58d1044 	str	r1, [sp, #68]	; 0x44
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        /* Loop through the current box's molecules */

        curr_ptr = BOX[i][j][k].list;
    5e10:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
    5e14:	e5903000 	ldr	r3, [r0]
    5e18:	e5901004 	ldr	r1, [r0, #4]
    5e1c:	e7923103 	ldr	r3, [r2, r3, lsl #2]
    5e20:	e5902008 	ldr	r2, [r0, #8]
    5e24:	e7933101 	ldr	r3, [r3, r1, lsl #2]
    5e28:	e7933202 	ldr	r3, [r3, r2, lsl #4]

        while (curr_ptr) {
    5e2c:	e3530000 	cmp	r3, #0
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        /* Loop through the current box's molecules */

        curr_ptr = BOX[i][j][k].list;
    5e30:	e58d304c 	str	r3, [sp, #76]	; 0x4c

        while (curr_ptr) {
    5e34:	0a0000c9 	beq	6160 <PREDIC+0x394>
    5e38:	e1a0a00b 	mov	sl, fp

            JIZ = 2;

            /* loop over F(X), F'(X), F''(X), etc. */

            for (func = 0; func < NORDER; func++) {
    5e3c:	e35a0000 	cmp	sl, #0
    5e40:	da0000bf 	ble	6144 <PREDIC+0x378>
    5e44:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
    5e48:	e59db054 	ldr	fp, [sp, #84]	; 0x54
    5e4c:	e2833d09 	add	r3, r3, #576	; 0x240
    5e50:	e58d3040 	str	r3, [sp, #64]	; 0x40
    5e54:	e1a0300a 	mov	r3, sl
    5e58:	e3a02001 	mov	r2, #1
    5e5c:	e1a0a00b 	mov	sl, fp
    5e60:	e1a0b003 	mov	fp, r3
    5e64:	e58d2008 	str	r2, [sp, #8]
    5e68:	e59d8008 	ldr	r8, [sp, #8]
 *  using Gear's sixth-order predictor-corrector method
 *
 * NOR1 : NOR1 = NORDER + 1 = 7 (for a sixth-order method)
 */
void PREDIC(double *C, long NOR1, long ProcID)
{
    5e6c:	e59d9040 	ldr	r9, [sp, #64]	; 0x40
    5e70:	e2882002 	add	r2, r8, #2
    5e74:	e58d2038 	str	r2, [sp, #56]	; 0x38
    5e78:	e2882005 	add	r2, r8, #5
    5e7c:	e58d202c 	str	r2, [sp, #44]	; 0x2c
    5e80:	e3a02003 	mov	r2, #3
    5e84:	e2880001 	add	r0, r8, #1
    5e88:	e2883003 	add	r3, r8, #3
    5e8c:	e58d0008 	str	r0, [sp, #8]
    5e90:	e2880004 	add	r0, r8, #4
    5e94:	e58d3034 	str	r3, [sp, #52]	; 0x34
    5e98:	e58d0030 	str	r0, [sp, #48]	; 0x30
    5e9c:	e2883006 	add	r3, r8, #6
    5ea0:	e2880007 	add	r0, r8, #7
    5ea4:	e58d3028 	str	r3, [sp, #40]	; 0x28
    5ea8:	e58d003c 	str	r0, [sp, #60]	; 0x3c
    5eac:	e58d2024 	str	r2, [sp, #36]	; 0x24
    5eb0:	e58d8020 	str	r8, [sp, #32]
    5eb4:	e3a06000 	mov	r6, #0
    5eb8:	e2493f7e 	sub	r3, r9, #504	; 0x1f8
    5ebc:	e2490f5a 	sub	r0, r9, #360	; 0x168
    5ec0:	e2492e12 	sub	r2, r9, #288	; 0x120
    5ec4:	e58d3004 	str	r3, [sp, #4]
    5ec8:	e58d000c 	str	r0, [sp, #12]
    5ecc:	e58d2010 	str	r2, [sp, #16]
    5ed0:	e24930d8 	sub	r3, r9, #216	; 0xd8
    5ed4:	e2490090 	sub	r0, r9, #144	; 0x90
    5ed8:	e2492048 	sub	r2, r9, #72	; 0x48
    5edc:	e2497f8a 	sub	r7, r9, #552	; 0x228
    5ee0:	e2498e1b 	sub	r8, r9, #432	; 0x1b0
    5ee4:	e58d3014 	str	r3, [sp, #20]
    5ee8:	e58d0018 	str	r0, [sp, #24]
    5eec:	e58d201c 	str	r2, [sp, #28]
    5ef0:	e59d0004 	ldr	r0, [sp, #4]
    5ef4:	e0803006 	add	r3, r0, r6
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    5ef8:	e1c321d8 	ldrd	r2, [r3, #24]
    5efc:	e1ca01d0 	ldrd	r0, [sl, #16]
    5f00:	eb003afe 	bl	14b00 <__aeabi_dmul>
    5f04:	e3a02000 	mov	r2, #0
    5f08:	e3a03000 	mov	r3, #0
    5f0c:	eb0039f7 	bl	146f0 <__adddf3>
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    5f10:	e59d2020 	ldr	r2, [sp, #32]
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    5f14:	e1a04000 	mov	r4, r0
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    5f18:	e15b0002 	cmp	fp, r2
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    5f1c:	e1a05001 	mov	r5, r1
    5f20:	e0883006 	add	r3, r8, r6
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    5f24:	da000070 	ble	60ec <PREDIC+0x320>
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    5f28:	e1c321d8 	ldrd	r2, [r3, #24]
    5f2c:	e1ca01d8 	ldrd	r0, [sl, #24]
    5f30:	eb003af2 	bl	14b00 <__aeabi_dmul>
    5f34:	e1a02000 	mov	r2, r0
    5f38:	e1a03001 	mov	r3, r1
    5f3c:	e1a00004 	mov	r0, r4
    5f40:	e1a01005 	mov	r1, r5
    5f44:	eb0039e9 	bl	146f0 <__adddf3>
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    5f48:	e59d2008 	ldr	r2, [sp, #8]
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    5f4c:	e1a04000 	mov	r4, r0
    5f50:	e59d000c 	ldr	r0, [sp, #12]
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    5f54:	e152000b 	cmp	r2, fp
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    5f58:	e1a05001 	mov	r5, r1
    5f5c:	e0803006 	add	r3, r0, r6
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    5f60:	aa000061 	bge	60ec <PREDIC+0x320>
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    5f64:	e1c321d8 	ldrd	r2, [r3, #24]
    5f68:	e1ca02d0 	ldrd	r0, [sl, #32]
    5f6c:	eb003ae3 	bl	14b00 <__aeabi_dmul>
    5f70:	e1a02000 	mov	r2, r0
    5f74:	e1a03001 	mov	r3, r1
    5f78:	e1a00004 	mov	r0, r4
    5f7c:	e1a01005 	mov	r1, r5
    5f80:	eb0039da 	bl	146f0 <__adddf3>
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    5f84:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    5f88:	e1a04000 	mov	r4, r0
    5f8c:	e59d0010 	ldr	r0, [sp, #16]
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    5f90:	e152000b 	cmp	r2, fp
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    5f94:	e1a05001 	mov	r5, r1
    5f98:	e0803006 	add	r3, r0, r6
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    5f9c:	aa000052 	bge	60ec <PREDIC+0x320>
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    5fa0:	e1c321d8 	ldrd	r2, [r3, #24]
    5fa4:	e1ca02d8 	ldrd	r0, [sl, #40]	; 0x28
    5fa8:	eb003ad4 	bl	14b00 <__aeabi_dmul>
    5fac:	e1a02000 	mov	r2, r0
    5fb0:	e1a03001 	mov	r3, r1
    5fb4:	e1a00004 	mov	r0, r4
    5fb8:	e1a01005 	mov	r1, r5
    5fbc:	eb0039cb 	bl	146f0 <__adddf3>
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    5fc0:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    5fc4:	e1a04000 	mov	r4, r0
    5fc8:	e59d0014 	ldr	r0, [sp, #20]
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    5fcc:	e152000b 	cmp	r2, fp
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    5fd0:	e1a05001 	mov	r5, r1
    5fd4:	e0803006 	add	r3, r0, r6
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    5fd8:	aa000043 	bge	60ec <PREDIC+0x320>
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    5fdc:	e1c321d8 	ldrd	r2, [r3, #24]
    5fe0:	e1ca03d0 	ldrd	r0, [sl, #48]	; 0x30
    5fe4:	eb003ac5 	bl	14b00 <__aeabi_dmul>
    5fe8:	e1a02000 	mov	r2, r0
    5fec:	e1a03001 	mov	r3, r1
    5ff0:	e1a00004 	mov	r0, r4
    5ff4:	e1a01005 	mov	r1, r5
    5ff8:	eb0039bc 	bl	146f0 <__adddf3>
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    5ffc:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    6000:	e1a04000 	mov	r4, r0
    6004:	e59d0018 	ldr	r0, [sp, #24]
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    6008:	e152000b 	cmp	r2, fp
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    600c:	e1a05001 	mov	r5, r1
    6010:	e0803006 	add	r3, r0, r6
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    6014:	aa000034 	bge	60ec <PREDIC+0x320>
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    6018:	e1c321d8 	ldrd	r2, [r3, #24]
    601c:	e1ca03d8 	ldrd	r0, [sl, #56]	; 0x38
    6020:	eb003ab6 	bl	14b00 <__aeabi_dmul>
    6024:	e1a02000 	mov	r2, r0
    6028:	e1a03001 	mov	r3, r1
    602c:	e1a00004 	mov	r0, r4
    6030:	e1a01005 	mov	r1, r5
    6034:	eb0039ad 	bl	146f0 <__adddf3>
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    6038:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    603c:	e1a04000 	mov	r4, r0
    6040:	e59d001c 	ldr	r0, [sp, #28]
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    6044:	e152000b 	cmp	r2, fp
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    6048:	e1a05001 	mov	r5, r1
    604c:	e0803006 	add	r3, r0, r6
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    6050:	aa000025 	bge	60ec <PREDIC+0x320>
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    6054:	e1c321d8 	ldrd	r2, [r3, #24]
    6058:	e1ca04d0 	ldrd	r0, [sl, #64]	; 0x40
    605c:	eb003aa7 	bl	14b00 <__aeabi_dmul>
    6060:	e1a03001 	mov	r3, r1
    6064:	e1a02000 	mov	r2, r0
    6068:	e1a01005 	mov	r1, r5
    606c:	e1a00004 	mov	r0, r4
    6070:	eb00399e 	bl	146f0 <__adddf3>
    6074:	e1a04000 	mov	r4, r0
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    6078:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    607c:	e1a05001 	mov	r5, r1
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    6080:	e150000b 	cmp	r0, fp
    6084:	e0893006 	add	r3, r9, r6
    6088:	aa000017 	bge	60ec <PREDIC+0x320>
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    608c:	e1c321d8 	ldrd	r2, [r3, #24]
    6090:	e1ca04d8 	ldrd	r0, [sl, #72]	; 0x48
    6094:	eb003a99 	bl	14b00 <__aeabi_dmul>
    6098:	e1a02000 	mov	r2, r0
    609c:	e1a03001 	mov	r3, r1
    60a0:	e1a00004 	mov	r0, r4
    60a4:	e1a01005 	mov	r1, r5
    60a8:	eb003990 	bl	146f0 <__adddf3>
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    60ac:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    60b0:	e1a04000 	mov	r4, r0
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    60b4:	e15b0002 	cmp	fp, r2
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    60b8:	e1a05001 	mov	r5, r1
    60bc:	e2873fa2 	add	r3, r7, #648	; 0x288
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
                        JI = JIZ;
                        /* sum over Taylor Series */
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
    60c0:	da000009 	ble	60ec <PREDIC+0x320>
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
    60c4:	e1c320d0 	ldrd	r2, [r3]
    60c8:	e1ca05d0 	ldrd	r0, [sl, #80]	; 0x50
    60cc:	eb003a8b 	bl	14b00 <__aeabi_dmul>
    60d0:	e1a02000 	mov	r2, r0
    60d4:	e1a03001 	mov	r3, r1
    60d8:	e1a00004 	mov	r0, r4
    60dc:	e1a01005 	mov	r1, r5
    60e0:	eb003982 	bl	146f0 <__adddf3>
    60e4:	e1a04000 	mov	r4, r0
    60e8:	e1a05001 	mov	r5, r1
                            JI++;
                        } /* for L */
                        curr_ptr->mol.F[func][dir][atom] += S;
    60ec:	e1c700d0 	ldrd	r0, [r7]
    60f0:	e1a02004 	mov	r2, r4
    60f4:	e1a03005 	mov	r3, r5
    60f8:	eb00397c 	bl	146f0 <__adddf3>
    60fc:	e2866008 	add	r6, r6, #8

            /* loop over F(X), F'(X), F''(X), etc. */

            for (func = 0; func < NORDER; func++) {
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
    6100:	e3560018 	cmp	r6, #24
                        S = 0.0;
                        for ( L = func; L < NORDER; L++) {
                            S += C[JI] * curr_ptr->mol.F[L+1][dir][atom];
                            JI++;
                        } /* for L */
                        curr_ptr->mol.F[func][dir][atom] += S;
    6104:	e0c700f8 	strd	r0, [r7], #8

            /* loop over F(X), F'(X), F''(X), etc. */

            for (func = 0; func < NORDER; func++) {
                for ( dir = 0; dir < NDIR; dir++)
                    for ( atom = 0; atom < NATOM; atom++ ) {
    6108:	1affff78 	bne	5ef0 <PREDIC+0x124>
            JIZ = 2;

            /* loop over F(X), F'(X), F''(X), etc. */

            for (func = 0; func < NORDER; func++) {
                for ( dir = 0; dir < NDIR; dir++)
    610c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    6110:	e2899018 	add	r9, r9, #24
    6114:	e2533001 	subs	r3, r3, #1
    6118:	e58d3024 	str	r3, [sp, #36]	; 0x24
    611c:	1affff64 	bne	5eb4 <PREDIC+0xe8>
    6120:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
    6124:	e59d8020 	ldr	r8, [sp, #32]
    6128:	e59d0044 	ldr	r0, [sp, #68]	; 0x44
    612c:	e2822048 	add	r2, r2, #72	; 0x48

            JIZ = 2;

            /* loop over F(X), F'(X), F''(X), etc. */

            for (func = 0; func < NORDER; func++) {
    6130:	e158000b 	cmp	r8, fp
    6134:	e08aa000 	add	sl, sl, r0
    6138:	e58d2040 	str	r2, [sp, #64]	; 0x40
    613c:	1affff49 	bne	5e68 <PREDIC+0x9c>
    6140:	e1a0a00b 	mov	sl, fp
                        } /* for L */
                        curr_ptr->mol.F[func][dir][atom] += S;
                    } /* for atom */
                JIZ += NOR1;
            } /* for func */
            curr_ptr = curr_ptr->next_mol;
    6144:	e59d304c 	ldr	r3, [sp, #76]	; 0x4c
    6148:	e59332a0 	ldr	r3, [r3, #672]	; 0x2a0

        /* Loop through the current box's molecules */

        curr_ptr = BOX[i][j][k].list;

        while (curr_ptr) {
    614c:	e3530000 	cmp	r3, #0
                        } /* for L */
                        curr_ptr->mol.F[func][dir][atom] += S;
                    } /* for atom */
                JIZ += NOR1;
            } /* for func */
            curr_ptr = curr_ptr->next_mol;
    6150:	e58d304c 	str	r3, [sp, #76]	; 0x4c

        /* Loop through the current box's molecules */

        curr_ptr = BOX[i][j][k].list;

        while (curr_ptr) {
    6154:	1affff38 	bne	5e3c <PREDIC+0x70>
    6158:	e1a0b00a 	mov	fp, sl
    615c:	e59d0048 	ldr	r0, [sp, #72]	; 0x48
                    } /* for atom */
                JIZ += NOR1;
            } /* for func */
            curr_ptr = curr_ptr->next_mol;
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    6160:	e590000c 	ldr	r0, [r0, #12]
    struct link *curr_ptr;
    struct list_of_boxes *curr_box;

    curr_box = my_boxes[ProcID];

    while (curr_box) {
    6164:	e3500000 	cmp	r0, #0
                    } /* for atom */
                JIZ += NOR1;
            } /* for func */
            curr_ptr = curr_ptr->next_mol;
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    6168:	e58d0048 	str	r0, [sp, #72]	; 0x48
    struct link *curr_ptr;
    struct list_of_boxes *curr_box;

    curr_box = my_boxes[ProcID];

    while (curr_box) {
    616c:	1affff27 	bne	5e10 <PREDIC+0x44>
            curr_ptr = curr_ptr->next_mol;
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    } /* while curr_box */

} /* end of subroutine PREDIC */
    6170:	e28dd05c 	add	sp, sp, #92	; 0x5c
    6174:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6178:	0013efcc 	.word	0x0013efcc
    617c:	0013f098 	.word	0x0013f098
    6180:	0013f528 	.word	0x0013f528

00006184 <CORREC>:
    double Y;
    long i, j, k, dir, atom, func;
    struct link *curr_ptr;
    box_list *curr_box;

    curr_box = my_boxes[ProcID];
    6184:	e59f3294 	ldr	r3, [pc, #660]	; 6420 <CORREC+0x29c>
 *
 * PCC  : the predictor-corrector constants
 * NOR1 : NORDER + 1 = 7 for a sixth-order method)
 */
void CORREC(double *PCC, long NOR1, long ProcID)
{
    6188:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    double Y;
    long i, j, k, dir, atom, func;
    struct link *curr_ptr;
    box_list *curr_box;

    curr_box = my_boxes[ProcID];
    618c:	e5933000 	ldr	r3, [r3]
 *
 * PCC  : the predictor-corrector constants
 * NOR1 : NORDER + 1 = 7 for a sixth-order method)
 */
void CORREC(double *PCC, long NOR1, long ProcID)
{
    6190:	e24dd02c 	sub	sp, sp, #44	; 0x2c
    double Y;
    long i, j, k, dir, atom, func;
    struct link *curr_ptr;
    box_list *curr_box;

    curr_box = my_boxes[ProcID];
    6194:	e7933102 	ldr	r3, [r3, r2, lsl #2]

    while (curr_box) {
    6198:	e3530000 	cmp	r3, #0
    double Y;
    long i, j, k, dir, atom, func;
    struct link *curr_ptr;
    box_list *curr_box;

    curr_box = my_boxes[ProcID];
    619c:	e58d3020 	str	r3, [sp, #32]

    while (curr_box) {
    61a0:	0a00009c 	beq	6418 <CORREC+0x294>
    61a4:	e1a0b000 	mov	fp, r0
    61a8:	e1a06001 	mov	r6, r1
    61ac:	e59f3270 	ldr	r3, [pc, #624]	; 6424 <CORREC+0x2a0>
    61b0:	e5933000 	ldr	r3, [r3]
    61b4:	e58d3024 	str	r3, [sp, #36]	; 0x24
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        /* Loop through the current box's molecules */

        curr_ptr = BOX[i][j][k].list;
    61b8:	e59d0020 	ldr	r0, [sp, #32]
    61bc:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
    61c0:	e5903000 	ldr	r3, [r0]
    61c4:	e5901004 	ldr	r1, [r0, #4]
    61c8:	e7923103 	ldr	r3, [r2, r3, lsl #2]
    61cc:	e5902008 	ldr	r2, [r0, #8]
    61d0:	e7933101 	ldr	r3, [r3, r1, lsl #2]
    61d4:	e7933202 	ldr	r3, [r3, r2, lsl #4]
        while (curr_ptr) {
    61d8:	e3530000 	cmp	r3, #0
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        /* Loop through the current box's molecules */

        curr_ptr = BOX[i][j][k].list;
    61dc:	e58d301c 	str	r3, [sp, #28]
    61e0:	11a03006 	movne	r3, r6
    61e4:	11a0600b 	movne	r6, fp
    61e8:	11a0b003 	movne	fp, r3
        while (curr_ptr) {
    61ec:	0a000084 	beq	6404 <CORREC+0x280>
 *
 * PCC  : the predictor-corrector constants
 * NOR1 : NORDER + 1 = 7 for a sixth-order method)
 */
void CORREC(double *PCC, long NOR1, long ProcID)
{
    61f0:	e3a02003 	mov	r2, #3
    61f4:	e59d001c 	ldr	r0, [sp, #28]
    61f8:	e58d2018 	str	r2, [sp, #24]
    61fc:	e28070c0 	add	r7, r0, #192	; 0xc0
    6200:	e58d7014 	str	r7, [sp, #20]
    6204:	e59d3014 	ldr	r3, [sp, #20]
    6208:	e1a09003 	mov	r9, r3
    620c:	e2838e15 	add	r8, r3, #336	; 0x150
    6210:	e24370a8 	sub	r7, r3, #168	; 0xa8
    6214:	e243a018 	sub	sl, r3, #24
        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
    6218:	e0c820d8 	ldrd	r2, [r8], #8
    621c:	e1cd20f0 	strd	r2, [sp]
    6220:	e1cd00d0 	ldrd	r0, [sp]
                        curr_ptr->mol.F[ACC][dir][atom];
    6224:	e0ca20d8 	ldrd	r2, [sl], #8
    6228:	e1cd20f8 	strd	r2, [sp, #8]
        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
    622c:	eb00392e 	bl	146ec <__aeabi_dsub>
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    6230:	e35b0000 	cmp	fp, #0
        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
    6234:	e1a04000 	mov	r4, r0
    6238:	e1a05001 	mov	r5, r1
    623c:	e2877008 	add	r7, r7, #8
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    6240:	da00005e 	ble	63c0 <CORREC+0x23c>
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    6244:	e1c620d0 	ldrd	r2, [r6]
    6248:	eb003a2c 	bl	14b00 <__aeabi_dmul>
    624c:	e1a02000 	mov	r2, r0
    6250:	e1a03001 	mov	r3, r1
    6254:	e14700d8 	ldrd	r0, [r7, #-8]
    6258:	eb003924 	bl	146f0 <__adddf3>

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    625c:	e35b0001 	cmp	fp, #1
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    6260:	e14700f8 	strd	r0, [r7, #-8]

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    6264:	0a000055 	beq	63c0 <CORREC+0x23c>
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    6268:	e1c620d8 	ldrd	r2, [r6, #8]
    626c:	e1a00004 	mov	r0, r4
    6270:	e1a01005 	mov	r1, r5
    6274:	eb003a21 	bl	14b00 <__aeabi_dmul>
    6278:	e1a02000 	mov	r2, r0
    627c:	e1a03001 	mov	r3, r1
    6280:	e14a05d0 	ldrd	r0, [sl, #-80]	; 0xffffffb0
    6284:	eb003919 	bl	146f0 <__adddf3>

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    6288:	e35b0002 	cmp	fp, #2
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    628c:	e14a05f0 	strd	r0, [sl, #-80]	; 0xffffffb0

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    6290:	0a00004a 	beq	63c0 <CORREC+0x23c>
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    6294:	e1c621d0 	ldrd	r2, [r6, #16]
    6298:	e1a00004 	mov	r0, r4
    629c:	e1a01005 	mov	r1, r5
    62a0:	eb003a16 	bl	14b00 <__aeabi_dmul>
    62a4:	e1a02000 	mov	r2, r0
    62a8:	e1a03001 	mov	r3, r1
    62ac:	e1cd00d8 	ldrd	r0, [sp, #8]
    62b0:	eb00390e 	bl	146f0 <__adddf3>

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    62b4:	e35b0003 	cmp	fp, #3
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    62b8:	e14a00f8 	strd	r0, [sl, #-8]

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    62bc:	0a00003f 	beq	63c0 <CORREC+0x23c>
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    62c0:	e1c621d8 	ldrd	r2, [r6, #24]
    62c4:	e1a00004 	mov	r0, r4
    62c8:	e1a01005 	mov	r1, r5
    62cc:	eb003a0b 	bl	14b00 <__aeabi_dmul>
    62d0:	e1a02000 	mov	r2, r0
    62d4:	e1a03001 	mov	r3, r1
    62d8:	e1ca04d0 	ldrd	r0, [sl, #64]	; 0x40
    62dc:	eb003903 	bl	146f0 <__adddf3>

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    62e0:	e35b0004 	cmp	fp, #4
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    62e4:	e1ca04f0 	strd	r0, [sl, #64]	; 0x40

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    62e8:	0a000034 	beq	63c0 <CORREC+0x23c>
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    62ec:	e1c622d0 	ldrd	r2, [r6, #32]
    62f0:	e1a00004 	mov	r0, r4
    62f4:	e1a01005 	mov	r1, r5
    62f8:	eb003a00 	bl	14b00 <__aeabi_dmul>
    62fc:	e1a02000 	mov	r2, r0
    6300:	e1a03001 	mov	r3, r1
    6304:	e1ca08d8 	ldrd	r0, [sl, #136]	; 0x88
    6308:	eb0038f8 	bl	146f0 <__adddf3>

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    630c:	e35b0005 	cmp	fp, #5
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    6310:	e1ca08f8 	strd	r0, [sl, #136]	; 0x88

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    6314:	0a000029 	beq	63c0 <CORREC+0x23c>
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    6318:	e1c622d8 	ldrd	r2, [r6, #40]	; 0x28
    631c:	e1a00004 	mov	r0, r4
    6320:	e1a01005 	mov	r1, r5
    6324:	eb0039f5 	bl	14b00 <__aeabi_dmul>
    6328:	e1a02000 	mov	r2, r0
    632c:	e1a03001 	mov	r3, r1
    6330:	e1ca0dd0 	ldrd	r0, [sl, #208]	; 0xd0
    6334:	eb0038ed 	bl	146f0 <__adddf3>

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    6338:	e35b0006 	cmp	fp, #6
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    633c:	e1ca0df0 	strd	r0, [sl, #208]	; 0xd0

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    6340:	0a00001e 	beq	63c0 <CORREC+0x23c>
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    6344:	e1c623d0 	ldrd	r2, [r6, #48]	; 0x30
    6348:	e1a00004 	mov	r0, r4
    634c:	e1a01005 	mov	r1, r5
    6350:	eb0039ea 	bl	14b00 <__aeabi_dmul>
    6354:	e1a02000 	mov	r2, r0
    6358:	e1a03001 	mov	r3, r1
    635c:	e14805d0 	ldrd	r0, [r8, #-80]	; 0xffffffb0
    6360:	eb0038e2 	bl	146f0 <__adddf3>

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    6364:	e35b0007 	cmp	fp, #7
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    6368:	e14805f0 	strd	r0, [r8, #-80]	; 0xffffffb0

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    636c:	0a000013 	beq	63c0 <CORREC+0x23c>
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    6370:	e1c623d8 	ldrd	r2, [r6, #56]	; 0x38
    6374:	e1a00004 	mov	r0, r4
    6378:	e1a01005 	mov	r1, r5
    637c:	eb0039df 	bl	14b00 <__aeabi_dmul>
    6380:	e1a02000 	mov	r2, r0
    6384:	e1a03001 	mov	r3, r1
    6388:	e1cd00d0 	ldrd	r0, [sp]
    638c:	eb0038d7 	bl	146f0 <__adddf3>

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    6390:	e35b0008 	cmp	fp, #8
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    6394:	e14800f8 	strd	r0, [r8, #-8]

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
                    Y = curr_ptr->mol.F[FORCES][dir][atom] -
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
    6398:	0a000008 	beq	63c0 <CORREC+0x23c>
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
    639c:	e1c624d0 	ldrd	r2, [r6, #64]	; 0x40
    63a0:	e1a00004 	mov	r0, r4
    63a4:	e1a01005 	mov	r1, r5
    63a8:	eb0039d4 	bl	14b00 <__aeabi_dmul>
    63ac:	e1a02000 	mov	r2, r0
    63b0:	e1a03001 	mov	r3, r1
    63b4:	e1c804d0 	ldrd	r0, [r8, #64]	; 0x40
    63b8:	eb0038cc 	bl	146f0 <__adddf3>
    63bc:	e1c804f0 	strd	r0, [r8, #64]	; 0x40

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {

            for (dir = 0; dir < NDIR; dir++) {
                for (atom = 0; atom < NATOM; atom++) {
    63c0:	e159000a 	cmp	r9, sl
    63c4:	1affff93 	bne	6218 <CORREC+0x94>
        /* Loop through the current box's molecules */

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {

            for (dir = 0; dir < NDIR; dir++) {
    63c8:	e59d3018 	ldr	r3, [sp, #24]
    63cc:	e59d0014 	ldr	r0, [sp, #20]
    63d0:	e2533001 	subs	r3, r3, #1
    63d4:	e2800018 	add	r0, r0, #24
    63d8:	e58d3018 	str	r3, [sp, #24]
    63dc:	e58d0014 	str	r0, [sp, #20]
    63e0:	1affff87 	bne	6204 <CORREC+0x80>
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
                } /* for atom */
            } /* for dir */
            curr_ptr= curr_ptr->next_mol;
    63e4:	e59d201c 	ldr	r2, [sp, #28]
    63e8:	e59222a0 	ldr	r2, [r2, #672]	; 0x2a0
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        /* Loop through the current box's molecules */

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
    63ec:	e3520000 	cmp	r2, #0
                        curr_ptr->mol.F[ACC][dir][atom];
                    for ( func = 0; func < NOR1; func++)
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
                } /* for atom */
            } /* for dir */
            curr_ptr= curr_ptr->next_mol;
    63f0:	e58d201c 	str	r2, [sp, #28]
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        /* Loop through the current box's molecules */

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
    63f4:	1affff7d 	bne	61f0 <CORREC+0x6c>
    63f8:	e1a0300b 	mov	r3, fp
    63fc:	e1a0b006 	mov	fp, r6
    6400:	e1a06003 	mov	r6, r3
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
                } /* for atom */
            } /* for dir */
            curr_ptr= curr_ptr->next_mol;
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    6404:	e59d3020 	ldr	r3, [sp, #32]
    6408:	e593300c 	ldr	r3, [r3, #12]
    struct link *curr_ptr;
    box_list *curr_box;

    curr_box = my_boxes[ProcID];

    while (curr_box) {
    640c:	e3530000 	cmp	r3, #0
                        curr_ptr->mol.F[func][dir][atom] += PCC[func] * Y;
                } /* for atom */
            } /* for dir */
            curr_ptr= curr_ptr->next_mol;
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    6410:	e58d3020 	str	r3, [sp, #32]
    struct link *curr_ptr;
    box_list *curr_box;

    curr_box = my_boxes[ProcID];

    while (curr_box) {
    6414:	1affff67 	bne	61b8 <CORREC+0x34>
            curr_ptr= curr_ptr->next_mol;
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    } /* while curr_box */

} /* end of subroutine CORREC */
    6418:	e28dd02c 	add	sp, sp, #44	; 0x2c
    641c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    6420:	0013efcc 	.word	0x0013efcc
    6424:	0013f098 	.word	0x0013f098

00006428 <WorkStart>:
    MAIN_END;
} /* main.c */

void WorkStart() /* routine that each created process starts at;
                    it simply calls the timestep routine */
{
    6428:	e92d4010 	push	{r4, lr}
    long ProcID;
    double LocalXTT;

    LOCK(gl->IndexLock);
    642c:	e59f4074 	ldr	r4, [pc, #116]	; 64a8 <WorkStart+0x80>
    MAIN_END;
} /* main.c */

void WorkStart() /* routine that each created process starts at;
                    it simply calls the timestep routine */
{
    6430:	e24dd008 	sub	sp, sp, #8
    long ProcID;
    double LocalXTT;

    LOCK(gl->IndexLock);
    6434:	e5940000 	ldr	r0, [r4]
    6438:	e280000c 	add	r0, r0, #12
    643c:	ebffe8ec 	bl	7f4 <pthread_mutex_lock>
    ProcID = gl->Index++;
    6440:	e5943000 	ldr	r3, [r4]
    6444:	e593409c 	ldr	r4, [r3, #156]	; 0x9c
    UNLOCK(gl->IndexLock);
    6448:	e283000c 	add	r0, r3, #12
{
    long ProcID;
    double LocalXTT;

    LOCK(gl->IndexLock);
    ProcID = gl->Index++;
    644c:	e2842001 	add	r2, r4, #1
    6450:	e583209c 	str	r2, [r3, #156]	; 0x9c
    UNLOCK(gl->IndexLock);
    6454:	ebffebc0 	bl	135c <pthread_mutex_unlock>

    BARINCLUDE(gl->start);
    BARINCLUDE(gl->InterfBar);
    BARINCLUDE(gl->PotengBar);

    ProcID = ProcID % NumProcs;
    6458:	e59f304c 	ldr	r3, [pc, #76]	; 64ac <WorkStart+0x84>
    645c:	e1a00004 	mov	r0, r4
    6460:	e5931000 	ldr	r1, [r3]
    6464:	eb003895 	bl	146c0 <__aeabi_idivmod>
    6468:	e1a04001 	mov	r4, r1

    /*  POSSIBLE ENHANCEMENT:  Here's where one might bind processes to processors
        if one wanted to.
        */

    LocalXTT = MDMAIN(NSTEP,NPRINT,NSAVE,NORD1,ProcID);
    646c:	e59f003c 	ldr	r0, [pc, #60]	; 64b0 <WorkStart+0x88>
    6470:	e59f103c 	ldr	r1, [pc, #60]	; 64b4 <WorkStart+0x8c>
    6474:	e59f203c 	ldr	r2, [pc, #60]	; 64b8 <WorkStart+0x90>
    6478:	e59f303c 	ldr	r3, [pc, #60]	; 64bc <WorkStart+0x94>
    647c:	e5900000 	ldr	r0, [r0]
    6480:	e5911000 	ldr	r1, [r1]
    6484:	e5922000 	ldr	r2, [r2]
    6488:	e5933000 	ldr	r3, [r3]
    648c:	e58d4000 	str	r4, [sp]
    6490:	ebfff907 	bl	48b4 <MDMAIN>
    if (ProcID == 0) {
    6494:	e3540000 	cmp	r4, #0
	    XTT = LocalXTT;
    6498:	059f3020 	ldreq	r3, [pc, #32]	; 64c0 <WorkStart+0x98>
    649c:	01c300f0 	strdeq	r0, [r3]
    }
}
    64a0:	e28dd008 	add	sp, sp, #8
    64a4:	e8bd8010 	pop	{r4, pc}
    64a8:	0013f3f0 	.word	0x0013f3f0
    64ac:	0013eec0 	.word	0x0013eec0
    64b0:	0013f000 	.word	0x0013f000
    64b4:	0013f0a8 	.word	0x0013f0a8
    64b8:	0013ea94 	.word	0x0013ea94
    64bc:	0013f428 	.word	0x0013f428
    64c0:	0013eff0 	.word	0x0013eff0

000064c4 <main>:
#else
    TSTEP = 1.5e-16;
    NMOL  =  NMOLS;
    NSTEP =  3;
//  NSTEP =  1;
    NORDER  =	6;
    64c4:	e3a0c006 	mov	ip, #6
    NSAVE   = -1 ;
    NRST    = 3000 ;
    NPRINT = 3 ;
    NFMC   = 0;
    NumProcs = NB_P;
    64c8:	e3a00002 	mov	r0, #2
        exit(0);
    }
#else

int main(void)
{
    64cc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

        /*  POSSIBLE ENHANCEMENT:  One might bind the first process to a processor
            here, even before the other (child) processes are bound later in mdmain().
            */

    six = stdout;
    64d0:	e59fbae0 	ldr	fp, [pc, #2784]	; 6fb8 <main+0xaf4>
#ifndef SIM_SOCLIB
    if (scanf("%lf%ld%ld%ld%ld%ld%ld%ld%ld%lf",&TSTEP, &NMOL, &NSTEP, &NORDER, &NSAVE, &NRST, &NPRINT, &NFMC,&NumProcs, &CUTOFF) != 10)
        fprintf(stderr,"ERROR: Usage: water < infile, which must have 10 fields, see SPLASH documentation or comment at top of water.C\n");
#else
    TSTEP = 1.5e-16;
    NMOL  =  NMOLS;
    64d4:	e3a02040 	mov	r2, #64	; 0x40

        /*  POSSIBLE ENHANCEMENT:  One might bind the first process to a processor
            here, even before the other (child) processes are bound later in mdmain().
            */

    six = stdout;
    64d8:	e59b3000 	ldr	r3, [fp]
#else
    TSTEP = 1.5e-16;
    NMOL  =  NMOLS;
    NSTEP =  3;
//  NSTEP =  1;
    NORDER  =	6;
    64dc:	e59f4ad8 	ldr	r4, [pc, #2776]	; 6fbc <main+0xaf8>

        /*  POSSIBLE ENHANCEMENT:  One might bind the first process to a processor
            here, even before the other (child) processes are bound later in mdmain().
            */

    six = stdout;
    64e0:	e5933008 	ldr	r3, [r3, #8]
    64e4:	e59f6ad4 	ldr	r6, [pc, #2772]	; 6fc0 <main+0xafc>
#else
    TSTEP = 1.5e-16;
    NMOL  =  NMOLS;
    NSTEP =  3;
//  NSTEP =  1;
    NORDER  =	6;
    64e8:	e584c000 	str	ip, [r4]

        /*  POSSIBLE ENHANCEMENT:  One might bind the first process to a processor
            here, even before the other (child) processes are bound later in mdmain().
            */

    six = stdout;
    64ec:	e5863000 	str	r3, [r6]
    TSTEP = 1.5e-16;
    NMOL  =  NMOLS;
    NSTEP =  3;
//  NSTEP =  1;
    NORDER  =	6;
    NSAVE   = -1 ;
    64f0:	e3e0c000 	mvn	ip, #0
    NRST    = 3000 ;
    NPRINT = 3 ;
    NFMC   = 0;
    NumProcs = NB_P;
    64f4:	e59f6ac8 	ldr	r6, [pc, #2760]	; 6fc4 <main+0xb00>
    if (scanf("%lf%ld%ld%ld%ld%ld%ld%ld%ld%lf",&TSTEP, &NMOL, &NSTEP, &NORDER, &NSAVE, &NRST, &NPRINT, &NFMC,&NumProcs, &CUTOFF) != 10)
        fprintf(stderr,"ERROR: Usage: water < infile, which must have 10 fields, see SPLASH documentation or comment at top of water.C\n");
#else
    TSTEP = 1.5e-16;
    NMOL  =  NMOLS;
    NSTEP =  3;
    64f8:	e3a01003 	mov	r1, #3
    NORDER  =	6;
    NSAVE   = -1 ;
    NRST    = 3000 ;
    NPRINT = 3 ;
    NFMC   = 0;
    NumProcs = NB_P;
    64fc:	e5860000 	str	r0, [r6]
//    CUTOFF = 6.212752;
    CUTOFF = 4;
    6500:	e3a06000 	mov	r6, #0
#ifndef SIM_SOCLIB
    if (scanf("%lf%ld%ld%ld%ld%ld%ld%ld%ld%lf",&TSTEP, &NMOL, &NSTEP, &NORDER, &NSAVE, &NRST, &NPRINT, &NFMC,&NumProcs, &CUTOFF) != 10)
        fprintf(stderr,"ERROR: Usage: water < infile, which must have 10 fields, see SPLASH documentation or comment at top of water.C\n");
#else
    TSTEP = 1.5e-16;
    NMOL  =  NMOLS;
    6504:	e59f7abc 	ldr	r7, [pc, #2748]	; 6fc8 <main+0xb04>
    NSTEP =  3;
    6508:	e59feabc 	ldr	lr, [pc, #2748]	; 6fcc <main+0xb08>
#ifndef SIM_SOCLIB
    if (scanf("%lf%ld%ld%ld%ld%ld%ld%ld%ld%lf",&TSTEP, &NMOL, &NSTEP, &NORDER, &NSAVE, &NRST, &NPRINT, &NFMC,&NumProcs, &CUTOFF) != 10)
        fprintf(stderr,"ERROR: Usage: water < infile, which must have 10 fields, see SPLASH documentation or comment at top of water.C\n");
#else
    TSTEP = 1.5e-16;
    NMOL  =  NMOLS;
    650c:	e5872000 	str	r2, [r7]
    NSTEP =  3;
//  NSTEP =  1;
    NORDER  =	6;
    NSAVE   = -1 ;
    6510:	e59f7ab8 	ldr	r7, [pc, #2744]	; 6fd0 <main+0xb0c>
    if (scanf("%lf%ld%ld%ld%ld%ld%ld%ld%ld%lf",&TSTEP, &NMOL, &NSTEP, &NORDER, &NSAVE, &NRST, &NPRINT, &NFMC,&NumProcs, &CUTOFF) != 10)
        fprintf(stderr,"ERROR: Usage: water < infile, which must have 10 fields, see SPLASH documentation or comment at top of water.C\n");
#else
    TSTEP = 1.5e-16;
    NMOL  =  NMOLS;
    NSTEP =  3;
    6514:	e58e1000 	str	r1, [lr]
//  NSTEP =  1;
    NORDER  =	6;
    NSAVE   = -1 ;
    6518:	e587c000 	str	ip, [r7]
    NRST    = 3000 ;
    NPRINT = 3 ;
    NFMC   = 0;
    NumProcs = NB_P;
//    CUTOFF = 6.212752;
    CUTOFF = 4;
    651c:	e59f7ab0 	ldr	r7, [pc, #2736]	; 6fd4 <main+0xb10>
    6520:	e59fcab0 	ldr	ip, [pc, #2736]	; 6fd8 <main+0xb14>
//  NSTEP =  1;
    NORDER  =	6;
    NSAVE   = -1 ;
    NRST    = 3000 ;
    NPRINT = 3 ;
    NFMC   = 0;
    6524:	e3a0e000 	mov	lr, #0
    NumProcs = NB_P;
//    CUTOFF = 6.212752;
    CUTOFF = 4;
    6528:	e1cc60f0 	strd	r6, [ip]
            here, even before the other (child) processes are bound later in mdmain().
            */

    six = stdout;

    TEMP  =298.0;
    652c:	e3a06000 	mov	r6, #0
    6530:	e59f7aa4 	ldr	r7, [pc, #2724]	; 6fdc <main+0xb18>
    6534:	e59faaa4 	ldr	sl, [pc, #2724]	; 6fe0 <main+0xb1c>
    RHO   =0.9980;
    6538:	e59fcaa4 	ldr	ip, [pc, #2724]	; 6fe4 <main+0xb20>
            here, even before the other (child) processes are bound later in mdmain().
            */

    six = stdout;

    TEMP  =298.0;
    653c:	e1ca60f0 	strd	r6, [sl]
    RHO   =0.9980;
    6540:	e59f6aa0 	ldr	r6, [pc, #2720]	; 6fe8 <main+0xb24>
    6544:	e59f7aa0 	ldr	r7, [pc, #2720]	; 6fec <main+0xb28>
    NSTEP =  3;
//  NSTEP =  1;
    NORDER  =	6;
    NSAVE   = -1 ;
    NRST    = 3000 ;
    NPRINT = 3 ;
    6548:	e59f8aa0 	ldr	r8, [pc, #2720]	; 6ff0 <main+0xb2c>
            */

    six = stdout;

    TEMP  =298.0;
    RHO   =0.9980;
    654c:	e1cc60f0 	strd	r6, [ip]

#ifndef SIM_SOCLIB
    if (scanf("%lf%ld%ld%ld%ld%ld%ld%ld%ld%lf",&TSTEP, &NMOL, &NSTEP, &NORDER, &NSAVE, &NRST, &NPRINT, &NFMC,&NumProcs, &CUTOFF) != 10)
        fprintf(stderr,"ERROR: Usage: water < infile, which must have 10 fields, see SPLASH documentation or comment at top of water.C\n");
#else
    TSTEP = 1.5e-16;
    6550:	e59f6a9c 	ldr	r6, [pc, #2716]	; 6ff4 <main+0xb30>
    6554:	e59f7a9c 	ldr	r7, [pc, #2716]	; 6ff8 <main+0xb34>
    6558:	e59fca9c 	ldr	ip, [pc, #2716]	; 6ffc <main+0xb38>
//  NSTEP =  1;
    NORDER  =	6;
    NSAVE   = -1 ;
    NRST    = 3000 ;
    NPRINT = 3 ;
    NFMC   = 0;
    655c:	e59f9a9c 	ldr	r9, [pc, #2716]	; 7000 <main+0xb3c>

#ifndef SIM_SOCLIB
    if (scanf("%lf%ld%ld%ld%ld%ld%ld%ld%ld%lf",&TSTEP, &NMOL, &NSTEP, &NORDER, &NSAVE, &NRST, &NPRINT, &NFMC,&NumProcs, &CUTOFF) != 10)
        fprintf(stderr,"ERROR: Usage: water < infile, which must have 10 fields, see SPLASH documentation or comment at top of water.C\n");
#else
    TSTEP = 1.5e-16;
    6560:	e1cc60f0 	strd	r6, [ip]
    NMOL  =  NMOLS;
    NSTEP =  3;
//  NSTEP =  1;
    NORDER  =	6;
    NSAVE   = -1 ;
    NRST    = 3000 ;
    6564:	e59f5a98 	ldr	r5, [pc, #2712]	; 7004 <main+0xb40>
    6568:	e59fca98 	ldr	ip, [pc, #2712]	; 7008 <main+0xb44>
//    CUTOFF = 6.212752;
    CUTOFF = 4;
#endif

    printf("Using %ld procs on %ld steps of %ld mols\n", NumProcs, NSTEP, NMOL);
    printf("Other parameters:\n\tTSTEP = %8.2e\n\tNORDER = %ld\n\tNSAVE = %ld\n",TSTEP,NORDER,NSAVE);
    656c:	e59f6a5c 	ldr	r6, [pc, #2652]	; 6fd0 <main+0xb0c>
        exit(0);
    }
#else

int main(void)
{
    6570:	e24dd05c 	sub	sp, sp, #92	; 0x5c
    NumProcs = NB_P;
//    CUTOFF = 6.212752;
    CUTOFF = 4;
#endif

    printf("Using %ld procs on %ld steps of %ld mols\n", NumProcs, NSTEP, NMOL);
    6574:	e1a03002 	mov	r3, r2
    NSTEP =  3;
//  NSTEP =  1;
    NORDER  =	6;
    NSAVE   = -1 ;
    NRST    = 3000 ;
    NPRINT = 3 ;
    6578:	e5881000 	str	r1, [r8]
    NumProcs = NB_P;
//    CUTOFF = 6.212752;
    CUTOFF = 4;
#endif

    printf("Using %ld procs on %ld steps of %ld mols\n", NumProcs, NSTEP, NMOL);
    657c:	e1a02001 	mov	r2, r1
    6580:	e1a01000 	mov	r1, r0
    6584:	e59f0a80 	ldr	r0, [pc, #2688]	; 700c <main+0xb48>
    NMOL  =  NMOLS;
    NSTEP =  3;
//  NSTEP =  1;
    NORDER  =	6;
    NSAVE   = -1 ;
    NRST    = 3000 ;
    6588:	e585c000 	str	ip, [r5]
    NPRINT = 3 ;
    NFMC   = 0;
    658c:	e589e000 	str	lr, [r9]
    NumProcs = NB_P;
//    CUTOFF = 6.212752;
    CUTOFF = 4;
#endif

    printf("Using %ld procs on %ld steps of %ld mols\n", NumProcs, NSTEP, NMOL);
    6590:	eb00492f 	bl	18a54 <printf>
    printf("Other parameters:\n\tTSTEP = %8.2e\n\tNORDER = %ld\n\tNSAVE = %ld\n",TSTEP,NORDER,NSAVE);
    6594:	e59fea60 	ldr	lr, [pc, #2656]	; 6ffc <main+0xb38>
    6598:	e5961000 	ldr	r1, [r6]
    659c:	e5940000 	ldr	r0, [r4]
    65a0:	e1ce20d0 	ldrd	r2, [lr]
    65a4:	e88d0003 	stm	sp, {r0, r1}
    65a8:	e59f0a60 	ldr	r0, [pc, #2656]	; 7010 <main+0xb4c>
    65ac:	eb004928 	bl	18a54 <printf>
    printf("\tNRST = %ld\n\tNPRINT = %ld\n\tNFMC = %ld\n\tCUTOFF = %lf\n\n",NRST,NPRINT,NFMC,CUTOFF);
    65b0:	e59f1a20 	ldr	r1, [pc, #2592]	; 6fd8 <main+0xb14>
    65b4:	e5982000 	ldr	r2, [r8]
    65b8:	e1c100d0 	ldrd	r0, [r1]
    65bc:	e1cd01f0 	strd	r0, [sp, #16]
    65c0:	e1cd61d0 	ldrd	r6, [sp, #16]
    65c4:	e5993000 	ldr	r3, [r9]
    65c8:	e5951000 	ldr	r1, [r5]
    65cc:	e59f0a40 	ldr	r0, [pc, #2624]	; 7014 <main+0xb50>
    65d0:	e1cd60f0 	strd	r6, [sp]
    65d4:	eb00491e 	bl	18a54 <printf>

    /* set up scaling factors and constants */

    NORD1=NORDER+1;
    65d8:	e5943000 	ldr	r3, [r4]
    65dc:	e59f2a34 	ldr	r2, [pc, #2612]	; 7018 <main+0xb54>
    65e0:	e2833001 	add	r3, r3, #1
    CNSTNT(NORD1,TLC);  /* sub. call to set up constants */

    SYSCNS();    /* sub. call to initialize system constants  */

    printf("%ld boxes with %ld processors\n\n",
           BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE, NumProcs);
    65e4:	e59f7a30 	ldr	r7, [pc, #2608]	; 701c <main+0xb58>

    /* set up scaling factors and constants */

    NORD1=NORDER+1;

    CNSTNT(NORD1,TLC);  /* sub. call to set up constants */
    65e8:	e1a00003 	mov	r0, r3
    65ec:	e59f1a2c 	ldr	r1, [pc, #2604]	; 7020 <main+0xb5c>
    printf("Other parameters:\n\tTSTEP = %8.2e\n\tNORDER = %ld\n\tNSAVE = %ld\n",TSTEP,NORDER,NSAVE);
    printf("\tNRST = %ld\n\tNPRINT = %ld\n\tNFMC = %ld\n\tCUTOFF = %lf\n\n",NRST,NPRINT,NFMC,CUTOFF);

    /* set up scaling factors and constants */

    NORD1=NORDER+1;
    65f0:	e5823000 	str	r3, [r2]

    CNSTNT(NORD1,TLC);  /* sub. call to set up constants */
    65f4:	ebfffbc7 	bl	5518 <CNSTNT>

    SYSCNS();    /* sub. call to initialize system constants  */
    65f8:	eb0008eb 	bl	89ac <SYSCNS>

    printf("%ld boxes with %ld processors\n\n",
           BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE, NumProcs);
    65fc:	e5973000 	ldr	r3, [r7]

    CNSTNT(NORD1,TLC);  /* sub. call to set up constants */

    SYSCNS();    /* sub. call to initialize system constants  */

    printf("%ld boxes with %ld processors\n\n",
    6600:	e59fc9bc 	ldr	ip, [pc, #2492]	; 6fc4 <main+0xb00>
           BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE, NumProcs);
    6604:	e0010393 	mul	r1, r3, r3

    CNSTNT(NORD1,TLC);  /* sub. call to set up constants */

    SYSCNS();    /* sub. call to initialize system constants  */

    printf("%ld boxes with %ld processors\n\n",
    6608:	e59c2000 	ldr	r2, [ip]
    660c:	e0010391 	mul	r1, r1, r3
    6610:	e59f0a0c 	ldr	r0, [pc, #2572]	; 7024 <main+0xb60>
    6614:	eb00490e 	bl	18a54 <printf>
           BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE, NumProcs);

    if (NumProcs > (BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE)) {
    6618:	e5972000 	ldr	r2, [r7]
    661c:	e59fe9a0 	ldr	lr, [pc, #2464]	; 6fc4 <main+0xb00>
    6620:	e0010292 	mul	r1, r2, r2
    6624:	e0020291 	mul	r2, r1, r2
    6628:	e59e3000 	ldr	r3, [lr]
    662c:	e1520003 	cmp	r2, r3
    6630:	ba00023a 	blt	6f20 <main+0xa5c>
                BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE, NumProcs);
        fflush(stderr);
        exit(-1);
    }

    fprintf(six,"\nTEMPERATURE                = %8.2f K\n",TEMP);
    6634:	e1ca20d0 	ldrd	r2, [sl]
    6638:	e59f1980 	ldr	r1, [pc, #2432]	; 6fc0 <main+0xafc>
    fprintf(six,"DENSITY                    = %8.5f G/C.C.\n",RHO);
    663c:	e59f797c 	ldr	r7, [pc, #2428]	; 6fc0 <main+0xafc>
    6640:	e59f699c 	ldr	r6, [pc, #2460]	; 6fe4 <main+0xb20>
                BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE, NumProcs);
        fflush(stderr);
        exit(-1);
    }

    fprintf(six,"\nTEMPERATURE                = %8.2f K\n",TEMP);
    6644:	e5910000 	ldr	r0, [r1]
    6648:	e59f19d8 	ldr	r1, [pc, #2520]	; 7028 <main+0xb64>
    664c:	eb004079 	bl	16838 <fprintf>
    fprintf(six,"DENSITY                    = %8.5f G/C.C.\n",RHO);
    6650:	e1c620d0 	ldrd	r2, [r6]
    6654:	e5970000 	ldr	r0, [r7]
    6658:	e59f19cc 	ldr	r1, [pc, #2508]	; 702c <main+0xb68>
    665c:	eb004075 	bl	16838 <fprintf>
    fprintf(six,"NUMBER OF MOLECULES        = %8ld\n",NMOL);
    6660:	e59fc960 	ldr	ip, [pc, #2400]	; 6fc8 <main+0xb04>
    6664:	e5970000 	ldr	r0, [r7]
    6668:	e59c2000 	ldr	r2, [ip]
    666c:	e59f19bc 	ldr	r1, [pc, #2492]	; 7030 <main+0xb6c>
    6670:	eb004070 	bl	16838 <fprintf>
    fprintf(six,"NUMBER OF PROCESSORS       = %8ld\n",NumProcs);
    6674:	e59fe948 	ldr	lr, [pc, #2376]	; 6fc4 <main+0xb00>
    6678:	e5970000 	ldr	r0, [r7]
    667c:	e59e2000 	ldr	r2, [lr]
    6680:	e59f19ac 	ldr	r1, [pc, #2476]	; 7034 <main+0xb70>
    6684:	eb00406b 	bl	16838 <fprintf>
    fprintf(six,"TIME STEP                  = %8.2e SEC\n",TSTEP);
    6688:	e59f096c 	ldr	r0, [pc, #2412]	; 6ffc <main+0xb38>
    668c:	e59f19a4 	ldr	r1, [pc, #2468]	; 7038 <main+0xb74>
    6690:	e1c020d0 	ldrd	r2, [r0]
    6694:	e5970000 	ldr	r0, [r7]
    6698:	eb004066 	bl	16838 <fprintf>
    fprintf(six,"ORDER USED TO SOLVE F=MA   = %8ld \n",NORDER);
    669c:	e5942000 	ldr	r2, [r4]
    66a0:	e5970000 	ldr	r0, [r7]
    66a4:	e59f1990 	ldr	r1, [pc, #2448]	; 703c <main+0xb78>
    66a8:	eb004062 	bl	16838 <fprintf>
    fprintf(six,"NO. OF TIME STEPS          = %8ld \n",NSTEP);
    66ac:	e59f1918 	ldr	r1, [pc, #2328]	; 6fcc <main+0xb08>
    66b0:	e5970000 	ldr	r0, [r7]
    66b4:	e5912000 	ldr	r2, [r1]
    66b8:	e59f1980 	ldr	r1, [pc, #2432]	; 7040 <main+0xb7c>
    66bc:	eb00405d 	bl	16838 <fprintf>
    fprintf(six,"FREQUENCY OF DATA SAVING   = %8ld \n",NSAVE);
    66c0:	e59f3908 	ldr	r3, [pc, #2312]	; 6fd0 <main+0xb0c>
    66c4:	e5970000 	ldr	r0, [r7]
    66c8:	e5932000 	ldr	r2, [r3]
    66cc:	e59f1970 	ldr	r1, [pc, #2416]	; 7044 <main+0xb80>
    66d0:	eb004058 	bl	16838 <fprintf>
    fprintf(six,"FREQUENCY TO WRITE RST FILE= %8ld \n",NRST);
    66d4:	e5952000 	ldr	r2, [r5]
    66d8:	e59f1968 	ldr	r1, [pc, #2408]	; 7048 <main+0xb84>
    66dc:	e5970000 	ldr	r0, [r7]
    66e0:	eb004054 	bl	16838 <fprintf>
    fflush(six);
    66e4:	e5970000 	ldr	r0, [r7]
    66e8:	eb003e8c 	bl	16120 <fflush>
        long x_first, y_first, z_first;
        long x_last, y_last, z_last;
        double proccbrt;
        long gmem_size = sizeof(struct GlobalMemory);

        MAIN_INITENV((NumProcs),40000000,);  /* macro call to initialize
    66ec:	e59f0958 	ldr	r0, [pc, #2392]	; 704c <main+0xb88>
    66f0:	eb0043e3 	bl	17684 <malloc>
        /* Allocate space for main (BOX) data structure as well as
         * synchronization variables
         */

        start_end = (first_last_array **)
            G_MALLOC(sizeof(first_last_array *) * NumProcs);
    66f4:	e59f68c8 	ldr	r6, [pc, #2248]	; 6fc4 <main+0xb00>
        long x_first, y_first, z_first;
        long x_last, y_last, z_last;
        double proccbrt;
        long gmem_size = sizeof(struct GlobalMemory);

        MAIN_INITENV((NumProcs),40000000,);  /* macro call to initialize
    66f8:	e59f7950 	ldr	r7, [pc, #2384]	; 7050 <main+0xb8c>
        /* Allocate space for main (BOX) data structure as well as
         * synchronization variables
         */

        start_end = (first_last_array **)
            G_MALLOC(sizeof(first_last_array *) * NumProcs);
    66fc:	e5964000 	ldr	r4, [r6]
        long x_first, y_first, z_first;
        long x_last, y_last, z_last;
        double proccbrt;
        long gmem_size = sizeof(struct GlobalMemory);

        MAIN_INITENV((NumProcs),40000000,);  /* macro call to initialize
    6700:	e5870000 	str	r0, [r7]
        /* Allocate space for main (BOX) data structure as well as
         * synchronization variables
         */

        start_end = (first_last_array **)
            G_MALLOC(sizeof(first_last_array *) * NumProcs);
    6704:	e1a00104 	lsl	r0, r4, #2
    6708:	eb0043dd 	bl	17684 <malloc>

        /* Allocate space for main (BOX) data structure as well as
         * synchronization variables
         */

        start_end = (first_last_array **)
    670c:	e59fc940 	ldr	ip, [pc, #2368]	; 7054 <main+0xb90>
            G_MALLOC(sizeof(first_last_array *) * NumProcs);
        for (i=0; i < NumProcs; i++) {
    6710:	e3540000 	cmp	r4, #0

        /* Allocate space for main (BOX) data structure as well as
         * synchronization variables
         */

        start_end = (first_last_array **)
    6714:	e58c0000 	str	r0, [ip]
            G_MALLOC(sizeof(first_last_array *) * NumProcs);
        for (i=0; i < NumProcs; i++) {
    6718:	da00000a 	ble	6748 <main+0x284>
    671c:	e1a06000 	mov	r6, r0
    6720:	e3a05000 	mov	r5, #0
    6724:	ea000001 	b	6730 <main+0x26c>
    6728:	e59fe924 	ldr	lr, [pc, #2340]	; 7054 <main+0xb90>
    672c:	e59e6000 	ldr	r6, [lr]
            start_end[i] = (first_last_array *)
                G_MALLOC(sizeof(first_last_array));
    6730:	e3a00018 	mov	r0, #24
    6734:	eb0043d2 	bl	17684 <malloc>
         */

        start_end = (first_last_array **)
            G_MALLOC(sizeof(first_last_array *) * NumProcs);
        for (i=0; i < NumProcs; i++) {
            start_end[i] = (first_last_array *)
    6738:	e7860105 	str	r0, [r6, r5, lsl #2]
         * synchronization variables
         */

        start_end = (first_last_array **)
            G_MALLOC(sizeof(first_last_array *) * NumProcs);
        for (i=0; i < NumProcs; i++) {
    673c:	e2855001 	add	r5, r5, #1
    6740:	e1550004 	cmp	r5, r4
    6744:	1afffff7 	bne	6728 <main+0x264>
        /* Calculate start and finish box numbers for processors */

        xprocs = 0;
        yprocs = 0;
        zprocs = 0;
        proccbrt = (double) pow((double) NumProcs, 1.0/3.0) + 0.00000000000001;
    6748:	e1a00004 	mov	r0, r4
    674c:	eb0038b4 	bl	14a24 <__aeabi_i2d>
    6750:	e59f2900 	ldr	r2, [pc, #2304]	; 7058 <main+0xb94>
    6754:	e59f3900 	ldr	r3, [pc, #2304]	; 705c <main+0xb98>
    6758:	eb008dba 	bl	29e48 <pow>
    675c:	e59f28fc 	ldr	r2, [pc, #2300]	; 7060 <main+0xb9c>
    6760:	e59f38fc 	ldr	r3, [pc, #2300]	; 7064 <main+0xba0>
    6764:	eb0037e1 	bl	146f0 <__adddf3>
        j = (long) proccbrt;
    6768:	eb003a5c 	bl	150e0 <__aeabi_d2iz>
         * synchronization variables
         */

        start_end = (first_last_array **)
            G_MALLOC(sizeof(first_last_array *) * NumProcs);
        for (i=0; i < NumProcs; i++) {
    676c:	e3a06000 	mov	r6, #0
        xprocs = 0;
        yprocs = 0;
        zprocs = 0;
        proccbrt = (double) pow((double) NumProcs, 1.0/3.0) + 0.00000000000001;
        j = (long) proccbrt;
        if (j<1) j = 1;
    6770:	e3500001 	cmp	r0, #1
    6774:	a1a05000 	movge	r5, r0
    6778:	b3a05001 	movlt	r5, #1
    677c:	e1a0a006 	mov	sl, r6
    6780:	e1a0c006 	mov	ip, r6
         * synchronization variables
         */

        start_end = (first_last_array **)
            G_MALLOC(sizeof(first_last_array *) * NumProcs);
        for (i=0; i < NumProcs; i++) {
    6784:	e58d6024 	str	r6, [sp, #36]	; 0x24
    6788:	e58d6040 	str	r6, [sp, #64]	; 0x40
    678c:	e2657000 	rsb	r7, r5, #0
        zprocs = 0;
        proccbrt = (double) pow((double) NumProcs, 1.0/3.0) + 0.00000000000001;
        j = (long) proccbrt;
        if (j<1) j = 1;
        while ((xprocs == 0) && (j>0)) {
            k = (long) sqrt((double) (NumProcs / j));
    6790:	e59fe82c 	ldr	lr, [pc, #2092]	; 6fc4 <main+0xb00>
    6794:	e1a01005 	mov	r1, r5
    6798:	e59e0000 	ldr	r0, [lr]
    679c:	e58dc00c 	str	ip, [sp, #12]
    67a0:	eb00377c 	bl	14598 <__aeabi_idiv>
    67a4:	eb00389e 	bl	14a24 <__aeabi_i2d>
    67a8:	eb008fc0 	bl	2a6b0 <sqrt>
    67ac:	eb003a4b 	bl	150e0 <__aeabi_d2iz>
            if (k<1) k=1;
            while ((yprocs == 0) && (k>0)) {
    67b0:	e59dc00c 	ldr	ip, [sp, #12]
        proccbrt = (double) pow((double) NumProcs, 1.0/3.0) + 0.00000000000001;
        j = (long) proccbrt;
        if (j<1) j = 1;
        while ((xprocs == 0) && (j>0)) {
            k = (long) sqrt((double) (NumProcs / j));
            if (k<1) k=1;
    67b4:	e3500001 	cmp	r0, #1
    67b8:	a1a04000 	movge	r4, r0
    67bc:	b3a04001 	movlt	r4, #1
            while ((yprocs == 0) && (k>0)) {
    67c0:	e35c0000 	cmp	ip, #0
    67c4:	1a0001d0 	bne	6f0c <main+0xa48>
    67c8:	e1a0600c 	mov	r6, ip
    67cc:	e59f07f0 	ldr	r0, [pc, #2032]	; 6fc4 <main+0xb00>
    67d0:	e0080495 	mul	r8, r5, r4
    67d4:	e5909000 	ldr	r9, [r0]
                l = NumProcs/(j*k);
    67d8:	e1a01008 	mov	r1, r8
    67dc:	e1a00009 	mov	r0, r9
    67e0:	eb00376c 	bl	14598 <__aeabi_idiv>
    67e4:	e16f3f14 	clz	r3, r4
                if ((j*k*l) == NumProcs) {
    67e8:	e0020890 	mul	r2, r0, r8
    67ec:	e1520009 	cmp	r2, r9
    67f0:	01a0c004 	moveq	ip, r4
    67f4:	01a06005 	moveq	r6, r5
    67f8:	01a0a000 	moveq	sl, r0
    67fc:	13a0c000 	movne	ip, #0
    6800:	e1520009 	cmp	r2, r9
    6804:	e1a032a3 	lsr	r3, r3, #5
    6808:	13a03001 	movne	r3, #1
                    xprocs = j;
                    yprocs = k;
                    zprocs = l;
                } /* if */
                k--;
    680c:	e2444001 	sub	r4, r4, #1
        j = (long) proccbrt;
        if (j<1) j = 1;
        while ((xprocs == 0) && (j>0)) {
            k = (long) sqrt((double) (NumProcs / j));
            if (k<1) k=1;
            while ((yprocs == 0) && (k>0)) {
    6810:	e3540000 	cmp	r4, #0
    6814:	d3a03000 	movle	r3, #0
    6818:	c2033001 	andgt	r3, r3, #1
    681c:	e3530000 	cmp	r3, #0
    6820:	e0888007 	add	r8, r8, r7
    6824:	1affffeb 	bne	67d8 <main+0x314>
    6828:	e16f3f16 	clz	r3, r6
    682c:	e1a032a3 	lsr	r3, r3, #5
                    yprocs = k;
                    zprocs = l;
                } /* if */
                k--;
            } /* while yprocs && k */
            j--;
    6830:	e2455001 	sub	r5, r5, #1
        yprocs = 0;
        zprocs = 0;
        proccbrt = (double) pow((double) NumProcs, 1.0/3.0) + 0.00000000000001;
        j = (long) proccbrt;
        if (j<1) j = 1;
        while ((xprocs == 0) && (j>0)) {
    6834:	e3550000 	cmp	r5, #0
    6838:	d3a04000 	movle	r4, #0
    683c:	c2034001 	andgt	r4, r3, #1
    6840:	e3540000 	cmp	r4, #0
    6844:	e2877001 	add	r7, r7, #1
    6848:	1affffd0 	bne	6790 <main+0x2cc>
                k--;
            } /* while yprocs && k */
            j--;
        } /* while xprocs && j */

        printf("xprocs = %ld\typrocs = %ld\tzprocs = %ld\n",
    684c:	e1a0200c 	mov	r2, ip
    6850:	e1a01006 	mov	r1, r6
    6854:	e1a0300a 	mov	r3, sl
    6858:	e59f0808 	ldr	r0, [pc, #2056]	; 7068 <main+0xba4>
    685c:	e58dc040 	str	ip, [sp, #64]	; 0x40
    6860:	e58da024 	str	sl, [sp, #36]	; 0x24
    6864:	eb00487a 	bl	18a54 <printf>
               xprocs, yprocs, zprocs);
        fflush(stdout);
    6868:	e59b3000 	ldr	r3, [fp]

        /* Fill in start_end array values */

        procnum = 0;
        x_inc = BOX_PER_SIDE/xprocs;
    686c:	e59f87a8 	ldr	r8, [pc, #1960]	; 701c <main+0xb58>
            j--;
        } /* while xprocs && j */

        printf("xprocs = %ld\typrocs = %ld\tzprocs = %ld\n",
               xprocs, yprocs, zprocs);
        fflush(stdout);
    6870:	e5930008 	ldr	r0, [r3, #8]
    6874:	eb003e29 	bl	16120 <fflush>

        /* Fill in start_end array values */

        procnum = 0;
        x_inc = BOX_PER_SIDE/xprocs;
    6878:	e5989000 	ldr	r9, [r8]
    687c:	e1a01006 	mov	r1, r6
    6880:	e1a00009 	mov	r0, r9
    6884:	eb003743 	bl	14598 <__aeabi_idiv>
        y_inc = BOX_PER_SIDE/yprocs;
    6888:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
        fflush(stdout);

        /* Fill in start_end array values */

        procnum = 0;
        x_inc = BOX_PER_SIDE/xprocs;
    688c:	e1a07000 	mov	r7, r0
        y_inc = BOX_PER_SIDE/yprocs;
    6890:	e1a00009 	mov	r0, r9
    6894:	eb00373f 	bl	14598 <__aeabi_idiv>
        z_inc = BOX_PER_SIDE/zprocs;
    6898:	e59d1024 	ldr	r1, [sp, #36]	; 0x24

        /* Fill in start_end array values */

        procnum = 0;
        x_inc = BOX_PER_SIDE/xprocs;
        y_inc = BOX_PER_SIDE/yprocs;
    689c:	e58d0028 	str	r0, [sp, #40]	; 0x28
        z_inc = BOX_PER_SIDE/zprocs;
    68a0:	e1a00009 	mov	r0, r9
    68a4:	eb00373b 	bl	14598 <__aeabi_idiv>

        x_left = BOX_PER_SIDE - (xprocs*x_inc);
        y_left = BOX_PER_SIDE - (yprocs*y_inc);
    68a8:	e59de028 	ldr	lr, [sp, #40]	; 0x28
    68ac:	e59dc040 	ldr	ip, [sp, #64]	; 0x40
        procnum = 0;
        x_inc = BOX_PER_SIDE/xprocs;
        y_inc = BOX_PER_SIDE/yprocs;
        z_inc = BOX_PER_SIDE/zprocs;

        x_left = BOX_PER_SIDE - (xprocs*x_inc);
    68b0:	e0010796 	mul	r1, r6, r7
        y_left = BOX_PER_SIDE - (yprocs*y_inc);
    68b4:	e0020e9c 	mul	r2, ip, lr
        z_left = BOX_PER_SIDE - (zprocs*z_inc);
    68b8:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
        procnum = 0;
        x_inc = BOX_PER_SIDE/xprocs;
        y_inc = BOX_PER_SIDE/yprocs;
        z_inc = BOX_PER_SIDE/zprocs;

        x_left = BOX_PER_SIDE - (xprocs*x_inc);
    68bc:	e0611009 	rsb	r1, r1, r9
        y_left = BOX_PER_SIDE - (yprocs*y_inc);
        z_left = BOX_PER_SIDE - (zprocs*z_inc);
    68c0:	e003009c 	mul	r3, ip, r0
        x_inc = BOX_PER_SIDE/xprocs;
        y_inc = BOX_PER_SIDE/yprocs;
        z_inc = BOX_PER_SIDE/zprocs;

        x_left = BOX_PER_SIDE - (xprocs*x_inc);
        y_left = BOX_PER_SIDE - (yprocs*y_inc);
    68c4:	e0622009 	rsb	r2, r2, r9
        z_left = BOX_PER_SIDE - (zprocs*z_inc);
    68c8:	e0633009 	rsb	r3, r3, r9
        procnum = 0;
        x_inc = BOX_PER_SIDE/xprocs;
        y_inc = BOX_PER_SIDE/yprocs;
        z_inc = BOX_PER_SIDE/zprocs;

        x_left = BOX_PER_SIDE - (xprocs*x_inc);
    68cc:	e58d103c 	str	r1, [sp, #60]	; 0x3c
        y_left = BOX_PER_SIDE - (yprocs*y_inc);
    68d0:	e58d2048 	str	r2, [sp, #72]	; 0x48
        z_left = BOX_PER_SIDE - (zprocs*z_inc);
        printf("x_inc = %ld\t y_inc = %ld\t z_inc = %ld\n",x_inc,y_inc,z_inc);
    68d4:	e1a01007 	mov	r1, r7
    68d8:	e1a0200e 	mov	r2, lr
        y_inc = BOX_PER_SIDE/yprocs;
        z_inc = BOX_PER_SIDE/zprocs;

        x_left = BOX_PER_SIDE - (xprocs*x_inc);
        y_left = BOX_PER_SIDE - (yprocs*y_inc);
        z_left = BOX_PER_SIDE - (zprocs*z_inc);
    68dc:	e58d3030 	str	r3, [sp, #48]	; 0x30
        /* Fill in start_end array values */

        procnum = 0;
        x_inc = BOX_PER_SIDE/xprocs;
        y_inc = BOX_PER_SIDE/yprocs;
        z_inc = BOX_PER_SIDE/zprocs;
    68e0:	e1a05000 	mov	r5, r0

        x_left = BOX_PER_SIDE - (xprocs*x_inc);
        y_left = BOX_PER_SIDE - (yprocs*y_inc);
        z_left = BOX_PER_SIDE - (zprocs*z_inc);
        printf("x_inc = %ld\t y_inc = %ld\t z_inc = %ld\n",x_inc,y_inc,z_inc);
    68e4:	e1a03000 	mov	r3, r0
    68e8:	e59f077c 	ldr	r0, [pc, #1916]	; 706c <main+0xba8>
    68ec:	eb004858 	bl	18a54 <printf>
        printf("x_left = %ld\t y_left = %ld\t z_left = %ld\n",x_left,y_left,z_left);
    68f0:	e59d103c 	ldr	r1, [sp, #60]	; 0x3c
    68f4:	e59d2048 	ldr	r2, [sp, #72]	; 0x48
    68f8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
    68fc:	e59f076c 	ldr	r0, [pc, #1900]	; 7070 <main+0xbac>
    6900:	eb004853 	bl	18a54 <printf>
        fflush(stdout);
    6904:	e59b3000 	ldr	r3, [fp]


        x_first = 0;
        x_ct = x_left;
        x_last = -1;
        x_inc++;
    6908:	e2877001 	add	r7, r7, #1
        x_left = BOX_PER_SIDE - (xprocs*x_inc);
        y_left = BOX_PER_SIDE - (yprocs*y_inc);
        z_left = BOX_PER_SIDE - (zprocs*z_inc);
        printf("x_inc = %ld\t y_inc = %ld\t z_inc = %ld\n",x_inc,y_inc,z_inc);
        printf("x_left = %ld\t y_left = %ld\t z_left = %ld\n",x_left,y_left,z_left);
        fflush(stdout);
    690c:	e5930008 	ldr	r0, [r3, #8]
    6910:	eb003e02 	bl	16120 <fflush>

        x_first = 0;
        x_ct = x_left;
        x_last = -1;
        x_inc++;
        for (i=0; i<xprocs; i++) {
    6914:	e3560000 	cmp	r6, #0


        x_first = 0;
        x_ct = x_left;
        x_last = -1;
        x_inc++;
    6918:	e58d7044 	str	r7, [sp, #68]	; 0x44
        for (i=0; i<xprocs; i++) {
    691c:	da00017d 	ble	6f18 <main+0xa54>
        fflush(stdout);


        x_first = 0;
        x_ct = x_left;
        x_last = -1;
    6920:	e3e0e000 	mvn	lr, #0
    6924:	e59d703c 	ldr	r7, [sp, #60]	; 0x3c
    6928:	e59dc048 	ldr	ip, [sp, #72]	; 0x48
    692c:	e0666007 	rsb	r6, r6, r7
    6930:	e58d604c 	str	r6, [sp, #76]	; 0x4c
    6934:	e59d6040 	ldr	r6, [sp, #64]	; 0x40
    6938:	e59f0714 	ldr	r0, [pc, #1812]	; 7054 <main+0xb90>
    693c:	e066c00c 	rsb	ip, r6, ip
        printf("x_inc = %ld\t y_inc = %ld\t z_inc = %ld\n",x_inc,y_inc,z_inc);
        printf("x_left = %ld\t y_left = %ld\t z_left = %ld\n",x_left,y_left,z_left);
        fflush(stdout);


        x_first = 0;
    6940:	e1a0a004 	mov	sl, r4
               xprocs, yprocs, zprocs);
        fflush(stdout);

        /* Fill in start_end array values */

        procnum = 0;
    6944:	e58d4020 	str	r4, [sp, #32]
    6948:	e5900000 	ldr	r0, [r0]
    694c:	e5984000 	ldr	r4, [r8]
    6950:	e58dc02c 	str	ip, [sp, #44]	; 0x2c
    6954:	e59d6024 	ldr	r6, [sp, #36]	; 0x24
    6958:	e59dc030 	ldr	ip, [sp, #48]	; 0x30
        fflush(stdout);


        x_first = 0;
        x_ct = x_left;
        x_last = -1;
    695c:	e58de038 	str	lr, [sp, #56]	; 0x38
    6960:	e58d0034 	str	r0, [sp, #52]	; 0x34
                for (k=0; k<zprocs; k++) {
                    if (z_ct == 0) z_inc--;
                    z_last += z_inc;
                    start_end[procnum]->box[XDIR][FIRST] = x_first;
                    start_end[procnum]->box[XDIR][LAST] =
                        min(x_last, BOX_PER_SIDE - 1);
    6964:	e084700e 	add	r7, r4, lr
    6968:	e066b00c 	rsb	fp, r6, ip
        x_ct = x_left;
        x_last = -1;
        x_inc++;
        for (i=0; i<xprocs; i++) {
            y_ct = y_left;
            if (x_ct == 0) x_inc--;
    696c:	e59dc03c 	ldr	ip, [sp, #60]	; 0x3c
            x_last += x_inc;
            y_first = 0;
            y_last = -1;
            y_inc++;
            for (j=0; j<yprocs; j++) {
    6970:	e59d6040 	ldr	r6, [sp, #64]	; 0x40
        x_ct = x_left;
        x_last = -1;
        x_inc++;
        for (i=0; i<xprocs; i++) {
            y_ct = y_left;
            if (x_ct == 0) x_inc--;
    6974:	e35c0000 	cmp	ip, #0
    6978:	059de044 	ldreq	lr, [sp, #68]	; 0x44
            x_last += x_inc;
    697c:	e59dc038 	ldr	ip, [sp, #56]	; 0x38
        x_ct = x_left;
        x_last = -1;
        x_inc++;
        for (i=0; i<xprocs; i++) {
            y_ct = y_left;
            if (x_ct == 0) x_inc--;
    6980:	024ee001 	subeq	lr, lr, #1
    6984:	058de044 	streq	lr, [sp, #68]	; 0x44
            x_last += x_inc;
    6988:	e59de044 	ldr	lr, [sp, #68]	; 0x44
            y_first = 0;
            y_last = -1;
            y_inc++;
            for (j=0; j<yprocs; j++) {
    698c:	e3560000 	cmp	r6, #0
            y_ct = y_left;
            if (x_ct == 0) x_inc--;
            x_last += x_inc;
            y_first = 0;
            y_last = -1;
            y_inc++;
    6990:	e59d6028 	ldr	r6, [sp, #40]	; 0x28
        x_last = -1;
        x_inc++;
        for (i=0; i<xprocs; i++) {
            y_ct = y_left;
            if (x_ct == 0) x_inc--;
            x_last += x_inc;
    6994:	e08cc00e 	add	ip, ip, lr
            y_first = 0;
            y_last = -1;
            y_inc++;
    6998:	e2866001 	add	r6, r6, #1
        x_last = -1;
        x_inc++;
        for (i=0; i<xprocs; i++) {
            y_ct = y_left;
            if (x_ct == 0) x_inc--;
            x_last += x_inc;
    699c:	e58dc038 	str	ip, [sp, #56]	; 0x38
            y_first = 0;
            y_last = -1;
            y_inc++;
    69a0:	e58d6028 	str	r6, [sp, #40]	; 0x28
            for (j=0; j<yprocs; j++) {
    69a4:	da00003b 	ble	6a98 <main+0x5d4>
    69a8:	e15c0004 	cmp	ip, r4
        for (i=0; i<xprocs; i++) {
            y_ct = y_left;
            if (x_ct == 0) x_inc--;
            x_last += x_inc;
            y_first = 0;
            y_last = -1;
    69ac:	e3e0e000 	mvn	lr, #0
    69b0:	e1a0900c 	mov	r9, ip
        x_inc++;
        for (i=0; i<xprocs; i++) {
            y_ct = y_left;
            if (x_ct == 0) x_inc--;
            x_last += x_inc;
            y_first = 0;
    69b4:	e3a06000 	mov	r6, #0
    69b8:	a1a09007 	movge	r9, r7
        x_first = 0;
        x_ct = x_left;
        x_last = -1;
        x_inc++;
        for (i=0; i<xprocs; i++) {
            y_ct = y_left;
    69bc:	e59dc048 	ldr	ip, [sp, #72]	; 0x48
            if (x_ct == 0) x_inc--;
            x_last += x_inc;
            y_first = 0;
            y_last = -1;
    69c0:	e58de018 	str	lr, [sp, #24]
        x_first = 0;
        x_ct = x_left;
        x_last = -1;
        x_inc++;
        for (i=0; i<xprocs; i++) {
            y_ct = y_left;
    69c4:	e58dc01c 	str	ip, [sp, #28]
            y_first = 0;
            y_last = -1;
            y_inc++;
            for (j=0; j<yprocs; j++) {
                z_ct = z_left;
                if (y_ct == 0) y_inc--;
    69c8:	e59d001c 	ldr	r0, [sp, #28]
                y_last += y_inc;
    69cc:	e59de018 	ldr	lr, [sp, #24]
            y_first = 0;
            y_last = -1;
            y_inc++;
            for (j=0; j<yprocs; j++) {
                z_ct = z_left;
                if (y_ct == 0) y_inc--;
    69d0:	e3500000 	cmp	r0, #0
    69d4:	059dc028 	ldreq	ip, [sp, #40]	; 0x28
                y_last += y_inc;
                z_first = 0;
                z_last = -1;
                z_inc++;
    69d8:	e2855001 	add	r5, r5, #1
            y_first = 0;
            y_last = -1;
            y_inc++;
            for (j=0; j<yprocs; j++) {
                z_ct = z_left;
                if (y_ct == 0) y_inc--;
    69dc:	024cc001 	subeq	ip, ip, #1
    69e0:	058dc028 	streq	ip, [sp, #40]	; 0x28
                y_last += y_inc;
                z_first = 0;
                z_last = -1;
                z_inc++;
                for (k=0; k<zprocs; k++) {
    69e4:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    69e8:	e35c0000 	cmp	ip, #0
            y_last = -1;
            y_inc++;
            for (j=0; j<yprocs; j++) {
                z_ct = z_left;
                if (y_ct == 0) y_inc--;
                y_last += y_inc;
    69ec:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
    69f0:	e08ee00c 	add	lr, lr, ip
    69f4:	e58de018 	str	lr, [sp, #24]
                z_first = 0;
                z_last = -1;
                z_inc++;
                for (k=0; k<zprocs; k++) {
    69f8:	da00001e 	ble	6a78 <main+0x5b4>
    69fc:	e15e0004 	cmp	lr, r4
    6a00:	e1a0800e 	mov	r8, lr
            for (j=0; j<yprocs; j++) {
                z_ct = z_left;
                if (y_ct == 0) y_inc--;
                y_last += y_inc;
                z_first = 0;
                z_last = -1;
    6a04:	e3e02000 	mvn	r2, #0
    6a08:	a1a08007 	movge	r8, r7
            y_inc++;
            for (j=0; j<yprocs; j++) {
                z_ct = z_left;
                if (y_ct == 0) y_inc--;
                y_last += y_inc;
                z_first = 0;
    6a0c:	e3a0c000 	mov	ip, #0
    6a10:	e59de020 	ldr	lr, [sp, #32]
    6a14:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
    6a18:	e24e0107 	sub	r0, lr, #-1073741823	; 0xc0000001
            x_last += x_inc;
            y_first = 0;
            y_last = -1;
            y_inc++;
            for (j=0; j<yprocs; j++) {
                z_ct = z_left;
    6a1c:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
    6a20:	e0830100 	add	r0, r3, r0, lsl #2
    6a24:	e3510000 	cmp	r1, #0
    6a28:	02455001 	subeq	r5, r5, #1
                z_first = 0;
                z_last = -1;
                z_inc++;
                for (k=0; k<zprocs; k++) {
                    if (z_ct == 0) z_inc--;
                    z_last += z_inc;
    6a2c:	e0822005 	add	r2, r2, r5
    6a30:	e1520004 	cmp	r2, r4
    6a34:	b1a0e002 	movlt	lr, r2
    6a38:	a1a0e007 	movge	lr, r7
                    start_end[procnum]->box[XDIR][FIRST] = x_first;
    6a3c:	e5b03004 	ldr	r3, [r0, #4]!
                        min(y_last, BOX_PER_SIDE - 1);
                    start_end[procnum]->box[ZDIR][FIRST] = z_first;
                    start_end[procnum]->box[ZDIR][LAST] =
                        min(z_last, BOX_PER_SIDE - 1);
                    z_first = z_last + 1;
                    z_ct--;
    6a40:	e2411001 	sub	r1, r1, #1
                if (y_ct == 0) y_inc--;
                y_last += y_inc;
                z_first = 0;
                z_last = -1;
                z_inc++;
                for (k=0; k<zprocs; k++) {
    6a44:	e151000b 	cmp	r1, fp
                    start_end[procnum]->box[XDIR][LAST] =
                        min(x_last, BOX_PER_SIDE - 1);
                    start_end[procnum]->box[YDIR][FIRST] = y_first;
                    start_end[procnum]->box[YDIR][LAST] =
                        min(y_last, BOX_PER_SIDE - 1);
                    start_end[procnum]->box[ZDIR][FIRST] = z_first;
    6a48:	e583c010 	str	ip, [r3, #16]
                    start_end[procnum]->box[ZDIR][LAST] =
    6a4c:	e583e014 	str	lr, [r3, #20]
                z_last = -1;
                z_inc++;
                for (k=0; k<zprocs; k++) {
                    if (z_ct == 0) z_inc--;
                    z_last += z_inc;
                    start_end[procnum]->box[XDIR][FIRST] = x_first;
    6a50:	e583a000 	str	sl, [r3]
                    start_end[procnum]->box[XDIR][LAST] =
    6a54:	e5839004 	str	r9, [r3, #4]
                        min(x_last, BOX_PER_SIDE - 1);
                    start_end[procnum]->box[YDIR][FIRST] = y_first;
    6a58:	e5836008 	str	r6, [r3, #8]
                    start_end[procnum]->box[YDIR][LAST] =
    6a5c:	e583800c 	str	r8, [r3, #12]
                        min(y_last, BOX_PER_SIDE - 1);
                    start_end[procnum]->box[ZDIR][FIRST] = z_first;
                    start_end[procnum]->box[ZDIR][LAST] =
                        min(z_last, BOX_PER_SIDE - 1);
                    z_first = z_last + 1;
    6a60:	e282c001 	add	ip, r2, #1
                if (y_ct == 0) y_inc--;
                y_last += y_inc;
                z_first = 0;
                z_last = -1;
                z_inc++;
                for (k=0; k<zprocs; k++) {
    6a64:	1affffee 	bne	6a24 <main+0x560>
    6a68:	e59d6020 	ldr	r6, [sp, #32]
    6a6c:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    6a70:	e086600c 	add	r6, r6, ip
    6a74:	e58d6020 	str	r6, [sp, #32]
                    z_first = z_last + 1;
                    z_ct--;
                    procnum++;
                }
                y_first = y_last + 1;
                y_ct--;
    6a78:	e59de01c 	ldr	lr, [sp, #28]
            if (x_ct == 0) x_inc--;
            x_last += x_inc;
            y_first = 0;
            y_last = -1;
            y_inc++;
            for (j=0; j<yprocs; j++) {
    6a7c:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
                    z_first = z_last + 1;
                    z_ct--;
                    procnum++;
                }
                y_first = y_last + 1;
                y_ct--;
    6a80:	e24ee001 	sub	lr, lr, #1
                        min(z_last, BOX_PER_SIDE - 1);
                    z_first = z_last + 1;
                    z_ct--;
                    procnum++;
                }
                y_first = y_last + 1;
    6a84:	e59d1018 	ldr	r1, [sp, #24]
            if (x_ct == 0) x_inc--;
            x_last += x_inc;
            y_first = 0;
            y_last = -1;
            y_inc++;
            for (j=0; j<yprocs; j++) {
    6a88:	e15e0000 	cmp	lr, r0
                    z_first = z_last + 1;
                    z_ct--;
                    procnum++;
                }
                y_first = y_last + 1;
                y_ct--;
    6a8c:	e58de01c 	str	lr, [sp, #28]
                        min(z_last, BOX_PER_SIDE - 1);
                    z_first = z_last + 1;
                    z_ct--;
                    procnum++;
                }
                y_first = y_last + 1;
    6a90:	e2816001 	add	r6, r1, #1
            if (x_ct == 0) x_inc--;
            x_last += x_inc;
            y_first = 0;
            y_last = -1;
            y_inc++;
            for (j=0; j<yprocs; j++) {
    6a94:	1affffcb 	bne	69c8 <main+0x504>
                }
                y_first = y_last + 1;
                y_ct--;
            }
            x_first = x_last + 1;
            x_ct--;
    6a98:	e59d603c 	ldr	r6, [sp, #60]	; 0x3c

        x_first = 0;
        x_ct = x_left;
        x_last = -1;
        x_inc++;
        for (i=0; i<xprocs; i++) {
    6a9c:	e59dc04c 	ldr	ip, [sp, #76]	; 0x4c
                }
                y_first = y_last + 1;
                y_ct--;
            }
            x_first = x_last + 1;
            x_ct--;
    6aa0:	e2466001 	sub	r6, r6, #1
                    procnum++;
                }
                y_first = y_last + 1;
                y_ct--;
            }
            x_first = x_last + 1;
    6aa4:	e59de038 	ldr	lr, [sp, #56]	; 0x38

        x_first = 0;
        x_ct = x_left;
        x_last = -1;
        x_inc++;
        for (i=0; i<xprocs; i++) {
    6aa8:	e156000c 	cmp	r6, ip
                }
                y_first = y_last + 1;
                y_ct--;
            }
            x_first = x_last + 1;
            x_ct--;
    6aac:	e58d603c 	str	r6, [sp, #60]	; 0x3c
                    procnum++;
                }
                y_first = y_last + 1;
                y_ct--;
            }
            x_first = x_last + 1;
    6ab0:	e28ea001 	add	sl, lr, #1

        x_first = 0;
        x_ct = x_left;
        x_last = -1;
        x_inc++;
        for (i=0; i<xprocs; i++) {
    6ab4:	1affffac 	bne	696c <main+0x4a8>
            x_ct--;
        }

        /* Allocate space for my_boxes array */

        my_boxes = (box_list **) G_MALLOC(NumProcs * sizeof(box_list *));
    6ab8:	e59f0504 	ldr	r0, [pc, #1284]	; 6fc4 <main+0xb00>
    6abc:	e5905000 	ldr	r5, [r0]
    6ac0:	e1a00105 	lsl	r0, r5, #2
    6ac4:	eb0042ee 	bl	17684 <malloc>
    6ac8:	e59f15a4 	ldr	r1, [pc, #1444]	; 7074 <main+0xbb0>

        /* Set all box ptrs to null */

        for (i=0; i<NumProcs; i++) my_boxes[i] = NULL;
    6acc:	e3550000 	cmp	r5, #0
            x_ct--;
        }

        /* Allocate space for my_boxes array */

        my_boxes = (box_list **) G_MALLOC(NumProcs * sizeof(box_list *));
    6ad0:	e5810000 	str	r0, [r1]

        /* Set all box ptrs to null */

        for (i=0; i<NumProcs; i++) my_boxes[i] = NULL;
    6ad4:	da000008 	ble	6afc <main+0x638>
    6ad8:	e3a03000 	mov	r3, #0
    6adc:	e1a02000 	mov	r2, r0
    6ae0:	e1a00003 	mov	r0, r3
    6ae4:	ea000000 	b	6aec <main+0x628>
    6ae8:	e5912000 	ldr	r2, [r1]
    6aec:	e7820103 	str	r0, [r2, r3, lsl #2]
    6af0:	e2833001 	add	r3, r3, #1
    6af4:	e1530005 	cmp	r3, r5
    6af8:	1afffffa 	bne	6ae8 <main+0x624>

        /* Set up links for all boxes for initial interf and intraf */

        temp_box = my_boxes[0];
    6afc:	e5913000 	ldr	r3, [r1]
    6b00:	e5933000 	ldr	r3, [r3]
        while (temp_box) {
    6b04:	e3530000 	cmp	r3, #0
    6b08:	0a000002 	beq	6b18 <main+0x654>
            temp_box = temp_box->next_box;
    6b0c:	e593300c 	ldr	r3, [r3, #12]
        for (i=0; i<NumProcs; i++) my_boxes[i] = NULL;

        /* Set up links for all boxes for initial interf and intraf */

        temp_box = my_boxes[0];
        while (temp_box) {
    6b10:	e3530000 	cmp	r3, #0
    6b14:	1afffffc 	bne	6b0c <main+0x648>
            temp_box = temp_box->next_box;
        }

        /* Allocate space for BOX array */

        BOX = (box_type ***) G_MALLOC(BOX_PER_SIDE * sizeof(box_type **));
    6b18:	e1a07104 	lsl	r7, r4, #2
    6b1c:	e1a00007 	mov	r0, r7
    6b20:	eb0042d7 	bl	17684 <malloc>
    6b24:	e59f554c 	ldr	r5, [pc, #1356]	; 7078 <main+0xbb4>
        for (i=0; i < BOX_PER_SIDE; i++) {
    6b28:	e3540000 	cmp	r4, #0
            temp_box = temp_box->next_box;
        }

        /* Allocate space for BOX array */

        BOX = (box_type ***) G_MALLOC(BOX_PER_SIDE * sizeof(box_type **));
    6b2c:	e5850000 	str	r0, [r5]
        for (i=0; i < BOX_PER_SIDE; i++) {
    6b30:	da000029 	ble	6bdc <main+0x718>
    6b34:	e3a08000 	mov	r8, #0
    6b38:	e1a09000 	mov	r9, r0
            BOX[i] = (box_type **) G_MALLOC( BOX_PER_SIDE * sizeof(box_type *));
            for (j=0; j < BOX_PER_SIDE; j++) {
    6b3c:	e1a06008 	mov	r6, r8
    6b40:	e1a00007 	mov	r0, r7

        /* Allocate space for BOX array */

        BOX = (box_type ***) G_MALLOC(BOX_PER_SIDE * sizeof(box_type **));
        for (i=0; i < BOX_PER_SIDE; i++) {
            BOX[i] = (box_type **) G_MALLOC( BOX_PER_SIDE * sizeof(box_type *));
    6b44:	eb0042ce 	bl	17684 <malloc>
            for (j=0; j < BOX_PER_SIDE; j++) {
    6b48:	e3540000 	cmp	r4, #0

        /* Allocate space for BOX array */

        BOX = (box_type ***) G_MALLOC(BOX_PER_SIDE * sizeof(box_type **));
        for (i=0; i < BOX_PER_SIDE; i++) {
            BOX[i] = (box_type **) G_MALLOC( BOX_PER_SIDE * sizeof(box_type *));
    6b4c:	e7890108 	str	r0, [r9, r8, lsl #2]
    6b50:	e1a09108 	lsl	r9, r8, #2
            for (j=0; j < BOX_PER_SIDE; j++) {
    6b54:	da000020 	ble	6bdc <main+0x718>
    6b58:	e3a0a000 	mov	sl, #0
                BOX[i][j] = (box_type *) G_MALLOC(BOX_PER_SIDE * sizeof(box_type));
    6b5c:	e5953000 	ldr	r3, [r5]
    6b60:	e1a00204 	lsl	r0, r4, #4
    6b64:	e7937009 	ldr	r7, [r3, r9]
    6b68:	eb0042c5 	bl	17684 <malloc>
                for (k=0; k < BOX_PER_SIDE; k++) {
    6b6c:	e3540000 	cmp	r4, #0

        BOX = (box_type ***) G_MALLOC(BOX_PER_SIDE * sizeof(box_type **));
        for (i=0; i < BOX_PER_SIDE; i++) {
            BOX[i] = (box_type **) G_MALLOC( BOX_PER_SIDE * sizeof(box_type *));
            for (j=0; j < BOX_PER_SIDE; j++) {
                BOX[i][j] = (box_type *) G_MALLOC(BOX_PER_SIDE * sizeof(box_type));
    6b70:	e787010a 	str	r0, [r7, sl, lsl #2]
    6b74:	e1a0b10a 	lsl	fp, sl, #2
                for (k=0; k < BOX_PER_SIDE; k++) {
    6b78:	da000012 	ble	6bc8 <main+0x704>
    6b7c:	e3a07000 	mov	r7, #0
                    BOX[i][j][k].list = NULL;
    6b80:	e5953000 	ldr	r3, [r5]
                    LOCKINIT(BOX[i][j][k].boxlock);
    6b84:	e3a01000 	mov	r1, #0
        for (i=0; i < BOX_PER_SIDE; i++) {
            BOX[i] = (box_type **) G_MALLOC( BOX_PER_SIDE * sizeof(box_type *));
            for (j=0; j < BOX_PER_SIDE; j++) {
                BOX[i][j] = (box_type *) G_MALLOC(BOX_PER_SIDE * sizeof(box_type));
                for (k=0; k < BOX_PER_SIDE; k++) {
                    BOX[i][j][k].list = NULL;
    6b88:	e7932009 	ldr	r2, [r3, r9]
    6b8c:	e792200b 	ldr	r2, [r2, fp]
    6b90:	e7826207 	str	r6, [r2, r7, lsl #4]
                    LOCKINIT(BOX[i][j][k].boxlock);
    6b94:	e7933009 	ldr	r3, [r3, r9]
    6b98:	e793000b 	ldr	r0, [r3, fp]
    6b9c:	e0800207 	add	r0, r0, r7, lsl #4
    6ba0:	e2800004 	add	r0, r0, #4
    6ba4:	ebffe90e 	bl	fe4 <pthread_mutex_init>
        BOX = (box_type ***) G_MALLOC(BOX_PER_SIDE * sizeof(box_type **));
        for (i=0; i < BOX_PER_SIDE; i++) {
            BOX[i] = (box_type **) G_MALLOC( BOX_PER_SIDE * sizeof(box_type *));
            for (j=0; j < BOX_PER_SIDE; j++) {
                BOX[i][j] = (box_type *) G_MALLOC(BOX_PER_SIDE * sizeof(box_type));
                for (k=0; k < BOX_PER_SIDE; k++) {
    6ba8:	e59f146c 	ldr	r1, [pc, #1132]	; 701c <main+0xb58>
    6bac:	e2877001 	add	r7, r7, #1
    6bb0:	e5914000 	ldr	r4, [r1]
    6bb4:	e1540007 	cmp	r4, r7
    6bb8:	cafffff0 	bgt	6b80 <main+0x6bc>
        /* Allocate space for BOX array */

        BOX = (box_type ***) G_MALLOC(BOX_PER_SIDE * sizeof(box_type **));
        for (i=0; i < BOX_PER_SIDE; i++) {
            BOX[i] = (box_type **) G_MALLOC( BOX_PER_SIDE * sizeof(box_type *));
            for (j=0; j < BOX_PER_SIDE; j++) {
    6bbc:	e28aa001 	add	sl, sl, #1
    6bc0:	e15a0004 	cmp	sl, r4
    6bc4:	baffffe4 	blt	6b5c <main+0x698>
        }

        /* Allocate space for BOX array */

        BOX = (box_type ***) G_MALLOC(BOX_PER_SIDE * sizeof(box_type **));
        for (i=0; i < BOX_PER_SIDE; i++) {
    6bc8:	e2888001 	add	r8, r8, #1
    6bcc:	e1540008 	cmp	r4, r8
    6bd0:	c5959000 	ldrgt	r9, [r5]
    6bd4:	c1a00104 	lslgt	r0, r4, #2
    6bd8:	caffffd9 	bgt	6b44 <main+0x680>
                    LOCKINIT(BOX[i][j][k].boxlock);
                }
            }
        } /* for i */

        gl = (struct GlobalMemory *) G_MALLOC(gmem_size);
    6bdc:	e3a00f42 	mov	r0, #264	; 0x108
    6be0:	eb0042a7 	bl	17684 <malloc>
    6be4:	e1a03000 	mov	r3, r0
    6be8:	e59f548c 	ldr	r5, [pc, #1164]	; 707c <main+0xbb8>

        /* macro calls to initialize synch variables  */

        BARINIT(gl->start, NumProcs);
    6bec:	e3a01000 	mov	r1, #0
    6bf0:	e2800048 	add	r0, r0, #72	; 0x48
                    LOCKINIT(BOX[i][j][k].boxlock);
                }
            }
        } /* for i */

        gl = (struct GlobalMemory *) G_MALLOC(gmem_size);
    6bf4:	e5853000 	str	r3, [r5]

        /* macro calls to initialize synch variables  */

        BARINIT(gl->start, NumProcs);
    6bf8:	ebffe8f9 	bl	fe4 <pthread_mutex_init>
    6bfc:	e2501000 	subs	r1, r0, #0
    6c00:	1a0000cf 	bne	6f44 <main+0xa80>
    6c04:	e5950000 	ldr	r0, [r5]
    6c08:	e2800054 	add	r0, r0, #84	; 0x54
    6c0c:	ebffe970 	bl	11d4 <pthread_cond_init>
    6c10:	e3500000 	cmp	r0, #0
    6c14:	1a0000ce 	bne	6f54 <main+0xa90>
    6c18:	e5953000 	ldr	r3, [r5]
        BARINIT(gl->InterfBar, NumProcs);
    6c1c:	e1a01000 	mov	r1, r0

        gl = (struct GlobalMemory *) G_MALLOC(gmem_size);

        /* macro calls to initialize synch variables  */

        BARINIT(gl->start, NumProcs);
    6c20:	e583005c 	str	r0, [r3, #92]	; 0x5c
    6c24:	e5830060 	str	r0, [r3, #96]	; 0x60
        BARINIT(gl->InterfBar, NumProcs);
    6c28:	e2830064 	add	r0, r3, #100	; 0x64
    6c2c:	ebffe8ec 	bl	fe4 <pthread_mutex_init>
    6c30:	e2501000 	subs	r1, r0, #0
    6c34:	1a0000c2 	bne	6f44 <main+0xa80>
    6c38:	e5950000 	ldr	r0, [r5]
    6c3c:	e2800070 	add	r0, r0, #112	; 0x70
    6c40:	ebffe963 	bl	11d4 <pthread_cond_init>
    6c44:	e3500000 	cmp	r0, #0
    6c48:	1a0000c8 	bne	6f70 <main+0xaac>
    6c4c:	e5953000 	ldr	r3, [r5]
        BARINIT(gl->PotengBar, NumProcs);
    6c50:	e1a01000 	mov	r1, r0
        gl = (struct GlobalMemory *) G_MALLOC(gmem_size);

        /* macro calls to initialize synch variables  */

        BARINIT(gl->start, NumProcs);
        BARINIT(gl->InterfBar, NumProcs);
    6c54:	e5830078 	str	r0, [r3, #120]	; 0x78
    6c58:	e583007c 	str	r0, [r3, #124]	; 0x7c
        BARINIT(gl->PotengBar, NumProcs);
    6c5c:	e2830080 	add	r0, r3, #128	; 0x80
    6c60:	ebffe8df 	bl	fe4 <pthread_mutex_init>
    6c64:	e2501000 	subs	r1, r0, #0
    6c68:	1a0000b5 	bne	6f44 <main+0xa80>
    6c6c:	e5950000 	ldr	r0, [r5]
    6c70:	e280008c 	add	r0, r0, #140	; 0x8c
    6c74:	ebffe956 	bl	11d4 <pthread_cond_init>
    6c78:	e2504000 	subs	r4, r0, #0
    6c7c:	1a0000c2 	bne	6f8c <main+0xac8>
    6c80:	e5950000 	ldr	r0, [r5]
        LOCKINIT(gl->IOLock);
    6c84:	e1a01004 	mov	r1, r4

        /* macro calls to initialize synch variables  */

        BARINIT(gl->start, NumProcs);
        BARINIT(gl->InterfBar, NumProcs);
        BARINIT(gl->PotengBar, NumProcs);
    6c88:	e5804094 	str	r4, [r0, #148]	; 0x94
    6c8c:	e5804098 	str	r4, [r0, #152]	; 0x98
        LOCKINIT(gl->IOLock);
    6c90:	ebffe8d3 	bl	fe4 <pthread_mutex_init>
        LOCKINIT(gl->IndexLock);
    6c94:	e5950000 	ldr	r0, [r5]
    6c98:	e1a01004 	mov	r1, r4
    6c9c:	e280000c 	add	r0, r0, #12
    6ca0:	ebffe8cf 	bl	fe4 <pthread_mutex_init>
        LOCKINIT(gl->IntrafVirLock);
    6ca4:	e5950000 	ldr	r0, [r5]
    6ca8:	e1a01004 	mov	r1, r4
    6cac:	e2800018 	add	r0, r0, #24
    6cb0:	ebffe8cb 	bl	fe4 <pthread_mutex_init>
        LOCKINIT(gl->InterfVirLock);
    6cb4:	e5950000 	ldr	r0, [r5]
    6cb8:	e1a01004 	mov	r1, r4
    6cbc:	e2800024 	add	r0, r0, #36	; 0x24
    6cc0:	ebffe8c7 	bl	fe4 <pthread_mutex_init>
        LOCKINIT(gl->KinetiSumLock);
    6cc4:	e5950000 	ldr	r0, [r5]
    6cc8:	e1a01004 	mov	r1, r4
    6ccc:	e2800030 	add	r0, r0, #48	; 0x30
    6cd0:	ebffe8c3 	bl	fe4 <pthread_mutex_init>
        LOCKINIT(gl->PotengSumLock);
    6cd4:	e5950000 	ldr	r0, [r5]
    }

    fprintf(six,"SPHERICAL CUTOFF RADIUS    = %8.4f ANGSTROM\n",CUTOFF);
    6cd8:	e59f72e0 	ldr	r7, [pc, #736]	; 6fc0 <main+0xafc>
    6cdc:	e59f62f4 	ldr	r6, [pc, #756]	; 6fd8 <main+0xb14>
        LOCKINIT(gl->IOLock);
        LOCKINIT(gl->IndexLock);
        LOCKINIT(gl->IntrafVirLock);
        LOCKINIT(gl->InterfVirLock);
        LOCKINIT(gl->KinetiSumLock);
        LOCKINIT(gl->PotengSumLock);
    6ce0:	e1a01004 	mov	r1, r4
    6ce4:	e280003c 	add	r0, r0, #60	; 0x3c
    6ce8:	ebffe8bd 	bl	fe4 <pthread_mutex_init>
    }

    fprintf(six,"SPHERICAL CUTOFF RADIUS    = %8.4f ANGSTROM\n",CUTOFF);
    6cec:	e1c620d0 	ldrd	r2, [r6]
    6cf0:	e59f1388 	ldr	r1, [pc, #904]	; 7080 <main+0xbbc>
    6cf4:	e5970000 	ldr	r0, [r7]
    6cf8:	eb003ece 	bl	16838 <fprintf>
    fflush(six);
    6cfc:	e5970000 	ldr	r0, [r7]
    6d00:	eb003d06 	bl	16120 <fflush>

    IRST=0;
    6d04:	e59f3378 	ldr	r3, [pc, #888]	; 7084 <main+0xbc0>
    6d08:	e5834000 	str	r4, [r3]

    /* call initialization routine */

    INITIA();
    6d0c:	eb000d67 	bl	a2b0 <INITIA>
    gl->intertime = 0;

    /* initialize Index to 1 so that the first created child gets
       id 1, not 0 */

    gl->Index = 1;
    6d10:	e3a01001 	mov	r1, #1

    if (NSAVE > 0) {  /* not true for input decks provided */
    6d14:	e59fc2b4 	ldr	ip, [pc, #692]	; 6fd0 <main+0xb0c>

    /* call initialization routine */

    INITIA();

    gl->tracktime = 0;
    6d18:	e5953000 	ldr	r3, [r5]
    /* initialize Index to 1 so that the first created child gets
       id 1, not 0 */

    gl->Index = 1;

    if (NSAVE > 0) {  /* not true for input decks provided */
    6d1c:	e59c2000 	ldr	r2, [ip]
    gl->intertime = 0;

    /* initialize Index to 1 so that the first created child gets
       id 1, not 0 */

    gl->Index = 1;
    6d20:	e583109c 	str	r1, [r3, #156]	; 0x9c

    if (NSAVE > 0) {  /* not true for input decks provided */
    6d24:	e3520000 	cmp	r2, #0

    /* call initialization routine */

    INITIA();

    gl->tracktime = 0;
    6d28:	e58340e8 	str	r4, [r3, #232]	; 0xe8
    gl->intratime = 0;
    6d2c:	e58340f4 	str	r4, [r3, #244]	; 0xf4
    gl->intertime = 0;
    6d30:	e5834100 	str	r4, [r3, #256]	; 0x100
    /* initialize Index to 1 so that the first created child gets
       id 1, not 0 */

    gl->Index = 1;

    if (NSAVE > 0) {  /* not true for input decks provided */
    6d34:	da000002 	ble	6d44 <main+0x880>
        fprintf(six,"COLLECTING X AND V DATA AT EVERY %4ld TIME STEPS \n",NSAVE);
    6d38:	e5970000 	ldr	r0, [r7]
    6d3c:	e59f1344 	ldr	r1, [pc, #836]	; 7088 <main+0xbc4>
    6d40:	eb003ebc 	bl	16838 <fprintf>
    }

    /* spawn helper processes */
    CLOCK(gl->computestart);
    6d44:	e3a01000 	mov	r1, #0
    6d48:	e28d0050 	add	r0, sp, #80	; 0x50
    6d4c:	eb00416c 	bl	17304 <gettimeofday>
    6d50:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
    6d54:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
    6d58:	e59f032c 	ldr	r0, [pc, #812]	; 708c <main+0xbc8>
    CREATE(WorkStart, NumProcs);
    6d5c:	e59fe260 	ldr	lr, [pc, #608]	; 6fc4 <main+0xb00>
    if (NSAVE > 0) {  /* not true for input decks provided */
        fprintf(six,"COLLECTING X AND V DATA AT EVERY %4ld TIME STEPS \n",NSAVE);
    }

    /* spawn helper processes */
    CLOCK(gl->computestart);
    6d60:	e0223290 	mla	r2, r0, r2, r3
    CREATE(WorkStart, NumProcs);
    6d64:	e59e1000 	ldr	r1, [lr]
    if (NSAVE > 0) {  /* not true for input decks provided */
        fprintf(six,"COLLECTING X AND V DATA AT EVERY %4ld TIME STEPS \n",NSAVE);
    }

    /* spawn helper processes */
    CLOCK(gl->computestart);
    6d68:	e5953000 	ldr	r3, [r5]
    CREATE(WorkStart, NumProcs);
    6d6c:	e3510001 	cmp	r1, #1
    if (NSAVE > 0) {  /* not true for input decks provided */
        fprintf(six,"COLLECTING X AND V DATA AT EVERY %4ld TIME STEPS \n",NSAVE);
    }

    /* spawn helper processes */
    CLOCK(gl->computestart);
    6d70:	e58320d8 	str	r2, [r3, #216]	; 0xd8
    CREATE(WorkStart, NumProcs);
    6d74:	da00000f 	ble	6db8 <main+0x8f4>
    6d78:	e3a04001 	mov	r4, #1
    6d7c:	e3a01000 	mov	r1, #0
    6d80:	e59f02c8 	ldr	r0, [pc, #712]	; 7050 <main+0xb8c>
    6d84:	e59f62c4 	ldr	r6, [pc, #708]	; 7050 <main+0xb8c>
    6d88:	e59f7234 	ldr	r7, [pc, #564]	; 6fc4 <main+0xb00>
    6d8c:	e8900009 	ldm	r0, {r0, r3}
    6d90:	e59f22f8 	ldr	r2, [pc, #760]	; 7090 <main+0xbcc>
    6d94:	e283c001 	add	ip, r3, #1
    6d98:	e0800103 	add	r0, r0, r3, lsl #2
    6d9c:	e1a03001 	mov	r3, r1
    6da0:	e586c004 	str	ip, [r6, #4]
    6da4:	ebffe785 	bl	bc0 <pthread_create>
    6da8:	e5973000 	ldr	r3, [r7]
    6dac:	e2844001 	add	r4, r4, #1
    6db0:	e1530004 	cmp	r3, r4
    6db4:	cafffff0 	bgt	6d7c <main+0x8b8>
    6db8:	ebfffd9a 	bl	6428 <WorkStart>

    /* macro to make main process wait for all others to finish */
    WAIT_FOR_END(NumProcs);
    6dbc:	e59fc28c 	ldr	ip, [pc, #652]	; 7050 <main+0xb8c>
    6dc0:	e59c3004 	ldr	r3, [ip, #4]
    6dc4:	e3530000 	cmp	r3, #0
    6dc8:	0a00000c 	beq	6e00 <main+0x93c>
    6dcc:	e3a04000 	mov	r4, #0
    6dd0:	e1a0600c 	mov	r6, ip
    6dd4:	e59fe274 	ldr	lr, [pc, #628]	; 7050 <main+0xb8c>
    6dd8:	e3a01000 	mov	r1, #0
    6ddc:	e59e3000 	ldr	r3, [lr]
    6de0:	e7930104 	ldr	r0, [r3, r4, lsl #2]
    6de4:	ebffe849 	bl	f10 <pthread_join>
    6de8:	e3500000 	cmp	r0, #0
    6dec:	1a00006d 	bne	6fa8 <main+0xae4>
    6df0:	e5963004 	ldr	r3, [r6, #4]
    6df4:	e2844001 	add	r4, r4, #1
    6df8:	e1530004 	cmp	r3, r4
    6dfc:	8afffff4 	bhi	6dd4 <main+0x910>
    CLOCK(gl->computeend);
    6e00:	e3a01000 	mov	r1, #0
    6e04:	e28d0050 	add	r0, sp, #80	; 0x50
    6e08:	eb00413d 	bl	17304 <gettimeofday>
    6e0c:	e59d1054 	ldr	r1, [sp, #84]	; 0x54
    6e10:	e59d2050 	ldr	r2, [sp, #80]	; 0x50
    6e14:	e59f0270 	ldr	r0, [pc, #624]	; 708c <main+0xbc8>
    6e18:	e5953000 	ldr	r3, [r5]
    6e1c:	e0221290 	mla	r2, r0, r2, r1

    printf("COMPUTESTART (after initialization) = %lu\n",gl->computestart);
    6e20:	e59310d8 	ldr	r1, [r3, #216]	; 0xd8
    CLOCK(gl->computestart);
    CREATE(WorkStart, NumProcs);

    /* macro to make main process wait for all others to finish */
    WAIT_FOR_END(NumProcs);
    CLOCK(gl->computeend);
    6e24:	e58320dc 	str	r2, [r3, #220]	; 0xdc

    printf("COMPUTESTART (after initialization) = %lu\n",gl->computestart);
    6e28:	e59f0264 	ldr	r0, [pc, #612]	; 7094 <main+0xbd0>
    6e2c:	eb004708 	bl	18a54 <printf>
    printf("COMPUTEEND = %lu\n",gl->computeend);
    6e30:	e5953000 	ldr	r3, [r5]
    6e34:	e59f025c 	ldr	r0, [pc, #604]	; 7098 <main+0xbd4>
    6e38:	e59310dc 	ldr	r1, [r3, #220]	; 0xdc
    6e3c:	eb004704 	bl	18a54 <printf>
    printf("COMPUTETIME (after initialization) = %lu\n",gl->computeend-gl->computestart);
    6e40:	e5953000 	ldr	r3, [r5]
    6e44:	e59f0250 	ldr	r0, [pc, #592]	; 709c <main+0xbd8>
    6e48:	e59310dc 	ldr	r1, [r3, #220]	; 0xdc
    6e4c:	e59330d8 	ldr	r3, [r3, #216]	; 0xd8
    6e50:	e0631001 	rsb	r1, r3, r1
    6e54:	eb0046fe 	bl	18a54 <printf>
    printf("Measured Time (2nd timestep onward) = %lu\n",gl->tracktime);
    6e58:	e5953000 	ldr	r3, [r5]
    6e5c:	e59f023c 	ldr	r0, [pc, #572]	; 70a0 <main+0xbdc>
    6e60:	e59310e8 	ldr	r1, [r3, #232]	; 0xe8
    6e64:	eb0046fa 	bl	18a54 <printf>
    printf("Intramolecular time only (2nd timestep onward) = %lu\n",gl->intratime);
    6e68:	e5953000 	ldr	r3, [r5]
    6e6c:	e59f0230 	ldr	r0, [pc, #560]	; 70a4 <main+0xbe0>
    6e70:	e59310f4 	ldr	r1, [r3, #244]	; 0xf4
    6e74:	eb0046f6 	bl	18a54 <printf>
    printf("Intermolecular time only (2nd timestep onward) = %lu\n",gl->intertime);
    6e78:	e5953000 	ldr	r3, [r5]
    6e7c:	e59f0224 	ldr	r0, [pc, #548]	; 70a8 <main+0xbe4>
    6e80:	e5931100 	ldr	r1, [r3, #256]	; 0x100
    6e84:	eb0046f2 	bl	18a54 <printf>
    printf("Other time (2nd timestep onward) = %lu\n",gl->tracktime - gl->intratime - gl->intertime);
    6e88:	e5953000 	ldr	r3, [r5]
    6e8c:	e59f0218 	ldr	r0, [pc, #536]	; 70ac <main+0xbe8>
    6e90:	e59320f4 	ldr	r2, [r3, #244]	; 0xf4
    6e94:	e59310e8 	ldr	r1, [r3, #232]	; 0xe8
    6e98:	e5933100 	ldr	r3, [r3, #256]	; 0x100
    6e9c:	e0621001 	rsb	r1, r2, r1
    6ea0:	e0631001 	rsb	r1, r3, r1
    6ea4:	eb0046ea 	bl	18a54 <printf>

    printf("\nExited Happily with XTT = %g (note: XTT value is garbage if NPRINT > NSTEP)\n", XTT);
    6ea8:	e59f3200 	ldr	r3, [pc, #512]	; 70b0 <main+0xbec>
    6eac:	e59f0200 	ldr	r0, [pc, #512]	; 70b4 <main+0xbf0>
    6eb0:	e1c320d0 	ldrd	r2, [r3]
    6eb4:	eb0046e6 	bl	18a54 <printf>

    MAIN_END;
    6eb8:	e59f01f8 	ldr	r0, [pc, #504]	; 70b8 <main+0xbf4>
    6ebc:	eb00475c 	bl	18c34 <puts>
    6ec0:	e3a03000 	mov	r3, #0
    6ec4:	e58d3050 	str	r3, [sp, #80]	; 0x50
    6ec8:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
    6ecc:	e3530ffa 	cmp	r3, #1000	; 0x3e8
    6ed0:	0a000005 	beq	6eec <main+0xa28>
    6ed4:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
    6ed8:	e2833001 	add	r3, r3, #1
    6edc:	e58d3050 	str	r3, [sp, #80]	; 0x50
    6ee0:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
    6ee4:	e3530ffa 	cmp	r3, #1000	; 0x3e8
    6ee8:	1afffff9 	bne	6ed4 <main+0xa10>
    6eec:	e3a03000 	mov	r3, #0
    6ef0:	e3a02482 	mov	r2, #-2113929216	; 0x82000000
    6ef4:	e3a01001 	mov	r1, #1
} /* main.c */
    6ef8:	e1a00003 	mov	r0, r3
    printf("Intermolecular time only (2nd timestep onward) = %lu\n",gl->intertime);
    printf("Other time (2nd timestep onward) = %lu\n",gl->tracktime - gl->intratime - gl->intertime);

    printf("\nExited Happily with XTT = %g (note: XTT value is garbage if NPRINT > NSTEP)\n", XTT);

    MAIN_END;
    6efc:	e5821004 	str	r1, [r2, #4]
    6f00:	e5833000 	str	r3, [r3]
} /* main.c */
    6f04:	e28dd05c 	add	sp, sp, #92	; 0x5c
    6f08:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        j = (long) proccbrt;
        if (j<1) j = 1;
        while ((xprocs == 0) && (j>0)) {
            k = (long) sqrt((double) (NumProcs / j));
            if (k<1) k=1;
            while ((yprocs == 0) && (k>0)) {
    6f0c:	e3a03001 	mov	r3, #1
    6f10:	e3a06000 	mov	r6, #0
    6f14:	eafffe45 	b	6830 <main+0x36c>
    6f18:	e5984000 	ldr	r4, [r8]
    6f1c:	eafffee5 	b	6ab8 <main+0x5f4>

    printf("%ld boxes with %ld processors\n\n",
           BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE, NumProcs);

    if (NumProcs > (BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE)) {
        fprintf(stderr,"ERROR: less boxes (%ld) than processors (%ld)\n",
    6f20:	e59b1000 	ldr	r1, [fp]
    6f24:	e591000c 	ldr	r0, [r1, #12]
    6f28:	e59f118c 	ldr	r1, [pc, #396]	; 70bc <main+0xbf8>
    6f2c:	eb003e41 	bl	16838 <fprintf>
                BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE, NumProcs);
        fflush(stderr);
    6f30:	e59b3000 	ldr	r3, [fp]
    6f34:	e593000c 	ldr	r0, [r3, #12]
    6f38:	eb003c78 	bl	16120 <fflush>
        exit(-1);
    6f3c:	e3e00000 	mvn	r0, #0
    6f40:	eb003b36 	bl	15c20 <exit>

        gl = (struct GlobalMemory *) G_MALLOC(gmem_size);

        /* macro calls to initialize synch variables  */

        BARINIT(gl->start, NumProcs);
    6f44:	e59f0174 	ldr	r0, [pc, #372]	; 70c0 <main+0xbfc>
    6f48:	eb004739 	bl	18c34 <puts>
    6f4c:	e3e00000 	mvn	r0, #0
    6f50:	eb003b32 	bl	15c20 <exit>
    6f54:	e59f0164 	ldr	r0, [pc, #356]	; 70c0 <main+0xbfc>
    6f58:	eb004735 	bl	18c34 <puts>
    6f5c:	e5950000 	ldr	r0, [r5]
    6f60:	e2800048 	add	r0, r0, #72	; 0x48
    6f64:	ebffe6fa 	bl	b54 <pthread_mutex_destroy>
    6f68:	e3e00000 	mvn	r0, #0
    6f6c:	eb003b2b 	bl	15c20 <exit>
        BARINIT(gl->InterfBar, NumProcs);
    6f70:	e59f0148 	ldr	r0, [pc, #328]	; 70c0 <main+0xbfc>
    6f74:	eb00472e 	bl	18c34 <puts>
    6f78:	e5950000 	ldr	r0, [r5]
    6f7c:	e2800064 	add	r0, r0, #100	; 0x64
    6f80:	ebffe6f3 	bl	b54 <pthread_mutex_destroy>
    6f84:	e3e00000 	mvn	r0, #0
    6f88:	eb003b24 	bl	15c20 <exit>
        BARINIT(gl->PotengBar, NumProcs);
    6f8c:	e59f012c 	ldr	r0, [pc, #300]	; 70c0 <main+0xbfc>
    6f90:	eb004727 	bl	18c34 <puts>
    6f94:	e5950000 	ldr	r0, [r5]
    6f98:	e2800080 	add	r0, r0, #128	; 0x80
    6f9c:	ebffe6ec 	bl	b54 <pthread_mutex_destroy>
    6fa0:	e3e00000 	mvn	r0, #0
    6fa4:	eb003b1d 	bl	15c20 <exit>
    /* spawn helper processes */
    CLOCK(gl->computestart);
    CREATE(WorkStart, NumProcs);

    /* macro to make main process wait for all others to finish */
    WAIT_FOR_END(NumProcs);
    6fa8:	e59f0114 	ldr	r0, [pc, #276]	; 70c4 <main+0xc00>
    6fac:	eb004720 	bl	18c34 <puts>
    6fb0:	e3e00000 	mvn	r0, #0
    6fb4:	eb003b19 	bl	15c20 <exit>
    6fb8:	0003e460 	.word	0x0003e460
    6fbc:	0013f528 	.word	0x0013f528
    6fc0:	0013f3f4 	.word	0x0013f3f4
    6fc4:	0013eec0 	.word	0x0013eec0
    6fc8:	0013f004 	.word	0x0013f004
    6fcc:	0013f000 	.word	0x0013f000
    6fd0:	0013ea94 	.word	0x0013ea94
    6fd4:	40100000 	.word	0x40100000
    6fd8:	0013f530 	.word	0x0013f530
    6fdc:	4072a000 	.word	0x4072a000
    6fe0:	0013ef90 	.word	0x0013ef90
    6fe4:	0013ef68 	.word	0x0013ef68
    6fe8:	b22d0e56 	.word	0xb22d0e56
    6fec:	3fefef9d 	.word	0x3fefef9d
    6ff0:	0013f0a8 	.word	0x0013f0a8
    6ff4:	f1e2674d 	.word	0xf1e2674d
    6ff8:	3ca59e05 	.word	0x3ca59e05
    6ffc:	0013eed8 	.word	0x0013eed8
    7000:	0013ea70 	.word	0x0013ea70
    7004:	0013ea60 	.word	0x0013ea60
    7008:	00000bb8 	.word	0x00000bb8
    700c:	0003298c 	.word	0x0003298c
    7010:	000329b8 	.word	0x000329b8
    7014:	000329f8 	.word	0x000329f8
    7018:	0013f428 	.word	0x0013f428
    701c:	0013ea50 	.word	0x0013ea50
    7020:	0013f0b0 	.word	0x0013f0b0
    7024:	00032a30 	.word	0x00032a30
    7028:	00032a80 	.word	0x00032a80
    702c:	00032aa8 	.word	0x00032aa8
    7030:	00032ad4 	.word	0x00032ad4
    7034:	00032af8 	.word	0x00032af8
    7038:	00032b1c 	.word	0x00032b1c
    703c:	00032b44 	.word	0x00032b44
    7040:	00032b68 	.word	0x00032b68
    7044:	00032b8c 	.word	0x00032b8c
    7048:	00032bb0 	.word	0x00032bb0
    704c:	09896800 	.word	0x09896800
    7050:	0013e9d4 	.word	0x0013e9d4
    7054:	0013ef50 	.word	0x0013ef50
    7058:	55555555 	.word	0x55555555
    705c:	3fd55555 	.word	0x3fd55555
    7060:	86a12b9b 	.word	0x86a12b9b
    7064:	3d06849b 	.word	0x3d06849b
    7068:	00032bd4 	.word	0x00032bd4
    706c:	00032bfc 	.word	0x00032bfc
    7070:	00032c24 	.word	0x00032c24
    7074:	0013efcc 	.word	0x0013efcc
    7078:	0013f098 	.word	0x0013f098
    707c:	0013f3f0 	.word	0x0013f3f0
    7080:	00032c74 	.word	0x00032c74
    7084:	0013efec 	.word	0x0013efec
    7088:	00032ca4 	.word	0x00032ca4
    708c:	000f4240 	.word	0x000f4240
    7090:	00006428 	.word	0x00006428
    7094:	00032cf4 	.word	0x00032cf4
    7098:	00032d20 	.word	0x00032d20
    709c:	00032d34 	.word	0x00032d34
    70a0:	00032d60 	.word	0x00032d60
    70a4:	00032d8c 	.word	0x00032d8c
    70a8:	00032dc4 	.word	0x00032dc4
    70ac:	00032dfc 	.word	0x00032dfc
    70b0:	0013eff0 	.word	0x0013eff0
    70b4:	00032e24 	.word	0x00032e24
    70b8:	00032e74 	.word	0x00032e74
    70bc:	00032a50 	.word	0x00032a50
    70c0:	00032c50 	.word	0x00032c50
    70c4:	00032cd8 	.word	0x00032cd8

000070c8 <UPDATE_FORCES>:


/*************    UPDATE FORCES SUBROUTINE     *************/

void UPDATE_FORCES(struct link *link_ptr, long DEST, double *XL, double *YL, double *ZL, double *FF)
{
    70c8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    70cc:	e1a0b002 	mov	fp, r2
    70d0:	e1a0a003 	mov	sl, r3
    70d4:	e3a08000 	mov	r8, #0
    70d8:	e24ddf77 	sub	sp, sp, #476	; 0x1dc
    70dc:	e59d9200 	ldr	r9, [sp, #512]	; 0x200
    70e0:	e59d7204 	ldr	r7, [sp, #516]	; 0x204
    70e4:	e58d0008 	str	r0, [sp, #8]
    70e8:	e58d100c 	str	r1, [sp, #12]
    70ec:	e28d6070 	add	r6, sp, #112	; 0x70


    /*   CALCULATE X-COMPONENT FORCES */

    for (K = 0; K < 14; K++)  {
        GG[K+1][XDIR] = FF[K]*XL[K];
    70f0:	e18740d8 	ldrd	r4, [r7, r8]
    70f4:	e18b20d8 	ldrd	r2, [fp, r8]
    70f8:	e1a00004 	mov	r0, r4
    70fc:	e1a01005 	mov	r1, r5
    7100:	eb00367e 	bl	14b00 <__aeabi_dmul>
        GG[K+1][YDIR] = FF[K]*YL[K];
    7104:	e18a20d8 	ldrd	r2, [sl, r8]


    /*   CALCULATE X-COMPONENT FORCES */

    for (K = 0; K < 14; K++)  {
        GG[K+1][XDIR] = FF[K]*XL[K];
    7108:	e1c601f8 	strd	r0, [r6, #24]
        GG[K+1][YDIR] = FF[K]*YL[K];
    710c:	e1a00004 	mov	r0, r4
    7110:	e1a01005 	mov	r1, r5
    7114:	eb003679 	bl	14b00 <__aeabi_dmul>
        GG[K+1][ZDIR] = FF[K]*ZL[K];
    7118:	e18920d8 	ldrd	r2, [r9, r8]

    /*   CALCULATE X-COMPONENT FORCES */

    for (K = 0; K < 14; K++)  {
        GG[K+1][XDIR] = FF[K]*XL[K];
        GG[K+1][YDIR] = FF[K]*YL[K];
    711c:	e1c602f0 	strd	r0, [r6, #32]
        GG[K+1][ZDIR] = FF[K]*ZL[K];
    7120:	e1a00004 	mov	r0, r4
    7124:	e1a01005 	mov	r1, r5
    7128:	eb003674 	bl	14b00 <__aeabi_dmul>
    712c:	e2888008 	add	r8, r8, #8
    double *tx_p, *ty_p, *tz_p;


    /*   CALCULATE X-COMPONENT FORCES */

    for (K = 0; K < 14; K++)  {
    7130:	e3580070 	cmp	r8, #112	; 0x70
        GG[K+1][XDIR] = FF[K]*XL[K];
        GG[K+1][YDIR] = FF[K]*YL[K];
        GG[K+1][ZDIR] = FF[K]*ZL[K];
    7134:	e1c602f8 	strd	r0, [r6, #40]	; 0x28
    7138:	e2866018 	add	r6, r6, #24
    double *tx_p, *ty_p, *tz_p;


    /*   CALCULATE X-COMPONENT FORCES */

    for (K = 0; K < 14; K++)  {
    713c:	1affffeb 	bne	70f0 <UPDATE_FORCES+0x28>
        GG[K+1][XDIR] = FF[K]*XL[K];
        GG[K+1][YDIR] = FF[K]*YL[K];
        GG[K+1][ZDIR] = FF[K]*ZL[K];
    }

    G110[XDIR] = GG[10][XDIR]+GG[1][XDIR]*C1;
    7140:	e59f952c 	ldr	r9, [pc, #1324]	; 7674 <UPDATE_FORCES+0x5ac>
    7144:	e59f352c 	ldr	r3, [pc, #1324]	; 7678 <UPDATE_FORCES+0x5b0>
    7148:	e28d1f76 	add	r1, sp, #472	; 0x1d8
    714c:	e1c940d0 	ldrd	r4, [r9]
    7150:	e18160d3 	ldrd	r6, [r1, r3]
    7154:	e1a02004 	mov	r2, r4
    7158:	e1a03005 	mov	r3, r5
    715c:	e1a00006 	mov	r0, r6
    7160:	e1a01007 	mov	r1, r7
    7164:	eb003665 	bl	14b00 <__aeabi_dmul>
    7168:	e28dcc02 	add	ip, sp, #512	; 0x200
    716c:	e14c2ad0 	ldrd	r2, [ip, #-160]	; 0xffffff60
    7170:	eb00355e 	bl	146f0 <__adddf3>
    G110[YDIR] = GG[10][YDIR]+GG[1][YDIR]*C1;
    7174:	e59f3500 	ldr	r3, [pc, #1280]	; 767c <UPDATE_FORCES+0x5b4>
    7178:	e28def76 	add	lr, sp, #472	; 0x1d8
    717c:	e18ea0d3 	ldrd	sl, [lr, r3]
        GG[K+1][XDIR] = FF[K]*XL[K];
        GG[K+1][YDIR] = FF[K]*YL[K];
        GG[K+1][ZDIR] = FF[K]*ZL[K];
    }

    G110[XDIR] = GG[10][XDIR]+GG[1][XDIR]*C1;
    7180:	e1cd05f8 	strd	r0, [sp, #88]	; 0x58
    G110[YDIR] = GG[10][YDIR]+GG[1][YDIR]*C1;
    7184:	e1a0200a 	mov	r2, sl
    7188:	e1a0300b 	mov	r3, fp
    718c:	e1a00004 	mov	r0, r4
    7190:	e1a01005 	mov	r1, r5
    7194:	eb003659 	bl	14b00 <__aeabi_dmul>
    7198:	e28dcc02 	add	ip, sp, #512	; 0x200
    719c:	e14c29d8 	ldrd	r2, [ip, #-152]	; 0xffffff68
    71a0:	eb003552 	bl	146f0 <__adddf3>
    G110[ZDIR] = GG[10][ZDIR]+GG[1][ZDIR]*C1;
    71a4:	e59f34d4 	ldr	r3, [pc, #1236]	; 7680 <UPDATE_FORCES+0x5b8>
        GG[K+1][YDIR] = FF[K]*YL[K];
        GG[K+1][ZDIR] = FF[K]*ZL[K];
    }

    G110[XDIR] = GG[10][XDIR]+GG[1][XDIR]*C1;
    G110[YDIR] = GG[10][YDIR]+GG[1][YDIR]*C1;
    71a8:	e1cd06f0 	strd	r0, [sp, #96]	; 0x60
    G110[ZDIR] = GG[10][ZDIR]+GG[1][ZDIR]*C1;
    71ac:	e1a01005 	mov	r1, r5
    71b0:	e28d5f76 	add	r5, sp, #472	; 0x1d8
    71b4:	e1a00004 	mov	r0, r4
    71b8:	e18540d3 	ldrd	r4, [r5, r3]
    71bc:	e1a02004 	mov	r2, r4
    71c0:	e1a03005 	mov	r3, r5
    71c4:	e1cd40f0 	strd	r4, [sp]
    71c8:	eb00364c 	bl	14b00 <__aeabi_dmul>
    71cc:	e28dcc02 	add	ip, sp, #512	; 0x200
    71d0:	e14c29d0 	ldrd	r2, [ip, #-144]	; 0xffffff70
    71d4:	eb003545 	bl	146f0 <__adddf3>
    G23[XDIR] = GG[2][XDIR]+GG[3][XDIR];
    71d8:	e59f24a4 	ldr	r2, [pc, #1188]	; 7684 <UPDATE_FORCES+0x5bc>
    71dc:	e59f34a4 	ldr	r3, [pc, #1188]	; 7688 <UPDATE_FORCES+0x5c0>
    71e0:	e28def76 	add	lr, sp, #472	; 0x1d8
        GG[K+1][ZDIR] = FF[K]*ZL[K];
    }

    G110[XDIR] = GG[10][XDIR]+GG[1][XDIR]*C1;
    G110[YDIR] = GG[10][YDIR]+GG[1][YDIR]*C1;
    G110[ZDIR] = GG[10][ZDIR]+GG[1][ZDIR]*C1;
    71e4:	e1cd06f8 	strd	r0, [sp, #104]	; 0x68
    G23[XDIR] = GG[2][XDIR]+GG[3][XDIR];
    71e8:	e18e00d2 	ldrd	r0, [lr, r2]
    71ec:	e18320de 	ldrd	r2, [r3, lr]
    71f0:	eb00353e 	bl	146f0 <__adddf3>
    G23[YDIR] = GG[2][YDIR]+GG[3][YDIR];
    71f4:	e59f2490 	ldr	r2, [pc, #1168]	; 768c <UPDATE_FORCES+0x5c4>
    71f8:	e59f3490 	ldr	r3, [pc, #1168]	; 7690 <UPDATE_FORCES+0x5c8>
    71fc:	e28d4f76 	add	r4, sp, #472	; 0x1d8
    }

    G110[XDIR] = GG[10][XDIR]+GG[1][XDIR]*C1;
    G110[YDIR] = GG[10][YDIR]+GG[1][YDIR]*C1;
    G110[ZDIR] = GG[10][ZDIR]+GG[1][ZDIR]*C1;
    G23[XDIR] = GG[2][XDIR]+GG[3][XDIR];
    7200:	e1cd01f0 	strd	r0, [sp, #16]
    G23[YDIR] = GG[2][YDIR]+GG[3][YDIR];
    7204:	e18400d2 	ldrd	r0, [r4, r2]
    7208:	e18320d4 	ldrd	r2, [r3, r4]
    720c:	eb003537 	bl	146f0 <__adddf3>
    G23[ZDIR] = GG[2][ZDIR]+GG[3][ZDIR];
    7210:	e59f247c 	ldr	r2, [pc, #1148]	; 7694 <UPDATE_FORCES+0x5cc>
    7214:	e59f347c 	ldr	r3, [pc, #1148]	; 7698 <UPDATE_FORCES+0x5d0>
    7218:	e28d5f76 	add	r5, sp, #472	; 0x1d8

    G110[XDIR] = GG[10][XDIR]+GG[1][XDIR]*C1;
    G110[YDIR] = GG[10][YDIR]+GG[1][YDIR]*C1;
    G110[ZDIR] = GG[10][ZDIR]+GG[1][ZDIR]*C1;
    G23[XDIR] = GG[2][XDIR]+GG[3][XDIR];
    G23[YDIR] = GG[2][YDIR]+GG[3][YDIR];
    721c:	e1cd01f8 	strd	r0, [sp, #24]
    G23[ZDIR] = GG[2][ZDIR]+GG[3][ZDIR];
    7220:	e18500d2 	ldrd	r0, [r5, r2]
    7224:	e18320d5 	ldrd	r2, [r3, r5]
    7228:	eb003530 	bl	146f0 <__adddf3>
    G45[XDIR]=GG[4][XDIR]+GG[5][XDIR];
    722c:	e1cd4ed8 	ldrd	r4, [sp, #232]	; 0xe8
    G45[YDIR]=GG[4][YDIR]+GG[5][YDIR];
    7230:	e3e030ff 	mvn	r3, #255	; 0xff
    G45[ZDIR]=GG[4][ZDIR]+GG[5][ZDIR];
    TT1[XDIR] =GG[1][XDIR]*C2;
    7234:	e59f2460 	ldr	r2, [pc, #1120]	; 769c <UPDATE_FORCES+0x5d4>
    G110[XDIR] = GG[10][XDIR]+GG[1][XDIR]*C1;
    G110[YDIR] = GG[10][YDIR]+GG[1][YDIR]*C1;
    G110[ZDIR] = GG[10][ZDIR]+GG[1][ZDIR]*C1;
    G23[XDIR] = GG[2][XDIR]+GG[3][XDIR];
    G23[YDIR] = GG[2][YDIR]+GG[3][YDIR];
    G23[ZDIR] = GG[2][ZDIR]+GG[3][ZDIR];
    7238:	e1cd02f0 	strd	r0, [sp, #32]
    G45[XDIR]=GG[4][XDIR]+GG[5][XDIR];
    G45[YDIR]=GG[4][YDIR]+GG[5][YDIR];
    G45[ZDIR]=GG[4][ZDIR]+GG[5][ZDIR];
    TT1[XDIR] =GG[1][XDIR]*C2;
    723c:	e1a01007 	mov	r1, r7
    G110[ZDIR] = GG[10][ZDIR]+GG[1][ZDIR]*C1;
    G23[XDIR] = GG[2][XDIR]+GG[3][XDIR];
    G23[YDIR] = GG[2][YDIR]+GG[3][YDIR];
    G23[ZDIR] = GG[2][ZDIR]+GG[3][ZDIR];
    G45[XDIR]=GG[4][XDIR]+GG[5][XDIR];
    G45[YDIR]=GG[4][YDIR]+GG[5][YDIR];
    7240:	e28d7f76 	add	r7, sp, #472	; 0x1d8
    G110[YDIR] = GG[10][YDIR]+GG[1][YDIR]*C1;
    G110[ZDIR] = GG[10][ZDIR]+GG[1][ZDIR]*C1;
    G23[XDIR] = GG[2][XDIR]+GG[3][XDIR];
    G23[YDIR] = GG[2][YDIR]+GG[3][YDIR];
    G23[ZDIR] = GG[2][ZDIR]+GG[3][ZDIR];
    G45[XDIR]=GG[4][XDIR]+GG[5][XDIR];
    7244:	e1cd43f0 	strd	r4, [sp, #48]	; 0x30
    G45[YDIR]=GG[4][YDIR]+GG[5][YDIR];
    7248:	e1cd4fd0 	ldrd	r4, [sp, #240]	; 0xf0
    G45[ZDIR]=GG[4][ZDIR]+GG[5][ZDIR];
    TT1[XDIR] =GG[1][XDIR]*C2;
    724c:	e1a00006 	mov	r0, r6
    G110[ZDIR] = GG[10][ZDIR]+GG[1][ZDIR]*C1;
    G23[XDIR] = GG[2][XDIR]+GG[3][XDIR];
    G23[YDIR] = GG[2][YDIR]+GG[3][YDIR];
    G23[ZDIR] = GG[2][ZDIR]+GG[3][ZDIR];
    G45[XDIR]=GG[4][XDIR]+GG[5][XDIR];
    G45[YDIR]=GG[4][YDIR]+GG[5][YDIR];
    7250:	e18760d3 	ldrd	r6, [r7, r3]
    7254:	e1cd44f0 	strd	r4, [sp, #64]	; 0x40
    G45[ZDIR]=GG[4][ZDIR]+GG[5][ZDIR];
    7258:	e1cd4ed0 	ldrd	r4, [sp, #224]	; 0xe0
    725c:	e1cd44f8 	strd	r4, [sp, #72]	; 0x48
    7260:	e1cd4fd8 	ldrd	r4, [sp, #248]	; 0xf8
    7264:	e1cd45f0 	strd	r4, [sp, #80]	; 0x50
    TT1[XDIR] =GG[1][XDIR]*C2;
    7268:	e1c240d0 	ldrd	r4, [r2]
    726c:	e1a02004 	mov	r2, r4
    7270:	e1a03005 	mov	r3, r5
    G110[ZDIR] = GG[10][ZDIR]+GG[1][ZDIR]*C1;
    G23[XDIR] = GG[2][XDIR]+GG[3][XDIR];
    G23[YDIR] = GG[2][YDIR]+GG[3][YDIR];
    G23[ZDIR] = GG[2][ZDIR]+GG[3][ZDIR];
    G45[XDIR]=GG[4][XDIR]+GG[5][XDIR];
    G45[YDIR]=GG[4][YDIR]+GG[5][YDIR];
    7274:	e1cd63f8 	strd	r6, [sp, #56]	; 0x38
    G45[ZDIR]=GG[4][ZDIR]+GG[5][ZDIR];
    TT1[XDIR] =GG[1][XDIR]*C2;
    7278:	eb003620 	bl	14b00 <__aeabi_dmul>
    TT1[YDIR] =GG[1][YDIR]*C2;
    TT1[ZDIR] =GG[1][ZDIR]*C2;
    TT[XDIR] =G23[XDIR]*C2+TT1[XDIR];
    727c:	e1a02004 	mov	r2, r4
    G23[YDIR] = GG[2][YDIR]+GG[3][YDIR];
    G23[ZDIR] = GG[2][ZDIR]+GG[3][ZDIR];
    G45[XDIR]=GG[4][XDIR]+GG[5][XDIR];
    G45[YDIR]=GG[4][YDIR]+GG[5][YDIR];
    G45[ZDIR]=GG[4][ZDIR]+GG[5][ZDIR];
    TT1[XDIR] =GG[1][XDIR]*C2;
    7280:	e1a06000 	mov	r6, r0
    7284:	e1a07001 	mov	r7, r1
    TT1[YDIR] =GG[1][YDIR]*C2;
    TT1[ZDIR] =GG[1][ZDIR]*C2;
    TT[XDIR] =G23[XDIR]*C2+TT1[XDIR];
    7288:	e1cd01d0 	ldrd	r0, [sp, #16]
    728c:	e1a03005 	mov	r3, r5
    7290:	eb00361a 	bl	14b00 <__aeabi_dmul>
    7294:	e1a02000 	mov	r2, r0
    7298:	e1a03001 	mov	r3, r1
    729c:	e1a00006 	mov	r0, r6
    72a0:	e1a01007 	mov	r1, r7
    72a4:	eb003511 	bl	146f0 <__adddf3>
    G23[ZDIR] = GG[2][ZDIR]+GG[3][ZDIR];
    G45[XDIR]=GG[4][XDIR]+GG[5][XDIR];
    G45[YDIR]=GG[4][YDIR]+GG[5][YDIR];
    G45[ZDIR]=GG[4][ZDIR]+GG[5][ZDIR];
    TT1[XDIR] =GG[1][XDIR]*C2;
    TT1[YDIR] =GG[1][YDIR]*C2;
    72a8:	e1a02004 	mov	r2, r4
    TT1[ZDIR] =GG[1][ZDIR]*C2;
    TT[XDIR] =G23[XDIR]*C2+TT1[XDIR];
    72ac:	e1cd02f8 	strd	r0, [sp, #40]	; 0x28
    G23[ZDIR] = GG[2][ZDIR]+GG[3][ZDIR];
    G45[XDIR]=GG[4][XDIR]+GG[5][XDIR];
    G45[YDIR]=GG[4][YDIR]+GG[5][YDIR];
    G45[ZDIR]=GG[4][ZDIR]+GG[5][ZDIR];
    TT1[XDIR] =GG[1][XDIR]*C2;
    TT1[YDIR] =GG[1][YDIR]*C2;
    72b0:	e1a03005 	mov	r3, r5
    72b4:	e1a0000a 	mov	r0, sl
    72b8:	e1a0100b 	mov	r1, fp
    72bc:	eb00360f 	bl	14b00 <__aeabi_dmul>
    TT1[ZDIR] =GG[1][ZDIR]*C2;
    TT[XDIR] =G23[XDIR]*C2+TT1[XDIR];
    TT[YDIR] =G23[YDIR]*C2+TT1[YDIR];
    72c0:	e1a02004 	mov	r2, r4
    G23[ZDIR] = GG[2][ZDIR]+GG[3][ZDIR];
    G45[XDIR]=GG[4][XDIR]+GG[5][XDIR];
    G45[YDIR]=GG[4][YDIR]+GG[5][YDIR];
    G45[ZDIR]=GG[4][ZDIR]+GG[5][ZDIR];
    TT1[XDIR] =GG[1][XDIR]*C2;
    TT1[YDIR] =GG[1][YDIR]*C2;
    72c4:	e1a06000 	mov	r6, r0
    72c8:	e1a07001 	mov	r7, r1
    TT1[ZDIR] =GG[1][ZDIR]*C2;
    TT[XDIR] =G23[XDIR]*C2+TT1[XDIR];
    TT[YDIR] =G23[YDIR]*C2+TT1[YDIR];
    72cc:	e1cd01d8 	ldrd	r0, [sp, #24]
    72d0:	e1a03005 	mov	r3, r5
    72d4:	eb003609 	bl	14b00 <__aeabi_dmul>
    72d8:	e1a02000 	mov	r2, r0
    72dc:	e1a03001 	mov	r3, r1
    72e0:	e1a00006 	mov	r0, r6
    72e4:	e1a01007 	mov	r1, r7
    72e8:	eb003500 	bl	146f0 <__adddf3>
    G45[XDIR]=GG[4][XDIR]+GG[5][XDIR];
    G45[YDIR]=GG[4][YDIR]+GG[5][YDIR];
    G45[ZDIR]=GG[4][ZDIR]+GG[5][ZDIR];
    TT1[XDIR] =GG[1][XDIR]*C2;
    TT1[YDIR] =GG[1][YDIR]*C2;
    TT1[ZDIR] =GG[1][ZDIR]*C2;
    72ec:	e1a02004 	mov	r2, r4
    TT[XDIR] =G23[XDIR]*C2+TT1[XDIR];
    TT[YDIR] =G23[YDIR]*C2+TT1[YDIR];
    72f0:	e1a0a000 	mov	sl, r0
    72f4:	e1a0b001 	mov	fp, r1
    G45[XDIR]=GG[4][XDIR]+GG[5][XDIR];
    G45[YDIR]=GG[4][YDIR]+GG[5][YDIR];
    G45[ZDIR]=GG[4][ZDIR]+GG[5][ZDIR];
    TT1[XDIR] =GG[1][XDIR]*C2;
    TT1[YDIR] =GG[1][YDIR]*C2;
    TT1[ZDIR] =GG[1][ZDIR]*C2;
    72f8:	e1cd00d0 	ldrd	r0, [sp]
    72fc:	e1a03005 	mov	r3, r5
    7300:	eb0035fe 	bl	14b00 <__aeabi_dmul>
    TT[XDIR] =G23[XDIR]*C2+TT1[XDIR];
    TT[YDIR] =G23[YDIR]*C2+TT1[YDIR];
    TT[ZDIR] =G23[ZDIR]*C2+TT1[ZDIR];
    7304:	e1a02004 	mov	r2, r4
    G45[XDIR]=GG[4][XDIR]+GG[5][XDIR];
    G45[YDIR]=GG[4][YDIR]+GG[5][YDIR];
    G45[ZDIR]=GG[4][ZDIR]+GG[5][ZDIR];
    TT1[XDIR] =GG[1][XDIR]*C2;
    TT1[YDIR] =GG[1][YDIR]*C2;
    TT1[ZDIR] =GG[1][ZDIR]*C2;
    7308:	e1a06000 	mov	r6, r0
    730c:	e1a07001 	mov	r7, r1
    TT[XDIR] =G23[XDIR]*C2+TT1[XDIR];
    TT[YDIR] =G23[YDIR]*C2+TT1[YDIR];
    TT[ZDIR] =G23[ZDIR]*C2+TT1[ZDIR];
    7310:	e1cd02d0 	ldrd	r0, [sp, #32]
    7314:	e1a03005 	mov	r3, r5
    7318:	eb0035f8 	bl	14b00 <__aeabi_dmul>
    731c:	e1a02000 	mov	r2, r0
    7320:	e1a03001 	mov	r3, r1
    7324:	e1a00006 	mov	r0, r6
    7328:	e1a01007 	mov	r1, r7
    732c:	eb0034ef 	bl	146f0 <__adddf3>
    tx_p = link_ptr->mol.F[DEST][XDIR];
    ty_p = link_ptr->mol.F[DEST][YDIR];
    tz_p = link_ptr->mol.F[DEST][ZDIR];

    tx_p[H1] +=
        GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
    7330:	e28dec01 	add	lr, sp, #256	; 0x100
    7334:	e28dcc02 	add	ip, sp, #512	; 0x200
    7338:	e14c2ed8 	ldrd	r2, [ip, #-232]	; 0xffffff18
    TT1[XDIR] =GG[1][XDIR]*C2;
    TT1[YDIR] =GG[1][YDIR]*C2;
    TT1[ZDIR] =GG[1][ZDIR]*C2;
    TT[XDIR] =G23[XDIR]*C2+TT1[XDIR];
    TT[YDIR] =G23[YDIR]*C2+TT1[YDIR];
    TT[ZDIR] =G23[ZDIR]*C2+TT1[ZDIR];
    733c:	e1cd00f0 	strd	r0, [sp]
    tx_p = link_ptr->mol.F[DEST][XDIR];
    ty_p = link_ptr->mol.F[DEST][YDIR];
    tz_p = link_ptr->mol.F[DEST][ZDIR];

    tx_p[H1] +=
        GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
    7340:	e1ce00d0 	ldrd	r0, [lr]
    7344:	e28d5c02 	add	r5, sp, #512	; 0x200
    7348:	eb0034e8 	bl	146f0 <__adddf3>
    734c:	e14525d8 	ldrd	r2, [r5, #-88]	; 0xffffffa8
    7350:	eb0034e6 	bl	146f0 <__adddf3>
    TT2[YDIR]=G45[YDIR]*C2+TT1[YDIR];
    TT2[ZDIR]=G45[ZDIR]*C2+TT1[ZDIR];

    /* Update force or acceleration for link */

    tx_p = link_ptr->mol.F[DEST][XDIR];
    7354:	e59d400c 	ldr	r4, [sp, #12]
    ty_p = link_ptr->mol.F[DEST][YDIR];
    tz_p = link_ptr->mol.F[DEST][ZDIR];

    tx_p[H1] +=
        GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
    7358:	e1a02000 	mov	r2, r0
    735c:	e1a03001 	mov	r3, r1
    7360:	e1cd02d8 	ldrd	r0, [sp, #40]	; 0x28
    TT2[YDIR]=G45[YDIR]*C2+TT1[YDIR];
    TT2[ZDIR]=G45[ZDIR]*C2+TT1[ZDIR];

    /* Update force or acceleration for link */

    tx_p = link_ptr->mol.F[DEST][XDIR];
    7364:	e0846184 	add	r6, r4, r4, lsl #3
    ty_p = link_ptr->mol.F[DEST][YDIR];
    tz_p = link_ptr->mol.F[DEST][ZDIR];
    7368:	e2848001 	add	r8, r4, #1
    G110[YDIR] = GG[10][YDIR]+GG[1][YDIR]*C1;
    G110[ZDIR] = GG[10][ZDIR]+GG[1][ZDIR]*C1;
    G23[XDIR] = GG[2][XDIR]+GG[3][XDIR];
    G23[YDIR] = GG[2][YDIR]+GG[3][YDIR];
    G23[ZDIR] = GG[2][ZDIR]+GG[3][ZDIR];
    G45[XDIR]=GG[4][XDIR]+GG[5][XDIR];
    736c:	e59f432c 	ldr	r4, [pc, #812]	; 76a0 <UPDATE_FORCES+0x5d8>
    tx_p = link_ptr->mol.F[DEST][XDIR];
    ty_p = link_ptr->mol.F[DEST][YDIR];
    tz_p = link_ptr->mol.F[DEST][ZDIR];

    tx_p[H1] +=
        GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
    7370:	eb0034de 	bl	146f0 <__adddf3>
    7374:	e28dcf76 	add	ip, sp, #472	; 0x1d8
    7378:	e18c20d4 	ldrd	r2, [ip, r4]
    737c:	eb0034db 	bl	146f0 <__adddf3>
    TT2[YDIR]=G45[YDIR]*C2+TT1[YDIR];
    TT2[ZDIR]=G45[ZDIR]*C2+TT1[ZDIR];

    /* Update force or acceleration for link */

    tx_p = link_ptr->mol.F[DEST][XDIR];
    7380:	e1a06186 	lsl	r6, r6, #3
    ty_p = link_ptr->mol.F[DEST][YDIR];
    tz_p = link_ptr->mol.F[DEST][ZDIR];

    tx_p[H1] +=
    7384:	e59d4008 	ldr	r4, [sp, #8]
    TT2[YDIR]=G45[YDIR]*C2+TT1[YDIR];
    TT2[ZDIR]=G45[ZDIR]*C2+TT1[ZDIR];

    /* Update force or acceleration for link */

    tx_p = link_ptr->mol.F[DEST][XDIR];
    7388:	e2867018 	add	r7, r6, #24
    ty_p = link_ptr->mol.F[DEST][YDIR];
    tz_p = link_ptr->mol.F[DEST][ZDIR];

    tx_p[H1] +=
        GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
    738c:	e1a02000 	mov	r2, r0
    7390:	e1a03001 	mov	r3, r1

    tx_p = link_ptr->mol.F[DEST][XDIR];
    ty_p = link_ptr->mol.F[DEST][YDIR];
    tz_p = link_ptr->mol.F[DEST][ZDIR];

    tx_p[H1] +=
    7394:	e18400d7 	ldrd	r0, [r4, r7]
    7398:	eb0034d4 	bl	146f0 <__adddf3>
        GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
    tx_p[O] +=
        G110[XDIR] + GG[11][XDIR] +GG[12][XDIR]+C1*G23[XDIR];
    739c:	e28d5c02 	add	r5, sp, #512	; 0x200
    73a0:	e14528d8 	ldrd	r2, [r5, #-136]	; 0xffffff78

    tx_p = link_ptr->mol.F[DEST][XDIR];
    ty_p = link_ptr->mol.F[DEST][YDIR];
    tz_p = link_ptr->mol.F[DEST][ZDIR];

    tx_p[H1] +=
    73a4:	e18400f7 	strd	r0, [r4, r7]
        GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
    tx_p[O] +=
        G110[XDIR] + GG[11][XDIR] +GG[12][XDIR]+C1*G23[XDIR];
    73a8:	e1cd05d8 	ldrd	r0, [sp, #88]	; 0x58
    73ac:	eb0034cf 	bl	146f0 <__adddf3>
    73b0:	e28dcc02 	add	ip, sp, #512	; 0x200
    73b4:	e14c27d0 	ldrd	r2, [ip, #-112]	; 0xffffff90
    73b8:	eb0034cc 	bl	146f0 <__adddf3>
    73bc:	e1c920d0 	ldrd	r2, [r9]
    73c0:	e1a04000 	mov	r4, r0
    73c4:	e1a05001 	mov	r5, r1
    73c8:	e1cd01d0 	ldrd	r0, [sp, #16]
    73cc:	eb0035cb 	bl	14b00 <__aeabi_dmul>
    73d0:	e1a02000 	mov	r2, r0
    73d4:	e1a03001 	mov	r3, r1
    73d8:	e1a00004 	mov	r0, r4
    73dc:	e1a01005 	mov	r1, r5
    73e0:	eb0034c2 	bl	146f0 <__adddf3>
    TT2[YDIR]=G45[YDIR]*C2+TT1[YDIR];
    TT2[ZDIR]=G45[ZDIR]*C2+TT1[ZDIR];

    /* Update force or acceleration for link */

    tx_p = link_ptr->mol.F[DEST][XDIR];
    73e4:	e59d4008 	ldr	r4, [sp, #8]
    tz_p = link_ptr->mol.F[DEST][ZDIR];

    tx_p[H1] +=
        GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
    tx_p[O] +=
        G110[XDIR] + GG[11][XDIR] +GG[12][XDIR]+C1*G23[XDIR];
    73e8:	e1a02000 	mov	r2, r0
    TT2[YDIR]=G45[YDIR]*C2+TT1[YDIR];
    TT2[ZDIR]=G45[ZDIR]*C2+TT1[ZDIR];

    /* Update force or acceleration for link */

    tx_p = link_ptr->mol.F[DEST][XDIR];
    73ec:	e0847007 	add	r7, r4, r7
    tz_p = link_ptr->mol.F[DEST][ZDIR];

    tx_p[H1] +=
        GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
    tx_p[O] +=
        G110[XDIR] + GG[11][XDIR] +GG[12][XDIR]+C1*G23[XDIR];
    73f0:	e1a03001 	mov	r3, r1
    ty_p = link_ptr->mol.F[DEST][YDIR];
    tz_p = link_ptr->mol.F[DEST][ZDIR];

    tx_p[H1] +=
        GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
    tx_p[O] +=
    73f4:	e1c700d8 	ldrd	r0, [r7, #8]
    73f8:	eb0034bc 	bl	146f0 <__adddf3>
        G110[XDIR] + GG[11][XDIR] +GG[12][XDIR]+C1*G23[XDIR];
    tx_p[H2] +=
        GG[8][XDIR]+GG[9][XDIR]+GG[14][XDIR]+TT[XDIR]+GG[5][XDIR];
    73fc:	e28d5c02 	add	r5, sp, #512	; 0x200
    7400:	e1452bd8 	ldrd	r2, [r5, #-184]	; 0xffffff48
    ty_p = link_ptr->mol.F[DEST][YDIR];
    tz_p = link_ptr->mol.F[DEST][ZDIR];

    tx_p[H1] +=
        GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
    tx_p[O] +=
    7404:	e1c700f8 	strd	r0, [r7, #8]
        G110[XDIR] + GG[11][XDIR] +GG[12][XDIR]+C1*G23[XDIR];
    tx_p[H2] +=
        GG[8][XDIR]+GG[9][XDIR]+GG[14][XDIR]+TT[XDIR]+GG[5][XDIR];
    7408:	e1450dd0 	ldrd	r0, [r5, #-208]	; 0xffffff30
    740c:	eb0034b7 	bl	146f0 <__adddf3>
    7410:	e28dcc02 	add	ip, sp, #512	; 0x200
    7414:	e14c24d0 	ldrd	r2, [ip, #-64]	; 0xffffffc0
    7418:	eb0034b4 	bl	146f0 <__adddf3>
    741c:	e1a02000 	mov	r2, r0
    7420:	e1a03001 	mov	r3, r1
    7424:	e1cd02d8 	ldrd	r0, [sp, #40]	; 0x28
    7428:	eb0034b0 	bl	146f0 <__adddf3>
    742c:	e1a02000 	mov	r2, r0
    7430:	e1a03001 	mov	r3, r1
    7434:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
    7438:	eb0034ac 	bl	146f0 <__adddf3>
    743c:	e1a02000 	mov	r2, r0
    7440:	e1a03001 	mov	r3, r1

    tx_p[H1] +=
        GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
    tx_p[O] +=
        G110[XDIR] + GG[11][XDIR] +GG[12][XDIR]+C1*G23[XDIR];
    tx_p[H2] +=
    7444:	e1c701d0 	ldrd	r0, [r7, #16]
    7448:	eb0034a8 	bl	146f0 <__adddf3>
        GG[8][XDIR]+GG[9][XDIR]+GG[14][XDIR]+TT[XDIR]+GG[5][XDIR];
    ty_p[H1] +=
        GG[6][YDIR]+GG[7][YDIR]+GG[13][YDIR]+TT[YDIR]+GG[4][YDIR];
    744c:	e28dec02 	add	lr, sp, #512	; 0x200
    7450:	e14e2ed0 	ldrd	r2, [lr, #-224]	; 0xffffff20

    tx_p[H1] +=
        GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
    tx_p[O] +=
        G110[XDIR] + GG[11][XDIR] +GG[12][XDIR]+C1*G23[XDIR];
    tx_p[H2] +=
    7454:	e1c701f0 	strd	r0, [r7, #16]
        GG[8][XDIR]+GG[9][XDIR]+GG[14][XDIR]+TT[XDIR]+GG[5][XDIR];
    ty_p[H1] +=
        GG[6][YDIR]+GG[7][YDIR]+GG[13][YDIR]+TT[YDIR]+GG[4][YDIR];
    7458:	e14e0fd8 	ldrd	r0, [lr, #-248]	; 0xffffff08
    745c:	e28d4c02 	add	r4, sp, #512	; 0x200
    7460:	eb0034a2 	bl	146f0 <__adddf3>
    7464:	e14425d0 	ldrd	r2, [r4, #-80]	; 0xffffffb0
    7468:	eb0034a0 	bl	146f0 <__adddf3>
    746c:	e1a02000 	mov	r2, r0
    7470:	e1a03001 	mov	r3, r1
    7474:	e1a0000a 	mov	r0, sl
    7478:	e1a0100b 	mov	r1, fp
    747c:	eb00349b 	bl	146f0 <__adddf3>
    7480:	e1a02000 	mov	r2, r0
    7484:	e1a03001 	mov	r3, r1
    7488:	e1cd03d8 	ldrd	r0, [sp, #56]	; 0x38
    748c:	eb003497 	bl	146f0 <__adddf3>
        GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
    tx_p[O] +=
        G110[XDIR] + GG[11][XDIR] +GG[12][XDIR]+C1*G23[XDIR];
    tx_p[H2] +=
        GG[8][XDIR]+GG[9][XDIR]+GG[14][XDIR]+TT[XDIR]+GG[5][XDIR];
    ty_p[H1] +=
    7490:	e59d5008 	ldr	r5, [sp, #8]
    TT2[ZDIR]=G45[ZDIR]*C2+TT1[ZDIR];

    /* Update force or acceleration for link */

    tx_p = link_ptr->mol.F[DEST][XDIR];
    ty_p = link_ptr->mol.F[DEST][YDIR];
    7494:	e2866030 	add	r6, r6, #48	; 0x30
    tx_p[O] +=
        G110[XDIR] + GG[11][XDIR] +GG[12][XDIR]+C1*G23[XDIR];
    tx_p[H2] +=
        GG[8][XDIR]+GG[9][XDIR]+GG[14][XDIR]+TT[XDIR]+GG[5][XDIR];
    ty_p[H1] +=
        GG[6][YDIR]+GG[7][YDIR]+GG[13][YDIR]+TT[YDIR]+GG[4][YDIR];
    7498:	e1a02000 	mov	r2, r0
    749c:	e1a03001 	mov	r3, r1
        GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
    tx_p[O] +=
        G110[XDIR] + GG[11][XDIR] +GG[12][XDIR]+C1*G23[XDIR];
    tx_p[H2] +=
        GG[8][XDIR]+GG[9][XDIR]+GG[14][XDIR]+TT[XDIR]+GG[5][XDIR];
    ty_p[H1] +=
    74a0:	e18500d6 	ldrd	r0, [r5, r6]
    74a4:	eb003491 	bl	146f0 <__adddf3>
        GG[6][YDIR]+GG[7][YDIR]+GG[13][YDIR]+TT[YDIR]+GG[4][YDIR];
    ty_p[O]  +=
        G110[YDIR]+GG[11][YDIR]+GG[12][YDIR]+C1*G23[YDIR];
    74a8:	e28d7c02 	add	r7, sp, #512	; 0x200
    74ac:	e14728d0 	ldrd	r2, [r7, #-128]	; 0xffffff80
        GG[6][XDIR]+GG[7][XDIR]+GG[13][XDIR]+TT[XDIR]+GG[4][XDIR];
    tx_p[O] +=
        G110[XDIR] + GG[11][XDIR] +GG[12][XDIR]+C1*G23[XDIR];
    tx_p[H2] +=
        GG[8][XDIR]+GG[9][XDIR]+GG[14][XDIR]+TT[XDIR]+GG[5][XDIR];
    ty_p[H1] +=
    74b0:	e18500f6 	strd	r0, [r5, r6]
        GG[6][YDIR]+GG[7][YDIR]+GG[13][YDIR]+TT[YDIR]+GG[4][YDIR];
    ty_p[O]  +=
        G110[YDIR]+GG[11][YDIR]+GG[12][YDIR]+C1*G23[YDIR];
    74b4:	e1cd06d0 	ldrd	r0, [sp, #96]	; 0x60
    74b8:	eb00348c 	bl	146f0 <__adddf3>
    74bc:	e28dcc02 	add	ip, sp, #512	; 0x200
    74c0:	e14c26d8 	ldrd	r2, [ip, #-104]	; 0xffffff98
    74c4:	eb003489 	bl	146f0 <__adddf3>
    74c8:	e1a04000 	mov	r4, r0
    74cc:	e1a05001 	mov	r5, r1
    74d0:	e1cd01d8 	ldrd	r0, [sp, #24]
    74d4:	e1c920d0 	ldrd	r2, [r9]
    74d8:	eb003588 	bl	14b00 <__aeabi_dmul>
    74dc:	e1a02000 	mov	r2, r0
    74e0:	e1a03001 	mov	r3, r1
    74e4:	e1a00004 	mov	r0, r4
    74e8:	e1a01005 	mov	r1, r5
    74ec:	eb00347f 	bl	146f0 <__adddf3>
    TT2[ZDIR]=G45[ZDIR]*C2+TT1[ZDIR];

    /* Update force or acceleration for link */

    tx_p = link_ptr->mol.F[DEST][XDIR];
    ty_p = link_ptr->mol.F[DEST][YDIR];
    74f0:	e59d4008 	ldr	r4, [sp, #8]
    tx_p[H2] +=
        GG[8][XDIR]+GG[9][XDIR]+GG[14][XDIR]+TT[XDIR]+GG[5][XDIR];
    ty_p[H1] +=
        GG[6][YDIR]+GG[7][YDIR]+GG[13][YDIR]+TT[YDIR]+GG[4][YDIR];
    ty_p[O]  +=
        G110[YDIR]+GG[11][YDIR]+GG[12][YDIR]+C1*G23[YDIR];
    74f4:	e1a02000 	mov	r2, r0
    TT2[ZDIR]=G45[ZDIR]*C2+TT1[ZDIR];

    /* Update force or acceleration for link */

    tx_p = link_ptr->mol.F[DEST][XDIR];
    ty_p = link_ptr->mol.F[DEST][YDIR];
    74f8:	e0846006 	add	r6, r4, r6
    tx_p[H2] +=
        GG[8][XDIR]+GG[9][XDIR]+GG[14][XDIR]+TT[XDIR]+GG[5][XDIR];
    ty_p[H1] +=
        GG[6][YDIR]+GG[7][YDIR]+GG[13][YDIR]+TT[YDIR]+GG[4][YDIR];
    ty_p[O]  +=
        G110[YDIR]+GG[11][YDIR]+GG[12][YDIR]+C1*G23[YDIR];
    74fc:	e1a03001 	mov	r3, r1
        G110[XDIR] + GG[11][XDIR] +GG[12][XDIR]+C1*G23[XDIR];
    tx_p[H2] +=
        GG[8][XDIR]+GG[9][XDIR]+GG[14][XDIR]+TT[XDIR]+GG[5][XDIR];
    ty_p[H1] +=
        GG[6][YDIR]+GG[7][YDIR]+GG[13][YDIR]+TT[YDIR]+GG[4][YDIR];
    ty_p[O]  +=
    7500:	e1c600d8 	ldrd	r0, [r6, #8]
    7504:	eb003479 	bl	146f0 <__adddf3>
        G110[YDIR]+GG[11][YDIR]+GG[12][YDIR]+C1*G23[YDIR];
    ty_p[H2] +=
        GG[8][YDIR]+GG[9][YDIR]+GG[14][YDIR]+TT[YDIR]+GG[5][YDIR];
    7508:	e28d5c02 	add	r5, sp, #512	; 0x200
    750c:	e1452bd0 	ldrd	r2, [r5, #-176]	; 0xffffff50
        G110[XDIR] + GG[11][XDIR] +GG[12][XDIR]+C1*G23[XDIR];
    tx_p[H2] +=
        GG[8][XDIR]+GG[9][XDIR]+GG[14][XDIR]+TT[XDIR]+GG[5][XDIR];
    ty_p[H1] +=
        GG[6][YDIR]+GG[7][YDIR]+GG[13][YDIR]+TT[YDIR]+GG[4][YDIR];
    ty_p[O]  +=
    7510:	e1c600f8 	strd	r0, [r6, #8]
        G110[YDIR]+GG[11][YDIR]+GG[12][YDIR]+C1*G23[YDIR];
    ty_p[H2] +=
        GG[8][YDIR]+GG[9][YDIR]+GG[14][YDIR]+TT[YDIR]+GG[5][YDIR];
    7514:	e1450cd8 	ldrd	r0, [r5, #-200]	; 0xffffff38
    7518:	e28d7c02 	add	r7, sp, #512	; 0x200
    751c:	eb003473 	bl	146f0 <__adddf3>
    7520:	e14723d8 	ldrd	r2, [r7, #-56]	; 0xffffffc8
    7524:	eb003471 	bl	146f0 <__adddf3>
    7528:	e1a02000 	mov	r2, r0
    752c:	e1a03001 	mov	r3, r1
    7530:	e1a0000a 	mov	r0, sl
    7534:	e1a0100b 	mov	r1, fp
    7538:	eb00346c 	bl	146f0 <__adddf3>
    753c:	e1a02000 	mov	r2, r0
    7540:	e1a03001 	mov	r3, r1
    7544:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    7548:	eb003468 	bl	146f0 <__adddf3>
    754c:	e1a02000 	mov	r2, r0
    7550:	e1a03001 	mov	r3, r1
        GG[8][XDIR]+GG[9][XDIR]+GG[14][XDIR]+TT[XDIR]+GG[5][XDIR];
    ty_p[H1] +=
        GG[6][YDIR]+GG[7][YDIR]+GG[13][YDIR]+TT[YDIR]+GG[4][YDIR];
    ty_p[O]  +=
        G110[YDIR]+GG[11][YDIR]+GG[12][YDIR]+C1*G23[YDIR];
    ty_p[H2] +=
    7554:	e1c601d0 	ldrd	r0, [r6, #16]
    7558:	eb003464 	bl	146f0 <__adddf3>
        GG[8][YDIR]+GG[9][YDIR]+GG[14][YDIR]+TT[YDIR]+GG[5][YDIR];
    tz_p[H1] +=
        GG[6][ZDIR]+GG[7][ZDIR]+GG[13][ZDIR]+TT[ZDIR]+GG[4][ZDIR];
    755c:	e28dcc02 	add	ip, sp, #512	; 0x200
    7560:	e14c2dd8 	ldrd	r2, [ip, #-216]	; 0xffffff28
        GG[8][XDIR]+GG[9][XDIR]+GG[14][XDIR]+TT[XDIR]+GG[5][XDIR];
    ty_p[H1] +=
        GG[6][YDIR]+GG[7][YDIR]+GG[13][YDIR]+TT[YDIR]+GG[4][YDIR];
    ty_p[O]  +=
        G110[YDIR]+GG[11][YDIR]+GG[12][YDIR]+C1*G23[YDIR];
    ty_p[H2] +=
    7564:	e1c601f0 	strd	r0, [r6, #16]
        GG[8][YDIR]+GG[9][YDIR]+GG[14][YDIR]+TT[YDIR]+GG[5][YDIR];
    tz_p[H1] +=
        GG[6][ZDIR]+GG[7][ZDIR]+GG[13][ZDIR]+TT[ZDIR]+GG[4][ZDIR];
    7568:	e14c0fd0 	ldrd	r0, [ip, #-240]	; 0xffffff10
    756c:	eb00345f 	bl	146f0 <__adddf3>
    7570:	e28dec02 	add	lr, sp, #512	; 0x200
    7574:	e14e24d8 	ldrd	r2, [lr, #-72]	; 0xffffffb8
    7578:	eb00345c 	bl	146f0 <__adddf3>
    757c:	e1a02000 	mov	r2, r0
    7580:	e1a03001 	mov	r3, r1
    7584:	e1cd00d0 	ldrd	r0, [sp]
    7588:	eb003458 	bl	146f0 <__adddf3>
    758c:	e1a02000 	mov	r2, r0
    7590:	e1a03001 	mov	r3, r1
    7594:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    7598:	eb003454 	bl	146f0 <__adddf3>

    /* Update force or acceleration for link */

    tx_p = link_ptr->mol.F[DEST][XDIR];
    ty_p = link_ptr->mol.F[DEST][YDIR];
    tz_p = link_ptr->mol.F[DEST][ZDIR];
    759c:	e0888188 	add	r8, r8, r8, lsl #3
    75a0:	e1a08188 	lsl	r8, r8, #3
    ty_p[O]  +=
        G110[YDIR]+GG[11][YDIR]+GG[12][YDIR]+C1*G23[YDIR];
    ty_p[H2] +=
        GG[8][YDIR]+GG[9][YDIR]+GG[14][YDIR]+TT[YDIR]+GG[5][YDIR];
    tz_p[H1] +=
        GG[6][ZDIR]+GG[7][ZDIR]+GG[13][ZDIR]+TT[ZDIR]+GG[4][ZDIR];
    75a4:	e1a02000 	mov	r2, r0
    75a8:	e1a03001 	mov	r3, r1
        GG[6][YDIR]+GG[7][YDIR]+GG[13][YDIR]+TT[YDIR]+GG[4][YDIR];
    ty_p[O]  +=
        G110[YDIR]+GG[11][YDIR]+GG[12][YDIR]+C1*G23[YDIR];
    ty_p[H2] +=
        GG[8][YDIR]+GG[9][YDIR]+GG[14][YDIR]+TT[YDIR]+GG[5][YDIR];
    tz_p[H1] +=
    75ac:	e18400d8 	ldrd	r0, [r4, r8]
    75b0:	eb00344e 	bl	146f0 <__adddf3>
    75b4:	e59d5008 	ldr	r5, [sp, #8]
        GG[6][ZDIR]+GG[7][ZDIR]+GG[13][ZDIR]+TT[ZDIR]+GG[4][ZDIR];
    tz_p[O]  +=
        G110[ZDIR]+GG[11][ZDIR]+GG[12][ZDIR]+C1*G23[ZDIR];
    75b8:	e28d4c02 	add	r4, sp, #512	; 0x200
    75bc:	e14427d8 	ldrd	r2, [r4, #-120]	; 0xffffff88
        GG[6][YDIR]+GG[7][YDIR]+GG[13][YDIR]+TT[YDIR]+GG[4][YDIR];
    ty_p[O]  +=
        G110[YDIR]+GG[11][YDIR]+GG[12][YDIR]+C1*G23[YDIR];
    ty_p[H2] +=
        GG[8][YDIR]+GG[9][YDIR]+GG[14][YDIR]+TT[YDIR]+GG[5][YDIR];
    tz_p[H1] +=
    75c0:	e18500f8 	strd	r0, [r5, r8]
        GG[6][ZDIR]+GG[7][ZDIR]+GG[13][ZDIR]+TT[ZDIR]+GG[4][ZDIR];
    tz_p[O]  +=
        G110[ZDIR]+GG[11][ZDIR]+GG[12][ZDIR]+C1*G23[ZDIR];
    75c4:	e1cd06d8 	ldrd	r0, [sp, #104]	; 0x68
    75c8:	e28d6c02 	add	r6, sp, #512	; 0x200
    75cc:	eb003447 	bl	146f0 <__adddf3>
    75d0:	e14626d0 	ldrd	r2, [r6, #-96]	; 0xffffffa0
    75d4:	eb003445 	bl	146f0 <__adddf3>
    75d8:	e1a04000 	mov	r4, r0
    75dc:	e1a05001 	mov	r5, r1
    75e0:	e1cd02d0 	ldrd	r0, [sp, #32]
    75e4:	e1c920d0 	ldrd	r2, [r9]
    75e8:	eb003544 	bl	14b00 <__aeabi_dmul>
    75ec:	e1a02000 	mov	r2, r0
    75f0:	e1a03001 	mov	r3, r1
    75f4:	e1a00004 	mov	r0, r4
    75f8:	e1a01005 	mov	r1, r5
    75fc:	eb00343b 	bl	146f0 <__adddf3>

    /* Update force or acceleration for link */

    tx_p = link_ptr->mol.F[DEST][XDIR];
    ty_p = link_ptr->mol.F[DEST][YDIR];
    tz_p = link_ptr->mol.F[DEST][ZDIR];
    7600:	e59d7008 	ldr	r7, [sp, #8]
    ty_p[H2] +=
        GG[8][YDIR]+GG[9][YDIR]+GG[14][YDIR]+TT[YDIR]+GG[5][YDIR];
    tz_p[H1] +=
        GG[6][ZDIR]+GG[7][ZDIR]+GG[13][ZDIR]+TT[ZDIR]+GG[4][ZDIR];
    tz_p[O]  +=
        G110[ZDIR]+GG[11][ZDIR]+GG[12][ZDIR]+C1*G23[ZDIR];
    7604:	e1a02000 	mov	r2, r0

    /* Update force or acceleration for link */

    tx_p = link_ptr->mol.F[DEST][XDIR];
    ty_p = link_ptr->mol.F[DEST][YDIR];
    tz_p = link_ptr->mol.F[DEST][ZDIR];
    7608:	e0878008 	add	r8, r7, r8
    ty_p[H2] +=
        GG[8][YDIR]+GG[9][YDIR]+GG[14][YDIR]+TT[YDIR]+GG[5][YDIR];
    tz_p[H1] +=
        GG[6][ZDIR]+GG[7][ZDIR]+GG[13][ZDIR]+TT[ZDIR]+GG[4][ZDIR];
    tz_p[O]  +=
        G110[ZDIR]+GG[11][ZDIR]+GG[12][ZDIR]+C1*G23[ZDIR];
    760c:	e1a03001 	mov	r3, r1
        G110[YDIR]+GG[11][YDIR]+GG[12][YDIR]+C1*G23[YDIR];
    ty_p[H2] +=
        GG[8][YDIR]+GG[9][YDIR]+GG[14][YDIR]+TT[YDIR]+GG[5][YDIR];
    tz_p[H1] +=
        GG[6][ZDIR]+GG[7][ZDIR]+GG[13][ZDIR]+TT[ZDIR]+GG[4][ZDIR];
    tz_p[O]  +=
    7610:	e1c800d8 	ldrd	r0, [r8, #8]
    7614:	eb003435 	bl	146f0 <__adddf3>
        G110[ZDIR]+GG[11][ZDIR]+GG[12][ZDIR]+C1*G23[ZDIR];
    tz_p[H2] +=
        GG[8][ZDIR]+GG[9][ZDIR]+GG[14][ZDIR]+TT[ZDIR]+GG[5][ZDIR];
    7618:	e28dcc02 	add	ip, sp, #512	; 0x200
    761c:	e14c2ad8 	ldrd	r2, [ip, #-168]	; 0xffffff58
        G110[YDIR]+GG[11][YDIR]+GG[12][YDIR]+C1*G23[YDIR];
    ty_p[H2] +=
        GG[8][YDIR]+GG[9][YDIR]+GG[14][YDIR]+TT[YDIR]+GG[5][YDIR];
    tz_p[H1] +=
        GG[6][ZDIR]+GG[7][ZDIR]+GG[13][ZDIR]+TT[ZDIR]+GG[4][ZDIR];
    tz_p[O]  +=
    7620:	e1c800f8 	strd	r0, [r8, #8]
        G110[ZDIR]+GG[11][ZDIR]+GG[12][ZDIR]+C1*G23[ZDIR];
    tz_p[H2] +=
        GG[8][ZDIR]+GG[9][ZDIR]+GG[14][ZDIR]+TT[ZDIR]+GG[5][ZDIR];
    7624:	e14c0cd0 	ldrd	r0, [ip, #-192]	; 0xffffff40
    7628:	eb003430 	bl	146f0 <__adddf3>
    762c:	e28dec02 	add	lr, sp, #512	; 0x200
    7630:	e14e23d0 	ldrd	r2, [lr, #-48]	; 0xffffffd0
    7634:	eb00342d 	bl	146f0 <__adddf3>
    7638:	e1a02000 	mov	r2, r0
    763c:	e1a03001 	mov	r3, r1
    7640:	e1cd00d0 	ldrd	r0, [sp]
    7644:	eb003429 	bl	146f0 <__adddf3>
    7648:	e1a02000 	mov	r2, r0
    764c:	e1a03001 	mov	r3, r1
    7650:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    7654:	eb003425 	bl	146f0 <__adddf3>
    7658:	e1a02000 	mov	r2, r0
    765c:	e1a03001 	mov	r3, r1
        GG[8][YDIR]+GG[9][YDIR]+GG[14][YDIR]+TT[YDIR]+GG[5][YDIR];
    tz_p[H1] +=
        GG[6][ZDIR]+GG[7][ZDIR]+GG[13][ZDIR]+TT[ZDIR]+GG[4][ZDIR];
    tz_p[O]  +=
        G110[ZDIR]+GG[11][ZDIR]+GG[12][ZDIR]+C1*G23[ZDIR];
    tz_p[H2] +=
    7660:	e1c801d0 	ldrd	r0, [r8, #16]
    7664:	eb003421 	bl	146f0 <__adddf3>
    7668:	e1c801f0 	strd	r0, [r8, #16]
        GG[8][ZDIR]+GG[9][ZDIR]+GG[14][ZDIR]+TT[ZDIR]+GG[5][ZDIR];

} /* end of subroutine UPDATE_FORCES */
    766c:	e28ddf77 	add	sp, sp, #476	; 0x1dc
    7670:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    7674:	0013ea48 	.word	0x0013ea48
    7678:	fffffeb0 	.word	0xfffffeb0
    767c:	fffffeb8 	.word	0xfffffeb8
    7680:	fffffec0 	.word	0xfffffec0
    7684:	fffffec8 	.word	0xfffffec8
    7688:	fffffee0 	.word	0xfffffee0
    768c:	fffffed0 	.word	0xfffffed0
    7690:	fffffee8 	.word	0xfffffee8
    7694:	fffffed8 	.word	0xfffffed8
    7698:	fffffef0 	.word	0xfffffef0
    769c:	0013efa0 	.word	0x0013efa0
    76a0:	fffffef8 	.word	0xfffffef8

000076a4 <INTERF>:
#include "mddata.h"
#include "split.h"
#include "global.h"

void INTERF(long DEST, double *VIR, long ProcID)
{
    76a4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

    long XBOX, YBOX, ZBOX, X_NUM, Y_NUM, Z_NUM;
    /* per interaction arrays that hold some computed distances */
    double YL[15], XL[15], ZL[15], RS[15], FF[15], RL[15];
    double  FTEMP;
    double LVIR = 0.0;
    76a8:	e3a04000 	mov	r4, #0
    76ac:	e3a05000 	mov	r5, #0
#include "mddata.h"
#include "split.h"
#include "global.h"

void INTERF(long DEST, double *VIR, long ProcID)
{
    76b0:	e24ddfe5 	sub	sp, sp, #916	; 0x394
    76b4:	e58d0064 	str	r0, [sp, #100]	; 0x64
    double LVIR = 0.0;
    struct link *curr_ptr, *neighbor_ptr;
    struct list_of_boxes *curr_box;
    double *temp_p;

    curr_box = my_boxes[ProcID];
    76b8:	e59f0cb8 	ldr	r0, [pc, #3256]	; 8378 <INTERF+0xcd4>
#include "mddata.h"
#include "split.h"
#include "global.h"

void INTERF(long DEST, double *VIR, long ProcID)
{
    76bc:	e58d20a8 	str	r2, [sp, #168]	; 0xa8
    double LVIR = 0.0;
    struct link *curr_ptr, *neighbor_ptr;
    struct list_of_boxes *curr_box;
    double *temp_p;

    curr_box = my_boxes[ProcID];
    76c0:	e5903000 	ldr	r3, [r0]
#include "mddata.h"
#include "split.h"
#include "global.h"

void INTERF(long DEST, double *VIR, long ProcID)
{
    76c4:	e58d10a4 	str	r1, [sp, #164]	; 0xa4
    double LVIR = 0.0;
    struct link *curr_ptr, *neighbor_ptr;
    struct list_of_boxes *curr_box;
    double *temp_p;

    curr_box = my_boxes[ProcID];
    76c8:	e7933102 	ldr	r3, [r3, r2, lsl #2]

    long XBOX, YBOX, ZBOX, X_NUM, Y_NUM, Z_NUM;
    /* per interaction arrays that hold some computed distances */
    double YL[15], XL[15], ZL[15], RS[15], FF[15], RL[15];
    double  FTEMP;
    double LVIR = 0.0;
    76cc:	e1cd44f8 	strd	r4, [sp, #72]	; 0x48
    struct link *curr_ptr, *neighbor_ptr;
    struct list_of_boxes *curr_box;
    double *temp_p;

    curr_box = my_boxes[ProcID];
    while (curr_box) {
    76d0:	e3530000 	cmp	r3, #0
    double LVIR = 0.0;
    struct link *curr_ptr, *neighbor_ptr;
    struct list_of_boxes *curr_box;
    double *temp_p;

    curr_box = my_boxes[ProcID];
    76d4:	e58d3080 	str	r3, [sp, #128]	; 0x80
    while (curr_box) {
    76d8:	0a000412 	beq	8728 <INTERF+0x1084>
    76dc:	e59dc080 	ldr	ip, [sp, #128]	; 0x80

        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
    76e0:	e59cc004 	ldr	ip, [ip, #4]
    double *temp_p;

    curr_box = my_boxes[ProcID];
    while (curr_box) {

        i = curr_box->coord[XDIR];  /* X coordinate of box */
    76e4:	e59d5080 	ldr	r5, [sp, #128]	; 0x80
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
    76e8:	e58dc088 	str	ip, [sp, #136]	; 0x88
    double *temp_p;

    curr_box = my_boxes[ProcID];
    while (curr_box) {

        i = curr_box->coord[XDIR];  /* X coordinate of box */
    76ec:	e5955000 	ldr	r5, [r5]
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */
    76f0:	e59dc080 	ldr	ip, [sp, #128]	; 0x80

        /* loop over nearest neighbor boxes */

        for (XBOX=i-1; XBOX<=i+1; XBOX++) {
    76f4:	e2454001 	sub	r4, r5, #1
    double *temp_p;

    curr_box = my_boxes[ProcID];
    while (curr_box) {

        i = curr_box->coord[XDIR];  /* X coordinate of box */
    76f8:	e58d5084 	str	r5, [sp, #132]	; 0x84
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */
    76fc:	e59cc008 	ldr	ip, [ip, #8]

        /* loop over nearest neighbor boxes */

        for (XBOX=i-1; XBOX<=i+1; XBOX++) {
    7700:	e2855001 	add	r5, r5, #1
    7704:	e1540005 	cmp	r4, r5
    7708:	e58d4078 	str	r4, [sp, #120]	; 0x78
    770c:	e58d5094 	str	r5, [sp, #148]	; 0x94
    curr_box = my_boxes[ProcID];
    while (curr_box) {

        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */
    7710:	e58dc08c 	str	ip, [sp, #140]	; 0x8c

        /* loop over nearest neighbor boxes */

        for (XBOX=i-1; XBOX<=i+1; XBOX++) {
    7714:	ca0003fe 	bgt	8714 <INTERF+0x1070>
    7718:	e59d4088 	ldr	r4, [sp, #136]	; 0x88
    771c:	e59d5088 	ldr	r5, [sp, #136]	; 0x88
    7720:	e2444001 	sub	r4, r4, #1
    7724:	e58d4098 	str	r4, [sp, #152]	; 0x98
    7728:	e59d408c 	ldr	r4, [sp, #140]	; 0x8c
    772c:	e2855001 	add	r5, r5, #1
    7730:	e24cc001 	sub	ip, ip, #1
    7734:	e2844001 	add	r4, r4, #1
    7738:	e58d509c 	str	r5, [sp, #156]	; 0x9c
    773c:	e58dc0a0 	str	ip, [sp, #160]	; 0xa0
    7740:	e58d4090 	str	r4, [sp, #144]	; 0x90
    7744:	e59d5084 	ldr	r5, [sp, #132]	; 0x84
    7748:	e59dc088 	ldr	ip, [sp, #136]	; 0x88
    774c:	e59d408c 	ldr	r4, [sp, #140]	; 0x8c
    7750:	e1a05105 	lsl	r5, r5, #2
    7754:	e1a0c10c 	lsl	ip, ip, #2
    7758:	e1a04204 	lsl	r4, r4, #4
    775c:	e58d506c 	str	r5, [sp, #108]	; 0x6c
    7760:	e58dc070 	str	ip, [sp, #112]	; 0x70
    7764:	e58d4074 	str	r4, [sp, #116]	; 0x74
            for (YBOX=j-1; YBOX<=j+1; YBOX++) {
    7768:	e59d5098 	ldr	r5, [sp, #152]	; 0x98
    776c:	e59dc09c 	ldr	ip, [sp, #156]	; 0x9c
    7770:	e155000c 	cmp	r5, ip
    7774:	ca0003e0 	bgt	86fc <INTERF+0x1058>
                for (ZBOX=k-1; ZBOX<=k+1; ZBOX++) {

                    /* Special case for two boxes per side */

                    if ((BOX_PER_SIDE == 2) && ((XBOX < 0) || (XBOX == 2) ||
    7778:	e59d4078 	ldr	r4, [sp, #120]	; 0x78
    777c:	e58d507c 	str	r5, [sp, #124]	; 0x7c
    7780:	e1a03fa4 	lsr	r3, r4, #31
    7784:	e3540002 	cmp	r4, #2
    7788:	03833001 	orreq	r3, r3, #1
    778c:	e58d30ac 	str	r3, [sp, #172]	; 0xac

        /* loop over nearest neighbor boxes */

        for (XBOX=i-1; XBOX<=i+1; XBOX++) {
            for (YBOX=j-1; YBOX<=j+1; YBOX++) {
                for (ZBOX=k-1; ZBOX<=k+1; ZBOX++) {
    7790:	e59d50a0 	ldr	r5, [sp, #160]	; 0xa0
    7794:	e59dc090 	ldr	ip, [sp, #144]	; 0x90
    7798:	e155000c 	cmp	r5, ip
    779c:	ca0003d0 	bgt	86e4 <INTERF+0x1040>

                    /* Special case for two boxes per side */

                    if ((BOX_PER_SIDE == 2) && ((XBOX < 0) || (XBOX == 2) ||
                                                (YBOX < 0) || (YBOX == 2) || (ZBOX < 0) || (ZBOX == 2)))
    77a0:	e59d407c 	ldr	r4, [sp, #124]	; 0x7c
                        Z_NUM -= BOX_PER_SIDE;

                    /* Don't do current box more than once */

                    if ((X_NUM == i) && (Y_NUM == j) && (Z_NUM == k) &&
                        ((XBOX != i) || (YBOX != j) || (ZBOX !=k))) {
    77a4:	e59d5088 	ldr	r5, [sp, #136]	; 0x88
    77a8:	e59dc078 	ldr	ip, [sp, #120]	; 0x78
    77ac:	e59de084 	ldr	lr, [sp, #132]	; 0x84
                for (ZBOX=k-1; ZBOX<=k+1; ZBOX++) {

                    /* Special case for two boxes per side */

                    if ((BOX_PER_SIDE == 2) && ((XBOX < 0) || (XBOX == 2) ||
                                                (YBOX < 0) || (YBOX == 2) || (ZBOX < 0) || (ZBOX == 2)))
    77b0:	e1a03fa4 	lsr	r3, r4, #31
    77b4:	e3540002 	cmp	r4, #2
    77b8:	03833001 	orreq	r3, r3, #1
                        Z_NUM -= BOX_PER_SIDE;

                    /* Don't do current box more than once */

                    if ((X_NUM == i) && (Y_NUM == j) && (Z_NUM == k) &&
                        ((XBOX != i) || (YBOX != j) || (ZBOX !=k))) {
    77bc:	e15c000e 	cmp	ip, lr
    77c0:	01540005 	cmpeq	r4, r5
    77c4:	13a05001 	movne	r5, #1
    77c8:	03a05000 	moveq	r5, #0
    77cc:	e59d40a0 	ldr	r4, [sp, #160]	; 0xa0
                for (ZBOX=k-1; ZBOX<=k+1; ZBOX++) {

                    /* Special case for two boxes per side */

                    if ((BOX_PER_SIDE == 2) && ((XBOX < 0) || (XBOX == 2) ||
                                                (YBOX < 0) || (YBOX == 2) || (ZBOX < 0) || (ZBOX == 2)))
    77d0:	e58d30b0 	str	r3, [sp, #176]	; 0xb0
                        Z_NUM -= BOX_PER_SIDE;

                    /* Don't do current box more than once */

                    if ((X_NUM == i) && (Y_NUM == j) && (Z_NUM == k) &&
                        ((XBOX != i) || (YBOX != j) || (ZBOX !=k))) {
    77d4:	e58d50b4 	str	r5, [sp, #180]	; 0xb4
    77d8:	e58d4068 	str	r4, [sp, #104]	; 0x68
            for (YBOX=j-1; YBOX<=j+1; YBOX++) {
                for (ZBOX=k-1; ZBOX<=k+1; ZBOX++) {

                    /* Special case for two boxes per side */

                    if ((BOX_PER_SIDE == 2) && ((XBOX < 0) || (XBOX == 2) ||
    77dc:	e59f5aa0 	ldr	r5, [pc, #2720]	; 8284 <INTERF+0xbe0>
    77e0:	e5953000 	ldr	r3, [r5]
    77e4:	e3530002 	cmp	r3, #2
    77e8:	0a000457 	beq	894c <INTERF+0x12a8>
                    Y_NUM = YBOX;
                    Z_NUM = ZBOX;

                    /* Make box number valid if out of box */

                    if (X_NUM == -1)
    77ec:	e59dc078 	ldr	ip, [sp, #120]	; 0x78
    77f0:	e37c0001 	cmn	ip, #1
                        X_NUM += BOX_PER_SIDE;
    77f4:	02430001 	subeq	r0, r3, #1
                    Y_NUM = YBOX;
                    Z_NUM = ZBOX;

                    /* Make box number valid if out of box */

                    if (X_NUM == -1)
    77f8:	0a000003 	beq	780c <INTERF+0x168>
                        X_NUM += BOX_PER_SIDE;
                    else if (X_NUM >= BOX_PER_SIDE)
    77fc:	e59d4078 	ldr	r4, [sp, #120]	; 0x78
    7800:	e1540003 	cmp	r4, r3
    7804:	b1a00004 	movlt	r0, r4
                        X_NUM -= BOX_PER_SIDE;
    7808:	a0630004 	rsbge	r0, r3, r4
                    if (Y_NUM == -1)
    780c:	e59d507c 	ldr	r5, [sp, #124]	; 0x7c
    7810:	e3750001 	cmn	r5, #1
                        Y_NUM += BOX_PER_SIDE;
    7814:	02431001 	subeq	r1, r3, #1

                    if (X_NUM == -1)
                        X_NUM += BOX_PER_SIDE;
                    else if (X_NUM >= BOX_PER_SIDE)
                        X_NUM -= BOX_PER_SIDE;
                    if (Y_NUM == -1)
    7818:	0a000002 	beq	7828 <INTERF+0x184>
                        Y_NUM += BOX_PER_SIDE;
                    else if (Y_NUM >= BOX_PER_SIDE)
    781c:	e1530005 	cmp	r3, r5
    7820:	c1a01005 	movgt	r1, r5
                        Y_NUM -= BOX_PER_SIDE;
    7824:	d0631005 	rsble	r1, r3, r5
                    if (Z_NUM == -1)
    7828:	e59d4068 	ldr	r4, [sp, #104]	; 0x68
    782c:	e3740001 	cmn	r4, #1
                        Z_NUM += BOX_PER_SIDE;
    7830:	02432001 	subeq	r2, r3, #1
                        X_NUM -= BOX_PER_SIDE;
                    if (Y_NUM == -1)
                        Y_NUM += BOX_PER_SIDE;
                    else if (Y_NUM >= BOX_PER_SIDE)
                        Y_NUM -= BOX_PER_SIDE;
                    if (Z_NUM == -1)
    7834:	0a000002 	beq	7844 <INTERF+0x1a0>
                        Z_NUM += BOX_PER_SIDE;
                    else if (Z_NUM >= BOX_PER_SIDE)
    7838:	e1530004 	cmp	r3, r4
    783c:	c1a02004 	movgt	r2, r4
                        Z_NUM -= BOX_PER_SIDE;
    7840:	d0632004 	rsble	r2, r3, r4

                    /* Don't do current box more than once */

                    if ((X_NUM == i) && (Y_NUM == j) && (Z_NUM == k) &&
    7844:	e59dc084 	ldr	ip, [sp, #132]	; 0x84
    7848:	e59d4088 	ldr	r4, [sp, #136]	; 0x88
    784c:	e150000c 	cmp	r0, ip
    7850:	01510004 	cmpeq	r1, r4
    7854:	1a000002 	bne	7864 <INTERF+0x1c0>
    7858:	e59d508c 	ldr	r5, [sp, #140]	; 0x8c
    785c:	e1520005 	cmp	r2, r5
    7860:	0a000393 	beq	86b4 <INTERF+0x1010>
                        ((XBOX != i) || (YBOX != j) || (ZBOX !=k))) {
                        continue;
                    }

                    neighbor_ptr = BOX[X_NUM][Y_NUM][Z_NUM].list;
    7864:	e59f5b10 	ldr	r5, [pc, #2832]	; 837c <INTERF+0xcd8>
    7868:	e5953000 	ldr	r3, [r5]
    786c:	e7930100 	ldr	r0, [r3, r0, lsl #2]
    7870:	e7901101 	ldr	r1, [r0, r1, lsl #2]
    7874:	e7911202 	ldr	r1, [r1, r2, lsl #4]

                    while (neighbor_ptr) {
    7878:	e3510000 	cmp	r1, #0
                    if ((X_NUM == i) && (Y_NUM == j) && (Z_NUM == k) &&
                        ((XBOX != i) || (YBOX != j) || (ZBOX !=k))) {
                        continue;
                    }

                    neighbor_ptr = BOX[X_NUM][Y_NUM][Z_NUM].list;
    787c:	e58d1050 	str	r1, [sp, #80]	; 0x50

                    while (neighbor_ptr) {
    7880:	0a000391 	beq	86cc <INTERF+0x1028>

                        /* go through current box list */

                        curr_ptr = BOX[i][j][k].list;
    7884:	e59dc06c 	ldr	ip, [sp, #108]	; 0x6c
    7888:	e59d4070 	ldr	r4, [sp, #112]	; 0x70
    788c:	e793300c 	ldr	r3, [r3, ip]
    7890:	e59d5074 	ldr	r5, [sp, #116]	; 0x74
    7894:	e7933004 	ldr	r3, [r3, r4]
    7898:	e793c005 	ldr	ip, [r3, r5]
                        while (curr_ptr) {
    789c:	e35c0000 	cmp	ip, #0
    78a0:	0a00020b 	beq	80d4 <INTERF+0xa30>
    78a4:	e1a0b00c 	mov	fp, ip

                            /* Don't do interaction with same molecule */

                            if (curr_ptr == neighbor_ptr) {
    78a8:	e59dc050 	ldr	ip, [sp, #80]	; 0x50
    78ac:	e15b000c 	cmp	fp, ip
    78b0:	0a000204 	beq	80c8 <INTERF+0xa24>
    78b4:	e1a0600c 	mov	r6, ip
                            }

                            /*  compute some intermolecular distances;
                                first call CSHIFT to implement periodic boundary conditions */

                            CSHIFT(curr_ptr->mol.F[DISP][XDIR],neighbor_ptr->mol.F[DISP][XDIR],
    78b8:	e1a0700b 	mov	r7, fp
    78bc:	e59f59c4 	ldr	r5, [pc, #2500]	; 8288 <INTERF+0xbe4>
    78c0:	e59fe9c4 	ldr	lr, [pc, #2500]	; 828c <INTERF+0xbe8>
    78c4:	e1c540d0 	ldrd	r4, [r5]
    78c8:	e1cd43f0 	strd	r4, [sp, #48]	; 0x30
    78cc:	e1ce80d0 	ldrd	r8, [lr]
    78d0:	e0c723d0 	ldrd	r2, [r7], #48	; 0x30
    78d4:	e0c643d0 	ldrd	r4, [r6], #48	; 0x30
    78d8:	e1cd40f0 	strd	r4, [sp]
    78dc:	e1cd43d0 	ldrd	r4, [sp, #48]	; 0x30
    78e0:	e1cd41f8 	strd	r4, [sp, #24]
    78e4:	e59d5050 	ldr	r5, [sp, #80]	; 0x50
    78e8:	e28dcf4e 	add	ip, sp, #312	; 0x138
    78ec:	e2851018 	add	r1, r5, #24
    78f0:	e28b0018 	add	r0, fp, #24
    78f4:	e58dc008 	str	ip, [sp, #8]
    78f8:	e1cd81f0 	strd	r8, [sp, #16]
    78fc:	ebfff35d 	bl	4678 <CSHIFT>
                                   curr_ptr->mol.VM[XDIR],neighbor_ptr->mol.VM[XDIR],XL,BOXH,BOXL);
                            CSHIFT(curr_ptr->mol.F[DISP][YDIR],neighbor_ptr->mol.F[DISP][YDIR],
    7900:	e1cb20d8 	ldrd	r2, [fp, #8]
    7904:	e59fc980 	ldr	ip, [pc, #2432]	; 828c <INTERF+0xbe8>
    7908:	e59f1978 	ldr	r1, [pc, #2424]	; 8288 <INTERF+0xbe4>
    790c:	e59d5050 	ldr	r5, [sp, #80]	; 0x50
    7910:	e1c100d0 	ldrd	r0, [r1]
    7914:	e1cc80d0 	ldrd	r8, [ip]
    7918:	e1cd02f8 	strd	r0, [sp, #40]	; 0x28
    791c:	e1c540d8 	ldrd	r4, [r5, #8]
    7920:	e28dc0c0 	add	ip, sp, #192	; 0xc0
    7924:	e1a00007 	mov	r0, r7
    7928:	e1a01006 	mov	r1, r6
    792c:	e58dc008 	str	ip, [sp, #8]
    7930:	e1cd40f0 	strd	r4, [sp]
    7934:	e1cd42d8 	ldrd	r4, [sp, #40]	; 0x28
    7938:	e1cd81f0 	strd	r8, [sp, #16]
    793c:	e1cd41f8 	strd	r4, [sp, #24]
    7940:	ebfff34c 	bl	4678 <CSHIFT>
                                   curr_ptr->mol.VM[YDIR],neighbor_ptr->mol.VM[YDIR],YL,BOXH,BOXL);
                            CSHIFT(curr_ptr->mol.F[DISP][ZDIR],neighbor_ptr->mol.F[DISP][ZDIR],
    7944:	e1cb21d0 	ldrd	r2, [fp, #16]
    7948:	e59d5050 	ldr	r5, [sp, #80]	; 0x50
    794c:	e59fe934 	ldr	lr, [pc, #2356]	; 8288 <INTERF+0xbe4>
    7950:	e59fc934 	ldr	ip, [pc, #2356]	; 828c <INTERF+0xbe8>
    7954:	e1c501d0 	ldrd	r0, [r5, #16]
    7958:	e1ce60d0 	ldrd	r6, [lr]
    795c:	e1cc40d0 	ldrd	r4, [ip]
    7960:	e1cd41f0 	strd	r4, [sp, #16]
    7964:	e59d4050 	ldr	r4, [sp, #80]	; 0x50
    7968:	e28dce1b 	add	ip, sp, #432	; 0x1b0
    796c:	e1cd00f0 	strd	r0, [sp]
    7970:	e1cd61f8 	strd	r6, [sp, #24]
    7974:	e2841048 	add	r1, r4, #72	; 0x48
    7978:	e58dc008 	str	ip, [sp, #8]
    797c:	e28b0048 	add	r0, fp, #72	; 0x48
    7980:	ebfff33c 	bl	4678 <CSHIFT>
                                   curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);

                            KC=0;
                            for (K = 0; K < 9; K++) {
                                RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    7984:	e59f2904 	ldr	r2, [pc, #2308]	; 8290 <INTERF+0xbec>
    7988:	e59f3904 	ldr	r3, [pc, #2308]	; 8294 <INTERF+0xbf0>
    798c:	e28dce39 	add	ip, sp, #912	; 0x390
    7990:	e18c80d3 	ldrd	r8, [ip, r3]
    7994:	e18c00d2 	ldrd	r0, [ip, r2]
    7998:	e59f58f8 	ldr	r5, [pc, #2296]	; 8298 <INTERF+0xbf4>
    799c:	e59fc8f8 	ldr	ip, [pc, #2296]	; 829c <INTERF+0xbf8>
    79a0:	e28dee39 	add	lr, sp, #912	; 0x390
    79a4:	e1a02000 	mov	r2, r0
    79a8:	e1c540d0 	ldrd	r4, [r5]
    79ac:	e1a03001 	mov	r3, r1
    79b0:	e1cd43f8 	strd	r4, [sp, #56]	; 0x38
    79b4:	e18e40dc 	ldrd	r4, [lr, ip]
    79b8:	eb003450 	bl	14b00 <__aeabi_dmul>
    79bc:	e1a02008 	mov	r2, r8
    79c0:	e1a06000 	mov	r6, r0
    79c4:	e1a07001 	mov	r7, r1
    79c8:	e1a03009 	mov	r3, r9
    79cc:	e1a00008 	mov	r0, r8
    79d0:	e1a01009 	mov	r1, r9
    79d4:	eb003449 	bl	14b00 <__aeabi_dmul>
    79d8:	e1a02000 	mov	r2, r0
    79dc:	e1a03001 	mov	r3, r1
    79e0:	e1a00006 	mov	r0, r6
    79e4:	e1a01007 	mov	r1, r7
    79e8:	eb003340 	bl	146f0 <__adddf3>
    79ec:	e1a02004 	mov	r2, r4
    79f0:	e1a06000 	mov	r6, r0
    79f4:	e1a07001 	mov	r7, r1
    79f8:	e1a03005 	mov	r3, r5
    79fc:	e1a00004 	mov	r0, r4
    7a00:	e1a01005 	mov	r1, r5
    7a04:	eb00343d 	bl	14b00 <__aeabi_dmul>
    7a08:	e1a02000 	mov	r2, r0
    7a0c:	e1a03001 	mov	r3, r1
    7a10:	e1a00006 	mov	r0, r6
    7a14:	e1a01007 	mov	r1, r7
    7a18:	eb003334 	bl	146f0 <__adddf3>
    7a1c:	e1cd23d8 	ldrd	r2, [sp, #56]	; 0x38
    7a20:	e59fc878 	ldr	ip, [pc, #2168]	; 82a0 <INTERF+0xbfc>
    7a24:	e28d4e39 	add	r4, sp, #912	; 0x390
    7a28:	e18400fc 	strd	r0, [r4, ip]
    7a2c:	e1cd04f0 	strd	r0, [sp, #64]	; 0x40
    7a30:	eb0035a4 	bl	150c8 <__aeabi_dcmpgt>
    7a34:	e59f3868 	ldr	r3, [pc, #2152]	; 82a4 <INTERF+0xc00>
    7a38:	e59fe868 	ldr	lr, [pc, #2152]	; 82a8 <INTERF+0xc04>
    7a3c:	e59fc868 	ldr	ip, [pc, #2152]	; 82ac <INTERF+0xc08>
    7a40:	e28d5e39 	add	r5, sp, #912	; 0x390
    7a44:	e290a000 	adds	sl, r0, #0
    7a48:	e18500d3 	ldrd	r0, [r5, r3]
    7a4c:	e1a02000 	mov	r2, r0
    7a50:	e18560dc 	ldrd	r6, [r5, ip]
    7a54:	e18580de 	ldrd	r8, [r5, lr]
    7a58:	e1a03001 	mov	r3, r1
    7a5c:	13a0a001 	movne	sl, #1
    7a60:	eb003426 	bl	14b00 <__aeabi_dmul>
    7a64:	e1a02008 	mov	r2, r8
    7a68:	e1a04000 	mov	r4, r0
    7a6c:	e1a05001 	mov	r5, r1
    7a70:	e1a03009 	mov	r3, r9
    7a74:	e1a00008 	mov	r0, r8
    7a78:	e1a01009 	mov	r1, r9
    7a7c:	eb00341f 	bl	14b00 <__aeabi_dmul>
    7a80:	e1a02000 	mov	r2, r0
    7a84:	e1a03001 	mov	r3, r1
    7a88:	e1a00004 	mov	r0, r4
    7a8c:	e1a01005 	mov	r1, r5
    7a90:	eb003316 	bl	146f0 <__adddf3>
    7a94:	e1a02006 	mov	r2, r6
    7a98:	e1a04000 	mov	r4, r0
    7a9c:	e1a05001 	mov	r5, r1
    7aa0:	e1a03007 	mov	r3, r7
    7aa4:	e1a00006 	mov	r0, r6
    7aa8:	e1a01007 	mov	r1, r7
    7aac:	eb003413 	bl	14b00 <__aeabi_dmul>
    7ab0:	e1a02000 	mov	r2, r0
    7ab4:	e1a03001 	mov	r3, r1
    7ab8:	e1a00004 	mov	r0, r4
    7abc:	e1a01005 	mov	r1, r5
    7ac0:	eb00330a 	bl	146f0 <__adddf3>
    7ac4:	e1cd23d8 	ldrd	r2, [sp, #56]	; 0x38
    7ac8:	e59fc7e0 	ldr	ip, [pc, #2016]	; 82b0 <INTERF+0xc0c>
    7acc:	e28dee39 	add	lr, sp, #912	; 0x390
    7ad0:	e18e00fc 	strd	r0, [lr, ip]
    7ad4:	eb00357b 	bl	150c8 <__aeabi_dcmpgt>
                                if (RS[K] > CUT2)
                                    KC++;
    7ad8:	e28a2001 	add	r2, sl, #1
    7adc:	e3500000 	cmp	r0, #0
                            CSHIFT(curr_ptr->mol.F[DISP][ZDIR],neighbor_ptr->mol.F[DISP][ZDIR],
                                   curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);

                            KC=0;
                            for (K = 0; K < 9; K++) {
                                RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    7ae0:	e59f37cc 	ldr	r3, [pc, #1996]	; 82b4 <INTERF+0xc10>
    7ae4:	11a0a002 	movne	sl, r2
    7ae8:	e59fe7c8 	ldr	lr, [pc, #1992]	; 82b8 <INTERF+0xc14>
    7aec:	e59fc7c8 	ldr	ip, [pc, #1992]	; 82bc <INTERF+0xc18>
    7af0:	e28d2e39 	add	r2, sp, #912	; 0x390
    7af4:	e18200d3 	ldrd	r0, [r2, r3]
    7af8:	e28d4e39 	add	r4, sp, #912	; 0x390
    7afc:	e1a02000 	mov	r2, r0
    7b00:	e18480de 	ldrd	r8, [r4, lr]
    7b04:	e18460dc 	ldrd	r6, [r4, ip]
    7b08:	e1a03001 	mov	r3, r1
    7b0c:	eb0033fb 	bl	14b00 <__aeabi_dmul>
    7b10:	e1a02008 	mov	r2, r8
    7b14:	e1a04000 	mov	r4, r0
    7b18:	e1a05001 	mov	r5, r1
    7b1c:	e1a03009 	mov	r3, r9
    7b20:	e1a00008 	mov	r0, r8
    7b24:	e1a01009 	mov	r1, r9
    7b28:	eb0033f4 	bl	14b00 <__aeabi_dmul>
    7b2c:	e1a02000 	mov	r2, r0
    7b30:	e1a03001 	mov	r3, r1
    7b34:	e1a00004 	mov	r0, r4
    7b38:	e1a01005 	mov	r1, r5
    7b3c:	eb0032eb 	bl	146f0 <__adddf3>
    7b40:	e1a02006 	mov	r2, r6
    7b44:	e1a04000 	mov	r4, r0
    7b48:	e1a05001 	mov	r5, r1
    7b4c:	e1a03007 	mov	r3, r7
    7b50:	e1a00006 	mov	r0, r6
    7b54:	e1a01007 	mov	r1, r7
    7b58:	eb0033e8 	bl	14b00 <__aeabi_dmul>
    7b5c:	e1a02000 	mov	r2, r0
    7b60:	e1a03001 	mov	r3, r1
    7b64:	e1a00004 	mov	r0, r4
    7b68:	e1a01005 	mov	r1, r5
    7b6c:	eb0032df 	bl	146f0 <__adddf3>
    7b70:	e1cd23d8 	ldrd	r2, [sp, #56]	; 0x38
    7b74:	e59fc744 	ldr	ip, [pc, #1860]	; 82c0 <INTERF+0xc1c>
    7b78:	e28d5e39 	add	r5, sp, #912	; 0x390
    7b7c:	e18500fc 	strd	r0, [r5, ip]
    7b80:	eb003550 	bl	150c8 <__aeabi_dcmpgt>
    7b84:	e59f3738 	ldr	r3, [pc, #1848]	; 82c4 <INTERF+0xc20>
    7b88:	e28dce39 	add	ip, sp, #912	; 0x390
    7b8c:	e3500000 	cmp	r0, #0
    7b90:	e59fe730 	ldr	lr, [pc, #1840]	; 82c8 <INTERF+0xc24>
                                if (RS[K] > CUT2)
                                    KC++;
    7b94:	e28a2001 	add	r2, sl, #1
                            CSHIFT(curr_ptr->mol.F[DISP][ZDIR],neighbor_ptr->mol.F[DISP][ZDIR],
                                   curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);

                            KC=0;
                            for (K = 0; K < 9; K++) {
                                RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    7b98:	e18c00d3 	ldrd	r0, [ip, r3]
    7b9c:	e59fc728 	ldr	ip, [pc, #1832]	; 82cc <INTERF+0xc28>
    7ba0:	11a0a002 	movne	sl, r2
    7ba4:	e28d4e39 	add	r4, sp, #912	; 0x390
    7ba8:	e1a02000 	mov	r2, r0
    7bac:	e18480de 	ldrd	r8, [r4, lr]
    7bb0:	e18460dc 	ldrd	r6, [r4, ip]
    7bb4:	e1a03001 	mov	r3, r1
    7bb8:	eb0033d0 	bl	14b00 <__aeabi_dmul>
    7bbc:	e1a02008 	mov	r2, r8
    7bc0:	e1a04000 	mov	r4, r0
    7bc4:	e1a05001 	mov	r5, r1
    7bc8:	e1a03009 	mov	r3, r9
    7bcc:	e1a00008 	mov	r0, r8
    7bd0:	e1a01009 	mov	r1, r9
    7bd4:	eb0033c9 	bl	14b00 <__aeabi_dmul>
    7bd8:	e1a02000 	mov	r2, r0
    7bdc:	e1a03001 	mov	r3, r1
    7be0:	e1a00004 	mov	r0, r4
    7be4:	e1a01005 	mov	r1, r5
    7be8:	eb0032c0 	bl	146f0 <__adddf3>
    7bec:	e1a02006 	mov	r2, r6
    7bf0:	e1a04000 	mov	r4, r0
    7bf4:	e1a05001 	mov	r5, r1
    7bf8:	e1a03007 	mov	r3, r7
    7bfc:	e1a00006 	mov	r0, r6
    7c00:	e1a01007 	mov	r1, r7
    7c04:	eb0033bd 	bl	14b00 <__aeabi_dmul>
    7c08:	e1a02000 	mov	r2, r0
    7c0c:	e1a03001 	mov	r3, r1
    7c10:	e1a00004 	mov	r0, r4
    7c14:	e1a01005 	mov	r1, r5
    7c18:	eb0032b4 	bl	146f0 <__adddf3>
    7c1c:	e1cd23d8 	ldrd	r2, [sp, #56]	; 0x38
    7c20:	e59fc6a8 	ldr	ip, [pc, #1704]	; 82d0 <INTERF+0xc2c>
    7c24:	e28d5e39 	add	r5, sp, #912	; 0x390
    7c28:	e18500fc 	strd	r0, [r5, ip]
    7c2c:	eb003525 	bl	150c8 <__aeabi_dcmpgt>
    7c30:	e59f369c 	ldr	r3, [pc, #1692]	; 82d4 <INTERF+0xc30>
    7c34:	e28dce39 	add	ip, sp, #912	; 0x390
    7c38:	e3500000 	cmp	r0, #0
    7c3c:	e59fe694 	ldr	lr, [pc, #1684]	; 82d8 <INTERF+0xc34>
                                if (RS[K] > CUT2)
                                    KC++;
    7c40:	e28a2001 	add	r2, sl, #1
                            CSHIFT(curr_ptr->mol.F[DISP][ZDIR],neighbor_ptr->mol.F[DISP][ZDIR],
                                   curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);

                            KC=0;
                            for (K = 0; K < 9; K++) {
                                RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    7c44:	e18c00d3 	ldrd	r0, [ip, r3]
    7c48:	e59fc68c 	ldr	ip, [pc, #1676]	; 82dc <INTERF+0xc38>
    7c4c:	11a0a002 	movne	sl, r2
    7c50:	e28d4e39 	add	r4, sp, #912	; 0x390
    7c54:	e1a02000 	mov	r2, r0
    7c58:	e18480de 	ldrd	r8, [r4, lr]
    7c5c:	e18460dc 	ldrd	r6, [r4, ip]
    7c60:	e1a03001 	mov	r3, r1
    7c64:	eb0033a5 	bl	14b00 <__aeabi_dmul>
    7c68:	e1a02008 	mov	r2, r8
    7c6c:	e1a04000 	mov	r4, r0
    7c70:	e1a05001 	mov	r5, r1
    7c74:	e1a03009 	mov	r3, r9
    7c78:	e1a00008 	mov	r0, r8
    7c7c:	e1a01009 	mov	r1, r9
    7c80:	eb00339e 	bl	14b00 <__aeabi_dmul>
    7c84:	e1a02000 	mov	r2, r0
    7c88:	e1a03001 	mov	r3, r1
    7c8c:	e1a00004 	mov	r0, r4
    7c90:	e1a01005 	mov	r1, r5
    7c94:	eb003295 	bl	146f0 <__adddf3>
    7c98:	e1a02006 	mov	r2, r6
    7c9c:	e1a04000 	mov	r4, r0
    7ca0:	e1a05001 	mov	r5, r1
    7ca4:	e1a03007 	mov	r3, r7
    7ca8:	e1a00006 	mov	r0, r6
    7cac:	e1a01007 	mov	r1, r7
    7cb0:	eb003392 	bl	14b00 <__aeabi_dmul>
    7cb4:	e1a02000 	mov	r2, r0
    7cb8:	e1a03001 	mov	r3, r1
    7cbc:	e1a00004 	mov	r0, r4
    7cc0:	e1a01005 	mov	r1, r5
    7cc4:	eb003289 	bl	146f0 <__adddf3>
    7cc8:	e1cd23d8 	ldrd	r2, [sp, #56]	; 0x38
    7ccc:	e59fc60c 	ldr	ip, [pc, #1548]	; 82e0 <INTERF+0xc3c>
    7cd0:	e28d5e39 	add	r5, sp, #912	; 0x390
    7cd4:	e18500fc 	strd	r0, [r5, ip]
    7cd8:	eb0034fa 	bl	150c8 <__aeabi_dcmpgt>
    7cdc:	e59f3600 	ldr	r3, [pc, #1536]	; 82e4 <INTERF+0xc40>
    7ce0:	e28dce39 	add	ip, sp, #912	; 0x390
    7ce4:	e3500000 	cmp	r0, #0
    7ce8:	e59fe5f8 	ldr	lr, [pc, #1528]	; 82e8 <INTERF+0xc44>
                                if (RS[K] > CUT2)
                                    KC++;
    7cec:	e28a2001 	add	r2, sl, #1
                            CSHIFT(curr_ptr->mol.F[DISP][ZDIR],neighbor_ptr->mol.F[DISP][ZDIR],
                                   curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);

                            KC=0;
                            for (K = 0; K < 9; K++) {
                                RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    7cf0:	e18c00d3 	ldrd	r0, [ip, r3]
    7cf4:	e59fc5f0 	ldr	ip, [pc, #1520]	; 82ec <INTERF+0xc48>
    7cf8:	11a0a002 	movne	sl, r2
    7cfc:	e28d4e39 	add	r4, sp, #912	; 0x390
    7d00:	e1a02000 	mov	r2, r0
    7d04:	e18480de 	ldrd	r8, [r4, lr]
    7d08:	e18460dc 	ldrd	r6, [r4, ip]
    7d0c:	e1a03001 	mov	r3, r1
    7d10:	eb00337a 	bl	14b00 <__aeabi_dmul>
    7d14:	e1a02008 	mov	r2, r8
    7d18:	e1a04000 	mov	r4, r0
    7d1c:	e1a05001 	mov	r5, r1
    7d20:	e1a03009 	mov	r3, r9
    7d24:	e1a00008 	mov	r0, r8
    7d28:	e1a01009 	mov	r1, r9
    7d2c:	eb003373 	bl	14b00 <__aeabi_dmul>
    7d30:	e1a02000 	mov	r2, r0
    7d34:	e1a03001 	mov	r3, r1
    7d38:	e1a00004 	mov	r0, r4
    7d3c:	e1a01005 	mov	r1, r5
    7d40:	eb00326a 	bl	146f0 <__adddf3>
    7d44:	e1a02006 	mov	r2, r6
    7d48:	e1a04000 	mov	r4, r0
    7d4c:	e1a05001 	mov	r5, r1
    7d50:	e1a03007 	mov	r3, r7
    7d54:	e1a00006 	mov	r0, r6
    7d58:	e1a01007 	mov	r1, r7
    7d5c:	eb003367 	bl	14b00 <__aeabi_dmul>
    7d60:	e1a02000 	mov	r2, r0
    7d64:	e1a03001 	mov	r3, r1
    7d68:	e1a00004 	mov	r0, r4
    7d6c:	e1a01005 	mov	r1, r5
    7d70:	eb00325e 	bl	146f0 <__adddf3>
    7d74:	e1cd23d8 	ldrd	r2, [sp, #56]	; 0x38
    7d78:	e59fc570 	ldr	ip, [pc, #1392]	; 82f0 <INTERF+0xc4c>
    7d7c:	e28d5e39 	add	r5, sp, #912	; 0x390
    7d80:	e18500fc 	strd	r0, [r5, ip]
    7d84:	eb0034cf 	bl	150c8 <__aeabi_dcmpgt>
    7d88:	e59f3564 	ldr	r3, [pc, #1380]	; 82f4 <INTERF+0xc50>
    7d8c:	e28dce39 	add	ip, sp, #912	; 0x390
    7d90:	e3500000 	cmp	r0, #0
    7d94:	e59fe55c 	ldr	lr, [pc, #1372]	; 82f8 <INTERF+0xc54>
    7d98:	e18c00d3 	ldrd	r0, [ip, r3]
                                if (RS[K] > CUT2)
                                    KC++;
    7d9c:	e28a2001 	add	r2, sl, #1
                            CSHIFT(curr_ptr->mol.F[DISP][ZDIR],neighbor_ptr->mol.F[DISP][ZDIR],
                                   curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);

                            KC=0;
                            for (K = 0; K < 9; K++) {
                                RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    7da0:	e59fc554 	ldr	ip, [pc, #1364]	; 82fc <INTERF+0xc58>
    7da4:	11a0a002 	movne	sl, r2
    7da8:	e28d4e39 	add	r4, sp, #912	; 0x390
    7dac:	e1a02000 	mov	r2, r0
    7db0:	e18480de 	ldrd	r8, [r4, lr]
    7db4:	e18460dc 	ldrd	r6, [r4, ip]
    7db8:	e1a03001 	mov	r3, r1
    7dbc:	eb00334f 	bl	14b00 <__aeabi_dmul>
    7dc0:	e1a02008 	mov	r2, r8
    7dc4:	e1a04000 	mov	r4, r0
    7dc8:	e1a05001 	mov	r5, r1
    7dcc:	e1a03009 	mov	r3, r9
    7dd0:	e1a00008 	mov	r0, r8
    7dd4:	e1a01009 	mov	r1, r9
    7dd8:	eb003348 	bl	14b00 <__aeabi_dmul>
    7ddc:	e1a02000 	mov	r2, r0
    7de0:	e1a03001 	mov	r3, r1
    7de4:	e1a00004 	mov	r0, r4
    7de8:	e1a01005 	mov	r1, r5
    7dec:	eb00323f 	bl	146f0 <__adddf3>
    7df0:	e1a02006 	mov	r2, r6
    7df4:	e1a04000 	mov	r4, r0
    7df8:	e1a05001 	mov	r5, r1
    7dfc:	e1a03007 	mov	r3, r7
    7e00:	e1a00006 	mov	r0, r6
    7e04:	e1a01007 	mov	r1, r7
    7e08:	eb00333c 	bl	14b00 <__aeabi_dmul>
    7e0c:	e1a02000 	mov	r2, r0
    7e10:	e1a03001 	mov	r3, r1
    7e14:	e1a00004 	mov	r0, r4
    7e18:	e1a01005 	mov	r1, r5
    7e1c:	eb003233 	bl	146f0 <__adddf3>
    7e20:	e1cd23d8 	ldrd	r2, [sp, #56]	; 0x38
    7e24:	e59fc4d4 	ldr	ip, [pc, #1236]	; 8300 <INTERF+0xc5c>
    7e28:	e28d5e39 	add	r5, sp, #912	; 0x390
    7e2c:	e18500fc 	strd	r0, [r5, ip]
    7e30:	eb0034a4 	bl	150c8 <__aeabi_dcmpgt>
    7e34:	e59f34c8 	ldr	r3, [pc, #1224]	; 8304 <INTERF+0xc60>
    7e38:	e28dce39 	add	ip, sp, #912	; 0x390
    7e3c:	e3500000 	cmp	r0, #0
    7e40:	e59fe4c0 	ldr	lr, [pc, #1216]	; 8308 <INTERF+0xc64>
    7e44:	e18c00d3 	ldrd	r0, [ip, r3]
                                if (RS[K] > CUT2)
                                    KC++;
    7e48:	e28a2001 	add	r2, sl, #1
                            CSHIFT(curr_ptr->mol.F[DISP][ZDIR],neighbor_ptr->mol.F[DISP][ZDIR],
                                   curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);

                            KC=0;
                            for (K = 0; K < 9; K++) {
                                RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    7e4c:	e59fc4b8 	ldr	ip, [pc, #1208]	; 830c <INTERF+0xc68>
    7e50:	11a0a002 	movne	sl, r2
    7e54:	e28d4e39 	add	r4, sp, #912	; 0x390
    7e58:	e1a02000 	mov	r2, r0
    7e5c:	e18480de 	ldrd	r8, [r4, lr]
    7e60:	e18460dc 	ldrd	r6, [r4, ip]
    7e64:	e1a03001 	mov	r3, r1
    7e68:	eb003324 	bl	14b00 <__aeabi_dmul>
    7e6c:	e1a02008 	mov	r2, r8
    7e70:	e1a04000 	mov	r4, r0
    7e74:	e1a05001 	mov	r5, r1
    7e78:	e1a03009 	mov	r3, r9
    7e7c:	e1a00008 	mov	r0, r8
    7e80:	e1a01009 	mov	r1, r9
    7e84:	eb00331d 	bl	14b00 <__aeabi_dmul>
    7e88:	e1a02000 	mov	r2, r0
    7e8c:	e1a03001 	mov	r3, r1
    7e90:	e1a00004 	mov	r0, r4
    7e94:	e1a01005 	mov	r1, r5
    7e98:	eb003214 	bl	146f0 <__adddf3>
    7e9c:	e1a02006 	mov	r2, r6
    7ea0:	e1a04000 	mov	r4, r0
    7ea4:	e1a05001 	mov	r5, r1
    7ea8:	e1a03007 	mov	r3, r7
    7eac:	e1a00006 	mov	r0, r6
    7eb0:	e1a01007 	mov	r1, r7
    7eb4:	eb003311 	bl	14b00 <__aeabi_dmul>
    7eb8:	e1a02000 	mov	r2, r0
    7ebc:	e1a03001 	mov	r3, r1
    7ec0:	e1a00004 	mov	r0, r4
    7ec4:	e1a01005 	mov	r1, r5
    7ec8:	eb003208 	bl	146f0 <__adddf3>
    7ecc:	e1cd23d8 	ldrd	r2, [sp, #56]	; 0x38
    7ed0:	e59fc438 	ldr	ip, [pc, #1080]	; 8310 <INTERF+0xc6c>
    7ed4:	e28d5e39 	add	r5, sp, #912	; 0x390
    7ed8:	e18500fc 	strd	r0, [r5, ip]
    7edc:	eb003479 	bl	150c8 <__aeabi_dcmpgt>
    7ee0:	e59f342c 	ldr	r3, [pc, #1068]	; 8314 <INTERF+0xc70>
    7ee4:	e28dce39 	add	ip, sp, #912	; 0x390
    7ee8:	e3500000 	cmp	r0, #0
    7eec:	e59fe424 	ldr	lr, [pc, #1060]	; 8318 <INTERF+0xc74>
    7ef0:	e18c00d3 	ldrd	r0, [ip, r3]
                                if (RS[K] > CUT2)
                                    KC++;
    7ef4:	e28a2001 	add	r2, sl, #1
                            CSHIFT(curr_ptr->mol.F[DISP][ZDIR],neighbor_ptr->mol.F[DISP][ZDIR],
                                   curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);

                            KC=0;
                            for (K = 0; K < 9; K++) {
                                RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    7ef8:	e59fc41c 	ldr	ip, [pc, #1052]	; 831c <INTERF+0xc78>
    7efc:	11a0a002 	movne	sl, r2
    7f00:	e28d4e39 	add	r4, sp, #912	; 0x390
    7f04:	e1a02000 	mov	r2, r0
    7f08:	e18480de 	ldrd	r8, [r4, lr]
    7f0c:	e18460dc 	ldrd	r6, [r4, ip]
    7f10:	e1a03001 	mov	r3, r1
    7f14:	eb0032f9 	bl	14b00 <__aeabi_dmul>
    7f18:	e1a02008 	mov	r2, r8
    7f1c:	e1a04000 	mov	r4, r0
    7f20:	e1a05001 	mov	r5, r1
    7f24:	e1a03009 	mov	r3, r9
    7f28:	e1a00008 	mov	r0, r8
    7f2c:	e1a01009 	mov	r1, r9
    7f30:	eb0032f2 	bl	14b00 <__aeabi_dmul>
    7f34:	e1a02000 	mov	r2, r0
    7f38:	e1a03001 	mov	r3, r1
    7f3c:	e1a00004 	mov	r0, r4
    7f40:	e1a01005 	mov	r1, r5
    7f44:	eb0031e9 	bl	146f0 <__adddf3>
    7f48:	e1a02006 	mov	r2, r6
    7f4c:	e1a05001 	mov	r5, r1
    7f50:	e1a04000 	mov	r4, r0
    7f54:	e1a03007 	mov	r3, r7
    7f58:	e1a00006 	mov	r0, r6
    7f5c:	e1a01007 	mov	r1, r7
    7f60:	eb0032e6 	bl	14b00 <__aeabi_dmul>
    7f64:	e1a02000 	mov	r2, r0
    7f68:	e1a03001 	mov	r3, r1
    7f6c:	e1a00004 	mov	r0, r4
    7f70:	e1a01005 	mov	r1, r5
    7f74:	eb0031dd 	bl	146f0 <__adddf3>
    7f78:	e1cd23d8 	ldrd	r2, [sp, #56]	; 0x38
    7f7c:	e59fc39c 	ldr	ip, [pc, #924]	; 8320 <INTERF+0xc7c>
    7f80:	e28d5e39 	add	r5, sp, #912	; 0x390
    7f84:	e18500fc 	strd	r0, [r5, ip]
    7f88:	eb00344e 	bl	150c8 <__aeabi_dcmpgt>
    7f8c:	e3500000 	cmp	r0, #0
                                if (RS[K] > CUT2)
                                    KC++;
    7f90:	e28a3001 	add	r3, sl, #1
    7f94:	01a0300a 	moveq	r3, sl
                            } /* for K */

                            if (KC != 9) {
    7f98:	e3530009 	cmp	r3, #9
    7f9c:	e58d3054 	str	r3, [sp, #84]	; 0x54
    7fa0:	0a000048 	beq	80c8 <INTERF+0xa24>
                                for (K = 0; K < 14; K++)
                                    FF[K]=0.0;
                                if (RS[0] < CUT2) {
    7fa4:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    7fa8:	e1cd23d8 	ldrd	r2, [sp, #56]	; 0x38
                                    KC++;
                            } /* for K */

                            if (KC != 9) {
                                for (K = 0; K < 14; K++)
                                    FF[K]=0.0;
    7fac:	e3a04000 	mov	r4, #0
    7fb0:	e3a05000 	mov	r5, #0
    7fb4:	e28dcc02 	add	ip, sp, #512	; 0x200
    7fb8:	e1cc4af0 	strd	r4, [ip, #160]	; 0xa0
    7fbc:	e1cc4af8 	strd	r4, [ip, #168]	; 0xa8
    7fc0:	e1cc4bf0 	strd	r4, [ip, #176]	; 0xb0
    7fc4:	e1cc4bf8 	strd	r4, [ip, #184]	; 0xb8
    7fc8:	e1cc4cf0 	strd	r4, [ip, #192]	; 0xc0
    7fcc:	e1cc4cf8 	strd	r4, [ip, #200]	; 0xc8
    7fd0:	e1cc4df0 	strd	r4, [ip, #208]	; 0xd0
    7fd4:	e1cc4df8 	strd	r4, [ip, #216]	; 0xd8
    7fd8:	e1cc4ef0 	strd	r4, [ip, #224]	; 0xe0
    7fdc:	e1cc4ef8 	strd	r4, [ip, #232]	; 0xe8
    7fe0:	e1cc4ff0 	strd	r4, [ip, #240]	; 0xf0
    7fe4:	e1cc4ff8 	strd	r4, [ip, #248]	; 0xf8
    7fe8:	e28deb01 	add	lr, sp, #1024	; 0x400
    7fec:	e28dcc03 	add	ip, sp, #768	; 0x300
    7ff0:	e1cc40f0 	strd	r4, [ip]
    7ff4:	e14e4ff8 	strd	r4, [lr, #-248]	; 0xffffff08
                                if (RS[0] < CUT2) {
    7ff8:	eb003420 	bl	15080 <__aeabi_dcmplt>
    7ffc:	e3500000 	cmp	r0, #0
    8000:	1a00007e 	bne	8200 <INTERF+0xb5c>
    8004:	e28dcf8a 	add	ip, sp, #552	; 0x228
    8008:	e1a0800c 	mov	r8, ip
                                    FF[0]=QQ4/(RS[0]*sqrt(RS[0]))+REF4;
                                    LVIR = LVIR + FF[0]*RS[0];
                                } /* if */


                                for (K = 1; K < 5; K++) {
    800c:	e3a09001 	mov	r9, #1
    8010:	e28d4fc6 	add	r4, sp, #792	; 0x318
    8014:	e28d5e2a 	add	r5, sp, #672	; 0x2a0
    8018:	e58dc040 	str	ip, [sp, #64]	; 0x40
    801c:	e58d4058 	str	r4, [sp, #88]	; 0x58
    8020:	e58d5060 	str	r5, [sp, #96]	; 0x60
    8024:	e1a0a005 	mov	sl, r5
    8028:	e58db05c 	str	fp, [sp, #92]	; 0x5c
    802c:	e1a0b004 	mov	fp, r4
    8030:	e1cd43d8 	ldrd	r4, [sp, #56]	; 0x38
                                    if (RS[K] < CUT2) {
    8034:	e1c860d8 	ldrd	r6, [r8, #8]
    8038:	e1a02004 	mov	r2, r4
    803c:	e1a03005 	mov	r3, r5
    8040:	e1a00006 	mov	r0, r6
    8044:	e1a01007 	mov	r1, r7
    8048:	eb00340c 	bl	15080 <__aeabi_dcmplt>
    804c:	e3500000 	cmp	r0, #0
    8050:	1a000046 	bne	8170 <INTERF+0xacc>
                                        FF[K]= -QQ2/(RS[K]*sqrt(RS[K]))-REF2;
                                        LVIR = LVIR + FF[K]*RS[K];
                                    } /* if */
                                    if (RS[K+4] <= CUT2) {
    8054:	e1c862d8 	ldrd	r6, [r8, #40]	; 0x28
    8058:	e1a02004 	mov	r2, r4
    805c:	e1a03005 	mov	r3, r5
    8060:	e1a00006 	mov	r0, r6
    8064:	e1a01007 	mov	r1, r7
    8068:	eb00340a 	bl	15098 <__aeabi_dcmple>
    806c:	e3500000 	cmp	r0, #0
    8070:	1a00001f 	bne	80f4 <INTERF+0xa50>
                                    FF[0]=QQ4/(RS[0]*sqrt(RS[0]))+REF4;
                                    LVIR = LVIR + FF[0]*RS[0];
                                } /* if */


                                for (K = 1; K < 5; K++) {
    8074:	e2899001 	add	r9, r9, #1
    8078:	e3590005 	cmp	r9, #5
    807c:	e2888008 	add	r8, r8, #8
    8080:	e28bb008 	add	fp, fp, #8
    8084:	e28aa008 	add	sl, sl, #8
    8088:	159fc208 	ldrne	ip, [pc, #520]	; 8298 <INTERF+0xbf4>
    808c:	11cc40d0 	ldrdne	r4, [ip]
    8090:	1affffe7 	bne	8034 <INTERF+0x990>
                                        FF[K+4]=QQ/(RS[K+4]*RL[K+4])+REF1;
                                        LVIR = LVIR + FF[K+4]*RS[K+4];
                                    } /* if */
                                } /* for K */

                                if (KC == 0) {
    8094:	e59d5054 	ldr	r5, [sp, #84]	; 0x54
    8098:	e59db05c 	ldr	fp, [sp, #92]	; 0x5c
    809c:	e3550000 	cmp	r5, #0
    80a0:	0a0000b9 	beq	838c <INTERF+0xce8>
                                        FF[K]=(AB3*exp(-B3*RL[K])-AB4*exp(-B4*RL[K]))/RL[K];
                                        LVIR = LVIR + FF[K]*RS[K];
                                    } /* for K */
                                } /* if KC == 0 */

                                UPDATE_FORCES(curr_ptr, DEST, XL, YL, ZL, FF);
    80a4:	e28dce1b 	add	ip, sp, #432	; 0x1b0
    80a8:	e28dee2a 	add	lr, sp, #672	; 0x2a0
    80ac:	e58dc000 	str	ip, [sp]
    80b0:	e58de004 	str	lr, [sp, #4]
    80b4:	e28d2f4e 	add	r2, sp, #312	; 0x138
    80b8:	e28d30c0 	add	r3, sp, #192	; 0xc0
    80bc:	e1a0000b 	mov	r0, fp
    80c0:	e59d1064 	ldr	r1, [sp, #100]	; 0x64
    80c4:	ebfffbff 	bl	70c8 <UPDATE_FORCES>
                            }  /* if KC != 9 */

                            curr_ptr = curr_ptr->next_mol;
    80c8:	e59bb2a0 	ldr	fp, [fp, #672]	; 0x2a0
                    while (neighbor_ptr) {

                        /* go through current box list */

                        curr_ptr = BOX[i][j][k].list;
                        while (curr_ptr) {
    80cc:	e35b0000 	cmp	fp, #0
    80d0:	1afffdf4 	bne	78a8 <INTERF+0x204>
                            }  /* if KC != 9 */

                            curr_ptr = curr_ptr->next_mol;
                        } /* while curr_ptr */

                        neighbor_ptr = neighbor_ptr->next_mol;
    80d4:	e59d4050 	ldr	r4, [sp, #80]	; 0x50
    80d8:	e59442a0 	ldr	r4, [r4, #672]	; 0x2a0
                        continue;
                    }

                    neighbor_ptr = BOX[X_NUM][Y_NUM][Z_NUM].list;

                    while (neighbor_ptr) {
    80dc:	e3540000 	cmp	r4, #0
                            }  /* if KC != 9 */

                            curr_ptr = curr_ptr->next_mol;
                        } /* while curr_ptr */

                        neighbor_ptr = neighbor_ptr->next_mol;
    80e0:	e58d4050 	str	r4, [sp, #80]	; 0x50
                        continue;
                    }

                    neighbor_ptr = BOX[X_NUM][Y_NUM][Z_NUM].list;

                    while (neighbor_ptr) {
    80e4:	0a000178 	beq	86cc <INTERF+0x1028>
    80e8:	e59f528c 	ldr	r5, [pc, #652]	; 837c <INTERF+0xcd8>
    80ec:	e5953000 	ldr	r3, [r5]
    80f0:	eafffde3 	b	7884 <INTERF+0x1e0>
                                    if (RS[K] < CUT2) {
                                        FF[K]= -QQ2/(RS[K]*sqrt(RS[K]))-REF2;
                                        LVIR = LVIR + FF[K]*RS[K];
                                    } /* if */
                                    if (RS[K+4] <= CUT2) {
                                        RL[K+4]=sqrt(RS[K+4]);
    80f4:	e1a00006 	mov	r0, r6
    80f8:	e1a01007 	mov	r1, r7
    80fc:	eb00896b 	bl	2a6b0 <sqrt>
    8100:	e1a02000 	mov	r2, r0
    8104:	e1a03001 	mov	r3, r1
                                        FF[K+4]=QQ/(RS[K+4]*RL[K+4])+REF1;
    8108:	e1a00006 	mov	r0, r6
                                    if (RS[K] < CUT2) {
                                        FF[K]= -QQ2/(RS[K]*sqrt(RS[K]))-REF2;
                                        LVIR = LVIR + FF[K]*RS[K];
                                    } /* if */
                                    if (RS[K+4] <= CUT2) {
                                        RL[K+4]=sqrt(RS[K+4]);
    810c:	e1cb22f8 	strd	r2, [fp, #40]	; 0x28
                                        FF[K+4]=QQ/(RS[K+4]*RL[K+4])+REF1;
    8110:	e1a01007 	mov	r1, r7
    8114:	eb003279 	bl	14b00 <__aeabi_dmul>
    8118:	e59fe204 	ldr	lr, [pc, #516]	; 8324 <INTERF+0xc80>
    811c:	e59f4204 	ldr	r4, [pc, #516]	; 8328 <INTERF+0xc84>
    8120:	e1a02000 	mov	r2, r0
    8124:	e1a03001 	mov	r3, r1
    8128:	e1ce00d0 	ldrd	r0, [lr]
    812c:	eb003317 	bl	14d90 <__aeabi_ddiv>
    8130:	e1c420d0 	ldrd	r2, [r4]
    8134:	eb00316d 	bl	146f0 <__adddf3>
    8138:	e1a04000 	mov	r4, r0
    813c:	e1a05001 	mov	r5, r1
                                        LVIR = LVIR + FF[K+4]*RS[K+4];
    8140:	e1a02004 	mov	r2, r4
    8144:	e1a03005 	mov	r3, r5
    8148:	e1a00006 	mov	r0, r6
    814c:	e1a01007 	mov	r1, r7
                                        FF[K]= -QQ2/(RS[K]*sqrt(RS[K]))-REF2;
                                        LVIR = LVIR + FF[K]*RS[K];
                                    } /* if */
                                    if (RS[K+4] <= CUT2) {
                                        RL[K+4]=sqrt(RS[K+4]);
                                        FF[K+4]=QQ/(RS[K+4]*RL[K+4])+REF1;
    8150:	e1ca42f8 	strd	r4, [sl, #40]	; 0x28
                                        LVIR = LVIR + FF[K+4]*RS[K+4];
    8154:	eb003269 	bl	14b00 <__aeabi_dmul>
    8158:	e1a02000 	mov	r2, r0
    815c:	e1a03001 	mov	r3, r1
    8160:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    8164:	eb003161 	bl	146f0 <__adddf3>
    8168:	e1cd04f8 	strd	r0, [sp, #72]	; 0x48
    816c:	eaffffc0 	b	8074 <INTERF+0x9d0>
                                } /* if */


                                for (K = 1; K < 5; K++) {
                                    if (RS[K] < CUT2) {
                                        FF[K]= -QQ2/(RS[K]*sqrt(RS[K]))-REF2;
    8170:	e59fe1b4 	ldr	lr, [pc, #436]	; 832c <INTERF+0xc88>
    8174:	e1a00006 	mov	r0, r6
    8178:	e1a01007 	mov	r1, r7
    817c:	e59e5000 	ldr	r5, [lr]
    8180:	e59e4004 	ldr	r4, [lr, #4]
    8184:	eb008949 	bl	2a6b0 <sqrt>
    8188:	e1a02000 	mov	r2, r0
    818c:	e1a03001 	mov	r3, r1
    8190:	e1a00006 	mov	r0, r6
    8194:	e1a01007 	mov	r1, r7
    8198:	eb003258 	bl	14b00 <__aeabi_dmul>
    819c:	e2844102 	add	r4, r4, #-2147483648	; 0x80000000
    81a0:	e1a03001 	mov	r3, r1
    81a4:	e1a01004 	mov	r1, r4
    81a8:	e59f4180 	ldr	r4, [pc, #384]	; 8330 <INTERF+0xc8c>
    81ac:	e1a02000 	mov	r2, r0
    81b0:	e1a00005 	mov	r0, r5
    81b4:	eb0032f5 	bl	14d90 <__aeabi_ddiv>
    81b8:	e1c420d0 	ldrd	r2, [r4]
    81bc:	eb00314a 	bl	146ec <__aeabi_dsub>
    81c0:	e1a04000 	mov	r4, r0
    81c4:	e1a05001 	mov	r5, r1
                                        LVIR = LVIR + FF[K]*RS[K];
    81c8:	e1a02004 	mov	r2, r4
    81cc:	e1a03005 	mov	r3, r5
                                } /* if */


                                for (K = 1; K < 5; K++) {
                                    if (RS[K] < CUT2) {
                                        FF[K]= -QQ2/(RS[K]*sqrt(RS[K]))-REF2;
    81d0:	e1ca40f8 	strd	r4, [sl, #8]
                                        LVIR = LVIR + FF[K]*RS[K];
    81d4:	e1a00006 	mov	r0, r6
    81d8:	e1a01007 	mov	r1, r7
    81dc:	eb003247 	bl	14b00 <__aeabi_dmul>
    81e0:	e1a02000 	mov	r2, r0
    81e4:	e1a03001 	mov	r3, r1
    81e8:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    81ec:	eb00313f 	bl	146f0 <__adddf3>
    81f0:	e59fc0a0 	ldr	ip, [pc, #160]	; 8298 <INTERF+0xbf4>
    81f4:	e1cd04f8 	strd	r0, [sp, #72]	; 0x48
    81f8:	e1cc40d0 	ldrd	r4, [ip]
    81fc:	eaffff94 	b	8054 <INTERF+0x9b0>

                            if (KC != 9) {
                                for (K = 0; K < 14; K++)
                                    FF[K]=0.0;
                                if (RS[0] < CUT2) {
                                    FF[0]=QQ4/(RS[0]*sqrt(RS[0]))+REF4;
    8200:	e59f312c 	ldr	r3, [pc, #300]	; 8334 <INTERF+0xc90>
    8204:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    8208:	e1c340d0 	ldrd	r4, [r3]
    820c:	eb008927 	bl	2a6b0 <sqrt>
    8210:	e1a02000 	mov	r2, r0
    8214:	e1a03001 	mov	r3, r1
    8218:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    821c:	eb003237 	bl	14b00 <__aeabi_dmul>
    8220:	e1a02000 	mov	r2, r0
    8224:	e1a03001 	mov	r3, r1
    8228:	e1a00004 	mov	r0, r4
    822c:	e1a01005 	mov	r1, r5
    8230:	eb0032d6 	bl	14d90 <__aeabi_ddiv>
    8234:	e59f30fc 	ldr	r3, [pc, #252]	; 8338 <INTERF+0xc94>
    8238:	e1c320d0 	ldrd	r2, [r3]
    823c:	eb00312b 	bl	146f0 <__adddf3>
    8240:	e1a04000 	mov	r4, r0
    8244:	e1a05001 	mov	r5, r1
                                    LVIR = LVIR + FF[0]*RS[0];
    8248:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40

                            if (KC != 9) {
                                for (K = 0; K < 14; K++)
                                    FF[K]=0.0;
                                if (RS[0] < CUT2) {
                                    FF[0]=QQ4/(RS[0]*sqrt(RS[0]))+REF4;
    824c:	e28dcc02 	add	ip, sp, #512	; 0x200
    8250:	e1cc4af0 	strd	r4, [ip, #160]	; 0xa0
                                    LVIR = LVIR + FF[0]*RS[0];
    8254:	e1a02004 	mov	r2, r4
    8258:	e1a03005 	mov	r3, r5
    825c:	eb003227 	bl	14b00 <__aeabi_dmul>
    8260:	e1a02000 	mov	r2, r0
    8264:	e1a03001 	mov	r3, r1
    8268:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    826c:	eb00311f 	bl	146f0 <__adddf3>
    8270:	e59f5020 	ldr	r5, [pc, #32]	; 8298 <INTERF+0xbf4>
    8274:	e1cd04f8 	strd	r0, [sp, #72]	; 0x48
    8278:	e1c540d0 	ldrd	r4, [r5]
    827c:	e1cd43f8 	strd	r4, [sp, #56]	; 0x38
    8280:	eaffff5f 	b	8004 <INTERF+0x960>
    8284:	0013ea50 	.word	0x0013ea50
    8288:	0013ea58 	.word	0x0013ea58
    828c:	0013efe0 	.word	0x0013efe0
    8290:	fffffda8 	.word	0xfffffda8
    8294:	fffffd30 	.word	0xfffffd30
    8298:	0013efb0 	.word	0x0013efb0
    829c:	fffffe20 	.word	0xfffffe20
    82a0:	fffffe98 	.word	0xfffffe98
    82a4:	fffffdb0 	.word	0xfffffdb0
    82a8:	fffffd38 	.word	0xfffffd38
    82ac:	fffffe28 	.word	0xfffffe28
    82b0:	fffffea0 	.word	0xfffffea0
    82b4:	fffffdb8 	.word	0xfffffdb8
    82b8:	fffffd40 	.word	0xfffffd40
    82bc:	fffffe30 	.word	0xfffffe30
    82c0:	fffffea8 	.word	0xfffffea8
    82c4:	fffffdc0 	.word	0xfffffdc0
    82c8:	fffffd48 	.word	0xfffffd48
    82cc:	fffffe38 	.word	0xfffffe38
    82d0:	fffffeb0 	.word	0xfffffeb0
    82d4:	fffffdc8 	.word	0xfffffdc8
    82d8:	fffffd50 	.word	0xfffffd50
    82dc:	fffffe40 	.word	0xfffffe40
    82e0:	fffffeb8 	.word	0xfffffeb8
    82e4:	fffffdd0 	.word	0xfffffdd0
    82e8:	fffffd58 	.word	0xfffffd58
    82ec:	fffffe48 	.word	0xfffffe48
    82f0:	fffffec0 	.word	0xfffffec0
    82f4:	fffffdd8 	.word	0xfffffdd8
    82f8:	fffffd60 	.word	0xfffffd60
    82fc:	fffffe50 	.word	0xfffffe50
    8300:	fffffec8 	.word	0xfffffec8
    8304:	fffffde0 	.word	0xfffffde0
    8308:	fffffd68 	.word	0xfffffd68
    830c:	fffffe58 	.word	0xfffffe58
    8310:	fffffed0 	.word	0xfffffed0
    8314:	fffffde8 	.word	0xfffffde8
    8318:	fffffd70 	.word	0xfffffd70
    831c:	fffffe60 	.word	0xfffffe60
    8320:	fffffed8 	.word	0xfffffed8
    8324:	0013f448 	.word	0x0013f448
    8328:	0013f520 	.word	0x0013f520
    832c:	0013eee0 	.word	0x0013eee0
    8330:	0013f010 	.word	0x0013f010
    8334:	0013f538 	.word	0x0013f538
    8338:	0013f438 	.word	0x0013f438
    833c:	fffffdf0 	.word	0xfffffdf0
    8340:	fffffd78 	.word	0xfffffd78
    8344:	fffffe68 	.word	0xfffffe68
    8348:	fffffee0 	.word	0xfffffee0
    834c:	0013f4f8 	.word	0x0013f4f8
    8350:	0013ea88 	.word	0x0013ea88
    8354:	0013f0a0 	.word	0x0013f0a0
    8358:	0013f550 	.word	0x0013f550
    835c:	0013f560 	.word	0x0013f560
    8360:	0013f3e8 	.word	0x0013f3e8
    8364:	0013f430 	.word	0x0013f430
    8368:	0013ef48 	.word	0x0013ef48
    836c:	0013f3f0 	.word	0x0013f3f0
    8370:	3fe00000 	.word	0x3fe00000
    8374:	0013eec0 	.word	0x0013eec0
    8378:	0013efcc 	.word	0x0013efcc
    837c:	0013f098 	.word	0x0013f098
    8380:	0013f558 	.word	0x0013f558
    8384:	0013eed0 	.word	0x0013eed0
    8388:	0003285c 	.word	0x0003285c
                                        LVIR = LVIR + FF[K+4]*RS[K+4];
                                    } /* if */
                                } /* for K */

                                if (KC == 0) {
                                    RS[9]=XL[9]*XL[9]+YL[9]*YL[9]+ZL[9]*ZL[9];
    838c:	e51f2058 	ldr	r2, [pc, #-88]	; 833c <INTERF+0xc98>
    8390:	e51f3058 	ldr	r3, [pc, #-88]	; 8340 <INTERF+0xc9c>
    8394:	e28dce39 	add	ip, sp, #912	; 0x390
    8398:	e18c60d3 	ldrd	r6, [ip, r3]
    839c:	e18c00d2 	ldrd	r0, [ip, r2]
    83a0:	e51fc064 	ldr	ip, [pc, #-100]	; 8344 <INTERF+0xca0>
    83a4:	e28dee39 	add	lr, sp, #912	; 0x390
    83a8:	e1a02000 	mov	r2, r0
    83ac:	e18e80dc 	ldrd	r8, [lr, ip]
    83b0:	e1a03001 	mov	r3, r1
    83b4:	eb0031d1 	bl	14b00 <__aeabi_dmul>
    83b8:	e1a02006 	mov	r2, r6
    83bc:	e1a04000 	mov	r4, r0
    83c0:	e1a05001 	mov	r5, r1
    83c4:	e1a03007 	mov	r3, r7
    83c8:	e1a00006 	mov	r0, r6
    83cc:	e1a01007 	mov	r1, r7
    83d0:	eb0031ca 	bl	14b00 <__aeabi_dmul>
    83d4:	e1a02000 	mov	r2, r0
    83d8:	e1a03001 	mov	r3, r1
    83dc:	e1a00004 	mov	r0, r4
    83e0:	e1a01005 	mov	r1, r5
    83e4:	eb0030c1 	bl	146f0 <__adddf3>
    83e8:	e1a02008 	mov	r2, r8
    83ec:	e1a04000 	mov	r4, r0
    83f0:	e1a05001 	mov	r5, r1
    83f4:	e1a03009 	mov	r3, r9
    83f8:	e1a00008 	mov	r0, r8
    83fc:	e1a01009 	mov	r1, r9
    8400:	eb0031be 	bl	14b00 <__aeabi_dmul>
    8404:	e1a02000 	mov	r2, r0
    8408:	e1a03001 	mov	r3, r1
    840c:	e1a00004 	mov	r0, r4
    8410:	e1a01005 	mov	r1, r5
    8414:	eb0030b5 	bl	146f0 <__adddf3>
    8418:	e1a06000 	mov	r6, r0
    841c:	e1a07001 	mov	r7, r1
    8420:	e51f30e0 	ldr	r3, [pc, #-224]	; 8348 <INTERF+0xca4>
    8424:	e28d2e39 	add	r2, sp, #912	; 0x390
    8428:	e18260f3 	strd	r6, [r2, r3]
                                    RL[9]=sqrt(RS[9]);
    842c:	eb00889f 	bl	2a6b0 <sqrt>
    8430:	e1a04000 	mov	r4, r0
    8434:	e1a05001 	mov	r5, r1
                                    FF[9]=AB1*exp(-B1*RL[9])/RL[9];
    8438:	e51fc0f4 	ldr	ip, [pc, #-244]	; 834c <INTERF+0xca8>
                                    } /* if */
                                } /* for K */

                                if (KC == 0) {
                                    RS[9]=XL[9]*XL[9]+YL[9]*YL[9]+ZL[9]*ZL[9];
                                    RL[9]=sqrt(RS[9]);
    843c:	e28deb01 	add	lr, sp, #1024	; 0x400
    8440:	e14e4af0 	strd	r4, [lr, #-160]	; 0xffffff60
                                    FF[9]=AB1*exp(-B1*RL[9])/RL[9];
    8444:	e89c1004 	ldm	ip, {r2, ip}
    8448:	e28c3102 	add	r3, ip, #-2147483648	; 0x80000000
    844c:	eb0031ab 	bl	14b00 <__aeabi_dmul>
    8450:	eb0085d4 	bl	29ba8 <exp>
    8454:	e51f310c 	ldr	r3, [pc, #-268]	; 8350 <INTERF+0xcac>
                                    LVIR = LVIR + FF[9]*RS[9];
                                    for (K = 10; K < 14; K++) {
    8458:	e3a0a00a 	mov	sl, #10
                                } /* for K */

                                if (KC == 0) {
                                    RS[9]=XL[9]*XL[9]+YL[9]*YL[9]+ZL[9]*ZL[9];
                                    RL[9]=sqrt(RS[9]);
                                    FF[9]=AB1*exp(-B1*RL[9])/RL[9];
    845c:	e1c320d0 	ldrd	r2, [r3]
    8460:	eb0031a6 	bl	14b00 <__aeabi_dmul>
    8464:	e1a02004 	mov	r2, r4
    8468:	e1a03005 	mov	r3, r5
    846c:	eb003247 	bl	14d90 <__aeabi_ddiv>
    8470:	e1a04000 	mov	r4, r0
    8474:	e1a05001 	mov	r5, r1
    8478:	e28dcc02 	add	ip, sp, #512	; 0x200
    847c:	e1cc4ef8 	strd	r4, [ip, #232]	; 0xe8
                                    LVIR = LVIR + FF[9]*RS[9];
    8480:	e1a00006 	mov	r0, r6
    8484:	e1a01007 	mov	r1, r7
    8488:	e1a02004 	mov	r2, r4
    848c:	e1a03005 	mov	r3, r5
    8490:	eb00319a 	bl	14b00 <__aeabi_dmul>
    8494:	e1cd24d8 	ldrd	r2, [sp, #72]	; 0x48
    8498:	eb003094 	bl	146f0 <__adddf3>
    849c:	e1a06000 	mov	r6, r0
    84a0:	e1a07001 	mov	r7, r1
    84a4:	e1cd04f8 	strd	r0, [sp, #72]	; 0x48
    84a8:	e58da038 	str	sl, [sp, #56]	; 0x38
    84ac:	e58db054 	str	fp, [sp, #84]	; 0x54
    84b0:	e51fc164 	ldr	ip, [pc, #-356]	; 8354 <INTERF+0xcb0>
    84b4:	e59db058 	ldr	fp, [sp, #88]	; 0x58
    84b8:	e59da060 	ldr	sl, [sp, #96]	; 0x60
                                    for (K = 10; K < 14; K++) {
                                        FTEMP=AB2*exp(-B2*RL[K-5])/RL[K-5];
    84bc:	e89c4001 	ldm	ip, {r0, lr}
    84c0:	e1cb22d8 	ldrd	r2, [fp, #40]	; 0x28
    84c4:	e28e1102 	add	r1, lr, #-2147483648	; 0x80000000
    84c8:	e58dc024 	str	ip, [sp, #36]	; 0x24
    84cc:	eb00318b 	bl	14b00 <__aeabi_dmul>
    84d0:	eb0085b4 	bl	29ba8 <exp>
    84d4:	e51fe184 	ldr	lr, [pc, #-388]	; 8358 <INTERF+0xcb4>
    84d8:	e28bb008 	add	fp, fp, #8
    84dc:	e1ce20d0 	ldrd	r2, [lr]
    84e0:	eb003186 	bl	14b00 <__aeabi_dmul>
    84e4:	e1cb22d0 	ldrd	r2, [fp, #32]
    84e8:	eb003228 	bl	14d90 <__aeabi_ddiv>
    84ec:	e1a04000 	mov	r4, r0
    84f0:	e1a05001 	mov	r5, r1
                                        FF[K-5]=FF[K-5]+FTEMP;
    84f4:	e1ca02d8 	ldrd	r0, [sl, #40]	; 0x28
    84f8:	e1a02004 	mov	r2, r4
    84fc:	e1a03005 	mov	r3, r5
    8500:	eb00307a 	bl	146f0 <__adddf3>
                                        LVIR= LVIR+FTEMP*RS[K-5];
    8504:	e59de040 	ldr	lr, [sp, #64]	; 0x40
                                    RL[9]=sqrt(RS[9]);
                                    FF[9]=AB1*exp(-B1*RL[9])/RL[9];
                                    LVIR = LVIR + FF[9]*RS[9];
                                    for (K = 10; K < 14; K++) {
                                        FTEMP=AB2*exp(-B2*RL[K-5])/RL[K-5];
                                        FF[K-5]=FF[K-5]+FTEMP;
    8508:	e1ca02f8 	strd	r0, [sl, #40]	; 0x28
                                        LVIR= LVIR+FTEMP*RS[K-5];
    850c:	e1ce22d8 	ldrd	r2, [lr, #40]	; 0x28
    8510:	e1a00004 	mov	r0, r4
    8514:	e1a01005 	mov	r1, r5
    8518:	eb003178 	bl	14b00 <__aeabi_dmul>
    851c:	e1a02006 	mov	r2, r6
    8520:	e1a03007 	mov	r3, r7
    8524:	eb003071 	bl	146f0 <__adddf3>
    8528:	e59d4038 	ldr	r4, [sp, #56]	; 0x38
                                        RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    852c:	e28de0c0 	add	lr, sp, #192	; 0xc0
    8530:	e1a03184 	lsl	r3, r4, #3
    8534:	e28d5f4e 	add	r5, sp, #312	; 0x138
    8538:	e28d2e1b 	add	r2, sp, #432	; 0x1b0
    853c:	e18e60d3 	ldrd	r6, [lr, r3]
    8540:	e18280d3 	ldrd	r8, [r2, r3]
                                    FF[9]=AB1*exp(-B1*RL[9])/RL[9];
                                    LVIR = LVIR + FF[9]*RS[9];
                                    for (K = 10; K < 14; K++) {
                                        FTEMP=AB2*exp(-B2*RL[K-5])/RL[K-5];
                                        FF[K-5]=FF[K-5]+FTEMP;
                                        LVIR= LVIR+FTEMP*RS[K-5];
    8544:	e1cd04f8 	strd	r0, [sp, #72]	; 0x48
                                        RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    8548:	e18500d3 	ldrd	r0, [r5, r3]
    854c:	e1a02000 	mov	r2, r0
    8550:	e1a03001 	mov	r3, r1
    8554:	eb003169 	bl	14b00 <__aeabi_dmul>
    8558:	e1a02006 	mov	r2, r6
    855c:	e1a04000 	mov	r4, r0
    8560:	e1a05001 	mov	r5, r1
    8564:	e1a03007 	mov	r3, r7
    8568:	e1a00006 	mov	r0, r6
    856c:	e1a01007 	mov	r1, r7
    8570:	eb003162 	bl	14b00 <__aeabi_dmul>
    8574:	e1a02000 	mov	r2, r0
    8578:	e1a03001 	mov	r3, r1
    857c:	e1a00004 	mov	r0, r4
    8580:	e1a01005 	mov	r1, r5
    8584:	eb003059 	bl	146f0 <__adddf3>
    8588:	e1a02008 	mov	r2, r8
    858c:	e1a04000 	mov	r4, r0
    8590:	e1a05001 	mov	r5, r1
    8594:	e1a03009 	mov	r3, r9
    8598:	e1a00008 	mov	r0, r8
    859c:	e1a01009 	mov	r1, r9
    85a0:	eb003156 	bl	14b00 <__aeabi_dmul>
    85a4:	e1a02000 	mov	r2, r0
    85a8:	e1a03001 	mov	r3, r1
    85ac:	e1a00004 	mov	r0, r4
    85b0:	e1a01005 	mov	r1, r5
    85b4:	eb00304d 	bl	146f0 <__adddf3>
    85b8:	e1a08000 	mov	r8, r0
    85bc:	e1a09001 	mov	r9, r1
    85c0:	e59d4040 	ldr	r4, [sp, #64]	; 0x40
                                        RL[K]=sqrt(RS[K]);
                                        FF[K]=(AB3*exp(-B3*RL[K])-AB4*exp(-B4*RL[K]))/RL[K];
    85c4:	e51f5270 	ldr	r5, [pc, #-624]	; 835c <INTERF+0xcb8>
                                    LVIR = LVIR + FF[9]*RS[9];
                                    for (K = 10; K < 14; K++) {
                                        FTEMP=AB2*exp(-B2*RL[K-5])/RL[K-5];
                                        FF[K-5]=FF[K-5]+FTEMP;
                                        LVIR= LVIR+FTEMP*RS[K-5];
                                        RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    85c8:	e1c485f0 	strd	r8, [r4, #80]	; 0x50
                                        RL[K]=sqrt(RS[K]);
    85cc:	eb008837 	bl	2a6b0 <sqrt>
                                        FF[K]=(AB3*exp(-B3*RL[K])-AB4*exp(-B4*RL[K]))/RL[K];
    85d0:	e8954004 	ldm	r5, {r2, lr}
                                    for (K = 10; K < 14; K++) {
                                        FTEMP=AB2*exp(-B2*RL[K-5])/RL[K-5];
                                        FF[K-5]=FF[K-5]+FTEMP;
                                        LVIR= LVIR+FTEMP*RS[K-5];
                                        RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
                                        RL[K]=sqrt(RS[K]);
    85d4:	e1a06000 	mov	r6, r0
    85d8:	e1a07001 	mov	r7, r1
                                        FF[K]=(AB3*exp(-B3*RL[K])-AB4*exp(-B4*RL[K]))/RL[K];
    85dc:	e28e3102 	add	r3, lr, #-2147483648	; 0x80000000
                                    for (K = 10; K < 14; K++) {
                                        FTEMP=AB2*exp(-B2*RL[K-5])/RL[K-5];
                                        FF[K-5]=FF[K-5]+FTEMP;
                                        LVIR= LVIR+FTEMP*RS[K-5];
                                        RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
                                        RL[K]=sqrt(RS[K]);
    85e0:	e1cb64f8 	strd	r6, [fp, #72]	; 0x48
                                        FF[K]=(AB3*exp(-B3*RL[K])-AB4*exp(-B4*RL[K]))/RL[K];
    85e4:	eb003145 	bl	14b00 <__aeabi_dmul>
    85e8:	eb00856e 	bl	29ba8 <exp>
    85ec:	e51fe294 	ldr	lr, [pc, #-660]	; 8360 <INTERF+0xcbc>
    85f0:	e28aa008 	add	sl, sl, #8
    85f4:	e1ce20d0 	ldrd	r2, [lr]
    85f8:	eb003140 	bl	14b00 <__aeabi_dmul>
    85fc:	e1a04000 	mov	r4, r0
    8600:	e51f02a4 	ldr	r0, [pc, #-676]	; 8364 <INTERF+0xcc0>
    8604:	e1a05001 	mov	r5, r1
                                if (KC == 0) {
                                    RS[9]=XL[9]*XL[9]+YL[9]*YL[9]+ZL[9]*ZL[9];
                                    RL[9]=sqrt(RS[9]);
                                    FF[9]=AB1*exp(-B1*RL[9])/RL[9];
                                    LVIR = LVIR + FF[9]*RS[9];
                                    for (K = 10; K < 14; K++) {
    8608:	e59de038 	ldr	lr, [sp, #56]	; 0x38
                                        FTEMP=AB2*exp(-B2*RL[K-5])/RL[K-5];
                                        FF[K-5]=FF[K-5]+FTEMP;
                                        LVIR= LVIR+FTEMP*RS[K-5];
                                        RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
                                        RL[K]=sqrt(RS[K]);
                                        FF[K]=(AB3*exp(-B3*RL[K])-AB4*exp(-B4*RL[K]))/RL[K];
    860c:	e5901004 	ldr	r1, [r0, #4]
    8610:	e5902000 	ldr	r2, [r0]
                                if (KC == 0) {
                                    RS[9]=XL[9]*XL[9]+YL[9]*YL[9]+ZL[9]*ZL[9];
                                    RL[9]=sqrt(RS[9]);
                                    FF[9]=AB1*exp(-B1*RL[9])/RL[9];
                                    LVIR = LVIR + FF[9]*RS[9];
                                    for (K = 10; K < 14; K++) {
    8614:	e28ee001 	add	lr, lr, #1
                                        FTEMP=AB2*exp(-B2*RL[K-5])/RL[K-5];
                                        FF[K-5]=FF[K-5]+FTEMP;
                                        LVIR= LVIR+FTEMP*RS[K-5];
                                        RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
                                        RL[K]=sqrt(RS[K]);
                                        FF[K]=(AB3*exp(-B3*RL[K])-AB4*exp(-B4*RL[K]))/RL[K];
    8618:	e2813102 	add	r3, r1, #-2147483648	; 0x80000000
    861c:	e1a00006 	mov	r0, r6
    8620:	e1a01007 	mov	r1, r7
                                if (KC == 0) {
                                    RS[9]=XL[9]*XL[9]+YL[9]*YL[9]+ZL[9]*ZL[9];
                                    RL[9]=sqrt(RS[9]);
                                    FF[9]=AB1*exp(-B1*RL[9])/RL[9];
                                    LVIR = LVIR + FF[9]*RS[9];
                                    for (K = 10; K < 14; K++) {
    8624:	e58de038 	str	lr, [sp, #56]	; 0x38
                                        FTEMP=AB2*exp(-B2*RL[K-5])/RL[K-5];
                                        FF[K-5]=FF[K-5]+FTEMP;
                                        LVIR= LVIR+FTEMP*RS[K-5];
                                        RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
                                        RL[K]=sqrt(RS[K]);
                                        FF[K]=(AB3*exp(-B3*RL[K])-AB4*exp(-B4*RL[K]))/RL[K];
    8628:	eb003134 	bl	14b00 <__aeabi_dmul>
    862c:	eb00855d 	bl	29ba8 <exp>
    8630:	e51fe2d0 	ldr	lr, [pc, #-720]	; 8368 <INTERF+0xcc4>
    8634:	e1ce20d0 	ldrd	r2, [lr]
    8638:	eb003130 	bl	14b00 <__aeabi_dmul>
    863c:	e1a02000 	mov	r2, r0
    8640:	e1a03001 	mov	r3, r1
    8644:	e1a00004 	mov	r0, r4
    8648:	e1a01005 	mov	r1, r5
    864c:	eb003026 	bl	146ec <__aeabi_dsub>
    8650:	e1a02006 	mov	r2, r6
    8654:	e1a03007 	mov	r3, r7
    8658:	eb0031cc 	bl	14d90 <__aeabi_ddiv>
    865c:	e1a04000 	mov	r4, r0
    8660:	e1a05001 	mov	r5, r1
                                        LVIR = LVIR + FF[K]*RS[K];
    8664:	e1a02004 	mov	r2, r4
                                        FTEMP=AB2*exp(-B2*RL[K-5])/RL[K-5];
                                        FF[K-5]=FF[K-5]+FTEMP;
                                        LVIR= LVIR+FTEMP*RS[K-5];
                                        RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
                                        RL[K]=sqrt(RS[K]);
                                        FF[K]=(AB3*exp(-B3*RL[K])-AB4*exp(-B4*RL[K]))/RL[K];
    8668:	e1ca44f8 	strd	r4, [sl, #72]	; 0x48
                                        LVIR = LVIR + FF[K]*RS[K];
    866c:	e1a03005 	mov	r3, r5
    8670:	e1a00008 	mov	r0, r8
    8674:	e1a01009 	mov	r1, r9
    8678:	eb003120 	bl	14b00 <__aeabi_dmul>
    867c:	e1cd24d8 	ldrd	r2, [sp, #72]	; 0x48
    8680:	eb00301a 	bl	146f0 <__adddf3>
    8684:	e59d5040 	ldr	r5, [sp, #64]	; 0x40
                                if (KC == 0) {
                                    RS[9]=XL[9]*XL[9]+YL[9]*YL[9]+ZL[9]*ZL[9];
                                    RL[9]=sqrt(RS[9]);
                                    FF[9]=AB1*exp(-B1*RL[9])/RL[9];
                                    LVIR = LVIR + FF[9]*RS[9];
                                    for (K = 10; K < 14; K++) {
    8688:	e59d4038 	ldr	r4, [sp, #56]	; 0x38
    868c:	e2855008 	add	r5, r5, #8
    8690:	e354000e 	cmp	r4, #14
                                        FF[K-5]=FF[K-5]+FTEMP;
                                        LVIR= LVIR+FTEMP*RS[K-5];
                                        RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
                                        RL[K]=sqrt(RS[K]);
                                        FF[K]=(AB3*exp(-B3*RL[K])-AB4*exp(-B4*RL[K]))/RL[K];
                                        LVIR = LVIR + FF[K]*RS[K];
    8694:	e1a06000 	mov	r6, r0
    8698:	e1a07001 	mov	r7, r1
    869c:	e58d5040 	str	r5, [sp, #64]	; 0x40
                                if (KC == 0) {
                                    RS[9]=XL[9]*XL[9]+YL[9]*YL[9]+ZL[9]*ZL[9];
                                    RL[9]=sqrt(RS[9]);
                                    FF[9]=AB1*exp(-B1*RL[9])/RL[9];
                                    LVIR = LVIR + FF[9]*RS[9];
                                    for (K = 10; K < 14; K++) {
    86a0:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    86a4:	1affff84 	bne	84bc <INTERF+0xe18>
    86a8:	e1cd64f8 	strd	r6, [sp, #72]	; 0x48
    86ac:	e59db054 	ldr	fp, [sp, #84]	; 0x54
    86b0:	eafffe7b 	b	80a4 <INTERF+0xa00>
                    else if (Z_NUM >= BOX_PER_SIDE)
                        Z_NUM -= BOX_PER_SIDE;

                    /* Don't do current box more than once */

                    if ((X_NUM == i) && (Y_NUM == j) && (Z_NUM == k) &&
    86b4:	e59dc0b4 	ldr	ip, [sp, #180]	; 0xb4
    86b8:	e35c0000 	cmp	ip, #0
    86bc:	1a000002 	bne	86cc <INTERF+0x1028>
                        ((XBOX != i) || (YBOX != j) || (ZBOX !=k))) {
    86c0:	e59d4068 	ldr	r4, [sp, #104]	; 0x68
    86c4:	e1540002 	cmp	r4, r2
    86c8:	0afffc65 	beq	7864 <INTERF+0x1c0>

        /* loop over nearest neighbor boxes */

        for (XBOX=i-1; XBOX<=i+1; XBOX++) {
            for (YBOX=j-1; YBOX<=j+1; YBOX++) {
                for (ZBOX=k-1; ZBOX<=k+1; ZBOX++) {
    86cc:	e59dc068 	ldr	ip, [sp, #104]	; 0x68
    86d0:	e59d4090 	ldr	r4, [sp, #144]	; 0x90
    86d4:	e28cc001 	add	ip, ip, #1
    86d8:	e15c0004 	cmp	ip, r4
    86dc:	e58dc068 	str	ip, [sp, #104]	; 0x68
    86e0:	dafffc3d 	ble	77dc <INTERF+0x138>
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        /* loop over nearest neighbor boxes */

        for (XBOX=i-1; XBOX<=i+1; XBOX++) {
            for (YBOX=j-1; YBOX<=j+1; YBOX++) {
    86e4:	e59d507c 	ldr	r5, [sp, #124]	; 0x7c
    86e8:	e59dc09c 	ldr	ip, [sp, #156]	; 0x9c
    86ec:	e2855001 	add	r5, r5, #1
    86f0:	e155000c 	cmp	r5, ip
    86f4:	e58d507c 	str	r5, [sp, #124]	; 0x7c
    86f8:	dafffc24 	ble	7790 <INTERF+0xec>
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        /* loop over nearest neighbor boxes */

        for (XBOX=i-1; XBOX<=i+1; XBOX++) {
    86fc:	e59d4078 	ldr	r4, [sp, #120]	; 0x78
    8700:	e59d5094 	ldr	r5, [sp, #148]	; 0x94
    8704:	e2844001 	add	r4, r4, #1
    8708:	e1540005 	cmp	r4, r5
    870c:	e58d4078 	str	r4, [sp, #120]	; 0x78
    8710:	dafffc14 	ble	7768 <INTERF+0xc4>

                }
            }
        }  /* neighbor boxes' for loops */

        curr_box = curr_box->next_box;
    8714:	e59dc080 	ldr	ip, [sp, #128]	; 0x80
    8718:	e59cc00c 	ldr	ip, [ip, #12]
    struct link *curr_ptr, *neighbor_ptr;
    struct list_of_boxes *curr_box;
    double *temp_p;

    curr_box = my_boxes[ProcID];
    while (curr_box) {
    871c:	e35c0000 	cmp	ip, #0

                }
            }
        }  /* neighbor boxes' for loops */

        curr_box = curr_box->next_box;
    8720:	e58dc080 	str	ip, [sp, #128]	; 0x80
    struct link *curr_ptr, *neighbor_ptr;
    struct list_of_boxes *curr_box;
    double *temp_p;

    curr_box = my_boxes[ProcID];
    while (curr_box) {
    8724:	1afffbed 	bne	76e0 <INTERF+0x3c>
        curr_box = curr_box->next_box;
    }  /* while mybox */

    /*  accumulate running sum from private partial sums */

    LOCK(gl->InterfVirLock);
    8728:	e51f43c4 	ldr	r4, [pc, #-964]	; 836c <INTERF+0xcc8>
    872c:	e5940000 	ldr	r0, [r4]
    8730:	e2800024 	add	r0, r0, #36	; 0x24
    8734:	ebffe02e 	bl	7f4 <pthread_mutex_lock>
    *VIR = *VIR + LVIR/2.0;
    8738:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    873c:	e3a02000 	mov	r2, #0
    8740:	e51f33d8 	ldr	r3, [pc, #-984]	; 8370 <INTERF+0xccc>
    8744:	eb0030ed 	bl	14b00 <__aeabi_dmul>
    8748:	e59d50a4 	ldr	r5, [sp, #164]	; 0xa4
    874c:	e1a02000 	mov	r2, r0
    8750:	e1a03001 	mov	r3, r1
    8754:	e1c500d0 	ldrd	r0, [r5]
    8758:	eb002fe4 	bl	146f0 <__adddf3>
    UNLOCK(gl->InterfVirLock);
    875c:	e5943000 	ldr	r3, [r4]
    }  /* while mybox */

    /*  accumulate running sum from private partial sums */

    LOCK(gl->InterfVirLock);
    *VIR = *VIR + LVIR/2.0;
    8760:	e1c500f0 	strd	r0, [r5]
    UNLOCK(gl->InterfVirLock);
    8764:	e2830024 	add	r0, r3, #36	; 0x24
    8768:	ebffe2fb 	bl	135c <pthread_mutex_unlock>

    /* wait till all forces are updated */

    BARRIER(gl->InterfBar, NumProcs);
    876c:	e5940000 	ldr	r0, [r4]
    8770:	e2800064 	add	r0, r0, #100	; 0x64
    8774:	ebffe01e 	bl	7f4 <pthread_mutex_lock>
    8778:	e2501000 	subs	r1, r0, #0
    877c:	1a00007f 	bne	8980 <INTERF+0x12dc>
    8780:	e5943000 	ldr	r3, [r4]
    8784:	e51fc418 	ldr	ip, [pc, #-1048]	; 8374 <INTERF+0xcd0>
    8788:	e5932078 	ldr	r2, [r3, #120]	; 0x78
    878c:	e59cc000 	ldr	ip, [ip]
    8790:	e2822001 	add	r2, r2, #1
    8794:	e152000c 	cmp	r2, ip
    8798:	e5832078 	str	r2, [r3, #120]	; 0x78
    879c:	e593507c 	ldr	r5, [r3, #124]	; 0x7c
    87a0:	0a00007a 	beq	8990 <INTERF+0x12ec>
    87a4:	e28d10b8 	add	r1, sp, #184	; 0xb8
    87a8:	ebffe312 	bl	13f8 <pthread_setcancelstate>
    87ac:	e5941000 	ldr	r1, [r4]
    87b0:	e591307c 	ldr	r3, [r1, #124]	; 0x7c
    87b4:	e1530005 	cmp	r3, r5
    87b8:	1a000004 	bne	87d0 <INTERF+0x112c>
    87bc:	e2810070 	add	r0, r1, #112	; 0x70
    87c0:	e2811064 	add	r1, r1, #100	; 0x64
    87c4:	ebffe379 	bl	15b0 <pthread_cond_wait>
    87c8:	e3500000 	cmp	r0, #0
    87cc:	0afffff6 	beq	87ac <INTERF+0x1108>
    87d0:	e59d00b8 	ldr	r0, [sp, #184]	; 0xb8
    87d4:	e28d10bc 	add	r1, sp, #188	; 0xbc
    87d8:	ebffe306 	bl	13f8 <pthread_setcancelstate>
    87dc:	e5940000 	ldr	r0, [r4]
    87e0:	e2800064 	add	r0, r0, #100	; 0x64
    87e4:	ebffe2dc 	bl	135c <pthread_mutex_unlock>

    /* divide final forces by masses */

    curr_box = my_boxes[ProcID];
    87e8:	e51fc478 	ldr	ip, [pc, #-1144]	; 8378 <INTERF+0xcd4>
    87ec:	e59d40a8 	ldr	r4, [sp, #168]	; 0xa8
    87f0:	e59c3000 	ldr	r3, [ip]
    87f4:	e7938104 	ldr	r8, [r3, r4, lsl #2]
    while (curr_box) {
    87f8:	e3580000 	cmp	r8, #0
    87fc:	0a000050 	beq	8944 <INTERF+0x12a0>
    8800:	e59d5064 	ldr	r5, [sp, #100]	; 0x64
    8804:	e51f2490 	ldr	r2, [pc, #-1168]	; 837c <INTERF+0xcd8>
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
            for ( dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DEST][dir];
    8808:	e0853185 	add	r3, r5, r5, lsl #3
    880c:	e1a03183 	lsl	r3, r3, #3
    8810:	e285a001 	add	sl, r5, #1
    8814:	e08aa18a 	add	sl, sl, sl, lsl #3
    8818:	e283b018 	add	fp, r3, #24
    881c:	e592c000 	ldr	ip, [r2]
    8820:	e2833030 	add	r3, r3, #48	; 0x30
    8824:	e51f74ac 	ldr	r7, [pc, #-1196]	; 8380 <INTERF+0xcdc>
    8828:	e51f94ac 	ldr	r9, [pc, #-1196]	; 8384 <INTERF+0xce0>
    882c:	e1a0a18a 	lsl	sl, sl, #3
    8830:	e58d3038 	str	r3, [sp, #56]	; 0x38

        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        curr_ptr = BOX[i][j][k].list;
    8834:	e5983000 	ldr	r3, [r8]
    8838:	e5981004 	ldr	r1, [r8, #4]
    883c:	e79c3103 	ldr	r3, [ip, r3, lsl #2]
    8840:	e5982008 	ldr	r2, [r8, #8]
    8844:	e7933101 	ldr	r3, [r3, r1, lsl #2]
    8848:	e7936202 	ldr	r6, [r3, r2, lsl #4]
        while (curr_ptr) {
    884c:	e3560000 	cmp	r6, #0
    8850:	0a000038 	beq	8938 <INTERF+0x1294>
    8854:	e1c740d0 	ldrd	r4, [r7]
    8858:	e58d8050 	str	r8, [sp, #80]	; 0x50
            for ( dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DEST][dir];
                temp_p[H1] = temp_p[H1] * FHM;
    885c:	e18600db 	ldrd	r0, [r6, fp]
    8860:	e1a02004 	mov	r2, r4
    8864:	e1a03005 	mov	r3, r5
    8868:	e58dc024 	str	ip, [sp, #36]	; 0x24
    886c:	eb0030a3 	bl	14b00 <__aeabi_dmul>
    8870:	e18600fb 	strd	r0, [r6, fp]
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
            for ( dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DEST][dir];
    8874:	e086800b 	add	r8, r6, fp
                temp_p[H1] = temp_p[H1] * FHM;
                temp_p[O]  = temp_p[O] * FOM;
    8878:	e1c800d8 	ldrd	r0, [r8, #8]
    887c:	e1c920d0 	ldrd	r2, [r9]
    8880:	eb00309e 	bl	14b00 <__aeabi_dmul>
                temp_p[H2] = temp_p[H2] * FHM;
    8884:	e1c740d0 	ldrd	r4, [r7]
        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
            for ( dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DEST][dir];
                temp_p[H1] = temp_p[H1] * FHM;
                temp_p[O]  = temp_p[O] * FOM;
    8888:	e1c800f8 	strd	r0, [r8, #8]
                temp_p[H2] = temp_p[H2] * FHM;
    888c:	e1c801d0 	ldrd	r0, [r8, #16]
    8890:	e1a02004 	mov	r2, r4
    8894:	e1a03005 	mov	r3, r5
    8898:	eb003098 	bl	14b00 <__aeabi_dmul>
    889c:	e1c801f0 	strd	r0, [r8, #16]

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
            for ( dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DEST][dir];
                temp_p[H1] = temp_p[H1] * FHM;
    88a0:	e1a02004 	mov	r2, r4
    88a4:	e59d4038 	ldr	r4, [sp, #56]	; 0x38
    88a8:	e1a03005 	mov	r3, r5
    88ac:	e18600d4 	ldrd	r0, [r6, r4]
    88b0:	eb003092 	bl	14b00 <__aeabi_dmul>
    88b4:	e18600f4 	strd	r0, [r6, r4]
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
            for ( dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DEST][dir];
    88b8:	e0868004 	add	r8, r6, r4
                temp_p[H1] = temp_p[H1] * FHM;
                temp_p[O]  = temp_p[O] * FOM;
    88bc:	e1c800d8 	ldrd	r0, [r8, #8]
    88c0:	e1c920d0 	ldrd	r2, [r9]
    88c4:	eb00308d 	bl	14b00 <__aeabi_dmul>
                temp_p[H2] = temp_p[H2] * FHM;
    88c8:	e1c740d0 	ldrd	r4, [r7]
        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
            for ( dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DEST][dir];
                temp_p[H1] = temp_p[H1] * FHM;
                temp_p[O]  = temp_p[O] * FOM;
    88cc:	e1c800f8 	strd	r0, [r8, #8]
                temp_p[H2] = temp_p[H2] * FHM;
    88d0:	e1c801d0 	ldrd	r0, [r8, #16]
    88d4:	e1a02004 	mov	r2, r4
    88d8:	e1a03005 	mov	r3, r5
    88dc:	eb003087 	bl	14b00 <__aeabi_dmul>
    88e0:	e1c801f0 	strd	r0, [r8, #16]

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
            for ( dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DEST][dir];
                temp_p[H1] = temp_p[H1] * FHM;
    88e4:	e1a02004 	mov	r2, r4
    88e8:	e18600da 	ldrd	r0, [r6, sl]
    88ec:	e1a03005 	mov	r3, r5
    88f0:	eb003082 	bl	14b00 <__aeabi_dmul>
    88f4:	e18600fa 	strd	r0, [r6, sl]
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
            for ( dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DEST][dir];
    88f8:	e086800a 	add	r8, r6, sl
                temp_p[H1] = temp_p[H1] * FHM;
                temp_p[O]  = temp_p[O] * FOM;
    88fc:	e1c920d0 	ldrd	r2, [r9]
    8900:	e1c800d8 	ldrd	r0, [r8, #8]
    8904:	eb00307d 	bl	14b00 <__aeabi_dmul>
                temp_p[H2] = temp_p[H2] * FHM;
    8908:	e1c740d0 	ldrd	r4, [r7]
        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
            for ( dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DEST][dir];
                temp_p[H1] = temp_p[H1] * FHM;
                temp_p[O]  = temp_p[O] * FOM;
    890c:	e1c800f8 	strd	r0, [r8, #8]
                temp_p[H2] = temp_p[H2] * FHM;
    8910:	e1c801d0 	ldrd	r0, [r8, #16]
    8914:	e1a02004 	mov	r2, r4
    8918:	e1a03005 	mov	r3, r5
    891c:	eb003077 	bl	14b00 <__aeabi_dmul>
            } /* for dir */

            curr_ptr = curr_ptr->next_mol;
    8920:	e59662a0 	ldr	r6, [r6, #672]	; 0x2a0
        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
    8924:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    8928:	e3560000 	cmp	r6, #0
            for ( dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DEST][dir];
                temp_p[H1] = temp_p[H1] * FHM;
                temp_p[O]  = temp_p[O] * FOM;
                temp_p[H2] = temp_p[H2] * FHM;
    892c:	e1c801f0 	strd	r0, [r8, #16]
        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
    8930:	1affffc9 	bne	885c <INTERF+0x11b8>
    8934:	e59d8050 	ldr	r8, [sp, #80]	; 0x50
                temp_p[H2] = temp_p[H2] * FHM;
            } /* for dir */

            curr_ptr = curr_ptr->next_mol;
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    8938:	e598800c 	ldr	r8, [r8, #12]
    BARRIER(gl->InterfBar, NumProcs);

    /* divide final forces by masses */

    curr_box = my_boxes[ProcID];
    while (curr_box) {
    893c:	e3580000 	cmp	r8, #0
    8940:	1affffbb 	bne	8834 <INTERF+0x1190>
            curr_ptr = curr_ptr->next_mol;
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    } /* while curr_box */

}/* end of subroutine INTERF */
    8944:	e28ddfe5 	add	sp, sp, #916	; 0x394
    8948:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            for (YBOX=j-1; YBOX<=j+1; YBOX++) {
                for (ZBOX=k-1; ZBOX<=k+1; ZBOX++) {

                    /* Special case for two boxes per side */

                    if ((BOX_PER_SIDE == 2) && ((XBOX < 0) || (XBOX == 2) ||
    894c:	e59dc0ac 	ldr	ip, [sp, #172]	; 0xac
    8950:	e35c0000 	cmp	ip, #0
    8954:	1affff5c 	bne	86cc <INTERF+0x1028>
                                                (YBOX < 0) || (YBOX == 2) || (ZBOX < 0) || (ZBOX == 2)))
    8958:	e59d40b0 	ldr	r4, [sp, #176]	; 0xb0
    895c:	e3540000 	cmp	r4, #0
    8960:	1affff59 	bne	86cc <INTERF+0x1028>
    8964:	e59d5068 	ldr	r5, [sp, #104]	; 0x68
    8968:	e2452002 	sub	r2, r5, #2
    896c:	e16f2f12 	clz	r2, r2
    8970:	e1a022a2 	lsr	r2, r2, #5
    8974:	e1925fa5 	orrs	r5, r2, r5, lsr #31
    8978:	1affff53 	bne	86cc <INTERF+0x1028>
    897c:	eafffb9e 	b	77fc <INTERF+0x158>
    *VIR = *VIR + LVIR/2.0;
    UNLOCK(gl->InterfVirLock);

    /* wait till all forces are updated */

    BARRIER(gl->InterfBar, NumProcs);
    8980:	e51f0600 	ldr	r0, [pc, #-1536]	; 8388 <INTERF+0xce4>
    8984:	eb0040aa 	bl	18c34 <puts>
    8988:	e3e00000 	mvn	r0, #0
    898c:	eb0034a3 	bl	15c20 <exit>
    8990:	e16f2f15 	clz	r2, r5
    8994:	e1a022a2 	lsr	r2, r2, #5
    8998:	e583207c 	str	r2, [r3, #124]	; 0x7c
    899c:	e5831078 	str	r1, [r3, #120]	; 0x78
    89a0:	e2830070 	add	r0, r3, #112	; 0x70
    89a4:	ebffdfcb 	bl	8d8 <pthread_cond_broadcast>
    89a8:	eaffff8b 	b	87dc <INTERF+0x1138>

000089ac <SYSCNS>:
#include "cnst.h"
#include "mddata.h"
#include "global.h"

void SYSCNS()                    /* sets up some system constants */
{
    89ac:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    TSTEP=TSTEP/UNITT;        /* time between steps */
    89b0:	e59f33a8 	ldr	r3, [pc, #936]	; 8d60 <SYSCNS+0x3b4>
    89b4:	e59fb3a8 	ldr	fp, [pc, #936]	; 8d64 <SYSCNS+0x3b8>
#include "cnst.h"
#include "mddata.h"
#include "global.h"

void SYSCNS()                    /* sets up some system constants */
{
    89b8:	e24dd01c 	sub	sp, sp, #28
    TSTEP=TSTEP/UNITT;        /* time between steps */
    89bc:	e1c340d0 	ldrd	r4, [r3]
    89c0:	e1cb00d0 	ldrd	r0, [fp]
    89c4:	e1a02004 	mov	r2, r4
    89c8:	e1a03005 	mov	r3, r5
    89cc:	eb0030ef 	bl	14d90 <__aeabi_ddiv>
    NATMO=NATOMS*NMOL;        /* total number of atoms in system */
    89d0:	e59f3390 	ldr	r3, [pc, #912]	; 8d68 <SYSCNS+0x3bc>
    89d4:	e59f2390 	ldr	r2, [pc, #912]	; 8d6c <SYSCNS+0x3c0>
    89d8:	e5938000 	ldr	r8, [r3]
    89dc:	e5927000 	ldr	r7, [r2]
    89e0:	e59fe388 	ldr	lr, [pc, #904]	; 8d70 <SYSCNS+0x3c4>
    89e4:	e0080798 	mul	r8, r8, r7
    NATMO3=NATMO*3; /* number of atoms * number of spatial dimensions */
    FPOT= UNITM * pow((UNITL/UNITT),2.0) / (BOLTZ*TEMP*NATMO);
    89e8:	e59f6384 	ldr	r6, [pc, #900]	; 8d74 <SYSCNS+0x3c8>

void SYSCNS()                    /* sets up some system constants */
{
    TSTEP=TSTEP/UNITT;        /* time between steps */
    NATMO=NATOMS*NMOL;        /* total number of atoms in system */
    NATMO3=NATMO*3; /* number of atoms * number of spatial dimensions */
    89ec:	e59fc384 	ldr	ip, [pc, #900]	; 8d78 <SYSCNS+0x3cc>
#include "mddata.h"
#include "global.h"

void SYSCNS()                    /* sets up some system constants */
{
    TSTEP=TSTEP/UNITT;        /* time between steps */
    89f0:	e1cd00f8 	strd	r0, [sp, #8]
    NATMO=NATOMS*NMOL;        /* total number of atoms in system */
    NATMO3=NATMO*3; /* number of atoms * number of spatial dimensions */
    FPOT= UNITM * pow((UNITL/UNITT),2.0) / (BOLTZ*TEMP*NATMO);
    89f4:	e1c600d0 	ldrd	r0, [r6]

void SYSCNS()                    /* sets up some system constants */
{
    TSTEP=TSTEP/UNITT;        /* time between steps */
    NATMO=NATOMS*NMOL;        /* total number of atoms in system */
    NATMO3=NATMO*3; /* number of atoms * number of spatial dimensions */
    89f8:	e0889088 	add	r9, r8, r8, lsl #1
#include "global.h"

void SYSCNS()                    /* sets up some system constants */
{
    TSTEP=TSTEP/UNITT;        /* time between steps */
    NATMO=NATOMS*NMOL;        /* total number of atoms in system */
    89fc:	e58e8000 	str	r8, [lr]
    NATMO3=NATMO*3; /* number of atoms * number of spatial dimensions */
    FPOT= UNITM * pow((UNITL/UNITT),2.0) / (BOLTZ*TEMP*NATMO);
    8a00:	e1a02004 	mov	r2, r4
    8a04:	e1a03005 	mov	r3, r5
#include "mddata.h"
#include "global.h"

void SYSCNS()                    /* sets up some system constants */
{
    TSTEP=TSTEP/UNITT;        /* time between steps */
    8a08:	e1cd40d8 	ldrd	r4, [sp, #8]
    NATMO=NATOMS*NMOL;        /* total number of atoms in system */
    NATMO3=NATMO*3; /* number of atoms * number of spatial dimensions */
    8a0c:	e58c9000 	str	r9, [ip]
#include "mddata.h"
#include "global.h"

void SYSCNS()                    /* sets up some system constants */
{
    TSTEP=TSTEP/UNITT;        /* time between steps */
    8a10:	e1cb40f0 	strd	r4, [fp]
    NATMO=NATOMS*NMOL;        /* total number of atoms in system */
    NATMO3=NATMO*3; /* number of atoms * number of spatial dimensions */
    FPOT= UNITM * pow((UNITL/UNITT),2.0) / (BOLTZ*TEMP*NATMO);
    8a14:	eb0030dd 	bl	14d90 <__aeabi_ddiv>
    8a18:	e59fc35c 	ldr	ip, [pc, #860]	; 8d7c <SYSCNS+0x3d0>
    8a1c:	e1a02000 	mov	r2, r0
    8a20:	e1cc40d0 	ldrd	r4, [ip]
    8a24:	e1a03001 	mov	r3, r1
    8a28:	e1cd40f0 	strd	r4, [sp]
    8a2c:	eb003033 	bl	14b00 <__aeabi_dmul>
    8a30:	e1a02000 	mov	r2, r0
    8a34:	e1a03001 	mov	r3, r1
    8a38:	e1cd00d0 	ldrd	r0, [sp]
    8a3c:	eb00302f 	bl	14b00 <__aeabi_dmul>
    8a40:	e59f2338 	ldr	r2, [pc, #824]	; 8d80 <SYSCNS+0x3d4>
    8a44:	e59f3338 	ldr	r3, [pc, #824]	; 8d84 <SYSCNS+0x3d8>
    8a48:	e1cd01f0 	strd	r0, [sp, #16]
    8a4c:	e1c200d0 	ldrd	r0, [r2]
    8a50:	e1c320d0 	ldrd	r2, [r3]
    8a54:	eb003029 	bl	14b00 <__aeabi_dmul>
    8a58:	e1a04000 	mov	r4, r0
    8a5c:	e1a00008 	mov	r0, r8
    8a60:	e1a05001 	mov	r5, r1
    8a64:	eb002fee 	bl	14a24 <__aeabi_i2d>
    8a68:	e1a02000 	mov	r2, r0
    8a6c:	e1a03001 	mov	r3, r1
    8a70:	e1a00004 	mov	r0, r4
    8a74:	e1a01005 	mov	r1, r5
    8a78:	eb003020 	bl	14b00 <__aeabi_dmul>
    8a7c:	e1a02000 	mov	r2, r0
    8a80:	e1a03001 	mov	r3, r1
    8a84:	e1cd01d0 	ldrd	r0, [sp, #16]
    8a88:	eb0030c0 	bl	14d90 <__aeabi_ddiv>
    8a8c:	e59fc2f4 	ldr	ip, [pc, #756]	; 8d88 <SYSCNS+0x3dc>
    FKIN=FPOT*0.50/(TSTEP*TSTEP);
    8a90:	e3a02000 	mov	r2, #0
void SYSCNS()                    /* sets up some system constants */
{
    TSTEP=TSTEP/UNITT;        /* time between steps */
    NATMO=NATOMS*NMOL;        /* total number of atoms in system */
    NATMO3=NATMO*3; /* number of atoms * number of spatial dimensions */
    FPOT= UNITM * pow((UNITL/UNITT),2.0) / (BOLTZ*TEMP*NATMO);
    8a94:	e1cc00f0 	strd	r0, [ip]
    FKIN=FPOT*0.50/(TSTEP*TSTEP);
    8a98:	e59f32ec 	ldr	r3, [pc, #748]	; 8d8c <SYSCNS+0x3e0>
    8a9c:	eb003017 	bl	14b00 <__aeabi_dmul>
    8aa0:	e1a04000 	mov	r4, r0
    8aa4:	e1a05001 	mov	r5, r1
    8aa8:	e1cd00d8 	ldrd	r0, [sp, #8]
    8aac:	e1a02000 	mov	r2, r0
    8ab0:	e1a03001 	mov	r3, r1
    8ab4:	eb003011 	bl	14b00 <__aeabi_dmul>
    8ab8:	e1a02000 	mov	r2, r0
    8abc:	e1a03001 	mov	r3, r1
    8ac0:	e1a00004 	mov	r0, r4
    8ac4:	e1a01005 	mov	r1, r5
    8ac8:	eb0030b0 	bl	14d90 <__aeabi_ddiv>
    8acc:	e59f32bc 	ldr	r3, [pc, #700]	; 8d90 <SYSCNS+0x3e4>

    /* set cutoff radius if it was not already read in nonzero from
       the input file in water.C.  If it was defined in the input file,
       then that definition is retained. */

    if (CUTOFF == 0.0) {
    8ad0:	e59fa2bc 	ldr	sl, [pc, #700]	; 8d94 <SYSCNS+0x3e8>
{
    TSTEP=TSTEP/UNITT;        /* time between steps */
    NATMO=NATOMS*NMOL;        /* total number of atoms in system */
    NATMO3=NATMO*3; /* number of atoms * number of spatial dimensions */
    FPOT= UNITM * pow((UNITL/UNITT),2.0) / (BOLTZ*TEMP*NATMO);
    FKIN=FPOT*0.50/(TSTEP*TSTEP);
    8ad4:	e1c300f0 	strd	r0, [r3]
    /* computed length of the cubical "box".  Note that box size is
     * computed as being large enough to handle the input number of
     * water molecules
     */

    BOXL= pow( (NMOL*WTMOL*UNITM/RHO),(1.00/3.00));
    8ad8:	e1a00007 	mov	r0, r7
    8adc:	eb002fd0 	bl	14a24 <__aeabi_i2d>
    8ae0:	e59f32b0 	ldr	r3, [pc, #688]	; 8d98 <SYSCNS+0x3ec>
    8ae4:	e1c320d0 	ldrd	r2, [r3]
    8ae8:	eb003004 	bl	14b00 <__aeabi_dmul>
    8aec:	e1a02000 	mov	r2, r0
    8af0:	e1a03001 	mov	r3, r1
    8af4:	e1cd00d0 	ldrd	r0, [sp]
    8af8:	eb003000 	bl	14b00 <__aeabi_dmul>
    8afc:	e59f3298 	ldr	r3, [pc, #664]	; 8d9c <SYSCNS+0x3f0>
    8b00:	e1c320d0 	ldrd	r2, [r3]
    8b04:	eb0030a1 	bl	14d90 <__aeabi_ddiv>
    8b08:	e59f2290 	ldr	r2, [pc, #656]	; 8da0 <SYSCNS+0x3f4>
    8b0c:	e59f3290 	ldr	r3, [pc, #656]	; 8da4 <SYSCNS+0x3f8>
    8b10:	eb0084cc 	bl	29e48 <pow>

    /* normalized length of computational box (in Angstroms) */

    BOXL=BOXL/UNITL;
    8b14:	e1c620d0 	ldrd	r2, [r6]
    8b18:	eb00309c 	bl	14d90 <__aeabi_ddiv>
    8b1c:	e1a06000 	mov	r6, r0
    8b20:	e1a07001 	mov	r7, r1
    8b24:	e59fc27c 	ldr	ip, [pc, #636]	; 8da8 <SYSCNS+0x3fc>

    /* # of boxes per side */

    BOXH = BOXL*0.50;
    8b28:	e3a02000 	mov	r2, #0
    8b2c:	e59f3258 	ldr	r3, [pc, #600]	; 8d8c <SYSCNS+0x3e0>

    BOXL= pow( (NMOL*WTMOL*UNITM/RHO),(1.00/3.00));

    /* normalized length of computational box (in Angstroms) */

    BOXL=BOXL/UNITL;
    8b30:	e1cc60f0 	strd	r6, [ip]

    /* # of boxes per side */

    BOXH = BOXL*0.50;
    8b34:	eb002ff1 	bl	14b00 <__aeabi_dmul>

    /* set cutoff radius if it was not already read in nonzero from
       the input file in water.C.  If it was defined in the input file,
       then that definition is retained. */

    if (CUTOFF == 0.0) {
    8b38:	e1ca40d0 	ldrd	r4, [sl]

    BOXL=BOXL/UNITL;

    /* # of boxes per side */

    BOXH = BOXL*0.50;
    8b3c:	e1a08000 	mov	r8, r0
    8b40:	e1a09001 	mov	r9, r1
    8b44:	e59fc260 	ldr	ip, [pc, #608]	; 8dac <SYSCNS+0x400>

    /* set cutoff radius if it was not already read in nonzero from
       the input file in water.C.  If it was defined in the input file,
       then that definition is retained. */

    if (CUTOFF == 0.0) {
    8b48:	e1a00004 	mov	r0, r4
    8b4c:	e1a01005 	mov	r1, r5
    8b50:	e3a02000 	mov	r2, #0
    8b54:	e3a03000 	mov	r3, #0

    BOXL=BOXL/UNITL;

    /* # of boxes per side */

    BOXH = BOXL*0.50;
    8b58:	e1cc80f0 	strd	r8, [ip]

    /* set cutoff radius if it was not already read in nonzero from
       the input file in water.C.  If it was defined in the input file,
       then that definition is retained. */

    if (CUTOFF == 0.0) {
    8b5c:	eb003141 	bl	15068 <__aeabi_dcmpeq>
    8b60:	e3500000 	cmp	r0, #0
    8b64:	0a000008 	beq	8b8c <SYSCNS+0x1e0>
        CUTOFF=max(BOXH,CUTOFF);    /* cutoff radius is max of BOXH
    8b68:	e1a02004 	mov	r2, r4
    8b6c:	e1a03005 	mov	r3, r5
    8b70:	e1a00008 	mov	r0, r8
    8b74:	e1a01009 	mov	r1, r9
    8b78:	eb003140 	bl	15080 <__aeabi_dcmplt>
    8b7c:	e3500000 	cmp	r0, #0
    8b80:	01a04008 	moveq	r4, r8
    8b84:	01a05009 	moveq	r5, r9
    8b88:	e1ca40f0 	strd	r4, [sl]
                                       and default (= 0); i.e. CUTOFF
                                       radius is set to half the normalized
                                       box length */
    }

    if (CUTOFF > 11.0) CUTOFF = 11.0; /* cutoff never greater than 11
    8b8c:	e3a08000 	mov	r8, #0
    8b90:	e59f9218 	ldr	r9, [pc, #536]	; 8db0 <SYSCNS+0x404>
    8b94:	e1a00004 	mov	r0, r4
    8b98:	e1a01005 	mov	r1, r5
    8b9c:	e1a02008 	mov	r2, r8
    8ba0:	e1a03009 	mov	r3, r9
    8ba4:	eb003147 	bl	150c8 <__aeabi_dcmpgt>
    8ba8:	e3500000 	cmp	r0, #0
    8bac:	1a000059 	bne	8d18 <SYSCNS+0x36c>
    8bb0:	e1a02004 	mov	r2, r4
    8bb4:	e1a03005 	mov	r3, r5
    8bb8:	e1a00004 	mov	r0, r4
    8bbc:	e1a01005 	mov	r1, r5
    8bc0:	eb002fce 	bl	14b00 <__aeabi_dmul>
    8bc4:	e1cd00f0 	strd	r0, [sp]
    8bc8:	e1cd20d0 	ldrd	r2, [sp]
    8bcc:	e1a00004 	mov	r0, r4
    8bd0:	e1a01005 	mov	r1, r5
    8bd4:	eb002fc9 	bl	14b00 <__aeabi_dmul>
    8bd8:	e1cd00f8 	strd	r0, [sp, #8]
                                         Angstrom */

    BOX_PER_SIDE = ( BOXL / CUTOFF);
    8bdc:	e1a03005 	mov	r3, r5
    8be0:	e1a02004 	mov	r2, r4
    8be4:	e1a00006 	mov	r0, r6
    8be8:	e1a01007 	mov	r1, r7
    8bec:	eb003067 	bl	14d90 <__aeabi_ddiv>
    8bf0:	eb00313a 	bl	150e0 <__aeabi_d2iz>

    /* BOX_PER_SIDE is always >=1 */
    if (!BOX_PER_SIDE) BOX_PER_SIDE = 1;
    8bf4:	e2503000 	subs	r3, r0, #0
    8bf8:	1a000050 	bne	8d40 <SYSCNS+0x394>
    8bfc:	e3a01001 	mov	r1, #1
    8c00:	e3a02000 	mov	r2, #0
    8c04:	e1a04001 	mov	r4, r1
    8c08:	e1a05001 	mov	r5, r1
    8c0c:	e59f01a0 	ldr	r0, [pc, #416]	; 8db4 <SYSCNS+0x408>
    8c10:	e59f31a0 	ldr	r3, [pc, #416]	; 8db8 <SYSCNS+0x40c>
    8c14:	e5801000 	str	r1, [r0]

    /* Length of a box in Angstroms */

    BOX_LENGTH = BOXL / ( (double) BOX_PER_SIDE);
    8c18:	e1a00006 	mov	r0, r6
    8c1c:	e1a01007 	mov	r1, r7
    8c20:	eb00305a 	bl	14d90 <__aeabi_ddiv>

    BPS_SQRD = BOX_PER_SIDE * BOX_PER_SIDE;

    NumBoxes = BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE;

    REF1= -QQ/(CUTOFF*CUTOFF*CUTOFF);
    8c24:	e59f3190 	ldr	r3, [pc, #400]	; 8dbc <SYSCNS+0x410>

    /* Length of a box in Angstroms */

    BOX_LENGTH = BOXL / ( (double) BOX_PER_SIDE);

    BPS_SQRD = BOX_PER_SIDE * BOX_PER_SIDE;
    8c28:	e59fe190 	ldr	lr, [pc, #400]	; 8dc0 <SYSCNS+0x414>

    NumBoxes = BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE;

    REF1= -QQ/(CUTOFF*CUTOFF*CUTOFF);
    8c2c:	e5938000 	ldr	r8, [r3]
    8c30:	e5933004 	ldr	r3, [r3, #4]

    BOX_LENGTH = BOXL / ( (double) BOX_PER_SIDE);

    BPS_SQRD = BOX_PER_SIDE * BOX_PER_SIDE;

    NumBoxes = BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE;
    8c34:	e59fc188 	ldr	ip, [pc, #392]	; 8dc4 <SYSCNS+0x418>
    /* BOX_PER_SIDE is always >=1 */
    if (!BOX_PER_SIDE) BOX_PER_SIDE = 1;

    /* Length of a box in Angstroms */

    BOX_LENGTH = BOXL / ( (double) BOX_PER_SIDE);
    8c38:	e59f6188 	ldr	r6, [pc, #392]	; 8dc8 <SYSCNS+0x41c>

    BPS_SQRD = BOX_PER_SIDE * BOX_PER_SIDE;

    NumBoxes = BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE;

    REF1= -QQ/(CUTOFF*CUTOFF*CUTOFF);
    8c3c:	e2839102 	add	r9, r3, #-2147483648	; 0x80000000

    /* Length of a box in Angstroms */

    BOX_LENGTH = BOXL / ( (double) BOX_PER_SIDE);

    BPS_SQRD = BOX_PER_SIDE * BOX_PER_SIDE;
    8c40:	e58e5000 	str	r5, [lr]

    NumBoxes = BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE;

    REF1= -QQ/(CUTOFF*CUTOFF*CUTOFF);
    8c44:	e1cd20d8 	ldrd	r2, [sp, #8]
    /* BOX_PER_SIDE is always >=1 */
    if (!BOX_PER_SIDE) BOX_PER_SIDE = 1;

    /* Length of a box in Angstroms */

    BOX_LENGTH = BOXL / ( (double) BOX_PER_SIDE);
    8c48:	e1c600f0 	strd	r0, [r6]

    BPS_SQRD = BOX_PER_SIDE * BOX_PER_SIDE;

    NumBoxes = BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE;
    8c4c:	e58c4000 	str	r4, [ip]

    REF1= -QQ/(CUTOFF*CUTOFF*CUTOFF);
    8c50:	e1a00008 	mov	r0, r8
    8c54:	e1a01009 	mov	r1, r9
    8c58:	eb00304c 	bl	14d90 <__aeabi_ddiv>
    8c5c:	e1a04000 	mov	r4, r0
    8c60:	e1a05001 	mov	r5, r1
    8c64:	e59fc160 	ldr	ip, [pc, #352]	; 8dcc <SYSCNS+0x420>
    REF2=2.00*REF1;
    8c68:	e1a02000 	mov	r2, r0

    BPS_SQRD = BOX_PER_SIDE * BOX_PER_SIDE;

    NumBoxes = BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE;

    REF1= -QQ/(CUTOFF*CUTOFF*CUTOFF);
    8c6c:	e1cc40f0 	strd	r4, [ip]
    REF2=2.00*REF1;
    8c70:	e1a03001 	mov	r3, r1
    8c74:	eb002e9d 	bl	146f0 <__adddf3>
    8c78:	e1a04000 	mov	r4, r0
    8c7c:	e1a05001 	mov	r5, r1
    8c80:	e59fc148 	ldr	ip, [pc, #328]	; 8dd0 <SYSCNS+0x424>
    REF4=2.00*REF2;
    8c84:	e1a02000 	mov	r2, r0
    BPS_SQRD = BOX_PER_SIDE * BOX_PER_SIDE;

    NumBoxes = BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE;

    REF1= -QQ/(CUTOFF*CUTOFF*CUTOFF);
    REF2=2.00*REF1;
    8c88:	e1cc40f0 	strd	r4, [ip]
    REF4=2.00*REF2;
    8c8c:	e1a03001 	mov	r3, r1
    8c90:	eb002e96 	bl	146f0 <__adddf3>
    CUT2=CUTOFF*CUTOFF;        /* square of cutoff radius,  used
                                  to actually decide whether an
                                  interaction should be computed in
                                  INTERF and POTENG */

    FHM=(TSTEP*TSTEP*0.50)/HMAS;
    8c94:	e1cb20d0 	ldrd	r2, [fp]
    NumBoxes = BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE;

    REF1= -QQ/(CUTOFF*CUTOFF*CUTOFF);
    REF2=2.00*REF1;
    REF4=2.00*REF2;
    CUT2=CUTOFF*CUTOFF;        /* square of cutoff radius,  used
    8c98:	e1cd40d0 	ldrd	r4, [sp]

    NumBoxes = BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE;

    REF1= -QQ/(CUTOFF*CUTOFF*CUTOFF);
    REF2=2.00*REF1;
    REF4=2.00*REF2;
    8c9c:	e59fe130 	ldr	lr, [pc, #304]	; 8dd4 <SYSCNS+0x428>
    CUT2=CUTOFF*CUTOFF;        /* square of cutoff radius,  used
    8ca0:	e59fc130 	ldr	ip, [pc, #304]	; 8dd8 <SYSCNS+0x42c>

    NumBoxes = BOX_PER_SIDE * BOX_PER_SIDE * BOX_PER_SIDE;

    REF1= -QQ/(CUTOFF*CUTOFF*CUTOFF);
    REF2=2.00*REF1;
    REF4=2.00*REF2;
    8ca4:	e1ce00f0 	strd	r0, [lr]
    CUT2=CUTOFF*CUTOFF;        /* square of cutoff radius,  used
    8ca8:	e1cc40f0 	strd	r4, [ip]
                                  to actually decide whether an
                                  interaction should be computed in
                                  INTERF and POTENG */

    FHM=(TSTEP*TSTEP*0.50)/HMAS;
    8cac:	e1a00002 	mov	r0, r2
    8cb0:	e1a01003 	mov	r1, r3
    8cb4:	eb002f91 	bl	14b00 <__aeabi_dmul>
    8cb8:	e3a02000 	mov	r2, #0
    8cbc:	e59f30c8 	ldr	r3, [pc, #200]	; 8d8c <SYSCNS+0x3e0>
    8cc0:	eb002f8e 	bl	14b00 <__aeabi_dmul>
    8cc4:	e59f3110 	ldr	r3, [pc, #272]	; 8ddc <SYSCNS+0x430>
    8cc8:	e1a04000 	mov	r4, r0
    8ccc:	e1c320d0 	ldrd	r2, [r3]
    8cd0:	e1a05001 	mov	r5, r1
    8cd4:	eb00302d 	bl	14d90 <__aeabi_ddiv>
    8cd8:	e59f6100 	ldr	r6, [pc, #256]	; 8de0 <SYSCNS+0x434>
    FOM=(TSTEP*TSTEP*0.50)/OMAS;
    8cdc:	e59f3100 	ldr	r3, [pc, #256]	; 8de4 <SYSCNS+0x438>
    CUT2=CUTOFF*CUTOFF;        /* square of cutoff radius,  used
                                  to actually decide whether an
                                  interaction should be computed in
                                  INTERF and POTENG */

    FHM=(TSTEP*TSTEP*0.50)/HMAS;
    8ce0:	e1c600f0 	strd	r0, [r6]
    FOM=(TSTEP*TSTEP*0.50)/OMAS;
    8ce4:	e1c320d0 	ldrd	r2, [r3]
    8ce8:	e1a00004 	mov	r0, r4
    8cec:	e1a01005 	mov	r1, r5
    8cf0:	eb003026 	bl	14d90 <__aeabi_ddiv>
    NMOL1=NMOL-1;
    8cf4:	e59f5070 	ldr	r5, [pc, #112]	; 8d6c <SYSCNS+0x3c0>
                                  to actually decide whether an
                                  interaction should be computed in
                                  INTERF and POTENG */

    FHM=(TSTEP*TSTEP*0.50)/HMAS;
    FOM=(TSTEP*TSTEP*0.50)/OMAS;
    8cf8:	e59f20e8 	ldr	r2, [pc, #232]	; 8de8 <SYSCNS+0x43c>
    NMOL1=NMOL-1;
    8cfc:	e5953000 	ldr	r3, [r5]
                                  to actually decide whether an
                                  interaction should be computed in
                                  INTERF and POTENG */

    FHM=(TSTEP*TSTEP*0.50)/HMAS;
    FOM=(TSTEP*TSTEP*0.50)/OMAS;
    8d00:	e1c200f0 	strd	r0, [r2]
    NMOL1=NMOL-1;
    8d04:	e59f20e0 	ldr	r2, [pc, #224]	; 8dec <SYSCNS+0x440>
    8d08:	e2433001 	sub	r3, r3, #1
    8d0c:	e5823000 	str	r3, [r2]

}       /* end of subroutine SYSCNS */
    8d10:	e28dd01c 	add	sp, sp, #28
    8d14:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                                       and default (= 0); i.e. CUTOFF
                                       radius is set to half the normalized
                                       box length */
    }

    if (CUTOFF > 11.0) CUTOFF = 11.0; /* cutoff never greater than 11
    8d18:	e3a02000 	mov	r2, #0
    8d1c:	e59f30cc 	ldr	r3, [pc, #204]	; 8df0 <SYSCNS+0x444>
    8d20:	e1a04008 	mov	r4, r8
    8d24:	e1cd20f8 	strd	r2, [sp, #8]
    8d28:	e3a02000 	mov	r2, #0
    8d2c:	e59f30c0 	ldr	r3, [pc, #192]	; 8df4 <SYSCNS+0x448>
    8d30:	e1a05009 	mov	r5, r9
    8d34:	e1cd20f0 	strd	r2, [sp]
    8d38:	e1ca80f0 	strd	r8, [sl]
    8d3c:	eaffffa6 	b	8bdc <SYSCNS+0x230>
    8d40:	e0050393 	mul	r5, r3, r3
                                         Angstrom */

    BOX_PER_SIDE = ( BOXL / CUTOFF);
    8d44:	e59f2068 	ldr	r2, [pc, #104]	; 8db4 <SYSCNS+0x408>
    8d48:	e0040395 	mul	r4, r5, r3
    8d4c:	e5823000 	str	r3, [r2]
    8d50:	eb002f33 	bl	14a24 <__aeabi_i2d>
    8d54:	e1a02000 	mov	r2, r0
    8d58:	e1a03001 	mov	r3, r1
    8d5c:	eaffffad 	b	8c18 <SYSCNS+0x26c>
    8d60:	0013f508 	.word	0x0013f508
    8d64:	0013eed8 	.word	0x0013eed8
    8d68:	0013ea74 	.word	0x0013ea74
    8d6c:	0013f004 	.word	0x0013f004
    8d70:	0013ef54 	.word	0x0013ef54
    8d74:	0013f460 	.word	0x0013f460
    8d78:	0013f008 	.word	0x0013f008
    8d7c:	0013f3d0 	.word	0x0013f3d0
    8d80:	0013efc0 	.word	0x0013efc0
    8d84:	0013ef90 	.word	0x0013ef90
    8d88:	0013f510 	.word	0x0013f510
    8d8c:	3fe00000 	.word	0x3fe00000
    8d90:	0013efb8 	.word	0x0013efb8
    8d94:	0013f530 	.word	0x0013f530
    8d98:	0013ea78 	.word	0x0013ea78
    8d9c:	0013ef68 	.word	0x0013ef68
    8da0:	55555555 	.word	0x55555555
    8da4:	3fd55555 	.word	0x3fd55555
    8da8:	0013ea58 	.word	0x0013ea58
    8dac:	0013efe0 	.word	0x0013efe0
    8db0:	40260000 	.word	0x40260000
    8db4:	0013ea50 	.word	0x0013ea50
    8db8:	3ff00000 	.word	0x3ff00000
    8dbc:	0013f448 	.word	0x0013f448
    8dc0:	0013ef70 	.word	0x0013ef70
    8dc4:	0013f3d8 	.word	0x0013f3d8
    8dc8:	0013ef58 	.word	0x0013ef58
    8dcc:	0013f520 	.word	0x0013f520
    8dd0:	0013f010 	.word	0x0013f010
    8dd4:	0013f438 	.word	0x0013f438
    8dd8:	0013efb0 	.word	0x0013efb0
    8ddc:	0013f418 	.word	0x0013f418
    8de0:	0013f558 	.word	0x0013f558
    8de4:	0013ef78 	.word	0x0013ef78
    8de8:	0013eed0 	.word	0x0013eed0
    8dec:	0013f454 	.word	0x0013f454
    8df0:	4094cc00 	.word	0x4094cc00
    8df4:	405e4000 	.word	0x405e4000

00008df8 <INTRAF>:
#include "mddata.h"
#include "split.h"
#include "global.h"

void INTRAF(double *VIR, long ProcID)
{
    8df8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8dfc:	e24ddf41 	sub	sp, sp, #260	; 0x104
    8e00:	e58d00f8 	str	r0, [sp, #248]	; 0xf8
    long i, j, k;
    struct link *curr_ptr;
    struct list_of_boxes *curr_box;
    double *temp_p;

    curr_box = my_boxes[ProcID];
    8e04:	e59f0ca4 	ldr	r0, [pc, #3236]	; 9ab0 <INTRAF+0xcb8>
#include "mddata.h"
#include "split.h"
#include "global.h"

void INTRAF(double *VIR, long ProcID)
{
    8e08:	e58d10fc 	str	r1, [sp, #252]	; 0xfc
    long i, j, k;
    struct link *curr_ptr;
    struct list_of_boxes *curr_box;
    double *temp_p;

    curr_box = my_boxes[ProcID];
    8e0c:	e5903000 	ldr	r3, [r0]
    8e10:	e7933101 	ldr	r3, [r3, r1, lsl #2]
    while (curr_box) {
    8e14:	e3530000 	cmp	r3, #0
    long i, j, k;
    struct link *curr_ptr;
    struct list_of_boxes *curr_box;
    double *temp_p;

    curr_box = my_boxes[ProcID];
    8e18:	e58d30f4 	str	r3, [sp, #244]	; 0xf4
    while (curr_box) {
    8e1c:	0a000520 	beq	a2a4 <INTRAF+0x14ac>
        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        curr_ptr = BOX[i][j][k].list;
    8e20:	e59dc0f4 	ldr	ip, [sp, #244]	; 0xf4
    8e24:	e59fec88 	ldr	lr, [pc, #3208]	; 9ab4 <INTRAF+0xcbc>
    8e28:	e59c2000 	ldr	r2, [ip]
    8e2c:	e59e3000 	ldr	r3, [lr]
    8e30:	e59c1004 	ldr	r1, [ip, #4]
    8e34:	e7933102 	ldr	r3, [r3, r2, lsl #2]
    8e38:	e59c2008 	ldr	r2, [ip, #8]
    8e3c:	e7933101 	ldr	r3, [r3, r1, lsl #2]
    8e40:	e793a202 	ldr	sl, [r3, r2, lsl #4]
        while (curr_ptr) {
    8e44:	e35a0000 	cmp	sl, #0
    8e48:	0a00047b 	beq	a03c <INTRAF+0x1244>
    8e4c:	e1a0c00a 	mov	ip, sl
    8e50:	e58da0f0 	str	sl, [sp, #240]	; 0xf0

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    8e54:	e59f1c5c 	ldr	r1, [pc, #3164]	; 9ab8 <INTRAF+0xcc0>
                    + C2 * (temp_p[H1] +
    8e58:	e59f3c5c 	ldr	r3, [pc, #3164]	; 9abc <INTRAF+0xcc4>

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    8e5c:	e1c100d0 	ldrd	r0, [r1]
    8e60:	e1cd00f0 	strd	r0, [sp]
    8e64:	e1cc42d0 	ldrd	r4, [ip, #32]
                    + C2 * (temp_p[H1] +
    8e68:	e1c320d0 	ldrd	r2, [r3]

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    8e6c:	e1a00004 	mov	r0, r4
                    + C2 * (temp_p[H1] +
    8e70:	e1cc61d8 	ldrd	r6, [ip, #24]
                            temp_p[H2] );
    8e74:	e1cca2d8 	ldrd	sl, [ip, #40]	; 0x28

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    8e78:	e1a01005 	mov	r1, r5
                    + C2 * (temp_p[H1] +
    8e7c:	e1cd21f8 	strd	r2, [sp, #24]

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    8e80:	e1cd20d0 	ldrd	r2, [sp]
    8e84:	eb002f1d 	bl	14b00 <__aeabi_dmul>
                    + C2 * (temp_p[H1] +
    8e88:	e1a0200a 	mov	r2, sl

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    8e8c:	e1a08000 	mov	r8, r0
    8e90:	e1a09001 	mov	r9, r1
                    + C2 * (temp_p[H1] +
    8e94:	e1a0300b 	mov	r3, fp
    8e98:	e1a00006 	mov	r0, r6
    8e9c:	e1a01007 	mov	r1, r7
    8ea0:	eb002e12 	bl	146f0 <__adddf3>
    8ea4:	e1cd21d8 	ldrd	r2, [sp, #24]
    8ea8:	eb002f14 	bl	14b00 <__aeabi_dmul>
    8eac:	e1a02000 	mov	r2, r0
    8eb0:	e1a03001 	mov	r3, r1
    8eb4:	e1a00008 	mov	r0, r8
    8eb8:	e1a01009 	mov	r1, r9
    8ebc:	eb002e0b 	bl	146f0 <__adddf3>

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    8ec0:	e59dc0f0 	ldr	ip, [sp, #240]	; 0xf0
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
    8ec4:	e1a02006 	mov	r2, r6

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    8ec8:	e1cc00f0 	strd	r0, [ip]
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
    8ecc:	e1a03007 	mov	r3, r7
    8ed0:	e1a00004 	mov	r0, r4
    8ed4:	e1a01005 	mov	r1, r5
    8ed8:	eb002e03 	bl	146ec <__aeabi_dsub>
                R1 += VR1[dir] * VR1[dir];
    8edc:	e1a02000 	mov	r2, r0
    8ee0:	e1a03001 	mov	r3, r1
            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
    8ee4:	e1cd03f8 	strd	r0, [sp, #56]	; 0x38
                R1 += VR1[dir] * VR1[dir];
    8ee8:	eb002f04 	bl	14b00 <__aeabi_dmul>
    8eec:	e3a02000 	mov	r2, #0
    8ef0:	e3a03000 	mov	r3, #0
    8ef4:	eb002dfd 	bl	146f0 <__adddf3>
                VR2[dir] = temp_p[O] - temp_p[H2];
    8ef8:	e1a0200a 	mov	r2, sl
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
                R1 += VR1[dir] * VR1[dir];
    8efc:	e1cd02f0 	strd	r0, [sp, #32]
                VR2[dir] = temp_p[O] - temp_p[H2];
    8f00:	e1a0300b 	mov	r3, fp
    8f04:	e1a00004 	mov	r0, r4
    8f08:	e1a01005 	mov	r1, r5
    8f0c:	eb002df6 	bl	146ec <__aeabi_dsub>
                R2 += VR2[dir] * VR2[dir];
    8f10:	e1a02000 	mov	r2, r0
    8f14:	e1a03001 	mov	r3, r1
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
                R1 += VR1[dir] * VR1[dir];
                VR2[dir] = temp_p[O] - temp_p[H2];
    8f18:	e1cd01f0 	strd	r0, [sp, #16]
                R2 += VR2[dir] * VR2[dir];
    8f1c:	eb002ef7 	bl	14b00 <__aeabi_dmul>
    8f20:	e3a02000 	mov	r2, #0
    8f24:	e3a03000 	mov	r3, #0
    8f28:	eb002df0 	bl	146f0 <__adddf3>
                SUM += VR1[dir] * VR2[dir];
    8f2c:	e1cd21d0 	ldrd	r2, [sp, #16]
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
                R1 += VR1[dir] * VR1[dir];
                VR2[dir] = temp_p[O] - temp_p[H2];
                R2 += VR2[dir] * VR2[dir];
    8f30:	e1cd02f8 	strd	r0, [sp, #40]	; 0x28
                SUM += VR1[dir] * VR2[dir];
    8f34:	e1cd03d8 	ldrd	r0, [sp, #56]	; 0x38
    8f38:	eb002ef0 	bl	14b00 <__aeabi_dmul>
    8f3c:	e3a02000 	mov	r2, #0
    8f40:	e3a03000 	mov	r3, #0
    8f44:	eb002de9 	bl	146f0 <__adddf3>

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    8f48:	e59dc0f0 	ldr	ip, [sp, #240]	; 0xf0
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
                R1 += VR1[dir] * VR1[dir];
                VR2[dir] = temp_p[O] - temp_p[H2];
                R2 += VR2[dir] * VR2[dir];
                SUM += VR1[dir] * VR2[dir];
    8f4c:	e1cd00f8 	strd	r0, [sp, #8]

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    8f50:	e1cc43d8 	ldrd	r4, [ip, #56]	; 0x38
    8f54:	e1cd00d0 	ldrd	r0, [sp]
    8f58:	e1a02004 	mov	r2, r4
                    + C2 * (temp_p[H1] +
    8f5c:	e1cc63d0 	ldrd	r6, [ip, #48]	; 0x30
                            temp_p[H2] );
    8f60:	e1cca4d0 	ldrd	sl, [ip, #64]	; 0x40

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    8f64:	e1a03005 	mov	r3, r5
    8f68:	eb002ee4 	bl	14b00 <__aeabi_dmul>
                    + C2 * (temp_p[H1] +
    8f6c:	e1a0200a 	mov	r2, sl

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    8f70:	e1a08000 	mov	r8, r0
    8f74:	e1a09001 	mov	r9, r1
                    + C2 * (temp_p[H1] +
    8f78:	e1a0300b 	mov	r3, fp
    8f7c:	e1a00006 	mov	r0, r6
    8f80:	e1a01007 	mov	r1, r7
    8f84:	eb002dd9 	bl	146f0 <__adddf3>
    8f88:	e1a02000 	mov	r2, r0
    8f8c:	e1a03001 	mov	r3, r1
    8f90:	e1cd01d8 	ldrd	r0, [sp, #24]
    8f94:	eb002ed9 	bl	14b00 <__aeabi_dmul>
    8f98:	e1a02000 	mov	r2, r0
    8f9c:	e1a03001 	mov	r3, r1
    8fa0:	e1a00008 	mov	r0, r8
    8fa4:	e1a01009 	mov	r1, r9
    8fa8:	eb002dd0 	bl	146f0 <__adddf3>

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    8fac:	e59dc0f0 	ldr	ip, [sp, #240]	; 0xf0
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
    8fb0:	e1a02006 	mov	r2, r6

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    8fb4:	e1cc00f8 	strd	r0, [ip, #8]
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
    8fb8:	e1a03007 	mov	r3, r7
    8fbc:	e1a00004 	mov	r0, r4
    8fc0:	e1a01005 	mov	r1, r5
    8fc4:	eb002dc8 	bl	146ec <__aeabi_dsub>
                R1 += VR1[dir] * VR1[dir];
    8fc8:	e1a02000 	mov	r2, r0
    8fcc:	e1a03001 	mov	r3, r1
            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
    8fd0:	e1cd03f0 	strd	r0, [sp, #48]	; 0x30
                R1 += VR1[dir] * VR1[dir];
    8fd4:	eb002ec9 	bl	14b00 <__aeabi_dmul>
    8fd8:	e1a02000 	mov	r2, r0
    8fdc:	e1a03001 	mov	r3, r1
    8fe0:	e1cd02d0 	ldrd	r0, [sp, #32]
    8fe4:	eb002dc1 	bl	146f0 <__adddf3>
                VR2[dir] = temp_p[O] - temp_p[H2];
    8fe8:	e1a0200a 	mov	r2, sl
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
                R1 += VR1[dir] * VR1[dir];
    8fec:	e1cd02f0 	strd	r0, [sp, #32]
                VR2[dir] = temp_p[O] - temp_p[H2];
    8ff0:	e1a0300b 	mov	r3, fp
    8ff4:	e1a00004 	mov	r0, r4
    8ff8:	e1a01005 	mov	r1, r5
    8ffc:	eb002dba 	bl	146ec <__aeabi_dsub>
                R2 += VR2[dir] * VR2[dir];
    9000:	e1a02000 	mov	r2, r0
    9004:	e1a03001 	mov	r3, r1
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
                R1 += VR1[dir] * VR1[dir];
                VR2[dir] = temp_p[O] - temp_p[H2];
    9008:	e1cd05f8 	strd	r0, [sp, #88]	; 0x58
                R2 += VR2[dir] * VR2[dir];
    900c:	eb002ebb 	bl	14b00 <__aeabi_dmul>
    9010:	e1a02000 	mov	r2, r0
    9014:	e1a03001 	mov	r3, r1
    9018:	e1cd02d8 	ldrd	r0, [sp, #40]	; 0x28
    901c:	eb002db3 	bl	146f0 <__adddf3>
                SUM += VR1[dir] * VR2[dir];
    9020:	e1cd25d8 	ldrd	r2, [sp, #88]	; 0x58
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
                R1 += VR1[dir] * VR1[dir];
                VR2[dir] = temp_p[O] - temp_p[H2];
                R2 += VR2[dir] * VR2[dir];
    9024:	e1cd02f8 	strd	r0, [sp, #40]	; 0x28
                SUM += VR1[dir] * VR2[dir];
    9028:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
    902c:	eb002eb3 	bl	14b00 <__aeabi_dmul>
    9030:	e1a02000 	mov	r2, r0
    9034:	e1a03001 	mov	r3, r1
    9038:	e1cd00d8 	ldrd	r0, [sp, #8]
    903c:	eb002dab 	bl	146f0 <__adddf3>

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    9040:	e59dc0f0 	ldr	ip, [sp, #240]	; 0xf0
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
                R1 += VR1[dir] * VR1[dir];
                VR2[dir] = temp_p[O] - temp_p[H2];
                R2 += VR2[dir] * VR2[dir];
                SUM += VR1[dir] * VR2[dir];
    9044:	e1cd04f8 	strd	r0, [sp, #72]	; 0x48

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    9048:	e1cc45d0 	ldrd	r4, [ip, #80]	; 0x50
    904c:	e1cd00d0 	ldrd	r0, [sp]
    9050:	e1a02004 	mov	r2, r4
                    + C2 * (temp_p[H1] +
    9054:	e1cc64d8 	ldrd	r6, [ip, #72]	; 0x48
                            temp_p[H2] );
    9058:	e1cca5d8 	ldrd	sl, [ip, #88]	; 0x58

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    905c:	e1a03005 	mov	r3, r5
    9060:	eb002ea6 	bl	14b00 <__aeabi_dmul>
                    + C2 * (temp_p[H1] +
    9064:	e1a0200a 	mov	r2, sl

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    9068:	e1a08000 	mov	r8, r0
    906c:	e1a09001 	mov	r9, r1
                    + C2 * (temp_p[H1] +
    9070:	e1a0300b 	mov	r3, fp
    9074:	e1a00006 	mov	r0, r6
    9078:	e1a01007 	mov	r1, r7
    907c:	eb002d9b 	bl	146f0 <__adddf3>
    9080:	e1a02000 	mov	r2, r0
    9084:	e1a03001 	mov	r3, r1
    9088:	e1cd01d8 	ldrd	r0, [sp, #24]
    908c:	eb002e9b 	bl	14b00 <__aeabi_dmul>
    9090:	e1a02000 	mov	r2, r0
    9094:	e1a03001 	mov	r3, r1
    9098:	e1a00008 	mov	r0, r8
    909c:	e1a01009 	mov	r1, r9
    90a0:	eb002d92 	bl	146f0 <__adddf3>

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    90a4:	e59dc0f0 	ldr	ip, [sp, #240]	; 0xf0
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
    90a8:	e1a02006 	mov	r2, r6

            /* loop through the three directions */

            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
    90ac:	e1cc01f0 	strd	r0, [ip, #16]
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
    90b0:	e1a03007 	mov	r3, r7
    90b4:	e1a00004 	mov	r0, r4
    90b8:	e1a01005 	mov	r1, r5
    90bc:	eb002d8a 	bl	146ec <__aeabi_dsub>
                R1 += VR1[dir] * VR1[dir];
    90c0:	e1a02000 	mov	r2, r0
    90c4:	e1a03001 	mov	r3, r1
            for (dir=XDIR; dir<=ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
    90c8:	e1cd06f0 	strd	r0, [sp, #96]	; 0x60
                R1 += VR1[dir] * VR1[dir];
    90cc:	eb002e8b 	bl	14b00 <__aeabi_dmul>
    90d0:	e1a02000 	mov	r2, r0
    90d4:	e1a03001 	mov	r3, r1
    90d8:	e1cd02d0 	ldrd	r0, [sp, #32]
    90dc:	eb002d83 	bl	146f0 <__adddf3>
                VR2[dir] = temp_p[O] - temp_p[H2];
    90e0:	e1a0200a 	mov	r2, sl
                temp_p = curr_ptr->mol.F[DISP][dir];
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
                R1 += VR1[dir] * VR1[dir];
    90e4:	e1a06000 	mov	r6, r0
    90e8:	e1a07001 	mov	r7, r1
                VR2[dir] = temp_p[O] - temp_p[H2];
    90ec:	e1a0300b 	mov	r3, fp
    90f0:	e1a00004 	mov	r0, r4
    90f4:	e1a01005 	mov	r1, r5
    90f8:	eb002d7b 	bl	146ec <__aeabi_dsub>
                R2 += VR2[dir] * VR2[dir];
    90fc:	e1a02000 	mov	r2, r0
    9100:	e1a03001 	mov	r3, r1
                curr_ptr->mol.VM[dir] = C1 * temp_p[O]
                    + C2 * (temp_p[H1] +
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
                R1 += VR1[dir] * VR1[dir];
                VR2[dir] = temp_p[O] - temp_p[H2];
    9104:	e1cd06f8 	strd	r0, [sp, #104]	; 0x68
                R2 += VR2[dir] * VR2[dir];
    9108:	eb002e7c 	bl	14b00 <__aeabi_dmul>
    910c:	e1a02000 	mov	r2, r0
    9110:	e1a03001 	mov	r3, r1
    9114:	e1cd02d8 	ldrd	r0, [sp, #40]	; 0x28
    9118:	eb002d74 	bl	146f0 <__adddf3>
    911c:	e1a04000 	mov	r4, r0
    9120:	e1a05001 	mov	r5, r1
                SUM += VR1[dir] * VR2[dir];
            } /* for dir */

            R1=sqrt(R1);
    9124:	e1a00006 	mov	r0, r6
    9128:	e1a01007 	mov	r1, r7
    912c:	eb00855f 	bl	2a6b0 <sqrt>
    9130:	e1a08000 	mov	r8, r0
    9134:	e1a09001 	mov	r9, r1
            R2=sqrt(R2);
    9138:	e1a00004 	mov	r0, r4
    913c:	e1a01005 	mov	r1, r5
    9140:	eb00855a 	bl	2a6b0 <sqrt>
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
                R1 += VR1[dir] * VR1[dir];
                VR2[dir] = temp_p[O] - temp_p[H2];
                R2 += VR2[dir] * VR2[dir];
                SUM += VR1[dir] * VR2[dir];
    9144:	e1cd26d8 	ldrd	r2, [sp, #104]	; 0x68
            } /* for dir */

            R1=sqrt(R1);
            R2=sqrt(R2);
    9148:	e1cd00f8 	strd	r0, [sp, #8]
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
                R1 += VR1[dir] * VR1[dir];
                VR2[dir] = temp_p[O] - temp_p[H2];
                R2 += VR2[dir] * VR2[dir];
                SUM += VR1[dir] * VR2[dir];
    914c:	e1cd06d0 	ldrd	r0, [sp, #96]	; 0x60
    9150:	eb002e6a 	bl	14b00 <__aeabi_dmul>
    9154:	e1a02000 	mov	r2, r0
    9158:	e1a03001 	mov	r3, r1
    915c:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    9160:	eb002d62 	bl	146f0 <__adddf3>
            R1=sqrt(R1);
            R2=sqrt(R2);

            /*calc cos(THETA), sin(THETA), delta(R1), delta(R2), delta(THETA)*/

            COS=SUM/(R1*R2);
    9164:	e1cd20d8 	ldrd	r2, [sp, #8]
                            temp_p[H2] );
                VR1[dir] = temp_p[O] - temp_p[H1];
                R1 += VR1[dir] * VR1[dir];
                VR2[dir] = temp_p[O] - temp_p[H2];
                R2 += VR2[dir] * VR2[dir];
                SUM += VR1[dir] * VR2[dir];
    9168:	e1a04000 	mov	r4, r0
    916c:	e1a05001 	mov	r5, r1
            R1=sqrt(R1);
            R2=sqrt(R2);

            /*calc cos(THETA), sin(THETA), delta(R1), delta(R2), delta(THETA)*/

            COS=SUM/(R1*R2);
    9170:	e1a00008 	mov	r0, r8
    9174:	e1a01009 	mov	r1, r9
    9178:	eb002e60 	bl	14b00 <__aeabi_dmul>
    917c:	e1a02000 	mov	r2, r0
    9180:	e1a03001 	mov	r3, r1
    9184:	e1a00004 	mov	r0, r4
    9188:	e1a01005 	mov	r1, r5
    918c:	eb002eff 	bl	14d90 <__aeabi_ddiv>
            SIN=sqrt(ONE-COS*COS);
    9190:	e1a02000 	mov	r2, r0
    9194:	e1a03001 	mov	r3, r1
            R1=sqrt(R1);
            R2=sqrt(R2);

            /*calc cos(THETA), sin(THETA), delta(R1), delta(R2), delta(THETA)*/

            COS=SUM/(R1*R2);
    9198:	e1cd01f8 	strd	r0, [sp, #24]
            SIN=sqrt(ONE-COS*COS);
    919c:	eb002e57 	bl	14b00 <__aeabi_dmul>
    91a0:	e1a02000 	mov	r2, r0
    91a4:	e1a03001 	mov	r3, r1
    91a8:	e3a00000 	mov	r0, #0
    91ac:	e59f190c 	ldr	r1, [pc, #2316]	; 9ac0 <INTRAF+0xcc8>
    91b0:	eb002d4d 	bl	146ec <__aeabi_dsub>
    91b4:	eb00853d 	bl	2a6b0 <sqrt>
    91b8:	e1cd07f0 	strd	r0, [sp, #112]	; 0x70
            DT=(acos(COS)-ANGLE)*ROH;
    91bc:	e1cd01d8 	ldrd	r0, [sp, #24]
    91c0:	eb008213 	bl	29a14 <acos>
    91c4:	e59fc8f8 	ldr	ip, [pc, #2296]	; 9ac4 <INTRAF+0xccc>
    91c8:	e59fe8f8 	ldr	lr, [pc, #2296]	; 9ac8 <INTRAF+0xcd0>
    91cc:	e1cc20d0 	ldrd	r2, [ip]
    91d0:	e1ce40d0 	ldrd	r4, [lr]
    91d4:	eb002d44 	bl	146ec <__aeabi_dsub>
    91d8:	e1a02004 	mov	r2, r4
    91dc:	e1a03005 	mov	r3, r5
    91e0:	eb002e46 	bl	14b00 <__aeabi_dmul>
            DTS=DT*DT;
    91e4:	e1a02000 	mov	r2, r0
    91e8:	e1a03001 	mov	r3, r1

            /*calc cos(THETA), sin(THETA), delta(R1), delta(R2), delta(THETA)*/

            COS=SUM/(R1*R2);
            SIN=sqrt(ONE-COS*COS);
            DT=(acos(COS)-ANGLE)*ROH;
    91ec:	e1cd00f0 	strd	r0, [sp]
            DTS=DT*DT;
    91f0:	eb002e42 	bl	14b00 <__aeabi_dmul>
            DR1=R1-ROH;
    91f4:	e1a02004 	mov	r2, r4
            /*calc cos(THETA), sin(THETA), delta(R1), delta(R2), delta(THETA)*/

            COS=SUM/(R1*R2);
            SIN=sqrt(ONE-COS*COS);
            DT=(acos(COS)-ANGLE)*ROH;
            DTS=DT*DT;
    91f8:	e1cd04f8 	strd	r0, [sp, #72]	; 0x48
            DR1=R1-ROH;
    91fc:	e1a03005 	mov	r3, r5
    9200:	e1a00008 	mov	r0, r8
    9204:	e1a01009 	mov	r1, r9
    9208:	eb002d37 	bl	146ec <__aeabi_dsub>
            DR1S=DR1*DR1;
    920c:	e1a02000 	mov	r2, r0
    9210:	e1a03001 	mov	r3, r1

            COS=SUM/(R1*R2);
            SIN=sqrt(ONE-COS*COS);
            DT=(acos(COS)-ANGLE)*ROH;
            DTS=DT*DT;
            DR1=R1-ROH;
    9214:	e1a0a000 	mov	sl, r0
    9218:	e1a0b001 	mov	fp, r1
            DR1S=DR1*DR1;
    921c:	eb002e37 	bl	14b00 <__aeabi_dmul>
            DR2=R2-ROH;
    9220:	e1a02004 	mov	r2, r4
    9224:	e1a03005 	mov	r3, r5
            COS=SUM/(R1*R2);
            SIN=sqrt(ONE-COS*COS);
            DT=(acos(COS)-ANGLE)*ROH;
            DTS=DT*DT;
            DR1=R1-ROH;
            DR1S=DR1*DR1;
    9228:	e1cd02f0 	strd	r0, [sp, #32]
            DR2=R2-ROH;
    922c:	e1cd00d8 	ldrd	r0, [sp, #8]
    9230:	eb002d2d 	bl	146ec <__aeabi_dsub>
            DR2S=DR2*DR2;
    9234:	e1a02000 	mov	r2, r0
    9238:	e1a03001 	mov	r3, r1
            SIN=sqrt(ONE-COS*COS);
            DT=(acos(COS)-ANGLE)*ROH;
            DTS=DT*DT;
            DR1=R1-ROH;
            DR1S=DR1*DR1;
            DR2=R2-ROH;
    923c:	e1a06000 	mov	r6, r0
    9240:	e1a07001 	mov	r7, r1
            DR2S=DR2*DR2;
    9244:	eb002e2d 	bl	14b00 <__aeabi_dmul>

            /* calculate derivatives of R1/X1, R2/X3, THETA/X1, and THETA/X3 */

            R1S=ROH/(R1*SIN);
    9248:	e1cd27d0 	ldrd	r2, [sp, #112]	; 0x70
            DT=(acos(COS)-ANGLE)*ROH;
            DTS=DT*DT;
            DR1=R1-ROH;
            DR1S=DR1*DR1;
            DR2=R2-ROH;
            DR2S=DR2*DR2;
    924c:	e1cd02f8 	strd	r0, [sp, #40]	; 0x28

            /* calculate derivatives of R1/X1, R2/X3, THETA/X1, and THETA/X3 */

            R1S=ROH/(R1*SIN);
    9250:	e1a00008 	mov	r0, r8
    9254:	e1a01009 	mov	r1, r9
    9258:	eb002e28 	bl	14b00 <__aeabi_dmul>
    925c:	e1a02000 	mov	r2, r0
    9260:	e1a03001 	mov	r3, r1
    9264:	e1a00004 	mov	r0, r4
    9268:	e1a01005 	mov	r1, r5
    926c:	eb002ec7 	bl	14d90 <__aeabi_ddiv>
            R2S=ROH/(R2*SIN);
    9270:	e1cd27d0 	ldrd	r2, [sp, #112]	; 0x70
            DR2=R2-ROH;
            DR2S=DR2*DR2;

            /* calculate derivatives of R1/X1, R2/X3, THETA/X1, and THETA/X3 */

            R1S=ROH/(R1*SIN);
    9274:	e1cd0af8 	strd	r0, [sp, #168]	; 0xa8
            R2S=ROH/(R2*SIN);
    9278:	e1cd00d8 	ldrd	r0, [sp, #8]
    927c:	eb002e1f 	bl	14b00 <__aeabi_dmul>
    9280:	e1a02000 	mov	r2, r0
    9284:	e1a03001 	mov	r3, r1
    9288:	e1a00004 	mov	r0, r4
    928c:	e1a01005 	mov	r1, r5
    9290:	eb002ebe 	bl	14d90 <__aeabi_ddiv>

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
    9294:	e1a02008 	mov	r2, r8
    9298:	e1a03009 	mov	r3, r9
            DR2S=DR2*DR2;

            /* calculate derivatives of R1/X1, R2/X3, THETA/X1, and THETA/X3 */

            R1S=ROH/(R1*SIN);
            R2S=ROH/(R2*SIN);
    929c:	e1cd07f0 	strd	r0, [sp, #112]	; 0x70

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
    92a0:	e1cd03d8 	ldrd	r0, [sp, #56]	; 0x38
    92a4:	eb002eb9 	bl	14d90 <__aeabi_ddiv>
                DR23[dir]=VR2[dir]/R2;
    92a8:	e1cd20d8 	ldrd	r2, [sp, #8]

            R1S=ROH/(R1*SIN);
            R2S=ROH/(R2*SIN);

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
    92ac:	e1cd0bf0 	strd	r0, [sp, #176]	; 0xb0
                DR23[dir]=VR2[dir]/R2;
    92b0:	e1cd01d0 	ldrd	r0, [sp, #16]
    92b4:	eb002eb5 	bl	14d90 <__aeabi_ddiv>

            R1S=ROH/(R1*SIN);
            R2S=ROH/(R2*SIN);

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
    92b8:	e1a02008 	mov	r2, r8
    92bc:	e1a03009 	mov	r3, r9
                DR23[dir]=VR2[dir]/R2;
    92c0:	e1cd0bf8 	strd	r0, [sp, #184]	; 0xb8

            R1S=ROH/(R1*SIN);
            R2S=ROH/(R2*SIN);

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
    92c4:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
    92c8:	eb002eb0 	bl	14d90 <__aeabi_ddiv>
                DR23[dir]=VR2[dir]/R2;
    92cc:	e1cd20d8 	ldrd	r2, [sp, #8]

            R1S=ROH/(R1*SIN);
            R2S=ROH/(R2*SIN);

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
    92d0:	e1cd0cf0 	strd	r0, [sp, #192]	; 0xc0
                DR23[dir]=VR2[dir]/R2;
    92d4:	e1cd05d8 	ldrd	r0, [sp, #88]	; 0x58
    92d8:	eb002eac 	bl	14d90 <__aeabi_ddiv>

            R1S=ROH/(R1*SIN);
            R2S=ROH/(R2*SIN);

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
    92dc:	e1a02008 	mov	r2, r8
    92e0:	e1a03009 	mov	r3, r9
                DR23[dir]=VR2[dir]/R2;
    92e4:	e1cd05f8 	strd	r0, [sp, #88]	; 0x58

            R1S=ROH/(R1*SIN);
            R2S=ROH/(R2*SIN);

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
    92e8:	e1cd06d0 	ldrd	r0, [sp, #96]	; 0x60
    92ec:	eb002ea7 	bl	14d90 <__aeabi_ddiv>
                DR23[dir]=VR2[dir]/R2;
    92f0:	e1cd20d8 	ldrd	r2, [sp, #8]

            R1S=ROH/(R1*SIN);
            R2S=ROH/(R2*SIN);

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
    92f4:	e1cd06f0 	strd	r0, [sp, #96]	; 0x60
                DR23[dir]=VR2[dir]/R2;
    92f8:	e1cd06d8 	ldrd	r0, [sp, #104]	; 0x68
    92fc:	eb002ea3 	bl	14d90 <__aeabi_ddiv>
                DT3[dir]=(-DR11[dir]+DR23[dir]*COS)*R2S;
            } /* for dir */

            /* calculate forces */

            F1=FC11*DR1+FC12*DR2+FC13*DT;
    9300:	e59fe7c4 	ldr	lr, [pc, #1988]	; 9acc <INTRAF+0xcd4>
            R1S=ROH/(R1*SIN);
            R2S=ROH/(R2*SIN);

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
                DR23[dir]=VR2[dir]/R2;
    9304:	e1cd06f8 	strd	r0, [sp, #104]	; 0x68
                DT3[dir]=(-DR11[dir]+DR23[dir]*COS)*R2S;
            } /* for dir */

            /* calculate forces */

            F1=FC11*DR1+FC12*DR2+FC13*DT;
    9308:	e1ce40d0 	ldrd	r4, [lr]
    930c:	e59f17bc 	ldr	r1, [pc, #1980]	; 9ad0 <INTRAF+0xcd8>
    9310:	e59f37bc 	ldr	r3, [pc, #1980]	; 9ad4 <INTRAF+0xcdc>
    9314:	e1c100d0 	ldrd	r0, [r1]
    9318:	e1c320d0 	ldrd	r2, [r3]
    931c:	e1cd00f8 	strd	r0, [sp, #8]
    9320:	e1cd21f0 	strd	r2, [sp, #16]
    9324:	e1cd20d0 	ldrd	r2, [sp]
    9328:	e1a00004 	mov	r0, r4
    932c:	e1a01005 	mov	r1, r5
    9330:	eb002df2 	bl	14b00 <__aeabi_dmul>
    9334:	e1a0200a 	mov	r2, sl
    9338:	e1a08000 	mov	r8, r0
    933c:	e1a09001 	mov	r9, r1
    9340:	e1cd00d8 	ldrd	r0, [sp, #8]
    9344:	e1a0300b 	mov	r3, fp
    9348:	eb002dec 	bl	14b00 <__aeabi_dmul>
    934c:	e1a02006 	mov	r2, r6
    9350:	e1a03007 	mov	r3, r7
    9354:	e1cd03f8 	strd	r0, [sp, #56]	; 0x38
    9358:	e1cd01d0 	ldrd	r0, [sp, #16]
    935c:	eb002de7 	bl	14b00 <__aeabi_dmul>
    9360:	e1a02000 	mov	r2, r0
    9364:	e1a03001 	mov	r3, r1
    9368:	e1cd03d8 	ldrd	r0, [sp, #56]	; 0x38
    936c:	eb002cdf 	bl	146f0 <__adddf3>
    9370:	e1a02008 	mov	r2, r8
    9374:	e1a03009 	mov	r3, r9
    9378:	eb002cdc 	bl	146f0 <__adddf3>
            F2=FC33*DT +FC13*(DR1+DR2);
    937c:	e1a02006 	mov	r2, r6
                DT3[dir]=(-DR11[dir]+DR23[dir]*COS)*R2S;
            } /* for dir */

            /* calculate forces */

            F1=FC11*DR1+FC12*DR2+FC13*DT;
    9380:	e1cd09f0 	strd	r0, [sp, #144]	; 0x90
            F2=FC33*DT +FC13*(DR1+DR2);
    9384:	e1a03007 	mov	r3, r7
    9388:	e1a0000a 	mov	r0, sl
    938c:	e1a0100b 	mov	r1, fp
    9390:	eb002cd6 	bl	146f0 <__adddf3>
    9394:	e59fc73c 	ldr	ip, [pc, #1852]	; 9ad8 <INTRAF+0xce0>
    9398:	e1cd03f8 	strd	r0, [sp, #56]	; 0x38
    939c:	e1cc20d0 	ldrd	r2, [ip]
    93a0:	e1cd00d0 	ldrd	r0, [sp]
    93a4:	eb002dd5 	bl	14b00 <__aeabi_dmul>
    93a8:	e1cd23d8 	ldrd	r2, [sp, #56]	; 0x38
    93ac:	e1cd03f0 	strd	r0, [sp, #48]	; 0x30
    93b0:	e1a00004 	mov	r0, r4
    93b4:	e1a01005 	mov	r1, r5
    93b8:	eb002dd0 	bl	14b00 <__aeabi_dmul>
    93bc:	e1a02000 	mov	r2, r0
    93c0:	e1a03001 	mov	r3, r1
    93c4:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
    93c8:	eb002cc8 	bl	146f0 <__adddf3>
            F3=FC11*DR2+FC12*DR1+FC13*DT;
    93cc:	e1cd20d8 	ldrd	r2, [sp, #8]
            } /* for dir */

            /* calculate forces */

            F1=FC11*DR1+FC12*DR2+FC13*DT;
            F2=FC33*DT +FC13*(DR1+DR2);
    93d0:	e1cd09f8 	strd	r0, [sp, #152]	; 0x98
            F3=FC11*DR2+FC12*DR1+FC13*DT;
    93d4:	e1a00006 	mov	r0, r6
    93d8:	e1a01007 	mov	r1, r7
    93dc:	eb002dc7 	bl	14b00 <__aeabi_dmul>
    93e0:	e1cd21d0 	ldrd	r2, [sp, #16]
    93e4:	e1a04000 	mov	r4, r0
    93e8:	e1a05001 	mov	r5, r1
    93ec:	e1a0000a 	mov	r0, sl
    93f0:	e1a0100b 	mov	r1, fp
    93f4:	eb002dc1 	bl	14b00 <__aeabi_dmul>
    93f8:	e1a02000 	mov	r2, r0
    93fc:	e1a03001 	mov	r3, r1
    9400:	e1a00004 	mov	r0, r4
    9404:	e1a01005 	mov	r1, r5
    9408:	eb002cb8 	bl	146f0 <__adddf3>
    940c:	e1a02000 	mov	r2, r0
    9410:	e1a03001 	mov	r3, r1
    9414:	e1a00008 	mov	r0, r8
    9418:	e1a01009 	mov	r1, r9
    941c:	eb002cb3 	bl	146f0 <__adddf3>
            F1=F1+(3.0*FC111*DR1S+FC112*(2.0*DR1+DR2)*DR2
    9420:	e59fe6b4 	ldr	lr, [pc, #1716]	; 9adc <INTRAF+0xce4>

            /* calculate forces */

            F1=FC11*DR1+FC12*DR2+FC13*DT;
            F2=FC33*DT +FC13*(DR1+DR2);
            F3=FC11*DR2+FC12*DR1+FC13*DT;
    9424:	e1cd0af0 	strd	r0, [sp, #160]	; 0xa0
            F1=F1+(3.0*FC111*DR1S+FC112*(2.0*DR1+DR2)*DR2
    9428:	e1ce00d0 	ldrd	r0, [lr]
    942c:	e3a02000 	mov	r2, #0
    9430:	e59f36ec 	ldr	r3, [pc, #1772]	; 9b24 <INTRAF+0xd2c>
    9434:	eb002db1 	bl	14b00 <__aeabi_dmul>
    9438:	e1a0200a 	mov	r2, sl
    943c:	e1cd07f8 	strd	r0, [sp, #120]	; 0x78
    9440:	e1a0300b 	mov	r3, fp
    9444:	e1a0000a 	mov	r0, sl
    9448:	e1a0100b 	mov	r1, fp
    944c:	eb002ca7 	bl	146f0 <__adddf3>
    9450:	e1a02006 	mov	r2, r6
    9454:	e1a03007 	mov	r3, r7
    9458:	eb002ca4 	bl	146f0 <__adddf3>
    945c:	e59f367c 	ldr	r3, [pc, #1660]	; 9ae0 <INTRAF+0xce8>
    9460:	e1cd05f0 	strd	r0, [sp, #80]	; 0x50
    9464:	e1c320d0 	ldrd	r2, [r3]
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
    9468:	e59f0674 	ldr	r0, [pc, #1652]	; 9ae4 <INTRAF+0xcec>
    946c:	e1c040d0 	ldrd	r4, [r0]
            /* calculate forces */

            F1=FC11*DR1+FC12*DR2+FC13*DT;
            F2=FC33*DT +FC13*(DR1+DR2);
            F3=FC11*DR2+FC12*DR1+FC13*DT;
            F1=F1+(3.0*FC111*DR1S+FC112*(2.0*DR1+DR2)*DR2
    9470:	e1cd21f0 	strd	r2, [sp, #16]
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
    9474:	e1a00004 	mov	r0, r4
    9478:	e1a02004 	mov	r2, r4
    947c:	e1a03005 	mov	r3, r5
    9480:	e1a01005 	mov	r1, r5
    9484:	eb002c99 	bl	146f0 <__adddf3>
    9488:	e59f2658 	ldr	r2, [pc, #1624]	; 9ae8 <INTRAF+0xcf0>
    948c:	e1cd08f0 	strd	r0, [sp, #128]	; 0x80
    9490:	e1c280d0 	ldrd	r8, [r2]
    9494:	e1cd24d8 	ldrd	r2, [sp, #72]	; 0x48
    9498:	e59f164c 	ldr	r1, [pc, #1612]	; 9aec <INTRAF+0xcf4>
    949c:	e1c100d0 	ldrd	r0, [r1]
    94a0:	e1cd03f0 	strd	r0, [sp, #48]	; 0x30
    94a4:	eb002d95 	bl	14b00 <__aeabi_dmul>
            /* calculate forces */

            F1=FC11*DR1+FC12*DR2+FC13*DT;
            F2=FC33*DT +FC13*(DR1+DR2);
            F3=FC11*DR2+FC12*DR1+FC13*DT;
            F1=F1+(3.0*FC111*DR1S+FC112*(2.0*DR1+DR2)*DR2
    94a8:	e1cd22d0 	ldrd	r2, [sp, #32]
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
    94ac:	e1cd08f8 	strd	r0, [sp, #136]	; 0x88
    94b0:	e59f1638 	ldr	r1, [pc, #1592]	; 9af0 <INTRAF+0xcf8>
    94b4:	e1c100d0 	ldrd	r0, [r1]
    94b8:	e1cd00f8 	strd	r0, [sp, #8]
            /* calculate forces */

            F1=FC11*DR1+FC12*DR2+FC13*DT;
            F2=FC33*DT +FC13*(DR1+DR2);
            F3=FC11*DR2+FC12*DR1+FC13*DT;
            F1=F1+(3.0*FC111*DR1S+FC112*(2.0*DR1+DR2)*DR2
    94bc:	e1cd07d8 	ldrd	r0, [sp, #120]	; 0x78
    94c0:	eb002d8e 	bl	14b00 <__aeabi_dmul>
    94c4:	e1cd21d0 	ldrd	r2, [sp, #16]
    94c8:	e1cd04f0 	strd	r0, [sp, #64]	; 0x40
    94cc:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    94d0:	eb002d8a 	bl	14b00 <__aeabi_dmul>
    94d4:	e1a02006 	mov	r2, r6
    94d8:	e1a03007 	mov	r3, r7
    94dc:	eb002d87 	bl	14b00 <__aeabi_dmul>
    94e0:	e1a02000 	mov	r2, r0
    94e4:	e1a03001 	mov	r3, r1
    94e8:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    94ec:	eb002c7f 	bl	146f0 <__adddf3>
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
    94f0:	e1a0200a 	mov	r2, sl
    94f4:	e1a0300b 	mov	r3, fp
            /* calculate forces */

            F1=FC11*DR1+FC12*DR2+FC13*DT;
            F2=FC33*DT +FC13*(DR1+DR2);
            F3=FC11*DR2+FC12*DR1+FC13*DT;
            F1=F1+(3.0*FC111*DR1S+FC112*(2.0*DR1+DR2)*DR2
    94f8:	e1cd04f0 	strd	r0, [sp, #64]	; 0x40
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
    94fc:	e1cd08d0 	ldrd	r0, [sp, #128]	; 0x80
    9500:	eb002d7e 	bl	14b00 <__aeabi_dmul>
    9504:	e1cd20d0 	ldrd	r2, [sp]
    9508:	eb002d7c 	bl	14b00 <__aeabi_dmul>
    950c:	e1a02000 	mov	r2, r0
    9510:	e1a03001 	mov	r3, r1
    9514:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    9518:	eb002c74 	bl	146f0 <__adddf3>
    951c:	e1a02006 	mov	r2, r6
    9520:	e1cd04f0 	strd	r0, [sp, #64]	; 0x40
    9524:	e1a03007 	mov	r3, r7
    9528:	e1a00008 	mov	r0, r8
    952c:	e1a01009 	mov	r1, r9
    9530:	eb002d72 	bl	14b00 <__aeabi_dmul>
    9534:	e1cd20d0 	ldrd	r2, [sp]
    9538:	eb002d70 	bl	14b00 <__aeabi_dmul>
    953c:	e1a02000 	mov	r2, r0
    9540:	e1a03001 	mov	r3, r1
    9544:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    9548:	eb002c68 	bl	146f0 <__adddf3>
    954c:	e1cd28d8 	ldrd	r2, [sp, #136]	; 0x88
    9550:	eb002c66 	bl	146f0 <__adddf3>
    9554:	e1cd20d8 	ldrd	r2, [sp, #8]
    9558:	eb002d68 	bl	14b00 <__aeabi_dmul>
            /* calculate forces */

            F1=FC11*DR1+FC12*DR2+FC13*DT;
            F2=FC33*DT +FC13*(DR1+DR2);
            F3=FC11*DR2+FC12*DR1+FC13*DT;
            F1=F1+(3.0*FC111*DR1S+FC112*(2.0*DR1+DR2)*DR2
    955c:	e1cd29d0 	ldrd	r2, [sp, #144]	; 0x90
    9560:	eb002c62 	bl	146f0 <__adddf3>
    9564:	e1cd0cf8 	strd	r0, [sp, #200]	; 0xc8
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
    9568:	e1cd02d0 	ldrd	r0, [sp, #32]
    956c:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
    9570:	eb002c5e 	bl	146f0 <__adddf3>
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
    9574:	e1a02008 	mov	r2, r8
            F1=FC11*DR1+FC12*DR2+FC13*DT;
            F2=FC33*DT +FC13*(DR1+DR2);
            F3=FC11*DR2+FC12*DR1+FC13*DT;
            F1=F1+(3.0*FC111*DR1S+FC112*(2.0*DR1+DR2)*DR2
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
    9578:	e1cd09f0 	strd	r0, [sp, #144]	; 0x90
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
    957c:	e1a03009 	mov	r3, r9
    9580:	e1a0000a 	mov	r0, sl
    9584:	e1a0100b 	mov	r1, fp
    9588:	eb002d5c 	bl	14b00 <__aeabi_dmul>
            F1=FC11*DR1+FC12*DR2+FC13*DT;
            F2=FC33*DT +FC13*(DR1+DR2);
            F3=FC11*DR2+FC12*DR1+FC13*DT;
            F1=F1+(3.0*FC111*DR1S+FC112*(2.0*DR1+DR2)*DR2
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
    958c:	e59f2560 	ldr	r2, [pc, #1376]	; 9af4 <INTRAF+0xcfc>
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
    9590:	e1a08000 	mov	r8, r0
    9594:	e1a09001 	mov	r9, r1
            F1=FC11*DR1+FC12*DR2+FC13*DT;
            F2=FC33*DT +FC13*(DR1+DR2);
            F3=FC11*DR2+FC12*DR1+FC13*DT;
            F1=F1+(3.0*FC111*DR1S+FC112*(2.0*DR1+DR2)*DR2
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
    9598:	e1c200d0 	ldrd	r0, [r2]
    959c:	e59f3580 	ldr	r3, [pc, #1408]	; 9b24 <INTRAF+0xd2c>
    95a0:	e3a02000 	mov	r2, #0
    95a4:	eb002d55 	bl	14b00 <__aeabi_dmul>
    95a8:	e1cd24d8 	ldrd	r2, [sp, #72]	; 0x48
    95ac:	eb002d53 	bl	14b00 <__aeabi_dmul>
    95b0:	e1cd29d0 	ldrd	r2, [sp, #144]	; 0x90
    95b4:	e1cd04f0 	strd	r0, [sp, #64]	; 0x40
    95b8:	e1a00004 	mov	r0, r4
    95bc:	e1a01005 	mov	r1, r5
    95c0:	eb002d4e 	bl	14b00 <__aeabi_dmul>
    95c4:	e1a02000 	mov	r2, r0
    95c8:	e1a03001 	mov	r3, r1
    95cc:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    95d0:	eb002c46 	bl	146f0 <__adddf3>
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
    95d4:	e1a02006 	mov	r2, r6
            F1=FC11*DR1+FC12*DR2+FC13*DT;
            F2=FC33*DT +FC13*(DR1+DR2);
            F3=FC11*DR2+FC12*DR1+FC13*DT;
            F1=F1+(3.0*FC111*DR1S+FC112*(2.0*DR1+DR2)*DR2
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
    95d8:	e1a04000 	mov	r4, r0
    95dc:	e1a05001 	mov	r5, r1
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
    95e0:	e1a03007 	mov	r3, r7
    95e4:	e1a00008 	mov	r0, r8
    95e8:	e1a01009 	mov	r1, r9
    95ec:	eb002d43 	bl	14b00 <__aeabi_dmul>
    95f0:	e1a02000 	mov	r2, r0
    95f4:	e1a03001 	mov	r3, r1
    95f8:	e1a00004 	mov	r0, r4
    95fc:	e1a01005 	mov	r1, r5
    9600:	eb002c3a 	bl	146f0 <__adddf3>
    9604:	e1a04000 	mov	r4, r0
    9608:	e1a05001 	mov	r5, r1
    960c:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
    9610:	e1a02000 	mov	r2, r0
    9614:	e1a03001 	mov	r3, r1
    9618:	eb002c34 	bl	146f0 <__adddf3>
    961c:	e1a02000 	mov	r2, r0
    9620:	e1a03001 	mov	r3, r1
    9624:	e1cd03d8 	ldrd	r0, [sp, #56]	; 0x38
    9628:	eb002d34 	bl	14b00 <__aeabi_dmul>
    962c:	e1cd20d0 	ldrd	r2, [sp]
    9630:	eb002d32 	bl	14b00 <__aeabi_dmul>
    9634:	e1a02000 	mov	r2, r0
    9638:	e1a03001 	mov	r3, r1
    963c:	e1a00004 	mov	r0, r4
    9640:	e1a01005 	mov	r1, r5
    9644:	eb002c29 	bl	146f0 <__adddf3>
    9648:	e1a02000 	mov	r2, r0
    964c:	e1a03001 	mov	r3, r1
    9650:	e1cd00d8 	ldrd	r0, [sp, #8]
    9654:	eb002d29 	bl	14b00 <__aeabi_dmul>
            F1=FC11*DR1+FC12*DR2+FC13*DT;
            F2=FC33*DT +FC13*(DR1+DR2);
            F3=FC11*DR2+FC12*DR1+FC13*DT;
            F1=F1+(3.0*FC111*DR1S+FC112*(2.0*DR1+DR2)*DR2
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
    9658:	e1cd29d8 	ldrd	r2, [sp, #152]	; 0x98
    965c:	eb002c23 	bl	146f0 <__adddf3>
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
    9660:	e1a02006 	mov	r2, r6
            F1=FC11*DR1+FC12*DR2+FC13*DT;
            F2=FC33*DT +FC13*(DR1+DR2);
            F3=FC11*DR2+FC12*DR1+FC13*DT;
            F1=F1+(3.0*FC111*DR1S+FC112*(2.0*DR1+DR2)*DR2
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
    9664:	e1cd0ef0 	strd	r0, [sp, #224]	; 0xe0
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
    9668:	e1a03007 	mov	r3, r7
    966c:	e1a00006 	mov	r0, r6
    9670:	e1a01007 	mov	r1, r7
    9674:	eb002c1d 	bl	146f0 <__adddf3>
    9678:	e1a0200a 	mov	r2, sl
    967c:	e1a0300b 	mov	r3, fp
    9680:	eb002c1a 	bl	146f0 <__adddf3>
    9684:	e1cd27d8 	ldrd	r2, [sp, #120]	; 0x78
    9688:	e1cd09f8 	strd	r0, [sp, #152]	; 0x98
    968c:	e1cd02d8 	ldrd	r0, [sp, #40]	; 0x28
    9690:	eb002d1a 	bl	14b00 <__aeabi_dmul>
    9694:	e1cd29d8 	ldrd	r2, [sp, #152]	; 0x98
    9698:	e1a04000 	mov	r4, r0
    969c:	e1a05001 	mov	r5, r1
    96a0:	e1cd01d0 	ldrd	r0, [sp, #16]
    96a4:	eb002d15 	bl	14b00 <__aeabi_dmul>
    96a8:	e1a0200a 	mov	r2, sl
    96ac:	e1a0300b 	mov	r3, fp
    96b0:	eb002d12 	bl	14b00 <__aeabi_dmul>
    96b4:	e1a02000 	mov	r2, r0
    96b8:	e1a03001 	mov	r3, r1
    96bc:	e1a00004 	mov	r0, r4
    96c0:	e1a01005 	mov	r1, r5
    96c4:	eb002c09 	bl	146f0 <__adddf3>
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
    96c8:	e1cd28d0 	ldrd	r2, [sp, #128]	; 0x80
            F3=FC11*DR2+FC12*DR1+FC13*DT;
            F1=F1+(3.0*FC111*DR1S+FC112*(2.0*DR1+DR2)*DR2
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
    96cc:	e1a04000 	mov	r4, r0
    96d0:	e1a05001 	mov	r5, r1
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
    96d4:	e1a00006 	mov	r0, r6
    96d8:	e1a01007 	mov	r1, r7
    96dc:	eb002d07 	bl	14b00 <__aeabi_dmul>
    96e0:	e1cd20d0 	ldrd	r2, [sp]
    96e4:	eb002d05 	bl	14b00 <__aeabi_dmul>
    96e8:	e1a02000 	mov	r2, r0
    96ec:	e1a03001 	mov	r3, r1
    96f0:	e1a00004 	mov	r0, r4
    96f4:	e1a01005 	mov	r1, r5
    96f8:	eb002bfc 	bl	146f0 <__adddf3>
    96fc:	e1a02008 	mov	r2, r8
    9700:	e1a04000 	mov	r4, r0
    9704:	e1a05001 	mov	r5, r1
    9708:	e1cd00d0 	ldrd	r0, [sp]
    970c:	e1a03009 	mov	r3, r9
    9710:	eb002cfa 	bl	14b00 <__aeabi_dmul>
    9714:	e1a02000 	mov	r2, r0
    9718:	e1a03001 	mov	r3, r1
    971c:	e1a00004 	mov	r0, r4
    9720:	e1a01005 	mov	r1, r5
    9724:	eb002bf1 	bl	146f0 <__adddf3>
    9728:	e1a02000 	mov	r2, r0
    972c:	e1a03001 	mov	r3, r1
    9730:	e1cd08d8 	ldrd	r0, [sp, #136]	; 0x88
    9734:	eb002bed 	bl	146f0 <__adddf3>
    9738:	e1a02000 	mov	r2, r0
    973c:	e1a03001 	mov	r3, r1
    9740:	e1cd00d8 	ldrd	r0, [sp, #8]
    9744:	eb002ced 	bl	14b00 <__aeabi_dmul>
            F3=FC11*DR2+FC12*DR1+FC13*DT;
            F1=F1+(3.0*FC111*DR1S+FC112*(2.0*DR1+DR2)*DR2
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
    9748:	e1cd2ad0 	ldrd	r2, [sp, #160]	; 0xa0
    974c:	eb002be7 	bl	146f0 <__adddf3>
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
    9750:	e59f33a0 	ldr	r3, [pc, #928]	; 9af8 <INTRAF+0xd00>
            F3=FC11*DR2+FC12*DR1+FC13*DT;
            F1=F1+(3.0*FC111*DR1S+FC112*(2.0*DR1+DR2)*DR2
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
    9754:	e1cd0ef8 	strd	r0, [sp, #232]	; 0xe8
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
    9758:	e1c300d0 	ldrd	r0, [r3]
    975c:	e3a02000 	mov	r2, #0
    9760:	e59f3394 	ldr	r3, [pc, #916]	; 9afc <INTRAF+0xd04>
    9764:	eb002ce5 	bl	14b00 <__aeabi_dmul>
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
    9768:	e59fc390 	ldr	ip, [pc, #912]	; 9b00 <INTRAF+0xd08>
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
    976c:	e59f3390 	ldr	r3, [pc, #912]	; 9b04 <INTRAF+0xd0c>
    9770:	e1cd0af0 	strd	r0, [sp, #160]	; 0xa0
    9774:	e1c320d0 	ldrd	r2, [r3]
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
    9778:	e1cc00d0 	ldrd	r0, [ip]
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
    977c:	e1cd28f0 	strd	r2, [sp, #128]	; 0x80
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
    9780:	e1a02000 	mov	r2, r0
    9784:	e1a03001 	mov	r3, r1
    9788:	eb002bd8 	bl	146f0 <__adddf3>
    978c:	e59fc374 	ldr	ip, [pc, #884]	; 9b08 <INTRAF+0xd10>
    9790:	e1cd04f0 	strd	r0, [sp, #64]	; 0x40
    9794:	e1cc80d0 	ldrd	r8, [ip]
    9798:	e3a02000 	mov	r2, #0
    979c:	e59f3380 	ldr	r3, [pc, #896]	; 9b24 <INTRAF+0xd2c>
    97a0:	e1a00008 	mov	r0, r8
    97a4:	e1a01009 	mov	r1, r9
    97a8:	eb002cd4 	bl	14b00 <__aeabi_dmul>
                   +FC1123*(2.0*DR1+DR2)*DR2*DT+(2.0*FC1133*DR1
    97ac:	e59fe358 	ldr	lr, [pc, #856]	; 9b0c <INTRAF+0xd14>
    97b0:	e59f3358 	ldr	r3, [pc, #856]	; 9b10 <INTRAF+0xd18>
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
    97b4:	e1cd0df0 	strd	r0, [sp, #208]	; 0xd0
                   +FC1123*(2.0*DR1+DR2)*DR2*DT+(2.0*FC1133*DR1
    97b8:	e1c320d0 	ldrd	r2, [r3]
    97bc:	e1ce00d0 	ldrd	r0, [lr]
    97c0:	e1cd21f0 	strd	r2, [sp, #16]
    97c4:	e1a02000 	mov	r2, r0
    97c8:	e1a03001 	mov	r3, r1
    97cc:	eb002bc7 	bl	146f0 <__adddf3>
                                                 +FC1233*DR2+FC1333*DT)*DTS)*ROHI2;
    97d0:	e59f333c 	ldr	r3, [pc, #828]	; 9b14 <INTRAF+0xd1c>
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
                   +FC1123*(2.0*DR1+DR2)*DR2*DT+(2.0*FC1133*DR1
    97d4:	e1cd07f8 	strd	r0, [sp, #120]	; 0x78
                                                 +FC1233*DR2+FC1333*DT)*DTS)*ROHI2;
    97d8:	e1c320d0 	ldrd	r2, [r3]
    97dc:	e59f1334 	ldr	r1, [pc, #820]	; 9b18 <INTRAF+0xd20>
    97e0:	e1cd28f8 	strd	r2, [sp, #136]	; 0x88
    97e4:	e1c100d0 	ldrd	r0, [r1]
    97e8:	e1cd20d0 	ldrd	r2, [sp]
    97ec:	e1cd00f8 	strd	r0, [sp, #8]
    97f0:	e1cd08d8 	ldrd	r0, [sp, #136]	; 0x88
    97f4:	eb002cc1 	bl	14b00 <__aeabi_dmul>
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
    97f8:	e1cd22d0 	ldrd	r2, [sp, #32]
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
                   +FC1123*(2.0*DR1+DR2)*DR2*DT+(2.0*FC1133*DR1
                                                 +FC1233*DR2+FC1333*DT)*DTS)*ROHI2;
    97fc:	e1cd0df8 	strd	r0, [sp, #216]	; 0xd8
    9800:	e59f1314 	ldr	r1, [pc, #788]	; 9b1c <INTRAF+0xd24>
    9804:	e1c100d0 	ldrd	r0, [r1]
    9808:	e1cd03f0 	strd	r0, [sp, #48]	; 0x30
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
    980c:	e1cd0ad0 	ldrd	r0, [sp, #160]	; 0xa0
    9810:	eb002cba 	bl	14b00 <__aeabi_dmul>
    9814:	e1a0200a 	mov	r2, sl
    9818:	e1a0300b 	mov	r3, fp
    981c:	eb002cb7 	bl	14b00 <__aeabi_dmul>
    9820:	e3a02000 	mov	r2, #0
    9824:	e1a04000 	mov	r4, r0
    9828:	e1a05001 	mov	r5, r1
    982c:	e1cd02d0 	ldrd	r0, [sp, #32]
    9830:	e59f32ec 	ldr	r3, [pc, #748]	; 9b24 <INTRAF+0xd2c>
    9834:	eb002cb1 	bl	14b00 <__aeabi_dmul>
    9838:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
    983c:	eb002bab 	bl	146f0 <__adddf3>
    9840:	e1cd28d0 	ldrd	r2, [sp, #128]	; 0x80
    9844:	eb002cad 	bl	14b00 <__aeabi_dmul>
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
    9848:	e1a02006 	mov	r2, r6
    984c:	e1a03007 	mov	r3, r7
    9850:	eb002caa 	bl	14b00 <__aeabi_dmul>
    9854:	e1a02000 	mov	r2, r0
    9858:	e1a03001 	mov	r3, r1
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
    985c:	e1a00004 	mov	r0, r4
    9860:	e1a01005 	mov	r1, r5
    9864:	eb002ba1 	bl	146f0 <__adddf3>
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
    9868:	e1a0200a 	mov	r2, sl
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
    986c:	e1a04000 	mov	r4, r0
    9870:	e1a05001 	mov	r5, r1
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
    9874:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    9878:	e1a0300b 	mov	r3, fp
    987c:	eb002c9f 	bl	14b00 <__aeabi_dmul>
    9880:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
    9884:	eb002c9d 	bl	14b00 <__aeabi_dmul>
    9888:	e1a02000 	mov	r2, r0
    988c:	e1a03001 	mov	r3, r1
    9890:	e1a00004 	mov	r0, r4
    9894:	e1a01005 	mov	r1, r5
    9898:	eb002b94 	bl	146f0 <__adddf3>
    989c:	e1cd22d0 	ldrd	r2, [sp, #32]
    98a0:	e1a04000 	mov	r4, r0
    98a4:	e1a05001 	mov	r5, r1
    98a8:	e1cd0dd0 	ldrd	r0, [sp, #208]	; 0xd0
    98ac:	eb002c93 	bl	14b00 <__aeabi_dmul>
    98b0:	e1cd20d0 	ldrd	r2, [sp]
    98b4:	eb002c91 	bl	14b00 <__aeabi_dmul>
    98b8:	e1a02000 	mov	r2, r0
    98bc:	e1a03001 	mov	r3, r1
    98c0:	e1a00004 	mov	r0, r4
    98c4:	e1a01005 	mov	r1, r5
    98c8:	eb002b88 	bl	146f0 <__adddf3>
                   +FC1123*(2.0*DR1+DR2)*DR2*DT+(2.0*FC1133*DR1
    98cc:	e1cd21d0 	ldrd	r2, [sp, #16]
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
    98d0:	e1a04000 	mov	r4, r0
    98d4:	e1a05001 	mov	r5, r1
                   +FC1123*(2.0*DR1+DR2)*DR2*DT+(2.0*FC1133*DR1
    98d8:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    98dc:	eb002c87 	bl	14b00 <__aeabi_dmul>
    98e0:	e1a02006 	mov	r2, r6
    98e4:	e1a03007 	mov	r3, r7
    98e8:	eb002c84 	bl	14b00 <__aeabi_dmul>
    98ec:	e1cd20d0 	ldrd	r2, [sp]
    98f0:	eb002c82 	bl	14b00 <__aeabi_dmul>
    98f4:	e1a02000 	mov	r2, r0
    98f8:	e1a03001 	mov	r3, r1
    98fc:	e1a00004 	mov	r0, r4
    9900:	e1a01005 	mov	r1, r5
    9904:	eb002b79 	bl	146f0 <__adddf3>
    9908:	e1a0200a 	mov	r2, sl
    990c:	e1a04000 	mov	r4, r0
    9910:	e1a05001 	mov	r5, r1
    9914:	e1cd07d8 	ldrd	r0, [sp, #120]	; 0x78
    9918:	e1a0300b 	mov	r3, fp
    991c:	eb002c77 	bl	14b00 <__aeabi_dmul>
                                                 +FC1233*DR2+FC1333*DT)*DTS)*ROHI2;
    9920:	e1a02006 	mov	r2, r6
    9924:	e1a03007 	mov	r3, r7
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
                   +FC1123*(2.0*DR1+DR2)*DR2*DT+(2.0*FC1133*DR1
    9928:	e1cd05f0 	strd	r0, [sp, #80]	; 0x50
                                                 +FC1233*DR2+FC1333*DT)*DTS)*ROHI2;
    992c:	e1cd00d8 	ldrd	r0, [sp, #8]
    9930:	eb002c72 	bl	14b00 <__aeabi_dmul>
    9934:	e1a02000 	mov	r2, r0
    9938:	e1a03001 	mov	r3, r1
    993c:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    9940:	eb002b6a 	bl	146f0 <__adddf3>
    9944:	e1cd2dd8 	ldrd	r2, [sp, #216]	; 0xd8
    9948:	eb002b68 	bl	146f0 <__adddf3>
    994c:	e1cd24d8 	ldrd	r2, [sp, #72]	; 0x48
    9950:	eb002c6a 	bl	14b00 <__aeabi_dmul>
    9954:	e1a02000 	mov	r2, r0
    9958:	e1a03001 	mov	r3, r1
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
                   +FC1123*(2.0*DR1+DR2)*DR2*DT+(2.0*FC1133*DR1
    995c:	e1a00004 	mov	r0, r4
    9960:	e1a01005 	mov	r1, r5
    9964:	eb002b61 	bl	146f0 <__adddf3>
                                                 +FC1233*DR2+FC1333*DT)*DTS)*ROHI2;
    9968:	e1cd23d0 	ldrd	r2, [sp, #48]	; 0x30
    996c:	eb002c63 	bl	14b00 <__aeabi_dmul>
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
    9970:	e1cd2cd8 	ldrd	r2, [sp, #200]	; 0xc8
    9974:	eb002b5d 	bl	146f0 <__adddf3>
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
                   +FC1123*(2.0*DR1+DR2)*DR2*DT+(2.0*FC1133*DR1
                                                 +FC1233*DR2+FC1333*DT)*DTS)*ROHI2;
            F2=F2+(4.0*FC3333*DTS*DT+FC1113*(DR1S*DR1+DR2S*DR2)
    9978:	e59f21a0 	ldr	r2, [pc, #416]	; 9b20 <INTRAF+0xd28>
                   +2.0*FC113*DR1*DT+FC123*DR2*DT+FC133*DTS)*ROHI;
            F2=F2+(3.0*FC333*DTS+FC113*(DR1S+DR2S)
                   +FC123*DR1*DR2+2.0*FC133*(DR1+DR2)*DT)*ROHI;
            F3=F3+(3.0*FC111*DR2S+FC112*(2.0*DR2+DR1)*DR1
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
    997c:	e1cd05f0 	strd	r0, [sp, #80]	; 0x50
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
                   +FC1123*(2.0*DR1+DR2)*DR2*DT+(2.0*FC1133*DR1
                                                 +FC1233*DR2+FC1333*DT)*DTS)*ROHI2;
            F2=F2+(4.0*FC3333*DTS*DT+FC1113*(DR1S*DR1+DR2S*DR2)
    9980:	e1c200d0 	ldrd	r0, [r2]
    9984:	e59f3170 	ldr	r3, [pc, #368]	; 9afc <INTRAF+0xd04>
    9988:	e3a02000 	mov	r2, #0
    998c:	eb002c5b 	bl	14b00 <__aeabi_dmul>
    9990:	e1cd24d8 	ldrd	r2, [sp, #72]	; 0x48
    9994:	eb002c59 	bl	14b00 <__aeabi_dmul>
    9998:	e1cd20d0 	ldrd	r2, [sp]
    999c:	eb002c57 	bl	14b00 <__aeabi_dmul>
    99a0:	e1a0200a 	mov	r2, sl
    99a4:	e1a04000 	mov	r4, r0
    99a8:	e1a05001 	mov	r5, r1
    99ac:	e1cd02d0 	ldrd	r0, [sp, #32]
    99b0:	e1a0300b 	mov	r3, fp
    99b4:	eb002c51 	bl	14b00 <__aeabi_dmul>
    99b8:	e1a02006 	mov	r2, r6
    99bc:	e1a03007 	mov	r3, r7
    99c0:	e1cd0cf8 	strd	r0, [sp, #200]	; 0xc8
    99c4:	e1cd02d8 	ldrd	r0, [sp, #40]	; 0x28
    99c8:	eb002c4c 	bl	14b00 <__aeabi_dmul>
    99cc:	e1a02000 	mov	r2, r0
    99d0:	e1a03001 	mov	r3, r1
    99d4:	e1cd0cd8 	ldrd	r0, [sp, #200]	; 0xc8
    99d8:	eb002b44 	bl	146f0 <__adddf3>
    99dc:	e1a02000 	mov	r2, r0
    99e0:	e1a03001 	mov	r3, r1
    99e4:	e1a00008 	mov	r0, r8
    99e8:	e1a01009 	mov	r1, r9
    99ec:	eb002c43 	bl	14b00 <__aeabi_dmul>
    99f0:	e1a02000 	mov	r2, r0
    99f4:	e1a03001 	mov	r3, r1
    99f8:	e1a00004 	mov	r0, r4
    99fc:	e1a01005 	mov	r1, r5
    9a00:	eb002b3a 	bl	146f0 <__adddf3>
                   +FC1123*(DR1+DR2)*DR1*DR2+2.0*FC1133*(DR1S+DR2S)
    9a04:	e1cd21d0 	ldrd	r2, [sp, #16]
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
                   +FC1123*(2.0*DR1+DR2)*DR2*DT+(2.0*FC1133*DR1
                                                 +FC1233*DR2+FC1333*DT)*DTS)*ROHI2;
            F2=F2+(4.0*FC3333*DTS*DT+FC1113*(DR1S*DR1+DR2S*DR2)
    9a08:	e1a04000 	mov	r4, r0
    9a0c:	e1a05001 	mov	r5, r1
                   +FC1123*(DR1+DR2)*DR1*DR2+2.0*FC1133*(DR1S+DR2S)
    9a10:	e1cd03d8 	ldrd	r0, [sp, #56]	; 0x38
    9a14:	eb002c39 	bl	14b00 <__aeabi_dmul>
    9a18:	e1a0200a 	mov	r2, sl
    9a1c:	e1a0300b 	mov	r3, fp
    9a20:	eb002c36 	bl	14b00 <__aeabi_dmul>
    9a24:	e1a02006 	mov	r2, r6
    9a28:	e1a03007 	mov	r3, r7
    9a2c:	eb002c33 	bl	14b00 <__aeabi_dmul>
    9a30:	e1a02000 	mov	r2, r0
    9a34:	e1a03001 	mov	r3, r1
    9a38:	e1a00004 	mov	r0, r4
    9a3c:	e1a01005 	mov	r1, r5
    9a40:	eb002b2a 	bl	146f0 <__adddf3>
    9a44:	e1cd27d8 	ldrd	r2, [sp, #120]	; 0x78
    9a48:	e1a04000 	mov	r4, r0
    9a4c:	e1a05001 	mov	r5, r1
    9a50:	e1cd09d0 	ldrd	r0, [sp, #144]	; 0x90
    9a54:	eb002c29 	bl	14b00 <__aeabi_dmul>
                   *DT+2.0*FC1233*DR1*DR2*DT+3.0*FC1333*(DR1+DR2)*DTS)
    9a58:	e1cd20d0 	ldrd	r2, [sp]
    9a5c:	eb002c27 	bl	14b00 <__aeabi_dmul>
    9a60:	e1a02000 	mov	r2, r0
    9a64:	e1a03001 	mov	r3, r1
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
                   +FC1123*(2.0*DR1+DR2)*DR2*DT+(2.0*FC1133*DR1
                                                 +FC1233*DR2+FC1333*DT)*DTS)*ROHI2;
            F2=F2+(4.0*FC3333*DTS*DT+FC1113*(DR1S*DR1+DR2S*DR2)
                   +FC1123*(DR1+DR2)*DR1*DR2+2.0*FC1133*(DR1S+DR2S)
    9a68:	e1a00004 	mov	r0, r4
    9a6c:	e1a01005 	mov	r1, r5
    9a70:	eb002b1e 	bl	146f0 <__adddf3>
    9a74:	e1a04000 	mov	r4, r0
    9a78:	e1a05001 	mov	r5, r1
                   *DT+2.0*FC1233*DR1*DR2*DT+3.0*FC1333*(DR1+DR2)*DTS)
    9a7c:	e1cd00d8 	ldrd	r0, [sp, #8]
    9a80:	e1a02000 	mov	r2, r0
    9a84:	e1a03001 	mov	r3, r1
    9a88:	eb002b18 	bl	146f0 <__adddf3>
    9a8c:	e1a0200a 	mov	r2, sl
    9a90:	e1a0300b 	mov	r3, fp
    9a94:	eb002c19 	bl	14b00 <__aeabi_dmul>
    9a98:	e1a02006 	mov	r2, r6
    9a9c:	e1a03007 	mov	r3, r7
    9aa0:	eb002c16 	bl	14b00 <__aeabi_dmul>
    9aa4:	e1cd20d0 	ldrd	r2, [sp]
    9aa8:	eb002c14 	bl	14b00 <__aeabi_dmul>
    9aac:	ea000020 	b	9b34 <INTRAF+0xd3c>
    9ab0:	0013efcc 	.word	0x0013efcc
    9ab4:	0013f098 	.word	0x0013f098
    9ab8:	0013ea48 	.word	0x0013ea48
    9abc:	0013efa0 	.word	0x0013efa0
    9ac0:	3ff00000 	.word	0x3ff00000
    9ac4:	0013f3f8 	.word	0x0013f3f8
    9ac8:	0013eee8 	.word	0x0013eee8
    9acc:	0013ea68 	.word	0x0013ea68
    9ad0:	0013ef60 	.word	0x0013ef60
    9ad4:	0013ef98 	.word	0x0013ef98
    9ad8:	0013efd0 	.word	0x0013efd0
    9adc:	0013f518 	.word	0x0013f518
    9ae0:	0013f4e8 	.word	0x0013f4e8
    9ae4:	0013eea0 	.word	0x0013eea0
    9ae8:	0013ee98 	.word	0x0013ee98
    9aec:	0013f408 	.word	0x0013f408
    9af0:	0013ea80 	.word	0x0013ea80
    9af4:	0013eeb0 	.word	0x0013eeb0
    9af8:	0013eff8 	.word	0x0013eff8
    9afc:	40100000 	.word	0x40100000
    9b00:	0013f548 	.word	0x0013f548
    9b04:	0013f420 	.word	0x0013f420
    9b08:	0013ef80 	.word	0x0013ef80
    9b0c:	0013ef88 	.word	0x0013ef88
    9b10:	0013f090 	.word	0x0013f090
    9b14:	0013f440 	.word	0x0013f440
    9b18:	0013eeb8 	.word	0x0013eeb8
    9b1c:	0013ea30 	.word	0x0013ea30
    9b20:	0013eea8 	.word	0x0013eea8
    9b24:	40080000 	.word	0x40080000
    9b28:	0013efcc 	.word	0x0013efcc
    9b2c:	0013f098 	.word	0x0013f098
    9b30:	0013f3f0 	.word	0x0013f3f0
    9b34:	e1a02000 	mov	r2, r0
    9b38:	e1a03001 	mov	r3, r1
    9b3c:	e1a00004 	mov	r0, r4
    9b40:	e1a01005 	mov	r1, r5
    9b44:	eb002ae9 	bl	146f0 <__adddf3>
    9b48:	e3a02000 	mov	r2, #0
    9b4c:	e1a04000 	mov	r4, r0
    9b50:	e1a05001 	mov	r5, r1
    9b54:	e1cd08d8 	ldrd	r0, [sp, #136]	; 0x88
    9b58:	e51f303c 	ldr	r3, [pc, #-60]	; 9b24 <INTRAF+0xd2c>
    9b5c:	eb002be7 	bl	14b00 <__aeabi_dmul>
    9b60:	e1a02000 	mov	r2, r0
    9b64:	e1a03001 	mov	r3, r1
    9b68:	e1cd03d8 	ldrd	r0, [sp, #56]	; 0x38
    9b6c:	eb002be3 	bl	14b00 <__aeabi_dmul>
    9b70:	e1cd24d8 	ldrd	r2, [sp, #72]	; 0x48
    9b74:	eb002be1 	bl	14b00 <__aeabi_dmul>
    9b78:	e1a02000 	mov	r2, r0
    9b7c:	e1a03001 	mov	r3, r1
    9b80:	e1a00004 	mov	r0, r4
    9b84:	e1a01005 	mov	r1, r5
    9b88:	eb002ad8 	bl	146f0 <__adddf3>
    9b8c:	e1a02000 	mov	r2, r0
    9b90:	e1a03001 	mov	r3, r1
                *ROHI2;
    9b94:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
    9b98:	eb002bd8 	bl	14b00 <__aeabi_dmul>
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
                   +FC1123*(2.0*DR1+DR2)*DR2*DT+(2.0*FC1133*DR1
                                                 +FC1233*DR2+FC1333*DT)*DTS)*ROHI2;
            F2=F2+(4.0*FC3333*DTS*DT+FC1113*(DR1S*DR1+DR2S*DR2)
    9b9c:	e1cd2ed0 	ldrd	r2, [sp, #224]	; 0xe0
    9ba0:	eb002ad2 	bl	146f0 <__adddf3>
                   +FC1123*(DR1+DR2)*DR1*DR2+2.0*FC1133*(DR1S+DR2S)
                   *DT+2.0*FC1233*DR1*DR2*DT+3.0*FC1333*(DR1+DR2)*DTS)
                *ROHI2;
            F3=F3+(4.0*FC1111*DR2S*DR2+FC1112*(3.0*DR2S+DR1S)
    9ba4:	e1cd2ad0 	ldrd	r2, [sp, #160]	; 0xa0
                   +2.0*FC113*DR2*DT+FC123*DR1*DT+FC133*DTS)*ROHI;
            F1=F1+(4.0*FC1111*DR1S*DR1+FC1112*(3.0*DR1S+DR2S)
                   *DR2+2.0*FC1122*DR1*DR2S+3.0*FC1113*DR1S*DT
                   +FC1123*(2.0*DR1+DR2)*DR2*DT+(2.0*FC1133*DR1
                                                 +FC1233*DR2+FC1333*DT)*DTS)*ROHI2;
            F2=F2+(4.0*FC3333*DTS*DT+FC1113*(DR1S*DR1+DR2S*DR2)
    9ba8:	e1a08000 	mov	r8, r0
    9bac:	e1a09001 	mov	r9, r1
                   +FC1123*(DR1+DR2)*DR1*DR2+2.0*FC1133*(DR1S+DR2S)
                   *DT+2.0*FC1233*DR1*DR2*DT+3.0*FC1333*(DR1+DR2)*DTS)
                *ROHI2;
            F3=F3+(4.0*FC1111*DR2S*DR2+FC1112*(3.0*DR2S+DR1S)
    9bb0:	e1cd02d8 	ldrd	r0, [sp, #40]	; 0x28
    9bb4:	eb002bd1 	bl	14b00 <__aeabi_dmul>
    9bb8:	e1a02006 	mov	r2, r6
    9bbc:	e1a03007 	mov	r3, r7
    9bc0:	eb002bce 	bl	14b00 <__aeabi_dmul>
    9bc4:	e3a02000 	mov	r2, #0
    9bc8:	e1a04000 	mov	r4, r0
    9bcc:	e1a05001 	mov	r5, r1
    9bd0:	e1cd02d8 	ldrd	r0, [sp, #40]	; 0x28
    9bd4:	e51f30b8 	ldr	r3, [pc, #-184]	; 9b24 <INTRAF+0xd2c>
    9bd8:	eb002bc8 	bl	14b00 <__aeabi_dmul>
    9bdc:	e1cd22d0 	ldrd	r2, [sp, #32]
    9be0:	eb002ac2 	bl	146f0 <__adddf3>
    9be4:	e1a02000 	mov	r2, r0
    9be8:	e1a03001 	mov	r3, r1
    9bec:	e1cd08d0 	ldrd	r0, [sp, #128]	; 0x80
    9bf0:	eb002bc2 	bl	14b00 <__aeabi_dmul>
                   *DR1+2.0*FC1122*DR1S*DR2+3.0*FC1113*DR2S*DT
    9bf4:	e1a0200a 	mov	r2, sl
    9bf8:	e1a0300b 	mov	r3, fp
    9bfc:	eb002bbf 	bl	14b00 <__aeabi_dmul>
    9c00:	e1a02000 	mov	r2, r0
    9c04:	e1a03001 	mov	r3, r1
                                                 +FC1233*DR2+FC1333*DT)*DTS)*ROHI2;
            F2=F2+(4.0*FC3333*DTS*DT+FC1113*(DR1S*DR1+DR2S*DR2)
                   +FC1123*(DR1+DR2)*DR1*DR2+2.0*FC1133*(DR1S+DR2S)
                   *DT+2.0*FC1233*DR1*DR2*DT+3.0*FC1333*(DR1+DR2)*DTS)
                *ROHI2;
            F3=F3+(4.0*FC1111*DR2S*DR2+FC1112*(3.0*DR2S+DR1S)
    9c08:	e1a00004 	mov	r0, r4
    9c0c:	e1a01005 	mov	r1, r5
    9c10:	eb002ab6 	bl	146f0 <__adddf3>
                   *DR1+2.0*FC1122*DR1S*DR2+3.0*FC1113*DR2S*DT
    9c14:	e1cd24d0 	ldrd	r2, [sp, #64]	; 0x40
                                                 +FC1233*DR2+FC1333*DT)*DTS)*ROHI2;
            F2=F2+(4.0*FC3333*DTS*DT+FC1113*(DR1S*DR1+DR2S*DR2)
                   +FC1123*(DR1+DR2)*DR1*DR2+2.0*FC1133*(DR1S+DR2S)
                   *DT+2.0*FC1233*DR1*DR2*DT+3.0*FC1333*(DR1+DR2)*DTS)
                *ROHI2;
            F3=F3+(4.0*FC1111*DR2S*DR2+FC1112*(3.0*DR2S+DR1S)
    9c18:	e1a04000 	mov	r4, r0
    9c1c:	e1a05001 	mov	r5, r1
                   *DR1+2.0*FC1122*DR1S*DR2+3.0*FC1113*DR2S*DT
    9c20:	e1cd02d0 	ldrd	r0, [sp, #32]
    9c24:	eb002bb5 	bl	14b00 <__aeabi_dmul>
    9c28:	e1a02006 	mov	r2, r6
    9c2c:	e1a03007 	mov	r3, r7
    9c30:	eb002bb2 	bl	14b00 <__aeabi_dmul>
    9c34:	e1a02000 	mov	r2, r0
    9c38:	e1a03001 	mov	r3, r1
    9c3c:	e1a00004 	mov	r0, r4
    9c40:	e1a01005 	mov	r1, r5
    9c44:	eb002aa9 	bl	146f0 <__adddf3>
    9c48:	e1cd2dd0 	ldrd	r2, [sp, #208]	; 0xd0
    9c4c:	e1a04000 	mov	r4, r0
    9c50:	e1a05001 	mov	r5, r1
    9c54:	e1cd02d8 	ldrd	r0, [sp, #40]	; 0x28
    9c58:	eb002ba8 	bl	14b00 <__aeabi_dmul>
    9c5c:	e1cd20d0 	ldrd	r2, [sp]
    9c60:	eb002ba6 	bl	14b00 <__aeabi_dmul>
    9c64:	e1a02000 	mov	r2, r0
    9c68:	e1a03001 	mov	r3, r1
    9c6c:	e1a00004 	mov	r0, r4
    9c70:	e1a01005 	mov	r1, r5
    9c74:	eb002a9d 	bl	146f0 <__adddf3>
                   +FC1123*(2.0*DR2+DR1)*DR1*DT+(2.0*FC1133*DR2
    9c78:	e1cd21d0 	ldrd	r2, [sp, #16]
            F2=F2+(4.0*FC3333*DTS*DT+FC1113*(DR1S*DR1+DR2S*DR2)
                   +FC1123*(DR1+DR2)*DR1*DR2+2.0*FC1133*(DR1S+DR2S)
                   *DT+2.0*FC1233*DR1*DR2*DT+3.0*FC1333*(DR1+DR2)*DTS)
                *ROHI2;
            F3=F3+(4.0*FC1111*DR2S*DR2+FC1112*(3.0*DR2S+DR1S)
                   *DR1+2.0*FC1122*DR1S*DR2+3.0*FC1113*DR2S*DT
    9c7c:	e1a04000 	mov	r4, r0
    9c80:	e1a05001 	mov	r5, r1
                   +FC1123*(2.0*DR2+DR1)*DR1*DT+(2.0*FC1133*DR2
    9c84:	e1cd09d8 	ldrd	r0, [sp, #152]	; 0x98
    9c88:	eb002b9c 	bl	14b00 <__aeabi_dmul>
    9c8c:	e1a0200a 	mov	r2, sl
    9c90:	e1a0300b 	mov	r3, fp
    9c94:	eb002b99 	bl	14b00 <__aeabi_dmul>
    9c98:	e1cd20d0 	ldrd	r2, [sp]
    9c9c:	eb002b97 	bl	14b00 <__aeabi_dmul>
    9ca0:	e1a02000 	mov	r2, r0
    9ca4:	e1a03001 	mov	r3, r1
    9ca8:	e1a00004 	mov	r0, r4
    9cac:	e1a01005 	mov	r1, r5
    9cb0:	eb002a8e 	bl	146f0 <__adddf3>
    9cb4:	e1cd27d8 	ldrd	r2, [sp, #120]	; 0x78
    9cb8:	e1a04000 	mov	r4, r0
    9cbc:	e1a05001 	mov	r5, r1
    9cc0:	e1a00006 	mov	r0, r6
    9cc4:	e1a01007 	mov	r1, r7
    9cc8:	eb002b8c 	bl	14b00 <__aeabi_dmul>
                                                 +FC1233*DR1+FC1333*DT)*DTS)*ROHI2;
    9ccc:	e1cd20d8 	ldrd	r2, [sp, #8]
                   +FC1123*(DR1+DR2)*DR1*DR2+2.0*FC1133*(DR1S+DR2S)
                   *DT+2.0*FC1233*DR1*DR2*DT+3.0*FC1333*(DR1+DR2)*DTS)
                *ROHI2;
            F3=F3+(4.0*FC1111*DR2S*DR2+FC1112*(3.0*DR2S+DR1S)
                   *DR1+2.0*FC1122*DR1S*DR2+3.0*FC1113*DR2S*DT
                   +FC1123*(2.0*DR2+DR1)*DR1*DT+(2.0*FC1133*DR2
    9cd0:	e1a06000 	mov	r6, r0
    9cd4:	e1a07001 	mov	r7, r1
                                                 +FC1233*DR1+FC1333*DT)*DTS)*ROHI2;
    9cd8:	e1a0000a 	mov	r0, sl
    9cdc:	e1a0100b 	mov	r1, fp
    9ce0:	eb002b86 	bl	14b00 <__aeabi_dmul>
    9ce4:	e1a02000 	mov	r2, r0
    9ce8:	e1a03001 	mov	r3, r1
    9cec:	e1a00006 	mov	r0, r6
    9cf0:	e1a01007 	mov	r1, r7
    9cf4:	eb002a7d 	bl	146f0 <__adddf3>
    9cf8:	e1a02000 	mov	r2, r0
    9cfc:	e1a03001 	mov	r3, r1
    9d00:	e1cd0dd8 	ldrd	r0, [sp, #216]	; 0xd8
    9d04:	eb002a79 	bl	146f0 <__adddf3>
    9d08:	e1cd24d8 	ldrd	r2, [sp, #72]	; 0x48
    9d0c:	eb002b7b 	bl	14b00 <__aeabi_dmul>
    9d10:	e1a02000 	mov	r2, r0
    9d14:	e1a03001 	mov	r3, r1
                   +FC1123*(DR1+DR2)*DR1*DR2+2.0*FC1133*(DR1S+DR2S)
                   *DT+2.0*FC1233*DR1*DR2*DT+3.0*FC1333*(DR1+DR2)*DTS)
                *ROHI2;
            F3=F3+(4.0*FC1111*DR2S*DR2+FC1112*(3.0*DR2S+DR1S)
                   *DR1+2.0*FC1122*DR1S*DR2+3.0*FC1113*DR2S*DT
                   +FC1123*(2.0*DR2+DR1)*DR1*DT+(2.0*FC1133*DR2
    9d18:	e1a00004 	mov	r0, r4
    9d1c:	e1a01005 	mov	r1, r5
    9d20:	eb002a72 	bl	146f0 <__adddf3>
    9d24:	e1a02000 	mov	r2, r0
    9d28:	e1a03001 	mov	r3, r1
                                                 +FC1233*DR1+FC1333*DT)*DTS)*ROHI2;
    9d2c:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
    9d30:	eb002b72 	bl	14b00 <__aeabi_dmul>
                                                 +FC1233*DR2+FC1333*DT)*DTS)*ROHI2;
            F2=F2+(4.0*FC3333*DTS*DT+FC1113*(DR1S*DR1+DR2S*DR2)
                   +FC1123*(DR1+DR2)*DR1*DR2+2.0*FC1133*(DR1S+DR2S)
                   *DT+2.0*FC1233*DR1*DR2*DT+3.0*FC1333*(DR1+DR2)*DTS)
                *ROHI2;
            F3=F3+(4.0*FC1111*DR2S*DR2+FC1112*(3.0*DR2S+DR1S)
    9d34:	e1cd2ed8 	ldrd	r2, [sp, #232]	; 0xe8
    9d38:	eb002a6c 	bl	146f0 <__adddf3>
            /* Update forces */

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
    9d3c:	e1cd2bd0 	ldrd	r2, [sp, #176]	; 0xb0
                                                 +FC1233*DR2+FC1333*DT)*DTS)*ROHI2;
            F2=F2+(4.0*FC3333*DTS*DT+FC1113*(DR1S*DR1+DR2S*DR2)
                   +FC1123*(DR1+DR2)*DR1*DR2+2.0*FC1133*(DR1S+DR2S)
                   *DT+2.0*FC1233*DR1*DR2*DT+3.0*FC1333*(DR1+DR2)*DTS)
                *ROHI2;
            F3=F3+(4.0*FC1111*DR2S*DR2+FC1112*(3.0*DR2S+DR1S)
    9d40:	e1a0a000 	mov	sl, r0
    9d44:	e1a0b001 	mov	fp, r1
            /* Update forces */

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
    9d48:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    9d4c:	eb002b6b 	bl	14b00 <__aeabi_dmul>
            R2S=ROH/(R2*SIN);

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
                DR23[dir]=VR2[dir]/R2;
                DT1[dir]=(-DR23[dir]+DR11[dir]*COS)*R1S;
    9d50:	e1cd2bd0 	ldrd	r2, [sp, #176]	; 0xb0
            /* Update forces */

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
    9d54:	e1a04000 	mov	r4, r0
    9d58:	e1a05001 	mov	r5, r1
            R2S=ROH/(R2*SIN);

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
                DR23[dir]=VR2[dir]/R2;
                DT1[dir]=(-DR23[dir]+DR11[dir]*COS)*R1S;
    9d5c:	e1cd01d8 	ldrd	r0, [sp, #24]
    9d60:	eb002b66 	bl	14b00 <__aeabi_dmul>
    9d64:	e1cd2bd8 	ldrd	r2, [sp, #184]	; 0xb8
    9d68:	eb002a5f 	bl	146ec <__aeabi_dsub>
    9d6c:	e1cd2ad8 	ldrd	r2, [sp, #168]	; 0xa8
    9d70:	eb002b62 	bl	14b00 <__aeabi_dmul>
    9d74:	e1a02000 	mov	r2, r0
    9d78:	e1a03001 	mov	r3, r1
            /* Update forces */

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
    9d7c:	e1a00008 	mov	r0, r8
    9d80:	e1a01009 	mov	r1, r9
    9d84:	eb002b5d 	bl	14b00 <__aeabi_dmul>
    9d88:	e1a02000 	mov	r2, r0
    9d8c:	e1a03001 	mov	r3, r1
    9d90:	e1a00004 	mov	r0, r4
    9d94:	e1a01005 	mov	r1, r5
    9d98:	eb002a54 	bl	146f0 <__adddf3>
                temp_p[H1] = T1;
                T2=F3*DR23[dir]+F2*DT3[dir];
    9d9c:	e1cd2bd8 	ldrd	r2, [sp, #184]	; 0xb8

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
                temp_p[H1] = T1;
    9da0:	e3a0ce21 	mov	ip, #528	; 0x210
            /* Update forces */

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
    9da4:	e1a04000 	mov	r4, r0
    9da8:	e1a05001 	mov	r5, r1
                temp_p[H1] = T1;
    9dac:	e59de0f0 	ldr	lr, [sp, #240]	; 0xf0
                T2=F3*DR23[dir]+F2*DT3[dir];
    9db0:	e1a0000a 	mov	r0, sl

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
                temp_p[H1] = T1;
    9db4:	e18e40fc 	strd	r4, [lr, ip]
                T2=F3*DR23[dir]+F2*DT3[dir];
    9db8:	e1a0100b 	mov	r1, fp
    9dbc:	eb002b4f 	bl	14b00 <__aeabi_dmul>

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
                DR23[dir]=VR2[dir]/R2;
                DT1[dir]=(-DR23[dir]+DR11[dir]*COS)*R1S;
                DT3[dir]=(-DR11[dir]+DR23[dir]*COS)*R2S;
    9dc0:	e1cd2bd8 	ldrd	r2, [sp, #184]	; 0xb8
            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
                temp_p[H1] = T1;
                T2=F3*DR23[dir]+F2*DT3[dir];
    9dc4:	e1a06000 	mov	r6, r0
    9dc8:	e1a07001 	mov	r7, r1

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
                DR23[dir]=VR2[dir]/R2;
                DT1[dir]=(-DR23[dir]+DR11[dir]*COS)*R1S;
                DT3[dir]=(-DR11[dir]+DR23[dir]*COS)*R2S;
    9dcc:	e1cd01d8 	ldrd	r0, [sp, #24]
    9dd0:	eb002b4a 	bl	14b00 <__aeabi_dmul>
    9dd4:	e1cd2bd0 	ldrd	r2, [sp, #176]	; 0xb0
    9dd8:	eb002a43 	bl	146ec <__aeabi_dsub>
    9ddc:	e1cd27d0 	ldrd	r2, [sp, #112]	; 0x70
    9de0:	eb002b46 	bl	14b00 <__aeabi_dmul>
    9de4:	e1a02000 	mov	r2, r0
    9de8:	e1a03001 	mov	r3, r1
            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
                temp_p[H1] = T1;
                T2=F3*DR23[dir]+F2*DT3[dir];
    9dec:	e1a00008 	mov	r0, r8
    9df0:	e1a01009 	mov	r1, r9
    9df4:	eb002b41 	bl	14b00 <__aeabi_dmul>
    9df8:	e1a02000 	mov	r2, r0
    9dfc:	e1a03001 	mov	r3, r1
    9e00:	e1a00006 	mov	r0, r6
    9e04:	e1a01007 	mov	r1, r7
    9e08:	eb002a38 	bl	146f0 <__adddf3>
                temp_p[H2] = T2;
    9e0c:	e3a0ce22 	mov	ip, #544	; 0x220
            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
                temp_p[H1] = T1;
                T2=F3*DR23[dir]+F2*DT3[dir];
    9e10:	e1a02000 	mov	r2, r0
    9e14:	e1a03001 	mov	r3, r1
                temp_p[H2] = T2;
    9e18:	e59de0f0 	ldr	lr, [sp, #240]	; 0xf0
                temp_p[O] = -(T1+T2);
    9e1c:	e1a00004 	mov	r0, r4
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
                temp_p[H1] = T1;
                T2=F3*DR23[dir]+F2*DT3[dir];
                temp_p[H2] = T2;
    9e20:	e18e20fc 	strd	r2, [lr, ip]
                temp_p[O] = -(T1+T2);
    9e24:	e1a01005 	mov	r1, r5
    9e28:	eb002a30 	bl	146f0 <__adddf3>
            /* Update forces */

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
    9e2c:	e1cd2cd0 	ldrd	r2, [sp, #192]	; 0xc0
                temp_p[H1] = T1;
                T2=F3*DR23[dir]+F2*DT3[dir];
                temp_p[H2] = T2;
                temp_p[O] = -(T1+T2);
    9e30:	e59dc0f0 	ldr	ip, [sp, #240]	; 0xf0
    9e34:	e2811102 	add	r1, r1, #-2147483648	; 0x80000000
    9e38:	e58c121c 	str	r1, [ip, #540]	; 0x21c
    9e3c:	e58c0218 	str	r0, [ip, #536]	; 0x218
            /* Update forces */

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
    9e40:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    9e44:	eb002b2d 	bl	14b00 <__aeabi_dmul>
            R2S=ROH/(R2*SIN);

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
                DR23[dir]=VR2[dir]/R2;
                DT1[dir]=(-DR23[dir]+DR11[dir]*COS)*R1S;
    9e48:	e1cd2cd0 	ldrd	r2, [sp, #192]	; 0xc0
            /* Update forces */

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
    9e4c:	e1a04000 	mov	r4, r0
    9e50:	e1a05001 	mov	r5, r1
            R2S=ROH/(R2*SIN);

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
                DR23[dir]=VR2[dir]/R2;
                DT1[dir]=(-DR23[dir]+DR11[dir]*COS)*R1S;
    9e54:	e1cd01d8 	ldrd	r0, [sp, #24]
    9e58:	eb002b28 	bl	14b00 <__aeabi_dmul>
    9e5c:	e1cd25d8 	ldrd	r2, [sp, #88]	; 0x58
    9e60:	eb002a21 	bl	146ec <__aeabi_dsub>
    9e64:	e1cd2ad8 	ldrd	r2, [sp, #168]	; 0xa8
    9e68:	eb002b24 	bl	14b00 <__aeabi_dmul>
    9e6c:	e1a02000 	mov	r2, r0
    9e70:	e1a03001 	mov	r3, r1
            /* Update forces */

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
    9e74:	e1a00008 	mov	r0, r8
    9e78:	e1a01009 	mov	r1, r9
    9e7c:	eb002b1f 	bl	14b00 <__aeabi_dmul>
    9e80:	e1a02000 	mov	r2, r0
    9e84:	e1a03001 	mov	r3, r1
    9e88:	e1a00004 	mov	r0, r4
    9e8c:	e1a01005 	mov	r1, r5
    9e90:	eb002a16 	bl	146f0 <__adddf3>
                temp_p[H1] = T1;
    9e94:	e3a03f8a 	mov	r3, #552	; 0x228
            /* Update forces */

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
    9e98:	e1a04000 	mov	r4, r0
    9e9c:	e1a05001 	mov	r5, r1
                temp_p[H1] = T1;
    9ea0:	e59dc0f0 	ldr	ip, [sp, #240]	; 0xf0
                T2=F3*DR23[dir]+F2*DT3[dir];
    9ea4:	e1a0000a 	mov	r0, sl

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
                temp_p[H1] = T1;
    9ea8:	e18c40f3 	strd	r4, [ip, r3]
                T2=F3*DR23[dir]+F2*DT3[dir];
    9eac:	e1cd25d8 	ldrd	r2, [sp, #88]	; 0x58
    9eb0:	e1a0100b 	mov	r1, fp
    9eb4:	eb002b11 	bl	14b00 <__aeabi_dmul>

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
                DR23[dir]=VR2[dir]/R2;
                DT1[dir]=(-DR23[dir]+DR11[dir]*COS)*R1S;
                DT3[dir]=(-DR11[dir]+DR23[dir]*COS)*R2S;
    9eb8:	e1cd25d8 	ldrd	r2, [sp, #88]	; 0x58
            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
                temp_p[H1] = T1;
                T2=F3*DR23[dir]+F2*DT3[dir];
    9ebc:	e1a06000 	mov	r6, r0
    9ec0:	e1a07001 	mov	r7, r1

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
                DR23[dir]=VR2[dir]/R2;
                DT1[dir]=(-DR23[dir]+DR11[dir]*COS)*R1S;
                DT3[dir]=(-DR11[dir]+DR23[dir]*COS)*R2S;
    9ec4:	e1cd01d8 	ldrd	r0, [sp, #24]
    9ec8:	eb002b0c 	bl	14b00 <__aeabi_dmul>
    9ecc:	e1cd2cd0 	ldrd	r2, [sp, #192]	; 0xc0
    9ed0:	eb002a05 	bl	146ec <__aeabi_dsub>
    9ed4:	e1cd27d0 	ldrd	r2, [sp, #112]	; 0x70
    9ed8:	eb002b08 	bl	14b00 <__aeabi_dmul>
    9edc:	e1a02000 	mov	r2, r0
    9ee0:	e1a03001 	mov	r3, r1
            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
                temp_p[H1] = T1;
                T2=F3*DR23[dir]+F2*DT3[dir];
    9ee4:	e1a00008 	mov	r0, r8
    9ee8:	e1a01009 	mov	r1, r9
    9eec:	eb002b03 	bl	14b00 <__aeabi_dmul>
    9ef0:	e1a02000 	mov	r2, r0
    9ef4:	e1a03001 	mov	r3, r1
    9ef8:	e1a00006 	mov	r0, r6
    9efc:	e1a01007 	mov	r1, r7
    9f00:	eb0029fa 	bl	146f0 <__adddf3>
                temp_p[H2] = T2;
    9f04:	e3a0cf8e 	mov	ip, #568	; 0x238
            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
                temp_p[H1] = T1;
                T2=F3*DR23[dir]+F2*DT3[dir];
    9f08:	e1a02000 	mov	r2, r0
    9f0c:	e1a03001 	mov	r3, r1
                temp_p[H2] = T2;
    9f10:	e59de0f0 	ldr	lr, [sp, #240]	; 0xf0
                temp_p[O] = -(T1+T2);
    9f14:	e1a00004 	mov	r0, r4
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
                temp_p[H1] = T1;
                T2=F3*DR23[dir]+F2*DT3[dir];
                temp_p[H2] = T2;
    9f18:	e18e20fc 	strd	r2, [lr, ip]
                temp_p[O] = -(T1+T2);
    9f1c:	e1a01005 	mov	r1, r5
    9f20:	eb0029f2 	bl	146f0 <__adddf3>
            /* Update forces */

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
    9f24:	e1cd26d0 	ldrd	r2, [sp, #96]	; 0x60
                temp_p[H1] = T1;
                T2=F3*DR23[dir]+F2*DT3[dir];
                temp_p[H2] = T2;
                temp_p[O] = -(T1+T2);
    9f28:	e59dc0f0 	ldr	ip, [sp, #240]	; 0xf0
    9f2c:	e2811102 	add	r1, r1, #-2147483648	; 0x80000000
    9f30:	e58c1234 	str	r1, [ip, #564]	; 0x234
    9f34:	e58c0230 	str	r0, [ip, #560]	; 0x230
            /* Update forces */

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
    9f38:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    9f3c:	eb002aef 	bl	14b00 <__aeabi_dmul>
            R2S=ROH/(R2*SIN);

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
                DR23[dir]=VR2[dir]/R2;
                DT1[dir]=(-DR23[dir]+DR11[dir]*COS)*R1S;
    9f40:	e1cd26d0 	ldrd	r2, [sp, #96]	; 0x60
            /* Update forces */

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
    9f44:	e1a04000 	mov	r4, r0
    9f48:	e1a05001 	mov	r5, r1
            R2S=ROH/(R2*SIN);

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
                DR23[dir]=VR2[dir]/R2;
                DT1[dir]=(-DR23[dir]+DR11[dir]*COS)*R1S;
    9f4c:	e1cd01d8 	ldrd	r0, [sp, #24]
    9f50:	eb002aea 	bl	14b00 <__aeabi_dmul>
    9f54:	e1cd26d8 	ldrd	r2, [sp, #104]	; 0x68
    9f58:	eb0029e3 	bl	146ec <__aeabi_dsub>
    9f5c:	e1cd2ad8 	ldrd	r2, [sp, #168]	; 0xa8
    9f60:	eb002ae6 	bl	14b00 <__aeabi_dmul>
    9f64:	e1a02000 	mov	r2, r0
    9f68:	e1a03001 	mov	r3, r1
            /* Update forces */

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
    9f6c:	e1a00008 	mov	r0, r8
    9f70:	e1a01009 	mov	r1, r9
    9f74:	eb002ae1 	bl	14b00 <__aeabi_dmul>
    9f78:	e1a02000 	mov	r2, r0
    9f7c:	e1a03001 	mov	r3, r1
    9f80:	e1a00004 	mov	r0, r4
    9f84:	e1a01005 	mov	r1, r5
    9f88:	eb0029d8 	bl	146f0 <__adddf3>
                temp_p[H1] = T1;
    9f8c:	e3a03d09 	mov	r3, #576	; 0x240
            /* Update forces */

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
    9f90:	e1a04000 	mov	r4, r0
    9f94:	e1a05001 	mov	r5, r1
                temp_p[H1] = T1;
    9f98:	e59dc0f0 	ldr	ip, [sp, #240]	; 0xf0
                T2=F3*DR23[dir]+F2*DT3[dir];
    9f9c:	e1a0000a 	mov	r0, sl

            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
                temp_p[H1] = T1;
    9fa0:	e18c40f3 	strd	r4, [ip, r3]
                T2=F3*DR23[dir]+F2*DT3[dir];
    9fa4:	e1cd26d8 	ldrd	r2, [sp, #104]	; 0x68
    9fa8:	e1a0100b 	mov	r1, fp
    9fac:	eb002ad3 	bl	14b00 <__aeabi_dmul>

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
                DR23[dir]=VR2[dir]/R2;
                DT1[dir]=(-DR23[dir]+DR11[dir]*COS)*R1S;
                DT3[dir]=(-DR11[dir]+DR23[dir]*COS)*R2S;
    9fb0:	e1cd26d8 	ldrd	r2, [sp, #104]	; 0x68
            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
                temp_p[H1] = T1;
                T2=F3*DR23[dir]+F2*DT3[dir];
    9fb4:	e1a06000 	mov	r6, r0
    9fb8:	e1a07001 	mov	r7, r1

            for (dir = XDIR; dir <= ZDIR; dir++) {
                DR11[dir]=VR1[dir]/R1;
                DR23[dir]=VR2[dir]/R2;
                DT1[dir]=(-DR23[dir]+DR11[dir]*COS)*R1S;
                DT3[dir]=(-DR11[dir]+DR23[dir]*COS)*R2S;
    9fbc:	e1cd01d8 	ldrd	r0, [sp, #24]
    9fc0:	eb002ace 	bl	14b00 <__aeabi_dmul>
    9fc4:	e1cd26d0 	ldrd	r2, [sp, #96]	; 0x60
    9fc8:	eb0029c7 	bl	146ec <__aeabi_dsub>
    9fcc:	e1cd27d0 	ldrd	r2, [sp, #112]	; 0x70
    9fd0:	eb002aca 	bl	14b00 <__aeabi_dmul>
    9fd4:	e1a02000 	mov	r2, r0
    9fd8:	e1a03001 	mov	r3, r1
            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
                temp_p[H1] = T1;
                T2=F3*DR23[dir]+F2*DT3[dir];
    9fdc:	e1a00008 	mov	r0, r8
    9fe0:	e1a01009 	mov	r1, r9
    9fe4:	eb002ac5 	bl	14b00 <__aeabi_dmul>
    9fe8:	e1a02000 	mov	r2, r0
    9fec:	e1a03001 	mov	r3, r1
    9ff0:	e1a00006 	mov	r0, r6
    9ff4:	e1a01007 	mov	r1, r7
    9ff8:	eb0029bc 	bl	146f0 <__adddf3>
                temp_p[H2] = T2;
    9ffc:	e3a0ce25 	mov	ip, #592	; 0x250
            for (dir = XDIR; dir <= ZDIR; dir++) {
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
                temp_p[H1] = T1;
                T2=F3*DR23[dir]+F2*DT3[dir];
    a000:	e1a02000 	mov	r2, r0
    a004:	e1a03001 	mov	r3, r1
                temp_p[H2] = T2;
    a008:	e59de0f0 	ldr	lr, [sp, #240]	; 0xf0
                temp_p[O] = -(T1+T2);
    a00c:	e1a00004 	mov	r0, r4
                temp_p = curr_ptr->mol.F[FORCES][dir];

                T1=F1*DR11[dir]+F2*DT1[dir];
                temp_p[H1] = T1;
                T2=F3*DR23[dir]+F2*DT3[dir];
                temp_p[H2] = T2;
    a010:	e18e20fc 	strd	r2, [lr, ip]
                temp_p[O] = -(T1+T2);
    a014:	e1a01005 	mov	r1, r5
    a018:	eb0029b4 	bl	146f0 <__adddf3>
    a01c:	e59dc0f0 	ldr	ip, [sp, #240]	; 0xf0
    a020:	e2811102 	add	r1, r1, #-2147483648	; 0x80000000
    a024:	e58c124c 	str	r1, [ip, #588]	; 0x24c
    a028:	e58c0248 	str	r0, [ip, #584]	; 0x248
            } /* for dir */

            curr_ptr = curr_ptr->next_mol;
    a02c:	e59cc2a0 	ldr	ip, [ip, #672]	; 0x2a0
        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
    a030:	e35c0000 	cmp	ip, #0
                T2=F3*DR23[dir]+F2*DT3[dir];
                temp_p[H2] = T2;
                temp_p[O] = -(T1+T2);
            } /* for dir */

            curr_ptr = curr_ptr->next_mol;
    a034:	e58dc0f0 	str	ip, [sp, #240]	; 0xf0
        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
    a038:	1afffb85 	bne	8e54 <INTRAF+0x5c>
                temp_p[O] = -(T1+T2);
            } /* for dir */

            curr_ptr = curr_ptr->next_mol;
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    a03c:	e59dc0f4 	ldr	ip, [sp, #244]	; 0xf4
    a040:	e59cc00c 	ldr	ip, [ip, #12]
    struct link *curr_ptr;
    struct list_of_boxes *curr_box;
    double *temp_p;

    curr_box = my_boxes[ProcID];
    while (curr_box) {
    a044:	e35c0000 	cmp	ip, #0
                temp_p[O] = -(T1+T2);
            } /* for dir */

            curr_ptr = curr_ptr->next_mol;
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    a048:	e58dc0f4 	str	ip, [sp, #244]	; 0xf4
    struct link *curr_ptr;
    struct list_of_boxes *curr_box;
    double *temp_p;

    curr_box = my_boxes[ProcID];
    while (curr_box) {
    a04c:	1afffb73 	bne	8e20 <INTRAF+0x28>
    /* calculate summation of the product of the displacement and computed
       force for every molecule, direction, and atom */

    LVIR=0.0;

    curr_box = my_boxes[ProcID];
    a050:	e51fe530 	ldr	lr, [pc, #-1328]	; 9b28 <INTRAF+0xd30>
    a054:	e59dc0fc 	ldr	ip, [sp, #252]	; 0xfc
    a058:	e59e3000 	ldr	r3, [lr]
    a05c:	e793310c 	ldr	r3, [r3, ip, lsl #2]
    while (curr_box) {
    a060:	e3530000 	cmp	r3, #0
    /* calculate summation of the product of the displacement and computed
       force for every molecule, direction, and atom */

    LVIR=0.0;

    curr_box = my_boxes[ProcID];
    a064:	e58d30f0 	str	r3, [sp, #240]	; 0xf0
    while (curr_box) {
    a068:	0a00008d 	beq	a2a4 <INTRAF+0x14ac>
    }   /* while curr_box */

    /* calculate summation of the product of the displacement and computed
       force for every molecule, direction, and atom */

    LVIR=0.0;
    a06c:	e3a04000 	mov	r4, #0
    a070:	e3a05000 	mov	r5, #0
        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
            for ( dir = XDIR; dir <= ZDIR; dir++)
                for (atom = 0; atom < NATOM; atom++)
                    LVIR += curr_ptr->mol.F[DISP][dir][atom] *
                        curr_ptr->mol.F[FORCES][dir][atom];
    a074:	e3a07e21 	mov	r7, #528	; 0x210
    a078:	e3a06f86 	mov	r6, #536	; 0x218
    a07c:	e3a09e22 	mov	r9, #544	; 0x220
    a080:	e3a0af8a 	mov	sl, #552	; 0x228
    a084:	e3a0be23 	mov	fp, #560	; 0x230
    a088:	e51fc564 	ldr	ip, [pc, #-1380]	; 9b2c <INTRAF+0xd34>
    a08c:	e59cc000 	ldr	ip, [ip]
    a090:	e58dc000 	str	ip, [sp]
    a094:	e59dc0f0 	ldr	ip, [sp, #240]	; 0xf0

        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        curr_ptr = BOX[i][j][k].list;
    a098:	e59c3000 	ldr	r3, [ip]
    a09c:	e59c1004 	ldr	r1, [ip, #4]
    a0a0:	e59dc000 	ldr	ip, [sp]
    a0a4:	e79c3103 	ldr	r3, [ip, r3, lsl #2]
    a0a8:	e59dc0f0 	ldr	ip, [sp, #240]	; 0xf0
    a0ac:	e7933101 	ldr	r3, [r3, r1, lsl #2]
    a0b0:	e59c2008 	ldr	r2, [ip, #8]
    a0b4:	e7938202 	ldr	r8, [r3, r2, lsl #4]
        while (curr_ptr) {
    a0b8:	e3580000 	cmp	r8, #0
    a0bc:	0a000060 	beq	a244 <INTRAF+0x144c>
            for ( dir = XDIR; dir <= ZDIR; dir++)
                for (atom = 0; atom < NATOM; atom++)
                    LVIR += curr_ptr->mol.F[DISP][dir][atom] *
    a0c0:	e18820d7 	ldrd	r2, [r8, r7]
    a0c4:	e1c801d8 	ldrd	r0, [r8, #24]
    a0c8:	eb002a8c 	bl	14b00 <__aeabi_dmul>
    a0cc:	e1a02000 	mov	r2, r0
    a0d0:	e1a03001 	mov	r3, r1
    a0d4:	e1a00004 	mov	r0, r4
    a0d8:	e1a01005 	mov	r1, r5
    a0dc:	eb002983 	bl	146f0 <__adddf3>
    a0e0:	e18820d6 	ldrd	r2, [r8, r6]
    a0e4:	e1a04000 	mov	r4, r0
    a0e8:	e1a05001 	mov	r5, r1
    a0ec:	e1c802d0 	ldrd	r0, [r8, #32]
    a0f0:	eb002a82 	bl	14b00 <__aeabi_dmul>
    a0f4:	e1a02000 	mov	r2, r0
    a0f8:	e1a03001 	mov	r3, r1
    a0fc:	e1a00004 	mov	r0, r4
    a100:	e1a01005 	mov	r1, r5
    a104:	eb002979 	bl	146f0 <__adddf3>
    a108:	e18820d9 	ldrd	r2, [r8, r9]
    a10c:	e1a04000 	mov	r4, r0
    a110:	e1a05001 	mov	r5, r1
    a114:	e1c802d8 	ldrd	r0, [r8, #40]	; 0x28
    a118:	eb002a78 	bl	14b00 <__aeabi_dmul>
    a11c:	e1a02000 	mov	r2, r0
    a120:	e1a03001 	mov	r3, r1
    a124:	e1a00004 	mov	r0, r4
    a128:	e1a01005 	mov	r1, r5
    a12c:	eb00296f 	bl	146f0 <__adddf3>
    a130:	e18820da 	ldrd	r2, [r8, sl]
    a134:	e1a04000 	mov	r4, r0
    a138:	e1a05001 	mov	r5, r1
    a13c:	e1c803d0 	ldrd	r0, [r8, #48]	; 0x30
    a140:	eb002a6e 	bl	14b00 <__aeabi_dmul>
    a144:	e1a02000 	mov	r2, r0
    a148:	e1a03001 	mov	r3, r1
    a14c:	e1a00004 	mov	r0, r4
    a150:	e1a01005 	mov	r1, r5
    a154:	eb002965 	bl	146f0 <__adddf3>
    a158:	e18820db 	ldrd	r2, [r8, fp]
    a15c:	e1a04000 	mov	r4, r0
    a160:	e1a05001 	mov	r5, r1
    a164:	e1c803d8 	ldrd	r0, [r8, #56]	; 0x38
    a168:	eb002a64 	bl	14b00 <__aeabi_dmul>
    a16c:	e1a02000 	mov	r2, r0
    a170:	e1a03001 	mov	r3, r1
    a174:	e1a00004 	mov	r0, r4
    a178:	e1a01005 	mov	r1, r5
    a17c:	eb00295b 	bl	146f0 <__adddf3>
    a180:	e3a0ef8e 	mov	lr, #568	; 0x238
    a184:	e1a04000 	mov	r4, r0
    a188:	e18820de 	ldrd	r2, [r8, lr]
    a18c:	e1a05001 	mov	r5, r1
    a190:	e1c804d0 	ldrd	r0, [r8, #64]	; 0x40
    a194:	eb002a59 	bl	14b00 <__aeabi_dmul>
    a198:	e1a02000 	mov	r2, r0
    a19c:	e1a03001 	mov	r3, r1
    a1a0:	e1a00004 	mov	r0, r4
    a1a4:	e1a01005 	mov	r1, r5
    a1a8:	eb002950 	bl	146f0 <__adddf3>
    a1ac:	e1a04000 	mov	r4, r0
    a1b0:	e3a00d09 	mov	r0, #576	; 0x240
    a1b4:	e1a05001 	mov	r5, r1
    a1b8:	e18820d0 	ldrd	r2, [r8, r0]
    a1bc:	e1c804d8 	ldrd	r0, [r8, #72]	; 0x48
    a1c0:	eb002a4e 	bl	14b00 <__aeabi_dmul>
    a1c4:	e1a02000 	mov	r2, r0
    a1c8:	e1a03001 	mov	r3, r1
    a1cc:	e1a00004 	mov	r0, r4
    a1d0:	e1a01005 	mov	r1, r5
    a1d4:	eb002945 	bl	146f0 <__adddf3>
    a1d8:	e1a05001 	mov	r5, r1
    a1dc:	e3a01f92 	mov	r1, #584	; 0x248
    a1e0:	e1a04000 	mov	r4, r0
    a1e4:	e18820d1 	ldrd	r2, [r8, r1]
    a1e8:	e1c805d0 	ldrd	r0, [r8, #80]	; 0x50
    a1ec:	eb002a43 	bl	14b00 <__aeabi_dmul>
    a1f0:	e1a02000 	mov	r2, r0
    a1f4:	e1a03001 	mov	r3, r1
    a1f8:	e1a00004 	mov	r0, r4
    a1fc:	e1a01005 	mov	r1, r5
    a200:	eb00293a 	bl	146f0 <__adddf3>
    a204:	e3a0ce25 	mov	ip, #592	; 0x250
    a208:	e1a04000 	mov	r4, r0
    a20c:	e1a05001 	mov	r5, r1
    a210:	e1c805d8 	ldrd	r0, [r8, #88]	; 0x58
    a214:	e18820dc 	ldrd	r2, [r8, ip]
    a218:	eb002a38 	bl	14b00 <__aeabi_dmul>
    a21c:	e1a02000 	mov	r2, r0
    a220:	e1a03001 	mov	r3, r1
    a224:	e1a00004 	mov	r0, r4
    a228:	e1a01005 	mov	r1, r5
    a22c:	eb00292f 	bl	146f0 <__adddf3>
                        curr_ptr->mol.F[FORCES][dir][atom];
            curr_ptr = curr_ptr->next_mol;
    a230:	e59882a0 	ldr	r8, [r8, #672]	; 0x2a0

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
            for ( dir = XDIR; dir <= ZDIR; dir++)
                for (atom = 0; atom < NATOM; atom++)
                    LVIR += curr_ptr->mol.F[DISP][dir][atom] *
    a234:	e1a04000 	mov	r4, r0
        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
    a238:	e3580000 	cmp	r8, #0
            for ( dir = XDIR; dir <= ZDIR; dir++)
                for (atom = 0; atom < NATOM; atom++)
                    LVIR += curr_ptr->mol.F[DISP][dir][atom] *
    a23c:	e1a05001 	mov	r5, r1
        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
    a240:	1affff9e 	bne	a0c0 <INTRAF+0x12c8>
                for (atom = 0; atom < NATOM; atom++)
                    LVIR += curr_ptr->mol.F[DISP][dir][atom] *
                        curr_ptr->mol.F[FORCES][dir][atom];
            curr_ptr = curr_ptr->next_mol;
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    a244:	e59dc0f0 	ldr	ip, [sp, #240]	; 0xf0
    a248:	e59cc00c 	ldr	ip, [ip, #12]
       force for every molecule, direction, and atom */

    LVIR=0.0;

    curr_box = my_boxes[ProcID];
    while (curr_box) {
    a24c:	e35c0000 	cmp	ip, #0
                for (atom = 0; atom < NATOM; atom++)
                    LVIR += curr_ptr->mol.F[DISP][dir][atom] *
                        curr_ptr->mol.F[FORCES][dir][atom];
            curr_ptr = curr_ptr->next_mol;
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    a250:	e58dc0f0 	str	ip, [sp, #240]	; 0xf0
       force for every molecule, direction, and atom */

    LVIR=0.0;

    curr_box = my_boxes[ProcID];
    while (curr_box) {
    a254:	1affff8f 	bne	a098 <INTRAF+0x12a0>
        curr_box = curr_box->next_box;
    } /* while curr_box */

    /* Update potential energy */

    LOCK(gl->IntrafVirLock);
    a258:	e51f6730 	ldr	r6, [pc, #-1840]	; 9b30 <INTRAF+0xd38>
    a25c:	e5960000 	ldr	r0, [r6]
    a260:	e2800018 	add	r0, r0, #24
    a264:	ebffd962 	bl	7f4 <pthread_mutex_lock>
    cpu_dcache_invalidate((void*)VIR,sizeof(double));
    a268:	e59d00f8 	ldr	r0, [sp, #248]	; 0xf8
    a26c:	e3a01008 	mov	r1, #8
    a270:	eb0018f2 	bl	10640 <cpu_dcache_invalidate>
    *VIR =  *VIR + LVIR;
    a274:	e59dc0f8 	ldr	ip, [sp, #248]	; 0xf8
    a278:	e1a03005 	mov	r3, r5
    a27c:	e1cc00d0 	ldrd	r0, [ip]
    a280:	e1a02004 	mov	r2, r4
    a284:	eb002919 	bl	146f0 <__adddf3>
    UNLOCK(gl->IntrafVirLock);
    a288:	e5963000 	ldr	r3, [r6]

    /* Update potential energy */

    LOCK(gl->IntrafVirLock);
    cpu_dcache_invalidate((void*)VIR,sizeof(double));
    *VIR =  *VIR + LVIR;
    a28c:	e59dc0f8 	ldr	ip, [sp, #248]	; 0xf8
    a290:	e1cc00f0 	strd	r0, [ip]
    UNLOCK(gl->IntrafVirLock);
    a294:	e2830018 	add	r0, r3, #24

} /* end of subroutine INTRAF */
    a298:	e28ddf41 	add	sp, sp, #260	; 0x104
    a29c:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    /* Update potential energy */

    LOCK(gl->IntrafVirLock);
    cpu_dcache_invalidate((void*)VIR,sizeof(double));
    *VIR =  *VIR + LVIR;
    UNLOCK(gl->IntrafVirLock);
    a2a0:	eaffdc2d 	b	135c <pthread_mutex_unlock>
    }   /* while curr_box */

    /* calculate summation of the product of the displacement and computed
       force for every molecule, direction, and atom */

    LVIR=0.0;
    a2a4:	e3a04000 	mov	r4, #0
    a2a8:	e3a05000 	mov	r5, #0
    a2ac:	eaffffe9 	b	a258 <INTRAF+0x1460>

0000a2b0 <INITIA>:
extern double g_sux;
extern double g_random[][3];

#endif
void INITIA()
{
    a2b0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
        fflush(stderr);
        exit(-1);
    }
#endif

    XMAS[1]=sqrt(OMAS*HMAS);
    a2b4:	e59fcb14 	ldr	ip, [pc, #2836]	; add0 <INITIA+0xb20>
    a2b8:	e59f5a8c 	ldr	r5, [pc, #2700]	; ad4c <INITIA+0xa9c>
    a2bc:	e1cc20d0 	ldrd	r2, [ip]
    a2c0:	e1c540d0 	ldrd	r4, [r5]
extern double g_sux;
extern double g_random[][3];

#endif
void INITIA()
{
    a2c4:	e24dd0b4 	sub	sp, sp, #180	; 0xb4
        fflush(stderr);
        exit(-1);
    }
#endif

    XMAS[1]=sqrt(OMAS*HMAS);
    a2c8:	e1a00004 	mov	r0, r4
    a2cc:	e1a01005 	mov	r1, r5
    a2d0:	e1cd47f0 	strd	r4, [sp, #112]	; 0x70
    a2d4:	eb002a09 	bl	14b00 <__aeabi_dmul>
    a2d8:	e3a02000 	mov	r2, #0
    a2dc:	e3a03000 	mov	r3, #0
    a2e0:	e1a04000 	mov	r4, r0
    a2e4:	e1a05001 	mov	r5, r1
    a2e8:	eb002b64 	bl	15080 <__aeabi_dcmplt>
    a2ec:	e3500000 	cmp	r0, #0
    a2f0:	0a000005 	beq	a30c <INITIA+0x5c>
    a2f4:	e1a01005 	mov	r1, r5
    a2f8:	e59f5a4c 	ldr	r5, [pc, #2636]	; ad4c <INITIA+0xa9c>
    a2fc:	e1a00004 	mov	r0, r4
    a300:	eb0080ea 	bl	2a6b0 <sqrt>
    a304:	e1c540d0 	ldrd	r4, [r5]
    a308:	e1cd47f0 	strd	r4, [sp, #112]	; 0x70
    /* .....assign positions */

    {
        long deriv;

        double NS = pow((double) NMOL, 1.0/3.0) - 0.00000000000001;
    a30c:	e59fca3c 	ldr	ip, [pc, #2620]	; ad50 <INITIA+0xaa0>
        double XS = BOXL/NS;
    a310:	e59f8a3c 	ldr	r8, [pc, #2620]	; ad54 <INITIA+0xaa4>
    /* .....assign positions */

    {
        long deriv;

        double NS = pow((double) NMOL, 1.0/3.0) - 0.00000000000001;
    a314:	e59c0000 	ldr	r0, [ip]
    a318:	eb0029c1 	bl	14a24 <__aeabi_i2d>
    a31c:	e59f2a34 	ldr	r2, [pc, #2612]	; ad58 <INITIA+0xaa8>
    a320:	e59f3a34 	ldr	r3, [pc, #2612]	; ad5c <INITIA+0xaac>
    a324:	eb007ec7 	bl	29e48 <pow>
    a328:	e59f2a30 	ldr	r2, [pc, #2608]	; ad60 <INITIA+0xab0>
    a32c:	e59f3a30 	ldr	r3, [pc, #2608]	; ad64 <INITIA+0xab4>
    a330:	eb0028ed 	bl	146ec <__aeabi_dsub>
    a334:	e1cd04f0 	strd	r0, [sp, #64]	; 0x40
        double XS = BOXL/NS;
    a338:	e1cd24d0 	ldrd	r2, [sp, #64]	; 0x40
    a33c:	e1c800d0 	ldrd	r0, [r8]
    a340:	eb002a92 	bl	14d90 <__aeabi_ddiv>
        double ZERO = XS * 0.50;
    a344:	e3a02000 	mov	r2, #0
    a348:	e59f3a18 	ldr	r3, [pc, #2584]	; ad68 <INITIA+0xab8>

    {
        long deriv;

        double NS = pow((double) NMOL, 1.0/3.0) - 0.00000000000001;
        double XS = BOXL/NS;
    a34c:	e1cd04f8 	strd	r0, [sp, #72]	; 0x48
        double ZERO = XS * 0.50;
    a350:	eb0029ea 	bl	14b00 <__aeabi_dmul>
    a354:	e1a07001 	mov	r7, r1
        double WCOS = ROH * cos(ANGLE * 0.5);
    a358:	e59f1a0c 	ldr	r1, [pc, #2572]	; ad6c <INITIA+0xabc>
    {
        long deriv;

        double NS = pow((double) NMOL, 1.0/3.0) - 0.00000000000001;
        double XS = BOXL/NS;
        double ZERO = XS * 0.50;
    a35c:	e1a06000 	mov	r6, r0
        double WCOS = ROH * cos(ANGLE * 0.5);
    a360:	e1c100d0 	ldrd	r0, [r1]
    a364:	e3a02000 	mov	r2, #0
    a368:	e59f39f8 	ldr	r3, [pc, #2552]	; ad68 <INITIA+0xab8>
    a36c:	eb0029e3 	bl	14b00 <__aeabi_dmul>
    a370:	e1a0a000 	mov	sl, r0
    a374:	e1a0b001 	mov	fp, r1
    a378:	eb007cbf 	bl	2967c <cos>
    a37c:	e59f39ec 	ldr	r3, [pc, #2540]	; ad70 <INITIA+0xac0>
        uint32_t line = 0;
#endif
        printf("\nNS = %.16f\n",NS);
        printf("BOXL = %10f\n",BOXL);
        printf("CUTOFF = %10f\n",CUTOFF);
        printf("BOX_LENGTH = %10f\n",BOX_LENGTH);
    a380:	e59f99ec 	ldr	r9, [pc, #2540]	; ad74 <INITIA+0xac4>
        long deriv;

        double NS = pow((double) NMOL, 1.0/3.0) - 0.00000000000001;
        double XS = BOXL/NS;
        double ZERO = XS * 0.50;
        double WCOS = ROH * cos(ANGLE * 0.5);
    a384:	e1c340d0 	ldrd	r4, [r3]
    a388:	e1a02004 	mov	r2, r4
    a38c:	e1a03005 	mov	r3, r5
    a390:	eb0029da 	bl	14b00 <__aeabi_dmul>
    a394:	e1cd08f0 	strd	r0, [sp, #128]	; 0x80
        double WSIN = ROH * sin(ANGLE * 0.5);
    a398:	e1a0000a 	mov	r0, sl
    a39c:	e1a0100b 	mov	r1, fp
    a3a0:	eb007d27 	bl	29844 <sin>
    a3a4:	e1a02000 	mov	r2, r0
    a3a8:	e1a03001 	mov	r3, r1
    a3ac:	e1a00004 	mov	r0, r4
    a3b0:	e1a01005 	mov	r1, r5
    a3b4:	eb0029d1 	bl	14b00 <__aeabi_dmul>
#ifdef SIM_SOCLIB
        uint32_t line = 0;
#endif
        printf("\nNS = %.16f\n",NS);
    a3b8:	e1cd24d0 	ldrd	r2, [sp, #64]	; 0x40

        double NS = pow((double) NMOL, 1.0/3.0) - 0.00000000000001;
        double XS = BOXL/NS;
        double ZERO = XS * 0.50;
        double WCOS = ROH * cos(ANGLE * 0.5);
        double WSIN = ROH * sin(ANGLE * 0.5);
    a3bc:	e1cd06f0 	strd	r0, [sp, #96]	; 0x60
#ifdef SIM_SOCLIB
        uint32_t line = 0;
#endif
        printf("\nNS = %.16f\n",NS);
    a3c0:	e59f09b0 	ldr	r0, [pc, #2480]	; ad78 <INITIA+0xac8>
    a3c4:	eb0039a2 	bl	18a54 <printf>
        printf("BOXL = %10f\n",BOXL);
    a3c8:	e1c820d0 	ldrd	r2, [r8]
    a3cc:	e59f09a8 	ldr	r0, [pc, #2472]	; ad7c <INITIA+0xacc>
    a3d0:	eb00399f 	bl	18a54 <printf>
        printf("CUTOFF = %10f\n",CUTOFF);
    a3d4:	e59f39a4 	ldr	r3, [pc, #2468]	; ad80 <INITIA+0xad0>
    a3d8:	e59f09a4 	ldr	r0, [pc, #2468]	; ad84 <INITIA+0xad4>
    a3dc:	e1c320d0 	ldrd	r2, [r3]
    a3e0:	eb00399b 	bl	18a54 <printf>
        printf("BOX_LENGTH = %10f\n",BOX_LENGTH);
    a3e4:	e1c920d0 	ldrd	r2, [r9]
    a3e8:	e59f0998 	ldr	r0, [pc, #2456]	; ad88 <INITIA+0xad8>
    a3ec:	eb003998 	bl	18a54 <printf>
        printf("BOX_PER_SIDE = %ld\n",BOX_PER_SIDE);
    a3f0:	e59f09dc 	ldr	r0, [pc, #2524]	; add4 <INITIA+0xb24>
        /* not random initial placement, but rather along a regular
           lattice.  This is the default and the prefered initialization
           since random does not necessarily make sense from the viewpoint
           of preserving bond distances */

        fprintf(six, "***** NEW RUN STARTING FROM REGULAR LATTICE *****\n");
    a3f4:	e59f4990 	ldr	r4, [pc, #2448]	; ad8c <INITIA+0xadc>
#endif
        printf("\nNS = %.16f\n",NS);
        printf("BOXL = %10f\n",BOXL);
        printf("CUTOFF = %10f\n",CUTOFF);
        printf("BOX_LENGTH = %10f\n",BOX_LENGTH);
        printf("BOX_PER_SIDE = %ld\n",BOX_PER_SIDE);
    a3f8:	e5901000 	ldr	r1, [r0]
    a3fc:	e59f098c 	ldr	r0, [pc, #2444]	; ad90 <INITIA+0xae0>
    a400:	eb003993 	bl	18a54 <printf>
        printf("XS = %10f\n",XS);
    a404:	e1cd24d8 	ldrd	r2, [sp, #72]	; 0x48
    a408:	e59f0984 	ldr	r0, [pc, #2436]	; ad94 <INITIA+0xae4>
    a40c:	eb003990 	bl	18a54 <printf>
        printf("ZERO = %g\n",ZERO);
    a410:	e1a02006 	mov	r2, r6
    a414:	e1a03007 	mov	r3, r7
    a418:	e59f0978 	ldr	r0, [pc, #2424]	; ad98 <INITIA+0xae8>
    a41c:	eb00398c 	bl	18a54 <printf>
        printf("WCOS = %f\n",WCOS);
    a420:	e1cd28d0 	ldrd	r2, [sp, #128]	; 0x80
    a424:	e59f0970 	ldr	r0, [pc, #2416]	; ad9c <INITIA+0xaec>
    a428:	eb003989 	bl	18a54 <printf>
        printf("WSIN = %f\n",WSIN);
    a42c:	e1cd26d0 	ldrd	r2, [sp, #96]	; 0x60
    a430:	e59f0968 	ldr	r0, [pc, #2408]	; ada0 <INITIA+0xaf0>
    a434:	eb003986 	bl	18a54 <printf>
        fflush(stdout);
    a438:	e59f3964 	ldr	r3, [pc, #2404]	; ada4 <INITIA+0xaf4>
    a43c:	e5933000 	ldr	r3, [r3]
    a440:	e5930008 	ldr	r0, [r3, #8]
    a444:	eb002f35 	bl	16120 <fflush>
        /* not random initial placement, but rather along a regular
           lattice.  This is the default and the prefered initialization
           since random does not necessarily make sense from the viewpoint
           of preserving bond distances */

        fprintf(six, "***** NEW RUN STARTING FROM REGULAR LATTICE *****\n");
    a448:	e5943000 	ldr	r3, [r4]
    a44c:	e3a02032 	mov	r2, #50	; 0x32
    a450:	e3a01001 	mov	r1, #1
    a454:	e59f094c 	ldr	r0, [pc, #2380]	; ada8 <INITIA+0xaf8>
    a458:	eb003393 	bl	172ac <fwrite>
        fflush(six);
    a45c:	e5940000 	ldr	r0, [r4]
    a460:	eb002f2e 	bl	16120 <fflush>
        XT[2] = ZERO;
    a464:	e1a01007 	mov	r1, r7
    a468:	e1a00006 	mov	r0, r6
    a46c:	eb002b1b 	bl	150e0 <__aeabi_d2iz>
    a470:	e58d005c 	str	r0, [sp, #92]	; 0x5c
    a474:	e59d405c 	ldr	r4, [sp, #92]	; 0x5c
        SUMY=0.0;
        SUMZ=0.0;

        /* Generate displacements along a regular lattice */

        for (i=0; i < NS; i++) {
    a478:	e3a02000 	mov	r2, #0
    a47c:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    a480:	e3a03000 	mov	r3, #0
           since random does not necessarily make sense from the viewpoint
           of preserving bond distances */

        fprintf(six, "***** NEW RUN STARTING FROM REGULAR LATTICE *****\n");
        fflush(six);
        XT[2] = ZERO;
    a484:	e58d4098 	str	r4, [sp, #152]	; 0x98
        SUMY=0.0;
        SUMZ=0.0;

        /* Generate displacements along a regular lattice */

        for (i=0; i < NS; i++) {
    a488:	eb002b0e 	bl	150c8 <__aeabi_dcmpgt>
    a48c:	e3500000 	cmp	r0, #0
    a490:	0a00013f 	beq	a994 <INITIA+0x6e4>
    a494:	e1c940d0 	ldrd	r4, [r9]
    a498:	e1cd42f8 	strd	r4, [sp, #40]	; 0x28
    fscanf(random_numbers,"%lf",&SUX);
#endif

        SUMX=0.0;
        SUMY=0.0;
        SUMZ=0.0;
    a49c:	e3a04000 	mov	r4, #0
    a4a0:	e3a05000 	mov	r5, #0
        double XS = BOXL/NS;
        double ZERO = XS * 0.50;
        double WCOS = ROH * cos(ANGLE * 0.5);
        double WSIN = ROH * sin(ANGLE * 0.5);
#ifdef SIM_SOCLIB
        uint32_t line = 0;
    a4a4:	e3a09000 	mov	r9, #0

#else
    fscanf(random_numbers,"%lf",&SUX);
#endif

        SUMX=0.0;
    a4a8:	e1a0b005 	mov	fp, r5
    a4ac:	e1a0a004 	mov	sl, r4
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][YDIR][atom] = *static_var;
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][ZDIR][atom] = *static_var;

			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
    a4b0:	e1cda1f8 	strd	sl, [sp, #24]
    a4b4:	e1a0b009 	mov	fp, r9
    a4b8:	e59f3918 	ldr	r3, [pc, #2328]	; add8 <INITIA+0xb28>
    fscanf(random_numbers,"%lf",&SUX);
#endif

        SUMX=0.0;
        SUMY=0.0;
        SUMZ=0.0;
    a4bc:	e1cd40f8 	strd	r4, [sp, #8]
#else
    fscanf(random_numbers,"%lf",&SUX);
#endif

        SUMX=0.0;
        SUMY=0.0;
    a4c0:	e1cd41f0 	strd	r4, [sp, #16]
    a4c4:	e5933000 	ldr	r3, [r3]
    a4c8:	e59f58dc 	ldr	r5, [pc, #2268]	; adac <INITIA+0xafc>
        SUMZ=0.0;

        /* Generate displacements along a regular lattice */

        for (i=0; i < NS; i++) {
    a4cc:	e59d405c 	ldr	r4, [sp, #92]	; 0x5c
           of preserving bond distances */

        fprintf(six, "***** NEW RUN STARTING FROM REGULAR LATTICE *****\n");
        fflush(six);
        XT[2] = ZERO;
        mol = 0;
    a4d0:	e58d9038 	str	r9, [sp, #56]	; 0x38
        SUMY=0.0;
        SUMZ=0.0;

        /* Generate displacements along a regular lattice */

        for (i=0; i < NS; i++) {
    a4d4:	e58d907c 	str	r9, [sp, #124]	; 0x7c
    a4d8:	e58d5058 	str	r5, [sp, #88]	; 0x58
    a4dc:	e58d3054 	str	r3, [sp, #84]	; 0x54
            XT[1]=XT[2]+WCOS;
    a4e0:	e1a00004 	mov	r0, r4
    a4e4:	eb00294e 	bl	14a24 <__aeabi_i2d>
    a4e8:	e1cd28d0 	ldrd	r2, [sp, #128]	; 0x80
    a4ec:	e1cd08f8 	strd	r0, [sp, #136]	; 0x88
    a4f0:	eb00287e 	bl	146f0 <__adddf3>
    a4f4:	eb002af9 	bl	150e0 <__aeabi_d2iz>
            XT[3]=XT[1];
            YT[2]=ZERO;
            for (j=0; j < NS; j+=1) {
    a4f8:	e3a0c000 	mov	ip, #0
        /* Generate displacements along a regular lattice */

        for (i=0; i < NS; i++) {
            XT[1]=XT[2]+WCOS;
            XT[3]=XT[1];
            YT[2]=ZERO;
    a4fc:	e59d405c 	ldr	r4, [sp, #92]	; 0x5c
    a500:	e59da038 	ldr	sl, [sp, #56]	; 0x38
            for (j=0; j < NS; j+=1) {
    a504:	e58dc078 	str	ip, [sp, #120]	; 0x78
        SUMZ=0.0;

        /* Generate displacements along a regular lattice */

        for (i=0; i < NS; i++) {
            XT[1]=XT[2]+WCOS;
    a508:	e58d0094 	str	r0, [sp, #148]	; 0x94
            XT[3]=XT[1];
    a50c:	e58d009c 	str	r0, [sp, #156]	; 0x9c
            YT[2]=ZERO;
    a510:	e58d40a8 	str	r4, [sp, #168]	; 0xa8
            for (j=0; j < NS; j+=1) {
                YT[1]=YT[2]+WSIN;
    a514:	e1a00004 	mov	r0, r4
    a518:	eb002941 	bl	14a24 <__aeabi_i2d>
    a51c:	e1cd26d0 	ldrd	r2, [sp, #96]	; 0x60
    a520:	e1cd06f8 	strd	r0, [sp, #104]	; 0x68
    a524:	eb002871 	bl	146f0 <__adddf3>
    a528:	eb002aec 	bl	150e0 <__aeabi_d2iz>
                YT[3]=YT[2]-WSIN;
    a52c:	e1cd26d0 	ldrd	r2, [sp, #96]	; 0x60
        for (i=0; i < NS; i++) {
            XT[1]=XT[2]+WCOS;
            XT[3]=XT[1];
            YT[2]=ZERO;
            for (j=0; j < NS; j+=1) {
                YT[1]=YT[2]+WSIN;
    a530:	e58d00a4 	str	r0, [sp, #164]	; 0xa4
                YT[3]=YT[2]-WSIN;
    a534:	e1cd06d8 	ldrd	r0, [sp, #104]	; 0x68
    a538:	eb00286b 	bl	146ec <__aeabi_dsub>
    a53c:	eb002ae7 	bl	150e0 <__aeabi_d2iz>
                Z=ZERO;
    a540:	e59d405c 	ldr	r4, [sp, #92]	; 0x5c
            XT[1]=XT[2]+WCOS;
            XT[3]=XT[1];
            YT[2]=ZERO;
            for (j=0; j < NS; j+=1) {
                YT[1]=YT[2]+WSIN;
                YT[3]=YT[2]-WSIN;
    a544:	e58d00ac 	str	r0, [sp, #172]	; 0xac
                Z=ZERO;
                for (k = 0; k < NS; k++) {
                    link_ptr = (struct link *) G_MALLOC(sizeof(link_type));
    a548:	e3a00faa 	mov	r0, #680	; 0x2a8
    a54c:	eb00344c 	bl	17684 <malloc>
    a550:	e59dc058 	ldr	ip, [sp, #88]	; 0x58
    a554:	e1a08000 	mov	r8, r0
    a558:	e59c9000 	ldr	r9, [ip]
    a55c:	e1a00004 	mov	r0, r4
                        /* read random velocities from file random.in */
                        SUMX = SUMX + link_ptr->mol.F[VEL][XDIR][atom];
                        SUMY = SUMY + link_ptr->mol.F[VEL][YDIR][atom];
                        SUMZ = SUMZ + link_ptr->mol.F[VEL][ZDIR][atom];
                        for (deriv = ACC; deriv < MAXODR; deriv++) {
                            link_ptr->mol.F[deriv][XDIR][atom] = 0.0;
    a560:	e1c94fc9 	bic	r4, r9, r9, asr #31
    a564:	e58d4030 	str	r4, [sp, #48]	; 0x30
    a568:	eb00292d 	bl	14a24 <__aeabi_i2d>
    a56c:	e1a04184 	lsl	r4, r4, #3
    a570:	e1cd02f0 	strd	r0, [sp, #32]
    a574:	e1a02004 	mov	r2, r4
    a578:	e3a01000 	mov	r1, #0
    a57c:	e28800a8 	add	r0, r8, #168	; 0xa8
    a580:	eb00387c 	bl	18778 <memset>
    a584:	e1a02004 	mov	r2, r4
    a588:	e3a01000 	mov	r1, #0
    a58c:	e28800c0 	add	r0, r8, #192	; 0xc0
    a590:	eb003878 	bl	18778 <memset>
    a594:	e1a02004 	mov	r2, r4
    a598:	e3a01000 	mov	r1, #0
    a59c:	e28800d8 	add	r0, r8, #216	; 0xd8
    a5a0:	eb003874 	bl	18778 <memset>
    a5a4:	e1a02004 	mov	r2, r4
    a5a8:	e3a01000 	mov	r1, #0
    a5ac:	e28800f0 	add	r0, r8, #240	; 0xf0
    a5b0:	eb003870 	bl	18778 <memset>
    a5b4:	e1a02004 	mov	r2, r4
    a5b8:	e3a01000 	mov	r1, #0
    a5bc:	e2880f42 	add	r0, r8, #264	; 0x108
    a5c0:	eb00386c 	bl	18778 <memset>
    a5c4:	e1a02004 	mov	r2, r4
    a5c8:	e3a01000 	mov	r1, #0
    a5cc:	e2880e12 	add	r0, r8, #288	; 0x120
    a5d0:	eb003868 	bl	18778 <memset>
    a5d4:	e1a02004 	mov	r2, r4
    a5d8:	e3a01000 	mov	r1, #0
    a5dc:	e2880f4e 	add	r0, r8, #312	; 0x138
    a5e0:	eb003864 	bl	18778 <memset>
    a5e4:	e1a02004 	mov	r2, r4
    a5e8:	e3a01000 	mov	r1, #0
    a5ec:	e2880e15 	add	r0, r8, #336	; 0x150
    a5f0:	eb003860 	bl	18778 <memset>
    a5f4:	e1a02004 	mov	r2, r4
    a5f8:	e3a01000 	mov	r1, #0
    a5fc:	e2880f5a 	add	r0, r8, #360	; 0x168
    a600:	eb00385c 	bl	18778 <memset>
    a604:	e1a02004 	mov	r2, r4
    a608:	e3a01000 	mov	r1, #0
    a60c:	e2880d06 	add	r0, r8, #384	; 0x180
    a610:	eb003858 	bl	18778 <memset>
    a614:	e1a02004 	mov	r2, r4
    a618:	e3a01000 	mov	r1, #0
    a61c:	e2880f66 	add	r0, r8, #408	; 0x198
    a620:	eb003854 	bl	18778 <memset>
    a624:	e1a02004 	mov	r2, r4
    a628:	e3a01000 	mov	r1, #0
    a62c:	e2880e1b 	add	r0, r8, #432	; 0x1b0
    a630:	eb003850 	bl	18778 <memset>
    a634:	e1a02004 	mov	r2, r4
    a638:	e3a01000 	mov	r1, #0
    a63c:	e2880f72 	add	r0, r8, #456	; 0x1c8
    a640:	eb00384c 	bl	18778 <memset>
    a644:	e1a02004 	mov	r2, r4
    a648:	e2880e1e 	add	r0, r8, #480	; 0x1e0
    a64c:	e3a01000 	mov	r1, #0
    a650:	eb003848 	bl	18778 <memset>
                YT[1]=YT[2]+WSIN;
                YT[3]=YT[2]-WSIN;
                Z=ZERO;
                for (k = 0; k < NS; k++) {
                    link_ptr = (struct link *) G_MALLOC(sizeof(link_type));
                    for (atom = 0; atom < NATOMS; atom++) {
    a654:	e3590000 	cmp	r9, #0
    a658:	da000071 	ble	a824 <INITIA+0x574>

                        /* displacements for atom */
                        link_ptr->mol.F[DISP][XDIR][atom] = XT[atom+1];
    a65c:	e59d0094 	ldr	r0, [sp, #148]	; 0x94
    a660:	eb0028ef 	bl	14a24 <__aeabi_i2d>
    a664:	e1c801f8 	strd	r0, [r8, #24]
                        link_ptr->mol.F[DISP][YDIR][atom] = YT[atom+1];
    a668:	e59d00a4 	ldr	r0, [sp, #164]	; 0xa4
    a66c:	eb0028ec 	bl	14a24 <__aeabi_i2d>
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][YDIR][atom] = *static_var;
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][ZDIR][atom] = *static_var;

			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
    a670:	e59f5738 	ldr	r5, [pc, #1848]	; adb0 <INITIA+0xb00>
    a674:	e08b308b 	add	r3, fp, fp, lsl #1
    a678:	e1a03183 	lsl	r3, r3, #3
    a67c:	e085c003 	add	ip, r5, r3
    a680:	e18320d5 	ldrd	r2, [r3, r5]
			link_ptr->mol.F[VEL][YDIR][atom] = g_random[line][1];
			link_ptr->mol.F[VEL][ZDIR][atom] = g_random[line][2];
    a684:	e1cc41d0 	ldrd	r4, [ip, #16]
    a688:	e1cd40f0 	strd	r4, [sp]
//			link_ptr->mol.F[VEL][YDIR][atom] = *static_var;
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][ZDIR][atom] = *static_var;

			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
			link_ptr->mol.F[VEL][YDIR][atom] = g_random[line][1];
    a68c:	e1cc60d8 	ldrd	r6, [ip, #8]
                    for (atom = 0; atom < NATOMS; atom++) {

                        /* displacements for atom */
                        link_ptr->mol.F[DISP][XDIR][atom] = XT[atom+1];
                        link_ptr->mol.F[DISP][YDIR][atom] = YT[atom+1];
                        link_ptr->mol.F[DISP][ZDIR][atom] = Z;
    a690:	e1cd42d0 	ldrd	r4, [sp, #32]
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][YDIR][atom] = *static_var;
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][ZDIR][atom] = *static_var;

			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
    a694:	e1c826f0 	strd	r2, [r8, #96]	; 0x60
                    link_ptr = (struct link *) G_MALLOC(sizeof(link_type));
                    for (atom = 0; atom < NATOMS; atom++) {

                        /* displacements for atom */
                        link_ptr->mol.F[DISP][XDIR][atom] = XT[atom+1];
                        link_ptr->mol.F[DISP][YDIR][atom] = YT[atom+1];
    a698:	e1c803f0 	strd	r0, [r8, #48]	; 0x30
//            printf("%d %lf %lf %lf\n", line, g_random[line][0],g_random[line][1],g_random[line][2]);
            line++;

#endif
                        /* read random velocities from file random.in */
                        SUMX = SUMX + link_ptr->mol.F[VEL][XDIR][atom];
    a69c:	e1cd01d8 	ldrd	r0, [sp, #24]
                    for (atom = 0; atom < NATOMS; atom++) {

                        /* displacements for atom */
                        link_ptr->mol.F[DISP][XDIR][atom] = XT[atom+1];
                        link_ptr->mol.F[DISP][YDIR][atom] = YT[atom+1];
                        link_ptr->mol.F[DISP][ZDIR][atom] = Z;
    a6a0:	e1c844f8 	strd	r4, [r8, #72]	; 0x48
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][ZDIR][atom] = *static_var;

			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
			link_ptr->mol.F[VEL][YDIR][atom] = g_random[line][1];
			link_ptr->mol.F[VEL][ZDIR][atom] = g_random[line][2];
    a6a4:	e1cd40d0 	ldrd	r4, [sp]
//			link_ptr->mol.F[VEL][YDIR][atom] = *static_var;
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][ZDIR][atom] = *static_var;

			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
			link_ptr->mol.F[VEL][YDIR][atom] = g_random[line][1];
    a6a8:	e1c867f8 	strd	r6, [r8, #120]	; 0x78
			link_ptr->mol.F[VEL][ZDIR][atom] = g_random[line][2];
    a6ac:	e1c849f0 	strd	r4, [r8, #144]	; 0x90
//            printf("%d %lf %lf %lf\n", line, g_random[line][0],g_random[line][1],g_random[line][2]);
            line++;

#endif
                        /* read random velocities from file random.in */
                        SUMX = SUMX + link_ptr->mol.F[VEL][XDIR][atom];
    a6b0:	eb00280e 	bl	146f0 <__adddf3>
                        SUMY = SUMY + link_ptr->mol.F[VEL][YDIR][atom];
    a6b4:	e1a02006 	mov	r2, r6
//            printf("%d %lf %lf %lf\n", line, g_random[line][0],g_random[line][1],g_random[line][2]);
            line++;

#endif
                        /* read random velocities from file random.in */
                        SUMX = SUMX + link_ptr->mol.F[VEL][XDIR][atom];
    a6b8:	e1cd01f8 	strd	r0, [sp, #24]
                        SUMY = SUMY + link_ptr->mol.F[VEL][YDIR][atom];
    a6bc:	e1cd01d0 	ldrd	r0, [sp, #16]
    a6c0:	e1a03007 	mov	r3, r7
    a6c4:	eb002809 	bl	146f0 <__adddf3>
                        SUMZ = SUMZ + link_ptr->mol.F[VEL][ZDIR][atom];
    a6c8:	e1cd20d0 	ldrd	r2, [sp]
            line++;

#endif
                        /* read random velocities from file random.in */
                        SUMX = SUMX + link_ptr->mol.F[VEL][XDIR][atom];
                        SUMY = SUMY + link_ptr->mol.F[VEL][YDIR][atom];
    a6cc:	e1cd01f0 	strd	r0, [sp, #16]
                        SUMZ = SUMZ + link_ptr->mol.F[VEL][ZDIR][atom];
    a6d0:	e1cd00d8 	ldrd	r0, [sp, #8]
    a6d4:	eb002805 	bl	146f0 <__adddf3>
                        for (deriv = ACC; deriv < MAXODR; deriv++) {
                            link_ptr->mol.F[deriv][XDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][YDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][ZDIR][atom] = 0.0;
    a6d8:	e3a02f7e 	mov	r2, #504	; 0x1f8

#endif
                        /* read random velocities from file random.in */
                        SUMX = SUMX + link_ptr->mol.F[VEL][XDIR][atom];
                        SUMY = SUMY + link_ptr->mol.F[VEL][YDIR][atom];
                        SUMZ = SUMZ + link_ptr->mol.F[VEL][ZDIR][atom];
    a6dc:	e1cd00f8 	strd	r0, [sp, #8]
                        for (deriv = ACC; deriv < MAXODR; deriv++) {
                            link_ptr->mol.F[deriv][XDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][YDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][ZDIR][atom] = 0.0;
    a6e0:	e3a00000 	mov	r0, #0
    a6e4:	e3a01000 	mov	r1, #0
                YT[1]=YT[2]+WSIN;
                YT[3]=YT[2]-WSIN;
                Z=ZERO;
                for (k = 0; k < NS; k++) {
                    link_ptr = (struct link *) G_MALLOC(sizeof(link_type));
                    for (atom = 0; atom < NATOMS; atom++) {
    a6e8:	e3590001 	cmp	r9, #1
                        SUMY = SUMY + link_ptr->mol.F[VEL][YDIR][atom];
                        SUMZ = SUMZ + link_ptr->mol.F[VEL][ZDIR][atom];
                        for (deriv = ACC; deriv < MAXODR; deriv++) {
                            link_ptr->mol.F[deriv][XDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][YDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][ZDIR][atom] = 0.0;
    a6ec:	e18800f2 	strd	r0, [r8, r2]
			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
			link_ptr->mol.F[VEL][YDIR][atom] = g_random[line][1];
			link_ptr->mol.F[VEL][ZDIR][atom] = g_random[line][2];

//            printf("%d %lf %lf %lf\n", line, g_random[line][0],g_random[line][1],g_random[line][2]);
            line++;
    a6f0:	e28b4001 	add	r4, fp, #1
                YT[1]=YT[2]+WSIN;
                YT[3]=YT[2]-WSIN;
                Z=ZERO;
                for (k = 0; k < NS; k++) {
                    link_ptr = (struct link *) G_MALLOC(sizeof(link_type));
                    for (atom = 0; atom < NATOMS; atom++) {
    a6f4:	0a00004a 	beq	a824 <INITIA+0x574>

                        /* displacements for atom */
                        link_ptr->mol.F[DISP][XDIR][atom] = XT[atom+1];
    a6f8:	e59d0098 	ldr	r0, [sp, #152]	; 0x98
    a6fc:	eb0028c8 	bl	14a24 <__aeabi_i2d>
    a700:	e1c802f0 	strd	r0, [r8, #32]
                        link_ptr->mol.F[DISP][YDIR][atom] = YT[atom+1];
    a704:	e59d00a8 	ldr	r0, [sp, #168]	; 0xa8
    a708:	eb0028c5 	bl	14a24 <__aeabi_i2d>
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][YDIR][atom] = *static_var;
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][ZDIR][atom] = *static_var;

			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
    a70c:	e0844084 	add	r4, r4, r4, lsl #1
    a710:	e59f3698 	ldr	r3, [pc, #1688]	; adb0 <INITIA+0xb00>
    a714:	e1a04184 	lsl	r4, r4, #3
    a718:	e083c004 	add	ip, r3, r4
    a71c:	e18320d4 	ldrd	r2, [r3, r4]
			link_ptr->mol.F[VEL][YDIR][atom] = g_random[line][1];
			link_ptr->mol.F[VEL][ZDIR][atom] = g_random[line][2];
    a720:	e1cc41d0 	ldrd	r4, [ip, #16]
    a724:	e1cd40f0 	strd	r4, [sp]
//			link_ptr->mol.F[VEL][YDIR][atom] = *static_var;
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][ZDIR][atom] = *static_var;

			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
			link_ptr->mol.F[VEL][YDIR][atom] = g_random[line][1];
    a728:	e1cc60d8 	ldrd	r6, [ip, #8]
                    for (atom = 0; atom < NATOMS; atom++) {

                        /* displacements for atom */
                        link_ptr->mol.F[DISP][XDIR][atom] = XT[atom+1];
                        link_ptr->mol.F[DISP][YDIR][atom] = YT[atom+1];
                        link_ptr->mol.F[DISP][ZDIR][atom] = Z;
    a72c:	e1cd42d0 	ldrd	r4, [sp, #32]
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][YDIR][atom] = *static_var;
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][ZDIR][atom] = *static_var;

			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
    a730:	e1c826f8 	strd	r2, [r8, #104]	; 0x68
                    link_ptr = (struct link *) G_MALLOC(sizeof(link_type));
                    for (atom = 0; atom < NATOMS; atom++) {

                        /* displacements for atom */
                        link_ptr->mol.F[DISP][XDIR][atom] = XT[atom+1];
                        link_ptr->mol.F[DISP][YDIR][atom] = YT[atom+1];
    a734:	e1c803f8 	strd	r0, [r8, #56]	; 0x38
//            printf("%d %lf %lf %lf\n", line, g_random[line][0],g_random[line][1],g_random[line][2]);
            line++;

#endif
                        /* read random velocities from file random.in */
                        SUMX = SUMX + link_ptr->mol.F[VEL][XDIR][atom];
    a738:	e1cd01d8 	ldrd	r0, [sp, #24]
                    for (atom = 0; atom < NATOMS; atom++) {

                        /* displacements for atom */
                        link_ptr->mol.F[DISP][XDIR][atom] = XT[atom+1];
                        link_ptr->mol.F[DISP][YDIR][atom] = YT[atom+1];
                        link_ptr->mol.F[DISP][ZDIR][atom] = Z;
    a73c:	e1c845f0 	strd	r4, [r8, #80]	; 0x50
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][ZDIR][atom] = *static_var;

			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
			link_ptr->mol.F[VEL][YDIR][atom] = g_random[line][1];
			link_ptr->mol.F[VEL][ZDIR][atom] = g_random[line][2];
    a740:	e1cd40d0 	ldrd	r4, [sp]
//			link_ptr->mol.F[VEL][YDIR][atom] = *static_var;
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][ZDIR][atom] = *static_var;

			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
			link_ptr->mol.F[VEL][YDIR][atom] = g_random[line][1];
    a744:	e1c868f0 	strd	r6, [r8, #128]	; 0x80
			link_ptr->mol.F[VEL][ZDIR][atom] = g_random[line][2];
    a748:	e1c849f8 	strd	r4, [r8, #152]	; 0x98
//            printf("%d %lf %lf %lf\n", line, g_random[line][0],g_random[line][1],g_random[line][2]);
            line++;

#endif
                        /* read random velocities from file random.in */
                        SUMX = SUMX + link_ptr->mol.F[VEL][XDIR][atom];
    a74c:	eb0027e7 	bl	146f0 <__adddf3>
                        SUMY = SUMY + link_ptr->mol.F[VEL][YDIR][atom];
    a750:	e1a02006 	mov	r2, r6
//            printf("%d %lf %lf %lf\n", line, g_random[line][0],g_random[line][1],g_random[line][2]);
            line++;

#endif
                        /* read random velocities from file random.in */
                        SUMX = SUMX + link_ptr->mol.F[VEL][XDIR][atom];
    a754:	e1cd01f8 	strd	r0, [sp, #24]
                        SUMY = SUMY + link_ptr->mol.F[VEL][YDIR][atom];
    a758:	e1cd01d0 	ldrd	r0, [sp, #16]
    a75c:	e1a03007 	mov	r3, r7
    a760:	eb0027e2 	bl	146f0 <__adddf3>
                        SUMZ = SUMZ + link_ptr->mol.F[VEL][ZDIR][atom];
    a764:	e1cd20d0 	ldrd	r2, [sp]
            line++;

#endif
                        /* read random velocities from file random.in */
                        SUMX = SUMX + link_ptr->mol.F[VEL][XDIR][atom];
                        SUMY = SUMY + link_ptr->mol.F[VEL][YDIR][atom];
    a768:	e1cd01f0 	strd	r0, [sp, #16]
                        SUMZ = SUMZ + link_ptr->mol.F[VEL][ZDIR][atom];
    a76c:	e1cd00d8 	ldrd	r0, [sp, #8]
    a770:	eb0027de 	bl	146f0 <__adddf3>
                        for (deriv = ACC; deriv < MAXODR; deriv++) {
                            link_ptr->mol.F[deriv][XDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][YDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][ZDIR][atom] = 0.0;
    a774:	e3a02c02 	mov	r2, #512	; 0x200

#endif
                        /* read random velocities from file random.in */
                        SUMX = SUMX + link_ptr->mol.F[VEL][XDIR][atom];
                        SUMY = SUMY + link_ptr->mol.F[VEL][YDIR][atom];
                        SUMZ = SUMZ + link_ptr->mol.F[VEL][ZDIR][atom];
    a778:	e1cd00f8 	strd	r0, [sp, #8]
                        for (deriv = ACC; deriv < MAXODR; deriv++) {
                            link_ptr->mol.F[deriv][XDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][YDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][ZDIR][atom] = 0.0;
    a77c:	e3a00000 	mov	r0, #0
    a780:	e3a01000 	mov	r1, #0
                YT[1]=YT[2]+WSIN;
                YT[3]=YT[2]-WSIN;
                Z=ZERO;
                for (k = 0; k < NS; k++) {
                    link_ptr = (struct link *) G_MALLOC(sizeof(link_type));
                    for (atom = 0; atom < NATOMS; atom++) {
    a784:	e3590002 	cmp	r9, #2
                        SUMY = SUMY + link_ptr->mol.F[VEL][YDIR][atom];
                        SUMZ = SUMZ + link_ptr->mol.F[VEL][ZDIR][atom];
                        for (deriv = ACC; deriv < MAXODR; deriv++) {
                            link_ptr->mol.F[deriv][XDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][YDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][ZDIR][atom] = 0.0;
    a788:	e18800f2 	strd	r0, [r8, r2]
			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
			link_ptr->mol.F[VEL][YDIR][atom] = g_random[line][1];
			link_ptr->mol.F[VEL][ZDIR][atom] = g_random[line][2];

//            printf("%d %lf %lf %lf\n", line, g_random[line][0],g_random[line][1],g_random[line][2]);
            line++;
    a78c:	e28b4002 	add	r4, fp, #2
                YT[1]=YT[2]+WSIN;
                YT[3]=YT[2]-WSIN;
                Z=ZERO;
                for (k = 0; k < NS; k++) {
                    link_ptr = (struct link *) G_MALLOC(sizeof(link_type));
                    for (atom = 0; atom < NATOMS; atom++) {
    a790:	0a000023 	beq	a824 <INITIA+0x574>

                        /* displacements for atom */
                        link_ptr->mol.F[DISP][XDIR][atom] = XT[atom+1];
    a794:	e59d009c 	ldr	r0, [sp, #156]	; 0x9c
    a798:	eb0028a1 	bl	14a24 <__aeabi_i2d>
    a79c:	e1c802f8 	strd	r0, [r8, #40]	; 0x28
                        link_ptr->mol.F[DISP][YDIR][atom] = YT[atom+1];
    a7a0:	e59d00ac 	ldr	r0, [sp, #172]	; 0xac
    a7a4:	eb00289e 	bl	14a24 <__aeabi_i2d>
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][YDIR][atom] = *static_var;
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][ZDIR][atom] = *static_var;

			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
    a7a8:	e0844084 	add	r4, r4, r4, lsl #1
    a7ac:	e59f35fc 	ldr	r3, [pc, #1532]	; adb0 <INITIA+0xb00>
    a7b0:	e1a04184 	lsl	r4, r4, #3
    a7b4:	e083c004 	add	ip, r3, r4
    a7b8:	e18320d4 	ldrd	r2, [r3, r4]
			link_ptr->mol.F[VEL][YDIR][atom] = g_random[line][1];
			link_ptr->mol.F[VEL][ZDIR][atom] = g_random[line][2];
    a7bc:	e1cc41d0 	ldrd	r4, [ip, #16]
    a7c0:	e1cd40f0 	strd	r4, [sp]
//			link_ptr->mol.F[VEL][YDIR][atom] = *static_var;
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][ZDIR][atom] = *static_var;

			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
			link_ptr->mol.F[VEL][YDIR][atom] = g_random[line][1];
    a7c4:	e1cc60d8 	ldrd	r6, [ip, #8]
                    for (atom = 0; atom < NATOMS; atom++) {

                        /* displacements for atom */
                        link_ptr->mol.F[DISP][XDIR][atom] = XT[atom+1];
                        link_ptr->mol.F[DISP][YDIR][atom] = YT[atom+1];
                        link_ptr->mol.F[DISP][ZDIR][atom] = Z;
    a7c8:	e1cd42d0 	ldrd	r4, [sp, #32]
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][YDIR][atom] = *static_var;
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][ZDIR][atom] = *static_var;

			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
    a7cc:	e1c827f0 	strd	r2, [r8, #112]	; 0x70
                    link_ptr = (struct link *) G_MALLOC(sizeof(link_type));
                    for (atom = 0; atom < NATOMS; atom++) {

                        /* displacements for atom */
                        link_ptr->mol.F[DISP][XDIR][atom] = XT[atom+1];
                        link_ptr->mol.F[DISP][YDIR][atom] = YT[atom+1];
    a7d0:	e1c804f0 	strd	r0, [r8, #64]	; 0x40
//            printf("%d %lf %lf %lf\n", line, g_random[line][0],g_random[line][1],g_random[line][2]);
            line++;

#endif
                        /* read random velocities from file random.in */
                        SUMX = SUMX + link_ptr->mol.F[VEL][XDIR][atom];
    a7d4:	e1cd01d8 	ldrd	r0, [sp, #24]
                    for (atom = 0; atom < NATOMS; atom++) {

                        /* displacements for atom */
                        link_ptr->mol.F[DISP][XDIR][atom] = XT[atom+1];
                        link_ptr->mol.F[DISP][YDIR][atom] = YT[atom+1];
                        link_ptr->mol.F[DISP][ZDIR][atom] = Z;
    a7d8:	e1c845f8 	strd	r4, [r8, #88]	; 0x58
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][ZDIR][atom] = *static_var;

			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
			link_ptr->mol.F[VEL][YDIR][atom] = g_random[line][1];
			link_ptr->mol.F[VEL][ZDIR][atom] = g_random[line][2];
    a7dc:	e1cd40d0 	ldrd	r4, [sp]
//			link_ptr->mol.F[VEL][YDIR][atom] = *static_var;
//			fscanf(random_numbers,"%lf",static_var);
//			link_ptr->mol.F[VEL][ZDIR][atom] = *static_var;

			link_ptr->mol.F[VEL][XDIR][atom] = g_random[line][0];
			link_ptr->mol.F[VEL][YDIR][atom] = g_random[line][1];
    a7e0:	e1c868f8 	strd	r6, [r8, #136]	; 0x88
			link_ptr->mol.F[VEL][ZDIR][atom] = g_random[line][2];
    a7e4:	e1c84af0 	strd	r4, [r8, #160]	; 0xa0
//            printf("%d %lf %lf %lf\n", line, g_random[line][0],g_random[line][1],g_random[line][2]);
            line++;

#endif
                        /* read random velocities from file random.in */
                        SUMX = SUMX + link_ptr->mol.F[VEL][XDIR][atom];
    a7e8:	eb0027c0 	bl	146f0 <__adddf3>
                        SUMY = SUMY + link_ptr->mol.F[VEL][YDIR][atom];
    a7ec:	e1a02006 	mov	r2, r6
//            printf("%d %lf %lf %lf\n", line, g_random[line][0],g_random[line][1],g_random[line][2]);
            line++;

#endif
                        /* read random velocities from file random.in */
                        SUMX = SUMX + link_ptr->mol.F[VEL][XDIR][atom];
    a7f0:	e1cd01f8 	strd	r0, [sp, #24]
                        SUMY = SUMY + link_ptr->mol.F[VEL][YDIR][atom];
    a7f4:	e1cd01d0 	ldrd	r0, [sp, #16]
    a7f8:	e1a03007 	mov	r3, r7
    a7fc:	eb0027bb 	bl	146f0 <__adddf3>
                        SUMZ = SUMZ + link_ptr->mol.F[VEL][ZDIR][atom];
    a800:	e1cd20d0 	ldrd	r2, [sp]
            line++;

#endif
                        /* read random velocities from file random.in */
                        SUMX = SUMX + link_ptr->mol.F[VEL][XDIR][atom];
                        SUMY = SUMY + link_ptr->mol.F[VEL][YDIR][atom];
    a804:	e1cd01f0 	strd	r0, [sp, #16]
                        SUMZ = SUMZ + link_ptr->mol.F[VEL][ZDIR][atom];
    a808:	e1cd00d8 	ldrd	r0, [sp, #8]
    a80c:	eb0027b7 	bl	146f0 <__adddf3>
                        for (deriv = ACC; deriv < MAXODR; deriv++) {
                            link_ptr->mol.F[deriv][XDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][YDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][ZDIR][atom] = 0.0;
    a810:	e3a03f82 	mov	r3, #520	; 0x208

#endif
                        /* read random velocities from file random.in */
                        SUMX = SUMX + link_ptr->mol.F[VEL][XDIR][atom];
                        SUMY = SUMY + link_ptr->mol.F[VEL][YDIR][atom];
                        SUMZ = SUMZ + link_ptr->mol.F[VEL][ZDIR][atom];
    a814:	e1cd00f8 	strd	r0, [sp, #8]
                        for (deriv = ACC; deriv < MAXODR; deriv++) {
                            link_ptr->mol.F[deriv][XDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][YDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][ZDIR][atom] = 0.0;
    a818:	e3a00000 	mov	r0, #0
    a81c:	e3a01000 	mov	r1, #0
    a820:	e18800f3 	strd	r0, [r8, r3]
                        }
                    }

                    link_ptr->next_mol = NULL;        /* Terminating link */
                    mol++;
                    Z += XS;
    a824:	e1cd22d0 	ldrd	r2, [sp, #32]
                            link_ptr->mol.F[deriv][YDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][ZDIR][atom] = 0.0;
                        }
                    }

                    link_ptr->next_mol = NULL;        /* Terminating link */
    a828:	e3a04000 	mov	r4, #0
                    mol++;
                    Z += XS;
    a82c:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
                            link_ptr->mol.F[deriv][YDIR][atom] = 0.0;
                            link_ptr->mol.F[deriv][ZDIR][atom] = 0.0;
                        }
                    }

                    link_ptr->next_mol = NULL;        /* Terminating link */
    a830:	e58842a0 	str	r4, [r8, #672]	; 0x2a0
                    mol++;
                    Z += XS;
    a834:	eb0027ad 	bl	146f0 <__adddf3>
    a838:	eb002a28 	bl	150e0 <__aeabi_d2iz>

                    /* update box numbers in all dimensions */

                    X_INDEX = (long) (link_ptr->mol.F[DISP][XDIR][O]/BOX_LENGTH);
    a83c:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
                        }
                    }

                    link_ptr->next_mol = NULL;        /* Terminating link */
                    mol++;
                    Z += XS;
    a840:	e1a04000 	mov	r4, r0

                    /* update box numbers in all dimensions */

                    X_INDEX = (long) (link_ptr->mol.F[DISP][XDIR][O]/BOX_LENGTH);
    a844:	e1c802d0 	ldrd	r0, [r8, #32]
    a848:	eb002950 	bl	14d90 <__aeabi_ddiv>
    a84c:	eb002a23 	bl	150e0 <__aeabi_d2iz>
                    Y_INDEX = (long) (link_ptr->mol.F[DISP][YDIR][O]/BOX_LENGTH);
    a850:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
                    mol++;
                    Z += XS;

                    /* update box numbers in all dimensions */

                    X_INDEX = (long) (link_ptr->mol.F[DISP][XDIR][O]/BOX_LENGTH);
    a854:	e1a06000 	mov	r6, r0
                    Y_INDEX = (long) (link_ptr->mol.F[DISP][YDIR][O]/BOX_LENGTH);
    a858:	e1c803d8 	ldrd	r0, [r8, #56]	; 0x38
    a85c:	eb00294b 	bl	14d90 <__aeabi_ddiv>
    a860:	eb002a1e 	bl	150e0 <__aeabi_d2iz>
                    Z_INDEX = (long) (link_ptr->mol.F[DISP][ZDIR][O]/BOX_LENGTH);
    a864:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
                    Z += XS;

                    /* update box numbers in all dimensions */

                    X_INDEX = (long) (link_ptr->mol.F[DISP][XDIR][O]/BOX_LENGTH);
                    Y_INDEX = (long) (link_ptr->mol.F[DISP][YDIR][O]/BOX_LENGTH);
    a868:	e1a05000 	mov	r5, r0
                    Z_INDEX = (long) (link_ptr->mol.F[DISP][ZDIR][O]/BOX_LENGTH);
    a86c:	e1c805d0 	ldrd	r0, [r8, #80]	; 0x50
    a870:	eb002946 	bl	14d90 <__aeabi_ddiv>
    a874:	eb002a19 	bl	150e0 <__aeabi_d2iz>

                    /* Put X_, Y_, and Z_INDEX back in box */

                    if (X_INDEX >=BOX_PER_SIDE) X_INDEX -= 1;
    a878:	e59fc554 	ldr	ip, [pc, #1364]	; add4 <INITIA+0xb24>
                            link_ptr->mol.F[deriv][ZDIR][atom] = 0.0;
                        }
                    }

                    link_ptr->next_mol = NULL;        /* Terminating link */
                    mol++;
    a87c:	e28aa001 	add	sl, sl, #1
                    Y_INDEX = (long) (link_ptr->mol.F[DISP][YDIR][O]/BOX_LENGTH);
                    Z_INDEX = (long) (link_ptr->mol.F[DISP][ZDIR][O]/BOX_LENGTH);

                    /* Put X_, Y_, and Z_INDEX back in box */

                    if (X_INDEX >=BOX_PER_SIDE) X_INDEX -= 1;
    a880:	e59c3000 	ldr	r3, [ip]
    a884:	e59dc030 	ldr	ip, [sp, #48]	; 0x30
    a888:	e1560003 	cmp	r6, r3
    a88c:	e08bb00c 	add	fp, fp, ip
                    if (Y_INDEX >=BOX_PER_SIDE) Y_INDEX -= 1;
                    if (Z_INDEX >=BOX_PER_SIDE) Z_INDEX -= 1;

                    /* get list ptr */
                    curr_ptr = BOX[X_INDEX][Y_INDEX][Z_INDEX].list;
    a890:	e59dc054 	ldr	ip, [sp, #84]	; 0x54
                    Y_INDEX = (long) (link_ptr->mol.F[DISP][YDIR][O]/BOX_LENGTH);
                    Z_INDEX = (long) (link_ptr->mol.F[DISP][ZDIR][O]/BOX_LENGTH);

                    /* Put X_, Y_, and Z_INDEX back in box */

                    if (X_INDEX >=BOX_PER_SIDE) X_INDEX -= 1;
    a894:	a2466001 	subge	r6, r6, #1
                    if (Y_INDEX >=BOX_PER_SIDE) Y_INDEX -= 1;
    a898:	e1550003 	cmp	r5, r3
    a89c:	a2455001 	subge	r5, r5, #1
                    if (Z_INDEX >=BOX_PER_SIDE) Z_INDEX -= 1;
    a8a0:	e1500003 	cmp	r0, r3

                    /* get list ptr */
                    curr_ptr = BOX[X_INDEX][Y_INDEX][Z_INDEX].list;
    a8a4:	e79c3106 	ldr	r3, [ip, r6, lsl #2]

                    /* Put X_, Y_, and Z_INDEX back in box */

                    if (X_INDEX >=BOX_PER_SIDE) X_INDEX -= 1;
                    if (Y_INDEX >=BOX_PER_SIDE) Y_INDEX -= 1;
                    if (Z_INDEX >=BOX_PER_SIDE) Z_INDEX -= 1;
    a8a8:	a2400001 	subge	r0, r0, #1

                    /* get list ptr */
                    curr_ptr = BOX[X_INDEX][Y_INDEX][Z_INDEX].list;
    a8ac:	e7933105 	ldr	r3, [r3, r5, lsl #2]
    a8b0:	e7932200 	ldr	r2, [r3, r0, lsl #4]

                    if (curr_ptr == NULL) {             /* No links in box yet */
    a8b4:	e3520000 	cmp	r2, #0
                        BOX[X_INDEX][Y_INDEX][Z_INDEX].list = link_ptr;
    a8b8:	07838200 	streq	r8, [r3, r0, lsl #4]
                    if (Z_INDEX >=BOX_PER_SIDE) Z_INDEX -= 1;

                    /* get list ptr */
                    curr_ptr = BOX[X_INDEX][Y_INDEX][Z_INDEX].list;

                    if (curr_ptr == NULL) {             /* No links in box yet */
    a8bc:	1a000001 	bne	a8c8 <INITIA+0x618>
    a8c0:	ea000004 	b	a8d8 <INITIA+0x628>
                        BOX[X_INDEX][Y_INDEX][Z_INDEX].list = link_ptr;
                    } else {
                        while (curr_ptr) {               /* Scan to end of list */
                            last_ptr = curr_ptr;
                            curr_ptr = curr_ptr->next_mol;
    a8c4:	e1a02003 	mov	r2, r3
    a8c8:	e59232a0 	ldr	r3, [r2, #672]	; 0x2a0
                    curr_ptr = BOX[X_INDEX][Y_INDEX][Z_INDEX].list;

                    if (curr_ptr == NULL) {             /* No links in box yet */
                        BOX[X_INDEX][Y_INDEX][Z_INDEX].list = link_ptr;
                    } else {
                        while (curr_ptr) {               /* Scan to end of list */
    a8cc:	e3530000 	cmp	r3, #0
    a8d0:	1afffffb 	bne	a8c4 <INITIA+0x614>
                            last_ptr = curr_ptr;
                            curr_ptr = curr_ptr->next_mol;
                        } /* while curr_ptr */
                        last_ptr->next_mol = link_ptr;    /* Add to end of list */
    a8d4:	e58282a0 	str	r8, [r2, #672]	; 0x2a0
            YT[2]=ZERO;
            for (j=0; j < NS; j+=1) {
                YT[1]=YT[2]+WSIN;
                YT[3]=YT[2]-WSIN;
                Z=ZERO;
                for (k = 0; k < NS; k++) {
    a8d8:	e59d5038 	ldr	r5, [sp, #56]	; 0x38
    a8dc:	e065000a 	rsb	r0, r5, sl
    a8e0:	eb00284f 	bl	14a24 <__aeabi_i2d>
    a8e4:	e1a02000 	mov	r2, r0
    a8e8:	e1a03001 	mov	r3, r1
    a8ec:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    a8f0:	eb0029f4 	bl	150c8 <__aeabi_dcmpgt>
    a8f4:	e3500000 	cmp	r0, #0
    a8f8:	1affff12 	bne	a548 <INITIA+0x298>
                        } /* while curr_ptr */
                        last_ptr->next_mol = link_ptr;    /* Add to end of list */
                    } /* if curr_ptr */

                } /* for k */
                YT[2] += XS;
    a8fc:	e1cd26d8 	ldrd	r2, [sp, #104]	; 0x68
    a900:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    a904:	eb002779 	bl	146f0 <__adddf3>
    a908:	eb0029f4 	bl	150e0 <__aeabi_d2iz>
    a90c:	e1a04000 	mov	r4, r0

        for (i=0; i < NS; i++) {
            XT[1]=XT[2]+WCOS;
            XT[3]=XT[1];
            YT[2]=ZERO;
            for (j=0; j < NS; j+=1) {
    a910:	e59dc078 	ldr	ip, [sp, #120]	; 0x78
                        } /* while curr_ptr */
                        last_ptr->next_mol = link_ptr;    /* Add to end of list */
                    } /* if curr_ptr */

                } /* for k */
                YT[2] += XS;
    a914:	e58d40a8 	str	r4, [sp, #168]	; 0xa8

        for (i=0; i < NS; i++) {
            XT[1]=XT[2]+WCOS;
            XT[3]=XT[1];
            YT[2]=ZERO;
            for (j=0; j < NS; j+=1) {
    a918:	e28cc001 	add	ip, ip, #1
    a91c:	e1a0000c 	mov	r0, ip
    a920:	e58dc078 	str	ip, [sp, #120]	; 0x78
    a924:	eb00283e 	bl	14a24 <__aeabi_i2d>
    a928:	e1a02000 	mov	r2, r0
    a92c:	e1a03001 	mov	r3, r1
    a930:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    a934:	eb0029e3 	bl	150c8 <__aeabi_dcmpgt>
    a938:	e3500000 	cmp	r0, #0
                            link_ptr->mol.F[deriv][ZDIR][atom] = 0.0;
                        }
                    }

                    link_ptr->next_mol = NULL;        /* Terminating link */
                    mol++;
    a93c:	e58da038 	str	sl, [sp, #56]	; 0x38

        for (i=0; i < NS; i++) {
            XT[1]=XT[2]+WCOS;
            XT[3]=XT[1];
            YT[2]=ZERO;
            for (j=0; j < NS; j+=1) {
    a940:	1afffef3 	bne	a514 <INITIA+0x264>
                    } /* if curr_ptr */

                } /* for k */
                YT[2] += XS;
            } /* for j */
            XT[2] += XS;
    a944:	e1cd28d8 	ldrd	r2, [sp, #136]	; 0x88
    a948:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    a94c:	eb002767 	bl	146f0 <__adddf3>
    a950:	eb0029e2 	bl	150e0 <__aeabi_d2iz>
    a954:	e1a04000 	mov	r4, r0
        SUMY=0.0;
        SUMZ=0.0;

        /* Generate displacements along a regular lattice */

        for (i=0; i < NS; i++) {
    a958:	e59d507c 	ldr	r5, [sp, #124]	; 0x7c
                    } /* if curr_ptr */

                } /* for k */
                YT[2] += XS;
            } /* for j */
            XT[2] += XS;
    a95c:	e58d4098 	str	r4, [sp, #152]	; 0x98
        SUMY=0.0;
        SUMZ=0.0;

        /* Generate displacements along a regular lattice */

        for (i=0; i < NS; i++) {
    a960:	e2855001 	add	r5, r5, #1
    a964:	e1a00005 	mov	r0, r5
    a968:	e58d507c 	str	r5, [sp, #124]	; 0x7c
    a96c:	eb00282c 	bl	14a24 <__aeabi_i2d>
    a970:	e1a02000 	mov	r2, r0
    a974:	e1a03001 	mov	r3, r1
    a978:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    a97c:	eb0029d1 	bl	150c8 <__aeabi_dcmpgt>
    a980:	e3500000 	cmp	r0, #0
    a984:	1afffed5 	bne	a4e0 <INITIA+0x230>
    a988:	e1cda1d8 	ldrd	sl, [sp, #24]
    a98c:	e59dc038 	ldr	ip, [sp, #56]	; 0x38
    a990:	ea000007 	b	a9b4 <INITIA+0x704>
    fscanf(random_numbers,"%lf",&SUX);
#endif

        SUMX=0.0;
        SUMY=0.0;
        SUMZ=0.0;
    a994:	e3a04000 	mov	r4, #0
    a998:	e3a05000 	mov	r5, #0

#else
    fscanf(random_numbers,"%lf",&SUX);
#endif

        SUMX=0.0;
    a99c:	e1a0a004 	mov	sl, r4
    a9a0:	e1a0b005 	mov	fp, r5
    a9a4:	e1a0c000 	mov	ip, r0
        SUMY=0.0;
        SUMZ=0.0;
    a9a8:	e1cd40f8 	strd	r4, [sp, #8]
#else
    fscanf(random_numbers,"%lf",&SUX);
#endif

        SUMX=0.0;
        SUMY=0.0;
    a9ac:	e1cd41f0 	strd	r4, [sp, #16]
           of preserving bond distances */

        fprintf(six, "***** NEW RUN STARTING FROM REGULAR LATTICE *****\n");
        fflush(six);
        XT[2] = ZERO;
        mol = 0;
    a9b0:	e58d0038 	str	r0, [sp, #56]	; 0x38
                YT[2] += XS;
            } /* for j */
            XT[2] += XS;
        } /* for i */

        if (NMOL != mol) {
    a9b4:	e59f5394 	ldr	r5, [pc, #916]	; ad50 <INITIA+0xaa0>
    a9b8:	e5952000 	ldr	r2, [r5]
    a9bc:	e152000c 	cmp	r2, ip
    a9c0:	1a0001db 	bne	b134 <INITIA+0xe84>
#endif
    }
    /* assign random momenta */
    /* find average momenta per atom */

    SUMX=SUMX/(NATOMS*NMOL);
    a9c4:	e59f43e0 	ldr	r4, [pc, #992]	; adac <INITIA+0xafc>
    a9c8:	e5940000 	ldr	r0, [r4]
    a9cc:	e58d4058 	str	r4, [sp, #88]	; 0x58
    a9d0:	e0000c90 	mul	r0, r0, ip
    a9d4:	eb002812 	bl	14a24 <__aeabi_i2d>
    a9d8:	e1a04000 	mov	r4, r0
    a9dc:	e1a05001 	mov	r5, r1
    a9e0:	e1a0000a 	mov	r0, sl
    a9e4:	e1a0100b 	mov	r1, fp
    a9e8:	e1a02004 	mov	r2, r4
    a9ec:	e1a03005 	mov	r3, r5
    a9f0:	eb0028e6 	bl	14d90 <__aeabi_ddiv>
    SUMY=SUMY/(NATOMS*NMOL);
    a9f4:	e1a02004 	mov	r2, r4
    a9f8:	e1a03005 	mov	r3, r5
#endif
    }
    /* assign random momenta */
    /* find average momenta per atom */

    SUMX=SUMX/(NATOMS*NMOL);
    a9fc:	e1a0a000 	mov	sl, r0
    aa00:	e1a0b001 	mov	fp, r1
    SUMY=SUMY/(NATOMS*NMOL);
    aa04:	e1cd01d0 	ldrd	r0, [sp, #16]
    aa08:	eb0028e0 	bl	14d90 <__aeabi_ddiv>
    SUMZ=SUMZ/(NATOMS*NMOL);
    aa0c:	e1a02004 	mov	r2, r4
    }
    /* assign random momenta */
    /* find average momenta per atom */

    SUMX=SUMX/(NATOMS*NMOL);
    SUMY=SUMY/(NATOMS*NMOL);
    aa10:	e1cd01f0 	strd	r0, [sp, #16]
    SUMZ=SUMZ/(NATOMS*NMOL);
    aa14:	e1cd00d8 	ldrd	r0, [sp, #8]
    aa18:	e1a03005 	mov	r3, r5
    aa1c:	eb0028db 	bl	14d90 <__aeabi_ddiv>

    SUX=0.0;
    SUY=0.0;
    SUZ=0.0;

    for (i=0; i<BOX_PER_SIDE; i++) {
    aa20:	e59fc3ac 	ldr	ip, [pc, #940]	; add4 <INITIA+0xb24>
    /* assign random momenta */
    /* find average momenta per atom */

    SUMX=SUMX/(NATOMS*NMOL);
    SUMY=SUMY/(NATOMS*NMOL);
    SUMZ=SUMZ/(NATOMS*NMOL);
    aa24:	e1cd00f8 	strd	r0, [sp, #8]

    SUX=0.0;
    SUY=0.0;
    SUZ=0.0;

    for (i=0; i<BOX_PER_SIDE; i++) {
    aa28:	e59cc000 	ldr	ip, [ip]
    aa2c:	e35c0000 	cmp	ip, #0
    aa30:	e58dc05c 	str	ip, [sp, #92]	; 0x5c
    aa34:	da0000e9 	ble	ade0 <INITIA+0xb30>
    aa38:	e59f530c 	ldr	r5, [pc, #780]	; ad4c <INITIA+0xa9c>
    aa3c:	e59f3394 	ldr	r3, [pc, #916]	; add8 <INITIA+0xb28>
    aa40:	e1c540d0 	ldrd	r4, [r5]
    aa44:	e1cd41f8 	strd	r4, [sp, #24]
    aa48:	e59f5380 	ldr	r5, [pc, #896]	; add0 <INITIA+0xb20>
    aa4c:	e5933000 	ldr	r3, [r3]
    aa50:	e1c540d0 	ldrd	r4, [r5]
    aa54:	e1cd42f0 	strd	r4, [sp, #32]

    /*  find normalization factor so that <k.e.>=KT/2  */

    SUX=0.0;
    SUY=0.0;
    SUZ=0.0;
    aa58:	e3a04000 	mov	r4, #0
    aa5c:	e3a05000 	mov	r5, #0
    aa60:	e1cd42f8 	strd	r4, [sp, #40]	; 0x28

    for (i=0; i<BOX_PER_SIDE; i++) {
    aa64:	e3a05000 	mov	r5, #0
    aa68:	e58d5078 	str	r5, [sp, #120]	; 0x78
    SUMZ=SUMZ/(NATOMS*NMOL);

    /*  find normalization factor so that <k.e.>=KT/2  */

    SUX=0.0;
    SUY=0.0;
    aa6c:	e1cd42d8 	ldrd	r4, [sp, #40]	; 0x28
    aa70:	e1cd43f8 	strd	r4, [sp, #56]	; 0x38
    SUMY=SUMY/(NATOMS*NMOL);
    SUMZ=SUMZ/(NATOMS*NMOL);

    /*  find normalization factor so that <k.e.>=KT/2  */

    SUX=0.0;
    aa74:	e1cd43f0 	strd	r4, [sp, #48]	; 0x30
    aa78:	e1a0520c 	lsl	r5, ip, #4
    aa7c:	e58d5048 	str	r5, [sp, #72]	; 0x48
    aa80:	e58d3068 	str	r3, [sp, #104]	; 0x68
    SUY=0.0;
    SUZ=0.0;

    for (i=0; i<BOX_PER_SIDE; i++) {
        for (j=0; j<BOX_PER_SIDE; j++) {
    aa84:	e3a0c000 	mov	ip, #0
    aa88:	e59d4078 	ldr	r4, [sp, #120]	; 0x78
    aa8c:	e59d5068 	ldr	r5, [sp, #104]	; 0x68
    aa90:	e58dc054 	str	ip, [sp, #84]	; 0x54
    aa94:	e7954104 	ldr	r4, [r5, r4, lsl #2]
    aa98:	e58d4060 	str	r4, [sp, #96]	; 0x60
    aa9c:	e3a09000 	mov	r9, #0
    aaa0:	e59dc054 	ldr	ip, [sp, #84]	; 0x54
    aaa4:	e59d4060 	ldr	r4, [sp, #96]	; 0x60
    aaa8:	e794c10c 	ldr	ip, [r4, ip, lsl #2]
    aaac:	e58dc040 	str	ip, [sp, #64]	; 0x40
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
    aab0:	e59d5040 	ldr	r5, [sp, #64]	; 0x40
    aab4:	e7958009 	ldr	r8, [r5, r9]
                while (curr_ptr) {
    aab8:	e3580000 	cmp	r8, #0
    aabc:	0a000092 	beq	ad0c <INITIA+0xa5c>
                    SUX = SUX +
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
    aac0:	e1c806d0 	ldrd	r0, [r8, #96]	; 0x60
    aac4:	e1a0200a 	mov	r2, sl
    aac8:	e1a0300b 	mov	r3, fp
    aacc:	eb002706 	bl	146ec <__aeabi_dsub>
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
    aad0:	e1a0200a 	mov	r2, sl
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
                    SUX = SUX +
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
    aad4:	e1a04000 	mov	r4, r0
    aad8:	e1a05001 	mov	r5, r1
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
    aadc:	e1c807d0 	ldrd	r0, [r8, #112]	; 0x70
    aae0:	e1a0300b 	mov	r3, fp
    aae4:	eb002700 	bl	146ec <__aeabi_dsub>
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
                    SUX = SUX +
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
    aae8:	e1a02004 	mov	r2, r4
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
    aaec:	e1a06000 	mov	r6, r0
    aaf0:	e1a07001 	mov	r7, r1
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
                    SUX = SUX +
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
    aaf4:	e1a03005 	mov	r3, r5
    aaf8:	e1a00004 	mov	r0, r4
    aafc:	e1a01005 	mov	r1, r5
    ab00:	eb0027fe 	bl	14b00 <__aeabi_dmul>
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
    ab04:	e1a02006 	mov	r2, r6
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
                    SUX = SUX +
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
    ab08:	e1a04000 	mov	r4, r0
    ab0c:	e1a05001 	mov	r5, r1
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
    ab10:	e1a03007 	mov	r3, r7
    ab14:	e1a00006 	mov	r0, r6
    ab18:	e1a01007 	mov	r1, r7
    ab1c:	eb0027f7 	bl	14b00 <__aeabi_dmul>
    ab20:	e1a02000 	mov	r2, r0
    ab24:	e1a03001 	mov	r3, r1
    ab28:	e1a00004 	mov	r0, r4
    ab2c:	e1a01005 	mov	r1, r5
    ab30:	eb0026ee 	bl	146f0 <__adddf3>
    ab34:	e1cd21d8 	ldrd	r2, [sp, #24]
    ab38:	eb002894 	bl	14d90 <__aeabi_ddiv>
    for (i=0; i<BOX_PER_SIDE; i++) {
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
                    SUX = SUX +
    ab3c:	e1cd23d0 	ldrd	r2, [sp, #48]	; 0x30
    ab40:	eb0026ea 	bl	146f0 <__adddf3>
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][XDIR][O]  - SUMX),2.0)/OMAS;
    ab44:	e1a0200a 	mov	r2, sl
    for (i=0; i<BOX_PER_SIDE; i++) {
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
                    SUX = SUX +
    ab48:	e1a04000 	mov	r4, r0
    ab4c:	e1a05001 	mov	r5, r1
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][XDIR][O]  - SUMX),2.0)/OMAS;
    ab50:	e1c806d8 	ldrd	r0, [r8, #104]	; 0x68
    ab54:	e1a0300b 	mov	r3, fp
    ab58:	eb0026e3 	bl	146ec <__aeabi_dsub>
    ab5c:	e1a02000 	mov	r2, r0
    ab60:	e1a03001 	mov	r3, r1
    ab64:	eb0027e5 	bl	14b00 <__aeabi_dmul>
    ab68:	e1cd22d0 	ldrd	r2, [sp, #32]
    ab6c:	eb002887 	bl	14d90 <__aeabi_ddiv>
    ab70:	e1a02000 	mov	r2, r0
    ab74:	e1a03001 	mov	r3, r1
    for (i=0; i<BOX_PER_SIDE; i++) {
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
                    SUX = SUX +
    ab78:	e1a00004 	mov	r0, r4
    ab7c:	e1a01005 	mov	r1, r5
    ab80:	eb0026da 	bl	146f0 <__adddf3>
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][XDIR][O]  - SUMX),2.0)/OMAS;

                    SUY = SUY +
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
    ab84:	e1cd21d0 	ldrd	r2, [sp, #16]
    for (i=0; i<BOX_PER_SIDE; i++) {
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
                    SUX = SUX +
    ab88:	e1cd03f0 	strd	r0, [sp, #48]	; 0x30
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][XDIR][O]  - SUMX),2.0)/OMAS;

                    SUY = SUY +
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
    ab8c:	e1c807d8 	ldrd	r0, [r8, #120]	; 0x78
    ab90:	eb0026d5 	bl	146ec <__aeabi_dsub>
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
    ab94:	e1cd21d0 	ldrd	r2, [sp, #16]
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][XDIR][O]  - SUMX),2.0)/OMAS;

                    SUY = SUY +
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
    ab98:	e1a04000 	mov	r4, r0
    ab9c:	e1a05001 	mov	r5, r1
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
    aba0:	e1c808d8 	ldrd	r0, [r8, #136]	; 0x88
    aba4:	eb0026d0 	bl	146ec <__aeabi_dsub>
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][XDIR][O]  - SUMX),2.0)/OMAS;

                    SUY = SUY +
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
    aba8:	e1a02004 	mov	r2, r4
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
    abac:	e1a06000 	mov	r6, r0
    abb0:	e1a07001 	mov	r7, r1
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][XDIR][O]  - SUMX),2.0)/OMAS;

                    SUY = SUY +
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
    abb4:	e1a03005 	mov	r3, r5
    abb8:	e1a00004 	mov	r0, r4
    abbc:	e1a01005 	mov	r1, r5
    abc0:	eb0027ce 	bl	14b00 <__aeabi_dmul>
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
    abc4:	e1a02006 	mov	r2, r6
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][XDIR][O]  - SUMX),2.0)/OMAS;

                    SUY = SUY +
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
    abc8:	e1a04000 	mov	r4, r0
    abcc:	e1a05001 	mov	r5, r1
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
    abd0:	e1a03007 	mov	r3, r7
    abd4:	e1a00006 	mov	r0, r6
    abd8:	e1a01007 	mov	r1, r7
    abdc:	eb0027c7 	bl	14b00 <__aeabi_dmul>
    abe0:	e1a02000 	mov	r2, r0
    abe4:	e1a03001 	mov	r3, r1
    abe8:	e1a00004 	mov	r0, r4
    abec:	e1a01005 	mov	r1, r5
    abf0:	eb0026be 	bl	146f0 <__adddf3>
    abf4:	e1cd21d8 	ldrd	r2, [sp, #24]
    abf8:	eb002864 	bl	14d90 <__aeabi_ddiv>
                    SUX = SUX +
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][XDIR][O]  - SUMX),2.0)/OMAS;

                    SUY = SUY +
    abfc:	e1cd23d8 	ldrd	r2, [sp, #56]	; 0x38
    ac00:	eb0026ba 	bl	146f0 <__adddf3>
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][YDIR][O]  - SUMY),2.0)/OMAS;
    ac04:	e1cd21d0 	ldrd	r2, [sp, #16]
                    SUX = SUX +
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][XDIR][O]  - SUMX),2.0)/OMAS;

                    SUY = SUY +
    ac08:	e1a04000 	mov	r4, r0
    ac0c:	e1a05001 	mov	r5, r1
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][YDIR][O]  - SUMY),2.0)/OMAS;
    ac10:	e1c808d0 	ldrd	r0, [r8, #128]	; 0x80
    ac14:	eb0026b4 	bl	146ec <__aeabi_dsub>
    ac18:	e1a02000 	mov	r2, r0
    ac1c:	e1a03001 	mov	r3, r1
    ac20:	eb0027b6 	bl	14b00 <__aeabi_dmul>
    ac24:	e1cd22d0 	ldrd	r2, [sp, #32]
    ac28:	eb002858 	bl	14d90 <__aeabi_ddiv>
    ac2c:	e1a02000 	mov	r2, r0
    ac30:	e1a03001 	mov	r3, r1
                    SUX = SUX +
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][XDIR][O]  - SUMX),2.0)/OMAS;

                    SUY = SUY +
    ac34:	e1a00004 	mov	r0, r4
    ac38:	e1a01005 	mov	r1, r5
    ac3c:	eb0026ab 	bl	146f0 <__adddf3>
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][YDIR][O]  - SUMY),2.0)/OMAS;

                    SUZ = SUZ +
                        (pow( (curr_ptr->mol.F[VEL][ZDIR][H1] - SUMZ),2.0)
    ac40:	e1cd20d8 	ldrd	r2, [sp, #8]
                    SUX = SUX +
                        (pow( (curr_ptr->mol.F[VEL][XDIR][H1] - SUMX),2.0)
                         +pow( (curr_ptr->mol.F[VEL][XDIR][H2] - SUMX),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][XDIR][O]  - SUMX),2.0)/OMAS;

                    SUY = SUY +
    ac44:	e1cd03f8 	strd	r0, [sp, #56]	; 0x38
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][YDIR][O]  - SUMY),2.0)/OMAS;

                    SUZ = SUZ +
                        (pow( (curr_ptr->mol.F[VEL][ZDIR][H1] - SUMZ),2.0)
    ac48:	e1c809d0 	ldrd	r0, [r8, #144]	; 0x90
    ac4c:	eb0026a6 	bl	146ec <__aeabi_dsub>
                         + pow( (curr_ptr->mol.F[VEL][ZDIR][H2] - SUMZ),2.0))/HMAS
    ac50:	e1cd20d8 	ldrd	r2, [sp, #8]
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][YDIR][O]  - SUMY),2.0)/OMAS;

                    SUZ = SUZ +
                        (pow( (curr_ptr->mol.F[VEL][ZDIR][H1] - SUMZ),2.0)
    ac54:	e1a04000 	mov	r4, r0
    ac58:	e1a05001 	mov	r5, r1
                         + pow( (curr_ptr->mol.F[VEL][ZDIR][H2] - SUMZ),2.0))/HMAS
    ac5c:	e1c80ad0 	ldrd	r0, [r8, #160]	; 0xa0
    ac60:	eb0026a1 	bl	146ec <__aeabi_dsub>
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][YDIR][O]  - SUMY),2.0)/OMAS;

                    SUZ = SUZ +
                        (pow( (curr_ptr->mol.F[VEL][ZDIR][H1] - SUMZ),2.0)
    ac64:	e1a02004 	mov	r2, r4
                         + pow( (curr_ptr->mol.F[VEL][ZDIR][H2] - SUMZ),2.0))/HMAS
    ac68:	e1a06000 	mov	r6, r0
    ac6c:	e1a07001 	mov	r7, r1
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][YDIR][O]  - SUMY),2.0)/OMAS;

                    SUZ = SUZ +
                        (pow( (curr_ptr->mol.F[VEL][ZDIR][H1] - SUMZ),2.0)
    ac70:	e1a03005 	mov	r3, r5
    ac74:	e1a00004 	mov	r0, r4
    ac78:	e1a01005 	mov	r1, r5
    ac7c:	eb00279f 	bl	14b00 <__aeabi_dmul>
                         + pow( (curr_ptr->mol.F[VEL][ZDIR][H2] - SUMZ),2.0))/HMAS
    ac80:	e1a02006 	mov	r2, r6
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][YDIR][O]  - SUMY),2.0)/OMAS;

                    SUZ = SUZ +
                        (pow( (curr_ptr->mol.F[VEL][ZDIR][H1] - SUMZ),2.0)
    ac84:	e1a04000 	mov	r4, r0
    ac88:	e1a05001 	mov	r5, r1
                         + pow( (curr_ptr->mol.F[VEL][ZDIR][H2] - SUMZ),2.0))/HMAS
    ac8c:	e1a03007 	mov	r3, r7
    ac90:	e1a00006 	mov	r0, r6
    ac94:	e1a01007 	mov	r1, r7
    ac98:	eb002798 	bl	14b00 <__aeabi_dmul>
    ac9c:	e1a02000 	mov	r2, r0
    aca0:	e1a03001 	mov	r3, r1
    aca4:	e1a00004 	mov	r0, r4
    aca8:	e1a01005 	mov	r1, r5
    acac:	eb00268f 	bl	146f0 <__adddf3>
    acb0:	e1cd21d8 	ldrd	r2, [sp, #24]
    acb4:	eb002835 	bl	14d90 <__aeabi_ddiv>
                    SUY = SUY +
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][YDIR][O]  - SUMY),2.0)/OMAS;

                    SUZ = SUZ +
    acb8:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
    acbc:	eb00268b 	bl	146f0 <__adddf3>
                        (pow( (curr_ptr->mol.F[VEL][ZDIR][H1] - SUMZ),2.0)
                         + pow( (curr_ptr->mol.F[VEL][ZDIR][H2] - SUMZ),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][ZDIR][O]  - SUMZ),2.0)/OMAS;
    acc0:	e1cd20d8 	ldrd	r2, [sp, #8]
                    SUY = SUY +
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][YDIR][O]  - SUMY),2.0)/OMAS;

                    SUZ = SUZ +
    acc4:	e1a04000 	mov	r4, r0
    acc8:	e1a05001 	mov	r5, r1
                        (pow( (curr_ptr->mol.F[VEL][ZDIR][H1] - SUMZ),2.0)
                         + pow( (curr_ptr->mol.F[VEL][ZDIR][H2] - SUMZ),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][ZDIR][O]  - SUMZ),2.0)/OMAS;
    accc:	e1c809d8 	ldrd	r0, [r8, #152]	; 0x98
    acd0:	eb002685 	bl	146ec <__aeabi_dsub>
    acd4:	e1a02000 	mov	r2, r0
    acd8:	e1a03001 	mov	r3, r1
    acdc:	eb002787 	bl	14b00 <__aeabi_dmul>
    ace0:	e1cd22d0 	ldrd	r2, [sp, #32]
    ace4:	eb002829 	bl	14d90 <__aeabi_ddiv>
    ace8:	e1a02000 	mov	r2, r0
    acec:	e1a03001 	mov	r3, r1
                    SUY = SUY +
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][YDIR][O]  - SUMY),2.0)/OMAS;

                    SUZ = SUZ +
    acf0:	e1a00004 	mov	r0, r4
    acf4:	e1a01005 	mov	r1, r5
    acf8:	eb00267c 	bl	146f0 <__adddf3>
                        (pow( (curr_ptr->mol.F[VEL][ZDIR][H1] - SUMZ),2.0)
                         + pow( (curr_ptr->mol.F[VEL][ZDIR][H2] - SUMZ),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][ZDIR][O]  - SUMZ),2.0)/OMAS;

                    curr_ptr = curr_ptr->next_mol;
    acfc:	e59882a0 	ldr	r8, [r8, #672]	; 0x2a0
                    SUY = SUY +
                        (pow( (curr_ptr->mol.F[VEL][YDIR][H1] - SUMY),2.0)
                         +pow( (curr_ptr->mol.F[VEL][YDIR][H2] - SUMY),2.0))/HMAS
                             +pow( (curr_ptr->mol.F[VEL][YDIR][O]  - SUMY),2.0)/OMAS;

                    SUZ = SUZ +
    ad00:	e1cd02f8 	strd	r0, [sp, #40]	; 0x28

    for (i=0; i<BOX_PER_SIDE; i++) {
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
    ad04:	e3580000 	cmp	r8, #0
    ad08:	1affff6c 	bne	aac0 <INITIA+0x810>
    SUY=0.0;
    SUZ=0.0;

    for (i=0; i<BOX_PER_SIDE; i++) {
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
    ad0c:	e59dc048 	ldr	ip, [sp, #72]	; 0x48
    ad10:	e2899010 	add	r9, r9, #16
    ad14:	e159000c 	cmp	r9, ip
    ad18:	1affff64 	bne	aab0 <INITIA+0x800>
    SUX=0.0;
    SUY=0.0;
    SUZ=0.0;

    for (i=0; i<BOX_PER_SIDE; i++) {
        for (j=0; j<BOX_PER_SIDE; j++) {
    ad1c:	e59d4054 	ldr	r4, [sp, #84]	; 0x54
    ad20:	e59d505c 	ldr	r5, [sp, #92]	; 0x5c
    ad24:	e2844001 	add	r4, r4, #1
    ad28:	e1540005 	cmp	r4, r5
    ad2c:	e58d4054 	str	r4, [sp, #84]	; 0x54
    ad30:	1affff59 	bne	aa9c <INITIA+0x7ec>

    SUX=0.0;
    SUY=0.0;
    SUZ=0.0;

    for (i=0; i<BOX_PER_SIDE; i++) {
    ad34:	e59dc078 	ldr	ip, [sp, #120]	; 0x78
    ad38:	e28cc001 	add	ip, ip, #1
    ad3c:	e15c0005 	cmp	ip, r5
    ad40:	e58dc078 	str	ip, [sp, #120]	; 0x78
    ad44:	1affff4e 	bne	aa84 <INITIA+0x7d4>
    ad48:	ea000029 	b	adf4 <INITIA+0xb44>
    ad4c:	0013f418 	.word	0x0013f418
    ad50:	0013f004 	.word	0x0013f004
    ad54:	0013ea58 	.word	0x0013ea58
    ad58:	55555555 	.word	0x55555555
    ad5c:	3fd55555 	.word	0x3fd55555
    ad60:	86a12b9b 	.word	0x86a12b9b
    ad64:	3d06849b 	.word	0x3d06849b
    ad68:	3fe00000 	.word	0x3fe00000
    ad6c:	0013f3f8 	.word	0x0013f3f8
    ad70:	0013eee8 	.word	0x0013eee8
    ad74:	0013ef58 	.word	0x0013ef58
    ad78:	00032ea0 	.word	0x00032ea0
    ad7c:	00032eb0 	.word	0x00032eb0
    ad80:	0013f530 	.word	0x0013f530
    ad84:	00032ec0 	.word	0x00032ec0
    ad88:	00032ed0 	.word	0x00032ed0
    ad8c:	0013f3f4 	.word	0x0013f3f4
    ad90:	00032ee4 	.word	0x00032ee4
    ad94:	00032ef8 	.word	0x00032ef8
    ad98:	00032f04 	.word	0x00032f04
    ad9c:	00032f10 	.word	0x00032f10
    ada0:	00032f1c 	.word	0x00032f1c
    ada4:	0003e460 	.word	0x0003e460
    ada8:	00032f28 	.word	0x00032f28
    adac:	0013ea74 	.word	0x0013ea74
    adb0:	00033a30 	.word	0x00033a30
    adb4:	0013f508 	.word	0x0013f508
    adb8:	0013eed8 	.word	0x0013eed8
    adbc:	0013f460 	.word	0x0013f460
    adc0:	0013efc0 	.word	0x0013efc0
    adc4:	0013ef90 	.word	0x0013ef90
    adc8:	0013ef54 	.word	0x0013ef54
    adcc:	0013f3d0 	.word	0x0013f3d0
    add0:	0013ef78 	.word	0x0013ef78
    add4:	0013ea50 	.word	0x0013ea50
    add8:	0013f098 	.word	0x0013f098
    addc:	00032f5c 	.word	0x00032f5c

    /*  find normalization factor so that <k.e.>=KT/2  */

    SUX=0.0;
    SUY=0.0;
    SUZ=0.0;
    ade0:	e3a04000 	mov	r4, #0
    ade4:	e3a05000 	mov	r5, #0
    ade8:	e1cd42f8 	strd	r4, [sp, #40]	; 0x28
    SUMZ=SUMZ/(NATOMS*NMOL);

    /*  find normalization factor so that <k.e.>=KT/2  */

    SUX=0.0;
    SUY=0.0;
    adec:	e1cd43f8 	strd	r4, [sp, #56]	; 0x38
    SUMY=SUMY/(NATOMS*NMOL);
    SUMZ=SUMZ/(NATOMS*NMOL);

    /*  find normalization factor so that <k.e.>=KT/2  */

    SUX=0.0;
    adf0:	e1cd43f0 	strd	r4, [sp, #48]	; 0x30
                } /* while curr_ptr */
            }
        }
    } /* for boxes */

    FAC=BOLTZ*TEMP*NATMO/UNITM * pow((UNITT*TSTEP/UNITL),2.0);
    adf4:	e51f2048 	ldr	r2, [pc, #-72]	; adb4 <INITIA+0xb04>
    adf8:	e51f3048 	ldr	r3, [pc, #-72]	; adb8 <INITIA+0xb08>
    adfc:	e1c200d0 	ldrd	r0, [r2]
    ae00:	e1c320d0 	ldrd	r2, [r3]
    ae04:	eb00273d 	bl	14b00 <__aeabi_dmul>
    ae08:	e51f3054 	ldr	r3, [pc, #-84]	; adbc <INITIA+0xb0c>
    ae0c:	e1c320d0 	ldrd	r2, [r3]
    ae10:	eb0027de 	bl	14d90 <__aeabi_ddiv>
    ae14:	e1a02000 	mov	r2, r0
    ae18:	e1a03001 	mov	r3, r1
    ae1c:	eb002737 	bl	14b00 <__aeabi_dmul>
    ae20:	e51f2068 	ldr	r2, [pc, #-104]	; adc0 <INITIA+0xb10>
    ae24:	e51f3068 	ldr	r3, [pc, #-104]	; adc4 <INITIA+0xb14>
    ae28:	e1a06000 	mov	r6, r0
    ae2c:	e1a07001 	mov	r7, r1
    ae30:	e1c200d0 	ldrd	r0, [r2]
    ae34:	e1c320d0 	ldrd	r2, [r3]
    ae38:	eb002730 	bl	14b00 <__aeabi_dmul>
    ae3c:	e51f307c 	ldr	r3, [pc, #-124]	; adc8 <INITIA+0xb18>
    ae40:	e1a04000 	mov	r4, r0
    ae44:	e5930000 	ldr	r0, [r3]
    ae48:	e1a05001 	mov	r5, r1
    ae4c:	eb0026f4 	bl	14a24 <__aeabi_i2d>
    ae50:	e1a02000 	mov	r2, r0
    ae54:	e1a03001 	mov	r3, r1
    ae58:	e1a00004 	mov	r0, r4
    ae5c:	e1a01005 	mov	r1, r5
    ae60:	eb002726 	bl	14b00 <__aeabi_dmul>
    ae64:	e51f30a0 	ldr	r3, [pc, #-160]	; adcc <INITIA+0xb1c>
    ae68:	e1c320d0 	ldrd	r2, [r3]
    ae6c:	eb0027c7 	bl	14d90 <__aeabi_ddiv>
    ae70:	e1a02000 	mov	r2, r0
    ae74:	e1a03001 	mov	r3, r1
    ae78:	e1a00006 	mov	r0, r6
    ae7c:	e1a01007 	mov	r1, r7
    ae80:	eb00271e 	bl	14b00 <__aeabi_dmul>
    SUX=sqrt(FAC/SUX);
    ae84:	e1cd23d0 	ldrd	r2, [sp, #48]	; 0x30
                } /* while curr_ptr */
            }
        }
    } /* for boxes */

    FAC=BOLTZ*TEMP*NATMO/UNITM * pow((UNITT*TSTEP/UNITL),2.0);
    ae88:	e1a04000 	mov	r4, r0
    ae8c:	e1a05001 	mov	r5, r1
    SUX=sqrt(FAC/SUX);
    ae90:	eb0027be 	bl	14d90 <__aeabi_ddiv>
    ae94:	eb007e05 	bl	2a6b0 <sqrt>
    SUY=sqrt(FAC/SUY);
    ae98:	e1cd23d8 	ldrd	r2, [sp, #56]	; 0x38
            }
        }
    } /* for boxes */

    FAC=BOLTZ*TEMP*NATMO/UNITM * pow((UNITT*TSTEP/UNITL),2.0);
    SUX=sqrt(FAC/SUX);
    ae9c:	e1a08000 	mov	r8, r0
    aea0:	e1a09001 	mov	r9, r1
    SUY=sqrt(FAC/SUY);
    aea4:	e1a00004 	mov	r0, r4
    aea8:	e1a01005 	mov	r1, r5
    aeac:	eb0027b7 	bl	14d90 <__aeabi_ddiv>
    aeb0:	eb007dfe 	bl	2a6b0 <sqrt>
    SUZ=sqrt(FAC/SUZ);
    aeb4:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
        }
    } /* for boxes */

    FAC=BOLTZ*TEMP*NATMO/UNITM * pow((UNITT*TSTEP/UNITL),2.0);
    SUX=sqrt(FAC/SUX);
    SUY=sqrt(FAC/SUY);
    aeb8:	e1cd01f8 	strd	r0, [sp, #24]
    SUZ=sqrt(FAC/SUZ);
    aebc:	e1a00004 	mov	r0, r4
    aec0:	e1a01005 	mov	r1, r5
    aec4:	eb0027b1 	bl	14d90 <__aeabi_ddiv>
    aec8:	eb007df8 	bl	2a6b0 <sqrt>

    /* normalize individual velocities so that there are no bulk momenta  */

    XMAS[1]=OMAS;
    aecc:	e51fc104 	ldr	ip, [pc, #-260]	; add0 <INITIA+0xb20>
    } /* for boxes */

    FAC=BOLTZ*TEMP*NATMO/UNITM * pow((UNITT*TSTEP/UNITL),2.0);
    SUX=sqrt(FAC/SUX);
    SUY=sqrt(FAC/SUY);
    SUZ=sqrt(FAC/SUZ);
    aed0:	e1cd02f0 	strd	r0, [sp, #32]

    /* normalize individual velocities so that there are no bulk momenta  */

    XMAS[1]=OMAS;
    aed4:	e1cc40d0 	ldrd	r4, [ip]
    for (i=0; i<BOX_PER_SIDE; i++) {
    aed8:	e51fc10c 	ldr	ip, [pc, #-268]	; add4 <INITIA+0xb24>
    aedc:	e59cc000 	ldr	ip, [ip]
    aee0:	e35c0000 	cmp	ip, #0
    aee4:	e58dc054 	str	ip, [sp, #84]	; 0x54
    aee8:	da00008f 	ble	b12c <INITIA+0xe7c>
    aeec:	e3a0c000 	mov	ip, #0
    aef0:	e58dc05c 	str	ip, [sp, #92]	; 0x5c
    aef4:	e59dc058 	ldr	ip, [sp, #88]	; 0x58
    aef8:	e51f3128 	ldr	r3, [pc, #-296]	; add8 <INITIA+0xb28>
    aefc:	e59c7000 	ldr	r7, [ip]
    af00:	e59dc054 	ldr	ip, [sp, #84]	; 0x54
    af04:	e5933000 	ldr	r3, [r3]
    af08:	e1a0c10c 	lsl	ip, ip, #2
    af0c:	e58dc058 	str	ip, [sp, #88]	; 0x58
    af10:	e59dc054 	ldr	ip, [sp, #84]	; 0x54
    af14:	e58d3060 	str	r3, [sp, #96]	; 0x60
    af18:	e1a0c20c 	lsl	ip, ip, #4
    af1c:	e58dc040 	str	ip, [sp, #64]	; 0x40
    af20:	e1cd82f8 	strd	r8, [sp, #40]	; 0x28
    af24:	e1a09007 	mov	r9, r7
    af28:	e1cd67d0 	ldrd	r6, [sp, #112]	; 0x70
    af2c:	e3a0c000 	mov	ip, #0
    af30:	e59d0060 	ldr	r0, [sp, #96]	; 0x60
    af34:	e58dc048 	str	ip, [sp, #72]	; 0x48
    af38:	e59dc05c 	ldr	ip, [sp, #92]	; 0x5c
    af3c:	e790c10c 	ldr	ip, [r0, ip, lsl #2]
    af40:	e58dc078 	str	ip, [sp, #120]	; 0x78
    af44:	e3a0c000 	mov	ip, #0
    af48:	e59d0078 	ldr	r0, [sp, #120]	; 0x78
    af4c:	e58dc030 	str	ip, [sp, #48]	; 0x30
    af50:	e59dc048 	ldr	ip, [sp, #72]	; 0x48
    af54:	e790c00c 	ldr	ip, [r0, ip]
    af58:	e58dc038 	str	ip, [sp, #56]	; 0x38
    af5c:	e59dc030 	ldr	ip, [sp, #48]	; 0x30
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
    af60:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
    af64:	e790800c 	ldr	r8, [r0, ip]
                while (curr_ptr) {
    af68:	e3580000 	cmp	r8, #0
    af6c:	0a00005c 	beq	b0e4 <INITIA+0xe34>
                    for (atom = 0; atom < NATOMS; atom++) {
    af70:	e3590000 	cmp	r9, #0
    af74:	da000057 	ble	b0d8 <INITIA+0xe28>
                        curr_ptr->mol.F[VEL][XDIR][atom] =
                            ( curr_ptr->mol.F[VEL][XDIR][atom] -
    af78:	e1c806d0 	ldrd	r0, [r8, #96]	; 0x60
    af7c:	e1a0200a 	mov	r2, sl
    af80:	e1a0300b 	mov	r3, fp
    af84:	eb0025d8 	bl	146ec <__aeabi_dsub>
                             SUMX) * SUX/XMAS[atom];
    af88:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
    af8c:	eb0026db 	bl	14b00 <__aeabi_dmul>
    af90:	e1a02006 	mov	r2, r6
    af94:	e1a03007 	mov	r3, r7
    af98:	eb00277c 	bl	14d90 <__aeabi_ddiv>
                        curr_ptr->mol.F[VEL][YDIR][atom] =
                            ( curr_ptr->mol.F[VEL][YDIR][atom] -
    af9c:	e1cd21d0 	ldrd	r2, [sp, #16]
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
                    for (atom = 0; atom < NATOMS; atom++) {
                        curr_ptr->mol.F[VEL][XDIR][atom] =
    afa0:	e1c806f0 	strd	r0, [r8, #96]	; 0x60
                            ( curr_ptr->mol.F[VEL][XDIR][atom] -
                             SUMX) * SUX/XMAS[atom];
                        curr_ptr->mol.F[VEL][YDIR][atom] =
                            ( curr_ptr->mol.F[VEL][YDIR][atom] -
    afa4:	e1c807d8 	ldrd	r0, [r8, #120]	; 0x78
    afa8:	eb0025cf 	bl	146ec <__aeabi_dsub>
                             SUMY) * SUY/XMAS[atom];
    afac:	e1cd21d8 	ldrd	r2, [sp, #24]
    afb0:	eb0026d2 	bl	14b00 <__aeabi_dmul>
    afb4:	e1a02006 	mov	r2, r6
    afb8:	e1a03007 	mov	r3, r7
    afbc:	eb002773 	bl	14d90 <__aeabi_ddiv>
                        curr_ptr->mol.F[VEL][ZDIR][atom] =
                            ( curr_ptr->mol.F[VEL][ZDIR][atom] -
    afc0:	e1cd20d8 	ldrd	r2, [sp, #8]
                while (curr_ptr) {
                    for (atom = 0; atom < NATOMS; atom++) {
                        curr_ptr->mol.F[VEL][XDIR][atom] =
                            ( curr_ptr->mol.F[VEL][XDIR][atom] -
                             SUMX) * SUX/XMAS[atom];
                        curr_ptr->mol.F[VEL][YDIR][atom] =
    afc4:	e1c807f8 	strd	r0, [r8, #120]	; 0x78
                            ( curr_ptr->mol.F[VEL][YDIR][atom] -
                             SUMY) * SUY/XMAS[atom];
                        curr_ptr->mol.F[VEL][ZDIR][atom] =
                            ( curr_ptr->mol.F[VEL][ZDIR][atom] -
    afc8:	e1c809d0 	ldrd	r0, [r8, #144]	; 0x90
    afcc:	eb0025c6 	bl	146ec <__aeabi_dsub>
                             SUMZ) * SUZ/XMAS[atom];
    afd0:	e1cd22d0 	ldrd	r2, [sp, #32]
    afd4:	eb0026c9 	bl	14b00 <__aeabi_dmul>
    afd8:	e1a02006 	mov	r2, r6
    afdc:	e1a03007 	mov	r3, r7
    afe0:	eb00276a 	bl	14d90 <__aeabi_ddiv>
    for (i=0; i<BOX_PER_SIDE; i++) {
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
                    for (atom = 0; atom < NATOMS; atom++) {
    afe4:	e3590001 	cmp	r9, #1
                            ( curr_ptr->mol.F[VEL][XDIR][atom] -
                             SUMX) * SUX/XMAS[atom];
                        curr_ptr->mol.F[VEL][YDIR][atom] =
                            ( curr_ptr->mol.F[VEL][YDIR][atom] -
                             SUMY) * SUY/XMAS[atom];
                        curr_ptr->mol.F[VEL][ZDIR][atom] =
    afe8:	e1c809f0 	strd	r0, [r8, #144]	; 0x90
    for (i=0; i<BOX_PER_SIDE; i++) {
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
                    for (atom = 0; atom < NATOMS; atom++) {
    afec:	0a000039 	beq	b0d8 <INITIA+0xe28>
                        curr_ptr->mol.F[VEL][XDIR][atom] =
                            ( curr_ptr->mol.F[VEL][XDIR][atom] -
    aff0:	e1c806d8 	ldrd	r0, [r8, #104]	; 0x68
    aff4:	e1a0200a 	mov	r2, sl
    aff8:	e1a0300b 	mov	r3, fp
    affc:	eb0025ba 	bl	146ec <__aeabi_dsub>
                             SUMX) * SUX/XMAS[atom];
    b000:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
    b004:	eb0026bd 	bl	14b00 <__aeabi_dmul>
    b008:	e1a02004 	mov	r2, r4
    b00c:	e1a03005 	mov	r3, r5
    b010:	eb00275e 	bl	14d90 <__aeabi_ddiv>
                        curr_ptr->mol.F[VEL][YDIR][atom] =
                            ( curr_ptr->mol.F[VEL][YDIR][atom] -
    b014:	e1cd21d0 	ldrd	r2, [sp, #16]
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
                    for (atom = 0; atom < NATOMS; atom++) {
                        curr_ptr->mol.F[VEL][XDIR][atom] =
    b018:	e1c806f8 	strd	r0, [r8, #104]	; 0x68
                            ( curr_ptr->mol.F[VEL][XDIR][atom] -
                             SUMX) * SUX/XMAS[atom];
                        curr_ptr->mol.F[VEL][YDIR][atom] =
                            ( curr_ptr->mol.F[VEL][YDIR][atom] -
    b01c:	e1c808d0 	ldrd	r0, [r8, #128]	; 0x80
    b020:	eb0025b1 	bl	146ec <__aeabi_dsub>
                             SUMY) * SUY/XMAS[atom];
    b024:	e1cd21d8 	ldrd	r2, [sp, #24]
    b028:	eb0026b4 	bl	14b00 <__aeabi_dmul>
    b02c:	e1a02004 	mov	r2, r4
    b030:	e1a03005 	mov	r3, r5
    b034:	eb002755 	bl	14d90 <__aeabi_ddiv>
                        curr_ptr->mol.F[VEL][ZDIR][atom] =
                            ( curr_ptr->mol.F[VEL][ZDIR][atom] -
    b038:	e1cd20d8 	ldrd	r2, [sp, #8]
                while (curr_ptr) {
                    for (atom = 0; atom < NATOMS; atom++) {
                        curr_ptr->mol.F[VEL][XDIR][atom] =
                            ( curr_ptr->mol.F[VEL][XDIR][atom] -
                             SUMX) * SUX/XMAS[atom];
                        curr_ptr->mol.F[VEL][YDIR][atom] =
    b03c:	e1c808f0 	strd	r0, [r8, #128]	; 0x80
                            ( curr_ptr->mol.F[VEL][YDIR][atom] -
                             SUMY) * SUY/XMAS[atom];
                        curr_ptr->mol.F[VEL][ZDIR][atom] =
                            ( curr_ptr->mol.F[VEL][ZDIR][atom] -
    b040:	e1c809d8 	ldrd	r0, [r8, #152]	; 0x98
    b044:	eb0025a8 	bl	146ec <__aeabi_dsub>
                             SUMZ) * SUZ/XMAS[atom];
    b048:	e1cd22d0 	ldrd	r2, [sp, #32]
    b04c:	eb0026ab 	bl	14b00 <__aeabi_dmul>
    b050:	e1a02004 	mov	r2, r4
    b054:	e1a03005 	mov	r3, r5
    b058:	eb00274c 	bl	14d90 <__aeabi_ddiv>
    for (i=0; i<BOX_PER_SIDE; i++) {
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
                    for (atom = 0; atom < NATOMS; atom++) {
    b05c:	e3590002 	cmp	r9, #2
                            ( curr_ptr->mol.F[VEL][XDIR][atom] -
                             SUMX) * SUX/XMAS[atom];
                        curr_ptr->mol.F[VEL][YDIR][atom] =
                            ( curr_ptr->mol.F[VEL][YDIR][atom] -
                             SUMY) * SUY/XMAS[atom];
                        curr_ptr->mol.F[VEL][ZDIR][atom] =
    b060:	e1c809f8 	strd	r0, [r8, #152]	; 0x98
    for (i=0; i<BOX_PER_SIDE; i++) {
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
                    for (atom = 0; atom < NATOMS; atom++) {
    b064:	0a00001b 	beq	b0d8 <INITIA+0xe28>
                        curr_ptr->mol.F[VEL][XDIR][atom] =
                            ( curr_ptr->mol.F[VEL][XDIR][atom] -
    b068:	e1c807d0 	ldrd	r0, [r8, #112]	; 0x70
    b06c:	e1a0200a 	mov	r2, sl
    b070:	e1a0300b 	mov	r3, fp
    b074:	eb00259c 	bl	146ec <__aeabi_dsub>
                             SUMX) * SUX/XMAS[atom];
    b078:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
    b07c:	eb00269f 	bl	14b00 <__aeabi_dmul>
    b080:	e1a02006 	mov	r2, r6
    b084:	e1a03007 	mov	r3, r7
    b088:	eb002740 	bl	14d90 <__aeabi_ddiv>
                        curr_ptr->mol.F[VEL][YDIR][atom] =
                            ( curr_ptr->mol.F[VEL][YDIR][atom] -
    b08c:	e1cd21d0 	ldrd	r2, [sp, #16]
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
                    for (atom = 0; atom < NATOMS; atom++) {
                        curr_ptr->mol.F[VEL][XDIR][atom] =
    b090:	e1c807f0 	strd	r0, [r8, #112]	; 0x70
                            ( curr_ptr->mol.F[VEL][XDIR][atom] -
                             SUMX) * SUX/XMAS[atom];
                        curr_ptr->mol.F[VEL][YDIR][atom] =
                            ( curr_ptr->mol.F[VEL][YDIR][atom] -
    b094:	e1c808d8 	ldrd	r0, [r8, #136]	; 0x88
    b098:	eb002593 	bl	146ec <__aeabi_dsub>
                             SUMY) * SUY/XMAS[atom];
    b09c:	e1cd21d8 	ldrd	r2, [sp, #24]
    b0a0:	eb002696 	bl	14b00 <__aeabi_dmul>
    b0a4:	e1a02006 	mov	r2, r6
    b0a8:	e1a03007 	mov	r3, r7
    b0ac:	eb002737 	bl	14d90 <__aeabi_ddiv>
                        curr_ptr->mol.F[VEL][ZDIR][atom] =
                            ( curr_ptr->mol.F[VEL][ZDIR][atom] -
    b0b0:	e1cd20d8 	ldrd	r2, [sp, #8]
                while (curr_ptr) {
                    for (atom = 0; atom < NATOMS; atom++) {
                        curr_ptr->mol.F[VEL][XDIR][atom] =
                            ( curr_ptr->mol.F[VEL][XDIR][atom] -
                             SUMX) * SUX/XMAS[atom];
                        curr_ptr->mol.F[VEL][YDIR][atom] =
    b0b4:	e1c808f8 	strd	r0, [r8, #136]	; 0x88
                            ( curr_ptr->mol.F[VEL][YDIR][atom] -
                             SUMY) * SUY/XMAS[atom];
                        curr_ptr->mol.F[VEL][ZDIR][atom] =
                            ( curr_ptr->mol.F[VEL][ZDIR][atom] -
    b0b8:	e1c80ad0 	ldrd	r0, [r8, #160]	; 0xa0
    b0bc:	eb00258a 	bl	146ec <__aeabi_dsub>
                             SUMZ) * SUZ/XMAS[atom];
    b0c0:	e1cd22d0 	ldrd	r2, [sp, #32]
    b0c4:	eb00268d 	bl	14b00 <__aeabi_dmul>
    b0c8:	e1a02006 	mov	r2, r6
    b0cc:	e1a03007 	mov	r3, r7
    b0d0:	eb00272e 	bl	14d90 <__aeabi_ddiv>
                            ( curr_ptr->mol.F[VEL][XDIR][atom] -
                             SUMX) * SUX/XMAS[atom];
                        curr_ptr->mol.F[VEL][YDIR][atom] =
                            ( curr_ptr->mol.F[VEL][YDIR][atom] -
                             SUMY) * SUY/XMAS[atom];
                        curr_ptr->mol.F[VEL][ZDIR][atom] =
    b0d4:	e1c80af0 	strd	r0, [r8, #160]	; 0xa0
                            ( curr_ptr->mol.F[VEL][ZDIR][atom] -
                             SUMZ) * SUZ/XMAS[atom];
                    } /* for atom */
                    curr_ptr = curr_ptr->next_mol;
    b0d8:	e59882a0 	ldr	r8, [r8, #672]	; 0x2a0
    XMAS[1]=OMAS;
    for (i=0; i<BOX_PER_SIDE; i++) {
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
                curr_ptr = BOX[i][j][k].list;
                while (curr_ptr) {
    b0dc:	e3580000 	cmp	r8, #0
    b0e0:	1affffa2 	bne	af70 <INITIA+0xcc0>
    b0e4:	e59dc030 	ldr	ip, [sp, #48]	; 0x30
    /* normalize individual velocities so that there are no bulk momenta  */

    XMAS[1]=OMAS;
    for (i=0; i<BOX_PER_SIDE; i++) {
        for (j=0; j<BOX_PER_SIDE; j++) {
            for (k=0; k<BOX_PER_SIDE; k++) {
    b0e8:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
    b0ec:	e28cc010 	add	ip, ip, #16
    b0f0:	e15c0000 	cmp	ip, r0
    b0f4:	e58dc030 	str	ip, [sp, #48]	; 0x30
    b0f8:	1affff98 	bne	af60 <INITIA+0xcb0>
    b0fc:	e59dc048 	ldr	ip, [sp, #72]	; 0x48

    /* normalize individual velocities so that there are no bulk momenta  */

    XMAS[1]=OMAS;
    for (i=0; i<BOX_PER_SIDE; i++) {
        for (j=0; j<BOX_PER_SIDE; j++) {
    b100:	e59d0058 	ldr	r0, [sp, #88]	; 0x58
    b104:	e28cc004 	add	ip, ip, #4
    b108:	e15c0000 	cmp	ip, r0
    b10c:	e58dc048 	str	ip, [sp, #72]	; 0x48
    b110:	1affff8b 	bne	af44 <INITIA+0xc94>
    SUZ=sqrt(FAC/SUZ);

    /* normalize individual velocities so that there are no bulk momenta  */

    XMAS[1]=OMAS;
    for (i=0; i<BOX_PER_SIDE; i++) {
    b114:	e59dc05c 	ldr	ip, [sp, #92]	; 0x5c
    b118:	e59d0054 	ldr	r0, [sp, #84]	; 0x54
    b11c:	e28cc001 	add	ip, ip, #1
    b120:	e15c0000 	cmp	ip, r0
    b124:	e58dc05c 	str	ip, [sp, #92]	; 0x5c
    b128:	1affff7f 	bne	af2c <INITIA+0xc7c>
//	if (retval < 0) printf ("Error closing the video file.\r\n");
    //fclose(random_numbers); avoid a call to an unimplemented function : vfs_lseek
#else
    fclose(random_numbers);
#endif
} /* end of subroutine INITIA */
    b12c:	e28dd0b4 	add	sp, sp, #180	; 0xb4
    b130:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
            } /* for j */
            XT[2] += XS;
        } /* for i */

        if (NMOL != mol) {
            printf("Lattice init error: total mol %ld != NMOL %ld\n", mol, NMOL);
    b134:	e1a0100c 	mov	r1, ip
    b138:	e51f0364 	ldr	r0, [pc, #-868]	; addc <INITIA+0xb2c>
    b13c:	eb003644 	bl	18a54 <printf>
            exit(-1);
    b140:	e3e00000 	mvn	r0, #0
    b144:	eb002ab5 	bl	15c20 <exit>

0000b148 <xrand>:
/*
 * XRAND: generate floating-point random number.
 */

double xrand(double xl, double xh)	/* lower, upper bounds on number */
{
    b148:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
    b14c:	e1a04000 	mov	r4, r0
    b150:	e1a05001 	mov	r5, r1
    double x;

    x=(xl + (xh - xl) * ((double) rand()) / 2147483647.0);
    b154:	e1a00002 	mov	r0, r2
    b158:	e1a01003 	mov	r1, r3
    b15c:	e1a02004 	mov	r2, r4
    b160:	e1a03005 	mov	r3, r5
    b164:	eb002560 	bl	146ec <__aeabi_dsub>
    b168:	e1a07001 	mov	r7, r1
    b16c:	e1a06000 	mov	r6, r0
    b170:	eb0036ce 	bl	18cb0 <rand>
    b174:	eb00262a 	bl	14a24 <__aeabi_i2d>
    b178:	e1a02000 	mov	r2, r0
    b17c:	e1a03001 	mov	r3, r1
    b180:	e1a00006 	mov	r0, r6
    b184:	e1a01007 	mov	r1, r7
    b188:	eb00265c 	bl	14b00 <__aeabi_dmul>
    b18c:	e59f2014 	ldr	r2, [pc, #20]	; b1a8 <xrand+0x60>
    b190:	e59f3014 	ldr	r3, [pc, #20]	; b1ac <xrand+0x64>
    b194:	eb0026fd 	bl	14d90 <__aeabi_ddiv>
    b198:	e1a02004 	mov	r2, r4
    b19c:	e1a03005 	mov	r3, r5
    b1a0:	eb002552 	bl	146f0 <__adddf3>
    return (x);
}
    b1a4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
    b1a8:	ffc00000 	.word	0xffc00000
    b1ac:	41dfffff 	.word	0x41dfffff

0000b1b0 <POTENG>:
#include "mddata.h"
#include "split.h"
#include "global.h"

void POTENG(double *POTA, double *POTR, double *PTRF, long ProcID)
{
    b1b0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b1b4:	e24ddfd1 	sub	sp, sp, #836	; 0x344
    b1b8:	e58d00d0 	str	r0, [sp, #208]	; 0xd0
    double tempa, tempb, tempc;

    /*  compute intra-molecular potential energy */

    LPOTA=0.0;
    curr_box = my_boxes[ProcID];
    b1bc:	e59f0d0c 	ldr	r0, [pc, #3340]	; bed0 <POTENG+0xd20>
#include "mddata.h"
#include "split.h"
#include "global.h"

void POTENG(double *POTA, double *POTR, double *PTRF, long ProcID)
{
    b1c0:	e58d3078 	str	r3, [sp, #120]	; 0x78
    double tempa, tempb, tempc;

    /*  compute intra-molecular potential energy */

    LPOTA=0.0;
    curr_box = my_boxes[ProcID];
    b1c4:	e59d4078 	ldr	r4, [sp, #120]	; 0x78
    b1c8:	e5903000 	ldr	r3, [r0]
    double *tx_p, *ty_p, *tz_p;
    double tempa, tempb, tempc;

    /*  compute intra-molecular potential energy */

    LPOTA=0.0;
    b1cc:	e3a05000 	mov	r5, #0
    curr_box = my_boxes[ProcID];
    b1d0:	e7933104 	ldr	r3, [r3, r4, lsl #2]
    double *tx_p, *ty_p, *tz_p;
    double tempa, tempb, tempc;

    /*  compute intra-molecular potential energy */

    LPOTA=0.0;
    b1d4:	e3a04000 	mov	r4, #0
    curr_box = my_boxes[ProcID];
    while (curr_box) {
    b1d8:	e3530000 	cmp	r3, #0
#include "mddata.h"
#include "split.h"
#include "global.h"

void POTENG(double *POTA, double *POTR, double *PTRF, long ProcID)
{
    b1dc:	e58d10d4 	str	r1, [sp, #212]	; 0xd4
    double tempa, tempb, tempc;

    /*  compute intra-molecular potential energy */

    LPOTA=0.0;
    curr_box = my_boxes[ProcID];
    b1e0:	e58d3088 	str	r3, [sp, #136]	; 0x88
#include "mddata.h"
#include "split.h"
#include "global.h"

void POTENG(double *POTA, double *POTR, double *PTRF, long ProcID)
{
    b1e4:	e58d20d8 	str	r2, [sp, #216]	; 0xd8
    double *tx_p, *ty_p, *tz_p;
    double tempa, tempb, tempc;

    /*  compute intra-molecular potential energy */

    LPOTA=0.0;
    b1e8:	e1cd4bf0 	strd	r4, [sp, #176]	; 0xb0
    curr_box = my_boxes[ProcID];
    while (curr_box) {
    b1ec:	0a00022f 	beq	bab0 <POTENG+0x900>
    b1f0:	e59d5088 	ldr	r5, [sp, #136]	; 0x88
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        /* Go through the molecules in a box */

        curr_ptr = BOX[i][j][k].list;
    b1f4:	e59fccd8 	ldr	ip, [pc, #3288]	; bed4 <POTENG+0xd24>
    b1f8:	e5952000 	ldr	r2, [r5]
    b1fc:	e59c3000 	ldr	r3, [ip]
    b200:	e5951004 	ldr	r1, [r5, #4]
    b204:	e7933102 	ldr	r3, [r3, r2, lsl #2]
    b208:	e5952008 	ldr	r2, [r5, #8]
    b20c:	e7933101 	ldr	r3, [r3, r1, lsl #2]
    b210:	e793c202 	ldr	ip, [r3, r2, lsl #4]
        while (curr_ptr) {
    b214:	e35c0000 	cmp	ip, #0
    b218:	0a00021f 	beq	ba9c <POTENG+0x8ec>

            tx_p = curr_ptr->mol.F[DISP][XDIR];
            ty_p = curr_ptr->mol.F[DISP][YDIR];
            tz_p = curr_ptr->mol.F[DISP][ZDIR];

            curr_ptr->mol.VM[XDIR] = C1 * tx_p[O] +
    b21c:	e1cca2d0 	ldrd	sl, [ip, #32]
                C2 * (tx_p[H1] +
    b220:	e1cc81d8 	ldrd	r8, [ip, #24]
                      tx_p[H2]);
    b224:	e1cc42d8 	ldrd	r4, [ip, #40]	; 0x28

            tx_p = curr_ptr->mol.F[DISP][XDIR];
            ty_p = curr_ptr->mol.F[DISP][YDIR];
            tz_p = curr_ptr->mol.F[DISP][ZDIR];

            curr_ptr->mol.VM[XDIR] = C1 * tx_p[O] +
    b228:	e59feca8 	ldr	lr, [pc, #3240]	; bed8 <POTENG+0xd28>
    b22c:	e1a0000a 	mov	r0, sl
    b230:	e1ce60d0 	ldrd	r6, [lr]
                C2 * (tx_p[H1] +
    b234:	e59feca0 	ldr	lr, [pc, #3232]	; bedc <POTENG+0xd2c>

            tx_p = curr_ptr->mol.F[DISP][XDIR];
            ty_p = curr_ptr->mol.F[DISP][YDIR];
            tz_p = curr_ptr->mol.F[DISP][ZDIR];

            curr_ptr->mol.VM[XDIR] = C1 * tx_p[O] +
    b238:	e1a02006 	mov	r2, r6
    b23c:	e1a03007 	mov	r3, r7
    b240:	e1a0100b 	mov	r1, fp
                C2 * (tx_p[H1] +
                      tx_p[H2]);
    b244:	e1cd45f0 	strd	r4, [sp, #80]	; 0x50
            tx_p = curr_ptr->mol.F[DISP][XDIR];
            ty_p = curr_ptr->mol.F[DISP][YDIR];
            tz_p = curr_ptr->mol.F[DISP][ZDIR];

            curr_ptr->mol.VM[XDIR] = C1 * tx_p[O] +
                C2 * (tx_p[H1] +
    b248:	e1ce40d0 	ldrd	r4, [lr]

            tx_p = curr_ptr->mol.F[DISP][XDIR];
            ty_p = curr_ptr->mol.F[DISP][YDIR];
            tz_p = curr_ptr->mol.F[DISP][ZDIR];

            curr_ptr->mol.VM[XDIR] = C1 * tx_p[O] +
    b24c:	e58dc024 	str	ip, [sp, #36]	; 0x24
    b250:	eb00262a 	bl	14b00 <__aeabi_dmul>
                C2 * (tx_p[H1] +
    b254:	e1cd25d0 	ldrd	r2, [sp, #80]	; 0x50

            tx_p = curr_ptr->mol.F[DISP][XDIR];
            ty_p = curr_ptr->mol.F[DISP][YDIR];
            tz_p = curr_ptr->mol.F[DISP][ZDIR];

            curr_ptr->mol.VM[XDIR] = C1 * tx_p[O] +
    b258:	e1cd04f8 	strd	r0, [sp, #72]	; 0x48
                C2 * (tx_p[H1] +
    b25c:	e1a00008 	mov	r0, r8
    b260:	e1a01009 	mov	r1, r9
    b264:	eb002521 	bl	146f0 <__adddf3>
    b268:	e1a02004 	mov	r2, r4
    b26c:	e1a03005 	mov	r3, r5
    b270:	eb002622 	bl	14b00 <__aeabi_dmul>
    b274:	e1a02000 	mov	r2, r0
    b278:	e1a03001 	mov	r3, r1

            tx_p = curr_ptr->mol.F[DISP][XDIR];
            ty_p = curr_ptr->mol.F[DISP][YDIR];
            tz_p = curr_ptr->mol.F[DISP][ZDIR];

            curr_ptr->mol.VM[XDIR] = C1 * tx_p[O] +
    b27c:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    b280:	eb00251a 	bl	146f0 <__adddf3>
                C2 * (tx_p[H1] +
                      tx_p[H2]);
            curr_ptr->mol.VM[YDIR] = C1*ty_p[O] +
    b284:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    b288:	e1cc23d8 	ldrd	r2, [ip, #56]	; 0x38
    b28c:	e1cd24f8 	strd	r2, [sp, #72]	; 0x48
                C2*(ty_p[H1] +
    b290:	e1cc23d0 	ldrd	r2, [ip, #48]	; 0x30

            tx_p = curr_ptr->mol.F[DISP][XDIR];
            ty_p = curr_ptr->mol.F[DISP][YDIR];
            tz_p = curr_ptr->mol.F[DISP][ZDIR];

            curr_ptr->mol.VM[XDIR] = C1 * tx_p[O] +
    b294:	e1cc00f0 	strd	r0, [ip]
                C2 * (tx_p[H1] +
                      tx_p[H2]);
            curr_ptr->mol.VM[YDIR] = C1*ty_p[O] +
                C2*(ty_p[H1] +
    b298:	e1cd25f8 	strd	r2, [sp, #88]	; 0x58
                    ty_p[H2]);
    b29c:	e1cc24d0 	ldrd	r2, [ip, #64]	; 0x40
            tz_p = curr_ptr->mol.F[DISP][ZDIR];

            curr_ptr->mol.VM[XDIR] = C1 * tx_p[O] +
                C2 * (tx_p[H1] +
                      tx_p[H2]);
            curr_ptr->mol.VM[YDIR] = C1*ty_p[O] +
    b2a0:	e1a00006 	mov	r0, r6
                C2*(ty_p[H1] +
                    ty_p[H2]);
    b2a4:	e1cd26f0 	strd	r2, [sp, #96]	; 0x60
            tz_p = curr_ptr->mol.F[DISP][ZDIR];

            curr_ptr->mol.VM[XDIR] = C1 * tx_p[O] +
                C2 * (tx_p[H1] +
                      tx_p[H2]);
            curr_ptr->mol.VM[YDIR] = C1*ty_p[O] +
    b2a8:	e1cd24d8 	ldrd	r2, [sp, #72]	; 0x48
    b2ac:	e1a01007 	mov	r1, r7
    b2b0:	e58dc024 	str	ip, [sp, #36]	; 0x24
    b2b4:	eb002611 	bl	14b00 <__aeabi_dmul>
                C2*(ty_p[H1] +
    b2b8:	e1cd26d0 	ldrd	r2, [sp, #96]	; 0x60
            tz_p = curr_ptr->mol.F[DISP][ZDIR];

            curr_ptr->mol.VM[XDIR] = C1 * tx_p[O] +
                C2 * (tx_p[H1] +
                      tx_p[H2]);
            curr_ptr->mol.VM[YDIR] = C1*ty_p[O] +
    b2bc:	e1cd04f0 	strd	r0, [sp, #64]	; 0x40
                C2*(ty_p[H1] +
    b2c0:	e1cd05d8 	ldrd	r0, [sp, #88]	; 0x58
    b2c4:	eb002509 	bl	146f0 <__adddf3>
    b2c8:	e1a02000 	mov	r2, r0
    b2cc:	e1a03001 	mov	r3, r1
    b2d0:	e1a00004 	mov	r0, r4
    b2d4:	e1a01005 	mov	r1, r5
    b2d8:	eb002608 	bl	14b00 <__aeabi_dmul>
    b2dc:	e1a02000 	mov	r2, r0
    b2e0:	e1a03001 	mov	r3, r1
            tz_p = curr_ptr->mol.F[DISP][ZDIR];

            curr_ptr->mol.VM[XDIR] = C1 * tx_p[O] +
                C2 * (tx_p[H1] +
                      tx_p[H2]);
            curr_ptr->mol.VM[YDIR] = C1*ty_p[O] +
    b2e4:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    b2e8:	eb002500 	bl	146f0 <__adddf3>
                C2*(ty_p[H1] +
                    ty_p[H2]);
            curr_ptr->mol.VM[ZDIR] = C1*tz_p[O] +
    b2ec:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    b2f0:	e1cc25d0 	ldrd	r2, [ip, #80]	; 0x50
    b2f4:	e1cd24f0 	strd	r2, [sp, #64]	; 0x40
                C2*(tz_p[H1] +
    b2f8:	e1cc24d8 	ldrd	r2, [ip, #72]	; 0x48
            tz_p = curr_ptr->mol.F[DISP][ZDIR];

            curr_ptr->mol.VM[XDIR] = C1 * tx_p[O] +
                C2 * (tx_p[H1] +
                      tx_p[H2]);
            curr_ptr->mol.VM[YDIR] = C1*ty_p[O] +
    b2fc:	e1cc00f8 	strd	r0, [ip, #8]
                C2*(ty_p[H1] +
                    ty_p[H2]);
            curr_ptr->mol.VM[ZDIR] = C1*tz_p[O] +
                C2*(tz_p[H1] +
    b300:	e1cd27f0 	strd	r2, [sp, #112]	; 0x70
                    tz_p[H2]);
    b304:	e1cc25d8 	ldrd	r2, [ip, #88]	; 0x58
                C2 * (tx_p[H1] +
                      tx_p[H2]);
            curr_ptr->mol.VM[YDIR] = C1*ty_p[O] +
                C2*(ty_p[H1] +
                    ty_p[H2]);
            curr_ptr->mol.VM[ZDIR] = C1*tz_p[O] +
    b308:	e1a00006 	mov	r0, r6
                C2*(tz_p[H1] +
                    tz_p[H2]);
    b30c:	e1cd26f8 	strd	r2, [sp, #104]	; 0x68
                C2 * (tx_p[H1] +
                      tx_p[H2]);
            curr_ptr->mol.VM[YDIR] = C1*ty_p[O] +
                C2*(ty_p[H1] +
                    ty_p[H2]);
            curr_ptr->mol.VM[ZDIR] = C1*tz_p[O] +
    b310:	e1cd24d0 	ldrd	r2, [sp, #64]	; 0x40
    b314:	e1a01007 	mov	r1, r7
    b318:	e58dc024 	str	ip, [sp, #36]	; 0x24
    b31c:	eb0025f7 	bl	14b00 <__aeabi_dmul>
                C2*(tz_p[H1] +
    b320:	e1cd26d8 	ldrd	r2, [sp, #104]	; 0x68
                C2 * (tx_p[H1] +
                      tx_p[H2]);
            curr_ptr->mol.VM[YDIR] = C1*ty_p[O] +
                C2*(ty_p[H1] +
                    ty_p[H2]);
            curr_ptr->mol.VM[ZDIR] = C1*tz_p[O] +
    b324:	e1a06000 	mov	r6, r0
    b328:	e1a07001 	mov	r7, r1
                C2*(tz_p[H1] +
    b32c:	e1cd07d0 	ldrd	r0, [sp, #112]	; 0x70
    b330:	eb0024ee 	bl	146f0 <__adddf3>
    b334:	e1a02000 	mov	r2, r0
    b338:	e1a03001 	mov	r3, r1
    b33c:	e1a00004 	mov	r0, r4
    b340:	e1a01005 	mov	r1, r5
    b344:	eb0025ed 	bl	14b00 <__aeabi_dmul>
    b348:	e1a02000 	mov	r2, r0
    b34c:	e1a03001 	mov	r3, r1
                C2 * (tx_p[H1] +
                      tx_p[H2]);
            curr_ptr->mol.VM[YDIR] = C1*ty_p[O] +
                C2*(ty_p[H1] +
                    ty_p[H2]);
            curr_ptr->mol.VM[ZDIR] = C1*tz_p[O] +
    b350:	e1a00006 	mov	r0, r6
    b354:	e1a01007 	mov	r1, r7
    b358:	eb0024e4 	bl	146f0 <__adddf3>
    b35c:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
                C2*(tz_p[H1] +
                    tz_p[H2]);
            tempa = tx_p[O] - tx_p[H1];
    b360:	e1a02008 	mov	r2, r8
                C2 * (tx_p[H1] +
                      tx_p[H2]);
            curr_ptr->mol.VM[YDIR] = C1*ty_p[O] +
                C2*(ty_p[H1] +
                    ty_p[H2]);
            curr_ptr->mol.VM[ZDIR] = C1*tz_p[O] +
    b364:	e1cc01f0 	strd	r0, [ip, #16]
                C2*(tz_p[H1] +
                    tz_p[H2]);
            tempa = tx_p[O] - tx_p[H1];
    b368:	e1a03009 	mov	r3, r9
    b36c:	e1a0000a 	mov	r0, sl
    b370:	e1a0100b 	mov	r1, fp
    b374:	e58dc024 	str	ip, [sp, #36]	; 0x24
    b378:	eb0024db 	bl	146ec <__aeabi_dsub>
            tempb = ty_p[O] - ty_p[H1];
    b37c:	e1cd25d8 	ldrd	r2, [sp, #88]	; 0x58
                C2*(ty_p[H1] +
                    ty_p[H2]);
            curr_ptr->mol.VM[ZDIR] = C1*tz_p[O] +
                C2*(tz_p[H1] +
                    tz_p[H2]);
            tempa = tx_p[O] - tx_p[H1];
    b380:	e1a08000 	mov	r8, r0
    b384:	e1a09001 	mov	r9, r1
            tempb = ty_p[O] - ty_p[H1];
    b388:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    b38c:	eb0024d6 	bl	146ec <__aeabi_dsub>
            tempc = tz_p[O] - tz_p[H1];
    b390:	e1cd27d0 	ldrd	r2, [sp, #112]	; 0x70
                    ty_p[H2]);
            curr_ptr->mol.VM[ZDIR] = C1*tz_p[O] +
                C2*(tz_p[H1] +
                    tz_p[H2]);
            tempa = tx_p[O] - tx_p[H1];
            tempb = ty_p[O] - ty_p[H1];
    b394:	e1a06000 	mov	r6, r0
    b398:	e1a07001 	mov	r7, r1
            tempc = tz_p[O] - tz_p[H1];
    b39c:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    b3a0:	eb0024d1 	bl	146ec <__aeabi_dsub>
            R1 = tempa * tempa + tempb * tempb + tempc * tempc;
    b3a4:	e1a02008 	mov	r2, r8
            curr_ptr->mol.VM[ZDIR] = C1*tz_p[O] +
                C2*(tz_p[H1] +
                    tz_p[H2]);
            tempa = tx_p[O] - tx_p[H1];
            tempb = ty_p[O] - ty_p[H1];
            tempc = tz_p[O] - tz_p[H1];
    b3a8:	e1a04000 	mov	r4, r0
    b3ac:	e1a05001 	mov	r5, r1
            R1 = tempa * tempa + tempb * tempb + tempc * tempc;
    b3b0:	e1a03009 	mov	r3, r9
    b3b4:	e1a00008 	mov	r0, r8
    b3b8:	e1a01009 	mov	r1, r9
    b3bc:	eb0025cf 	bl	14b00 <__aeabi_dmul>
    b3c0:	e1a02006 	mov	r2, r6
    b3c4:	e1cd05f8 	strd	r0, [sp, #88]	; 0x58
    b3c8:	e1a03007 	mov	r3, r7
    b3cc:	e1a00006 	mov	r0, r6
    b3d0:	e1a01007 	mov	r1, r7
    b3d4:	eb0025c9 	bl	14b00 <__aeabi_dmul>
    b3d8:	e1a02000 	mov	r2, r0
    b3dc:	e1a03001 	mov	r3, r1
    b3e0:	e1cd05d8 	ldrd	r0, [sp, #88]	; 0x58
    b3e4:	eb0024c1 	bl	146f0 <__adddf3>
    b3e8:	e1a02004 	mov	r2, r4
    b3ec:	e1cd05f8 	strd	r0, [sp, #88]	; 0x58
    b3f0:	e1a03005 	mov	r3, r5
    b3f4:	e1a00004 	mov	r0, r4
    b3f8:	e1a01005 	mov	r1, r5
    b3fc:	eb0025bf 	bl	14b00 <__aeabi_dmul>
    b400:	e1a02000 	mov	r2, r0
    b404:	e1a03001 	mov	r3, r1
    b408:	e1cd05d8 	ldrd	r0, [sp, #88]	; 0x58
    b40c:	eb0024b7 	bl	146f0 <__adddf3>
            tempa = tx_p[O] - tx_p[H2];
    b410:	e1cd25d0 	ldrd	r2, [sp, #80]	; 0x50
                C2*(tz_p[H1] +
                    tz_p[H2]);
            tempa = tx_p[O] - tx_p[H1];
            tempb = ty_p[O] - ty_p[H1];
            tempc = tz_p[O] - tz_p[H1];
            R1 = tempa * tempa + tempb * tempb + tempc * tempc;
    b414:	e1cd05f8 	strd	r0, [sp, #88]	; 0x58
            tempa = tx_p[O] - tx_p[H2];
    b418:	e1a0000a 	mov	r0, sl
    b41c:	e1a0100b 	mov	r1, fp
    b420:	eb0024b1 	bl	146ec <__aeabi_dsub>
            tempb = ty_p[O] - ty_p[H2];
    b424:	e1cd26d0 	ldrd	r2, [sp, #96]	; 0x60
                    tz_p[H2]);
            tempa = tx_p[O] - tx_p[H1];
            tempb = ty_p[O] - ty_p[H1];
            tempc = tz_p[O] - tz_p[H1];
            R1 = tempa * tempa + tempb * tempb + tempc * tempc;
            tempa = tx_p[O] - tx_p[H2];
    b428:	e1a0a000 	mov	sl, r0
    b42c:	e1a0b001 	mov	fp, r1
            tempb = ty_p[O] - ty_p[H2];
    b430:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    b434:	eb0024ac 	bl	146ec <__aeabi_dsub>
            tempc = tz_p[O] - tz_p[H2];
    b438:	e1cd26d8 	ldrd	r2, [sp, #104]	; 0x68
            tempa = tx_p[O] - tx_p[H1];
            tempb = ty_p[O] - ty_p[H1];
            tempc = tz_p[O] - tz_p[H1];
            R1 = tempa * tempa + tempb * tempb + tempc * tempc;
            tempa = tx_p[O] - tx_p[H2];
            tempb = ty_p[O] - ty_p[H2];
    b43c:	e1cd04f8 	strd	r0, [sp, #72]	; 0x48
            tempc = tz_p[O] - tz_p[H2];
    b440:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    b444:	eb0024a8 	bl	146ec <__aeabi_dsub>
            R2 = tempa * tempa + tempb * tempb + tempc * tempc;
    b448:	e1a0200a 	mov	r2, sl
            tempb = ty_p[O] - ty_p[H1];
            tempc = tz_p[O] - tz_p[H1];
            R1 = tempa * tempa + tempb * tempb + tempc * tempc;
            tempa = tx_p[O] - tx_p[H2];
            tempb = ty_p[O] - ty_p[H2];
            tempc = tz_p[O] - tz_p[H2];
    b44c:	e1cd04f0 	strd	r0, [sp, #64]	; 0x40
            R2 = tempa * tempa + tempb * tempb + tempc * tempc;
    b450:	e1a0300b 	mov	r3, fp
    b454:	e1a0000a 	mov	r0, sl
    b458:	e1a0100b 	mov	r1, fp
    b45c:	eb0025a7 	bl	14b00 <__aeabi_dmul>
    b460:	e1cd05f0 	strd	r0, [sp, #80]	; 0x50
    b464:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    b468:	e1a02000 	mov	r2, r0
    b46c:	e1a03001 	mov	r3, r1
    b470:	eb0025a2 	bl	14b00 <__aeabi_dmul>
    b474:	e1a02000 	mov	r2, r0
    b478:	e1a03001 	mov	r3, r1
    b47c:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    b480:	eb00249a 	bl	146f0 <__adddf3>
    b484:	e1cd05f0 	strd	r0, [sp, #80]	; 0x50
    b488:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    b48c:	e1a02000 	mov	r2, r0
    b490:	e1a03001 	mov	r3, r1
    b494:	eb002599 	bl	14b00 <__aeabi_dmul>
    b498:	e1a02000 	mov	r2, r0
    b49c:	e1a03001 	mov	r3, r1
    b4a0:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    b4a4:	eb002491 	bl	146f0 <__adddf3>
    b4a8:	e1a02000 	mov	r2, r0
    b4ac:	e1a03001 	mov	r3, r1
                      ((ty_p[O] - ty_p[H1]) *
                       (ty_p[O] - ty_p[H2])) +
                           ((tz_p[O] - tz_p[H1]) *
                            (tz_p[O] - tz_p[H2]));

            R1=sqrt(R1);
    b4b0:	e1cd05d8 	ldrd	r0, [sp, #88]	; 0x58
    b4b4:	e58d202c 	str	r2, [sp, #44]	; 0x2c
    b4b8:	e58d3028 	str	r3, [sp, #40]	; 0x28
    b4bc:	eb007c7b 	bl	2a6b0 <sqrt>
            R2=sqrt(R2);
    b4c0:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    b4c4:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
                      ((ty_p[O] - ty_p[H1]) *
                       (ty_p[O] - ty_p[H2])) +
                           ((tz_p[O] - tz_p[H1]) *
                            (tz_p[O] - tz_p[H2]));

            R1=sqrt(R1);
    b4c8:	e1cd05f0 	strd	r0, [sp, #80]	; 0x50
            R2=sqrt(R2);
    b4cc:	e1a00002 	mov	r0, r2
    b4d0:	e1a01003 	mov	r1, r3
    b4d4:	eb007c75 	bl	2a6b0 <sqrt>
            tempa = tx_p[O] - tx_p[H2];
            tempb = ty_p[O] - ty_p[H2];
            tempc = tz_p[O] - tz_p[H2];
            R2 = tempa * tempa + tempb * tempb + tempc * tempc;

            RX = ((tx_p[O] - tx_p[H1]) *
    b4d8:	e1a0200a 	mov	r2, sl
                       (ty_p[O] - ty_p[H2])) +
                           ((tz_p[O] - tz_p[H1]) *
                            (tz_p[O] - tz_p[H2]));

            R1=sqrt(R1);
            R2=sqrt(R2);
    b4dc:	e1cd05f8 	strd	r0, [sp, #88]	; 0x58
            tempa = tx_p[O] - tx_p[H2];
            tempb = ty_p[O] - ty_p[H2];
            tempc = tz_p[O] - tz_p[H2];
            R2 = tempa * tempa + tempb * tempb + tempc * tempc;

            RX = ((tx_p[O] - tx_p[H1]) *
    b4e0:	e1a0300b 	mov	r3, fp
    b4e4:	e1a00008 	mov	r0, r8
    b4e8:	e1a01009 	mov	r1, r9
    b4ec:	eb002583 	bl	14b00 <__aeabi_dmul>
                  (tx_p[O] - tx_p[H2])) +
                      ((ty_p[O] - ty_p[H1]) *
    b4f0:	e1cd24d8 	ldrd	r2, [sp, #72]	; 0x48
            tempa = tx_p[O] - tx_p[H2];
            tempb = ty_p[O] - ty_p[H2];
            tempc = tz_p[O] - tz_p[H2];
            R2 = tempa * tempa + tempb * tempb + tempc * tempc;

            RX = ((tx_p[O] - tx_p[H1]) *
    b4f4:	e1a08000 	mov	r8, r0
    b4f8:	e1a09001 	mov	r9, r1
                  (tx_p[O] - tx_p[H2])) +
                      ((ty_p[O] - ty_p[H1]) *
    b4fc:	e1a00006 	mov	r0, r6
    b500:	e1a01007 	mov	r1, r7
    b504:	eb00257d 	bl	14b00 <__aeabi_dmul>
    b508:	e1a02000 	mov	r2, r0
    b50c:	e1a03001 	mov	r3, r1
            tempb = ty_p[O] - ty_p[H2];
            tempc = tz_p[O] - tz_p[H2];
            R2 = tempa * tempa + tempb * tempb + tempc * tempc;

            RX = ((tx_p[O] - tx_p[H1]) *
                  (tx_p[O] - tx_p[H2])) +
    b510:	e1a00008 	mov	r0, r8
    b514:	e1a01009 	mov	r1, r9
    b518:	eb002474 	bl	146f0 <__adddf3>
                      ((ty_p[O] - ty_p[H1]) *
                       (ty_p[O] - ty_p[H2])) +
                           ((tz_p[O] - tz_p[H1]) *
    b51c:	e1cd24d0 	ldrd	r2, [sp, #64]	; 0x40
            tempb = ty_p[O] - ty_p[H2];
            tempc = tz_p[O] - tz_p[H2];
            R2 = tempa * tempa + tempb * tempb + tempc * tempc;

            RX = ((tx_p[O] - tx_p[H1]) *
                  (tx_p[O] - tx_p[H2])) +
    b520:	e1a06000 	mov	r6, r0
    b524:	e1a07001 	mov	r7, r1
                      ((ty_p[O] - ty_p[H1]) *
                       (ty_p[O] - ty_p[H2])) +
                           ((tz_p[O] - tz_p[H1]) *
    b528:	e1a00004 	mov	r0, r4
    b52c:	e1a01005 	mov	r1, r5
    b530:	eb002572 	bl	14b00 <__aeabi_dmul>
    b534:	e1a02000 	mov	r2, r0
    b538:	e1a03001 	mov	r3, r1
            tempa = tx_p[O] - tx_p[H2];
            tempb = ty_p[O] - ty_p[H2];
            tempc = tz_p[O] - tz_p[H2];
            R2 = tempa * tempa + tempb * tempb + tempc * tempc;

            RX = ((tx_p[O] - tx_p[H1]) *
    b53c:	e1a00006 	mov	r0, r6
    b540:	e1a01007 	mov	r1, r7
    b544:	eb002469 	bl	146f0 <__adddf3>
                           ((tz_p[O] - tz_p[H1]) *
                            (tz_p[O] - tz_p[H2]));

            R1=sqrt(R1);
            R2=sqrt(R2);
            COS=RX/(R1*R2);
    b548:	e1cd25d8 	ldrd	r2, [sp, #88]	; 0x58
            tempa = tx_p[O] - tx_p[H2];
            tempb = ty_p[O] - ty_p[H2];
            tempc = tz_p[O] - tz_p[H2];
            R2 = tempa * tempa + tempb * tempb + tempc * tempc;

            RX = ((tx_p[O] - tx_p[H1]) *
    b54c:	e1a04000 	mov	r4, r0
    b550:	e1a05001 	mov	r5, r1
                           ((tz_p[O] - tz_p[H1]) *
                            (tz_p[O] - tz_p[H2]));

            R1=sqrt(R1);
            R2=sqrt(R2);
            COS=RX/(R1*R2);
    b554:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    b558:	eb002568 	bl	14b00 <__aeabi_dmul>
    b55c:	e1a02000 	mov	r2, r0
    b560:	e1a03001 	mov	r3, r1
    b564:	e1a00004 	mov	r0, r4
    b568:	e1a01005 	mov	r1, r5
    b56c:	eb002607 	bl	14d90 <__aeabi_ddiv>
            DT=(acos(COS)-ANGLE)*ROH;
    b570:	eb007927 	bl	29a14 <acos>
    b574:	e59fe964 	ldr	lr, [pc, #2404]	; bee0 <POTENG+0xd30>
    b578:	e59f3964 	ldr	r3, [pc, #2404]	; bee4 <POTENG+0xd34>
    b57c:	e1c340d0 	ldrd	r4, [r3]
    b580:	e1ce20d0 	ldrd	r2, [lr]
    b584:	eb002458 	bl	146ec <__aeabi_dsub>
    b588:	e1a02004 	mov	r2, r4
    b58c:	e1a03005 	mov	r3, r5
    b590:	eb00255a 	bl	14b00 <__aeabi_dmul>
            DR1=R1-ROH;
    b594:	e1a02004 	mov	r2, r4
                            (tz_p[O] - tz_p[H2]));

            R1=sqrt(R1);
            R2=sqrt(R2);
            COS=RX/(R1*R2);
            DT=(acos(COS)-ANGLE)*ROH;
    b598:	e1a08000 	mov	r8, r0
    b59c:	e1a09001 	mov	r9, r1
            DR1=R1-ROH;
    b5a0:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    b5a4:	e1a03005 	mov	r3, r5
    b5a8:	eb00244f 	bl	146ec <__aeabi_dsub>
            DR2=R2-ROH;
    b5ac:	e1a02004 	mov	r2, r4

            R1=sqrt(R1);
            R2=sqrt(R2);
            COS=RX/(R1*R2);
            DT=(acos(COS)-ANGLE)*ROH;
            DR1=R1-ROH;
    b5b0:	e1a06000 	mov	r6, r0
    b5b4:	e1a07001 	mov	r7, r1
            DR2=R2-ROH;
    b5b8:	e1cd05d8 	ldrd	r0, [sp, #88]	; 0x58
    b5bc:	e1a03005 	mov	r3, r5
    b5c0:	eb002449 	bl	146ec <__aeabi_dsub>
            DR1S=DR1*DR1;
    b5c4:	e1a02006 	mov	r2, r6
            R1=sqrt(R1);
            R2=sqrt(R2);
            COS=RX/(R1*R2);
            DT=(acos(COS)-ANGLE)*ROH;
            DR1=R1-ROH;
            DR2=R2-ROH;
    b5c8:	e1a04000 	mov	r4, r0
    b5cc:	e1a05001 	mov	r5, r1
            DR1S=DR1*DR1;
    b5d0:	e1a03007 	mov	r3, r7
    b5d4:	e1a00006 	mov	r0, r6
    b5d8:	e1a01007 	mov	r1, r7
    b5dc:	eb002547 	bl	14b00 <__aeabi_dmul>
            DR2S=DR2*DR2;
    b5e0:	e1a02004 	mov	r2, r4
            R2=sqrt(R2);
            COS=RX/(R1*R2);
            DT=(acos(COS)-ANGLE)*ROH;
            DR1=R1-ROH;
            DR2=R2-ROH;
            DR1S=DR1*DR1;
    b5e4:	e1cd04f8 	strd	r0, [sp, #72]	; 0x48
            DR2S=DR2*DR2;
    b5e8:	e1a03005 	mov	r3, r5
    b5ec:	e1a00004 	mov	r0, r4
    b5f0:	e1a01005 	mov	r1, r5
    b5f4:	eb002541 	bl	14b00 <__aeabi_dmul>
            DRP=DR1+DR2;
    b5f8:	e1a02004 	mov	r2, r4
            COS=RX/(R1*R2);
            DT=(acos(COS)-ANGLE)*ROH;
            DR1=R1-ROH;
            DR2=R2-ROH;
            DR1S=DR1*DR1;
            DR2S=DR2*DR2;
    b5fc:	e1cd04f0 	strd	r0, [sp, #64]	; 0x40
            DRP=DR1+DR2;
    b600:	e1a03005 	mov	r3, r5
    b604:	e1a00006 	mov	r0, r6
    b608:	e1a01007 	mov	r1, r7
    b60c:	eb002437 	bl	146f0 <__adddf3>
            DTS=DT*DT;
    b610:	e1a02008 	mov	r2, r8
            DT=(acos(COS)-ANGLE)*ROH;
            DR1=R1-ROH;
            DR2=R2-ROH;
            DR1S=DR1*DR1;
            DR2S=DR2*DR2;
            DRP=DR1+DR2;
    b614:	e1cd05f0 	strd	r0, [sp, #80]	; 0x50
            DTS=DT*DT;
    b618:	e1a03009 	mov	r3, r9
    b61c:	e1a00008 	mov	r0, r8
    b620:	e1a01009 	mov	r1, r9
    b624:	eb002535 	bl	14b00 <__aeabi_dmul>
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
    b628:	e1cd24d0 	ldrd	r2, [sp, #64]	; 0x40
            DR1=R1-ROH;
            DR2=R2-ROH;
            DR1S=DR1*DR1;
            DR2S=DR2*DR2;
            DRP=DR1+DR2;
            DTS=DT*DT;
    b62c:	e1a0a000 	mov	sl, r0
    b630:	e1a0b001 	mov	fp, r1
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
    b634:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    b638:	eb00242c 	bl	146f0 <__adddf3>
                +FC12*DR1*DR2+FC13*DRP*DT
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
    b63c:	e1a02006 	mov	r2, r6
            DR2=R2-ROH;
            DR1S=DR1*DR1;
            DR2S=DR2*DR2;
            DRP=DR1+DR2;
            DTS=DT*DT;
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
    b640:	e1cd05f8 	strd	r0, [sp, #88]	; 0x58
                +FC12*DR1*DR2+FC13*DRP*DT
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
    b644:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    b648:	e1a03007 	mov	r3, r7
    b64c:	eb00252b 	bl	14b00 <__aeabi_dmul>
    b650:	e1a02004 	mov	r2, r4
    b654:	e1a03005 	mov	r3, r5
    b658:	e1cd06f0 	strd	r0, [sp, #96]	; 0x60
    b65c:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    b660:	eb002526 	bl	14b00 <__aeabi_dmul>
    b664:	e1a02000 	mov	r2, r0
    b668:	e1a03001 	mov	r3, r1
    b66c:	e1cd06d0 	ldrd	r0, [sp, #96]	; 0x60
    b670:	eb00241e 	bl	146f0 <__adddf3>
            DR2=R2-ROH;
            DR1S=DR1*DR1;
            DR2S=DR2*DR2;
            DRP=DR1+DR2;
            DTS=DT*DT;
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
    b674:	e59fe86c 	ldr	lr, [pc, #2156]	; bee8 <POTENG+0xd38>
                +FC12*DR1*DR2+FC13*DRP*DT
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
    b678:	e1cd06f0 	strd	r0, [sp, #96]	; 0x60
            DR2=R2-ROH;
            DR1S=DR1*DR1;
            DR2S=DR2*DR2;
            DRP=DR1+DR2;
            DTS=DT*DT;
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
    b67c:	e1ce20d0 	ldrd	r2, [lr]
    b680:	e1cd05d8 	ldrd	r0, [sp, #88]	; 0x58
    b684:	eb00251d 	bl	14b00 <__aeabi_dmul>
    b688:	e59fe85c 	ldr	lr, [pc, #2140]	; beec <POTENG+0xd3c>
    b68c:	e1cd07f0 	strd	r0, [sp, #112]	; 0x70
    b690:	e1ce20d0 	ldrd	r2, [lr]
    b694:	e1a0000a 	mov	r0, sl
    b698:	e1a0100b 	mov	r1, fp
    b69c:	eb002517 	bl	14b00 <__aeabi_dmul>
    b6a0:	e1a02000 	mov	r2, r0
    b6a4:	e1a03001 	mov	r3, r1
    b6a8:	e1cd07d0 	ldrd	r0, [sp, #112]	; 0x70
    b6ac:	eb00240f 	bl	146f0 <__adddf3>
    b6b0:	e3a02000 	mov	r2, #0
    b6b4:	e59f393c 	ldr	r3, [pc, #2364]	; bff8 <POTENG+0xe48>
    b6b8:	eb002510 	bl	14b00 <__aeabi_dmul>
                +FC12*DR1*DR2+FC13*DRP*DT
    b6bc:	e59fe82c 	ldr	lr, [pc, #2092]	; bef0 <POTENG+0xd40>
            DR2=R2-ROH;
            DR1S=DR1*DR1;
            DR2S=DR2*DR2;
            DRP=DR1+DR2;
            DTS=DT*DT;
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
    b6c0:	e1cd07f0 	strd	r0, [sp, #112]	; 0x70
                +FC12*DR1*DR2+FC13*DRP*DT
    b6c4:	e1ce20d0 	ldrd	r2, [lr]
    b6c8:	e1a00006 	mov	r0, r6
    b6cc:	e1a01007 	mov	r1, r7
    b6d0:	eb00250a 	bl	14b00 <__aeabi_dmul>
    b6d4:	e1a02004 	mov	r2, r4
    b6d8:	e1a03005 	mov	r3, r5
    b6dc:	eb002507 	bl	14b00 <__aeabi_dmul>
    b6e0:	e1a02000 	mov	r2, r0
    b6e4:	e1a03001 	mov	r3, r1
    b6e8:	e1cd07d0 	ldrd	r0, [sp, #112]	; 0x70
    b6ec:	eb0023ff 	bl	146f0 <__adddf3>
    b6f0:	e59fe7fc 	ldr	lr, [pc, #2044]	; bef4 <POTENG+0xd44>
    b6f4:	e1cd07f0 	strd	r0, [sp, #112]	; 0x70
    b6f8:	e1ce20d0 	ldrd	r2, [lr]
    b6fc:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    b700:	eb0024fe 	bl	14b00 <__aeabi_dmul>
    b704:	e1a02008 	mov	r2, r8
    b708:	e1a03009 	mov	r3, r9
    b70c:	eb0024fb 	bl	14b00 <__aeabi_dmul>
    b710:	e1a02000 	mov	r2, r0
    b714:	e1a03001 	mov	r3, r1
    b718:	e1cd07d0 	ldrd	r0, [sp, #112]	; 0x70
    b71c:	eb0023f3 	bl	146f0 <__adddf3>
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
    b720:	e59fe7d0 	ldr	lr, [pc, #2000]	; bef8 <POTENG+0xd48>
            DR1S=DR1*DR1;
            DR2S=DR2*DR2;
            DRP=DR1+DR2;
            DTS=DT*DT;
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
                +FC12*DR1*DR2+FC13*DRP*DT
    b724:	e1cd07f0 	strd	r0, [sp, #112]	; 0x70
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
    b728:	e1ce20d0 	ldrd	r2, [lr]
    b72c:	e1cd06d0 	ldrd	r0, [sp, #96]	; 0x60
    b730:	eb0024f2 	bl	14b00 <__aeabi_dmul>
    b734:	e59fe7c0 	ldr	lr, [pc, #1984]	; befc <POTENG+0xd4c>
    b738:	e1cd06f8 	strd	r0, [sp, #104]	; 0x68
    b73c:	e1ce20d0 	ldrd	r2, [lr]
    b740:	e1a0000a 	mov	r0, sl
    b744:	e1a0100b 	mov	r1, fp
    b748:	eb0024ec 	bl	14b00 <__aeabi_dmul>
    b74c:	e1a02008 	mov	r2, r8
    b750:	e1a03009 	mov	r3, r9
    b754:	eb0024e9 	bl	14b00 <__aeabi_dmul>
    b758:	e1a02000 	mov	r2, r0
    b75c:	e1a03001 	mov	r3, r1
    b760:	e1cd06d8 	ldrd	r0, [sp, #104]	; 0x68
    b764:	eb0023e1 	bl	146f0 <__adddf3>
    b768:	e59fe790 	ldr	lr, [pc, #1936]	; bf00 <POTENG+0xd50>
    b76c:	e1cd06f8 	strd	r0, [sp, #104]	; 0x68
    b770:	e1ce20d0 	ldrd	r2, [lr]
    b774:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    b778:	eb0024e0 	bl	14b00 <__aeabi_dmul>
    b77c:	e1a02006 	mov	r2, r6
    b780:	e1a03007 	mov	r3, r7
    b784:	eb0024dd 	bl	14b00 <__aeabi_dmul>
    b788:	e1a02004 	mov	r2, r4
    b78c:	e1a03005 	mov	r3, r5
    b790:	eb0024da 	bl	14b00 <__aeabi_dmul>
    b794:	e1a02000 	mov	r2, r0
    b798:	e1a03001 	mov	r3, r1
    b79c:	e1cd06d8 	ldrd	r0, [sp, #104]	; 0x68
    b7a0:	eb0023d2 	bl	146f0 <__adddf3>
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;
    b7a4:	e59fe758 	ldr	lr, [pc, #1880]	; bf04 <POTENG+0xd54>
            DR2S=DR2*DR2;
            DRP=DR1+DR2;
            DTS=DT*DT;
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
                +FC12*DR1*DR2+FC13*DRP*DT
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
    b7a8:	e1cd06f8 	strd	r0, [sp, #104]	; 0x68
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;
    b7ac:	e1ce20d0 	ldrd	r2, [lr]
    b7b0:	e1cd05d8 	ldrd	r0, [sp, #88]	; 0x58
    b7b4:	eb0024d1 	bl	14b00 <__aeabi_dmul>
    b7b8:	e1a02008 	mov	r2, r8
    b7bc:	e1a03009 	mov	r3, r9
    b7c0:	eb0024ce 	bl	14b00 <__aeabi_dmul>
    b7c4:	e1a02000 	mov	r2, r0
    b7c8:	e1a03001 	mov	r3, r1
            DR2S=DR2*DR2;
            DRP=DR1+DR2;
            DTS=DT*DT;
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
                +FC12*DR1*DR2+FC13*DRP*DT
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
    b7cc:	e1cd06d8 	ldrd	r0, [sp, #104]	; 0x68
    b7d0:	eb0023c6 	bl	146f0 <__adddf3>
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;
    b7d4:	e59fe72c 	ldr	lr, [pc, #1836]	; bf08 <POTENG+0xd58>
            DR2S=DR2*DR2;
            DRP=DR1+DR2;
            DTS=DT*DT;
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
                +FC12*DR1*DR2+FC13*DRP*DT
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
    b7d8:	e1cd06f8 	strd	r0, [sp, #104]	; 0x68
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;
    b7dc:	e1ce20d0 	ldrd	r2, [lr]
    b7e0:	e1a00006 	mov	r0, r6
    b7e4:	e1a01007 	mov	r1, r7
    b7e8:	eb0024c4 	bl	14b00 <__aeabi_dmul>
    b7ec:	e1a02004 	mov	r2, r4
    b7f0:	e1a03005 	mov	r3, r5
    b7f4:	eb0024c1 	bl	14b00 <__aeabi_dmul>
    b7f8:	e1a02008 	mov	r2, r8
    b7fc:	e1a03009 	mov	r3, r9
    b800:	eb0024be 	bl	14b00 <__aeabi_dmul>
    b804:	e1a02000 	mov	r2, r0
    b808:	e1a03001 	mov	r3, r1
    b80c:	e1cd06d8 	ldrd	r0, [sp, #104]	; 0x68
    b810:	eb0023b6 	bl	146f0 <__adddf3>
    b814:	e59fe6f0 	ldr	lr, [pc, #1776]	; bf0c <POTENG+0xd5c>
    b818:	e1cd06f8 	strd	r0, [sp, #104]	; 0x68
    b81c:	e1ce20d0 	ldrd	r2, [lr]
    b820:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    b824:	eb0024b5 	bl	14b00 <__aeabi_dmul>
    b828:	e1a0200a 	mov	r2, sl
    b82c:	e1a0300b 	mov	r3, fp
    b830:	eb0024b2 	bl	14b00 <__aeabi_dmul>
    b834:	e1a02000 	mov	r2, r0
    b838:	e1a03001 	mov	r3, r1
    b83c:	e1cd06d8 	ldrd	r0, [sp, #104]	; 0x68
    b840:	eb0023aa 	bl	146f0 <__adddf3>
    b844:	e59fe6c4 	ldr	lr, [pc, #1732]	; bf10 <POTENG+0xd60>
    b848:	e1ce20d0 	ldrd	r2, [lr]
    b84c:	eb0024ab 	bl	14b00 <__aeabi_dmul>
    b850:	e1a02000 	mov	r2, r0
    b854:	e1a03001 	mov	r3, r1
            DR2S=DR2*DR2;
            DRP=DR1+DR2;
            DTS=DT*DT;
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
                +FC12*DR1*DR2+FC13*DRP*DT
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
    b858:	e1cd07d0 	ldrd	r0, [sp, #112]	; 0x70
    b85c:	eb0023a3 	bl	146f0 <__adddf3>
            DR2=R2-ROH;
            DR1S=DR1*DR1;
            DR2S=DR2*DR2;
            DRP=DR1+DR2;
            DTS=DT*DT;
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
    b860:	e1cd2bd0 	ldrd	r2, [sp, #176]	; 0xb0
    b864:	eb0023a1 	bl	146f0 <__adddf3>
    b868:	e1cd07f0 	strd	r0, [sp, #112]	; 0x70
                +FC12*DR1*DR2+FC13*DRP*DT
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;

            LPOTA += (FC1111*(DR1S*DR1S+DR2S*DR2S)+FC3333*DTS*DTS+
    b86c:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    b870:	e1a02000 	mov	r2, r0
    b874:	e1a03001 	mov	r3, r1
    b878:	eb0024a0 	bl	14b00 <__aeabi_dmul>
    b87c:	e1cd06f8 	strd	r0, [sp, #104]	; 0x68
    b880:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    b884:	e1a02000 	mov	r2, r0
    b888:	e1a03001 	mov	r3, r1
    b88c:	eb00249b 	bl	14b00 <__aeabi_dmul>
    b890:	e1a02000 	mov	r2, r0
    b894:	e1a03001 	mov	r3, r1
    b898:	e1cd06d8 	ldrd	r0, [sp, #104]	; 0x68
    b89c:	eb002393 	bl	146f0 <__adddf3>
    b8a0:	e59fe66c 	ldr	lr, [pc, #1644]	; bf14 <POTENG+0xd64>
    b8a4:	e1ce20d0 	ldrd	r2, [lr]
    b8a8:	eb002494 	bl	14b00 <__aeabi_dmul>
    b8ac:	e59fe664 	ldr	lr, [pc, #1636]	; bf18 <POTENG+0xd68>
    b8b0:	e1cd06f8 	strd	r0, [sp, #104]	; 0x68
    b8b4:	e1ce20d0 	ldrd	r2, [lr]
    b8b8:	e1a0000a 	mov	r0, sl
    b8bc:	e1a0100b 	mov	r1, fp
    b8c0:	eb00248e 	bl	14b00 <__aeabi_dmul>
    b8c4:	e1a0200a 	mov	r2, sl
    b8c8:	e1a0300b 	mov	r3, fp
    b8cc:	eb00248b 	bl	14b00 <__aeabi_dmul>
    b8d0:	e1a02000 	mov	r2, r0
    b8d4:	e1a03001 	mov	r3, r1
    b8d8:	e1cd06d8 	ldrd	r0, [sp, #104]	; 0x68
    b8dc:	eb002383 	bl	146f0 <__adddf3>
                      FC1112*(DR1S+DR2S)*DR1*DR2+FC1122*DR1S*DR2S+
    b8e0:	e59fe634 	ldr	lr, [pc, #1588]	; bf1c <POTENG+0xd6c>
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
                +FC12*DR1*DR2+FC13*DRP*DT
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;

            LPOTA += (FC1111*(DR1S*DR1S+DR2S*DR2S)+FC3333*DTS*DTS+
    b8e4:	e1cd06f8 	strd	r0, [sp, #104]	; 0x68
                      FC1112*(DR1S+DR2S)*DR1*DR2+FC1122*DR1S*DR2S+
    b8e8:	e1ce20d0 	ldrd	r2, [lr]
    b8ec:	e1cd05d8 	ldrd	r0, [sp, #88]	; 0x58
    b8f0:	eb002482 	bl	14b00 <__aeabi_dmul>
    b8f4:	e1a02006 	mov	r2, r6
    b8f8:	e1a03007 	mov	r3, r7
    b8fc:	eb00247f 	bl	14b00 <__aeabi_dmul>
    b900:	e1a02004 	mov	r2, r4
    b904:	e1a03005 	mov	r3, r5
    b908:	eb00247c 	bl	14b00 <__aeabi_dmul>
    b90c:	e1a02000 	mov	r2, r0
    b910:	e1a03001 	mov	r3, r1
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
                +FC12*DR1*DR2+FC13*DRP*DT
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;

            LPOTA += (FC1111*(DR1S*DR1S+DR2S*DR2S)+FC3333*DTS*DTS+
    b914:	e1cd06d8 	ldrd	r0, [sp, #104]	; 0x68
    b918:	eb002374 	bl	146f0 <__adddf3>
                      FC1112*(DR1S+DR2S)*DR1*DR2+FC1122*DR1S*DR2S+
    b91c:	e59fe5fc 	ldr	lr, [pc, #1532]	; bf20 <POTENG+0xd70>
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
                +FC12*DR1*DR2+FC13*DRP*DT
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;

            LPOTA += (FC1111*(DR1S*DR1S+DR2S*DR2S)+FC3333*DTS*DTS+
    b920:	e1cd06f8 	strd	r0, [sp, #104]	; 0x68
                      FC1112*(DR1S+DR2S)*DR1*DR2+FC1122*DR1S*DR2S+
    b924:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    b928:	e1ce20d0 	ldrd	r2, [lr]
    b92c:	eb002473 	bl	14b00 <__aeabi_dmul>
    b930:	e1cd24d0 	ldrd	r2, [sp, #64]	; 0x40
    b934:	eb002471 	bl	14b00 <__aeabi_dmul>
    b938:	e1a02000 	mov	r2, r0
    b93c:	e1a03001 	mov	r3, r1
    b940:	e1cd06d8 	ldrd	r0, [sp, #104]	; 0x68
    b944:	eb002369 	bl	146f0 <__adddf3>
                      FC1113*(DR1S*DR1+DR2S*DR2)*DT+FC1123*DRP*DR1*DR2*DT+
    b948:	e59fe5d4 	ldr	lr, [pc, #1492]	; bf24 <POTENG+0xd74>
                +FC12*DR1*DR2+FC13*DRP*DT
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;

            LPOTA += (FC1111*(DR1S*DR1S+DR2S*DR2S)+FC3333*DTS*DTS+
                      FC1112*(DR1S+DR2S)*DR1*DR2+FC1122*DR1S*DR2S+
    b94c:	e1cd04f8 	strd	r0, [sp, #72]	; 0x48
                      FC1113*(DR1S*DR1+DR2S*DR2)*DT+FC1123*DRP*DR1*DR2*DT+
    b950:	e1ce20d0 	ldrd	r2, [lr]
    b954:	e1cd06d0 	ldrd	r0, [sp, #96]	; 0x60
    b958:	eb002468 	bl	14b00 <__aeabi_dmul>
    b95c:	e1a02008 	mov	r2, r8
    b960:	e1a03009 	mov	r3, r9
    b964:	eb002465 	bl	14b00 <__aeabi_dmul>
    b968:	e1a02000 	mov	r2, r0
    b96c:	e1a03001 	mov	r3, r1
                +FC12*DR1*DR2+FC13*DRP*DT
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;

            LPOTA += (FC1111*(DR1S*DR1S+DR2S*DR2S)+FC3333*DTS*DTS+
                      FC1112*(DR1S+DR2S)*DR1*DR2+FC1122*DR1S*DR2S+
    b970:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    b974:	eb00235d 	bl	146f0 <__adddf3>
                      FC1113*(DR1S*DR1+DR2S*DR2)*DT+FC1123*DRP*DR1*DR2*DT+
    b978:	e59fe5a8 	ldr	lr, [pc, #1448]	; bf28 <POTENG+0xd78>
                +FC12*DR1*DR2+FC13*DRP*DT
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;

            LPOTA += (FC1111*(DR1S*DR1S+DR2S*DR2S)+FC3333*DTS*DTS+
                      FC1112*(DR1S+DR2S)*DR1*DR2+FC1122*DR1S*DR2S+
    b97c:	e1cd04f8 	strd	r0, [sp, #72]	; 0x48
                      FC1113*(DR1S*DR1+DR2S*DR2)*DT+FC1123*DRP*DR1*DR2*DT+
    b980:	e1ce20d0 	ldrd	r2, [lr]
    b984:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    b988:	eb00245c 	bl	14b00 <__aeabi_dmul>
    b98c:	e1a02006 	mov	r2, r6
    b990:	e1a03007 	mov	r3, r7
    b994:	eb002459 	bl	14b00 <__aeabi_dmul>
    b998:	e1a02004 	mov	r2, r4
    b99c:	e1a03005 	mov	r3, r5
    b9a0:	eb002456 	bl	14b00 <__aeabi_dmul>
    b9a4:	e1a02008 	mov	r2, r8
    b9a8:	e1a03009 	mov	r3, r9
    b9ac:	eb002453 	bl	14b00 <__aeabi_dmul>
    b9b0:	e1a02000 	mov	r2, r0
    b9b4:	e1a03001 	mov	r3, r1
    b9b8:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    b9bc:	eb00234b 	bl	146f0 <__adddf3>
                      FC1133*(DR1S+DR2S)*DTS+FC1233*DR1*DR2*DTS+
    b9c0:	e59fe564 	ldr	lr, [pc, #1380]	; bf2c <POTENG+0xd7c>
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;

            LPOTA += (FC1111*(DR1S*DR1S+DR2S*DR2S)+FC3333*DTS*DTS+
                      FC1112*(DR1S+DR2S)*DR1*DR2+FC1122*DR1S*DR2S+
                      FC1113*(DR1S*DR1+DR2S*DR2)*DT+FC1123*DRP*DR1*DR2*DT+
    b9c4:	e1cd04f8 	strd	r0, [sp, #72]	; 0x48
                      FC1133*(DR1S+DR2S)*DTS+FC1233*DR1*DR2*DTS+
    b9c8:	e1ce20d0 	ldrd	r2, [lr]
    b9cc:	e1cd05d8 	ldrd	r0, [sp, #88]	; 0x58
    b9d0:	eb00244a 	bl	14b00 <__aeabi_dmul>
    b9d4:	e1a0200a 	mov	r2, sl
    b9d8:	e1a0300b 	mov	r3, fp
    b9dc:	eb002447 	bl	14b00 <__aeabi_dmul>
    b9e0:	e1a02000 	mov	r2, r0
    b9e4:	e1a03001 	mov	r3, r1
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;

            LPOTA += (FC1111*(DR1S*DR1S+DR2S*DR2S)+FC3333*DTS*DTS+
                      FC1112*(DR1S+DR2S)*DR1*DR2+FC1122*DR1S*DR2S+
                      FC1113*(DR1S*DR1+DR2S*DR2)*DT+FC1123*DRP*DR1*DR2*DT+
    b9e8:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    b9ec:	eb00233f 	bl	146f0 <__adddf3>
                      FC1133*(DR1S+DR2S)*DTS+FC1233*DR1*DR2*DTS+
    b9f0:	e59fe538 	ldr	lr, [pc, #1336]	; bf30 <POTENG+0xd80>
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;

            LPOTA += (FC1111*(DR1S*DR1S+DR2S*DR2S)+FC3333*DTS*DTS+
                      FC1112*(DR1S+DR2S)*DR1*DR2+FC1122*DR1S*DR2S+
                      FC1113*(DR1S*DR1+DR2S*DR2)*DT+FC1123*DRP*DR1*DR2*DT+
    b9f4:	e1cd04f8 	strd	r0, [sp, #72]	; 0x48
                      FC1133*(DR1S+DR2S)*DTS+FC1233*DR1*DR2*DTS+
    b9f8:	e1ce20d0 	ldrd	r2, [lr]
    b9fc:	e1a00006 	mov	r0, r6
    ba00:	e1a01007 	mov	r1, r7
    ba04:	eb00243d 	bl	14b00 <__aeabi_dmul>
    ba08:	e1a02004 	mov	r2, r4
    ba0c:	e1a03005 	mov	r3, r5
    ba10:	eb00243a 	bl	14b00 <__aeabi_dmul>
    ba14:	e1a0200a 	mov	r2, sl
    ba18:	e1a0300b 	mov	r3, fp
    ba1c:	eb002437 	bl	14b00 <__aeabi_dmul>
    ba20:	e1a02000 	mov	r2, r0
    ba24:	e1a03001 	mov	r3, r1
    ba28:	e1cd04d8 	ldrd	r0, [sp, #72]	; 0x48
    ba2c:	eb00232f 	bl	146f0 <__adddf3>
                      FC1333*DRP*DTS*DT)*ROHI2;
    ba30:	e59fe4fc 	ldr	lr, [pc, #1276]	; bf34 <POTENG+0xd84>
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;

            LPOTA += (FC1111*(DR1S*DR1S+DR2S*DR2S)+FC3333*DTS*DTS+
                      FC1112*(DR1S+DR2S)*DR1*DR2+FC1122*DR1S*DR2S+
                      FC1113*(DR1S*DR1+DR2S*DR2)*DT+FC1123*DRP*DR1*DR2*DT+
                      FC1133*(DR1S+DR2S)*DTS+FC1233*DR1*DR2*DTS+
    ba34:	e1a04000 	mov	r4, r0
    ba38:	e1a05001 	mov	r5, r1
                      FC1333*DRP*DTS*DT)*ROHI2;
    ba3c:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    ba40:	e1ce20d0 	ldrd	r2, [lr]
    ba44:	eb00242d 	bl	14b00 <__aeabi_dmul>
    ba48:	e1a0200a 	mov	r2, sl
    ba4c:	e1a0300b 	mov	r3, fp
    ba50:	eb00242a 	bl	14b00 <__aeabi_dmul>
    ba54:	e1a02008 	mov	r2, r8
    ba58:	e1a03009 	mov	r3, r9
    ba5c:	eb002427 	bl	14b00 <__aeabi_dmul>
    ba60:	e1a02000 	mov	r2, r0
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;

            LPOTA += (FC1111*(DR1S*DR1S+DR2S*DR2S)+FC3333*DTS*DTS+
                      FC1112*(DR1S+DR2S)*DR1*DR2+FC1122*DR1S*DR2S+
                      FC1113*(DR1S*DR1+DR2S*DR2)*DT+FC1123*DRP*DR1*DR2*DT+
                      FC1133*(DR1S+DR2S)*DTS+FC1233*DR1*DR2*DTS+
    ba64:	e1a00004 	mov	r0, r4
                      FC1333*DRP*DTS*DT)*ROHI2;
    ba68:	e59f44c8 	ldr	r4, [pc, #1224]	; bf38 <POTENG+0xd88>
    ba6c:	e1a03001 	mov	r3, r1
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;

            LPOTA += (FC1111*(DR1S*DR1S+DR2S*DR2S)+FC3333*DTS*DTS+
                      FC1112*(DR1S+DR2S)*DR1*DR2+FC1122*DR1S*DR2S+
                      FC1113*(DR1S*DR1+DR2S*DR2)*DT+FC1123*DRP*DR1*DR2*DT+
                      FC1133*(DR1S+DR2S)*DTS+FC1233*DR1*DR2*DTS+
    ba70:	e1a01005 	mov	r1, r5
    ba74:	eb00231d 	bl	146f0 <__adddf3>
                      FC1333*DRP*DTS*DT)*ROHI2;
    ba78:	e1c420d0 	ldrd	r2, [r4]
    ba7c:	eb00241f 	bl	14b00 <__aeabi_dmul>
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
                +FC12*DR1*DR2+FC13*DRP*DT
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;

            LPOTA += (FC1111*(DR1S*DR1S+DR2S*DR2S)+FC3333*DTS*DTS+
    ba80:	e1cd27d0 	ldrd	r2, [sp, #112]	; 0x70
    ba84:	eb002319 	bl	146f0 <__adddf3>
                      FC1112*(DR1S+DR2S)*DR1*DR2+FC1122*DR1S*DR2S+
                      FC1113*(DR1S*DR1+DR2S*DR2)*DT+FC1123*DRP*DR1*DR2*DT+
                      FC1133*(DR1S+DR2S)*DTS+FC1233*DR1*DR2*DTS+
                      FC1333*DRP*DTS*DT)*ROHI2;

            curr_ptr = curr_ptr->next_mol;
    ba88:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
            LPOTA += (FC11*(DR1S+DR2S)+FC33*DTS)*0.5
                +FC12*DR1*DR2+FC13*DRP*DT
                    +(FC111*(DR1S*DR1+DR2S*DR2)+FC333*DTS*DT+FC112*DRP*DR1*DR2+
                      FC113*(DR1S+DR2S)*DT+FC123*DR1*DR2*DT+FC133*DRP*DTS)*ROHI;

            LPOTA += (FC1111*(DR1S*DR1S+DR2S*DR2S)+FC3333*DTS*DTS+
    ba8c:	e1cd0bf0 	strd	r0, [sp, #176]	; 0xb0
                      FC1112*(DR1S+DR2S)*DR1*DR2+FC1122*DR1S*DR2S+
                      FC1113*(DR1S*DR1+DR2S*DR2)*DT+FC1123*DRP*DR1*DR2*DT+
                      FC1133*(DR1S+DR2S)*DTS+FC1233*DR1*DR2*DTS+
                      FC1333*DRP*DTS*DT)*ROHI2;

            curr_ptr = curr_ptr->next_mol;
    ba90:	e59cc2a0 	ldr	ip, [ip, #672]	; 0x2a0
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        /* Go through the molecules in a box */

        curr_ptr = BOX[i][j][k].list;
        while (curr_ptr) {
    ba94:	e35c0000 	cmp	ip, #0
    ba98:	1afffddf 	bne	b21c <POTENG+0x6c>
                      FC1133*(DR1S+DR2S)*DTS+FC1233*DR1*DR2*DTS+
                      FC1333*DRP*DTS*DT)*ROHI2;

            curr_ptr = curr_ptr->next_mol;
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    ba9c:	e59d5088 	ldr	r5, [sp, #136]	; 0x88
    baa0:	e595500c 	ldr	r5, [r5, #12]

    /*  compute intra-molecular potential energy */

    LPOTA=0.0;
    curr_box = my_boxes[ProcID];
    while (curr_box) {
    baa4:	e3550000 	cmp	r5, #0
                      FC1133*(DR1S+DR2S)*DTS+FC1233*DR1*DR2*DTS+
                      FC1333*DRP*DTS*DT)*ROHI2;

            curr_ptr = curr_ptr->next_mol;
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    baa8:	e58d5088 	str	r5, [sp, #136]	; 0x88

    /*  compute intra-molecular potential energy */

    LPOTA=0.0;
    curr_box = my_boxes[ProcID];
    while (curr_box) {
    baac:	1afffdd0 	bne	b1f4 <POTENG+0x44>
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    } /* while curr_box */


    BARRIER(gl->PotengBar, NumProcs);
    bab0:	e59f5544 	ldr	r5, [pc, #1348]	; bffc <POTENG+0xe4c>
    bab4:	e5950000 	ldr	r0, [r5]
    bab8:	e2800080 	add	r0, r0, #128	; 0x80
    babc:	ebffd34c 	bl	7f4 <pthread_mutex_lock>
    bac0:	e2501000 	subs	r1, r0, #0
    bac4:	1a0004a1 	bne	cd50 <POTENG+0x1ba0>
    bac8:	e59fc52c 	ldr	ip, [pc, #1324]	; bffc <POTENG+0xe4c>
    bacc:	e59c3000 	ldr	r3, [ip]
    bad0:	e59fc464 	ldr	ip, [pc, #1124]	; bf3c <POTENG+0xd8c>
    bad4:	e5932094 	ldr	r2, [r3, #148]	; 0x94
    bad8:	e59cc000 	ldr	ip, [ip]
    badc:	e2822001 	add	r2, r2, #1
    bae0:	e152000c 	cmp	r2, ip
    bae4:	e5832094 	str	r2, [r3, #148]	; 0x94
    bae8:	e5934098 	ldr	r4, [r3, #152]	; 0x98
    baec:	0a000490 	beq	cd34 <POTENG+0x1b84>
    baf0:	e28d1e25 	add	r1, sp, #592	; 0x250
    baf4:	ebffd63f 	bl	13f8 <pthread_setcancelstate>
    baf8:	e59fe4fc 	ldr	lr, [pc, #1276]	; bffc <POTENG+0xe4c>
    bafc:	e59e1000 	ldr	r1, [lr]
    bb00:	e5913098 	ldr	r3, [r1, #152]	; 0x98
    bb04:	e1530004 	cmp	r3, r4
    bb08:	1a000004 	bne	bb20 <POTENG+0x970>
    bb0c:	e281008c 	add	r0, r1, #140	; 0x8c
    bb10:	e2811080 	add	r1, r1, #128	; 0x80
    bb14:	ebffd6a5 	bl	15b0 <pthread_cond_wait>
    bb18:	e3500000 	cmp	r0, #0
    bb1c:	0afffff5 	beq	baf8 <POTENG+0x948>
    bb20:	e59d0250 	ldr	r0, [sp, #592]	; 0x250
    bb24:	e28d1fb2 	add	r1, sp, #712	; 0x2c8
    bb28:	ebffd632 	bl	13f8 <pthread_setcancelstate>
    bb2c:	e59f14c8 	ldr	r1, [pc, #1224]	; bffc <POTENG+0xe4c>
    bb30:	e5910000 	ldr	r0, [r1]
    bb34:	e2800080 	add	r0, r0, #128	; 0x80
    bb38:	ebffd607 	bl	135c <pthread_mutex_unlock>

    /*  compute inter-molecular potential energy */

    LPOTR=0.0;
    LPTRF=0.0;
    curr_box = my_boxes[ProcID];
    bb3c:	e59f238c 	ldr	r2, [pc, #908]	; bed0 <POTENG+0xd20>
    bb40:	e59d4078 	ldr	r4, [sp, #120]	; 0x78
    bb44:	e5923000 	ldr	r3, [r2]
    bb48:	e7933104 	ldr	r3, [r3, r4, lsl #2]
    while (curr_box) {
    bb4c:	e3530000 	cmp	r3, #0

    /*  compute inter-molecular potential energy */

    LPOTR=0.0;
    LPTRF=0.0;
    curr_box = my_boxes[ProcID];
    bb50:	e58d30a4 	str	r3, [sp, #164]	; 0xa4
    while (curr_box) {
    bb54:	0a000456 	beq	ccb4 <POTENG+0x1b04>
    BARRIER(gl->PotengBar, NumProcs);

    /*  compute inter-molecular potential energy */

    LPOTR=0.0;
    LPTRF=0.0;
    bb58:	e3a04000 	mov	r4, #0
    bb5c:	e3a05000 	mov	r5, #0
    bb60:	e1cd45f8 	strd	r4, [sp, #88]	; 0x58

    BARRIER(gl->PotengBar, NumProcs);

    /*  compute inter-molecular potential energy */

    LPOTR=0.0;
    bb64:	e1cd45f0 	strd	r4, [sp, #80]	; 0x50
    LPTRF=0.0;
    curr_box = my_boxes[ProcID];
    while (curr_box) {

        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
    bb68:	e59dc0a4 	ldr	ip, [sp, #164]	; 0xa4
    LPOTR=0.0;
    LPTRF=0.0;
    curr_box = my_boxes[ProcID];
    while (curr_box) {

        i = curr_box->coord[XDIR];  /* X coordinate of box */
    bb6c:	e59d50a4 	ldr	r5, [sp, #164]	; 0xa4
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
    bb70:	e59cc004 	ldr	ip, [ip, #4]
    LPOTR=0.0;
    LPTRF=0.0;
    curr_box = my_boxes[ProcID];
    while (curr_box) {

        i = curr_box->coord[XDIR];  /* X coordinate of box */
    bb74:	e5955000 	ldr	r5, [r5]
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
    bb78:	e58dc0ac 	str	ip, [sp, #172]	; 0xac
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */
    bb7c:	e59dc0a4 	ldr	ip, [sp, #164]	; 0xa4

        /* loop over nearest neighbor boxes */

        for (XBOX=i-1; XBOX<=i+1; XBOX++) {
    bb80:	e2454001 	sub	r4, r5, #1
    LPOTR=0.0;
    LPTRF=0.0;
    curr_box = my_boxes[ProcID];
    while (curr_box) {

        i = curr_box->coord[XDIR];  /* X coordinate of box */
    bb84:	e58d50a8 	str	r5, [sp, #168]	; 0xa8
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */
    bb88:	e59cc008 	ldr	ip, [ip, #8]

        /* loop over nearest neighbor boxes */

        for (XBOX=i-1; XBOX<=i+1; XBOX++) {
    bb8c:	e2855001 	add	r5, r5, #1
    bb90:	e1540005 	cmp	r4, r5
    bb94:	e58d409c 	str	r4, [sp, #156]	; 0x9c
    bb98:	e58d50c0 	str	r5, [sp, #192]	; 0xc0
    curr_box = my_boxes[ProcID];
    while (curr_box) {

        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */
    bb9c:	e58dc0b8 	str	ip, [sp, #184]	; 0xb8

        /* loop over nearest neighbor boxes */

        for (XBOX=i-1; XBOX<=i+1; XBOX++) {
    bba0:	ca000424 	bgt	cc38 <POTENG+0x1a88>
    bba4:	e59d40ac 	ldr	r4, [sp, #172]	; 0xac
    bba8:	e59d50ac 	ldr	r5, [sp, #172]	; 0xac
    bbac:	e2444001 	sub	r4, r4, #1
    bbb0:	e58d40c4 	str	r4, [sp, #196]	; 0xc4
    bbb4:	e59d40b8 	ldr	r4, [sp, #184]	; 0xb8
    bbb8:	e2855001 	add	r5, r5, #1
    bbbc:	e24cc001 	sub	ip, ip, #1
    bbc0:	e2844001 	add	r4, r4, #1
    bbc4:	e58d50c8 	str	r5, [sp, #200]	; 0xc8
    bbc8:	e58dc0cc 	str	ip, [sp, #204]	; 0xcc
    bbcc:	e58d40bc 	str	r4, [sp, #188]	; 0xbc
    bbd0:	e59d50a8 	ldr	r5, [sp, #168]	; 0xa8
    bbd4:	e59dc0ac 	ldr	ip, [sp, #172]	; 0xac
    bbd8:	e59d40b8 	ldr	r4, [sp, #184]	; 0xb8
    bbdc:	e1a05105 	lsl	r5, r5, #2
    bbe0:	e1a0c10c 	lsl	ip, ip, #2
    bbe4:	e1a04204 	lsl	r4, r4, #4
    bbe8:	e58d508c 	str	r5, [sp, #140]	; 0x8c
    bbec:	e58dc090 	str	ip, [sp, #144]	; 0x90
    bbf0:	e58d4094 	str	r4, [sp, #148]	; 0x94
            for (YBOX=j-1; YBOX<=j+1; YBOX++) {
    bbf4:	e59d50c4 	ldr	r5, [sp, #196]	; 0xc4
    bbf8:	e59dc0c8 	ldr	ip, [sp, #200]	; 0xc8
    bbfc:	e155000c 	cmp	r5, ip
    bc00:	ca000406 	bgt	cc20 <POTENG+0x1a70>

                    X_NUM = XBOX;
                    Y_NUM = YBOX;
                    Z_NUM = ZBOX;

                    if ((BOX_PER_SIDE == 2) && ((XBOX < 0) || (XBOX == 2) ||
    bc04:	e59d409c 	ldr	r4, [sp, #156]	; 0x9c
    bc08:	e58d50a0 	str	r5, [sp, #160]	; 0xa0
    bc0c:	e1a03fa4 	lsr	r3, r4, #31
    bc10:	e3540002 	cmp	r4, #2
    bc14:	03833001 	orreq	r3, r3, #1
    bc18:	e58d30dc 	str	r3, [sp, #220]	; 0xdc

        /* loop over nearest neighbor boxes */

        for (XBOX=i-1; XBOX<=i+1; XBOX++) {
            for (YBOX=j-1; YBOX<=j+1; YBOX++) {
                for (ZBOX=k-1; ZBOX<=k+1; ZBOX++) {
    bc1c:	e59d50cc 	ldr	r5, [sp, #204]	; 0xcc
    bc20:	e59dc0bc 	ldr	ip, [sp, #188]	; 0xbc
    bc24:	e155000c 	cmp	r5, ip
    bc28:	ca0003f6 	bgt	cc08 <POTENG+0x1a58>
                    X_NUM = XBOX;
                    Y_NUM = YBOX;
                    Z_NUM = ZBOX;

                    if ((BOX_PER_SIDE == 2) && ((XBOX < 0) || (XBOX == 2) ||
                                                (YBOX < 0) || (YBOX == 2) ||
    bc2c:	e59d40a0 	ldr	r4, [sp, #160]	; 0xa0
                        Z_NUM -= BOX_PER_SIDE;


                    /* Don't do current box more than once */
                    if ((X_NUM == i) && (Y_NUM == j) && (Z_NUM == k) &&
                        ((XBOX != i) || (YBOX != j) || (ZBOX !=k))) {
    bc30:	e59d50ac 	ldr	r5, [sp, #172]	; 0xac
    bc34:	e59dc09c 	ldr	ip, [sp, #156]	; 0x9c
    bc38:	e59de0a8 	ldr	lr, [sp, #168]	; 0xa8
                    X_NUM = XBOX;
                    Y_NUM = YBOX;
                    Z_NUM = ZBOX;

                    if ((BOX_PER_SIDE == 2) && ((XBOX < 0) || (XBOX == 2) ||
                                                (YBOX < 0) || (YBOX == 2) ||
    bc3c:	e1a03fa4 	lsr	r3, r4, #31
    bc40:	e3540002 	cmp	r4, #2
    bc44:	03833001 	orreq	r3, r3, #1
                        Z_NUM -= BOX_PER_SIDE;


                    /* Don't do current box more than once */
                    if ((X_NUM == i) && (Y_NUM == j) && (Z_NUM == k) &&
                        ((XBOX != i) || (YBOX != j) || (ZBOX !=k))) {
    bc48:	e15c000e 	cmp	ip, lr
    bc4c:	01540005 	cmpeq	r4, r5
    bc50:	13a05001 	movne	r5, #1
    bc54:	03a05000 	moveq	r5, #0
    bc58:	e59d40cc 	ldr	r4, [sp, #204]	; 0xcc
                                for (K = 0; K < 9; K++) {
                                    if (RS[K] <= CUT2) {
                                        RL[K]=sqrt(RS[K]);
                                    }
                                    else {
                                        RL[K]=CUTOFF;
    bc5c:	e59fa2dc 	ldr	sl, [pc, #732]	; bf40 <POTENG+0xd90>
                    X_NUM = XBOX;
                    Y_NUM = YBOX;
                    Z_NUM = ZBOX;

                    if ((BOX_PER_SIDE == 2) && ((XBOX < 0) || (XBOX == 2) ||
                                                (YBOX < 0) || (YBOX == 2) ||
    bc60:	e58d30e0 	str	r3, [sp, #224]	; 0xe0
                        Z_NUM -= BOX_PER_SIDE;


                    /* Don't do current box more than once */
                    if ((X_NUM == i) && (Y_NUM == j) && (Z_NUM == k) &&
                        ((XBOX != i) || (YBOX != j) || (ZBOX !=k))) {
    bc64:	e58d50e4 	str	r5, [sp, #228]	; 0xe4
    bc68:	e58d4098 	str	r4, [sp, #152]	; 0x98

                    X_NUM = XBOX;
                    Y_NUM = YBOX;
                    Z_NUM = ZBOX;

                    if ((BOX_PER_SIDE == 2) && ((XBOX < 0) || (XBOX == 2) ||
    bc6c:	e59f52d0 	ldr	r5, [pc, #720]	; bf44 <POTENG+0xd94>
    bc70:	e5953000 	ldr	r3, [r5]
    bc74:	e3530002 	cmp	r3, #2
    bc78:	0a000400 	beq	cc80 <POTENG+0x1ad0>
                                                (ZBOX < 0) || (ZBOX == 2)))
                        continue;

                    /* Make box number valid if out of box */

                    if (X_NUM == -1)
    bc7c:	e59dc09c 	ldr	ip, [sp, #156]	; 0x9c
    bc80:	e37c0001 	cmn	ip, #1
                        X_NUM += BOX_PER_SIDE;
    bc84:	02430001 	subeq	r0, r3, #1
                                                (ZBOX < 0) || (ZBOX == 2)))
                        continue;

                    /* Make box number valid if out of box */

                    if (X_NUM == -1)
    bc88:	0a000003 	beq	bc9c <POTENG+0xaec>
                        X_NUM += BOX_PER_SIDE;
                    else if (X_NUM >= BOX_PER_SIDE)
    bc8c:	e59d409c 	ldr	r4, [sp, #156]	; 0x9c
    bc90:	e1530004 	cmp	r3, r4
    bc94:	c1a00004 	movgt	r0, r4
                        X_NUM -= BOX_PER_SIDE;
    bc98:	d0630004 	rsble	r0, r3, r4
                    if (Y_NUM == -1)
    bc9c:	e59d50a0 	ldr	r5, [sp, #160]	; 0xa0
    bca0:	e3750001 	cmn	r5, #1
                        Y_NUM += BOX_PER_SIDE;
    bca4:	02431001 	subeq	r1, r3, #1

                    if (X_NUM == -1)
                        X_NUM += BOX_PER_SIDE;
                    else if (X_NUM >= BOX_PER_SIDE)
                        X_NUM -= BOX_PER_SIDE;
                    if (Y_NUM == -1)
    bca8:	0a000002 	beq	bcb8 <POTENG+0xb08>
                        Y_NUM += BOX_PER_SIDE;
                    else if (Y_NUM >= BOX_PER_SIDE)
    bcac:	e1530005 	cmp	r3, r5
    bcb0:	c1a01005 	movgt	r1, r5
                        Y_NUM -= BOX_PER_SIDE;
    bcb4:	d0631005 	rsble	r1, r3, r5
                    if (Z_NUM == -1)
    bcb8:	e59d4098 	ldr	r4, [sp, #152]	; 0x98
    bcbc:	e3740001 	cmn	r4, #1
                        Z_NUM += BOX_PER_SIDE;
    bcc0:	02432001 	subeq	r2, r3, #1
                        X_NUM -= BOX_PER_SIDE;
                    if (Y_NUM == -1)
                        Y_NUM += BOX_PER_SIDE;
                    else if (Y_NUM >= BOX_PER_SIDE)
                        Y_NUM -= BOX_PER_SIDE;
                    if (Z_NUM == -1)
    bcc4:	0a000002 	beq	bcd4 <POTENG+0xb24>
                        Z_NUM += BOX_PER_SIDE;
                    else if (Z_NUM >= BOX_PER_SIDE)
    bcc8:	e1530004 	cmp	r3, r4
    bccc:	c1a02004 	movgt	r2, r4
                        Z_NUM -= BOX_PER_SIDE;
    bcd0:	d0632004 	rsble	r2, r3, r4


                    /* Don't do current box more than once */
                    if ((X_NUM == i) && (Y_NUM == j) && (Z_NUM == k) &&
    bcd4:	e59dc0a8 	ldr	ip, [sp, #168]	; 0xa8
    bcd8:	e59d40ac 	ldr	r4, [sp, #172]	; 0xac
    bcdc:	e150000c 	cmp	r0, ip
    bce0:	01510004 	cmpeq	r1, r4
    bce4:	1a000002 	bne	bcf4 <POTENG+0xb44>
    bce8:	e59d50b8 	ldr	r5, [sp, #184]	; 0xb8
    bcec:	e1520005 	cmp	r2, r5
    bcf0:	0a0003b8 	beq	cbd8 <POTENG+0x1a28>
                        ((XBOX != i) || (YBOX != j) || (ZBOX !=k))) {
                        continue;
                    }

                    neighbor_ptr = BOX[X_NUM][Y_NUM][Z_NUM].list;
    bcf4:	e59f51d8 	ldr	r5, [pc, #472]	; bed4 <POTENG+0xd24>
    bcf8:	e5953000 	ldr	r3, [r5]
    bcfc:	e7930100 	ldr	r0, [r3, r0, lsl #2]
    bd00:	e7901101 	ldr	r1, [r0, r1, lsl #2]
    bd04:	e7911202 	ldr	r1, [r1, r2, lsl #4]
                    while (neighbor_ptr) {
    bd08:	e3510000 	cmp	r1, #0
                    if ((X_NUM == i) && (Y_NUM == j) && (Z_NUM == k) &&
                        ((XBOX != i) || (YBOX != j) || (ZBOX !=k))) {
                        continue;
                    }

                    neighbor_ptr = BOX[X_NUM][Y_NUM][Z_NUM].list;
    bd0c:	e58d1048 	str	r1, [sp, #72]	; 0x48
                    while (neighbor_ptr) {
    bd10:	0a0003b6 	beq	cbf0 <POTENG+0x1a40>
                        /* go through current box list */
                        curr_ptr = BOX[i][j][k].list;
    bd14:	e59dc08c 	ldr	ip, [sp, #140]	; 0x8c
    bd18:	e59d4090 	ldr	r4, [sp, #144]	; 0x90
    bd1c:	e793300c 	ldr	r3, [r3, ip]
    bd20:	e59d5094 	ldr	r5, [sp, #148]	; 0x94
    bd24:	e7933004 	ldr	r3, [r3, r4]
    bd28:	e7939005 	ldr	r9, [r3, r5]
                        while (curr_ptr) {
    bd2c:	e3590000 	cmp	r9, #0
    bd30:	0a0002d2 	beq	c880 <POTENG+0x16d0>
    bd34:	e58d9088 	str	r9, [sp, #136]	; 0x88

                            /* Don't do interaction with same molecule */

                            if (curr_ptr == neighbor_ptr) {
    bd38:	e59dc088 	ldr	ip, [sp, #136]	; 0x88
    bd3c:	e59d4048 	ldr	r4, [sp, #72]	; 0x48
    bd40:	e15c0004 	cmp	ip, r4
    bd44:	0a0003a0 	beq	cbcc <POTENG+0x1a1c>
    bd48:	e1a0700c 	mov	r7, ip
    bd4c:	e1a06004 	mov	r6, r4
                                curr_ptr = curr_ptr->next_mol;
                                continue;
                            }

                            /*  compute some intermolecular distances */
                            CSHIFT(curr_ptr->mol.F[DISP][XDIR],neighbor_ptr->mol.F[DISP][XDIR],
    bd50:	e0c723d0 	ldrd	r2, [r7], #48	; 0x30
    bd54:	e59f51ec 	ldr	r5, [pc, #492]	; bf48 <POTENG+0xd98>
    bd58:	e59fc1ec 	ldr	ip, [pc, #492]	; bf4c <POTENG+0xd9c>
    bd5c:	e1c540d0 	ldrd	r4, [r5]
    bd60:	e1cd43f8 	strd	r4, [sp, #56]	; 0x38
    bd64:	e1cc80d0 	ldrd	r8, [ip]
    bd68:	e0c643d0 	ldrd	r4, [r6], #48	; 0x30
    bd6c:	e59dc088 	ldr	ip, [sp, #136]	; 0x88
    bd70:	e1cd40f0 	strd	r4, [sp]
    bd74:	e1cd43d8 	ldrd	r4, [sp, #56]	; 0x38
    bd78:	e1cd41f8 	strd	r4, [sp, #24]
    bd7c:	e59d5048 	ldr	r5, [sp, #72]	; 0x48
    bd80:	e28de0e8 	add	lr, sp, #232	; 0xe8
    bd84:	e28c0018 	add	r0, ip, #24
    bd88:	e2851018 	add	r1, r5, #24
    bd8c:	e58de008 	str	lr, [sp, #8]
    bd90:	e1cd81f0 	strd	r8, [sp, #16]
    bd94:	ebffe237 	bl	4678 <CSHIFT>
                                   curr_ptr->mol.VM[XDIR],neighbor_ptr->mol.VM[XDIR],XL,BOXH,BOXL);
                            CSHIFT(curr_ptr->mol.F[DISP][YDIR],neighbor_ptr->mol.F[DISP][YDIR],
    bd98:	e59dc088 	ldr	ip, [sp, #136]	; 0x88
    bd9c:	e59f11a4 	ldr	r1, [pc, #420]	; bf48 <POTENG+0xd98>
    bda0:	e59fe1a4 	ldr	lr, [pc, #420]	; bf4c <POTENG+0xd9c>
    bda4:	e59d5048 	ldr	r5, [sp, #72]	; 0x48
    bda8:	e1c100d0 	ldrd	r0, [r1]
    bdac:	e1cc20d8 	ldrd	r2, [ip, #8]
    bdb0:	e1cd03f0 	strd	r0, [sp, #48]	; 0x30
    bdb4:	e1ce80d0 	ldrd	r8, [lr]
    bdb8:	e1c540d8 	ldrd	r4, [r5, #8]
    bdbc:	e28dce16 	add	ip, sp, #352	; 0x160
    bdc0:	e1a00007 	mov	r0, r7
    bdc4:	e1a01006 	mov	r1, r6
    bdc8:	e58dc008 	str	ip, [sp, #8]
    bdcc:	e1cd40f0 	strd	r4, [sp]
    bdd0:	e1cd43d0 	ldrd	r4, [sp, #48]	; 0x30
    bdd4:	e1cd81f0 	strd	r8, [sp, #16]
    bdd8:	e1cd41f8 	strd	r4, [sp, #24]
    bddc:	ebffe225 	bl	4678 <CSHIFT>
                                   curr_ptr->mol.VM[YDIR],neighbor_ptr->mol.VM[YDIR],YL,BOXH,BOXL);
                            CSHIFT(curr_ptr->mol.F[DISP][ZDIR],neighbor_ptr->mol.F[DISP][ZDIR],
    bde0:	e59dc048 	ldr	ip, [sp, #72]	; 0x48
    bde4:	e59d5088 	ldr	r5, [sp, #136]	; 0x88
    bde8:	e1cc01d0 	ldrd	r0, [ip, #16]
    bdec:	e59fe158 	ldr	lr, [pc, #344]	; bf4c <POTENG+0xd9c>
    bdf0:	e59fc150 	ldr	ip, [pc, #336]	; bf48 <POTENG+0xd98>
    bdf4:	e1c521d0 	ldrd	r2, [r5, #16]
    bdf8:	e1cc60d0 	ldrd	r6, [ip]
    bdfc:	e1ce40d0 	ldrd	r4, [lr]
    be00:	e1cd41f0 	strd	r4, [sp, #16]
    be04:	e59d4088 	ldr	r4, [sp, #136]	; 0x88
    be08:	e59d5048 	ldr	r5, [sp, #72]	; 0x48
    be0c:	e28def76 	add	lr, sp, #472	; 0x1d8
    be10:	e1cd00f0 	strd	r0, [sp]
    be14:	e58de008 	str	lr, [sp, #8]
    be18:	e2840048 	add	r0, r4, #72	; 0x48
    be1c:	e2851048 	add	r1, r5, #72	; 0x48
    be20:	e1cd61f8 	strd	r6, [sp, #24]
    be24:	ebffe213 	bl	4678 <CSHIFT>
    be28:	e59fc18c 	ldr	ip, [pc, #396]	; bfbc <POTENG+0xe0c>
                                   curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);


                            KC=0;
                            for (K = 0; K < 9; K++) {
                                RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    be2c:	e59f211c 	ldr	r2, [pc, #284]	; bf50 <POTENG+0xda0>
    be30:	e59f311c 	ldr	r3, [pc, #284]	; bf54 <POTENG+0xda4>
    be34:	e1cc80d0 	ldrd	r8, [ip]
    be38:	e28ded0d 	add	lr, sp, #832	; 0x340
    be3c:	e59fc114 	ldr	ip, [pc, #276]	; bf58 <POTENG+0xda8>
    be40:	e18e60d3 	ldrd	r6, [lr, r3]
    be44:	e18e00d2 	ldrd	r0, [lr, r2]
    be48:	e1a02000 	mov	r2, r0
    be4c:	e18e40dc 	ldrd	r4, [lr, ip]
    be50:	e1a03001 	mov	r3, r1
    be54:	e1cd44f0 	strd	r4, [sp, #64]	; 0x40
    be58:	eb002328 	bl	14b00 <__aeabi_dmul>
    be5c:	e1a02006 	mov	r2, r6
    be60:	e1a04000 	mov	r4, r0
    be64:	e1a05001 	mov	r5, r1
    be68:	e1a03007 	mov	r3, r7
    be6c:	e1a00006 	mov	r0, r6
    be70:	e1a01007 	mov	r1, r7
    be74:	eb002321 	bl	14b00 <__aeabi_dmul>
    be78:	e1a02000 	mov	r2, r0
    be7c:	e1a03001 	mov	r3, r1
    be80:	e1a00004 	mov	r0, r4
    be84:	e1a01005 	mov	r1, r5
    be88:	eb002218 	bl	146f0 <__adddf3>
    be8c:	e1a04000 	mov	r4, r0
    be90:	e1a05001 	mov	r5, r1
    be94:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    be98:	e1a02000 	mov	r2, r0
    be9c:	e1a03001 	mov	r3, r1
    bea0:	eb002316 	bl	14b00 <__aeabi_dmul>
    bea4:	e1a02000 	mov	r2, r0
    bea8:	e1a03001 	mov	r3, r1
    beac:	e1a00004 	mov	r0, r4
    beb0:	e1a01005 	mov	r1, r5
    beb4:	eb00220d 	bl	146f0 <__adddf3>
    beb8:	e28dcc02 	add	ip, sp, #512	; 0x200
    bebc:	e1cc05f0 	strd	r0, [ip, #80]	; 0x50
    bec0:	e1a02008 	mov	r2, r8
    bec4:	e1a03009 	mov	r3, r9
    bec8:	eb00247e 	bl	150c8 <__aeabi_dcmpgt>
    becc:	ea00004c 	b	c004 <POTENG+0xe54>
    bed0:	0013efcc 	.word	0x0013efcc
    bed4:	0013f098 	.word	0x0013f098
    bed8:	0013ea48 	.word	0x0013ea48
    bedc:	0013efa0 	.word	0x0013efa0
    bee0:	0013f3f8 	.word	0x0013f3f8
    bee4:	0013eee8 	.word	0x0013eee8
    bee8:	0013ef60 	.word	0x0013ef60
    beec:	0013efd0 	.word	0x0013efd0
    bef0:	0013ef98 	.word	0x0013ef98
    bef4:	0013ea68 	.word	0x0013ea68
    bef8:	0013f518 	.word	0x0013f518
    befc:	0013eeb0 	.word	0x0013eeb0
    bf00:	0013f4e8 	.word	0x0013f4e8
    bf04:	0013eea0 	.word	0x0013eea0
    bf08:	0013ee98 	.word	0x0013ee98
    bf0c:	0013f408 	.word	0x0013f408
    bf10:	0013ea80 	.word	0x0013ea80
    bf14:	0013eff8 	.word	0x0013eff8
    bf18:	0013eea8 	.word	0x0013eea8
    bf1c:	0013f420 	.word	0x0013f420
    bf20:	0013f548 	.word	0x0013f548
    bf24:	0013ef80 	.word	0x0013ef80
    bf28:	0013f090 	.word	0x0013f090
    bf2c:	0013ef88 	.word	0x0013ef88
    bf30:	0013eeb8 	.word	0x0013eeb8
    bf34:	0013f440 	.word	0x0013f440
    bf38:	0013ea30 	.word	0x0013ea30
    bf3c:	0013eec0 	.word	0x0013eec0
    bf40:	0013f530 	.word	0x0013f530
    bf44:	0013ea50 	.word	0x0013ea50
    bf48:	0013ea58 	.word	0x0013ea58
    bf4c:	0013efe0 	.word	0x0013efe0
    bf50:	fffffda8 	.word	0xfffffda8
    bf54:	fffffe20 	.word	0xfffffe20
    bf58:	fffffe98 	.word	0xfffffe98
    bf5c:	fffffdb0 	.word	0xfffffdb0
    bf60:	fffffea0 	.word	0xfffffea0
    bf64:	fffffe28 	.word	0xfffffe28
    bf68:	fffffdb8 	.word	0xfffffdb8
    bf6c:	fffffea8 	.word	0xfffffea8
    bf70:	fffffe30 	.word	0xfffffe30
    bf74:	fffffdc0 	.word	0xfffffdc0
    bf78:	fffffeb0 	.word	0xfffffeb0
    bf7c:	fffffe38 	.word	0xfffffe38
    bf80:	fffffdc8 	.word	0xfffffdc8
    bf84:	fffffeb8 	.word	0xfffffeb8
    bf88:	fffffe40 	.word	0xfffffe40
    bf8c:	fffffdd0 	.word	0xfffffdd0
    bf90:	fffffec0 	.word	0xfffffec0
    bf94:	fffffe48 	.word	0xfffffe48
    bf98:	fffffdd8 	.word	0xfffffdd8
    bf9c:	fffffec8 	.word	0xfffffec8
    bfa0:	fffffe50 	.word	0xfffffe50
    bfa4:	fffffde0 	.word	0xfffffde0
    bfa8:	fffffed0 	.word	0xfffffed0
    bfac:	fffffe58 	.word	0xfffffe58
    bfb0:	fffffde8 	.word	0xfffffde8
    bfb4:	fffffed8 	.word	0xfffffed8
    bfb8:	fffffe60 	.word	0xfffffe60
    bfbc:	0013efb0 	.word	0x0013efb0
    bfc0:	0013eee0 	.word	0x0013eee0
    bfc4:	0013f448 	.word	0x0013f448
    bfc8:	0013f538 	.word	0x0013f538
    bfcc:	0013f010 	.word	0x0013f010
    bfd0:	0013f520 	.word	0x0013f520
    bfd4:	0013f098 	.word	0x0013f098
    bfd8:	0013f4f8 	.word	0x0013f4f8
    bfdc:	0013f540 	.word	0x0013f540
    bfe0:	0013f0a0 	.word	0x0013f0a0
    bfe4:	0013f3e0 	.word	0x0013f3e0
    bfe8:	0013f560 	.word	0x0013f560
    bfec:	0013eec8 	.word	0x0013eec8
    bff0:	0013f430 	.word	0x0013f430
    bff4:	0013f088 	.word	0x0013f088
    bff8:	3fe00000 	.word	0x3fe00000
    bffc:	0013f3f0 	.word	0x0013f3f0
    c000:	0003285c 	.word	0x0003285c
    c004:	e51f30b0 	ldr	r3, [pc, #-176]	; bf5c <POTENG+0xdac>
    c008:	e28ded0d 	add	lr, sp, #832	; 0x340
    c00c:	e290b000 	adds	fp, r0, #0
    c010:	e51fc0b8 	ldr	ip, [pc, #-184]	; bf60 <POTENG+0xdb0>
    c014:	e18e00d3 	ldrd	r0, [lr, r3]
    c018:	e51fe0bc 	ldr	lr, [pc, #-188]	; bf64 <POTENG+0xdb4>
    c01c:	e1a02000 	mov	r2, r0
    c020:	e1a03001 	mov	r3, r1
    c024:	e28d4d0d 	add	r4, sp, #832	; 0x340
    c028:	13a0b001 	movne	fp, #1
    c02c:	e18460de 	ldrd	r6, [r4, lr]
    c030:	e18440dc 	ldrd	r4, [r4, ip]
    c034:	e1cd44f0 	strd	r4, [sp, #64]	; 0x40
    c038:	eb0022b0 	bl	14b00 <__aeabi_dmul>
    c03c:	e1a02006 	mov	r2, r6
    c040:	e1a04000 	mov	r4, r0
    c044:	e1a05001 	mov	r5, r1
    c048:	e1a03007 	mov	r3, r7
    c04c:	e1a00006 	mov	r0, r6
    c050:	e1a01007 	mov	r1, r7
    c054:	eb0022a9 	bl	14b00 <__aeabi_dmul>
    c058:	e1a02000 	mov	r2, r0
    c05c:	e1a03001 	mov	r3, r1
    c060:	e1a00004 	mov	r0, r4
    c064:	e1a01005 	mov	r1, r5
    c068:	eb0021a0 	bl	146f0 <__adddf3>
    c06c:	e1a04000 	mov	r4, r0
    c070:	e1a05001 	mov	r5, r1
    c074:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    c078:	e1a02000 	mov	r2, r0
    c07c:	e1a03001 	mov	r3, r1
    c080:	eb00229e 	bl	14b00 <__aeabi_dmul>
    c084:	e1a02000 	mov	r2, r0
    c088:	e1a03001 	mov	r3, r1
    c08c:	e1a00004 	mov	r0, r4
    c090:	e1a01005 	mov	r1, r5
    c094:	eb002195 	bl	146f0 <__adddf3>
    c098:	e1a04000 	mov	r4, r0
    c09c:	e1a05001 	mov	r5, r1
    c0a0:	e28dcc02 	add	ip, sp, #512	; 0x200
    c0a4:	e1cc45f8 	strd	r4, [ip, #88]	; 0x58
    c0a8:	e1a02004 	mov	r2, r4
    c0ac:	e1a03005 	mov	r3, r5
    c0b0:	e1a01009 	mov	r1, r9
    c0b4:	e1a00008 	mov	r0, r8
    c0b8:	eb0023f0 	bl	15080 <__aeabi_dcmplt>
    c0bc:	e51f315c 	ldr	r3, [pc, #-348]	; bf68 <POTENG+0xdb8>
    c0c0:	e28ded0d 	add	lr, sp, #832	; 0x340
                                if (RS[K] > CUT2)
                                    KC++;
    c0c4:	e28b2001 	add	r2, fp, #1
    c0c8:	e3500000 	cmp	r0, #0
                                   curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);


                            KC=0;
                            for (K = 0; K < 9; K++) {
                                RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    c0cc:	e51fc168 	ldr	ip, [pc, #-360]	; bf6c <POTENG+0xdbc>
    c0d0:	e18e00d3 	ldrd	r0, [lr, r3]
    c0d4:	e51fe16c 	ldr	lr, [pc, #-364]	; bf70 <POTENG+0xdc0>
    c0d8:	11a0b002 	movne	fp, r2
    c0dc:	e1a03001 	mov	r3, r1
    c0e0:	e1a02000 	mov	r2, r0
    c0e4:	e28d4d0d 	add	r4, sp, #832	; 0x340
    c0e8:	e18460de 	ldrd	r6, [r4, lr]
    c0ec:	e18440dc 	ldrd	r4, [r4, ip]
    c0f0:	e1cd44f0 	strd	r4, [sp, #64]	; 0x40
    c0f4:	eb002281 	bl	14b00 <__aeabi_dmul>
    c0f8:	e1a02006 	mov	r2, r6
    c0fc:	e1a04000 	mov	r4, r0
    c100:	e1a05001 	mov	r5, r1
    c104:	e1a03007 	mov	r3, r7
    c108:	e1a00006 	mov	r0, r6
    c10c:	e1a01007 	mov	r1, r7
    c110:	eb00227a 	bl	14b00 <__aeabi_dmul>
    c114:	e1a02000 	mov	r2, r0
    c118:	e1a03001 	mov	r3, r1
    c11c:	e1a00004 	mov	r0, r4
    c120:	e1a01005 	mov	r1, r5
    c124:	eb002171 	bl	146f0 <__adddf3>
    c128:	e1a04000 	mov	r4, r0
    c12c:	e1a05001 	mov	r5, r1
    c130:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    c134:	e1a02000 	mov	r2, r0
    c138:	e1a03001 	mov	r3, r1
    c13c:	eb00226f 	bl	14b00 <__aeabi_dmul>
    c140:	e1a02000 	mov	r2, r0
    c144:	e1a03001 	mov	r3, r1
    c148:	e1a00004 	mov	r0, r4
    c14c:	e1a01005 	mov	r1, r5
    c150:	eb002166 	bl	146f0 <__adddf3>
    c154:	e28dcc02 	add	ip, sp, #512	; 0x200
    c158:	e1cc06f0 	strd	r0, [ip, #96]	; 0x60
    c15c:	e1a02008 	mov	r2, r8
    c160:	e1a03009 	mov	r3, r9
    c164:	eb0023d7 	bl	150c8 <__aeabi_dcmpgt>
    c168:	e51f31fc 	ldr	r3, [pc, #-508]	; bf74 <POTENG+0xdc4>
    c16c:	e28ded0d 	add	lr, sp, #832	; 0x340
    c170:	e3500000 	cmp	r0, #0
                                if (RS[K] > CUT2)
                                    KC++;
    c174:	e28b2001 	add	r2, fp, #1
                                   curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);


                            KC=0;
                            for (K = 0; K < 9; K++) {
                                RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    c178:	e51fc208 	ldr	ip, [pc, #-520]	; bf78 <POTENG+0xdc8>
    c17c:	e18e00d3 	ldrd	r0, [lr, r3]
    c180:	e51fe20c 	ldr	lr, [pc, #-524]	; bf7c <POTENG+0xdcc>
    c184:	11a0b002 	movne	fp, r2
    c188:	e1a03001 	mov	r3, r1
    c18c:	e1a02000 	mov	r2, r0
    c190:	e28d4d0d 	add	r4, sp, #832	; 0x340
    c194:	e18460de 	ldrd	r6, [r4, lr]
    c198:	e18440dc 	ldrd	r4, [r4, ip]
    c19c:	e1cd44f0 	strd	r4, [sp, #64]	; 0x40
    c1a0:	eb002256 	bl	14b00 <__aeabi_dmul>
    c1a4:	e1a02006 	mov	r2, r6
    c1a8:	e1a04000 	mov	r4, r0
    c1ac:	e1a05001 	mov	r5, r1
    c1b0:	e1a03007 	mov	r3, r7
    c1b4:	e1a00006 	mov	r0, r6
    c1b8:	e1a01007 	mov	r1, r7
    c1bc:	eb00224f 	bl	14b00 <__aeabi_dmul>
    c1c0:	e1a02000 	mov	r2, r0
    c1c4:	e1a03001 	mov	r3, r1
    c1c8:	e1a00004 	mov	r0, r4
    c1cc:	e1a01005 	mov	r1, r5
    c1d0:	eb002146 	bl	146f0 <__adddf3>
    c1d4:	e1a04000 	mov	r4, r0
    c1d8:	e1a05001 	mov	r5, r1
    c1dc:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    c1e0:	e1a02000 	mov	r2, r0
    c1e4:	e1a03001 	mov	r3, r1
    c1e8:	eb002244 	bl	14b00 <__aeabi_dmul>
    c1ec:	e1a02000 	mov	r2, r0
    c1f0:	e1a03001 	mov	r3, r1
    c1f4:	e1a00004 	mov	r0, r4
    c1f8:	e1a01005 	mov	r1, r5
    c1fc:	eb00213b 	bl	146f0 <__adddf3>
    c200:	e28dcc02 	add	ip, sp, #512	; 0x200
    c204:	e1cc06f8 	strd	r0, [ip, #104]	; 0x68
    c208:	e1a02008 	mov	r2, r8
    c20c:	e1a03009 	mov	r3, r9
    c210:	eb0023ac 	bl	150c8 <__aeabi_dcmpgt>
    c214:	e51f329c 	ldr	r3, [pc, #-668]	; bf80 <POTENG+0xdd0>
    c218:	e28ded0d 	add	lr, sp, #832	; 0x340
    c21c:	e3500000 	cmp	r0, #0
                                if (RS[K] > CUT2)
                                    KC++;
    c220:	e28b2001 	add	r2, fp, #1
                                   curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);


                            KC=0;
                            for (K = 0; K < 9; K++) {
                                RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    c224:	e51fc2a8 	ldr	ip, [pc, #-680]	; bf84 <POTENG+0xdd4>
    c228:	e18e00d3 	ldrd	r0, [lr, r3]
    c22c:	e51fe2ac 	ldr	lr, [pc, #-684]	; bf88 <POTENG+0xdd8>
    c230:	11a0b002 	movne	fp, r2
    c234:	e1a03001 	mov	r3, r1
    c238:	e1a02000 	mov	r2, r0
    c23c:	e28d4d0d 	add	r4, sp, #832	; 0x340
    c240:	e18460de 	ldrd	r6, [r4, lr]
    c244:	e18440dc 	ldrd	r4, [r4, ip]
    c248:	e1cd44f0 	strd	r4, [sp, #64]	; 0x40
    c24c:	eb00222b 	bl	14b00 <__aeabi_dmul>
    c250:	e1a02006 	mov	r2, r6
    c254:	e1a04000 	mov	r4, r0
    c258:	e1a05001 	mov	r5, r1
    c25c:	e1a03007 	mov	r3, r7
    c260:	e1a00006 	mov	r0, r6
    c264:	e1a01007 	mov	r1, r7
    c268:	eb002224 	bl	14b00 <__aeabi_dmul>
    c26c:	e1a02000 	mov	r2, r0
    c270:	e1a03001 	mov	r3, r1
    c274:	e1a00004 	mov	r0, r4
    c278:	e1a01005 	mov	r1, r5
    c27c:	eb00211b 	bl	146f0 <__adddf3>
    c280:	e1a04000 	mov	r4, r0
    c284:	e1a05001 	mov	r5, r1
    c288:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    c28c:	e1a02000 	mov	r2, r0
    c290:	e1a03001 	mov	r3, r1
    c294:	eb002219 	bl	14b00 <__aeabi_dmul>
    c298:	e1a02000 	mov	r2, r0
    c29c:	e1a03001 	mov	r3, r1
    c2a0:	e1a00004 	mov	r0, r4
    c2a4:	e1a01005 	mov	r1, r5
    c2a8:	eb002110 	bl	146f0 <__adddf3>
    c2ac:	e28dcc02 	add	ip, sp, #512	; 0x200
    c2b0:	e1cc07f0 	strd	r0, [ip, #112]	; 0x70
    c2b4:	e1a02008 	mov	r2, r8
    c2b8:	e1a03009 	mov	r3, r9
    c2bc:	eb002381 	bl	150c8 <__aeabi_dcmpgt>
    c2c0:	e51f333c 	ldr	r3, [pc, #-828]	; bf8c <POTENG+0xddc>
    c2c4:	e28ded0d 	add	lr, sp, #832	; 0x340
    c2c8:	e3500000 	cmp	r0, #0
    c2cc:	e51fc344 	ldr	ip, [pc, #-836]	; bf90 <POTENG+0xde0>
                                if (RS[K] > CUT2)
                                    KC++;
    c2d0:	e28b2001 	add	r2, fp, #1
                                   curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);


                            KC=0;
                            for (K = 0; K < 9; K++) {
                                RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    c2d4:	e18e00d3 	ldrd	r0, [lr, r3]
    c2d8:	e51fe34c 	ldr	lr, [pc, #-844]	; bf94 <POTENG+0xde4>
    c2dc:	11a0b002 	movne	fp, r2
    c2e0:	e1a03001 	mov	r3, r1
    c2e4:	e1a02000 	mov	r2, r0
    c2e8:	e28d4d0d 	add	r4, sp, #832	; 0x340
    c2ec:	e18460de 	ldrd	r6, [r4, lr]
    c2f0:	e18440dc 	ldrd	r4, [r4, ip]
    c2f4:	e1cd44f0 	strd	r4, [sp, #64]	; 0x40
    c2f8:	eb002200 	bl	14b00 <__aeabi_dmul>
    c2fc:	e1a02006 	mov	r2, r6
    c300:	e1a04000 	mov	r4, r0
    c304:	e1a05001 	mov	r5, r1
    c308:	e1a03007 	mov	r3, r7
    c30c:	e1a00006 	mov	r0, r6
    c310:	e1a01007 	mov	r1, r7
    c314:	eb0021f9 	bl	14b00 <__aeabi_dmul>
    c318:	e1a02000 	mov	r2, r0
    c31c:	e1a03001 	mov	r3, r1
    c320:	e1a00004 	mov	r0, r4
    c324:	e1a01005 	mov	r1, r5
    c328:	eb0020f0 	bl	146f0 <__adddf3>
    c32c:	e1a04000 	mov	r4, r0
    c330:	e1a05001 	mov	r5, r1
    c334:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    c338:	e1a02000 	mov	r2, r0
    c33c:	e1a03001 	mov	r3, r1
    c340:	eb0021ee 	bl	14b00 <__aeabi_dmul>
    c344:	e1a02000 	mov	r2, r0
    c348:	e1a03001 	mov	r3, r1
    c34c:	e1a00004 	mov	r0, r4
    c350:	e1a01005 	mov	r1, r5
    c354:	eb0020e5 	bl	146f0 <__adddf3>
    c358:	e28dcc02 	add	ip, sp, #512	; 0x200
    c35c:	e1cc07f8 	strd	r0, [ip, #120]	; 0x78
    c360:	e1a02008 	mov	r2, r8
    c364:	e1a03009 	mov	r3, r9
    c368:	eb002356 	bl	150c8 <__aeabi_dcmpgt>
    c36c:	e51f33dc 	ldr	r3, [pc, #-988]	; bf98 <POTENG+0xde8>
    c370:	e28ded0d 	add	lr, sp, #832	; 0x340
    c374:	e3500000 	cmp	r0, #0
    c378:	e51fc3e4 	ldr	ip, [pc, #-996]	; bf9c <POTENG+0xdec>
                                if (RS[K] > CUT2)
                                    KC++;
    c37c:	e28b2001 	add	r2, fp, #1
                                   curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);


                            KC=0;
                            for (K = 0; K < 9; K++) {
                                RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    c380:	e18e00d3 	ldrd	r0, [lr, r3]
    c384:	e51fe3ec 	ldr	lr, [pc, #-1004]	; bfa0 <POTENG+0xdf0>
    c388:	11a0b002 	movne	fp, r2
    c38c:	e1a03001 	mov	r3, r1
    c390:	e1a02000 	mov	r2, r0
    c394:	e28d4d0d 	add	r4, sp, #832	; 0x340
    c398:	e18460de 	ldrd	r6, [r4, lr]
    c39c:	e18440dc 	ldrd	r4, [r4, ip]
    c3a0:	e1cd44f0 	strd	r4, [sp, #64]	; 0x40
    c3a4:	eb0021d5 	bl	14b00 <__aeabi_dmul>
    c3a8:	e1a02006 	mov	r2, r6
    c3ac:	e1a04000 	mov	r4, r0
    c3b0:	e1a05001 	mov	r5, r1
    c3b4:	e1a03007 	mov	r3, r7
    c3b8:	e1a00006 	mov	r0, r6
    c3bc:	e1a01007 	mov	r1, r7
    c3c0:	eb0021ce 	bl	14b00 <__aeabi_dmul>
    c3c4:	e1a02000 	mov	r2, r0
    c3c8:	e1a03001 	mov	r3, r1
    c3cc:	e1a00004 	mov	r0, r4
    c3d0:	e1a01005 	mov	r1, r5
    c3d4:	eb0020c5 	bl	146f0 <__adddf3>
    c3d8:	e1a04000 	mov	r4, r0
    c3dc:	e1a05001 	mov	r5, r1
    c3e0:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    c3e4:	e1a02000 	mov	r2, r0
    c3e8:	e1a03001 	mov	r3, r1
    c3ec:	eb0021c3 	bl	14b00 <__aeabi_dmul>
    c3f0:	e1a02000 	mov	r2, r0
    c3f4:	e1a03001 	mov	r3, r1
    c3f8:	e1a00004 	mov	r0, r4
    c3fc:	e1a01005 	mov	r1, r5
    c400:	eb0020ba 	bl	146f0 <__adddf3>
    c404:	e28dcc02 	add	ip, sp, #512	; 0x200
    c408:	e1cc08f0 	strd	r0, [ip, #128]	; 0x80
    c40c:	e1a02008 	mov	r2, r8
    c410:	e1a03009 	mov	r3, r9
    c414:	eb00232b 	bl	150c8 <__aeabi_dcmpgt>
    c418:	e51f347c 	ldr	r3, [pc, #-1148]	; bfa4 <POTENG+0xdf4>
    c41c:	e28ded0d 	add	lr, sp, #832	; 0x340
    c420:	e3500000 	cmp	r0, #0
    c424:	e51fc484 	ldr	ip, [pc, #-1156]	; bfa8 <POTENG+0xdf8>
                                if (RS[K] > CUT2)
                                    KC++;
    c428:	e28b2001 	add	r2, fp, #1
                                   curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);


                            KC=0;
                            for (K = 0; K < 9; K++) {
                                RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    c42c:	e18e00d3 	ldrd	r0, [lr, r3]
    c430:	e51fe48c 	ldr	lr, [pc, #-1164]	; bfac <POTENG+0xdfc>
    c434:	11a0b002 	movne	fp, r2
    c438:	e1a03001 	mov	r3, r1
    c43c:	e1a02000 	mov	r2, r0
    c440:	e28d4d0d 	add	r4, sp, #832	; 0x340
    c444:	e18460de 	ldrd	r6, [r4, lr]
    c448:	e18440dc 	ldrd	r4, [r4, ip]
    c44c:	e1cd44f0 	strd	r4, [sp, #64]	; 0x40
    c450:	eb0021aa 	bl	14b00 <__aeabi_dmul>
    c454:	e1a02006 	mov	r2, r6
    c458:	e1a04000 	mov	r4, r0
    c45c:	e1a05001 	mov	r5, r1
    c460:	e1a03007 	mov	r3, r7
    c464:	e1a00006 	mov	r0, r6
    c468:	e1a01007 	mov	r1, r7
    c46c:	eb0021a3 	bl	14b00 <__aeabi_dmul>
    c470:	e1a02000 	mov	r2, r0
    c474:	e1a03001 	mov	r3, r1
    c478:	e1a00004 	mov	r0, r4
    c47c:	e1a01005 	mov	r1, r5
    c480:	eb00209a 	bl	146f0 <__adddf3>
    c484:	e1a04000 	mov	r4, r0
    c488:	e1a05001 	mov	r5, r1
    c48c:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    c490:	e1a02000 	mov	r2, r0
    c494:	e1a03001 	mov	r3, r1
    c498:	eb002198 	bl	14b00 <__aeabi_dmul>
    c49c:	e1a02000 	mov	r2, r0
    c4a0:	e1a03001 	mov	r3, r1
    c4a4:	e1a00004 	mov	r0, r4
    c4a8:	e1a01005 	mov	r1, r5
    c4ac:	eb00208f 	bl	146f0 <__adddf3>
    c4b0:	e28dcc02 	add	ip, sp, #512	; 0x200
    c4b4:	e1cc08f8 	strd	r0, [ip, #136]	; 0x88
    c4b8:	e1a02008 	mov	r2, r8
    c4bc:	e1a03009 	mov	r3, r9
    c4c0:	eb002300 	bl	150c8 <__aeabi_dcmpgt>
    c4c4:	e51f351c 	ldr	r3, [pc, #-1308]	; bfb0 <POTENG+0xe00>
    c4c8:	e28ded0d 	add	lr, sp, #832	; 0x340
    c4cc:	e3500000 	cmp	r0, #0
    c4d0:	e51fc524 	ldr	ip, [pc, #-1316]	; bfb4 <POTENG+0xe04>
    c4d4:	e18e00d3 	ldrd	r0, [lr, r3]
                                if (RS[K] > CUT2)
                                    KC++;
    c4d8:	e28b2001 	add	r2, fp, #1
                                   curr_ptr->mol.VM[ZDIR],neighbor_ptr->mol.VM[ZDIR],ZL,BOXH,BOXL);


                            KC=0;
                            for (K = 0; K < 9; K++) {
                                RS[K]=XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K];
    c4dc:	e51fe52c 	ldr	lr, [pc, #-1324]	; bfb8 <POTENG+0xe08>
    c4e0:	11a0b002 	movne	fp, r2
    c4e4:	e1a03001 	mov	r3, r1
    c4e8:	e1a02000 	mov	r2, r0
    c4ec:	e28d4d0d 	add	r4, sp, #832	; 0x340
    c4f0:	e18460de 	ldrd	r6, [r4, lr]
    c4f4:	e18440dc 	ldrd	r4, [r4, ip]
    c4f8:	e1cd44f0 	strd	r4, [sp, #64]	; 0x40
    c4fc:	eb00217f 	bl	14b00 <__aeabi_dmul>
    c500:	e1a02006 	mov	r2, r6
    c504:	e1a04000 	mov	r4, r0
    c508:	e1a05001 	mov	r5, r1
    c50c:	e1a03007 	mov	r3, r7
    c510:	e1a00006 	mov	r0, r6
    c514:	e1a01007 	mov	r1, r7
    c518:	eb002178 	bl	14b00 <__aeabi_dmul>
    c51c:	e1a02000 	mov	r2, r0
    c520:	e1a03001 	mov	r3, r1
    c524:	e1a00004 	mov	r0, r4
    c528:	e1a01005 	mov	r1, r5
    c52c:	eb00206f 	bl	146f0 <__adddf3>
    c530:	e1a04000 	mov	r4, r0
    c534:	e1a05001 	mov	r5, r1
    c538:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    c53c:	e1a02000 	mov	r2, r0
    c540:	e1a03001 	mov	r3, r1
    c544:	eb00216d 	bl	14b00 <__aeabi_dmul>
    c548:	e1a02000 	mov	r2, r0
    c54c:	e1a03001 	mov	r3, r1
    c550:	e1a00004 	mov	r0, r4
    c554:	e1a01005 	mov	r1, r5
    c558:	eb002064 	bl	146f0 <__adddf3>
    c55c:	e28dcc02 	add	ip, sp, #512	; 0x200
    c560:	e1a03009 	mov	r3, r9
    c564:	e1a02008 	mov	r2, r8
    c568:	e1cc09f0 	strd	r0, [ip, #144]	; 0x90
    c56c:	eb0022d5 	bl	150c8 <__aeabi_dcmpgt>
                                if (RS[K] > CUT2)
                                    KC++;
    c570:	e28b3001 	add	r3, fp, #1
    c574:	e3500000 	cmp	r0, #0
    c578:	11a0b003 	movne	fp, r3
                            } /* for K */


                            if (KC != 9) {
    c57c:	e35b0009 	cmp	fp, #9
    c580:	13a07000 	movne	r7, #0
    c584:	128d6e25 	addne	r6, sp, #592	; 0x250
    c588:	1a000009 	bne	c5b4 <POTENG+0x1404>
    c58c:	ea0000b5 	b	c868 <POTENG+0x16b8>
                                for (K = 0; K < 9; K++) {
                                    if (RS[K] <= CUT2) {
                                        RL[K]=sqrt(RS[K]);
                                    }
                                    else {
                                        RL[K]=CUTOFF;
    c590:	e28d4fb2 	add	r4, sp, #712	; 0x2c8
                                        RS[K]=CUT2;
    c594:	e18680f7 	strd	r8, [r6, r7]
                                for (K = 0; K < 9; K++) {
                                    if (RS[K] <= CUT2) {
                                        RL[K]=sqrt(RS[K]);
                                    }
                                    else {
                                        RL[K]=CUTOFF;
    c598:	e1ca20d0 	ldrd	r2, [sl]
    c59c:	e18420f7 	strd	r2, [r4, r7]
    c5a0:	e2877008 	add	r7, r7, #8
                                    KC++;
                            } /* for K */


                            if (KC != 9) {
                                for (K = 0; K < 9; K++) {
    c5a4:	e3570048 	cmp	r7, #72	; 0x48
    c5a8:	0a000011 	beq	c5f4 <POTENG+0x1444>
    c5ac:	e51fe5f8 	ldr	lr, [pc, #-1528]	; bfbc <POTENG+0xe0c>
    c5b0:	e1ce80d0 	ldrd	r8, [lr]
                                    if (RS[K] <= CUT2) {
    c5b4:	e18640d7 	ldrd	r4, [r6, r7]
    c5b8:	e1a02008 	mov	r2, r8
    c5bc:	e1a03009 	mov	r3, r9
    c5c0:	e1a00004 	mov	r0, r4
    c5c4:	e1a01005 	mov	r1, r5
    c5c8:	eb0022b2 	bl	15098 <__aeabi_dcmple>
    c5cc:	e3500000 	cmp	r0, #0
    c5d0:	0affffee 	beq	c590 <POTENG+0x13e0>
                                        RL[K]=sqrt(RS[K]);
    c5d4:	e1a00004 	mov	r0, r4
    c5d8:	e1a01005 	mov	r1, r5
    c5dc:	eb007833 	bl	2a6b0 <sqrt>
    c5e0:	e28d2fb2 	add	r2, sp, #712	; 0x2c8
    c5e4:	e18200f7 	strd	r0, [r2, r7]
    c5e8:	e2877008 	add	r7, r7, #8
                                    KC++;
                            } /* for K */


                            if (KC != 9) {
                                for (K = 0; K < 9; K++) {
    c5ec:	e3570048 	cmp	r7, #72	; 0x48
    c5f0:	1affffed 	bne	c5ac <POTENG+0x13fc>
                                        RL[K]=CUTOFF;
                                        RS[K]=CUT2;
                                    } /* else */
                                } /* for K */

                                LPOTR= LPOTR-QQ2/RL[1]-QQ2/RL[2]-QQ2/RL[3]-QQ2/RL[4]
    c5f4:	e51fc63c 	ldr	ip, [pc, #-1596]	; bfc0 <POTENG+0xe10>
    c5f8:	e28dec02 	add	lr, sp, #512	; 0x200
    c5fc:	e1cc40d0 	ldrd	r4, [ip]
                                    + QQ/RL[5]+ QQ/RL[6]+ QQ/RL[7]+ QQ/RL[8]
    c600:	e51fc644 	ldr	ip, [pc, #-1604]	; bfc4 <POTENG+0xe14>
                                        RL[K]=CUTOFF;
                                        RS[K]=CUT2;
                                    } /* else */
                                } /* for K */

                                LPOTR= LPOTR-QQ2/RL[1]-QQ2/RL[2]-QQ2/RL[3]-QQ2/RL[4]
    c604:	e1ce2dd0 	ldrd	r2, [lr, #208]	; 0xd0
    c608:	e1a00004 	mov	r0, r4
                                    + QQ/RL[5]+ QQ/RL[6]+ QQ/RL[7]+ QQ/RL[8]
    c60c:	e1cc80d0 	ldrd	r8, [ip]
                                        RL[K]=CUTOFF;
                                        RS[K]=CUT2;
                                    } /* else */
                                } /* for K */

                                LPOTR= LPOTR-QQ2/RL[1]-QQ2/RL[2]-QQ2/RL[3]-QQ2/RL[4]
    c610:	e1a01005 	mov	r1, r5
    c614:	eb0021dd 	bl	14d90 <__aeabi_ddiv>
    c618:	e1a02000 	mov	r2, r0
    c61c:	e1a03001 	mov	r3, r1
    c620:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    c624:	eb002030 	bl	146ec <__aeabi_dsub>
    c628:	e28dcc02 	add	ip, sp, #512	; 0x200
    c62c:	e1cc2dd8 	ldrd	r2, [ip, #216]	; 0xd8
    c630:	e1a06000 	mov	r6, r0
    c634:	e1a07001 	mov	r7, r1
    c638:	e1a00004 	mov	r0, r4
    c63c:	e1a01005 	mov	r1, r5
    c640:	eb0021d2 	bl	14d90 <__aeabi_ddiv>
    c644:	e1a02000 	mov	r2, r0
    c648:	e1a03001 	mov	r3, r1
    c64c:	e1a00006 	mov	r0, r6
    c650:	e1a01007 	mov	r1, r7
    c654:	eb002024 	bl	146ec <__aeabi_dsub>
    c658:	e28dec02 	add	lr, sp, #512	; 0x200
    c65c:	e1ce2ed0 	ldrd	r2, [lr, #224]	; 0xe0
    c660:	e1a06000 	mov	r6, r0
    c664:	e1a07001 	mov	r7, r1
    c668:	e1a00004 	mov	r0, r4
    c66c:	e1a01005 	mov	r1, r5
    c670:	eb0021c6 	bl	14d90 <__aeabi_ddiv>
    c674:	e1a02000 	mov	r2, r0
    c678:	e1a03001 	mov	r3, r1
    c67c:	e1a00006 	mov	r0, r6
    c680:	e1a01007 	mov	r1, r7
    c684:	eb002018 	bl	146ec <__aeabi_dsub>
    c688:	e1a06000 	mov	r6, r0
    c68c:	e1a00004 	mov	r0, r4
    c690:	e28d4c02 	add	r4, sp, #512	; 0x200
    c694:	e1c42ed8 	ldrd	r2, [r4, #232]	; 0xe8
    c698:	e1a07001 	mov	r7, r1
    c69c:	e1a01005 	mov	r1, r5
    c6a0:	eb0021ba 	bl	14d90 <__aeabi_ddiv>
    c6a4:	e1a02000 	mov	r2, r0
    c6a8:	e1a03001 	mov	r3, r1
    c6ac:	e1a00006 	mov	r0, r6
    c6b0:	e1a01007 	mov	r1, r7
    c6b4:	eb00200c 	bl	146ec <__aeabi_dsub>
                                    + QQ/RL[5]+ QQ/RL[6]+ QQ/RL[7]+ QQ/RL[8]
    c6b8:	e28dcc02 	add	ip, sp, #512	; 0x200
    c6bc:	e1cc2fd0 	ldrd	r2, [ip, #240]	; 0xf0
                                        RL[K]=CUTOFF;
                                        RS[K]=CUT2;
                                    } /* else */
                                } /* for K */

                                LPOTR= LPOTR-QQ2/RL[1]-QQ2/RL[2]-QQ2/RL[3]-QQ2/RL[4]
    c6c0:	e1a04000 	mov	r4, r0
    c6c4:	e1a05001 	mov	r5, r1
                                    + QQ/RL[5]+ QQ/RL[6]+ QQ/RL[7]+ QQ/RL[8]
    c6c8:	e1a00008 	mov	r0, r8
    c6cc:	e1a01009 	mov	r1, r9
    c6d0:	eb0021ae 	bl	14d90 <__aeabi_ddiv>
    c6d4:	e1a02000 	mov	r2, r0
    c6d8:	e1a03001 	mov	r3, r1
    c6dc:	e1a00004 	mov	r0, r4
    c6e0:	e1a01005 	mov	r1, r5
    c6e4:	eb002001 	bl	146f0 <__adddf3>
    c6e8:	e28dec02 	add	lr, sp, #512	; 0x200
    c6ec:	e1ce2fd8 	ldrd	r2, [lr, #248]	; 0xf8
    c6f0:	e1a04000 	mov	r4, r0
    c6f4:	e1a05001 	mov	r5, r1
    c6f8:	e1a00008 	mov	r0, r8
    c6fc:	e1a01009 	mov	r1, r9
    c700:	eb0021a2 	bl	14d90 <__aeabi_ddiv>
    c704:	e1a02000 	mov	r2, r0
    c708:	e1a03001 	mov	r3, r1
    c70c:	e1a00004 	mov	r0, r4
    c710:	e1a01005 	mov	r1, r5
    c714:	eb001ff5 	bl	146f0 <__adddf3>
    c718:	e28dcc03 	add	ip, sp, #768	; 0x300
    c71c:	e1cc20d0 	ldrd	r2, [ip]
    c720:	e1a04000 	mov	r4, r0
    c724:	e1a05001 	mov	r5, r1
    c728:	e1a00008 	mov	r0, r8
    c72c:	e1a01009 	mov	r1, r9
    c730:	eb002196 	bl	14d90 <__aeabi_ddiv>
    c734:	e1a02000 	mov	r2, r0
    c738:	e1a03001 	mov	r3, r1
    c73c:	e1a00004 	mov	r0, r4
    c740:	e1a01005 	mov	r1, r5
    c744:	eb001fe9 	bl	146f0 <__adddf3>
    c748:	e28deb01 	add	lr, sp, #1024	; 0x400
    c74c:	e14e2fd8 	ldrd	r2, [lr, #-248]	; 0xffffff08
    c750:	e1a04000 	mov	r4, r0
    c754:	e1a05001 	mov	r5, r1
    c758:	e1a00008 	mov	r0, r8
    c75c:	e1a01009 	mov	r1, r9
    c760:	eb00218a 	bl	14d90 <__aeabi_ddiv>
    c764:	e1a02000 	mov	r2, r0
    c768:	e1a03001 	mov	r3, r1
    c76c:	e1a00004 	mov	r0, r4
    c770:	e1a01005 	mov	r1, r5
    c774:	eb001fdd 	bl	146f0 <__adddf3>
    c778:	e1a05001 	mov	r5, r1
                                        + QQ4/RL[0];
    c77c:	e51f17bc 	ldr	r1, [pc, #-1980]	; bfc8 <POTENG+0xe18>
                                        RS[K]=CUT2;
                                    } /* else */
                                } /* for K */

                                LPOTR= LPOTR-QQ2/RL[1]-QQ2/RL[2]-QQ2/RL[3]-QQ2/RL[4]
                                    + QQ/RL[5]+ QQ/RL[6]+ QQ/RL[7]+ QQ/RL[8]
    c780:	e1a04000 	mov	r4, r0
                                        + QQ4/RL[0];
    c784:	e28d0c02 	add	r0, sp, #512	; 0x200
    c788:	e1c02cd8 	ldrd	r2, [r0, #200]	; 0xc8
    c78c:	e1c100d0 	ldrd	r0, [r1]
    c790:	eb00217e 	bl	14d90 <__aeabi_ddiv>
    c794:	e1a02000 	mov	r2, r0
    c798:	e1a03001 	mov	r3, r1
                                        RL[K]=CUTOFF;
                                        RS[K]=CUT2;
                                    } /* else */
                                } /* for K */

                                LPOTR= LPOTR-QQ2/RL[1]-QQ2/RL[2]-QQ2/RL[3]-QQ2/RL[4]
    c79c:	e1a00004 	mov	r0, r4
    c7a0:	e1a01005 	mov	r1, r5
    c7a4:	eb001fd1 	bl	146f0 <__adddf3>
                                    + QQ/RL[5]+ QQ/RL[6]+ QQ/RL[7]+ QQ/RL[8]
                                        + QQ4/RL[0];

                                LPTRF= LPTRF-REF2*RS[0]-REF1*((RS[5]+RS[6]+RS[7]+RS[8])*0.5
    c7a8:	e51f37e4 	ldr	r3, [pc, #-2020]	; bfcc <POTENG+0xe1c>
    c7ac:	e28d2c02 	add	r2, sp, #512	; 0x200
                                        RL[K]=CUTOFF;
                                        RS[K]=CUT2;
                                    } /* else */
                                } /* for K */

                                LPOTR= LPOTR-QQ2/RL[1]-QQ2/RL[2]-QQ2/RL[3]-QQ2/RL[4]
    c7b0:	e1cd05f0 	strd	r0, [sp, #80]	; 0x50
                                    + QQ/RL[5]+ QQ/RL[6]+ QQ/RL[7]+ QQ/RL[8]
                                        + QQ4/RL[0];

                                LPTRF= LPTRF-REF2*RS[0]-REF1*((RS[5]+RS[6]+RS[7]+RS[8])*0.5
    c7b4:	e1c205d0 	ldrd	r0, [r2, #80]	; 0x50
    c7b8:	e1c320d0 	ldrd	r2, [r3]
    c7bc:	eb0020cf 	bl	14b00 <__aeabi_dmul>
    c7c0:	e1a02000 	mov	r2, r0
    c7c4:	e1a03001 	mov	r3, r1
    c7c8:	e1cd05d8 	ldrd	r0, [sp, #88]	; 0x58
    c7cc:	eb001fc6 	bl	146ec <__aeabi_dsub>
    c7d0:	e28dcc02 	add	ip, sp, #512	; 0x200
    c7d4:	e1cc28d0 	ldrd	r2, [ip, #128]	; 0x80
    c7d8:	e1a04000 	mov	r4, r0
    c7dc:	e1a05001 	mov	r5, r1
    c7e0:	e1cc07d8 	ldrd	r0, [ip, #120]	; 0x78
    c7e4:	eb001fc1 	bl	146f0 <__adddf3>
    c7e8:	e28dec02 	add	lr, sp, #512	; 0x200
    c7ec:	e1ce28d8 	ldrd	r2, [lr, #136]	; 0x88
    c7f0:	eb001fbe 	bl	146f0 <__adddf3>
    c7f4:	e28dcc02 	add	ip, sp, #512	; 0x200
    c7f8:	e1cc29d0 	ldrd	r2, [ip, #144]	; 0x90
    c7fc:	eb001fbb 	bl	146f0 <__adddf3>
    c800:	e3a02000 	mov	r2, #0
    c804:	e51f3814 	ldr	r3, [pc, #-2068]	; bff8 <POTENG+0xe48>
    c808:	eb0020bc 	bl	14b00 <__aeabi_dmul>
                                                              -RS[1]-RS[2]-RS[3]-RS[4]);
    c80c:	e28dec02 	add	lr, sp, #512	; 0x200
    c810:	e1ce25d8 	ldrd	r2, [lr, #88]	; 0x58
    c814:	eb001fb4 	bl	146ec <__aeabi_dsub>
    c818:	e28dcc02 	add	ip, sp, #512	; 0x200
    c81c:	e1cc26d0 	ldrd	r2, [ip, #96]	; 0x60
    c820:	eb001fb1 	bl	146ec <__aeabi_dsub>
    c824:	e28dec02 	add	lr, sp, #512	; 0x200
    c828:	e1ce26d8 	ldrd	r2, [lr, #104]	; 0x68
    c82c:	eb001fae 	bl	146ec <__aeabi_dsub>
    c830:	e28dcc02 	add	ip, sp, #512	; 0x200
    c834:	e1cc27d0 	ldrd	r2, [ip, #112]	; 0x70
    c838:	eb001fab 	bl	146ec <__aeabi_dsub>

                                LPOTR= LPOTR-QQ2/RL[1]-QQ2/RL[2]-QQ2/RL[3]-QQ2/RL[4]
                                    + QQ/RL[5]+ QQ/RL[6]+ QQ/RL[7]+ QQ/RL[8]
                                        + QQ4/RL[0];

                                LPTRF= LPTRF-REF2*RS[0]-REF1*((RS[5]+RS[6]+RS[7]+RS[8])*0.5
    c83c:	e51f3874 	ldr	r3, [pc, #-2164]	; bfd0 <POTENG+0xe20>
    c840:	e1c320d0 	ldrd	r2, [r3]
    c844:	eb0020ad 	bl	14b00 <__aeabi_dmul>
    c848:	e1a02000 	mov	r2, r0
    c84c:	e1a03001 	mov	r3, r1
    c850:	e1a00004 	mov	r0, r4
    c854:	e1a01005 	mov	r1, r5
    c858:	eb001fa3 	bl	146ec <__aeabi_dsub>
                                                              -RS[1]-RS[2]-RS[3]-RS[4]);

                                if (KC <= 0) {
    c85c:	e35b0000 	cmp	fp, #0

                                LPOTR= LPOTR-QQ2/RL[1]-QQ2/RL[2]-QQ2/RL[3]-QQ2/RL[4]
                                    + QQ/RL[5]+ QQ/RL[6]+ QQ/RL[7]+ QQ/RL[8]
                                        + QQ4/RL[0];

                                LPTRF= LPTRF-REF2*RS[0]-REF1*((RS[5]+RS[6]+RS[7]+RS[8])*0.5
    c860:	e1cd05f8 	strd	r0, [sp, #88]	; 0x58
                                                              -RS[1]-RS[2]-RS[3]-RS[4]);

                                if (KC <= 0) {
    c864:	0a00000d 	beq	c8a0 <POTENG+0x16f0>
                                                     +exp(-B4*RL[12])+exp(-B4*RL[13]));
                                } /* if KC <= 0 */


                            } /* if KC != 9 */
                            curr_ptr = curr_ptr->next_mol;
    c868:	e59d4088 	ldr	r4, [sp, #136]	; 0x88
    c86c:	e59442a0 	ldr	r4, [r4, #672]	; 0x2a0
    c870:	e1a05004 	mov	r5, r4
    c874:	e58d4088 	str	r4, [sp, #136]	; 0x88

                    neighbor_ptr = BOX[X_NUM][Y_NUM][Z_NUM].list;
                    while (neighbor_ptr) {
                        /* go through current box list */
                        curr_ptr = BOX[i][j][k].list;
                        while (curr_ptr) {
    c878:	e3550000 	cmp	r5, #0
    c87c:	1afffd2d 	bne	bd38 <POTENG+0xb88>


                            } /* if KC != 9 */
                            curr_ptr = curr_ptr->next_mol;
                        }
                        neighbor_ptr = neighbor_ptr->next_mol;
    c880:	e59dc048 	ldr	ip, [sp, #72]	; 0x48
    c884:	e59cc2a0 	ldr	ip, [ip, #672]	; 0x2a0
                        ((XBOX != i) || (YBOX != j) || (ZBOX !=k))) {
                        continue;
                    }

                    neighbor_ptr = BOX[X_NUM][Y_NUM][Z_NUM].list;
                    while (neighbor_ptr) {
    c888:	e35c0000 	cmp	ip, #0


                            } /* if KC != 9 */
                            curr_ptr = curr_ptr->next_mol;
                        }
                        neighbor_ptr = neighbor_ptr->next_mol;
    c88c:	e58dc048 	str	ip, [sp, #72]	; 0x48
                        ((XBOX != i) || (YBOX != j) || (ZBOX !=k))) {
                        continue;
                    }

                    neighbor_ptr = BOX[X_NUM][Y_NUM][Z_NUM].list;
                    while (neighbor_ptr) {
    c890:	0a0000d6 	beq	cbf0 <POTENG+0x1a40>
    c894:	e51fe8c8 	ldr	lr, [pc, #-2248]	; bfd4 <POTENG+0xe24>
    c898:	e59e3000 	ldr	r3, [lr]
    c89c:	eafffd1c 	b	bd14 <POTENG+0xb64>

                                LPTRF= LPTRF-REF2*RS[0]-REF1*((RS[5]+RS[6]+RS[7]+RS[8])*0.5
                                                              -RS[1]-RS[2]-RS[3]-RS[4]);

                                if (KC <= 0) {
                                    for (K = 9; K <  14; K++)  {
    c8a0:	e3a08009 	mov	r8, #9
                                        RL[K]=sqrt(XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K]);
    c8a4:	e28de0e8 	add	lr, sp, #232	; 0xe8
    c8a8:	e1a09188 	lsl	r9, r8, #3
    c8ac:	e28d2e16 	add	r2, sp, #352	; 0x160
    c8b0:	e18e00d9 	ldrd	r0, [lr, r9]
    c8b4:	e18260d9 	ldrd	r6, [r2, r9]
    c8b8:	e1a03001 	mov	r3, r1
    c8bc:	e1a02000 	mov	r2, r0
    c8c0:	e28d5f76 	add	r5, sp, #472	; 0x1d8
    c8c4:	e18540d9 	ldrd	r4, [r5, r9]
    c8c8:	e1cd44f0 	strd	r4, [sp, #64]	; 0x40
    c8cc:	eb00208b 	bl	14b00 <__aeabi_dmul>
    c8d0:	e1a02006 	mov	r2, r6
    c8d4:	e1a04000 	mov	r4, r0
    c8d8:	e1a05001 	mov	r5, r1
    c8dc:	e1a03007 	mov	r3, r7
    c8e0:	e1a00006 	mov	r0, r6
    c8e4:	e1a01007 	mov	r1, r7
    c8e8:	eb002084 	bl	14b00 <__aeabi_dmul>
    c8ec:	e1a02000 	mov	r2, r0
    c8f0:	e1a03001 	mov	r3, r1
    c8f4:	e1a00004 	mov	r0, r4
    c8f8:	e1a01005 	mov	r1, r5
    c8fc:	eb001f7b 	bl	146f0 <__adddf3>
    c900:	e1a04000 	mov	r4, r0
    c904:	e1a05001 	mov	r5, r1
    c908:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    c90c:	e1a02000 	mov	r2, r0
    c910:	e1a03001 	mov	r3, r1
    c914:	eb002079 	bl	14b00 <__aeabi_dmul>
    c918:	e1a02000 	mov	r2, r0
    c91c:	e1a03001 	mov	r3, r1
    c920:	e1a00004 	mov	r0, r4
    c924:	e1a01005 	mov	r1, r5
    c928:	eb001f70 	bl	146f0 <__adddf3>
    c92c:	eb00775f 	bl	2a6b0 <sqrt>

                                LPTRF= LPTRF-REF2*RS[0]-REF1*((RS[5]+RS[6]+RS[7]+RS[8])*0.5
                                                              -RS[1]-RS[2]-RS[3]-RS[4]);

                                if (KC <= 0) {
                                    for (K = 9; K <  14; K++)  {
    c930:	e2888001 	add	r8, r8, #1
                                        RL[K]=sqrt(XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K]);
    c934:	e28dcfb2 	add	ip, sp, #712	; 0x2c8

                                LPTRF= LPTRF-REF2*RS[0]-REF1*((RS[5]+RS[6]+RS[7]+RS[8])*0.5
                                                              -RS[1]-RS[2]-RS[3]-RS[4]);

                                if (KC <= 0) {
                                    for (K = 9; K <  14; K++)  {
    c938:	e358000e 	cmp	r8, #14
                                        RL[K]=sqrt(XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K]);
    c93c:	e18c00f9 	strd	r0, [ip, r9]

                                LPTRF= LPTRF-REF2*RS[0]-REF1*((RS[5]+RS[6]+RS[7]+RS[8])*0.5
                                                              -RS[1]-RS[2]-RS[3]-RS[4]);

                                if (KC <= 0) {
                                    for (K = 9; K <  14; K++)  {
    c940:	1affffd7 	bne	c8a4 <POTENG+0x16f4>
                                        RL[K]=sqrt(XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K]);
                                    }

                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
    c944:	e51fc974 	ldr	ip, [pc, #-2420]	; bfd8 <POTENG+0xe28>
    c948:	e28deb01 	add	lr, sp, #1024	; 0x400
    c94c:	e14e2fd0 	ldrd	r2, [lr, #-240]	; 0xffffff10
    c950:	e89c1001 	ldm	ip, {r0, ip}
    c954:	e28c1102 	add	r1, ip, #-2147483648	; 0x80000000
    c958:	eb002068 	bl	14b00 <__aeabi_dmul>
    c95c:	eb007491 	bl	29ba8 <exp>
    c960:	e51f398c 	ldr	r3, [pc, #-2444]	; bfdc <POTENG+0xe2c>
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
    c964:	e51f498c 	ldr	r4, [pc, #-2444]	; bfe0 <POTENG+0xe30>
                                if (KC <= 0) {
                                    for (K = 9; K <  14; K++)  {
                                        RL[K]=sqrt(XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K]);
                                    }

                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
    c968:	e1c320d0 	ldrd	r2, [r3]
    c96c:	eb002063 	bl	14b00 <__aeabi_dmul>
    c970:	e1cd25d0 	ldrd	r2, [sp, #80]	; 0x50
    c974:	eb001f5d 	bl	146f0 <__adddf3>
    c978:	e1cd06f0 	strd	r0, [sp, #96]	; 0x60
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
    c97c:	e28d0c02 	add	r0, sp, #512	; 0x200
    c980:	e1c02fd0 	ldrd	r2, [r0, #240]	; 0xf0
    c984:	e8941001 	ldm	r4, {r0, ip}
    c988:	e28c1102 	add	r1, ip, #-2147483648	; 0x80000000
    c98c:	eb00205b 	bl	14b00 <__aeabi_dmul>
    c990:	eb007484 	bl	29ba8 <exp>
    c994:	e1cd04f0 	strd	r0, [sp, #64]	; 0x40
    c998:	e8941001 	ldm	r4, {r0, ip}
    c99c:	e28d1c02 	add	r1, sp, #512	; 0x200
    c9a0:	e1c12fd8 	ldrd	r2, [r1, #248]	; 0xf8
    c9a4:	e28c1102 	add	r1, ip, #-2147483648	; 0x80000000
    c9a8:	eb002054 	bl	14b00 <__aeabi_dmul>
    c9ac:	eb00747d 	bl	29ba8 <exp>
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
    c9b0:	e28d5c03 	add	r5, sp, #768	; 0x300
    c9b4:	e1c520d0 	ldrd	r2, [r5]
                                    for (K = 9; K <  14; K++)  {
                                        RL[K]=sqrt(XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K]);
                                    }

                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
    c9b8:	e1cd05f0 	strd	r0, [sp, #80]	; 0x50
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
    c9bc:	e8941001 	ldm	r4, {r0, ip}
    c9c0:	e28c1102 	add	r1, ip, #-2147483648	; 0x80000000
    c9c4:	eb00204d 	bl	14b00 <__aeabi_dmul>
    c9c8:	eb007476 	bl	29ba8 <exp>
    c9cc:	e28dcb01 	add	ip, sp, #1024	; 0x400
    c9d0:	e14c2fd8 	ldrd	r2, [ip, #-248]	; 0xffffff08
    c9d4:	e1a08000 	mov	r8, r0
    c9d8:	e8941001 	ldm	r4, {r0, ip}
    c9dc:	e1a09001 	mov	r9, r1
    c9e0:	e28c1102 	add	r1, ip, #-2147483648	; 0x80000000
    c9e4:	eb002045 	bl	14b00 <__aeabi_dmul>
    c9e8:	eb00746e 	bl	29ba8 <exp>
                                    for (K = 9; K <  14; K++)  {
                                        RL[K]=sqrt(XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K]);
                                    }

                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
    c9ec:	e1cd25d0 	ldrd	r2, [sp, #80]	; 0x50
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
    c9f0:	e1a04000 	mov	r4, r0
    c9f4:	e1a05001 	mov	r5, r1
                                    for (K = 9; K <  14; K++)  {
                                        RL[K]=sqrt(XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K]);
                                    }

                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
    c9f8:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    c9fc:	eb001f3b 	bl	146f0 <__adddf3>
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
    ca00:	e1a02008 	mov	r2, r8
    ca04:	e1a03009 	mov	r3, r9
    ca08:	eb001f38 	bl	146f0 <__adddf3>
    ca0c:	e1a02004 	mov	r2, r4
    ca10:	e1a03005 	mov	r3, r5
    ca14:	eb001f35 	bl	146f0 <__adddf3>
                                    for (K = 9; K <  14; K++)  {
                                        RL[K]=sqrt(XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K]);
                                    }

                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
    ca18:	e51f3a3c 	ldr	r3, [pc, #-2620]	; bfe4 <POTENG+0xe34>
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
                                            +A3*(exp(-B3*RL[10])+exp(-B3*RL[11])
    ca1c:	e51f7a3c 	ldr	r7, [pc, #-2620]	; bfe8 <POTENG+0xe38>
                                    for (K = 9; K <  14; K++)  {
                                        RL[K]=sqrt(XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K]);
                                    }

                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
    ca20:	e1c320d0 	ldrd	r2, [r3]
    ca24:	eb002035 	bl	14b00 <__aeabi_dmul>
    ca28:	e1a02000 	mov	r2, r0
    ca2c:	e1a03001 	mov	r3, r1
    ca30:	e1cd06d0 	ldrd	r0, [sp, #96]	; 0x60
    ca34:	eb001f2d 	bl	146f0 <__adddf3>
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
                                            +A3*(exp(-B3*RL[10])+exp(-B3*RL[11])
    ca38:	e28d5b01 	add	r5, sp, #1024	; 0x400
    ca3c:	e1454ed8 	ldrd	r4, [r5, #-232]	; 0xffffff18
                                    for (K = 9; K <  14; K++)  {
                                        RL[K]=sqrt(XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K]);
                                    }

                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
    ca40:	e1cd08f0 	strd	r0, [sp, #128]	; 0x80
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
                                            +A3*(exp(-B3*RL[10])+exp(-B3*RL[11])
    ca44:	e8971001 	ldm	r7, {r0, ip}
    ca48:	e1a02004 	mov	r2, r4
    ca4c:	e1a03005 	mov	r3, r5
    ca50:	e28c1102 	add	r1, ip, #-2147483648	; 0x80000000
    ca54:	e1cd44f0 	strd	r4, [sp, #64]	; 0x40
    ca58:	eb002028 	bl	14b00 <__aeabi_dmul>
    ca5c:	eb007451 	bl	29ba8 <exp>
    ca60:	e28d5b01 	add	r5, sp, #1024	; 0x400
    ca64:	e1454ed0 	ldrd	r4, [r5, #-224]	; 0xffffff20
    ca68:	e1cd06f0 	strd	r0, [sp, #96]	; 0x60
    ca6c:	e8971001 	ldm	r7, {r0, ip}
    ca70:	e1a02004 	mov	r2, r4
    ca74:	e1a03005 	mov	r3, r5
    ca78:	e28c1102 	add	r1, ip, #-2147483648	; 0x80000000
    ca7c:	e1cd45f0 	strd	r4, [sp, #80]	; 0x50
    ca80:	eb00201e 	bl	14b00 <__aeabi_dmul>
    ca84:	eb007447 	bl	29ba8 <exp>
                                                 +exp(-B3*RL[12])+exp(-B3*RL[13]))
    ca88:	e28dcb01 	add	ip, sp, #1024	; 0x400
    ca8c:	e14c8dd8 	ldrd	r8, [ip, #-216]	; 0xffffff28
                                    }

                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
                                            +A3*(exp(-B3*RL[10])+exp(-B3*RL[11])
    ca90:	e1cd07f0 	strd	r0, [sp, #112]	; 0x70
                                                 +exp(-B3*RL[12])+exp(-B3*RL[13]))
    ca94:	e8971001 	ldm	r7, {r0, ip}
    ca98:	e1a02008 	mov	r2, r8
    ca9c:	e28c1102 	add	r1, ip, #-2147483648	; 0x80000000
    caa0:	e1a03009 	mov	r3, r9
    caa4:	eb002015 	bl	14b00 <__aeabi_dmul>
    caa8:	eb00743e 	bl	29ba8 <exp>
    caac:	e28deb01 	add	lr, sp, #1024	; 0x400
    cab0:	e14e4dd0 	ldrd	r4, [lr, #-208]	; 0xffffff30
    cab4:	e1cd06f8 	strd	r0, [sp, #104]	; 0x68
    cab8:	e8970009 	ldm	r7, {r0, r3}
    cabc:	e1a02004 	mov	r2, r4
    cac0:	e2831102 	add	r1, r3, #-2147483648	; 0x80000000
    cac4:	e1a03005 	mov	r3, r5
    cac8:	eb00200c 	bl	14b00 <__aeabi_dmul>
    cacc:	eb007435 	bl	29ba8 <exp>
                                    }

                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
                                            +A3*(exp(-B3*RL[10])+exp(-B3*RL[11])
    cad0:	e1cd27d0 	ldrd	r2, [sp, #112]	; 0x70
                                                 +exp(-B3*RL[12])+exp(-B3*RL[13]))
    cad4:	e1cd07f8 	strd	r0, [sp, #120]	; 0x78
                                    }

                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
                                            +A3*(exp(-B3*RL[10])+exp(-B3*RL[11])
    cad8:	e1cd06d0 	ldrd	r0, [sp, #96]	; 0x60
    cadc:	eb001f03 	bl	146f0 <__adddf3>
                                                 +exp(-B3*RL[12])+exp(-B3*RL[13]))
    cae0:	e1cd26d8 	ldrd	r2, [sp, #104]	; 0x68
    cae4:	eb001f01 	bl	146f0 <__adddf3>
    cae8:	e1cd27d8 	ldrd	r2, [sp, #120]	; 0x78
    caec:	eb001eff 	bl	146f0 <__adddf3>
                                    }

                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
                                            +A3*(exp(-B3*RL[10])+exp(-B3*RL[11])
    caf0:	e51f3b0c 	ldr	r3, [pc, #-2828]	; bfec <POTENG+0xe3c>
                                                 +exp(-B3*RL[12])+exp(-B3*RL[13]))
                                                -A4*(exp(-B4*RL[10])+exp(-B4*RL[11])
    caf4:	e51f6b0c 	ldr	r6, [pc, #-2828]	; bff0 <POTENG+0xe40>
                                    }

                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
                                            +A3*(exp(-B3*RL[10])+exp(-B3*RL[11])
    caf8:	e1c320d0 	ldrd	r2, [r3]
    cafc:	eb001fff 	bl	14b00 <__aeabi_dmul>
    cb00:	e1a02000 	mov	r2, r0
    cb04:	e1a03001 	mov	r3, r1
    cb08:	e1cd08d0 	ldrd	r0, [sp, #128]	; 0x80
    cb0c:	eb001ef7 	bl	146f0 <__adddf3>
                                                 +exp(-B3*RL[12])+exp(-B3*RL[13]))
                                                -A4*(exp(-B4*RL[10])+exp(-B4*RL[11])
    cb10:	e8961004 	ldm	r6, {r2, ip}
                                    }

                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
                                            +A3*(exp(-B3*RL[10])+exp(-B3*RL[11])
    cb14:	e1cd06f0 	strd	r0, [sp, #96]	; 0x60
                                                 +exp(-B3*RL[12])+exp(-B3*RL[13]))
                                                -A4*(exp(-B4*RL[10])+exp(-B4*RL[11])
    cb18:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    cb1c:	e28c3102 	add	r3, ip, #-2147483648	; 0x80000000
    cb20:	eb001ff6 	bl	14b00 <__aeabi_dmul>
    cb24:	eb00741f 	bl	29ba8 <exp>
    cb28:	e8961004 	ldm	r6, {r2, ip}
    cb2c:	e1cd04f0 	strd	r0, [sp, #64]	; 0x40
    cb30:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    cb34:	e28c3102 	add	r3, ip, #-2147483648	; 0x80000000
    cb38:	eb001ff0 	bl	14b00 <__aeabi_dmul>
    cb3c:	eb007419 	bl	29ba8 <exp>
                                                     +exp(-B4*RL[12])+exp(-B4*RL[13]));
    cb40:	e8961004 	ldm	r6, {r2, ip}
                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
                                            +A3*(exp(-B3*RL[10])+exp(-B3*RL[11])
                                                 +exp(-B3*RL[12])+exp(-B3*RL[13]))
                                                -A4*(exp(-B4*RL[10])+exp(-B4*RL[11])
    cb44:	e1cd05f0 	strd	r0, [sp, #80]	; 0x50
                                                     +exp(-B4*RL[12])+exp(-B4*RL[13]));
    cb48:	e28c3102 	add	r3, ip, #-2147483648	; 0x80000000
    cb4c:	e1a00008 	mov	r0, r8
    cb50:	e1a01009 	mov	r1, r9
    cb54:	eb001fe9 	bl	14b00 <__aeabi_dmul>
    cb58:	eb007412 	bl	29ba8 <exp>
    cb5c:	e8961004 	ldm	r6, {r2, ip}
    cb60:	e1a08000 	mov	r8, r0
    cb64:	e28c3102 	add	r3, ip, #-2147483648	; 0x80000000
    cb68:	e1a09001 	mov	r9, r1
    cb6c:	e1a00004 	mov	r0, r4
    cb70:	e1a01005 	mov	r1, r5
    cb74:	eb001fe1 	bl	14b00 <__aeabi_dmul>
    cb78:	eb00740a 	bl	29ba8 <exp>
                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
                                            +A3*(exp(-B3*RL[10])+exp(-B3*RL[11])
                                                 +exp(-B3*RL[12])+exp(-B3*RL[13]))
                                                -A4*(exp(-B4*RL[10])+exp(-B4*RL[11])
    cb7c:	e1cd25d0 	ldrd	r2, [sp, #80]	; 0x50
                                                     +exp(-B4*RL[12])+exp(-B4*RL[13]));
    cb80:	e1a04000 	mov	r4, r0
    cb84:	e1a05001 	mov	r5, r1
                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
                                            +A3*(exp(-B3*RL[10])+exp(-B3*RL[11])
                                                 +exp(-B3*RL[12])+exp(-B3*RL[13]))
                                                -A4*(exp(-B4*RL[10])+exp(-B4*RL[11])
    cb88:	e1cd04d0 	ldrd	r0, [sp, #64]	; 0x40
    cb8c:	eb001ed7 	bl	146f0 <__adddf3>
                                                     +exp(-B4*RL[12])+exp(-B4*RL[13]));
    cb90:	e1a02008 	mov	r2, r8
    cb94:	e1a03009 	mov	r3, r9
    cb98:	eb001ed4 	bl	146f0 <__adddf3>
    cb9c:	e1a02004 	mov	r2, r4
    cba0:	e1a03005 	mov	r3, r5
    cba4:	eb001ed1 	bl	146f0 <__adddf3>
                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
                                        +A2*(exp(-B2*RL[ 5])+exp(-B2*RL[ 6])
                                             +exp(-B2*RL[ 7])+exp(-B2*RL[ 8]))
                                            +A3*(exp(-B3*RL[10])+exp(-B3*RL[11])
                                                 +exp(-B3*RL[12])+exp(-B3*RL[13]))
                                                -A4*(exp(-B4*RL[10])+exp(-B4*RL[11])
    cba8:	e51f3bbc 	ldr	r3, [pc, #-3004]	; bff4 <POTENG+0xe44>
    cbac:	e1c320d0 	ldrd	r2, [r3]
    cbb0:	eb001fd2 	bl	14b00 <__aeabi_dmul>
    cbb4:	e1a02000 	mov	r2, r0
    cbb8:	e1a03001 	mov	r3, r1
                                if (KC <= 0) {
                                    for (K = 9; K <  14; K++)  {
                                        RL[K]=sqrt(XL[K]*XL[K]+YL[K]*YL[K]+ZL[K]*ZL[K]);
                                    }

                                    LPOTR= LPOTR+A1* exp(-B1*RL[9])
    cbbc:	e1cd06d0 	ldrd	r0, [sp, #96]	; 0x60
    cbc0:	eb001ec9 	bl	146ec <__aeabi_dsub>
    cbc4:	e1cd05f0 	strd	r0, [sp, #80]	; 0x50
    cbc8:	eaffff26 	b	c868 <POTENG+0x16b8>
                        while (curr_ptr) {

                            /* Don't do interaction with same molecule */

                            if (curr_ptr == neighbor_ptr) {
                                curr_ptr = curr_ptr->next_mol;
    cbcc:	e59c52a0 	ldr	r5, [ip, #672]	; 0x2a0
    cbd0:	e58d5088 	str	r5, [sp, #136]	; 0x88
                                continue;
    cbd4:	eaffff27 	b	c878 <POTENG+0x16c8>
                    else if (Z_NUM >= BOX_PER_SIDE)
                        Z_NUM -= BOX_PER_SIDE;


                    /* Don't do current box more than once */
                    if ((X_NUM == i) && (Y_NUM == j) && (Z_NUM == k) &&
    cbd8:	e59dc0e4 	ldr	ip, [sp, #228]	; 0xe4
    cbdc:	e35c0000 	cmp	ip, #0
    cbe0:	1a000002 	bne	cbf0 <POTENG+0x1a40>
                        ((XBOX != i) || (YBOX != j) || (ZBOX !=k))) {
    cbe4:	e59d4098 	ldr	r4, [sp, #152]	; 0x98
    cbe8:	e1540002 	cmp	r4, r2
    cbec:	0afffc40 	beq	bcf4 <POTENG+0xb44>

        /* loop over nearest neighbor boxes */

        for (XBOX=i-1; XBOX<=i+1; XBOX++) {
            for (YBOX=j-1; YBOX<=j+1; YBOX++) {
                for (ZBOX=k-1; ZBOX<=k+1; ZBOX++) {
    cbf0:	e59d4098 	ldr	r4, [sp, #152]	; 0x98
    cbf4:	e59d50bc 	ldr	r5, [sp, #188]	; 0xbc
    cbf8:	e2844001 	add	r4, r4, #1
    cbfc:	e1540005 	cmp	r4, r5
    cc00:	e58d4098 	str	r4, [sp, #152]	; 0x98
    cc04:	dafffc18 	ble	bc6c <POTENG+0xabc>
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        /* loop over nearest neighbor boxes */

        for (XBOX=i-1; XBOX<=i+1; XBOX++) {
            for (YBOX=j-1; YBOX<=j+1; YBOX++) {
    cc08:	e59dc0a0 	ldr	ip, [sp, #160]	; 0xa0
    cc0c:	e59d40c8 	ldr	r4, [sp, #200]	; 0xc8
    cc10:	e28cc001 	add	ip, ip, #1
    cc14:	e15c0004 	cmp	ip, r4
    cc18:	e58dc0a0 	str	ip, [sp, #160]	; 0xa0
    cc1c:	dafffbfe 	ble	bc1c <POTENG+0xa6c>
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        /* loop over nearest neighbor boxes */

        for (XBOX=i-1; XBOX<=i+1; XBOX++) {
    cc20:	e59d509c 	ldr	r5, [sp, #156]	; 0x9c
    cc24:	e59dc0c0 	ldr	ip, [sp, #192]	; 0xc0
    cc28:	e2855001 	add	r5, r5, #1
    cc2c:	e155000c 	cmp	r5, ip
    cc30:	e58d509c 	str	r5, [sp, #156]	; 0x9c
    cc34:	dafffbee 	ble	bbf4 <POTENG+0xa44>
                        neighbor_ptr = neighbor_ptr->next_mol;
                    }
                }
            }
        } /* neighbor boxes for loops */
        curr_box = curr_box->next_box;
    cc38:	e59d40a4 	ldr	r4, [sp, #164]	; 0xa4
    cc3c:	e594400c 	ldr	r4, [r4, #12]
    /*  compute inter-molecular potential energy */

    LPOTR=0.0;
    LPTRF=0.0;
    curr_box = my_boxes[ProcID];
    while (curr_box) {
    cc40:	e3540000 	cmp	r4, #0
                        neighbor_ptr = neighbor_ptr->next_mol;
                    }
                }
            }
        } /* neighbor boxes for loops */
        curr_box = curr_box->next_box;
    cc44:	e58d40a4 	str	r4, [sp, #164]	; 0xa4
    /*  compute inter-molecular potential energy */

    LPOTR=0.0;
    LPTRF=0.0;
    curr_box = my_boxes[ProcID];
    while (curr_box) {
    cc48:	1afffbc6 	bne	bb68 <POTENG+0x9b8>
    cc4c:	e3a02000 	mov	r2, #0
    cc50:	e1cd05d0 	ldrd	r0, [sp, #80]	; 0x50
    cc54:	e51f3c64 	ldr	r3, [pc, #-3172]	; bff8 <POTENG+0xe48>
    cc58:	eb001fa8 	bl	14b00 <__aeabi_dmul>
    cc5c:	e3a02000 	mov	r2, #0
    cc60:	e1a04000 	mov	r4, r0
    cc64:	e1a05001 	mov	r5, r1
    cc68:	e1cd05d8 	ldrd	r0, [sp, #88]	; 0x58
    cc6c:	e51f3c7c 	ldr	r3, [pc, #-3196]	; bff8 <POTENG+0xe48>
    cc70:	eb001fa2 	bl	14b00 <__aeabi_dmul>
    cc74:	e1a06000 	mov	r6, r0
    cc78:	e1a07001 	mov	r7, r1
    cc7c:	ea000010 	b	ccc4 <POTENG+0x1b14>

                    X_NUM = XBOX;
                    Y_NUM = YBOX;
                    Z_NUM = ZBOX;

                    if ((BOX_PER_SIDE == 2) && ((XBOX < 0) || (XBOX == 2) ||
    cc80:	e59dc0dc 	ldr	ip, [sp, #220]	; 0xdc
    cc84:	e35c0000 	cmp	ip, #0
    cc88:	1affffd8 	bne	cbf0 <POTENG+0x1a40>
                                                (YBOX < 0) || (YBOX == 2) ||
    cc8c:	e59d40e0 	ldr	r4, [sp, #224]	; 0xe0
    cc90:	e3540000 	cmp	r4, #0
    cc94:	1affffd5 	bne	cbf0 <POTENG+0x1a40>
                                                (ZBOX < 0) || (ZBOX == 2)))
    cc98:	e59d5098 	ldr	r5, [sp, #152]	; 0x98
    cc9c:	e2452002 	sub	r2, r5, #2
    cca0:	e16f2f12 	clz	r2, r2
    cca4:	e1a022a2 	lsr	r2, r2, #5
    cca8:	e1925fa5 	orrs	r5, r2, r5, lsr #31
    ccac:	1affffcf 	bne	cbf0 <POTENG+0x1a40>
    ccb0:	eafffbf5 	b	bc8c <POTENG+0xadc>
    /*  compute inter-molecular potential energy */

    LPOTR=0.0;
    LPTRF=0.0;
    curr_box = my_boxes[ProcID];
    while (curr_box) {
    ccb4:	e3a06000 	mov	r6, #0
    ccb8:	e3a07000 	mov	r7, #0
    ccbc:	e1a04006 	mov	r4, r6
    ccc0:	e1a05007 	mov	r5, r7
    LPOTR = LPOTR/2.0;
    LPTRF = LPTRF/2.0;

    /* update shared sums from computed private sums */

    LOCK(gl->PotengSumLock);
    ccc4:	e51fccd0 	ldr	ip, [pc, #-3280]	; bffc <POTENG+0xe4c>
    ccc8:	e59c0000 	ldr	r0, [ip]
    cccc:	e280003c 	add	r0, r0, #60	; 0x3c
    ccd0:	ebffcec7 	bl	7f4 <pthread_mutex_lock>
    *POTA = *POTA + LPOTA;
    ccd4:	e1cd2bd0 	ldrd	r2, [sp, #176]	; 0xb0
    ccd8:	e59dc0d0 	ldr	ip, [sp, #208]	; 0xd0
    ccdc:	e1cc00d0 	ldrd	r0, [ip]
    cce0:	eb001e82 	bl	146f0 <__adddf3>
    cce4:	e59dc0d0 	ldr	ip, [sp, #208]	; 0xd0
    *POTR = *POTR + LPOTR;
    cce8:	e1a02004 	mov	r2, r4
    LPTRF = LPTRF/2.0;

    /* update shared sums from computed private sums */

    LOCK(gl->PotengSumLock);
    *POTA = *POTA + LPOTA;
    ccec:	e1cc00f0 	strd	r0, [ip]
    *POTR = *POTR + LPOTR;
    ccf0:	e59d40d4 	ldr	r4, [sp, #212]	; 0xd4
    ccf4:	e1a03005 	mov	r3, r5
    ccf8:	e1c400d0 	ldrd	r0, [r4]
    ccfc:	eb001e7b 	bl	146f0 <__adddf3>
    cd00:	e1c400f0 	strd	r0, [r4]
    *PTRF = *PTRF + LPTRF;
    cd04:	e59d50d8 	ldr	r5, [sp, #216]	; 0xd8
    cd08:	e1a02006 	mov	r2, r6
    cd0c:	e1c500d0 	ldrd	r0, [r5]
    cd10:	e1a03007 	mov	r3, r7
    cd14:	eb001e75 	bl	146f0 <__adddf3>
    UNLOCK(gl->PotengSumLock);
    cd18:	e51fcd24 	ldr	ip, [pc, #-3364]	; bffc <POTENG+0xe4c>
    cd1c:	e59c3000 	ldr	r3, [ip]
    /* update shared sums from computed private sums */

    LOCK(gl->PotengSumLock);
    *POTA = *POTA + LPOTA;
    *POTR = *POTR + LPOTR;
    *PTRF = *PTRF + LPTRF;
    cd20:	e1c500f0 	strd	r0, [r5]
    UNLOCK(gl->PotengSumLock);
    cd24:	e283003c 	add	r0, r3, #60	; 0x3c
    cd28:	ebffd18b 	bl	135c <pthread_mutex_unlock>

} /* end of subroutine POTENG */
    cd2c:	e28ddfd1 	add	sp, sp, #836	; 0x344
    cd30:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    } /* while curr_box */


    BARRIER(gl->PotengBar, NumProcs);
    cd34:	e16f4f14 	clz	r4, r4
    cd38:	e1a042a4 	lsr	r4, r4, #5
    cd3c:	e5834098 	str	r4, [r3, #152]	; 0x98
    cd40:	e5831094 	str	r1, [r3, #148]	; 0x94
    cd44:	e283008c 	add	r0, r3, #140	; 0x8c
    cd48:	ebffcee2 	bl	8d8 <pthread_cond_broadcast>
    cd4c:	eafffb76 	b	bb2c <POTENG+0x97c>
    cd50:	e51f0d58 	ldr	r0, [pc, #-3416]	; c000 <POTENG+0xe50>
    cd54:	eb002fb6 	bl	18c34 <puts>
    cd58:	e3e00000 	mvn	r0, #0
    cd5c:	eb0023af 	bl	15c20 <exit>

0000cd60 <KINETI>:
#include "global.h"

/* this routine computes kinetic energy in each of the three spatial
   dimensions, and puts the computed values in the SUM array */
void KINETI(double *SUM, double HMAS, double OMAS, long ProcID)
{
    cd60:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    struct list_of_boxes *curr_box;
    double *tempptr;

    /* Loop over three directions */

    for (dir = XDIR; dir <= ZDIR; dir++) {
    cd64:	e3a04000 	mov	r4, #0
#include "global.h"

/* this routine computes kinetic energy in each of the three spatial
   dimensions, and puts the computed values in the SUM array */
void KINETI(double *SUM, double HMAS, double OMAS, long ProcID)
{
    cd68:	e24dd02c 	sub	sp, sp, #44	; 0x2c
    cd6c:	e1cd20f8 	strd	r2, [sp, #8]
    cd70:	e59d3058 	ldr	r3, [sp, #88]	; 0x58
    cd74:	e58d0020 	str	r0, [sp, #32]
    cd78:	e1a03103 	lsl	r3, r3, #2
    struct list_of_boxes *curr_box;
    double *tempptr;

    /* Loop over three directions */

    for (dir = XDIR; dir <= ZDIR; dir++) {
    cd7c:	e58d401c 	str	r4, [sp, #28]
    cd80:	e58d3024 	str	r3, [sp, #36]	; 0x24
        S=0.0;

        /* loop over processor's boxes */
        curr_box = my_boxes[ProcID];
    cd84:	e59f5180 	ldr	r5, [pc, #384]	; cf0c <KINETI+0x1ac>
    cd88:	e59d4024 	ldr	r4, [sp, #36]	; 0x24
    cd8c:	e5953000 	ldr	r3, [r5]
    double *tempptr;

    /* Loop over three directions */

    for (dir = XDIR; dir <= ZDIR; dir++) {
        S=0.0;
    cd90:	e3a06000 	mov	r6, #0

        /* loop over processor's boxes */
        curr_box = my_boxes[ProcID];
    cd94:	e7933004 	ldr	r3, [r3, r4]
    double *tempptr;

    /* Loop over three directions */

    for (dir = XDIR; dir <= ZDIR; dir++) {
        S=0.0;
    cd98:	e3a07000 	mov	r7, #0

        /* loop over processor's boxes */
        curr_box = my_boxes[ProcID];

        while (curr_box) {
    cd9c:	e3530000 	cmp	r3, #0

    for (dir = XDIR; dir <= ZDIR; dir++) {
        S=0.0;

        /* loop over processor's boxes */
        curr_box = my_boxes[ProcID];
    cda0:	e58d3014 	str	r3, [sp, #20]

        while (curr_box) {
    cda4:	0a000042 	beq	ceb4 <KINETI+0x154>

            /* loop over the molecules */

            curr_ptr = BOX[i][j][k].list;
            while (curr_ptr) {
                tempptr = curr_ptr->mol.F[VEL][dir];
    cda8:	e59d501c 	ldr	r5, [sp, #28]
    cdac:	e59f415c 	ldr	r4, [pc, #348]	; cf10 <KINETI+0x1b0>
    cdb0:	e085b085 	add	fp, r5, r5, lsl #1
    cdb4:	e5944000 	ldr	r4, [r4]
    cdb8:	e1a0b18b 	lsl	fp, fp, #3
    cdbc:	e59d5014 	ldr	r5, [sp, #20]
    cdc0:	e58d4018 	str	r4, [sp, #24]
    cdc4:	e28bb060 	add	fp, fp, #96	; 0x60
            j = curr_box->coord[YDIR];  /* Y coordinate of box */
            k = curr_box->coord[ZDIR];  /* Z coordinate of box */

            /* loop over the molecules */

            curr_ptr = BOX[i][j][k].list;
    cdc8:	e5953000 	ldr	r3, [r5]
    cdcc:	e59d4018 	ldr	r4, [sp, #24]
    cdd0:	e5951004 	ldr	r1, [r5, #4]
    cdd4:	e7943103 	ldr	r3, [r4, r3, lsl #2]
    cdd8:	e5952008 	ldr	r2, [r5, #8]
    cddc:	e7933101 	ldr	r3, [r3, r1, lsl #2]
    cde0:	e793a202 	ldr	sl, [r3, r2, lsl #4]
            while (curr_ptr) {
    cde4:	e35a0000 	cmp	sl, #0
    cde8:	0a00002c 	beq	cea0 <KINETI+0x140>
                tempptr = curr_ptr->mol.F[VEL][dir];
                S += (tempptr[H1] * tempptr[H1] +
    cdec:	e18a00db 	ldrd	r0, [sl, fp]

            /* loop over the molecules */

            curr_ptr = BOX[i][j][k].list;
            while (curr_ptr) {
                tempptr = curr_ptr->mol.F[VEL][dir];
    cdf0:	e08ac00b 	add	ip, sl, fp
                S += (tempptr[H1] * tempptr[H1] +
    cdf4:	e1a02000 	mov	r2, r0
                      tempptr[H2] * tempptr[H2] ) * HMAS +
                          (tempptr[O] * tempptr[O]) * OMAS;
    cdf8:	e1cc80d8 	ldrd	r8, [ip, #8]

            curr_ptr = BOX[i][j][k].list;
            while (curr_ptr) {
                tempptr = curr_ptr->mol.F[VEL][dir];
                S += (tempptr[H1] * tempptr[H1] +
                      tempptr[H2] * tempptr[H2] ) * HMAS +
    cdfc:	e1cc41d0 	ldrd	r4, [ip, #16]
            /* loop over the molecules */

            curr_ptr = BOX[i][j][k].list;
            while (curr_ptr) {
                tempptr = curr_ptr->mol.F[VEL][dir];
                S += (tempptr[H1] * tempptr[H1] +
    ce00:	e1a03001 	mov	r3, r1
                      tempptr[H2] * tempptr[H2] ) * HMAS +
    ce04:	e1cd40f0 	strd	r4, [sp]
            /* loop over the molecules */

            curr_ptr = BOX[i][j][k].list;
            while (curr_ptr) {
                tempptr = curr_ptr->mol.F[VEL][dir];
                S += (tempptr[H1] * tempptr[H1] +
    ce08:	eb001f3c 	bl	14b00 <__aeabi_dmul>
    ce0c:	e1a04000 	mov	r4, r0
    ce10:	e1a05001 	mov	r5, r1
                      tempptr[H2] * tempptr[H2] ) * HMAS +
    ce14:	e1cd00d0 	ldrd	r0, [sp]
    ce18:	e1a02000 	mov	r2, r0
    ce1c:	e1a03001 	mov	r3, r1
    ce20:	eb001f36 	bl	14b00 <__aeabi_dmul>
    ce24:	e1a02000 	mov	r2, r0
    ce28:	e1a03001 	mov	r3, r1
            /* loop over the molecules */

            curr_ptr = BOX[i][j][k].list;
            while (curr_ptr) {
                tempptr = curr_ptr->mol.F[VEL][dir];
                S += (tempptr[H1] * tempptr[H1] +
    ce2c:	e1a00004 	mov	r0, r4
    ce30:	e1a01005 	mov	r1, r5
    ce34:	eb001e2d 	bl	146f0 <__adddf3>
                      tempptr[H2] * tempptr[H2] ) * HMAS +
    ce38:	e1cd20d8 	ldrd	r2, [sp, #8]
    ce3c:	eb001f2f 	bl	14b00 <__aeabi_dmul>
                          (tempptr[O] * tempptr[O]) * OMAS;
    ce40:	e1a02008 	mov	r2, r8

            curr_ptr = BOX[i][j][k].list;
            while (curr_ptr) {
                tempptr = curr_ptr->mol.F[VEL][dir];
                S += (tempptr[H1] * tempptr[H1] +
                      tempptr[H2] * tempptr[H2] ) * HMAS +
    ce44:	e1a04000 	mov	r4, r0
    ce48:	e1a05001 	mov	r5, r1
                          (tempptr[O] * tempptr[O]) * OMAS;
    ce4c:	e1a03009 	mov	r3, r9
    ce50:	e1a00008 	mov	r0, r8
    ce54:	e1a01009 	mov	r1, r9
    ce58:	eb001f28 	bl	14b00 <__aeabi_dmul>
    ce5c:	e1cd25d0 	ldrd	r2, [sp, #80]	; 0x50
    ce60:	eb001f26 	bl	14b00 <__aeabi_dmul>
    ce64:	e1a02000 	mov	r2, r0
    ce68:	e1a03001 	mov	r3, r1

            curr_ptr = BOX[i][j][k].list;
            while (curr_ptr) {
                tempptr = curr_ptr->mol.F[VEL][dir];
                S += (tempptr[H1] * tempptr[H1] +
                      tempptr[H2] * tempptr[H2] ) * HMAS +
    ce6c:	e1a00004 	mov	r0, r4
    ce70:	e1a01005 	mov	r1, r5
    ce74:	eb001e1d 	bl	146f0 <__adddf3>
    ce78:	e1a02000 	mov	r2, r0
    ce7c:	e1a03001 	mov	r3, r1
            /* loop over the molecules */

            curr_ptr = BOX[i][j][k].list;
            while (curr_ptr) {
                tempptr = curr_ptr->mol.F[VEL][dir];
                S += (tempptr[H1] * tempptr[H1] +
    ce80:	e1a00006 	mov	r0, r6
    ce84:	e1a01007 	mov	r1, r7
    ce88:	eb001e18 	bl	146f0 <__adddf3>
                      tempptr[H2] * tempptr[H2] ) * HMAS +
                          (tempptr[O] * tempptr[O]) * OMAS;
                curr_ptr = curr_ptr->next_mol;
    ce8c:	e59aa2a0 	ldr	sl, [sl, #672]	; 0x2a0
            /* loop over the molecules */

            curr_ptr = BOX[i][j][k].list;
            while (curr_ptr) {
                tempptr = curr_ptr->mol.F[VEL][dir];
                S += (tempptr[H1] * tempptr[H1] +
    ce90:	e1a06000 	mov	r6, r0
            k = curr_box->coord[ZDIR];  /* Z coordinate of box */

            /* loop over the molecules */

            curr_ptr = BOX[i][j][k].list;
            while (curr_ptr) {
    ce94:	e35a0000 	cmp	sl, #0
                tempptr = curr_ptr->mol.F[VEL][dir];
                S += (tempptr[H1] * tempptr[H1] +
    ce98:	e1a07001 	mov	r7, r1
            k = curr_box->coord[ZDIR];  /* Z coordinate of box */

            /* loop over the molecules */

            curr_ptr = BOX[i][j][k].list;
            while (curr_ptr) {
    ce9c:	1affffd2 	bne	cdec <KINETI+0x8c>
                      tempptr[H2] * tempptr[H2] ) * HMAS +
                          (tempptr[O] * tempptr[O]) * OMAS;
                curr_ptr = curr_ptr->next_mol;
            } /* while curr_ptr */

            curr_box = curr_box->next_box;
    cea0:	e59d5014 	ldr	r5, [sp, #20]
    cea4:	e595500c 	ldr	r5, [r5, #12]
        S=0.0;

        /* loop over processor's boxes */
        curr_box = my_boxes[ProcID];

        while (curr_box) {
    cea8:	e3550000 	cmp	r5, #0
                      tempptr[H2] * tempptr[H2] ) * HMAS +
                          (tempptr[O] * tempptr[O]) * OMAS;
                curr_ptr = curr_ptr->next_mol;
            } /* while curr_ptr */

            curr_box = curr_box->next_box;
    ceac:	e58d5014 	str	r5, [sp, #20]
        S=0.0;

        /* loop over processor's boxes */
        curr_box = my_boxes[ProcID];

        while (curr_box) {
    ceb0:	1affffc4 	bne	cdc8 <KINETI+0x68>

            curr_box = curr_box->next_box;

        } /* while curr_box */

        LOCK(gl->KinetiSumLock);
    ceb4:	e59f2058 	ldr	r2, [pc, #88]	; cf14 <KINETI+0x1b4>
    struct list_of_boxes *curr_box;
    double *tempptr;

    /* Loop over three directions */

    for (dir = XDIR; dir <= ZDIR; dir++) {
    ceb8:	e59d401c 	ldr	r4, [sp, #28]

            curr_box = curr_box->next_box;

        } /* while curr_box */

        LOCK(gl->KinetiSumLock);
    cebc:	e5920000 	ldr	r0, [r2]
    struct list_of_boxes *curr_box;
    double *tempptr;

    /* Loop over three directions */

    for (dir = XDIR; dir <= ZDIR; dir++) {
    cec0:	e2844001 	add	r4, r4, #1

            curr_box = curr_box->next_box;

        } /* while curr_box */

        LOCK(gl->KinetiSumLock);
    cec4:	e2800030 	add	r0, r0, #48	; 0x30
    struct list_of_boxes *curr_box;
    double *tempptr;

    /* Loop over three directions */

    for (dir = XDIR; dir <= ZDIR; dir++) {
    cec8:	e58d401c 	str	r4, [sp, #28]

            curr_box = curr_box->next_box;

        } /* while curr_box */

        LOCK(gl->KinetiSumLock);
    cecc:	ebffce48 	bl	7f4 <pthread_mutex_lock>
        SUM[dir]+=S;
    ced0:	e59d5020 	ldr	r5, [sp, #32]
    ced4:	e1a02006 	mov	r2, r6
    ced8:	e1c500d0 	ldrd	r0, [r5]
    cedc:	e1a03007 	mov	r3, r7
    cee0:	eb001e02 	bl	146f0 <__adddf3>
        UNLOCK(gl->KinetiSumLock);
    cee4:	e59f2028 	ldr	r2, [pc, #40]	; cf14 <KINETI+0x1b4>
    cee8:	e5923000 	ldr	r3, [r2]
            curr_box = curr_box->next_box;

        } /* while curr_box */

        LOCK(gl->KinetiSumLock);
        SUM[dir]+=S;
    ceec:	e0c500f8 	strd	r0, [r5], #8
        UNLOCK(gl->KinetiSumLock);
    cef0:	e2830030 	add	r0, r3, #48	; 0x30
            curr_box = curr_box->next_box;

        } /* while curr_box */

        LOCK(gl->KinetiSumLock);
        SUM[dir]+=S;
    cef4:	e58d5020 	str	r5, [sp, #32]
        UNLOCK(gl->KinetiSumLock);
    cef8:	ebffd117 	bl	135c <pthread_mutex_unlock>
    struct list_of_boxes *curr_box;
    double *tempptr;

    /* Loop over three directions */

    for (dir = XDIR; dir <= ZDIR; dir++) {
    cefc:	e3540003 	cmp	r4, #3
    cf00:	1affff9f 	bne	cd84 <KINETI+0x24>
        SUM[dir]+=S;
        UNLOCK(gl->KinetiSumLock);

    } /* for dir */

} /* end of subroutine KINETI */
    cf04:	e28dd02c 	add	sp, sp, #44	; 0x2c
    cf08:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cf0c:	0013efcc 	.word	0x0013efcc
    cf10:	0013f098 	.word	0x0013f098
    cf14:	0013f3f0 	.word	0x0013f3f0

0000cf18 <BNDRY>:
    struct link *curr_ptr, *last_ptr, *next_ptr, *temp_ptr;
    struct list_of_boxes *curr_box;
    double *extra_p;

    /* for each box */
    curr_box = my_boxes[ProcID];
    cf18:	e59f3480 	ldr	r3, [pc, #1152]	; d3a0 <BNDRY+0x488>
#include "mddata.h"
#include "split.h"
#include "global.h"

void BNDRY(long ProcID)     /* this routine puts the molecules back inside the box if they are out */
{
    cf1c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    struct link *curr_ptr, *last_ptr, *next_ptr, *temp_ptr;
    struct list_of_boxes *curr_box;
    double *extra_p;

    /* for each box */
    curr_box = my_boxes[ProcID];
    cf20:	e5933000 	ldr	r3, [r3]
#include "mddata.h"
#include "split.h"
#include "global.h"

void BNDRY(long ProcID)     /* this routine puts the molecules back inside the box if they are out */
{
    cf24:	e24dd034 	sub	sp, sp, #52	; 0x34
    struct link *curr_ptr, *last_ptr, *next_ptr, *temp_ptr;
    struct list_of_boxes *curr_box;
    double *extra_p;

    /* for each box */
    curr_box = my_boxes[ProcID];
    cf28:	e7933100 	ldr	r3, [r3, r0, lsl #2]
    while (curr_box) {
    cf2c:	e3530000 	cmp	r3, #0
    struct link *curr_ptr, *last_ptr, *next_ptr, *temp_ptr;
    struct list_of_boxes *curr_box;
    double *extra_p;

    /* for each box */
    curr_box = my_boxes[ProcID];
    cf30:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    while (curr_box) {
    cf34:	0a000117 	beq	d398 <BNDRY+0x480>
    cf38:	e59fb464 	ldr	fp, [pc, #1124]	; d3a4 <BNDRY+0x48c>
    cf3c:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
        i = curr_box->coord[XDIR];  /* X coordinate of box */
    cf40:	e5900000 	ldr	r0, [r0]
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        last_ptr = NULL;
        curr_ptr = BOX[i][j][k].list;
    cf44:	e59b3000 	ldr	r3, [fp]

    /* for each box */
    curr_box = my_boxes[ProcID];
    while (curr_box) {
        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
    cf48:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        last_ptr = NULL;
        curr_ptr = BOX[i][j][k].list;
    cf4c:	e7933100 	ldr	r3, [r3, r0, lsl #2]

    /* for each box */
    curr_box = my_boxes[ProcID];
    while (curr_box) {
        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
    cf50:	e5911004 	ldr	r1, [r1, #4]
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */
    cf54:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c

        last_ptr = NULL;
        curr_ptr = BOX[i][j][k].list;
    cf58:	e7933101 	ldr	r3, [r3, r1, lsl #2]
    /* for each box */
    curr_box = my_boxes[ProcID];
    while (curr_box) {
        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */
    cf5c:	e5922008 	ldr	r2, [r2, #8]
    double *extra_p;

    /* for each box */
    curr_box = my_boxes[ProcID];
    while (curr_box) {
        i = curr_box->coord[XDIR];  /* X coordinate of box */
    cf60:	e58d0020 	str	r0, [sp, #32]
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        last_ptr = NULL;
        curr_ptr = BOX[i][j][k].list;
    cf64:	e793a202 	ldr	sl, [r3, r2, lsl #4]

    /* for each box */
    curr_box = my_boxes[ProcID];
    while (curr_box) {
        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
    cf68:	e58d1024 	str	r1, [sp, #36]	; 0x24
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */
    cf6c:	e58d2028 	str	r2, [sp, #40]	; 0x28

        last_ptr = NULL;
        curr_ptr = BOX[i][j][k].list;
    cf70:	e1a00100 	lsl	r0, r0, #2
    cf74:	e1a01101 	lsl	r1, r1, #2
    cf78:	e1a02202 	lsl	r2, r2, #4

        /* Go through molecules in current box */

        while (curr_ptr) {
    cf7c:	e35a0000 	cmp	sl, #0
        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        last_ptr = NULL;
        curr_ptr = BOX[i][j][k].list;
    cf80:	e58d0010 	str	r0, [sp, #16]
    cf84:	e58d1014 	str	r1, [sp, #20]
    cf88:	e58d2018 	str	r2, [sp, #24]

        /* Go through molecules in current box */

        while (curr_ptr) {
    cf8c:	0a0000fc 	beq	d384 <BNDRY+0x46c>
    while (curr_box) {
        i = curr_box->coord[XDIR];  /* X coordinate of box */
        j = curr_box->coord[YDIR];  /* Y coordinate of box */
        k = curr_box->coord[ZDIR];  /* Z coordinate of box */

        last_ptr = NULL;
    cf90:	e3a03000 	mov	r3, #0
    cf94:	e58d301c 	str	r3, [sp, #28]
    cf98:	ea000071 	b	d164 <BNDRY+0x24c>
                    /* move all three atoms back in the box */
                    extra_p[H1] -= BOXL;
                    extra_p[O]  -= BOXL;
                    extra_p[H2] -= BOXL;
                }
                else if (extra_p[O] < 0.00) {
    cf9c:	e1a00008 	mov	r0, r8
    cfa0:	e1a01009 	mov	r1, r9
    cfa4:	e3a02000 	mov	r2, #0
    cfa8:	e3a03000 	mov	r3, #0
    cfac:	eb002033 	bl	15080 <__aeabi_dcmplt>
    cfb0:	e3500000 	cmp	r0, #0
    cfb4:	1a0000c0 	bne	d2bc <BNDRY+0x3a4>

            for ( dir = XDIR; dir <= ZDIR; dir++ ) {
                extra_p = curr_ptr->mol.F[DISP][dir];

                /* if the oxygen atom is out of the box */
                if (extra_p[O] > BOXL ) {
    cfb8:	e1ca23d8 	ldrd	r2, [sl, #56]	; 0x38
    cfbc:	e1a00004 	mov	r0, r4
    cfc0:	e1a01005 	mov	r1, r5
    cfc4:	e1cd20f0 	strd	r2, [sp]
    cfc8:	eb00202c 	bl	15080 <__aeabi_dcmplt>
    cfcc:	e3500000 	cmp	r0, #0
    cfd0:	1a000095 	bne	d22c <BNDRY+0x314>
                    /* move all three atoms back in the box */
                    extra_p[H1] -= BOXL;
                    extra_p[O]  -= BOXL;
                    extra_p[H2] -= BOXL;
                }
                else if (extra_p[O] < 0.00) {
    cfd4:	e1cd00d0 	ldrd	r0, [sp]
    cfd8:	e3a02000 	mov	r2, #0
    cfdc:	e3a03000 	mov	r3, #0
    cfe0:	eb002026 	bl	15080 <__aeabi_dcmplt>
    cfe4:	e3500000 	cmp	r0, #0
    cfe8:	1a0000a1 	bne	d274 <BNDRY+0x35c>

            for ( dir = XDIR; dir <= ZDIR; dir++ ) {
                extra_p = curr_ptr->mol.F[DISP][dir];

                /* if the oxygen atom is out of the box */
                if (extra_p[O] > BOXL ) {
    cfec:	e1ca65d0 	ldrd	r6, [sl, #80]	; 0x50
    cff0:	e1a00004 	mov	r0, r4
    cff4:	e1a01005 	mov	r1, r5
    cff8:	e1a02006 	mov	r2, r6
    cffc:	e1a03007 	mov	r3, r7
    d000:	eb00201e 	bl	15080 <__aeabi_dcmplt>
    d004:	e3500000 	cmp	r0, #0
    d008:	1a000074 	bne	d1e0 <BNDRY+0x2c8>
                    /* move all three atoms back in the box */
                    extra_p[H1] -= BOXL;
                    extra_p[O]  -= BOXL;
                    extra_p[H2] -= BOXL;
                }
                else if (extra_p[O] < 0.00) {
    d00c:	e1a00006 	mov	r0, r6
    d010:	e1a01007 	mov	r1, r7
    d014:	e3a02000 	mov	r2, #0
    d018:	e3a03000 	mov	r3, #0
    d01c:	eb002017 	bl	15080 <__aeabi_dcmplt>
    d020:	e3500000 	cmp	r0, #0
    d024:	1a0000b7 	bne	d308 <BNDRY+0x3f0>
                    extra_p[H2] += BOXL;
                }
            } /* for dir */

            /* If O atom moves out of current box, put it in correct box */
            X_INDEX = (long) (curr_ptr->mol.F[DISP][XDIR][O] / BOX_LENGTH);
    d028:	e59f3378 	ldr	r3, [pc, #888]	; d3a8 <BNDRY+0x490>
    d02c:	e1a00008 	mov	r0, r8
    d030:	e1c340d0 	ldrd	r4, [r3]
    d034:	e1a01009 	mov	r1, r9
    d038:	e1a03005 	mov	r3, r5
    d03c:	e1a02004 	mov	r2, r4
    d040:	eb001f52 	bl	14d90 <__aeabi_ddiv>
    d044:	eb002025 	bl	150e0 <__aeabi_d2iz>
            Y_INDEX = (long) (curr_ptr->mol.F[DISP][YDIR][O] / BOX_LENGTH);
    d048:	e1a03005 	mov	r3, r5
    d04c:	e1a02004 	mov	r2, r4
                    extra_p[H2] += BOXL;
                }
            } /* for dir */

            /* If O atom moves out of current box, put it in correct box */
            X_INDEX = (long) (curr_ptr->mol.F[DISP][XDIR][O] / BOX_LENGTH);
    d050:	e1a08000 	mov	r8, r0
            Y_INDEX = (long) (curr_ptr->mol.F[DISP][YDIR][O] / BOX_LENGTH);
    d054:	e1cd00d0 	ldrd	r0, [sp]
    d058:	eb001f4c 	bl	14d90 <__aeabi_ddiv>
    d05c:	eb00201f 	bl	150e0 <__aeabi_d2iz>
            Z_INDEX = (long) (curr_ptr->mol.F[DISP][ZDIR][O] / BOX_LENGTH);
    d060:	e1a03005 	mov	r3, r5
                }
            } /* for dir */

            /* If O atom moves out of current box, put it in correct box */
            X_INDEX = (long) (curr_ptr->mol.F[DISP][XDIR][O] / BOX_LENGTH);
            Y_INDEX = (long) (curr_ptr->mol.F[DISP][YDIR][O] / BOX_LENGTH);
    d064:	e1a09000 	mov	r9, r0
            Z_INDEX = (long) (curr_ptr->mol.F[DISP][ZDIR][O] / BOX_LENGTH);
    d068:	e1a02004 	mov	r2, r4
    d06c:	e1a00006 	mov	r0, r6
    d070:	e1a01007 	mov	r1, r7
    d074:	eb001f45 	bl	14d90 <__aeabi_ddiv>
    d078:	eb002018 	bl	150e0 <__aeabi_d2iz>

            if ((X_INDEX != i) ||
    d07c:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
            } /* for dir */

            /* If O atom moves out of current box, put it in correct box */
            X_INDEX = (long) (curr_ptr->mol.F[DISP][XDIR][O] / BOX_LENGTH);
            Y_INDEX = (long) (curr_ptr->mol.F[DISP][YDIR][O] / BOX_LENGTH);
            Z_INDEX = (long) (curr_ptr->mol.F[DISP][ZDIR][O] / BOX_LENGTH);
    d080:	e1a05000 	mov	r5, r0

            if ((X_INDEX != i) ||
    d084:	e59d0020 	ldr	r0, [sp, #32]
    d088:	e1590001 	cmp	r9, r1
    d08c:	01580000 	cmpeq	r8, r0
    d090:	1a000003 	bne	d0a4 <BNDRY+0x18c>
                (Y_INDEX != j) ||
    d094:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
    d098:	e1550002 	cmp	r5, r2
    d09c:	058da01c 	streq	sl, [sp, #28]
    d0a0:	0a00002b 	beq	d154 <BNDRY+0x23c>
                (Z_INDEX != k)) {

                /* Remove link from BOX[i][j][k] */

                LOCK(BOX[i][j][k].boxlock);
    d0a4:	e59d0010 	ldr	r0, [sp, #16]
    d0a8:	e59b3000 	ldr	r3, [fp]
    d0ac:	e59d1014 	ldr	r1, [sp, #20]
    d0b0:	e7933000 	ldr	r3, [r3, r0]
    d0b4:	e59d2018 	ldr	r2, [sp, #24]
    d0b8:	e7930001 	ldr	r0, [r3, r1]
    d0bc:	e0800002 	add	r0, r0, r2
    d0c0:	e2800004 	add	r0, r0, #4
    d0c4:	ebffcdca 	bl	7f4 <pthread_mutex_lock>
                if (last_ptr != NULL)
    d0c8:	e59d301c 	ldr	r3, [sp, #28]
    d0cc:	e3530000 	cmp	r3, #0
    d0d0:	0a00009f 	beq	d354 <BNDRY+0x43c>
    d0d4:	e1a01003 	mov	r1, r3
                    last_ptr->next_mol = curr_ptr->next_mol;
    d0d8:	e59a22a0 	ldr	r2, [sl, #672]	; 0x2a0
    d0dc:	e59f02c0 	ldr	r0, [pc, #704]	; d3a4 <BNDRY+0x48c>
    d0e0:	e58122a0 	str	r2, [r1, #672]	; 0x2a0
    d0e4:	e5903000 	ldr	r3, [r0]
    d0e8:	e59d2010 	ldr	r2, [sp, #16]
    d0ec:	e0833002 	add	r3, r3, r2
    d0f0:	e59d2018 	ldr	r2, [sp, #24]
                else
                    BOX[i][j][k].list = curr_ptr->next_mol;
                UNLOCK(BOX[i][j][k].boxlock);
    d0f4:	e59d1014 	ldr	r1, [sp, #20]
    d0f8:	e5933000 	ldr	r3, [r3]

                /* Add link to BOX[X_INDEX][Y_INDEX][Z_INDEX] */

                LOCK(BOX[X_INDEX][Y_INDEX][Z_INDEX].boxlock);
    d0fc:	e1a04205 	lsl	r4, r5, #4
                LOCK(BOX[i][j][k].boxlock);
                if (last_ptr != NULL)
                    last_ptr->next_mol = curr_ptr->next_mol;
                else
                    BOX[i][j][k].list = curr_ptr->next_mol;
                UNLOCK(BOX[i][j][k].boxlock);
    d100:	e7930001 	ldr	r0, [r3, r1]
    d104:	e0800002 	add	r0, r0, r2
    d108:	e2800004 	add	r0, r0, #4
    d10c:	ebffd092 	bl	135c <pthread_mutex_unlock>

                /* Add link to BOX[X_INDEX][Y_INDEX][Z_INDEX] */

                LOCK(BOX[X_INDEX][Y_INDEX][Z_INDEX].boxlock);
    d110:	e59b3000 	ldr	r3, [fp]
    d114:	e7933108 	ldr	r3, [r3, r8, lsl #2]
    d118:	e7930109 	ldr	r0, [r3, r9, lsl #2]
    d11c:	e0800004 	add	r0, r0, r4
    d120:	e2800004 	add	r0, r0, #4
    d124:	ebffcdb2 	bl	7f4 <pthread_mutex_lock>
                temp_ptr = BOX[X_INDEX][Y_INDEX][Z_INDEX].list;
    d128:	e59b3000 	ldr	r3, [fp]
    d12c:	e7932108 	ldr	r2, [r3, r8, lsl #2]
    d130:	e7922109 	ldr	r2, [r2, r9, lsl #2]
    d134:	e7921205 	ldr	r1, [r2, r5, lsl #4]
                BOX[X_INDEX][Y_INDEX][Z_INDEX].list = curr_ptr;
    d138:	e782a205 	str	sl, [r2, r5, lsl #4]
                curr_ptr->next_mol = temp_ptr;
    d13c:	e58a12a0 	str	r1, [sl, #672]	; 0x2a0
                UNLOCK(BOX[X_INDEX][Y_INDEX][Z_INDEX].boxlock);
    d140:	e7933108 	ldr	r3, [r3, r8, lsl #2]
    d144:	e7933109 	ldr	r3, [r3, r9, lsl #2]
    d148:	e0830004 	add	r0, r3, r4
    d14c:	e2800004 	add	r0, r0, #4
    d150:	ebffd081 	bl	135c <pthread_mutex_unlock>
        last_ptr = NULL;
        curr_ptr = BOX[i][j][k].list;

        /* Go through molecules in current box */

        while (curr_ptr) {
    d154:	e59d300c 	ldr	r3, [sp, #12]
    d158:	e3530000 	cmp	r3, #0
    d15c:	0a000088 	beq	d384 <BNDRY+0x46c>
                curr_ptr->next_mol = temp_ptr;
                UNLOCK(BOX[X_INDEX][Y_INDEX][Z_INDEX].boxlock);

            }
            else last_ptr = curr_ptr;
            curr_ptr = next_ptr;   /* Go to next molecule in current box */
    d160:	e1a0a003 	mov	sl, r3

            for ( dir = XDIR; dir <= ZDIR; dir++ ) {
                extra_p = curr_ptr->mol.F[DISP][dir];

                /* if the oxygen atom is out of the box */
                if (extra_p[O] > BOXL ) {
    d164:	e1ca82d0 	ldrd	r8, [sl, #32]
    d168:	e59f023c 	ldr	r0, [pc, #572]	; d3ac <BNDRY+0x494>
    d16c:	e1a01009 	mov	r1, r9
    d170:	e1c040d0 	ldrd	r4, [r0]
    d174:	e1a00008 	mov	r0, r8
    d178:	e1a02004 	mov	r2, r4
    d17c:	e1a03005 	mov	r3, r5
    d180:	eb001fd0 	bl	150c8 <__aeabi_dcmpgt>
        curr_ptr = BOX[i][j][k].list;

        /* Go through molecules in current box */

        while (curr_ptr) {
            next_ptr = curr_ptr->next_mol;
    d184:	e59a12a0 	ldr	r1, [sl, #672]	; 0x2a0

            for ( dir = XDIR; dir <= ZDIR; dir++ ) {
                extra_p = curr_ptr->mol.F[DISP][dir];

                /* if the oxygen atom is out of the box */
                if (extra_p[O] > BOXL ) {
    d188:	e3500000 	cmp	r0, #0
        curr_ptr = BOX[i][j][k].list;

        /* Go through molecules in current box */

        while (curr_ptr) {
            next_ptr = curr_ptr->next_mol;
    d18c:	e58d100c 	str	r1, [sp, #12]

            for ( dir = XDIR; dir <= ZDIR; dir++ ) {
                extra_p = curr_ptr->mol.F[DISP][dir];

                /* if the oxygen atom is out of the box */
                if (extra_p[O] > BOXL ) {
    d190:	0affff81 	beq	cf9c <BNDRY+0x84>

                    /* move all three atoms back in the box */
                    extra_p[H1] -= BOXL;
    d194:	e1ca01d8 	ldrd	r0, [sl, #24]
    d198:	e1a02004 	mov	r2, r4
    d19c:	e1a03005 	mov	r3, r5
    d1a0:	eb001d51 	bl	146ec <__aeabi_dsub>
                    extra_p[O]  -= BOXL;
    d1a4:	e1a02004 	mov	r2, r4

                /* if the oxygen atom is out of the box */
                if (extra_p[O] > BOXL ) {

                    /* move all three atoms back in the box */
                    extra_p[H1] -= BOXL;
    d1a8:	e1ca01f8 	strd	r0, [sl, #24]
                    extra_p[O]  -= BOXL;
    d1ac:	e1a03005 	mov	r3, r5
    d1b0:	e1a00008 	mov	r0, r8
    d1b4:	e1a01009 	mov	r1, r9
    d1b8:	eb001d4b 	bl	146ec <__aeabi_dsub>
    d1bc:	e1a08000 	mov	r8, r0
    d1c0:	e1a09001 	mov	r9, r1
                    extra_p[H2] -= BOXL;
    d1c4:	e1ca02d8 	ldrd	r0, [sl, #40]	; 0x28
                /* if the oxygen atom is out of the box */
                if (extra_p[O] > BOXL ) {

                    /* move all three atoms back in the box */
                    extra_p[H1] -= BOXL;
                    extra_p[O]  -= BOXL;
    d1c8:	e1ca82f0 	strd	r8, [sl, #32]
                    extra_p[H2] -= BOXL;
    d1cc:	e1a02004 	mov	r2, r4
    d1d0:	e1a03005 	mov	r3, r5
    d1d4:	eb001d44 	bl	146ec <__aeabi_dsub>
    d1d8:	e1ca02f8 	strd	r0, [sl, #40]	; 0x28
    d1dc:	eaffff75 	b	cfb8 <BNDRY+0xa0>

                /* if the oxygen atom is out of the box */
                if (extra_p[O] > BOXL ) {

                    /* move all three atoms back in the box */
                    extra_p[H1] -= BOXL;
    d1e0:	e1ca04d8 	ldrd	r0, [sl, #72]	; 0x48
    d1e4:	e1a02004 	mov	r2, r4
    d1e8:	e1a03005 	mov	r3, r5
    d1ec:	eb001d3e 	bl	146ec <__aeabi_dsub>
                    extra_p[O]  -= BOXL;
    d1f0:	e1a02004 	mov	r2, r4

                /* if the oxygen atom is out of the box */
                if (extra_p[O] > BOXL ) {

                    /* move all three atoms back in the box */
                    extra_p[H1] -= BOXL;
    d1f4:	e1ca04f8 	strd	r0, [sl, #72]	; 0x48
                    extra_p[O]  -= BOXL;
    d1f8:	e1a03005 	mov	r3, r5
    d1fc:	e1a00006 	mov	r0, r6
    d200:	e1a01007 	mov	r1, r7
    d204:	eb001d38 	bl	146ec <__aeabi_dsub>
    d208:	e1a06000 	mov	r6, r0
    d20c:	e1a07001 	mov	r7, r1
                    extra_p[H2] -= BOXL;
    d210:	e1ca05d8 	ldrd	r0, [sl, #88]	; 0x58
                /* if the oxygen atom is out of the box */
                if (extra_p[O] > BOXL ) {

                    /* move all three atoms back in the box */
                    extra_p[H1] -= BOXL;
                    extra_p[O]  -= BOXL;
    d214:	e1ca65f0 	strd	r6, [sl, #80]	; 0x50
                    extra_p[H2] -= BOXL;
    d218:	e1a02004 	mov	r2, r4
    d21c:	e1a03005 	mov	r3, r5
    d220:	eb001d31 	bl	146ec <__aeabi_dsub>
    d224:	e1ca05f8 	strd	r0, [sl, #88]	; 0x58
    d228:	eaffff7e 	b	d028 <BNDRY+0x110>

                /* if the oxygen atom is out of the box */
                if (extra_p[O] > BOXL ) {

                    /* move all three atoms back in the box */
                    extra_p[H1] -= BOXL;
    d22c:	e1ca03d0 	ldrd	r0, [sl, #48]	; 0x30
    d230:	e1a02004 	mov	r2, r4
    d234:	e1a03005 	mov	r3, r5
    d238:	eb001d2b 	bl	146ec <__aeabi_dsub>
                    extra_p[O]  -= BOXL;
    d23c:	e1a02004 	mov	r2, r4
    d240:	e1a03005 	mov	r3, r5

                /* if the oxygen atom is out of the box */
                if (extra_p[O] > BOXL ) {

                    /* move all three atoms back in the box */
                    extra_p[H1] -= BOXL;
    d244:	e1ca03f0 	strd	r0, [sl, #48]	; 0x30
                    extra_p[O]  -= BOXL;
    d248:	e1cd00d0 	ldrd	r0, [sp]
    d24c:	eb001d26 	bl	146ec <__aeabi_dsub>
    d250:	e1cd00f0 	strd	r0, [sp]
    d254:	e1cd20d0 	ldrd	r2, [sp]
                    extra_p[H2] -= BOXL;
    d258:	e1ca04d0 	ldrd	r0, [sl, #64]	; 0x40
                /* if the oxygen atom is out of the box */
                if (extra_p[O] > BOXL ) {

                    /* move all three atoms back in the box */
                    extra_p[H1] -= BOXL;
                    extra_p[O]  -= BOXL;
    d25c:	e1ca23f8 	strd	r2, [sl, #56]	; 0x38
                    extra_p[H2] -= BOXL;
    d260:	e1a02004 	mov	r2, r4
    d264:	e1a03005 	mov	r3, r5
    d268:	eb001d1f 	bl	146ec <__aeabi_dsub>
    d26c:	e1ca04f0 	strd	r0, [sl, #64]	; 0x40
    d270:	eaffff5d 	b	cfec <BNDRY+0xd4>
                }
                else if (extra_p[O] < 0.00) {
                    extra_p[H1] += BOXL;
    d274:	e1ca03d0 	ldrd	r0, [sl, #48]	; 0x30
    d278:	e1a02004 	mov	r2, r4
    d27c:	e1a03005 	mov	r3, r5
    d280:	eb001d1a 	bl	146f0 <__adddf3>
                    extra_p[O]  += BOXL;
    d284:	e1a02004 	mov	r2, r4
    d288:	e1a03005 	mov	r3, r5
                    extra_p[H1] -= BOXL;
                    extra_p[O]  -= BOXL;
                    extra_p[H2] -= BOXL;
                }
                else if (extra_p[O] < 0.00) {
                    extra_p[H1] += BOXL;
    d28c:	e1ca03f0 	strd	r0, [sl, #48]	; 0x30
                    extra_p[O]  += BOXL;
    d290:	e1cd00d0 	ldrd	r0, [sp]
    d294:	eb001d15 	bl	146f0 <__adddf3>
    d298:	e1cd00f0 	strd	r0, [sp]
    d29c:	e1cd20d0 	ldrd	r2, [sp]
                    extra_p[H2] += BOXL;
    d2a0:	e1ca04d0 	ldrd	r0, [sl, #64]	; 0x40
                    extra_p[O]  -= BOXL;
                    extra_p[H2] -= BOXL;
                }
                else if (extra_p[O] < 0.00) {
                    extra_p[H1] += BOXL;
                    extra_p[O]  += BOXL;
    d2a4:	e1ca23f8 	strd	r2, [sl, #56]	; 0x38
                    extra_p[H2] += BOXL;
    d2a8:	e1a02004 	mov	r2, r4
    d2ac:	e1a03005 	mov	r3, r5
    d2b0:	eb001d0e 	bl	146f0 <__adddf3>
    d2b4:	e1ca04f0 	strd	r0, [sl, #64]	; 0x40
    d2b8:	eaffff4b 	b	cfec <BNDRY+0xd4>
                    extra_p[H1] -= BOXL;
                    extra_p[O]  -= BOXL;
                    extra_p[H2] -= BOXL;
                }
                else if (extra_p[O] < 0.00) {
                    extra_p[H1] += BOXL;
    d2bc:	e1ca01d8 	ldrd	r0, [sl, #24]
    d2c0:	e1a02004 	mov	r2, r4
    d2c4:	e1a03005 	mov	r3, r5
    d2c8:	eb001d08 	bl	146f0 <__adddf3>
                    extra_p[O]  += BOXL;
    d2cc:	e1a02004 	mov	r2, r4
                    extra_p[H1] -= BOXL;
                    extra_p[O]  -= BOXL;
                    extra_p[H2] -= BOXL;
                }
                else if (extra_p[O] < 0.00) {
                    extra_p[H1] += BOXL;
    d2d0:	e1ca01f8 	strd	r0, [sl, #24]
                    extra_p[O]  += BOXL;
    d2d4:	e1a03005 	mov	r3, r5
    d2d8:	e1a00008 	mov	r0, r8
    d2dc:	e1a01009 	mov	r1, r9
    d2e0:	eb001d02 	bl	146f0 <__adddf3>
    d2e4:	e1a08000 	mov	r8, r0
    d2e8:	e1a09001 	mov	r9, r1
                    extra_p[H2] += BOXL;
    d2ec:	e1ca02d8 	ldrd	r0, [sl, #40]	; 0x28
                    extra_p[O]  -= BOXL;
                    extra_p[H2] -= BOXL;
                }
                else if (extra_p[O] < 0.00) {
                    extra_p[H1] += BOXL;
                    extra_p[O]  += BOXL;
    d2f0:	e1ca82f0 	strd	r8, [sl, #32]
                    extra_p[H2] += BOXL;
    d2f4:	e1a02004 	mov	r2, r4
    d2f8:	e1a03005 	mov	r3, r5
    d2fc:	eb001cfb 	bl	146f0 <__adddf3>
    d300:	e1ca02f8 	strd	r0, [sl, #40]	; 0x28
    d304:	eaffff2b 	b	cfb8 <BNDRY+0xa0>
                    extra_p[H1] -= BOXL;
                    extra_p[O]  -= BOXL;
                    extra_p[H2] -= BOXL;
                }
                else if (extra_p[O] < 0.00) {
                    extra_p[H1] += BOXL;
    d308:	e1ca04d8 	ldrd	r0, [sl, #72]	; 0x48
    d30c:	e1a02004 	mov	r2, r4
    d310:	e1a03005 	mov	r3, r5
    d314:	eb001cf5 	bl	146f0 <__adddf3>
                    extra_p[O]  += BOXL;
    d318:	e1a02004 	mov	r2, r4
                    extra_p[H1] -= BOXL;
                    extra_p[O]  -= BOXL;
                    extra_p[H2] -= BOXL;
                }
                else if (extra_p[O] < 0.00) {
                    extra_p[H1] += BOXL;
    d31c:	e1ca04f8 	strd	r0, [sl, #72]	; 0x48
                    extra_p[O]  += BOXL;
    d320:	e1a03005 	mov	r3, r5
    d324:	e1a00006 	mov	r0, r6
    d328:	e1a01007 	mov	r1, r7
    d32c:	eb001cef 	bl	146f0 <__adddf3>
    d330:	e1a06000 	mov	r6, r0
    d334:	e1a07001 	mov	r7, r1
                    extra_p[H2] += BOXL;
    d338:	e1ca05d8 	ldrd	r0, [sl, #88]	; 0x58
                    extra_p[O]  -= BOXL;
                    extra_p[H2] -= BOXL;
                }
                else if (extra_p[O] < 0.00) {
                    extra_p[H1] += BOXL;
                    extra_p[O]  += BOXL;
    d33c:	e1ca65f0 	strd	r6, [sl, #80]	; 0x50
                    extra_p[H2] += BOXL;
    d340:	e1a02004 	mov	r2, r4
    d344:	e1a03005 	mov	r3, r5
    d348:	eb001ce8 	bl	146f0 <__adddf3>
    d34c:	e1ca05f8 	strd	r0, [sl, #88]	; 0x58
    d350:	eaffff34 	b	d028 <BNDRY+0x110>

                LOCK(BOX[i][j][k].boxlock);
                if (last_ptr != NULL)
                    last_ptr->next_mol = curr_ptr->next_mol;
                else
                    BOX[i][j][k].list = curr_ptr->next_mol;
    d354:	e59f0048 	ldr	r0, [pc, #72]	; d3a4 <BNDRY+0x48c>
    d358:	e59a12a0 	ldr	r1, [sl, #672]	; 0x2a0
    d35c:	e5903000 	ldr	r3, [r0]
    d360:	e59d0010 	ldr	r0, [sp, #16]
    d364:	e7932000 	ldr	r2, [r3, r0]
    d368:	e0833000 	add	r3, r3, r0
    d36c:	e59d0014 	ldr	r0, [sp, #20]
    d370:	e7922000 	ldr	r2, [r2, r0]
    d374:	e59d0018 	ldr	r0, [sp, #24]
    d378:	e7821000 	str	r1, [r2, r0]
    d37c:	e1a02000 	mov	r2, r0
    d380:	eaffff5b 	b	d0f4 <BNDRY+0x1dc>

            }
            else last_ptr = curr_ptr;
            curr_ptr = next_ptr;   /* Go to next molecule in current box */
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    d384:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    d388:	e590000c 	ldr	r0, [r0, #12]
    struct list_of_boxes *curr_box;
    double *extra_p;

    /* for each box */
    curr_box = my_boxes[ProcID];
    while (curr_box) {
    d38c:	e3500000 	cmp	r0, #0

            }
            else last_ptr = curr_ptr;
            curr_ptr = next_ptr;   /* Go to next molecule in current box */
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    d390:	e58d002c 	str	r0, [sp, #44]	; 0x2c
    struct list_of_boxes *curr_box;
    double *extra_p;

    /* for each box */
    curr_box = my_boxes[ProcID];
    while (curr_box) {
    d394:	1afffee9 	bne	cf40 <BNDRY+0x28>
            curr_ptr = next_ptr;   /* Go to next molecule in current box */
        } /* while curr_ptr */
        curr_box = curr_box->next_box;
    } /* for curr_box */

} /* end of subroutine BNDRY */
    d398:	e28dd034 	add	sp, sp, #52	; 0x34
    d39c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    d3a0:	0013efcc 	.word	0x0013efcc
    d3a4:	0013f098 	.word	0x0013f098
    d3a8:	0013ef58 	.word	0x0013ef58
    d3ac:	0013ea58 	.word	0x0013ea58

0000d3b0 <vfs_stop>:
 */

{

  return DNA_OK;
}
    d3b0:	e3a00000 	mov	r0, #0
    d3b4:	e12fff1e 	bx	lr

0000d3b8 <vnode_volume_inspector>:
  vnode_t vnode = node;
  volume_t volume = va_arg (list, volume_t);

  watch (bool)
  {
    ensure (vnode != NULL, false);
    d3b8:	e3500000 	cmp	r0, #0
 * SOURCE
 */

{
  vnode_t vnode = node;
  volume_t volume = va_arg (list, volume_t);
    d3bc:	e5913000 	ldr	r3, [r1]

  watch (bool)
  {
    ensure (vnode != NULL, false);
    d3c0:	012fff1e 	bxeq	lr
    ensure (volume != NULL, false);
    d3c4:	e3530000 	cmp	r3, #0
    return vnode -> volume == volume;
    d3c8:	15900010 	ldrne	r0, [r0, #16]
    d3cc:	10630000 	rsbne	r0, r3, r0
    d3d0:	116f0f10 	clzne	r0, r0
    d3d4:	11a002a0 	lsrne	r0, r0, #5
  vnode_t vnode = node;
  volume_t volume = va_arg (list, volume_t);

  watch (bool)
  {
    ensure (vnode != NULL, false);
    d3d8:	01a00003 	moveq	r0, r3
    ensure (volume != NULL, false);
    return vnode -> volume == volume;
  }
}
    d3dc:	e12fff1e 	bx	lr

0000d3e0 <volume_destroy>:
 * RESULT
 *
 * SOURCE
 */

{
    d3e0:	e92d4070 	push	{r4, r5, r6, lr}
    d3e4:	e1a05000 	mov	r5, r0
  interrupt_status_t it_status = 0;

  it_status = cpu_trap_mask_and_backup();
    d3e8:	eb000c28 	bl	10490 <cpu_trap_mask_and_backup>
    d3ec:	e1a06000 	mov	r6, r0
  lock_acquire (& volume_manager . volume_list . lock);
    d3f0:	e59f4030 	ldr	r4, [pc, #48]	; d428 <volume_destroy+0x48>
    d3f4:	e1a00004 	mov	r0, r4
    d3f8:	eb000d70 	bl	109c0 <lock_acquire>

  queue_extract (& volume_manager . volume_list, volume);
    d3fc:	e1a01005 	mov	r1, r5
    d400:	e1a00004 	mov	r0, r4
    d404:	eb000777 	bl	f1e8 <queue_extract>

  lock_release (& volume_manager . volume_list . lock);
    d408:	e1a00004 	mov	r0, r4
    d40c:	eb00181f 	bl	13490 <lock_release>
  cpu_trap_restore(it_status);
    d410:	e1a00006 	mov	r0, r6
    d414:	eb000c56 	bl	10574 <cpu_trap_restore>

  kernel_free (volume);
    d418:	e1a00005 	mov	r0, r5
    d41c:	eb001b50 	bl	14164 <kernel_free>
  return DNA_OK;
}
    d420:	e3a00000 	mov	r0, #0
    d424:	e8bd8070 	pop	{r4, r5, r6, pc}
    d428:	0013f58c 	.word	0x0013f58c

0000d42c <vnode_put>:
 * * DNA_ERROR if an error occured.
 *
 * SOURCE
 */

{
    d42c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    d430:	e24dd00c 	sub	sp, sp, #12
    d434:	e1a04002 	mov	r4, r2
    d438:	e1a05003 	mov	r5, r3
    d43c:	e1a06000 	mov	r6, r0
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup();
    d440:	eb000c12 	bl	10490 <cpu_trap_mask_and_backup>
    d444:	e1a07000 	mov	r7, r0
    lock_acquire (& vnode_manager . vnode_list . lock);
    d448:	e59f00e8 	ldr	r0, [pc, #232]	; d538 <vnode_put+0x10c>
    d44c:	eb000d5b 	bl	109c0 <lock_acquire>

    vnode = queue_lookup (& vnode_manager . vnode_list,
    d450:	e1a02004 	mov	r2, r4
    d454:	e58d6000 	str	r6, [sp]
    d458:	e1a03005 	mov	r3, r5
    d45c:	e59f00d4 	ldr	r0, [pc, #212]	; d538 <vnode_put+0x10c>
    d460:	e59f10d4 	ldr	r1, [pc, #212]	; d53c <vnode_put+0x110>
    d464:	eb000aa1 	bl	fef0 <queue_lookup>
        vnode_id_inspector, vnid, vid);

    check (invalid_vnode, vnode != NULL, DNA_NO_VNODE);
    d468:	e2504000 	subs	r4, r0, #0
    d46c:	0a00002a 	beq	d51c <vnode_put+0xf0>

    atomic_add (& vnode -> usage_counter, -1);
    d470:	e2840018 	add	r0, r4, #24
    d474:	e3e01000 	mvn	r1, #0
    d478:	eb000aba 	bl	ff68 <atomic_add>

    if (vnode -> usage_counter == 0)
    d47c:	e5943018 	ldr	r3, [r4, #24]
    {
      queue_extract (& vnode_manager . vnode_list, & vnode -> link);
    d480:	e59f00b0 	ldr	r0, [pc, #176]	; d538 <vnode_put+0x10c>

    check (invalid_vnode, vnode != NULL, DNA_NO_VNODE);

    atomic_add (& vnode -> usage_counter, -1);

    if (vnode -> usage_counter == 0)
    d484:	e3530000 	cmp	r3, #0
    d488:	1a00001d 	bne	d504 <vnode_put+0xd8>
    {
      queue_extract (& vnode_manager . vnode_list, & vnode -> link);
    d48c:	e1a01004 	mov	r1, r4
    d490:	eb000754 	bl	f1e8 <queue_extract>

      lock_release (& vnode_manager . vnode_list . lock);
    d494:	e59f009c 	ldr	r0, [pc, #156]	; d538 <vnode_put+0x10c>
    d498:	eb0017fc 	bl	13490 <lock_release>
      cpu_trap_restore(it_status);
    d49c:	e1a00007 	mov	r0, r7
    d4a0:	eb000c33 	bl	10574 <cpu_trap_restore>

      volume = vnode -> volume;
    d4a4:	e5945010 	ldr	r5, [r4, #16]
      data = vnode -> data;
    d4a8:	e594601c 	ldr	r6, [r4, #28]
      destroy = vnode -> destroy;
      status = volume -> cmd -> write_vnode (volume -> data, data);
    d4ac:	e5953020 	ldr	r3, [r5, #32]
    d4b0:	e5950024 	ldr	r0, [r5, #36]	; 0x24
    d4b4:	e593300c 	ldr	r3, [r3, #12]
    d4b8:	e1a01006 	mov	r1, r6
      lock_release (& vnode_manager . vnode_list . lock);
      cpu_trap_restore(it_status);

      volume = vnode -> volume;
      data = vnode -> data;
      destroy = vnode -> destroy;
    d4bc:	e5d47014 	ldrb	r7, [r4, #20]
      status = volume -> cmd -> write_vnode (volume -> data, data);
    d4c0:	e12fff33 	blx	r3
      ensure (status == DNA_OK, status);
    d4c4:	e3500000 	cmp	r0, #0
    d4c8:	1a000011 	bne	d514 <vnode_put+0xe8>

      if (destroy)
    d4cc:	e3570000 	cmp	r7, #0
    d4d0:	0a000006 	beq	d4f0 <vnode_put+0xc4>
      {
        status = volume -> cmd -> destroy_vnode (volume -> data, data); 
    d4d4:	e5953020 	ldr	r3, [r5, #32]
    d4d8:	e1a01006 	mov	r1, r6
    d4dc:	e5933010 	ldr	r3, [r3, #16]
    d4e0:	e5950024 	ldr	r0, [r5, #36]	; 0x24
    d4e4:	e12fff33 	blx	r3
        ensure (status == DNA_OK, status);
    d4e8:	e3500000 	cmp	r0, #0
    d4ec:	1a000008 	bne	d514 <vnode_put+0xe8>
      }

      kernel_free (vnode);
    d4f0:	e1a00004 	mov	r0, r4
    d4f4:	eb001b1a 	bl	14164 <kernel_free>
    {
      lock_release (& vnode_manager . vnode_list . lock);
      cpu_trap_restore(it_status);
    }

    return DNA_OK;
    d4f8:	e3a00000 	mov	r0, #0
  {
    lock_release (& vnode_manager . vnode_list . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    d4fc:	e28dd00c 	add	sp, sp, #12
    d500:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

      kernel_free (vnode);
    }
    else
    {
      lock_release (& vnode_manager . vnode_list . lock);
    d504:	eb0017e1 	bl	13490 <lock_release>
      cpu_trap_restore(it_status);
    d508:	e1a00007 	mov	r0, r7
    d50c:	eb000c18 	bl	10574 <cpu_trap_restore>
    }

    return DNA_OK;
    d510:	e3a00000 	mov	r0, #0
  {
    lock_release (& vnode_manager . vnode_list . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    d514:	e28dd00c 	add	sp, sp, #12
    d518:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    return DNA_OK;
  }

  rescue (invalid_vnode)
  {
    lock_release (& vnode_manager . vnode_list . lock);
    d51c:	e59f0014 	ldr	r0, [pc, #20]	; d538 <vnode_put+0x10c>
    d520:	eb0017da 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
    d524:	e1a00007 	mov	r0, r7
    d528:	eb000c11 	bl	10574 <cpu_trap_restore>
    leave;
    d52c:	e59f000c 	ldr	r0, [pc, #12]	; d540 <vnode_put+0x114>
  }
}
    d530:	e28dd00c 	add	sp, sp, #12
    d534:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    d538:	0013f574 	.word	0x0013f574
    d53c:	0000e004 	.word	0x0000e004
    d540:	0000fefd 	.word	0x0000fefd

0000d544 <vnode_get>:
 * * DNA_OK if the operation succeeded.
 *
 * SOURCE
 */

{
    d544:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    d548:	e24dd00c 	sub	sp, sp, #12
    d54c:	e59d6028 	ldr	r6, [sp, #40]	; 0x28
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (data != NULL, DNA_ERROR);
    d550:	e3560000 	cmp	r6, #0
    d554:	0a00001f 	beq	d5d8 <vnode_get+0x94>
    d558:	e1a04002 	mov	r4, r2
    d55c:	e1a05003 	mov	r5, r3
    d560:	e1a08000 	mov	r8, r0

    it_status = cpu_trap_mask_and_backup();
    d564:	eb000bc9 	bl	10490 <cpu_trap_mask_and_backup>
    d568:	e1a09000 	mov	r9, r0
    lock_acquire (& vnode_manager . vnode_list . lock);
    d56c:	e59f00e4 	ldr	r0, [pc, #228]	; d658 <vnode_get+0x114>
    d570:	eb000d12 	bl	109c0 <lock_acquire>

    vnode = queue_lookup (& vnode_manager . vnode_list,
    d574:	e59f10e0 	ldr	r1, [pc, #224]	; d65c <vnode_get+0x118>
    d578:	e1a02004 	mov	r2, r4
    d57c:	e1a03005 	mov	r3, r5
    d580:	e58d8000 	str	r8, [sp]
    d584:	e59f00cc 	ldr	r0, [pc, #204]	; d658 <vnode_get+0x114>
    d588:	eb000a58 	bl	fef0 <queue_lookup>
    d58c:	e1a07000 	mov	r7, r0
        vnode_id_inspector, vnid, vid);

    lock_release (& vnode_manager . vnode_list . lock);
    d590:	e59f00c0 	ldr	r0, [pc, #192]	; d658 <vnode_get+0x114>
    d594:	eb0017bd 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
    d598:	e1a00009 	mov	r0, r9
    d59c:	eb000bf4 	bl	10574 <cpu_trap_restore>

    if (vnode == NULL)
    d5a0:	e3570000 	cmp	r7, #0
    d5a4:	0a00000e 	beq	d5e4 <vnode_get+0xa0>
      ensure (status == DNA_OK, status);

      status = vnode_create (vnid, volume -> id, *data);
      ensure (status == DNA_OK, status);
    }
    else if (! vnode -> destroy)
    d5a8:	e5d74014 	ldrb	r4, [r7, #20]
    d5ac:	e3540000 	cmp	r4, #0
    {
      *data = vnode -> data;
      atomic_add (& vnode -> usage_counter, 1);
    }

    return DNA_OK;
    d5b0:	13a00000 	movne	r0, #0
      ensure (status == DNA_OK, status);

      status = vnode_create (vnid, volume -> id, *data);
      ensure (status == DNA_OK, status);
    }
    else if (! vnode -> destroy)
    d5b4:	1a000005 	bne	d5d0 <vnode_get+0x8c>
    {
      *data = vnode -> data;
    d5b8:	e597301c 	ldr	r3, [r7, #28]
      atomic_add (& vnode -> usage_counter, 1);
    d5bc:	e2870018 	add	r0, r7, #24
      status = vnode_create (vnid, volume -> id, *data);
      ensure (status == DNA_OK, status);
    }
    else if (! vnode -> destroy)
    {
      *data = vnode -> data;
    d5c0:	e5863000 	str	r3, [r6]
      atomic_add (& vnode -> usage_counter, 1);
    d5c4:	e3a01001 	mov	r1, #1
    d5c8:	eb000a66 	bl	ff68 <atomic_add>
    }

    return DNA_OK;
    d5cc:	e1a00004 	mov	r0, r4
  }
}
    d5d0:	e28dd00c 	add	sp, sp, #12
    d5d4:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (data != NULL, DNA_ERROR);
    d5d8:	e59f0080 	ldr	r0, [pc, #128]	; d660 <vnode_get+0x11c>
      atomic_add (& vnode -> usage_counter, 1);
    }

    return DNA_OK;
  }
}
    d5dc:	e28dd00c 	add	sp, sp, #12
    d5e0:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
    lock_release (& vnode_manager . vnode_list . lock);
    cpu_trap_restore(it_status);

    if (vnode == NULL)
    {
      it_status = cpu_trap_mask_and_backup();
    d5e4:	eb000ba9 	bl	10490 <cpu_trap_mask_and_backup>
    d5e8:	e1a09000 	mov	r9, r0
      lock_acquire (& volume_manager . volume_list . lock);
    d5ec:	e59f0070 	ldr	r0, [pc, #112]	; d664 <vnode_get+0x120>
    d5f0:	eb000cf2 	bl	109c0 <lock_acquire>

      volume = queue_lookup (& volume_manager . volume_list,
    d5f4:	e1a02008 	mov	r2, r8
    d5f8:	e59f1068 	ldr	r1, [pc, #104]	; d668 <vnode_get+0x124>
    d5fc:	e59f0060 	ldr	r0, [pc, #96]	; d664 <vnode_get+0x120>
    d600:	eb000a3a 	bl	fef0 <queue_lookup>
    d604:	e1a07000 	mov	r7, r0
          volume_id_inspector, vid);

      lock_release (& volume_manager . volume_list . lock);
    d608:	e59f0054 	ldr	r0, [pc, #84]	; d664 <vnode_get+0x120>
    d60c:	eb00179f 	bl	13490 <lock_release>
      cpu_trap_restore(it_status);
    d610:	e1a00009 	mov	r0, r9
    d614:	eb000bd6 	bl	10574 <cpu_trap_restore>

      status = volume -> cmd -> read_vnode (volume -> data, vnid, data);
    d618:	e5973020 	ldr	r3, [r7, #32]
    d61c:	e5970024 	ldr	r0, [r7, #36]	; 0x24
    d620:	e58d6000 	str	r6, [sp]
    d624:	e5931008 	ldr	r1, [r3, #8]
    d628:	e1a02004 	mov	r2, r4
    d62c:	e1a03005 	mov	r3, r5
    d630:	e12fff31 	blx	r1
      ensure (status == DNA_OK, status);
    d634:	e3500000 	cmp	r0, #0
    d638:	1affffe4 	bne	d5d0 <vnode_get+0x8c>

      status = vnode_create (vnid, volume -> id, *data);
    d63c:	e1a00004 	mov	r0, r4
    d640:	e1a01005 	mov	r1, r5
    d644:	e5972004 	ldr	r2, [r7, #4]
    d648:	e5963000 	ldr	r3, [r6]
      atomic_add (& vnode -> usage_counter, 1);
    }

    return DNA_OK;
  }
}
    d64c:	e28dd00c 	add	sp, sp, #12
    d650:	e8bd43f0 	pop	{r4, r5, r6, r7, r8, r9, lr}
      cpu_trap_restore(it_status);

      status = volume -> cmd -> read_vnode (volume -> data, vnid, data);
      ensure (status == DNA_OK, status);

      status = vnode_create (vnid, volume -> id, *data);
    d654:	ea00009a 	b	d8c4 <vnode_create>
    d658:	0013f574 	.word	0x0013f574
    d65c:	0000e004 	.word	0x0000e004
    d660:	0000ffff 	.word	0x0000ffff
    d664:	0013f58c 	.word	0x0013f58c
    d668:	0000e76c 	.word	0x0000e76c

0000d66c <vfs_readdir>:
 * * DNA_OK : the operation succeeded
 *
 * SOURCE
 */

{
    d66c:	e92d4070 	push	{r4, r5, r6, lr}
  int32_t n_data = count;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (entry_array != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    d670:	e3530000 	cmp	r3, #0
    d674:	13510000 	cmpne	r1, #0
    d678:	e1a04003 	mov	r4, r3
 *
 * SOURCE
 */

{
  file_t file = NULL;
    d67c:	e3a03000 	mov	r3, #0
 * * DNA_OK : the operation succeeded
 *
 * SOURCE
 */

{
    d680:	e24dd010 	sub	sp, sp, #16
  int32_t n_data = count;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (entry_array != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    d684:	e1a05001 	mov	r5, r1
 * SOURCE
 */

{
  file_t file = NULL;
  int32_t n_data = count;
    d688:	e58d200c 	str	r2, [sp, #12]
 *
 * SOURCE
 */

{
  file_t file = NULL;
    d68c:	e58d3008 	str	r3, [sp, #8]
  int32_t n_data = count;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (entry_array != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    d690:	1a000002 	bne	d6a0 <vfs_readdir+0x34>
    d694:	e59f00ac 	ldr	r0, [pc, #172]	; d748 <vfs_readdir+0xdc>
    panic (status != DNA_OK);

    *p_ret = -1;
    leave;
  }
}
    d698:	e28dd010 	add	sp, sp, #16
    d69c:	e8bd8070 	pop	{r4, r5, r6, pc}
  int32_t n_data = count;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (entry_array != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    d6a0:	e1520003 	cmp	r2, r3
    d6a4:	0afffffa 	beq	d694 <vfs_readdir+0x28>
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    d6a8:	e6ff3070 	uxth	r3, r0
    d6ac:	e35300ff 	cmp	r3, #255	; 0xff
    d6b0:	e1a06000 	mov	r6, r0
    d6b4:	859f0090 	ldrhi	r0, [pc, #144]	; d74c <vfs_readdir+0xe0>
    d6b8:	8afffff6 	bhi	d698 <vfs_readdir+0x2c>

    /*
     * Get the file associated to the fd.
     */

    status = file_get (fd, & file);
    d6bc:	e28d1008 	add	r1, sp, #8
    d6c0:	eb0001bd 	bl	ddbc <file_get>
    ensure (status == DNA_OK, status);
    d6c4:	e3500000 	cmp	r0, #0
    d6c8:	1afffff2 	bne	d698 <vfs_readdir+0x2c>

    /*
     * Read the file.
     */

    status = file -> vnode -> volume -> cmd -> readdir
    d6cc:	e59d3008 	ldr	r3, [sp, #8]
    d6d0:	e28de00c 	add	lr, sp, #12
    d6d4:	e5931008 	ldr	r1, [r3, #8]
    d6d8:	e5932020 	ldr	r2, [r3, #32]
    d6dc:	e5910010 	ldr	r0, [r1, #16]
      (file -> vnode -> volume -> data, file -> vnode -> data,
    d6e0:	e2833018 	add	r3, r3, #24

    /*
     * Read the file.
     */

    status = file -> vnode -> volume -> cmd -> readdir
    d6e4:	e590c020 	ldr	ip, [r0, #32]
    d6e8:	e591101c 	ldr	r1, [r1, #28]
    d6ec:	e5900024 	ldr	r0, [r0, #36]	; 0x24
    d6f0:	e88d4008 	stm	sp, {r3, lr}
    d6f4:	e1a03005 	mov	r3, r5
    d6f8:	e59cc038 	ldr	ip, [ip, #56]	; 0x38
    d6fc:	e12fff3c 	blx	ip
      (file -> vnode -> volume -> data, file -> vnode -> data,
       file -> data, entry_array, & file -> offset, & n_data);

    check (error, status == DNA_OK, status);
    d700:	e2505000 	subs	r5, r0, #0
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    d704:	e1a00006 	mov	r0, r6

    status = file -> vnode -> volume -> cmd -> readdir
      (file -> vnode -> volume -> data, file -> vnode -> data,
       file -> data, entry_array, & file -> offset, & n_data);

    check (error, status == DNA_OK, status);
    d708:	0a000003 	beq	d71c <vfs_readdir+0xb0>
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    d70c:	eb000375 	bl	e4e8 <file_put>
    panic (status != DNA_OK);
    d710:	e3500000 	cmp	r0, #0
    d714:	0a000007 	beq	d738 <vfs_readdir+0xcc>
    d718:	eafffffe 	b	d718 <vfs_readdir+0xac>

    /*
     * Release the file and return.
     */

    status = file_put (fd);
    d71c:	eb000371 	bl	e4e8 <file_put>
    panic (status != DNA_OK);
    d720:	e3500000 	cmp	r0, #0
    d724:	0a000000 	beq	d72c <vfs_readdir+0xc0>
    d728:	eafffffe 	b	d728 <vfs_readdir+0xbc>

    *p_ret = n_data;
    d72c:	e59d300c 	ldr	r3, [sp, #12]
    d730:	e5843000 	str	r3, [r4]
    return DNA_OK;
    d734:	eaffffd7 	b	d698 <vfs_readdir+0x2c>
  rescue (error)
  {
    status = file_put (fd);
    panic (status != DNA_OK);

    *p_ret = -1;
    d738:	e3e03000 	mvn	r3, #0
    leave;
    d73c:	e1a00005 	mov	r0, r5
  rescue (error)
  {
    status = file_put (fd);
    panic (status != DNA_OK);

    *p_ret = -1;
    d740:	e5843000 	str	r3, [r4]
    leave;
    d744:	eaffffd3 	b	d698 <vfs_readdir+0x2c>
    d748:	0000ffff 	.word	0x0000ffff
    d74c:	0000fef8 	.word	0x0000fef8

0000d750 <file_create>:
 * * DNA_OK if the operation succeed
 *
 * SOURCE
 */

{
    d750:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d754:	e24dd064 	sub	sp, sp, #100	; 0x64
    d758:	e1a07000 	mov	r7, r0
    d75c:	e1a05001 	mov	r5, r1
  file_t file = NULL, * file_array = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    d760:	e3a00000 	mov	r0, #0
    d764:	e28d100c 	add	r1, sp, #12
 * * DNA_OK if the operation succeed
 *
 * SOURCE
 */

{
    d768:	e1a06002 	mov	r6, r2
    d76c:	e1a04003 	mov	r4, r3
  file_t file = NULL, * file_array = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    d770:	eb001889 	bl	1399c <thread_find>
    ensure (status == DNA_OK, status);
    d774:	e3500000 	cmp	r0, #0
    d778:	0a000001 	beq	d784 <file_create+0x34>
  {
    lock_release (& file_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    d77c:	e28dd064 	add	sp, sp, #100	; 0x64
    d780:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    ensure (status == DNA_OK, status);

    status = thread_get_info (tid, & info);
    d784:	e59d000c 	ldr	r0, [sp, #12]
    d788:	e28d1010 	add	r1, sp, #16
    d78c:	eb001428 	bl	12834 <thread_get_info>
    ensure (status == DNA_OK, status);
    d790:	e3500000 	cmp	r0, #0
    d794:	1afffff8 	bne	d77c <file_create+0x2c>

    ensure (info . group >= 0, DNA_BAD_ARGUMENT);
    ensure (info . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    d798:	e59d8034 	ldr	r8, [sp, #52]	; 0x34
    d79c:	e3580000 	cmp	r8, #0
    d7a0:	0a000002 	beq	d7b0 <file_create+0x60>
    d7a4:	e59f0108 	ldr	r0, [pc, #264]	; d8b4 <file_create+0x164>
  {
    lock_release (& file_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    d7a8:	e28dd064 	add	sp, sp, #100	; 0x64
    d7ac:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ensure (status == DNA_OK, status);

    ensure (info . group >= 0, DNA_BAD_ARGUMENT);
    ensure (info . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);

    ensure (p_fd != NULL, DNA_BAD_ARGUMENT);
    d7b0:	e3540000 	cmp	r4, #0
    d7b4:	0afffffa 	beq	d7a4 <file_create+0x54>
    ensure (p_file != NULL, DNA_BAD_ARGUMENT);
    d7b8:	e59d3088 	ldr	r3, [sp, #136]	; 0x88
    d7bc:	e3530000 	cmp	r3, #0
    d7c0:	0afffff7 	beq	d7a4 <file_create+0x54>

    it_status = cpu_trap_mask_and_backup();
    d7c4:	eb000b31 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& file_pool . lock);
    d7c8:	e59f90e8 	ldr	r9, [pc, #232]	; d8b8 <file_create+0x168>
    ensure (info . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);

    ensure (p_fd != NULL, DNA_BAD_ARGUMENT);
    ensure (p_file != NULL, DNA_BAD_ARGUMENT);

    it_status = cpu_trap_mask_and_backup();
    d7cc:	e58d0004 	str	r0, [sp, #4]
    lock_acquire (& file_pool . lock);
    d7d0:	e1a00009 	mov	r0, r9
    d7d4:	eb000c79 	bl	109c0 <lock_acquire>

    /*
     * Find a free file descriptor.
     */

    file_array = file_pool . file[info . group];
    d7d8:	e5993004 	ldr	r3, [r9, #4]
    d7dc:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
    d7e0:	e7933102 	ldr	r3, [r3, r2, lsl #2]

    for (fd = 0; file_array[fd] != NULL && fd < DNA_MAX_FILE; fd += 1);
    d7e4:	e593b000 	ldr	fp, [r3]
    d7e8:	e35b0000 	cmp	fp, #0
    d7ec:	0a00002e 	beq	d8ac <file_create+0x15c>
    d7f0:	e2630004 	rsb	r0, r3, #4
    d7f4:	ea000001 	b	d800 <file_create+0xb0>
    d7f8:	e3520c01 	cmp	r2, #256	; 0x100
    d7fc:	0a000028 	beq	d8a4 <file_create+0x154>
    d800:	e080b003 	add	fp, r0, r3
    d804:	e5b31004 	ldr	r1, [r3, #4]!
    d808:	e2888001 	add	r8, r8, #1
    d80c:	e6ff2078 	uxth	r2, r8
    d810:	e3510000 	cmp	r1, #0
    d814:	e6ff8072 	uxth	r8, r2
    d818:	1afffff6 	bne	d7f8 <file_create+0xa8>
    check (error, fd != DNA_MAX_FILE, DNA_MAX_OPENED_FILES);
    d81c:	e6bf2078 	sxth	r2, r8
    d820:	e3520c01 	cmp	r2, #256	; 0x100
    d824:	e1a0a008 	mov	sl, r8
    d828:	0a00001d 	beq	d8a4 <file_create+0x154>

    /*
     * Allocate the new file.
     */

    file = kernel_malloc (sizeof (struct _file), true);
    d82c:	e3a00028 	mov	r0, #40	; 0x28
    d830:	e3a01001 	mov	r1, #1
    d834:	eb001a15 	bl	14090 <kernel_malloc>
    check (error, file != NULL, DNA_OUT_OF_MEM);
    d838:	e2508000 	subs	r8, r0, #0
    d83c:	0a000011 	beq	d888 <file_create+0x138>

    file -> vnode = vnode;
    file -> mode = mode;
    file -> data = data;
    file -> usage_counter = 1;
    d840:	e3a01001 	mov	r1, #1

    file_pool . file[info . group][fd] = file;
    d844:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
    d848:	e5992004 	ldr	r2, [r9, #4]
     */

    file = kernel_malloc (sizeof (struct _file), true);
    check (error, file != NULL, DNA_OUT_OF_MEM);

    file -> vnode = vnode;
    d84c:	e5887008 	str	r7, [r8, #8]
    file -> mode = mode;
    file -> data = data;
    d850:	e5886020 	str	r6, [r8, #32]
    file -> usage_counter = 1;

    file_pool . file[info . group][fd] = file;
    d854:	e7922100 	ldr	r2, [r2, r0, lsl #2]
    check (error, file != NULL, DNA_OUT_OF_MEM);

    file -> vnode = vnode;
    file -> mode = mode;
    file -> data = data;
    file -> usage_counter = 1;
    d858:	e5881004 	str	r1, [r8, #4]

    file = kernel_malloc (sizeof (struct _file), true);
    check (error, file != NULL, DNA_OUT_OF_MEM);

    file -> vnode = vnode;
    file -> mode = mode;
    d85c:	e5885010 	str	r5, [r8, #16]
    file -> data = data;
    file -> usage_counter = 1;

    file_pool . file[info . group][fd] = file;

    lock_release (& file_pool . lock);
    d860:	e59f0050 	ldr	r0, [pc, #80]	; d8b8 <file_create+0x168>
    file -> vnode = vnode;
    file -> mode = mode;
    file -> data = data;
    file -> usage_counter = 1;

    file_pool . file[info . group][fd] = file;
    d864:	e782800b 	str	r8, [r2, fp]

    lock_release (& file_pool . lock);
    d868:	eb001708 	bl	13490 <lock_release>
    cpu_trap_restore (it_status);
    d86c:	e59d0004 	ldr	r0, [sp, #4]
    d870:	eb000b3f 	bl	10574 <cpu_trap_restore>
     */

    dna_log(VERBOSE_LEVEL, "Created FD (%d, 0x%x).", fd, file);

    *p_fd = fd;
    *p_file = file;
    d874:	e59d3088 	ldr	r3, [sp, #136]	; 0x88
     * Return the new file and the new FD.
     */

    dna_log(VERBOSE_LEVEL, "Created FD (%d, 0x%x).", fd, file);

    *p_fd = fd;
    d878:	e1c4a0b0 	strh	sl, [r4]
    *p_file = file;

    return DNA_OK;
    d87c:	e3a00000 	mov	r0, #0
     */

    dna_log(VERBOSE_LEVEL, "Created FD (%d, 0x%x).", fd, file);

    *p_fd = fd;
    *p_file = file;
    d880:	e5838000 	str	r8, [r3]

    return DNA_OK;
    d884:	eaffffbc 	b	d77c <file_create+0x2c>
    /*
     * Allocate the new file.
     */

    file = kernel_malloc (sizeof (struct _file), true);
    check (error, file != NULL, DNA_OUT_OF_MEM);
    d888:	e59f402c 	ldr	r4, [pc, #44]	; d8bc <file_create+0x16c>
    return DNA_OK;
  }

  rescue (error)
  {
    lock_release (& file_pool . lock);
    d88c:	e59f0024 	ldr	r0, [pc, #36]	; d8b8 <file_create+0x168>
    d890:	eb0016fe 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
    d894:	e59d0004 	ldr	r0, [sp, #4]
    d898:	eb000b35 	bl	10574 <cpu_trap_restore>
    leave;
    d89c:	e1a00004 	mov	r0, r4
    d8a0:	eaffffb5 	b	d77c <file_create+0x2c>
     */

    file_array = file_pool . file[info . group];

    for (fd = 0; file_array[fd] != NULL && fd < DNA_MAX_FILE; fd += 1);
    check (error, fd != DNA_MAX_FILE, DNA_MAX_OPENED_FILES);
    d8a4:	e59f4014 	ldr	r4, [pc, #20]	; d8c0 <file_create+0x170>
    d8a8:	eafffff7 	b	d88c <file_create+0x13c>
     * Find a free file descriptor.
     */

    file_array = file_pool . file[info . group];

    for (fd = 0; file_array[fd] != NULL && fd < DNA_MAX_FILE; fd += 1);
    d8ac:	e1a0a00b 	mov	sl, fp
    d8b0:	eaffffdd 	b	d82c <file_create+0xdc>
    d8b4:	0000fffc 	.word	0x0000fffc
    d8b8:	0013f568 	.word	0x0013f568
    d8bc:	0000fffd 	.word	0x0000fffd
    d8c0:	0000fef9 	.word	0x0000fef9

0000d8c4 <vnode_create>:
 * * DNA_OUT_OF_MEM if the system ran out of memory during the operation.
 *
 * SOURCE
 */

{
    d8c4:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    d8c8:	e24dd00c 	sub	sp, sp, #12
    d8cc:	e1a09003 	mov	r9, r3
    d8d0:	e1a06002 	mov	r6, r2
    d8d4:	e1a05001 	mov	r5, r1
    d8d8:	e1a04000 	mov	r4, r0
  {
    /*
     * We first volume corresponding to vid
     */

    it_status = cpu_trap_mask_and_backup();
    d8dc:	eb000aeb 	bl	10490 <cpu_trap_mask_and_backup>
    d8e0:	e1a08000 	mov	r8, r0
    lock_acquire (& volume_manager . volume_list . lock);
    d8e4:	e59f00e4 	ldr	r0, [pc, #228]	; d9d0 <vnode_create+0x10c>
    d8e8:	eb000c34 	bl	109c0 <lock_acquire>

    volume = queue_lookup (& volume_manager . volume_list,
    d8ec:	e1a02006 	mov	r2, r6
    d8f0:	e59f10dc 	ldr	r1, [pc, #220]	; d9d4 <vnode_create+0x110>
    d8f4:	e59f00d4 	ldr	r0, [pc, #212]	; d9d0 <vnode_create+0x10c>
    d8f8:	eb00097c 	bl	fef0 <queue_lookup>
    d8fc:	e1a07000 	mov	r7, r0
        volume_id_inspector, vid);

    lock_release (& volume_manager . volume_list . lock);
    d900:	e59f00c8 	ldr	r0, [pc, #200]	; d9d0 <vnode_create+0x10c>
    d904:	eb0016e1 	bl	13490 <lock_release>
    cpu_trap_restore (it_status);
    d908:	e1a00008 	mov	r0, r8
    d90c:	eb000b18 	bl	10574 <cpu_trap_restore>

    ensure (volume != NULL, DNA_NO_VOLUME);
    d910:	e3570000 	cmp	r7, #0
    d914:	059f00bc 	ldreq	r0, [pc, #188]	; d9d8 <vnode_create+0x114>
    d918:	0a000011 	beq	d964 <vnode_create+0xa0>
    
    /*
     * Then we can check if the vnid is not already taken
     */

    it_status = cpu_trap_mask_and_backup();
    d91c:	eb000adb 	bl	10490 <cpu_trap_mask_and_backup>
    d920:	e1a08000 	mov	r8, r0
    lock_acquire (& vnode_manager . vnode_list . lock);
    d924:	e59f00b0 	ldr	r0, [pc, #176]	; d9dc <vnode_create+0x118>
    d928:	eb000c24 	bl	109c0 <lock_acquire>

    vnode = queue_lookup (& vnode_manager . vnode_list,
    d92c:	e59f10ac 	ldr	r1, [pc, #172]	; d9e0 <vnode_create+0x11c>
    d930:	e1a02004 	mov	r2, r4
    d934:	e1a03005 	mov	r3, r5
    d938:	e58d6000 	str	r6, [sp]
    d93c:	e59f0098 	ldr	r0, [pc, #152]	; d9dc <vnode_create+0x118>
    d940:	eb00096a 	bl	fef0 <queue_lookup>
    d944:	e1a06000 	mov	r6, r0
        vnode_id_inspector, vnid, vid);

    lock_release (& vnode_manager . vnode_list . lock);
    d948:	e59f008c 	ldr	r0, [pc, #140]	; d9dc <vnode_create+0x118>
    d94c:	eb0016cf 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
    d950:	e1a00008 	mov	r0, r8
    d954:	eb000b06 	bl	10574 <cpu_trap_restore>

    ensure (vnode == NULL, DNA_ERROR);
    d958:	e3560000 	cmp	r6, #0
    d95c:	159f0080 	ldrne	r0, [pc, #128]	; d9e4 <vnode_create+0x120>
    d960:	0a000001 	beq	d96c <vnode_create+0xa8>
    lock_release (& vnode_manager . vnode_list . lock);
    cpu_trap_restore(it_status);

    return DNA_OK;
  }
}
    d964:	e28dd00c 	add	sp, sp, #12
    d968:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}

    /*
     * Next, we create the vnode
     */

    vnode = kernel_malloc (sizeof (struct _vnode), true);
    d96c:	e3a00020 	mov	r0, #32
    d970:	e3a01001 	mov	r1, #1
    d974:	eb0019c5 	bl	14090 <kernel_malloc>
    ensure (vnode != NULL, DNA_OUT_OF_MEM);
    d978:	e2508000 	subs	r8, r0, #0
    d97c:	059f0064 	ldreq	r0, [pc, #100]	; d9e8 <vnode_create+0x124>
    d980:	0afffff7 	beq	d964 <vnode_create+0xa0>

    vnode -> id = vnid;
    vnode -> volume = volume;
    vnode -> destroy = false;
    vnode -> data = data;
    vnode -> usage_counter = 1;
    d984:	e3a03001 	mov	r3, #1
     */

    vnode = kernel_malloc (sizeof (struct _vnode), true);
    ensure (vnode != NULL, DNA_OUT_OF_MEM);

    vnode -> id = vnid;
    d988:	e1c840f8 	strd	r4, [r8, #8]
    vnode -> volume = volume;
    vnode -> destroy = false;
    vnode -> data = data;
    vnode -> usage_counter = 1;
    d98c:	e5883018 	str	r3, [r8, #24]

    vnode = kernel_malloc (sizeof (struct _vnode), true);
    ensure (vnode != NULL, DNA_OUT_OF_MEM);

    vnode -> id = vnid;
    vnode -> volume = volume;
    d990:	e5887010 	str	r7, [r8, #16]
    vnode -> destroy = false;
    d994:	e5c86014 	strb	r6, [r8, #20]
    vnode -> data = data;
    d998:	e588901c 	str	r9, [r8, #28]

    /*
     * And finally we add it to the vnode manager
     */

    it_status = cpu_trap_mask_and_backup();
    d99c:	eb000abb 	bl	10490 <cpu_trap_mask_and_backup>
    d9a0:	e1a04000 	mov	r4, r0
    lock_acquire (& vnode_manager . vnode_list . lock);
    d9a4:	e59f0030 	ldr	r0, [pc, #48]	; d9dc <vnode_create+0x118>
    d9a8:	eb000c04 	bl	109c0 <lock_acquire>

    queue_add (& vnode_manager . vnode_list, vnode);
    d9ac:	e1a01008 	mov	r1, r8
    d9b0:	e59f0024 	ldr	r0, [pc, #36]	; d9dc <vnode_create+0x118>
    d9b4:	eb000916 	bl	fe14 <queue_add>

    lock_release (& vnode_manager . vnode_list . lock);
    d9b8:	e59f001c 	ldr	r0, [pc, #28]	; d9dc <vnode_create+0x118>
    d9bc:	eb0016b3 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
    d9c0:	e1a00004 	mov	r0, r4
    d9c4:	eb000aea 	bl	10574 <cpu_trap_restore>

    return DNA_OK;
    d9c8:	e1a00006 	mov	r0, r6
    d9cc:	eaffffe4 	b	d964 <vnode_create+0xa0>
    d9d0:	0013f58c 	.word	0x0013f58c
    d9d4:	0000e76c 	.word	0x0000e76c
    d9d8:	0000fefe 	.word	0x0000fefe
    d9dc:	0013f574 	.word	0x0013f574
    d9e0:	0000e004 	.word	0x0000e004
    d9e4:	0000ffff 	.word	0x0000ffff
    d9e8:	0000fffd 	.word	0x0000fffd

0000d9ec <vfs_set_info>:
 *
 * SOURCE
 */

{
  file_t file = NULL;
    d9ec:	e3a01000 	mov	r1, #0
 * File attributes are modified depending on the mask.
 *
 * SOURCE
 */

{
    d9f0:	e24dd008 	sub	sp, sp, #8
    d9f4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    d9f8:	e6ffc070 	uxth	ip, r0
 * File attributes are modified depending on the mask.
 *
 * SOURCE
 */

{
    d9fc:	e24dd050 	sub	sp, sp, #80	; 0x50
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    da00:	e35c00ff 	cmp	ip, #255	; 0xff
 * File attributes are modified depending on the mask.
 *
 * SOURCE
 */

{
    da04:	e28d4068 	add	r4, sp, #104	; 0x68
    da08:	e1a05000 	mov	r5, r0
  file_t file = NULL;
    da0c:	e58d104c 	str	r1, [sp, #76]	; 0x4c
 * File attributes are modified depending on the mask.
 *
 * SOURCE
 */

{
    da10:	e884000c 	stm	r4, {r2, r3}
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    da14:	859f00b4 	ldrhi	r0, [pc, #180]	; dad0 <vfs_set_info+0xe4>
    da18:	9a000003 	bls	da2c <vfs_set_info+0x40>
  {
    status = file_put (fd);
    panic (status != DNA_OK);
    leave;
  }
}
    da1c:	e28dd050 	add	sp, sp, #80	; 0x50
    da20:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
    da24:	e28dd008 	add	sp, sp, #8
    da28:	e12fff1e 	bx	lr

    /*
     * Get the file associated to the fd.
     */

    status = file_get (fd, & file);
    da2c:	e28d104c 	add	r1, sp, #76	; 0x4c
    da30:	eb0000e1 	bl	ddbc <file_get>
    ensure (status == DNA_OK, status);
    da34:	e3500000 	cmp	r0, #0
    da38:	1afffff7 	bne	da1c <vfs_set_info+0x30>

    /*
     * Call ioctl on the file.
     */

    status = file -> vnode -> volume -> cmd -> set_info
    da3c:	e1a0e004 	mov	lr, r4
    da40:	e1a0c00d 	mov	ip, sp
    da44:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    da48:	e59d404c 	ldr	r4, [sp, #76]	; 0x4c
    da4c:	e5946008 	ldr	r6, [r4, #8]
    da50:	e5947020 	ldr	r7, [r4, #32]
    da54:	e5964010 	ldr	r4, [r6, #16]
    da58:	e596801c 	ldr	r8, [r6, #28]
    da5c:	e5946020 	ldr	r6, [r4, #32]
    da60:	e5944024 	ldr	r4, [r4, #36]	; 0x24
    da64:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    da68:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    da6c:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    da70:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    da74:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    da78:	e89e000f 	ldm	lr, {r0, r1, r2, r3}
    da7c:	e88c000f 	stm	ip, {r0, r1, r2, r3}
    da80:	e59d30a8 	ldr	r3, [sp, #168]	; 0xa8
    da84:	e1a00004 	mov	r0, r4
    da88:	e58d3040 	str	r3, [sp, #64]	; 0x40
    da8c:	e1a01008 	mov	r1, r8
    da90:	e1a02007 	mov	r2, r7
    da94:	e5963030 	ldr	r3, [r6, #48]	; 0x30
    da98:	e12fff33 	blx	r3
      (file -> vnode -> volume -> data, file -> vnode -> data,
       file -> data, info, mask);

    check (error, status == DNA_OK, status);
    da9c:	e2504000 	subs	r4, r0, #0
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    daa0:	e1a00005 	mov	r0, r5

    status = file -> vnode -> volume -> cmd -> set_info
      (file -> vnode -> volume -> data, file -> vnode -> data,
       file -> data, info, mask);

    check (error, status == DNA_OK, status);
    daa4:	0a000003 	beq	dab8 <vfs_set_info+0xcc>
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    daa8:	eb00028e 	bl	e4e8 <file_put>
    panic (status != DNA_OK);
    daac:	e3500000 	cmp	r0, #0
    dab0:	0a000004 	beq	dac8 <vfs_set_info+0xdc>
    dab4:	eafffffe 	b	dab4 <vfs_set_info+0xc8>

    /*
     * Release the file and return.
     */

    status = file_put (fd);
    dab8:	eb00028a 	bl	e4e8 <file_put>
    panic (status != DNA_OK);
    dabc:	e3500000 	cmp	r0, #0
    dac0:	0affffd5 	beq	da1c <vfs_set_info+0x30>
    dac4:	eafffffe 	b	dac4 <vfs_set_info+0xd8>
    dac8:	e1a00004 	mov	r0, r4
    dacc:	eaffffd2 	b	da1c <vfs_set_info+0x30>
    dad0:	0000fef8 	.word	0x0000fef8

0000dad4 <volume_host_inspector>:
 * SOURCE
 */

{
  volume_t volume = item;
  volume_t host = va_arg (list, volume_t);
    dad4:	e491c00b 	ldr	ip, [r1], #11
  int64_t vnid = va_arg (list, int64_t); 

  watch (bool)
  {
    ensure (volume != NULL, false);
    dad8:	e3500000 	cmp	r0, #0
 */

{
  volume_t volume = item;
  volume_t host = va_arg (list, volume_t);
  int64_t vnid = va_arg (list, int64_t); 
    dadc:	e3c11007 	bic	r1, r1, #7
    dae0:	e1c120d0 	ldrd	r2, [r1]

  watch (bool)
  {
    ensure (volume != NULL, false);
    dae4:	012fff1e 	bxeq	lr
    return volume -> host_volume == host && volume -> host_vnid == vnid;
    dae8:	e5901014 	ldr	r1, [r0, #20]
    daec:	e151000c 	cmp	r1, ip
    daf0:	0a000001 	beq	dafc <volume_host_inspector+0x28>
    daf4:	e3a00000 	mov	r0, #0
  }
}
    daf8:	e12fff1e 	bx	lr
  int64_t vnid = va_arg (list, int64_t); 

  watch (bool)
  {
    ensure (volume != NULL, false);
    return volume -> host_volume == host && volume -> host_vnid == vnid;
    dafc:	e1c001d8 	ldrd	r0, [r0, #24]
    db00:	e1530001 	cmp	r3, r1
    db04:	01520000 	cmpeq	r2, r0
    db08:	03a00001 	moveq	r0, #1
    db0c:	13a00000 	movne	r0, #0
    db10:	e12fff1e 	bx	lr

0000db14 <file_destroy>:
 * * DNA_OK if the operation succeed
 *
 * SOURCE
 */

{
    db14:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    db18:	e24dd058 	sub	sp, sp, #88	; 0x58
    db1c:	e1a04000 	mov	r4, r0
  interrupt_status_t it_status = 0;
  vnode_t vnode = NULL;

  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    db20:	e28d1004 	add	r1, sp, #4
    db24:	e3a00000 	mov	r0, #0
    db28:	eb00179b 	bl	1399c <thread_find>
    ensure (status == DNA_OK, status);
    db2c:	e3500000 	cmp	r0, #0
    db30:	0a000001 	beq	db3c <file_destroy+0x28>
  {
    lock_release (& file_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    db34:	e28dd058 	add	sp, sp, #88	; 0x58
    db38:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    ensure (status == DNA_OK, status);

    status = thread_get_info (tid, & info);
    db3c:	e59d0004 	ldr	r0, [sp, #4]
    db40:	e28d1008 	add	r1, sp, #8
    db44:	eb00133a 	bl	12834 <thread_get_info>
    ensure (status == DNA_OK, status);
    db48:	e3500000 	cmp	r0, #0
    db4c:	1afffff8 	bne	db34 <file_destroy+0x20>

    ensure (info . group >= 0, DNA_BAD_ARGUMENT);
    ensure (info . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    db50:	e59d502c 	ldr	r5, [sp, #44]	; 0x2c
    db54:	e3550000 	cmp	r5, #0
    db58:	159f00d4 	ldrne	r0, [pc, #212]	; dc34 <file_destroy+0x120>
    db5c:	1afffff4 	bne	db34 <file_destroy+0x20>

    /*
     * Look for the file in the pool.
     */

    it_status = cpu_trap_mask_and_backup();
    db60:	eb000a4a 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& file_pool . lock);
    db64:	e59f70cc 	ldr	r7, [pc, #204]	; dc38 <file_destroy+0x124>

    /*
     * Look for the file in the pool.
     */

    it_status = cpu_trap_mask_and_backup();
    db68:	e1a08000 	mov	r8, r0
    lock_acquire (& file_pool . lock);
    db6c:	e1a00007 	mov	r0, r7
    db70:	eb000b92 	bl	109c0 <lock_acquire>

    file = file_pool . file[info . group][fd];
    db74:	e5973004 	ldr	r3, [r7, #4]
    db78:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    db7c:	e7933102 	ldr	r3, [r3, r2, lsl #2]
    db80:	e7936104 	ldr	r6, [r3, r4, lsl #2]
    check (error, file != NULL, DNA_INVALID_FD);
    db84:	e3560000 	cmp	r6, #0
    db88:	0a000027 	beq	dc2c <file_destroy+0x118>
    check (error, file -> usage_counter > 0, DNA_ERROR);
    db8c:	e5963004 	ldr	r3, [r6, #4]
    db90:	e3530000 	cmp	r3, #0
    db94:	da000015 	ble	dbf0 <file_destroy+0xdc>

    atomic_add (& file -> usage_counter, -1);
    db98:	e2860004 	add	r0, r6, #4
    db9c:	e3e01000 	mvn	r1, #0
    dba0:	eb0008f0 	bl	ff68 <atomic_add>
 
    if (file -> usage_counter == 0)
    dba4:	e5963004 	ldr	r3, [r6, #4]
    dba8:	e3530000 	cmp	r3, #0
    dbac:	1a000016 	bne	dc0c <file_destroy+0xf8>
    {
      file_pool . file[info . group][fd] = NULL;
    dbb0:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
    dbb4:	e5972004 	ldr	r2, [r7, #4]

      lock_release (& file_pool . lock);
    dbb8:	e1a00007 	mov	r0, r7

    atomic_add (& file -> usage_counter, -1);
 
    if (file -> usage_counter == 0)
    {
      file_pool . file[info . group][fd] = NULL;
    dbbc:	e7922101 	ldr	r2, [r2, r1, lsl #2]
    dbc0:	e7823104 	str	r3, [r2, r4, lsl #2]

      lock_release (& file_pool . lock);
    dbc4:	eb001631 	bl	13490 <lock_release>
      cpu_trap_restore(it_status);
    dbc8:	e1a00008 	mov	r0, r8
    dbcc:	eb000a68 	bl	10574 <cpu_trap_restore>

      vnode = file -> vnode;
    dbd0:	e5964008 	ldr	r4, [r6, #8]
      kernel_free (file);
    dbd4:	e1a00006 	mov	r0, r6
    dbd8:	eb001961 	bl	14164 <kernel_free>

      status = vnode_put (vnode -> volume -> id, vnode -> id);
    dbdc:	e1c420d8 	ldrd	r2, [r4, #8]
    dbe0:	e5941010 	ldr	r1, [r4, #16]
    dbe4:	e5910004 	ldr	r0, [r1, #4]
    dbe8:	ebfffe0f 	bl	d42c <vnode_put>
    dbec:	eaffffd0 	b	db34 <file_destroy+0x20>
    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& file_pool . lock);

    file = file_pool . file[info . group][fd];
    check (error, file != NULL, DNA_INVALID_FD);
    check (error, file -> usage_counter > 0, DNA_ERROR);
    dbf0:	e59f4044 	ldr	r4, [pc, #68]	; dc3c <file_destroy+0x128>
    return DNA_OK;
  }

  rescue (error)
  {
    lock_release (& file_pool . lock);
    dbf4:	e59f003c 	ldr	r0, [pc, #60]	; dc38 <file_destroy+0x124>
    dbf8:	eb001624 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
    dbfc:	e1a00008 	mov	r0, r8
    dc00:	eb000a5b 	bl	10574 <cpu_trap_restore>
    leave;
    dc04:	e1a00004 	mov	r0, r4
    dc08:	eaffffc9 	b	db34 <file_destroy+0x20>
      status = vnode_put (vnode -> volume -> id, vnode -> id);
      ensure (status == DNA_OK, status);
    }
    else
    {
      file -> destroy = true;
    dc0c:	e3a03001 	mov	r3, #1

      lock_release (& file_pool . lock);
    dc10:	e1a00007 	mov	r0, r7
      status = vnode_put (vnode -> volume -> id, vnode -> id);
      ensure (status == DNA_OK, status);
    }
    else
    {
      file -> destroy = true;
    dc14:	e5c6300c 	strb	r3, [r6, #12]

      lock_release (& file_pool . lock);
    dc18:	eb00161c 	bl	13490 <lock_release>
      cpu_trap_restore(it_status);
    dc1c:	e1a00008 	mov	r0, r8
    dc20:	eb000a53 	bl	10574 <cpu_trap_restore>
    }

    dna_log(VERBOSE_LEVEL, "Destroyed FD %d.", fd);
    return DNA_OK;
    dc24:	e1a00005 	mov	r0, r5
    dc28:	eaffffc1 	b	db34 <file_destroy+0x20>

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& file_pool . lock);

    file = file_pool . file[info . group][fd];
    check (error, file != NULL, DNA_INVALID_FD);
    dc2c:	e59f400c 	ldr	r4, [pc, #12]	; dc40 <file_destroy+0x12c>
    dc30:	eaffffef 	b	dbf4 <file_destroy+0xe0>
    dc34:	0000fffc 	.word	0x0000fffc
    dc38:	0013f568 	.word	0x0013f568
    dc3c:	0000ffff 	.word	0x0000ffff
    dc40:	0000fef8 	.word	0x0000fef8

0000dc44 <file_get_size>:
#include <Private/VirtualFileSystem.h>
#include <Core/Core.h>
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>

status_t file_get_size(file_t file, int32_t *ret, ...){
    dc44:	e92d000e 	push	{r1, r2, r3}
    dc48:	e92d4010 	push	{r4, lr}
	 
	 status_t stat;
	 va_list va_arg;
	 va_start (va_arg, ret);
	 stat = file -> vnode -> volume -> cmd -> ioctl
    dc4c:	e5901008 	ldr	r1, [r0, #8]
#include <Private/VirtualFileSystem.h>
#include <Core/Core.h>
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>

status_t file_get_size(file_t file, int32_t *ret, ...){
    dc50:	e24dd014 	sub	sp, sp, #20
	 
	 status_t stat;
	 va_list va_arg;
	 va_start (va_arg, ret);
	 stat = file -> vnode -> volume -> cmd -> ioctl
    dc54:	e5913010 	ldr	r3, [r1, #16]
#include <Private/VirtualFileSystem.h>
#include <Core/Core.h>
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>

status_t file_get_size(file_t file, int32_t *ret, ...){
    dc58:	e59d401c 	ldr	r4, [sp, #28]
	 
	 status_t stat;
	 va_list va_arg;
	 va_start (va_arg, ret);
	 stat = file -> vnode -> volume -> cmd -> ioctl
    dc5c:	e593e020 	ldr	lr, [r3, #32]

status_t file_get_size(file_t file, int32_t *ret, ...){
	 
	 status_t stat;
	 va_list va_arg;
	 va_start (va_arg, ret);
    dc60:	e28dc020 	add	ip, sp, #32
	 stat = file -> vnode -> volume -> cmd -> ioctl
    dc64:	e5902020 	ldr	r2, [r0, #32]
    dc68:	e591101c 	ldr	r1, [r1, #28]
    dc6c:	e5930024 	ldr	r0, [r3, #36]	; 0x24
    dc70:	e58d4004 	str	r4, [sp, #4]
    dc74:	e58dc000 	str	ip, [sp]
    dc78:	e59e403c 	ldr	r4, [lr, #60]	; 0x3c
    dc7c:	e3a03000 	mov	r3, #0

status_t file_get_size(file_t file, int32_t *ret, ...){
	 
	 status_t stat;
	 va_list va_arg;
	 va_start (va_arg, ret);
    dc80:	e58dc00c 	str	ip, [sp, #12]
	 stat = file -> vnode -> volume -> cmd -> ioctl
    dc84:	e12fff34 	blx	r4
		  (file -> vnode -> volume -> data, file -> vnode -> data, file -> data,
		   DNA_GET_DEVICE_SIZE, va_arg, ret);
	 va_end (va_arg);
	 return stat;
} 
    dc88:	e28dd014 	add	sp, sp, #20
    dc8c:	e8bd4010 	pop	{r4, lr}
    dc90:	e28dd00c 	add	sp, sp, #12
    dc94:	e12fff1e 	bx	lr

0000dc98 <vfs_lseek>:
 *
 * SOURCE
 */

{
  file_t file = NULL;
    dc98:	e3a01000 	mov	r1, #0
 * * DN_OK : the operation succeeded
 *
 * SOURCE
 */

{
    dc9c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  int64_t size;
  int32_t ret;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    dca0:	e6ffc070 	uxth	ip, r0
 * * DN_OK : the operation succeeded
 *
 * SOURCE
 */

{
    dca4:	e24dd010 	sub	sp, sp, #16
  int64_t size;
  int32_t ret;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    dca8:	e35c00ff 	cmp	ip, #255	; 0xff
 * * DN_OK : the operation succeeded
 *
 * SOURCE
 */

{
    dcac:	e1a06000 	mov	r6, r0
  file_t file = NULL;
    dcb0:	e58d1000 	str	r1, [sp]
  int64_t size;
  int32_t ret;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    dcb4:	859f00f8 	ldrhi	r0, [pc, #248]	; ddb4 <vfs_lseek+0x11c>
    dcb8:	9a000001 	bls	dcc4 <vfs_lseek+0x2c>
    panic (status != DNA_OK);

    *p_ret = -1;
    leave;
  }
}
    dcbc:	e28dd010 	add	sp, sp, #16
    dcc0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  int32_t ret;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    ensure (whence == DNA_SEEK_SET || whence == DNA_SEEK_FROM_CURRENT ||
    dcc4:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
    dcc8:	e3510002 	cmp	r1, #2
    dccc:	859f00e4 	ldrhi	r0, [pc, #228]	; ddb8 <vfs_lseek+0x120>
    dcd0:	8afffff9 	bhi	dcbc <vfs_lseek+0x24>

    /*
     * Get the file associated to the fd.
     */

    status = file_get (fd, & file);
    dcd4:	e1a0100d 	mov	r1, sp
    dcd8:	e1a04002 	mov	r4, r2
    dcdc:	e1a05003 	mov	r5, r3
    dce0:	eb000035 	bl	ddbc <file_get>
    ensure (status == DNA_OK, status);
    dce4:	e3500000 	cmp	r0, #0
    dce8:	1afffff3 	bne	dcbc <vfs_lseek+0x24>

    /*
     * Check the seek whence operator.
     */

    it_status = cpu_trap_mask_and_backup();
    dcec:	eb0009e7 	bl	10490 <cpu_trap_mask_and_backup>
    dcf0:	e1a07000 	mov	r7, r0
    lock_acquire (& file -> lock);
    dcf4:	e59d0000 	ldr	r0, [sp]
    dcf8:	eb000b30 	bl	109c0 <lock_acquire>

    switch (whence)
    dcfc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
      case DNA_SEEK_SET :
        file -> offset = offset;
        break;

      case DNA_SEEK_FROM_CURRENT :
        file -> offset += offset;
    dd00:	e59d0000 	ldr	r0, [sp]
     */

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& file -> lock);

    switch (whence)
    dd04:	e3530001 	cmp	r3, #1
    dd08:	0a000024 	beq	dda0 <vfs_lseek+0x108>
    dd0c:	e3530002 	cmp	r3, #2
    dd10:	1a000015 	bne	dd6c <vfs_lseek+0xd4>
        file -> offset += offset;
        break;

      case DNA_SEEK_FROM_END :

		status = file_get_size(file, &ret, &size);
    dd14:	e28d1004 	add	r1, sp, #4
    dd18:	e28d2008 	add	r2, sp, #8
    dd1c:	ebffffc8 	bl	dc44 <file_get_size>
		/* FIXME: va_list cast may be a problem ... */

        check (error, status == DNA_OK, status);
    dd20:	e2508000 	subs	r8, r0, #0
    dd24:	1a000012 	bne	dd74 <vfs_lseek+0xdc>

        file -> offset = size + offset;
    dd28:	e1cd20d8 	ldrd	r2, [sp, #8]
    dd2c:	e59d0000 	ldr	r0, [sp]
    dd30:	e0922004 	adds	r2, r2, r4
    dd34:	e0a33005 	adc	r3, r3, r5
    dd38:	e1c021f8 	strd	r2, [r0, #24]

    /*
     * Update the offset, release the file, and return.$
     */

    lock_release (& file -> lock);
    dd3c:	eb0015d3 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
    dd40:	e1a00007 	mov	r0, r7
    dd44:	eb000a0a 	bl	10574 <cpu_trap_restore>
    
    *p_ret = file -> offset;
    dd48:	e59d3000 	ldr	r3, [sp]
    dd4c:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
    dd50:	e1c321d8 	ldrd	r2, [r3, #24]

    status = file_put (fd);
    dd54:	e1a00006 	mov	r0, r6
     */

    lock_release (& file -> lock);
    cpu_trap_restore(it_status);
    
    *p_ret = file -> offset;
    dd58:	e1c120f0 	strd	r2, [r1]

    status = file_put (fd);
    dd5c:	eb0001e1 	bl	e4e8 <file_put>
    panic (status != DNA_OK);
    dd60:	e3500000 	cmp	r0, #0
    dd64:	0affffd4 	beq	dcbc <vfs_lseek+0x24>
    dd68:	eafffffe 	b	dd68 <vfs_lseek+0xd0>
    lock_acquire (& file -> lock);

    switch (whence)
    {
      case DNA_SEEK_SET :
        file -> offset = offset;
    dd6c:	e1c041f8 	strd	r4, [r0, #24]
        break;
    dd70:	eafffff1 	b	dd3c <vfs_lseek+0xa4>
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    dd74:	e1a00006 	mov	r0, r6
    dd78:	eb0001da 	bl	e4e8 <file_put>
    panic (status != DNA_OK);
    dd7c:	e3500000 	cmp	r0, #0
    dd80:	0a000000 	beq	dd88 <vfs_lseek+0xf0>
    dd84:	eafffffe 	b	dd84 <vfs_lseek+0xec>

    *p_ret = -1;
    dd88:	e3e02000 	mvn	r2, #0
    dd8c:	e3e03000 	mvn	r3, #0
    dd90:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
    leave;
    dd94:	e1a00008 	mov	r0, r8
  rescue (error)
  {
    status = file_put (fd);
    panic (status != DNA_OK);

    *p_ret = -1;
    dd98:	e1c120f0 	strd	r2, [r1]
    leave;
    dd9c:	eaffffc6 	b	dcbc <vfs_lseek+0x24>
      case DNA_SEEK_SET :
        file -> offset = offset;
        break;

      case DNA_SEEK_FROM_CURRENT :
        file -> offset += offset;
    dda0:	e1c021d8 	ldrd	r2, [r0, #24]
    dda4:	e0922004 	adds	r2, r2, r4
    dda8:	e0a33005 	adc	r3, r3, r5
    ddac:	e1c021f8 	strd	r2, [r0, #24]
        break;
    ddb0:	eaffffe1 	b	dd3c <vfs_lseek+0xa4>
    ddb4:	0000fef8 	.word	0x0000fef8
    ddb8:	0000fef6 	.word	0x0000fef6

0000ddbc <file_get>:
 * * DNA_OK if the operation succeed
 *
 * SOURCE
 */

{
    ddbc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    ddc0:	e24dd058 	sub	sp, sp, #88	; 0x58
    ddc4:	e1a05000 	mov	r5, r0
    ddc8:	e1a04001 	mov	r4, r1
  file_t file = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    ddcc:	e3a00000 	mov	r0, #0
    ddd0:	e28d1004 	add	r1, sp, #4
    ddd4:	eb0016f0 	bl	1399c <thread_find>
    ensure (status == DNA_OK, status);
    ddd8:	e3500000 	cmp	r0, #0
    dddc:	0a000001 	beq	dde8 <file_get+0x2c>
  {
    lock_release (& file_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    dde0:	e28dd058 	add	sp, sp, #88	; 0x58
    dde4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    ensure (status == DNA_OK, status);

    status = thread_get_info (tid, & info);
    dde8:	e59d0004 	ldr	r0, [sp, #4]
    ddec:	e28d1008 	add	r1, sp, #8
    ddf0:	eb00128f 	bl	12834 <thread_get_info>
    ensure (status == DNA_OK, status);
    ddf4:	e3500000 	cmp	r0, #0
    ddf8:	1afffff8 	bne	dde0 <file_get+0x24>

    ensure (info . group >= 0, DNA_BAD_ARGUMENT);
    ensure (info . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    ddfc:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
    de00:	e3530000 	cmp	r3, #0
    de04:	0a000002 	beq	de14 <file_get+0x58>
    de08:	e59f0084 	ldr	r0, [pc, #132]	; de94 <file_get+0xd8>
  {
    lock_release (& file_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    de0c:	e28dd058 	add	sp, sp, #88	; 0x58
    de10:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    status = thread_get_info (tid, & info);
    ensure (status == DNA_OK, status);

    ensure (info . group >= 0, DNA_BAD_ARGUMENT);
    ensure (info . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    ensure (p_file != NULL, DNA_BAD_ARGUMENT);
    de14:	e3540000 	cmp	r4, #0
    de18:	0afffffa 	beq	de08 <file_get+0x4c>

    /*
     * Look for the file in the pool.
     */

    it_status = cpu_trap_mask_and_backup();
    de1c:	eb00099b 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& file_pool . lock);
    de20:	e59f6070 	ldr	r6, [pc, #112]	; de98 <file_get+0xdc>

    /*
     * Look for the file in the pool.
     */

    it_status = cpu_trap_mask_and_backup();
    de24:	e1a07000 	mov	r7, r0
    lock_acquire (& file_pool . lock);
    de28:	e1a00006 	mov	r0, r6
    de2c:	eb000ae3 	bl	109c0 <lock_acquire>

    file = file_pool . file[info . group][fd];
    de30:	e5963004 	ldr	r3, [r6, #4]
    de34:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    de38:	e7933102 	ldr	r3, [r3, r2, lsl #2]
    de3c:	e7935105 	ldr	r5, [r3, r5, lsl #2]
    check (error, file != NULL && ! file -> destroy, DNA_INVALID_FD);
    de40:	e3550000 	cmp	r5, #0
    de44:	0a000002 	beq	de54 <file_get+0x98>
    de48:	e5d5800c 	ldrb	r8, [r5, #12]
    de4c:	e3580000 	cmp	r8, #0
    de50:	0a000005 	beq	de6c <file_get+0xb0>
    return DNA_OK;
  }

  rescue (error)
  {
    lock_release (& file_pool . lock);
    de54:	e59f003c 	ldr	r0, [pc, #60]	; de98 <file_get+0xdc>
    de58:	eb00158c 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
    de5c:	e1a00007 	mov	r0, r7
    de60:	eb0009c3 	bl	10574 <cpu_trap_restore>
    leave;
    de64:	e59f0030 	ldr	r0, [pc, #48]	; de9c <file_get+0xe0>
    de68:	eaffffdc 	b	dde0 <file_get+0x24>
    lock_acquire (& file_pool . lock);

    file = file_pool . file[info . group][fd];
    check (error, file != NULL && ! file -> destroy, DNA_INVALID_FD);

    atomic_add (& file -> usage_counter, 1);
    de6c:	e3a01001 	mov	r1, #1
    de70:	e2850004 	add	r0, r5, #4
    de74:	eb00083b 	bl	ff68 <atomic_add>

    lock_release (& file_pool . lock);
    de78:	e1a00006 	mov	r0, r6
    de7c:	eb001583 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
    de80:	e1a00007 	mov	r0, r7
    de84:	eb0009ba 	bl	10574 <cpu_trap_restore>

    dna_log(VERBOSE_LEVEL, "Got FD %d.", fd);

    *p_file = file;
    de88:	e5845000 	str	r5, [r4]
    return DNA_OK;
    de8c:	e1a00008 	mov	r0, r8
    de90:	eaffffd2 	b	dde0 <file_get+0x24>
    de94:	0000fffc 	.word	0x0000fffc
    de98:	0013f568 	.word	0x0013f568
    de9c:	0000fef8 	.word	0x0000fef8

0000dea0 <vfs_ioctl>:
 *
 * SOURCE
 */

{
  file_t file = NULL;
    dea0:	e3a0c000 	mov	ip, #0
 * Implementation-dependent.
 *
 * SOURCE
 */

{
    dea4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    dea8:	e6ffe070 	uxth	lr, r0
 * Implementation-dependent.
 *
 * SOURCE
 */

{
    deac:	e24dd014 	sub	sp, sp, #20
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    deb0:	e35e00ff 	cmp	lr, #255	; 0xff
 * Implementation-dependent.
 *
 * SOURCE
 */

{
    deb4:	e1a04000 	mov	r4, r0
  file_t file = NULL;
    deb8:	e58dc00c 	str	ip, [sp, #12]
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    debc:	859f0090 	ldrhi	r0, [pc, #144]	; df54 <vfs_ioctl+0xb4>
    dec0:	9a000001 	bls	decc <vfs_ioctl+0x2c>

    *p_ret = -1;
    leave;
  }

}
    dec4:	e28dd014 	add	sp, sp, #20
    dec8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    decc:	e1a06001 	mov	r6, r1

    /*
     * Get the file associated to the fd.
     */

    status = file_get (fd, & file);
    ded0:	e28d100c 	add	r1, sp, #12
    ded4:	e1a07002 	mov	r7, r2
    ded8:	e1a05003 	mov	r5, r3
    dedc:	ebffffb6 	bl	ddbc <file_get>
    ensure (status == DNA_OK, status);
    dee0:	e3500000 	cmp	r0, #0
    dee4:	1afffff6 	bne	dec4 <vfs_ioctl+0x24>

    /*
     * Call ioctl on the file.
     */

    status = file -> vnode -> volume -> cmd -> ioctl
    dee8:	e59d200c 	ldr	r2, [sp, #12]
    deec:	e1a03006 	mov	r3, r6
    def0:	e5921008 	ldr	r1, [r2, #8]
    def4:	e5922020 	ldr	r2, [r2, #32]
    def8:	e5910010 	ldr	r0, [r1, #16]
    defc:	e591101c 	ldr	r1, [r1, #28]
    df00:	e590c020 	ldr	ip, [r0, #32]
    df04:	e5900024 	ldr	r0, [r0, #36]	; 0x24
    df08:	e58d7000 	str	r7, [sp]
    df0c:	e58d5004 	str	r5, [sp, #4]
    df10:	e59cc03c 	ldr	ip, [ip, #60]	; 0x3c
    df14:	e12fff3c 	blx	ip
      (file -> vnode -> volume -> data, file -> vnode -> data, file -> data,
       function, arguments, p_ret);

    check (error, status == DNA_OK, status);
    df18:	e2506000 	subs	r6, r0, #0
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    df1c:	e1a00004 	mov	r0, r4

    status = file -> vnode -> volume -> cmd -> ioctl
      (file -> vnode -> volume -> data, file -> vnode -> data, file -> data,
       function, arguments, p_ret);

    check (error, status == DNA_OK, status);
    df20:	0a000003 	beq	df34 <vfs_ioctl+0x94>
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    df24:	eb00016f 	bl	e4e8 <file_put>
    panic (status != DNA_OK);
    df28:	e3500000 	cmp	r0, #0
    df2c:	0a000004 	beq	df44 <vfs_ioctl+0xa4>
    df30:	eafffffe 	b	df30 <vfs_ioctl+0x90>

    /*
     * Release the file and return.
     */

    status = file_put (fd);
    df34:	eb00016b 	bl	e4e8 <file_put>
    panic (status != DNA_OK);
    df38:	e3500000 	cmp	r0, #0
    df3c:	0affffe0 	beq	dec4 <vfs_ioctl+0x24>
    df40:	eafffffe 	b	df40 <vfs_ioctl+0xa0>
  rescue (error)
  {
    status = file_put (fd);
    panic (status != DNA_OK);

    *p_ret = -1;
    df44:	e3e03000 	mvn	r3, #0
    leave;
    df48:	e1a00006 	mov	r0, r6
  rescue (error)
  {
    status = file_put (fd);
    panic (status != DNA_OK);

    *p_ret = -1;
    df4c:	e5853000 	str	r3, [r5]
    leave;
    df50:	eaffffdb 	b	dec4 <vfs_ioctl+0x24>
    df54:	0000fef8 	.word	0x0000fef8

0000df58 <vfs_destroy>:
 */

{

  return DNA_NOT_IMPLEMENTED;
}
    df58:	e59f0000 	ldr	r0, [pc]	; df60 <vfs_destroy+0x8>
    df5c:	e12fff1e 	bx	lr
    df60:	0000fffe 	.word	0x0000fffe

0000df64 <vfs_get_info>:
 *
 * SOURCE
 */

{
  file_t file = NULL;
    df64:	e3a02000 	mov	r2, #0
 * Fill-in the file_info_t structure.
 *
 * SOURCE
 */

{
    df68:	e92d4030 	push	{r4, r5, lr}
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    df6c:	e6ff3070 	uxth	r3, r0
 * Fill-in the file_info_t structure.
 *
 * SOURCE
 */

{
    df70:	e24dd00c 	sub	sp, sp, #12
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    df74:	e35300ff 	cmp	r3, #255	; 0xff
 * Fill-in the file_info_t structure.
 *
 * SOURCE
 */

{
    df78:	e1a04000 	mov	r4, r0
  file_t file = NULL;
    df7c:	e58d2004 	str	r2, [sp, #4]
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    df80:	859f0078 	ldrhi	r0, [pc, #120]	; e000 <vfs_get_info+0x9c>
    df84:	9a000001 	bls	df90 <vfs_get_info+0x2c>
    status = file_put (fd);
    panic (status != DNA_OK);
    leave;
  }

}
    df88:	e28dd00c 	add	sp, sp, #12
    df8c:	e8bd8030 	pop	{r4, r5, pc}
    df90:	e1a05001 	mov	r5, r1

    /*
     * Get the file associated to the fd.
     */

    status = file_get (fd, & file);
    df94:	e28d1004 	add	r1, sp, #4
    df98:	ebffff87 	bl	ddbc <file_get>
    ensure (status == DNA_OK, status);
    df9c:	e3500000 	cmp	r0, #0
    dfa0:	1afffff8 	bne	df88 <vfs_get_info+0x24>

    /*
     * Call ioctl on the file.
     */

    status = file -> vnode -> volume -> cmd -> get_info
    dfa4:	e59d2004 	ldr	r2, [sp, #4]
    dfa8:	e1a03005 	mov	r3, r5
    dfac:	e5921008 	ldr	r1, [r2, #8]
    dfb0:	e5922020 	ldr	r2, [r2, #32]
    dfb4:	e5910010 	ldr	r0, [r1, #16]
    dfb8:	e591101c 	ldr	r1, [r1, #28]
    dfbc:	e590c020 	ldr	ip, [r0, #32]
    dfc0:	e5900024 	ldr	r0, [r0, #36]	; 0x24
    dfc4:	e59cc02c 	ldr	ip, [ip, #44]	; 0x2c
    dfc8:	e12fff3c 	blx	ip
      (file -> vnode -> volume -> data, file -> vnode -> data,
       file -> data, p_info);

    check (error, status == DNA_OK, status);
    dfcc:	e2505000 	subs	r5, r0, #0
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    dfd0:	e1a00004 	mov	r0, r4

    status = file -> vnode -> volume -> cmd -> get_info
      (file -> vnode -> volume -> data, file -> vnode -> data,
       file -> data, p_info);

    check (error, status == DNA_OK, status);
    dfd4:	0a000003 	beq	dfe8 <vfs_get_info+0x84>
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    dfd8:	eb000142 	bl	e4e8 <file_put>
    panic (status != DNA_OK);
    dfdc:	e3500000 	cmp	r0, #0
    dfe0:	0a000004 	beq	dff8 <vfs_get_info+0x94>
    dfe4:	eafffffe 	b	dfe4 <vfs_get_info+0x80>

    /*
     * Release the file and return.
     */

    status = file_put (fd);
    dfe8:	eb00013e 	bl	e4e8 <file_put>
    panic (status != DNA_OK);
    dfec:	e3500000 	cmp	r0, #0
    dff0:	0affffe4 	beq	df88 <vfs_get_info+0x24>
    dff4:	eafffffe 	b	dff4 <vfs_get_info+0x90>
    dff8:	e1a00005 	mov	r0, r5
    dffc:	eaffffe1 	b	df88 <vfs_get_info+0x24>
    e000:	0000fef8 	.word	0x0000fef8

0000e004 <vnode_id_inspector>:
 * SOURCE
 */

{
  vnode_t vnode = node;
  int64_t vnid = va_arg (list, int64_t);
    e004:	e2811007 	add	r1, r1, #7
    e008:	e3c11007 	bic	r1, r1, #7
  int32_t vid = va_arg (list, int32_t);

  watch (bool)
  {
    ensure (vnode != NULL, false);
    e00c:	e3500000 	cmp	r0, #0
 * SOURCE
 */

{
  vnode_t vnode = node;
  int64_t vnid = va_arg (list, int64_t);
    e010:	e1c120d0 	ldrd	r2, [r1]
  int32_t vid = va_arg (list, int32_t);
    e014:	e5911008 	ldr	r1, [r1, #8]

  watch (bool)
  {
    ensure (vnode != NULL, false);
    e018:	012fff1e 	bxeq	lr
 * Return TRUE if the strings match, FALSE otherwise.
 *
 * SOURCE
 */

{
    e01c:	e92d0030 	push	{r4, r5}
  int32_t vid = va_arg (list, int32_t);

  watch (bool)
  {
    ensure (vnode != NULL, false);
    return vnode -> id == vnid && vnode -> volume -> id == vid;
    e020:	e1c040d8 	ldrd	r4, [r0, #8]
    e024:	e1550003 	cmp	r5, r3
    e028:	01540002 	cmpeq	r4, r2
    e02c:	05903010 	ldreq	r3, [r0, #16]
    e030:	13a00000 	movne	r0, #0
  }
}
    e034:	e8bd0030 	pop	{r4, r5}
  int32_t vid = va_arg (list, int32_t);

  watch (bool)
  {
    ensure (vnode != NULL, false);
    return vnode -> id == vnid && vnode -> volume -> id == vid;
    e038:	05930004 	ldreq	r0, [r3, #4]
    e03c:	00600001 	rsbeq	r0, r0, r1
    e040:	016f0f10 	clzeq	r0, r0
    e044:	01a002a0 	lsreq	r0, r0, #5
  }
}
    e048:	e12fff1e 	bx	lr

0000e04c <vfs_open>:
 * * DNA_OK : the operation succeeded
 *
 * SOURCE
 */

{
    e04c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
  int16_t fd = -1;
  file_t file = NULL;
    e050:	e3a0c000 	mov	ip, #0
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (path != NULL && p_fd != NULL, DNA_ERROR);
    e054:	e3530000 	cmp	r3, #0
    e058:	13500000 	cmpne	r0, #0
 */

{
  int16_t fd = -1;
  file_t file = NULL;
  int64_t vnid = -1, file_vnid = -1;
    e05c:	e3e04000 	mvn	r4, #0
    e060:	e3e05000 	mvn	r5, #0
 *
 * SOURCE
 */

{
  int16_t fd = -1;
    e064:	e3e0a000 	mvn	sl, #0
 * * DNA_OK : the operation succeeded
 *
 * SOURCE
 */

{
    e068:	e24dde53 	sub	sp, sp, #1328	; 0x530
    e06c:	e24dd008 	sub	sp, sp, #8
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (path != NULL && p_fd != NULL, DNA_ERROR);
    e070:	e1a06003 	mov	r6, r3
 *
 * SOURCE
 */

{
  int16_t fd = -1;
    e074:	e59fe1c4 	ldr	lr, [pc, #452]	; e240 <vfs_open+0x1f4>
  file_t file = NULL;
  int64_t vnid = -1, file_vnid = -1;
    e078:	e59f31c4 	ldr	r3, [pc, #452]	; e244 <vfs_open+0x1f8>
    e07c:	e59f71c4 	ldr	r7, [pc, #452]	; e248 <vfs_open+0x1fc>
 * * DNA_OK : the operation succeeded
 *
 * SOURCE
 */

{
    e080:	e1a08001 	mov	r8, r1
  int16_t fd = -1;
    e084:	e28d1e53 	add	r1, sp, #1328	; 0x530
    e088:	e2811008 	add	r1, r1, #8
    e08c:	e181a0be 	strh	sl, [r1, lr]
  file_t file = NULL;
    e090:	e58dc018 	str	ip, [sp, #24]
  int64_t vnid = -1, file_vnid = -1;
  vnode_t vnode = NULL;
  volume_t volume = NULL;
    e094:	e58dc01c 	str	ip, [sp, #28]
  void * data = NULL, * file_data = NULL;
    e098:	e58dc020 	str	ip, [sp, #32]
    e09c:	e58dc024 	str	ip, [sp, #36]	; 0x24
 */

{
  int16_t fd = -1;
  file_t file = NULL;
  int64_t vnid = -1, file_vnid = -1;
    e0a0:	e18140f3 	strd	r4, [r1, r3]
    e0a4:	e18140f7 	strd	r4, [r1, r7]
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (path != NULL && p_fd != NULL, DNA_ERROR);
    e0a8:	059f019c 	ldreq	r0, [pc, #412]	; e24c <vfs_open+0x200>
    e0ac:	1a000002 	bne	e0bc <vfs_open+0x70>
    ensure (status == DNA_OK, status);
 
    *p_fd = fd;
    return DNA_OK;
  }
}
    e0b0:	e28dde53 	add	sp, sp, #1328	; 0x530
    e0b4:	e28dd008 	add	sp, sp, #8
    e0b8:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (path != NULL && p_fd != NULL, DNA_ERROR);
    dna_strcpy (buffer, path);
    e0bc:	e1a01000 	mov	r1, r0
    e0c0:	e28d0f4e 	add	r0, sp, #312	; 0x138
    e0c4:	e1a09002 	mov	r9, r2
    e0c8:	eb0007ea 	bl	10078 <dna_strcpy>

    if ((mode & DNA_CREATE) != 0)
    e0cc:	e3180c02 	tst	r8, #512	; 0x200
    e0d0:	0a000023 	beq	e164 <vfs_open+0x118>
    {
      /*
       * Spilt the path into base + token
       */

      status = path_split (buffer, token);
    e0d4:	e28d1038 	add	r1, sp, #56	; 0x38
    e0d8:	e28d0f4e 	add	r0, sp, #312	; 0x138
    e0dc:	eb0007b9 	bl	ffc8 <path_split>
      ensure (status == DNA_OK, status);
    e0e0:	e3500000 	cmp	r0, #0
    e0e4:	1afffff1 	bne	e0b0 <vfs_open+0x64>

      /*
       * Get the vnode corresponding to the base directory
       */

      status = vnode_walk (buffer, & volume, & vnid, & data);
    e0e8:	e28d2028 	add	r2, sp, #40	; 0x28
    e0ec:	e28d0f4e 	add	r0, sp, #312	; 0x138
    e0f0:	e28d101c 	add	r1, sp, #28
    e0f4:	e2423008 	sub	r3, r2, #8
    e0f8:	eb000368 	bl	eea0 <vnode_walk>
      ensure (status == DNA_OK, status);
    e0fc:	e3500000 	cmp	r0, #0
    e100:	1affffea 	bne	e0b0 <vfs_open+0x64>

      /*
       * Ask to create the file.
       */

      status = volume -> cmd -> create (volume -> data, data, token,
    e104:	e59d301c 	ldr	r3, [sp, #28]
    e108:	e28dc024 	add	ip, sp, #36	; 0x24
    e10c:	e5932020 	ldr	r2, [r3, #32]
    e110:	e5930024 	ldr	r0, [r3, #36]	; 0x24
    e114:	e28d3030 	add	r3, sp, #48	; 0x30
    e118:	e58d3004 	str	r3, [sp, #4]
    e11c:	e58dc008 	str	ip, [sp, #8]
    e120:	e58d9000 	str	r9, [sp]
    e124:	e592c020 	ldr	ip, [r2, #32]
    e128:	e59d1020 	ldr	r1, [sp, #32]
    e12c:	e28d2038 	add	r2, sp, #56	; 0x38
    e130:	e1a03008 	mov	r3, r8
    e134:	e12fff3c 	blx	ip
          mode, perms, & file_vnid, & file_data);
      ensure (status == DNA_OK, status);
    e138:	e3500000 	cmp	r0, #0
    e13c:	1affffdb 	bne	e0b0 <vfs_open+0x64>

      /*
       * Release the parent file, it is not required anymore.
       */

      status = vnode_put (volume -> id, vnid);
    e140:	e59d101c 	ldr	r1, [sp, #28]
    e144:	e28dce53 	add	ip, sp, #1328	; 0x530
    e148:	e28cc008 	add	ip, ip, #8
    e14c:	e18c20d7 	ldrd	r2, [ip, r7]
    e150:	e5910004 	ldr	r0, [r1, #4]
    e154:	ebfffcb4 	bl	d42c <vnode_put>
      panic (status != DNA_OK);
    e158:	e3500000 	cmp	r0, #0
    e15c:	0a000011 	beq	e1a8 <vfs_open+0x15c>
    e160:	eafffffe 	b	e160 <vfs_open+0x114>
    {
      /*
       * Get the vnode corresponding to the base directory
       */

      status = vnode_walk (buffer, & volume, & vnid, & data);
    e164:	e28d2028 	add	r2, sp, #40	; 0x28
    e168:	e28d0f4e 	add	r0, sp, #312	; 0x138
    e16c:	e28d101c 	add	r1, sp, #28
    e170:	e2423008 	sub	r3, r2, #8
    e174:	eb000349 	bl	eea0 <vnode_walk>
      ensure (status == DNA_OK, status);
    e178:	e3500000 	cmp	r0, #0
    e17c:	1affffcb 	bne	e0b0 <vfs_open+0x64>

      /*
       * Ask to open the file
       */

      status = volume -> cmd -> open (volume -> data, data, mode, & file_data);
    e180:	e59d201c 	ldr	r2, [sp, #28]
    e184:	e28d3024 	add	r3, sp, #36	; 0x24
    e188:	e5921020 	ldr	r1, [r2, #32]
    e18c:	e5920024 	ldr	r0, [r2, #36]	; 0x24
    e190:	e591c014 	ldr	ip, [r1, #20]
    e194:	e1a02008 	mov	r2, r8
    e198:	e59d1020 	ldr	r1, [sp, #32]
    e19c:	e12fff3c 	blx	ip
      ensure (status == DNA_OK, status);
    e1a0:	e3500000 	cmp	r0, #0
    e1a4:	1affffc1 	bne	e0b0 <vfs_open+0x64>
  
    /*
     * Find the new vnode.
     */

    it_status = cpu_trap_mask_and_backup();
    e1a8:	eb0008b8 	bl	10490 <cpu_trap_mask_and_backup>
    e1ac:	e1a05000 	mov	r5, r0
    lock_acquire (& vnode_manager . lock);
    e1b0:	e59f0098 	ldr	r0, [pc, #152]	; e250 <vfs_open+0x204>
    e1b4:	eb000a01 	bl	109c0 <lock_acquire>

    vnode = queue_lookup (& vnode_manager . vnode_list,
    e1b8:	e59d201c 	ldr	r2, [sp, #28]
    e1bc:	e59f3084 	ldr	r3, [pc, #132]	; e248 <vfs_open+0x1fc>
    e1c0:	e5921004 	ldr	r1, [r2, #4]
    e1c4:	e28d0e53 	add	r0, sp, #1328	; 0x530
    e1c8:	e2800008 	add	r0, r0, #8
    e1cc:	e18320d0 	ldrd	r2, [r3, r0]
    e1d0:	e58d1000 	str	r1, [sp]
    e1d4:	e59f0078 	ldr	r0, [pc, #120]	; e254 <vfs_open+0x208>
    e1d8:	e59f1078 	ldr	r1, [pc, #120]	; e258 <vfs_open+0x20c>
    e1dc:	eb000743 	bl	fef0 <queue_lookup>
    e1e0:	e1a04000 	mov	r4, r0
        vnode_id_inspector, vnid, volume -> id);

    lock_release (& vnode_manager . lock);
    e1e4:	e59f0064 	ldr	r0, [pc, #100]	; e250 <vfs_open+0x204>
    e1e8:	eb0014a8 	bl	13490 <lock_release>
    cpu_trap_restore (it_status);
    e1ec:	e1a00005 	mov	r0, r5
    e1f0:	eb0008df 	bl	10574 <cpu_trap_restore>

    ensure (vnode != NULL, DNA_NO_VNODE);
    e1f4:	e3540000 	cmp	r4, #0
    e1f8:	0a00000e 	beq	e238 <vfs_open+0x1ec>

    /*
     * Acquire a new file.
     */

    status = file_create (vnode, mode, file_data, & fd, & file); 
    e1fc:	e28d3018 	add	r3, sp, #24
    e200:	e58d3000 	str	r3, [sp]
    e204:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
    e208:	e1a00004 	mov	r0, r4
    e20c:	e1a01008 	mov	r1, r8
    e210:	e28d3016 	add	r3, sp, #22
    e214:	ebfffd4d 	bl	d750 <file_create>
    ensure (status == DNA_OK, status);
    e218:	e3500000 	cmp	r0, #0
    e21c:	1affffa3 	bne	e0b0 <vfs_open+0x64>
 
    *p_fd = fd;
    e220:	e59f3018 	ldr	r3, [pc, #24]	; e240 <vfs_open+0x1f4>
    e224:	e28d1e53 	add	r1, sp, #1328	; 0x530
    e228:	e2811008 	add	r1, r1, #8
    e22c:	e19130b3 	ldrh	r3, [r1, r3]
    e230:	e1c630b0 	strh	r3, [r6]
    return DNA_OK;
    e234:	eaffff9d 	b	e0b0 <vfs_open+0x64>
        vnode_id_inspector, vnid, volume -> id);

    lock_release (& vnode_manager . lock);
    cpu_trap_restore (it_status);

    ensure (vnode != NULL, DNA_NO_VNODE);
    e238:	e59f001c 	ldr	r0, [pc, #28]	; e25c <vfs_open+0x210>
    e23c:	eaffff9b 	b	e0b0 <vfs_open+0x64>
    e240:	fffffade 	.word	0xfffffade
    e244:	fffffaf8 	.word	0xfffffaf8
    e248:	fffffaf0 	.word	0xfffffaf0
    e24c:	0000ffff 	.word	0x0000ffff
    e250:	0013f570 	.word	0x0013f570
    e254:	0013f574 	.word	0x0013f574
    e258:	0000e004 	.word	0x0000e004
    e25c:	0000fefd 	.word	0x0000fefd

0000e260 <filesystem_load>:

/*
 * SOURCE
 */

{
    e260:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}

  watch (status_t)
  {
    dna_log(INFO_LEVEL, "Loading FS \"%s\"", name);

    for (int32_t i = 0; i < OS_N_FILESYSTEMS; i++)
    e264:	e59f612c 	ldr	r6, [pc, #300]	; e398 <filesystem_load+0x138>
    e268:	e5963000 	ldr	r3, [r6]
    e26c:	e3530000 	cmp	r3, #0
    e270:	da000046 	ble	e390 <filesystem_load+0x130>
    e274:	e1a07000 	mov	r7, r0
    e278:	e1a08001 	mov	r8, r1
    e27c:	e3a04000 	mov	r4, #0
    e280:	e59f5114 	ldr	r5, [pc, #276]	; e39c <filesystem_load+0x13c>
    e284:	ea000003 	b	e298 <filesystem_load+0x38>
    e288:	e5963000 	ldr	r3, [r6]
    e28c:	e2844001 	add	r4, r4, #1
    e290:	e1530004 	cmp	r3, r4
    e294:	da00003d 	ble	e390 <filesystem_load+0x130>
    {
      if (dna_strcmp (OS_FILESYSTEMS_LIST[i] -> name, name) == 0)
    e298:	e5b53004 	ldr	r3, [r5, #4]!
    e29c:	e1a01007 	mov	r1, r7
    e2a0:	e5930000 	ldr	r0, [r3]
    e2a4:	eb000705 	bl	fec0 <dna_strcmp>
    e2a8:	e3500000 	cmp	r0, #0
    e2ac:	1afffff5 	bne	e288 <filesystem_load+0x28>
      {
        new_fs = OS_FILESYSTEMS_LIST[i];
    e2b0:	e59f30e8 	ldr	r3, [pc, #232]	; e3a0 <filesystem_load+0x140>
    e2b4:	e7932104 	ldr	r2, [r3, r4, lsl #2]
        break;
      }
    }

    ensure (new_fs != NULL, DNA_ERROR);
    e2b8:	e3520000 	cmp	r2, #0
    e2bc:	0a000033 	beq	e390 <filesystem_load+0x130>
     * Check the consistency of the filesystem.
     */

    for (int32_t i = 0; i < sizeof (filesystem_cmd_t) >> 2; i += 1)
    {
      ensure (((void **)new_fs -> cmd)[i] != NULL, DNA_ERROR);
    e2c0:	e5923004 	ldr	r3, [r2, #4]
    e2c4:	e5931000 	ldr	r1, [r3]
    e2c8:	e3510000 	cmp	r1, #0
    e2cc:	0a00002f 	beq	e390 <filesystem_load+0x130>
    e2d0:	e5931004 	ldr	r1, [r3, #4]
    e2d4:	e3510000 	cmp	r1, #0
    e2d8:	0a00002c 	beq	e390 <filesystem_load+0x130>
    e2dc:	e5931008 	ldr	r1, [r3, #8]
    e2e0:	e3510000 	cmp	r1, #0
    e2e4:	0a000029 	beq	e390 <filesystem_load+0x130>
    e2e8:	e593100c 	ldr	r1, [r3, #12]
    e2ec:	e3510000 	cmp	r1, #0
    e2f0:	0a000026 	beq	e390 <filesystem_load+0x130>
    e2f4:	e5931010 	ldr	r1, [r3, #16]
    e2f8:	e3510000 	cmp	r1, #0
    e2fc:	0a000023 	beq	e390 <filesystem_load+0x130>
    e300:	e5931014 	ldr	r1, [r3, #20]
    e304:	e3510000 	cmp	r1, #0
    e308:	0a000020 	beq	e390 <filesystem_load+0x130>
    e30c:	e5931018 	ldr	r1, [r3, #24]
    e310:	e3510000 	cmp	r1, #0
    e314:	0a00001d 	beq	e390 <filesystem_load+0x130>
    e318:	e593101c 	ldr	r1, [r3, #28]
    e31c:	e3510000 	cmp	r1, #0
    e320:	0a00001a 	beq	e390 <filesystem_load+0x130>
    e324:	e5931020 	ldr	r1, [r3, #32]
    e328:	e3510000 	cmp	r1, #0
    e32c:	0a000017 	beq	e390 <filesystem_load+0x130>
    e330:	e5931024 	ldr	r1, [r3, #36]	; 0x24
    e334:	e3510000 	cmp	r1, #0
    e338:	0a000014 	beq	e390 <filesystem_load+0x130>
    e33c:	e5931028 	ldr	r1, [r3, #40]	; 0x28
    e340:	e3510000 	cmp	r1, #0
    e344:	0a000011 	beq	e390 <filesystem_load+0x130>
    e348:	e593102c 	ldr	r1, [r3, #44]	; 0x2c
    e34c:	e3510000 	cmp	r1, #0
    e350:	0a00000e 	beq	e390 <filesystem_load+0x130>
    e354:	e5931030 	ldr	r1, [r3, #48]	; 0x30
    e358:	e3510000 	cmp	r1, #0
    e35c:	0a00000b 	beq	e390 <filesystem_load+0x130>
    e360:	e5931034 	ldr	r1, [r3, #52]	; 0x34
    e364:	e3510000 	cmp	r1, #0
    e368:	0a000008 	beq	e390 <filesystem_load+0x130>
    e36c:	e5931038 	ldr	r1, [r3, #56]	; 0x38
    e370:	e3510000 	cmp	r1, #0
    e374:	0a000005 	beq	e390 <filesystem_load+0x130>
    e378:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
    e37c:	e3530000 	cmp	r3, #0
    e380:	0a000002 	beq	e390 <filesystem_load+0x130>
    }

    *fs = new_fs;
    e384:	e5882000 	str	r2, [r8]
    return DNA_OK;
    e388:	e3a00000 	mov	r0, #0
    e38c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        new_fs = OS_FILESYSTEMS_LIST[i];
        break;
      }
    }

    ensure (new_fs != NULL, DNA_ERROR);
    e390:	e59f000c 	ldr	r0, [pc, #12]	; e3a4 <filesystem_load+0x144>
    e394:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    e398:	0003e924 	.word	0x0003e924
    e39c:	0003e924 	.word	0x0003e924
    e3a0:	0003e928 	.word	0x0003e928
    e3a4:	0000ffff 	.word	0x0000ffff

0000e3a8 <vfs_create>:
 * Initializes the VFS structures.
 *
 * SOURCE
 */

{
    e3a8:	e92d4038 	push	{r3, r4, r5, lr}
  watch (status_t)
  {
    dna_memset (& vnode_manager, 0, sizeof (vnode_manager_t));
    e3ac:	e3a01000 	mov	r1, #0
    e3b0:	e3a02014 	mov	r2, #20

    /*
     * Initialize the file pool.
     */

    dna_memset (& file_pool, 0, sizeof (file_pool_t));
    e3b4:	e59f407c 	ldr	r4, [pc, #124]	; e438 <vfs_create+0x90>
 */

{
  watch (status_t)
  {
    dna_memset (& vnode_manager, 0, sizeof (vnode_manager_t));
    e3b8:	e59f007c 	ldr	r0, [pc, #124]	; e43c <vfs_create+0x94>
    e3bc:	eb00042c 	bl	f474 <dna_memset>
    dna_memset (& volume_manager, 0, sizeof (volume_manager_t));
    e3c0:	e3a01000 	mov	r1, #0
    e3c4:	e3a02018 	mov	r2, #24
    e3c8:	e59f0070 	ldr	r0, [pc, #112]	; e440 <vfs_create+0x98>
    e3cc:	eb000428 	bl	f474 <dna_memset>

    /*
     * Initialize the file pool.
     */

    dna_memset (& file_pool, 0, sizeof (file_pool_t));
    e3d0:	e3a01000 	mov	r1, #0
    e3d4:	e3a02008 	mov	r2, #8
    e3d8:	e1a00004 	mov	r0, r4
    e3dc:	eb000424 	bl	f474 <dna_memset>

    file_pool . file = kernel_malloc (DNA_MAX_GROUP * sizeof (file_t *), true);
    e3e0:	e3a00004 	mov	r0, #4
    e3e4:	e3a01001 	mov	r1, #1
    e3e8:	eb001728 	bl	14090 <kernel_malloc>
    ensure (file_pool . file != NULL, DNA_OUT_OF_MEM);
    e3ec:	e3500000 	cmp	r0, #0
     * Initialize the file pool.
     */

    dna_memset (& file_pool, 0, sizeof (file_pool_t));

    file_pool . file = kernel_malloc (DNA_MAX_GROUP * sizeof (file_t *), true);
    e3f0:	e1a05000 	mov	r5, r0
    e3f4:	e5840004 	str	r0, [r4, #4]
    ensure (file_pool . file != NULL, DNA_OUT_OF_MEM);
    e3f8:	0a000009 	beq	e424 <vfs_create+0x7c>

    for (int32_t i = 0; i < DNA_MAX_GROUP; i += 1)
    {
      file_pool . file[i] = kernel_malloc
        (DNA_MAX_FILE * sizeof (file_t), true);
    e3fc:	e3a00b01 	mov	r0, #1024	; 0x400
    e400:	e3a01001 	mov	r1, #1
    e404:	eb001721 	bl	14090 <kernel_malloc>
    file_pool . file = kernel_malloc (DNA_MAX_GROUP * sizeof (file_t *), true);
    ensure (file_pool . file != NULL, DNA_OUT_OF_MEM);

    for (int32_t i = 0; i < DNA_MAX_GROUP; i += 1)
    {
      file_pool . file[i] = kernel_malloc
    e408:	e5850000 	str	r0, [r5]
        (DNA_MAX_FILE * sizeof (file_t), true);
      check (file_no_mem, file_pool . file[i] != NULL, DNA_OUT_OF_MEM);
    e40c:	e5940004 	ldr	r0, [r4, #4]
    e410:	e5903000 	ldr	r3, [r0]
    e414:	e3530000 	cmp	r3, #0
    e418:	0a000003 	beq	e42c <vfs_create+0x84>
    }

    return DNA_OK;
    e41c:	e3a00000 	mov	r0, #0
    }

    kernel_free (file_pool . file);
    leave;
  }
}
    e420:	e8bd8038 	pop	{r3, r4, r5, pc}
     */

    dna_memset (& file_pool, 0, sizeof (file_pool_t));

    file_pool . file = kernel_malloc (DNA_MAX_GROUP * sizeof (file_t *), true);
    ensure (file_pool . file != NULL, DNA_OUT_OF_MEM);
    e424:	e59f0018 	ldr	r0, [pc, #24]	; e444 <vfs_create+0x9c>
    e428:	e8bd8038 	pop	{r3, r4, r5, pc}
      {
        kernel_free (file_pool . file[i]);
      }
    }

    kernel_free (file_pool . file);
    e42c:	eb00174c 	bl	14164 <kernel_free>
    leave;
    e430:	e59f000c 	ldr	r0, [pc, #12]	; e444 <vfs_create+0x9c>
    e434:	e8bd8038 	pop	{r3, r4, r5, pc}
    e438:	0013f568 	.word	0x0013f568
    e43c:	0013f570 	.word	0x0013f570
    e440:	0013f584 	.word	0x0013f584
    e444:	0000fffd 	.word	0x0000fffd

0000e448 <volume_create>:
 * DNA_OK if th operation succedded, DNA_ERROR otherwise.
 *
 * SOURCE
 */

{
    e448:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
  volume_t volume = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    volume = kernel_malloc (sizeof (struct _volume), true);
    e44c:	e3a01001 	mov	r1, #1
 * DNA_OK if th operation succedded, DNA_ERROR otherwise.
 *
 * SOURCE
 */

{
    e450:	e1a07000 	mov	r7, r0
  volume_t volume = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    volume = kernel_malloc (sizeof (struct _volume), true);
    e454:	e3a00028 	mov	r0, #40	; 0x28
 * DNA_OK if th operation succedded, DNA_ERROR otherwise.
 *
 * SOURCE
 */

{
    e458:	e1a04002 	mov	r4, r2
    e45c:	e1a05003 	mov	r5, r3
  volume_t volume = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    volume = kernel_malloc (sizeof (struct _volume), true);
    e460:	eb00170a 	bl	14090 <kernel_malloc>
    ensure (volume != NULL, DNA_OUT_OF_MEM);
    e464:	e2506000 	subs	r6, r0, #0
    e468:	0a000019 	beq	e4d4 <volume_create+0x8c>

    volume -> id = atomic_add (& volume_manager . volume_index, 1);
    e46c:	e3a01001 	mov	r1, #1
    e470:	e59f0064 	ldr	r0, [pc, #100]	; e4dc <volume_create+0x94>
    e474:	eb0006bb 	bl	ff68 <atomic_add>
    volume -> root_vnid = -1;
    e478:	e3e02000 	mvn	r2, #0
    e47c:	e3e03000 	mvn	r3, #0
    volume -> host_volume = host_volume;
    volume -> host_vnid = host_vnid;
    volume -> cmd = cmd;
    e480:	e59d1018 	ldr	r1, [sp, #24]
  {
    volume = kernel_malloc (sizeof (struct _volume), true);
    ensure (volume != NULL, DNA_OUT_OF_MEM);

    volume -> id = atomic_add (& volume_manager . volume_index, 1);
    volume -> root_vnid = -1;
    e484:	e1c620f8 	strd	r2, [r6, #8]
    volume -> host_volume = host_volume;
    volume -> host_vnid = host_vnid;
    volume -> cmd = cmd;
    e488:	e5861020 	str	r1, [r6, #32]
    ensure (volume != NULL, DNA_OUT_OF_MEM);

    volume -> id = atomic_add (& volume_manager . volume_index, 1);
    volume -> root_vnid = -1;
    volume -> host_volume = host_volume;
    volume -> host_vnid = host_vnid;
    e48c:	e1c641f8 	strd	r4, [r6, #24]
  watch (status_t)
  {
    volume = kernel_malloc (sizeof (struct _volume), true);
    ensure (volume != NULL, DNA_OUT_OF_MEM);

    volume -> id = atomic_add (& volume_manager . volume_index, 1);
    e490:	e5860004 	str	r0, [r6, #4]
    volume -> root_vnid = -1;
    volume -> host_volume = host_volume;
    e494:	e5867014 	str	r7, [r6, #20]
    volume -> host_vnid = host_vnid;
    volume -> cmd = cmd;

    it_status = cpu_trap_mask_and_backup();
    e498:	eb0007fc 	bl	10490 <cpu_trap_mask_and_backup>
    e49c:	e1a04000 	mov	r4, r0
    lock_acquire (& volume_manager . volume_list . lock);
    e4a0:	e59f0038 	ldr	r0, [pc, #56]	; e4e0 <volume_create+0x98>
    e4a4:	eb000945 	bl	109c0 <lock_acquire>

    queue_add (& volume_manager . volume_list, volume);
    e4a8:	e1a01006 	mov	r1, r6
    e4ac:	e59f002c 	ldr	r0, [pc, #44]	; e4e0 <volume_create+0x98>
    e4b0:	eb000657 	bl	fe14 <queue_add>

    lock_release (& volume_manager . volume_list . lock);
    e4b4:	e59f0024 	ldr	r0, [pc, #36]	; e4e0 <volume_create+0x98>
    e4b8:	eb0013f4 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
    e4bc:	e1a00004 	mov	r0, r4
    e4c0:	eb00082b 	bl	10574 <cpu_trap_restore>

    *p_volume = volume;
    e4c4:	e59d301c 	ldr	r3, [sp, #28]
    return DNA_OK;
    e4c8:	e3a00000 	mov	r0, #0
    queue_add (& volume_manager . volume_list, volume);

    lock_release (& volume_manager . volume_list . lock);
    cpu_trap_restore(it_status);

    *p_volume = volume;
    e4cc:	e5836000 	str	r6, [r3]
    return DNA_OK;
    e4d0:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    volume = kernel_malloc (sizeof (struct _volume), true);
    ensure (volume != NULL, DNA_OUT_OF_MEM);
    e4d4:	e59f0008 	ldr	r0, [pc, #8]	; e4e4 <volume_create+0x9c>
    cpu_trap_restore(it_status);

    *p_volume = volume;
    return DNA_OK;
  }
}
    e4d8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
    e4dc:	0013f588 	.word	0x0013f588
    e4e0:	0013f58c 	.word	0x0013f58c
    e4e4:	0000fffd 	.word	0x0000fffd

0000e4e8 <file_put>:
 * * DNA_OK if the operation succeed
 *
 * SOURCE
 */

{
    e4e8:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    e4ec:	e24dd05c 	sub	sp, sp, #92	; 0x5c
    e4f0:	e1a04000 	mov	r4, r0
  interrupt_status_t it_status = 0;
  vnode_t vnode = NULL;

  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    e4f4:	e28d1004 	add	r1, sp, #4
    e4f8:	e3a00000 	mov	r0, #0
    e4fc:	eb001526 	bl	1399c <thread_find>
    ensure (status == DNA_OK, status);
    e500:	e3500000 	cmp	r0, #0
    e504:	0a000001 	beq	e510 <file_put+0x28>
  {
    lock_release (& file_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    e508:	e28dd05c 	add	sp, sp, #92	; 0x5c
    e50c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    ensure (status == DNA_OK, status);

    status = thread_get_info (tid, & info);
    e510:	e59d0004 	ldr	r0, [sp, #4]
    e514:	e28d1008 	add	r1, sp, #8
    e518:	eb0010c5 	bl	12834 <thread_get_info>
    ensure (status == DNA_OK, status);
    e51c:	e3500000 	cmp	r0, #0
    e520:	1afffff8 	bne	e508 <file_put+0x20>

    ensure (info . group >= 0, DNA_BAD_ARGUMENT);
    ensure (info . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    e524:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
    e528:	e3530000 	cmp	r3, #0
    e52c:	159f010c 	ldrne	r0, [pc, #268]	; e640 <file_put+0x158>
    e530:	1afffff4 	bne	e508 <file_put+0x20>

    /*
     * Look for the file in the pool.
     */

    it_status = cpu_trap_mask_and_backup();
    e534:	eb0007d5 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& file_pool . lock);
    e538:	e59f6104 	ldr	r6, [pc, #260]	; e644 <file_put+0x15c>

    /*
     * Look for the file in the pool.
     */

    it_status = cpu_trap_mask_and_backup();
    e53c:	e1a07000 	mov	r7, r0
    lock_acquire (& file_pool . lock);
    e540:	e1a00006 	mov	r0, r6
    e544:	eb00091d 	bl	109c0 <lock_acquire>

    file = file_pool . file[info . group][fd];
    e548:	e5963004 	ldr	r3, [r6, #4]
    e54c:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    e550:	e7933102 	ldr	r3, [r3, r2, lsl #2]
    e554:	e7935104 	ldr	r5, [r3, r4, lsl #2]
    check (error, file != NULL, DNA_INVALID_FD);
    e558:	e3550000 	cmp	r5, #0
    e55c:	0a000018 	beq	e5c4 <file_put+0xdc>
    check (error, file -> usage_counter > 0, DNA_ERROR);
    e560:	e5953004 	ldr	r3, [r5, #4]
    e564:	e3530000 	cmp	r3, #0
    e568:	da00000e 	ble	e5a8 <file_put+0xc0>

    atomic_add (& file -> usage_counter, -1);
    e56c:	e2850004 	add	r0, r5, #4
    e570:	e3e01000 	mvn	r1, #0
    e574:	eb00067b 	bl	ff68 <atomic_add>
 
    if (file -> usage_counter == 0 && file -> destroy)
    e578:	e5953004 	ldr	r3, [r5, #4]
    e57c:	e3530000 	cmp	r3, #0
    e580:	1a000002 	bne	e590 <file_put+0xa8>
    e584:	e5d5200c 	ldrb	r2, [r5, #12]
    e588:	e3520000 	cmp	r2, #0
    e58c:	1a00000e 	bne	e5cc <file_put+0xe4>
      status = vnode_put (vnode -> volume -> id, vnode -> id);
      panic (status != DNA_OK);
    }
    else
    {
      lock_release (& file_pool . lock);
    e590:	e59f00ac 	ldr	r0, [pc, #172]	; e644 <file_put+0x15c>
    e594:	eb0013bd 	bl	13490 <lock_release>
      cpu_trap_restore(it_status);
    e598:	e1a00007 	mov	r0, r7
    e59c:	eb0007f4 	bl	10574 <cpu_trap_restore>
    }

    dna_log(VERBOSE_LEVEL, "Put FD %d.", fd);

    return DNA_OK;
    e5a0:	e3a00000 	mov	r0, #0
    e5a4:	eaffffd7 	b	e508 <file_put+0x20>
    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& file_pool . lock);

    file = file_pool . file[info . group][fd];
    check (error, file != NULL, DNA_INVALID_FD);
    check (error, file -> usage_counter > 0, DNA_ERROR);
    e5a8:	e59f4098 	ldr	r4, [pc, #152]	; e648 <file_put+0x160>
    return DNA_OK;
  }

  rescue (error)
  {
    lock_release (& file_pool . lock);
    e5ac:	e59f0090 	ldr	r0, [pc, #144]	; e644 <file_put+0x15c>
    e5b0:	eb0013b6 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
    e5b4:	e1a00007 	mov	r0, r7
    e5b8:	eb0007ed 	bl	10574 <cpu_trap_restore>
    leave;
    e5bc:	e1a00004 	mov	r0, r4
    e5c0:	eaffffd0 	b	e508 <file_put+0x20>

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& file_pool . lock);

    file = file_pool . file[info . group][fd];
    check (error, file != NULL, DNA_INVALID_FD);
    e5c4:	e59f4080 	ldr	r4, [pc, #128]	; e64c <file_put+0x164>
    e5c8:	eafffff7 	b	e5ac <file_put+0xc4>

    atomic_add (& file -> usage_counter, -1);
 
    if (file -> usage_counter == 0 && file -> destroy)
    {
      file_pool . file[info . group][fd] = NULL;
    e5cc:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
    e5d0:	e5962004 	ldr	r2, [r6, #4]

      lock_release (& file_pool . lock);
    e5d4:	e1a00006 	mov	r0, r6

    atomic_add (& file -> usage_counter, -1);
 
    if (file -> usage_counter == 0 && file -> destroy)
    {
      file_pool . file[info . group][fd] = NULL;
    e5d8:	e7922101 	ldr	r2, [r2, r1, lsl #2]
    e5dc:	e7823104 	str	r3, [r2, r4, lsl #2]

      lock_release (& file_pool . lock);
    e5e0:	eb0013aa 	bl	13490 <lock_release>
      cpu_trap_restore(it_status);
    e5e4:	e1a00007 	mov	r0, r7
    e5e8:	eb0007e1 	bl	10574 <cpu_trap_restore>

      status =  file -> vnode -> volume -> cmd -> free
    e5ec:	e5951008 	ldr	r1, [r5, #8]
    e5f0:	e5952020 	ldr	r2, [r5, #32]
    e5f4:	e5913010 	ldr	r3, [r1, #16]
    e5f8:	e591101c 	ldr	r1, [r1, #28]
    e5fc:	e593c020 	ldr	ip, [r3, #32]
    e600:	e5930024 	ldr	r0, [r3, #36]	; 0x24
    e604:	e59c301c 	ldr	r3, [ip, #28]
    e608:	e12fff33 	blx	r3
        (file -> vnode -> volume -> data, file -> vnode -> data, file -> data);
      panic (status != DNA_OK);
    e60c:	e3500000 	cmp	r0, #0
    e610:	0a000000 	beq	e618 <file_put+0x130>
    e614:	eafffffe 	b	e614 <file_put+0x12c>

      vnode = file -> vnode;
    e618:	e5954008 	ldr	r4, [r5, #8]
      kernel_free (file);
    e61c:	e1a00005 	mov	r0, r5
    e620:	eb0016cf 	bl	14164 <kernel_free>

      status = vnode_put (vnode -> volume -> id, vnode -> id);
    e624:	e1c420d8 	ldrd	r2, [r4, #8]
    e628:	e5941010 	ldr	r1, [r4, #16]
    e62c:	e5910004 	ldr	r0, [r1, #4]
    e630:	ebfffb7d 	bl	d42c <vnode_put>
      panic (status != DNA_OK);
    e634:	e3500000 	cmp	r0, #0
    e638:	0affffb2 	beq	e508 <file_put+0x20>
    e63c:	eafffffe 	b	e63c <file_put+0x154>
    e640:	0000fffc 	.word	0x0000fffc
    e644:	0013f568 	.word	0x0013f568
    e648:	0000ffff 	.word	0x0000ffff
    e64c:	0000fef8 	.word	0x0000fef8

0000e650 <vfs_write>:
 * RESULT
 *
 * SOURCE
 */

{
    e650:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  interrupt_status_t it_status;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (data != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    e654:	e3530000 	cmp	r3, #0
    e658:	13510000 	cmpne	r1, #0
    e65c:	e1a06003 	mov	r6, r3
 *
 * SOURCE
 */

{
  file_t file = NULL;
    e660:	e3a03000 	mov	r3, #0
 * RESULT
 *
 * SOURCE
 */

{
    e664:	e24dd018 	sub	sp, sp, #24
  interrupt_status_t it_status;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (data != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    e668:	e1a08001 	mov	r8, r1
 * SOURCE
 */

{
  file_t file = NULL;
  int32_t n_data = count;
    e66c:	e58d2014 	str	r2, [sp, #20]
 *
 * SOURCE
 */

{
  file_t file = NULL;
    e670:	e58d3010 	str	r3, [sp, #16]
  interrupt_status_t it_status;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (data != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    e674:	1a000002 	bne	e684 <vfs_write+0x34>
    e678:	e59f00e4 	ldr	r0, [pc, #228]	; e764 <vfs_write+0x114>
  {
    file_put (fd);
    *p_ret = -1;
    leave;
  }
}
    e67c:	e28dd018 	add	sp, sp, #24
    e680:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  interrupt_status_t it_status;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (data != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    e684:	e1520003 	cmp	r2, r3
    e688:	dafffffa 	ble	e678 <vfs_write+0x28>
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    e68c:	e6ff3070 	uxth	r3, r0
    e690:	e35300ff 	cmp	r3, #255	; 0xff
    e694:	e1a07000 	mov	r7, r0
    e698:	859f00c8 	ldrhi	r0, [pc, #200]	; e768 <vfs_write+0x118>
    e69c:	8afffff6 	bhi	e67c <vfs_write+0x2c>

    /*
     * Get the file associated to the fd.
     */

    status = file_get (fd, & file);
    e6a0:	e28d1010 	add	r1, sp, #16
    e6a4:	ebfffdc4 	bl	ddbc <file_get>
    ensure (status == DNA_OK, status);
    e6a8:	e3500000 	cmp	r0, #0
    e6ac:	1afffff2 	bne	e67c <vfs_write+0x2c>

    /*
     * Read the file.
     */
    cpu_dcache_invalidate((void*)&file->offset, sizeof(uint32_t) );
    e6b0:	e59d0010 	ldr	r0, [sp, #16]
    e6b4:	e3a01004 	mov	r1, #4
    e6b8:	e2800018 	add	r0, r0, #24
    e6bc:	eb0007df 	bl	10640 <cpu_dcache_invalidate>
    status = file -> vnode -> volume -> cmd -> write
    e6c0:	e59d3010 	ldr	r3, [sp, #16]
    e6c4:	e28de014 	add	lr, sp, #20
    e6c8:	e5931008 	ldr	r1, [r3, #8]
    e6cc:	e1c341d8 	ldrd	r4, [r3, #24]
    e6d0:	e5910010 	ldr	r0, [r1, #16]
    e6d4:	e5932020 	ldr	r2, [r3, #32]
    e6d8:	e590c020 	ldr	ip, [r0, #32]
    e6dc:	e591101c 	ldr	r1, [r1, #28]
    e6e0:	e5900024 	ldr	r0, [r0, #36]	; 0x24
    e6e4:	e1cd40f0 	strd	r4, [sp]
    e6e8:	e58de008 	str	lr, [sp, #8]
    e6ec:	e1a03008 	mov	r3, r8
    e6f0:	e59cc028 	ldr	ip, [ip, #40]	; 0x28
    e6f4:	e12fff3c 	blx	ip
      (file -> vnode -> volume -> data, file -> vnode -> data, file -> data,
       data, file -> offset, & n_data);

    check (write_error, status == DNA_OK, status);
    e6f8:	e2504000 	subs	r4, r0, #0
    e6fc:	1a000012 	bne	e74c <vfs_write+0xfc>

    /*
     * If everything went well, increasing the file offset.
     */

    it_status = cpu_trap_mask_and_backup();
    e700:	eb000762 	bl	10490 <cpu_trap_mask_and_backup>
    e704:	e1a04000 	mov	r4, r0
    lock_acquire (& file -> lock);
    e708:	e59d0010 	ldr	r0, [sp, #16]
    e70c:	eb0008ab 	bl	109c0 <lock_acquire>

    file -> offset += n_data;
    e710:	e59d1010 	ldr	r1, [sp, #16]
    e714:	e59d0014 	ldr	r0, [sp, #20]
    e718:	e1c121d8 	ldrd	r2, [r1, #24]
    e71c:	e0922000 	adds	r2, r2, r0
    e720:	e0a33fc0 	adc	r3, r3, r0, asr #31
    e724:	e1c121f8 	strd	r2, [r1, #24]

    lock_release (& file -> lock);
    e728:	e1a00001 	mov	r0, r1
    e72c:	eb001357 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
    e730:	e1a00004 	mov	r0, r4
    e734:	eb00078e 	bl	10574 <cpu_trap_restore>

    /*
     * Release the file and return.
     */

    *p_ret = n_data;
    e738:	e59d3014 	ldr	r3, [sp, #20]
    return file_put (fd);
    e73c:	e1a00007 	mov	r0, r7

    /*
     * Release the file and return.
     */

    *p_ret = n_data;
    e740:	e5863000 	str	r3, [r6]
    return file_put (fd);
    e744:	ebffff67 	bl	e4e8 <file_put>
    e748:	eaffffcb 	b	e67c <vfs_write+0x2c>
  }

  rescue (write_error)
  {
    file_put (fd);
    e74c:	e1a00007 	mov	r0, r7
    e750:	ebffff64 	bl	e4e8 <file_put>
    *p_ret = -1;
    e754:	e3e03000 	mvn	r3, #0
    leave;
    e758:	e1a00004 	mov	r0, r4
  }

  rescue (write_error)
  {
    file_put (fd);
    *p_ret = -1;
    e75c:	e5863000 	str	r3, [r6]
    leave;
    e760:	eaffffc5 	b	e67c <vfs_write+0x2c>
    e764:	0000ffff 	.word	0x0000ffff
    e768:	0000fef8 	.word	0x0000fef8

0000e76c <volume_id_inspector>:
  volume_t nspace = ns;
  int32_t nid = va_arg (list, int32_t);

  watch (bool)
  {
    ensure (nspace != NULL, false);
    e76c:	e3500000 	cmp	r0, #0
 * SOURCE
 */

{
  volume_t nspace = ns;
  int32_t nid = va_arg (list, int32_t);
    e770:	e5913000 	ldr	r3, [r1]

  watch (bool)
  {
    ensure (nspace != NULL, false);
    return nspace -> id == nid;
    e774:	15900004 	ldrne	r0, [r0, #4]
    e778:	10630000 	rsbne	r0, r3, r0
    e77c:	116f0f10 	clzne	r0, r0
    e780:	11a002a0 	lsrne	r0, r0, #5
  }
}
    e784:	e12fff1e 	bx	lr

0000e788 <vfs_start>:
     * Mounting the file systems
     */

    dna_log(INFO_LEVEL, "Mounting the default file systems.");

    status = vfs_mount ("", "/", "rootfs", 0, NULL);
    e788:	e3a03000 	mov	r3, #0
 *
 * SOURCE
 */

{
  int16_t dummy = -1;
    e78c:	e3e0c000 	mvn	ip, #0
 * Mount the base file systems and open the standard files.
 *
 * SOURCE
 */

{
    e790:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    e794:	e24dd014 	sub	sp, sp, #20
     * Mounting the file systems
     */

    dna_log(INFO_LEVEL, "Mounting the default file systems.");

    status = vfs_mount ("", "/", "rootfs", 0, NULL);
    e798:	e58d3000 	str	r3, [sp]
    e79c:	e59f008c 	ldr	r0, [pc, #140]	; e830 <vfs_start+0xa8>
    e7a0:	e59f108c 	ldr	r1, [pc, #140]	; e834 <vfs_start+0xac>
    e7a4:	e59f208c 	ldr	r2, [pc, #140]	; e838 <vfs_start+0xb0>
 *
 * SOURCE
 */

{
  int16_t dummy = -1;
    e7a8:	e1cdc0be 	strh	ip, [sp, #14]
     * Mounting the file systems
     */

    dna_log(INFO_LEVEL, "Mounting the default file systems.");

    status = vfs_mount ("", "/", "rootfs", 0, NULL);
    e7ac:	eb000050 	bl	e8f4 <vfs_mount>
    ensure (status == DNA_OK, status);
    e7b0:	e2503000 	subs	r3, r0, #0
    e7b4:	11a00003 	movne	r0, r3
    e7b8:	0a000001 	beq	e7c4 <vfs_start+0x3c>
    status = vfs_open ("/devices/serial/kernel/console", 0, 0, & dummy);
    ensure (status == DNA_OK, status);

    return DNA_OK;
  }
}
    e7bc:	e28dd014 	add	sp, sp, #20
    e7c0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    dna_log(INFO_LEVEL, "Mounting the default file systems.");

    status = vfs_mount ("", "/", "rootfs", 0, NULL);
    ensure (status == DNA_OK, status);

    status = vfs_mount ("", "/devices", "devfs", 0, NULL);
    e7c4:	e59f1070 	ldr	r1, [pc, #112]	; e83c <vfs_start+0xb4>
    e7c8:	e58d3000 	str	r3, [sp]
    e7cc:	e59f005c 	ldr	r0, [pc, #92]	; e830 <vfs_start+0xa8>
    e7d0:	e59f2068 	ldr	r2, [pc, #104]	; e840 <vfs_start+0xb8>
    e7d4:	eb000046 	bl	e8f4 <vfs_mount>
    ensure (status == DNA_OK, status);
    e7d8:	e2501000 	subs	r1, r0, #0
    e7dc:	0a000002 	beq	e7ec <vfs_start+0x64>
    e7e0:	e1a00001 	mov	r0, r1
    status = vfs_open ("/devices/serial/kernel/console", 0, 0, & dummy);
    ensure (status == DNA_OK, status);

    return DNA_OK;
  }
}
    e7e4:	e28dd014 	add	sp, sp, #20
    e7e8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     * Opening the default in/out/error files
     */

    dna_log(INFO_LEVEL, "Opening the default in/out/error files.");

    status = vfs_open ("/devices/serial/kernel/console", 0, 0, & dummy);
    e7ec:	e1a02001 	mov	r2, r1
    e7f0:	e28d300e 	add	r3, sp, #14
    e7f4:	e59f0048 	ldr	r0, [pc, #72]	; e844 <vfs_start+0xbc>
    e7f8:	ebfffe13 	bl	e04c <vfs_open>
    ensure (status == DNA_OK, status);
    e7fc:	e2501000 	subs	r1, r0, #0
    e800:	1afffff6 	bne	e7e0 <vfs_start+0x58>

    status = vfs_open ("/devices/serial/kernel/console", 0, 0, & dummy);
    e804:	e1a02001 	mov	r2, r1
    e808:	e59f0034 	ldr	r0, [pc, #52]	; e844 <vfs_start+0xbc>
    e80c:	e28d300e 	add	r3, sp, #14
    e810:	ebfffe0d 	bl	e04c <vfs_open>
    ensure (status == DNA_OK, status);
    e814:	e2501000 	subs	r1, r0, #0
    e818:	1afffff0 	bne	e7e0 <vfs_start+0x58>

    status = vfs_open ("/devices/serial/kernel/console", 0, 0, & dummy);
    e81c:	e28d300e 	add	r3, sp, #14
    e820:	e1a02001 	mov	r2, r1
    e824:	e59f0018 	ldr	r0, [pc, #24]	; e844 <vfs_start+0xbc>
    e828:	ebfffe07 	bl	e04c <vfs_open>
    e82c:	eaffffe2 	b	e7bc <vfs_start+0x34>
    e830:	00032ca0 	.word	0x00032ca0
    e834:	0003280c 	.word	0x0003280c
    e838:	0003284c 	.word	0x0003284c
    e83c:	00032f9c 	.word	0x00032f9c
    e840:	00032818 	.word	0x00032818
    e844:	00032fa8 	.word	0x00032fa8

0000e848 <vfs_close>:
 *
 * SOURCE
 */

{
  file_t file = NULL;
    e848:	e3a03000 	mov	r3, #0
 * * DNA_OK if the operation succeed
 *
 * SOURCE
 */

{
    e84c:	e92d4030 	push	{r4, r5, lr}
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    e850:	e6ff2070 	uxth	r2, r0
 * * DNA_OK if the operation succeed
 *
 * SOURCE
 */

{
    e854:	e24dd00c 	sub	sp, sp, #12
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    e858:	e35200ff 	cmp	r2, #255	; 0xff
 * * DNA_OK if the operation succeed
 *
 * SOURCE
 */

{
    e85c:	e1a04000 	mov	r4, r0
  file_t file = NULL;
    e860:	e58d3004 	str	r3, [sp, #4]
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    e864:	859f0084 	ldrhi	r0, [pc, #132]	; e8f0 <vfs_close+0xa8>
    e868:	9a000001 	bls	e874 <vfs_close+0x2c>
    status = file_put (fd);
    panic (status != DNA_OK);

    leave;
  }
}
    e86c:	e28dd00c 	add	sp, sp, #12
    e870:	e8bd8030 	pop	{r4, r5, pc}

    /*
     * Get the file associated to the fd.
     */

    status = file_get (fd, & file);
    e874:	e28d1004 	add	r1, sp, #4
    e878:	ebfffd4f 	bl	ddbc <file_get>
    ensure (status == DNA_OK, status);
    e87c:	e3500000 	cmp	r0, #0
    e880:	1afffff9 	bne	e86c <vfs_close+0x24>

    /*
     * Close the file.
     */

    status = file -> vnode -> volume -> cmd -> close
    e884:	e59d3004 	ldr	r3, [sp, #4]
    e888:	e5931008 	ldr	r1, [r3, #8]
    e88c:	e5932020 	ldr	r2, [r3, #32]
    e890:	e5913010 	ldr	r3, [r1, #16]
    e894:	e591101c 	ldr	r1, [r1, #28]
    e898:	e593c020 	ldr	ip, [r3, #32]
    e89c:	e5930024 	ldr	r0, [r3, #36]	; 0x24
    e8a0:	e59c3018 	ldr	r3, [ip, #24]
    e8a4:	e12fff33 	blx	r3
      (file -> vnode -> volume -> data, file -> vnode -> data, file -> data);

    check (error, status == DNA_OK, status);
    e8a8:	e2505000 	subs	r5, r0, #0
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    e8ac:	e1a00004 	mov	r0, r4
     */

    status = file -> vnode -> volume -> cmd -> close
      (file -> vnode -> volume -> data, file -> vnode -> data, file -> data);

    check (error, status == DNA_OK, status);
    e8b0:	0a000003 	beq	e8c4 <vfs_close+0x7c>
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    e8b4:	ebffff0b 	bl	e4e8 <file_put>
    panic (status != DNA_OK);
    e8b8:	e3500000 	cmp	r0, #0
    e8bc:	0a000004 	beq	e8d4 <vfs_close+0x8c>
    e8c0:	eafffffe 	b	e8c0 <vfs_close+0x78>

    /*
     * Release the file, destroy the file, and return.
     */

    status = file_put (fd);
    e8c4:	ebffff07 	bl	e4e8 <file_put>
    panic (status != DNA_OK);
    e8c8:	e3500000 	cmp	r0, #0
    e8cc:	0a000002 	beq	e8dc <vfs_close+0x94>
    e8d0:	eafffffe 	b	e8d0 <vfs_close+0x88>
    e8d4:	e1a00005 	mov	r0, r5
    e8d8:	eaffffe3 	b	e86c <vfs_close+0x24>

    status = file_destroy (fd);
    e8dc:	e1a00004 	mov	r0, r4
    e8e0:	ebfffc8b 	bl	db14 <file_destroy>
    panic (status != DNA_OK);
    e8e4:	e3500000 	cmp	r0, #0
    e8e8:	0affffdf 	beq	e86c <vfs_close+0x24>
    e8ec:	eafffffe 	b	e8ec <vfs_close+0xa4>
    e8f0:	0000fef8 	.word	0x0000fef8

0000e8f4 <vfs_mount>:
 *
 * SOURCE
 */

{
  filesystem_t * fs = NULL;
    e8f4:	e3a0c000 	mov	ip, #0
 * DNA_ERROR : fs_type doesn't exist.
 *
 * SOURCE
 */

{
    e8f8:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (source != NULL && target != NULL
    e8fc:	e151000c 	cmp	r1, ip
    e900:	1150000c 	cmpne	r0, ip
 * SOURCE
 */

{
  filesystem_t * fs = NULL;
  int64_t host_vnid = -1;
    e904:	e3e04000 	mvn	r4, #0
    e908:	e3e05000 	mvn	r5, #0
 * DNA_ERROR : fs_type doesn't exist.
 *
 * SOURCE
 */

{
    e90c:	e24dd024 	sub	sp, sp, #36	; 0x24
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (source != NULL && target != NULL
    e910:	e1a06000 	mov	r6, r0
 *
 * SOURCE
 */

{
  filesystem_t * fs = NULL;
    e914:	e58dc008 	str	ip, [sp, #8]
  int64_t host_vnid = -1;
  volume_t host_volume = NULL, volume = NULL;
    e918:	e58dc00c 	str	ip, [sp, #12]
    e91c:	e58dc010 	str	ip, [sp, #16]

  void * node_data = NULL;
    e920:	e58dc014 	str	ip, [sp, #20]
 * SOURCE
 */

{
  filesystem_t * fs = NULL;
  int64_t host_vnid = -1;
    e924:	e1cd41f8 	strd	r4, [sp, #24]
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (source != NULL && target != NULL
    e928:	1a000002 	bne	e938 <vfs_mount+0x44>
    e92c:	e59f0148 	ldr	r0, [pc, #328]	; ea7c <vfs_mount+0x188>
    status = volume_destroy (volume);
    panic (status != DNA_OK);

    leave;
  }
}
    e930:	e28dd024 	add	sp, sp, #36	; 0x24
    e934:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (source != NULL && target != NULL
    e938:	e152000c 	cmp	r2, ip
    e93c:	e1a08002 	mov	r8, r2
    e940:	0afffff9 	beq	e92c <vfs_mount+0x38>

    /*
     * Find the vnode corresponding to the path
     */

    status = vnode_walk (target, & host_volume, & host_vnid, & node_data);
    e944:	e1a00001 	mov	r0, r1
    e948:	e1a07003 	mov	r7, r3
    e94c:	e28d100c 	add	r1, sp, #12
    e950:	e28d3014 	add	r3, sp, #20
    e954:	e28d2018 	add	r2, sp, #24
    e958:	eb000150 	bl	eea0 <vnode_walk>
    ensure (status == DNA_OK || status == DNA_NO_VOLUME, status);
    e95c:	e59f311c 	ldr	r3, [pc, #284]	; ea80 <vfs_mount+0x18c>
    e960:	e1500003 	cmp	r0, r3
    e964:	13500000 	cmpne	r0, #0
    e968:	1afffff0 	bne	e930 <vfs_mount+0x3c>

    /*
     * Check if the vnode is not already associated
     */

    it_status = cpu_trap_mask_and_backup();
    e96c:	eb0006c7 	bl	10490 <cpu_trap_mask_and_backup>
    e970:	e1a09000 	mov	r9, r0
    lock_acquire (& volume_manager . volume_list . lock);
    e974:	e59f0108 	ldr	r0, [pc, #264]	; ea84 <vfs_mount+0x190>
    e978:	eb000810 	bl	109c0 <lock_acquire>

    volume = queue_lookup (& volume_manager . volume_list,
    e97c:	e1cd41d8 	ldrd	r4, [sp, #24]
    e980:	e59d200c 	ldr	r2, [sp, #12]
    e984:	e59f10fc 	ldr	r1, [pc, #252]	; ea88 <vfs_mount+0x194>
    e988:	e1cd40f0 	strd	r4, [sp]
    e98c:	e59f00f0 	ldr	r0, [pc, #240]	; ea84 <vfs_mount+0x190>
    e990:	eb000556 	bl	fef0 <queue_lookup>
    e994:	e58d0010 	str	r0, [sp, #16]
        volume_host_inspector, host_volume, host_vnid);

    lock_release (& volume_manager . volume_list . lock);
    e998:	e59f00e4 	ldr	r0, [pc, #228]	; ea84 <vfs_mount+0x190>
    e99c:	eb0012bb 	bl	13490 <lock_release>
    cpu_trap_restore (it_status);
    e9a0:	e1a00009 	mov	r0, r9
    e9a4:	eb0006f2 	bl	10574 <cpu_trap_restore>

    ensure (volume == NULL, DNA_VNODE_MOUNTED);
    e9a8:	e59d3010 	ldr	r3, [sp, #16]
    e9ac:	e3530000 	cmp	r3, #0
    e9b0:	159f00d4 	ldrne	r0, [pc, #212]	; ea8c <vfs_mount+0x198>
    e9b4:	1affffdd 	bne	e930 <vfs_mount+0x3c>

    /*
     * Get the required filesystem
     */

    status = filesystem_load (fs_type, & fs);
    e9b8:	e1a00008 	mov	r0, r8
    e9bc:	e28d1008 	add	r1, sp, #8
    e9c0:	ebfffe26 	bl	e260 <filesystem_load>
    ensure (status == DNA_OK, status);
    e9c4:	e3500000 	cmp	r0, #0
    e9c8:	1affffd8 	bne	e930 <vfs_mount+0x3c>

    /*
     * Create the volume
     */

    status = volume_create (host_volume, host_vnid, fs -> cmd, & volume);
    e9cc:	e1cd21d8 	ldrd	r2, [sp, #24]
    e9d0:	e59d1008 	ldr	r1, [sp, #8]
    e9d4:	e59d000c 	ldr	r0, [sp, #12]
    e9d8:	e591c004 	ldr	ip, [r1, #4]
    e9dc:	e28d1010 	add	r1, sp, #16
    e9e0:	e58dc000 	str	ip, [sp]
    e9e4:	e58d1004 	str	r1, [sp, #4]
    e9e8:	ebfffe96 	bl	e448 <volume_create>
    ensure (volume != NULL, DNA_OUT_OF_MEM);
    e9ec:	e59d3010 	ldr	r3, [sp, #16]
    e9f0:	e3530000 	cmp	r3, #0
    e9f4:	0a000017 	beq	ea58 <vfs_mount+0x164>

    /*
     * Mount the filesystem
     */

    status = fs -> cmd -> mount (volume -> id, source, flags, data,
    e9f8:	e59d2008 	ldr	r2, [sp, #8]
    e9fc:	e2831024 	add	r1, r3, #36	; 0x24
    ea00:	e5920004 	ldr	r0, [r2, #4]
    ea04:	e2832008 	add	r2, r3, #8
    ea08:	e88d0006 	stm	sp, {r1, r2}
    ea0c:	e1a01006 	mov	r1, r6
    ea10:	e590c004 	ldr	ip, [r0, #4]
    ea14:	e1a02007 	mov	r2, r7
    ea18:	e5930004 	ldr	r0, [r3, #4]
    ea1c:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
    ea20:	e12fff3c 	blx	ip
        & volume -> data, & volume -> root_vnid);

    check (cannot_mount, status == DNA_OK, status);
    ea24:	e2504000 	subs	r4, r0, #0
    ea28:	1a00000c 	bne	ea60 <vfs_mount+0x16c>

    /*
     * Put the host vnode back
     */

    if (host_volume != NULL)
    ea2c:	e59d300c 	ldr	r3, [sp, #12]
    ea30:	e3530000 	cmp	r3, #0
    ea34:	0a000005 	beq	ea50 <vfs_mount+0x15c>
    {
      status = vnode_put (host_volume -> id, host_vnid);
    ea38:	e5930004 	ldr	r0, [r3, #4]
    ea3c:	e1cd21d8 	ldrd	r2, [sp, #24]
    ea40:	ebfffa79 	bl	d42c <vnode_put>
      panic (status != DNA_OK);
    ea44:	e3500000 	cmp	r0, #0
    ea48:	0a000000 	beq	ea50 <vfs_mount+0x15c>
    ea4c:	eafffffe 	b	ea4c <vfs_mount+0x158>
    }

    return DNA_OK;
    ea50:	e3a00000 	mov	r0, #0
    ea54:	eaffffb5 	b	e930 <vfs_mount+0x3c>
    /*
     * Create the volume
     */

    status = volume_create (host_volume, host_vnid, fs -> cmd, & volume);
    ensure (volume != NULL, DNA_OUT_OF_MEM);
    ea58:	e59f0030 	ldr	r0, [pc, #48]	; ea90 <vfs_mount+0x19c>
    ea5c:	eaffffb3 	b	e930 <vfs_mount+0x3c>
    return DNA_OK;
  }

  rescue (cannot_mount)
  {
    status = volume_destroy (volume);
    ea60:	e59d0010 	ldr	r0, [sp, #16]
    ea64:	ebfffa5d 	bl	d3e0 <volume_destroy>
    panic (status != DNA_OK);
    ea68:	e3500000 	cmp	r0, #0
    ea6c:	0a000000 	beq	ea74 <vfs_mount+0x180>
    ea70:	eafffffe 	b	ea70 <vfs_mount+0x17c>
    ea74:	e1a00004 	mov	r0, r4
    ea78:	eaffffac 	b	e930 <vfs_mount+0x3c>
    ea7c:	0000ffff 	.word	0x0000ffff
    ea80:	0000fefe 	.word	0x0000fefe
    ea84:	0013f58c 	.word	0x0013f58c
    ea88:	0000dad4 	.word	0x0000dad4
    ea8c:	0000fefb 	.word	0x0000fefb
    ea90:	0000fffd 	.word	0x0000fffd

0000ea94 <vfs_read>:
 * * DNA_OK : the operation succeeded
 *
 * SOURCE
 */

{
    ea94:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  interrupt_status_t it_status;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (data != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    ea98:	e3530000 	cmp	r3, #0
    ea9c:	13510000 	cmpne	r1, #0
    eaa0:	e1a06003 	mov	r6, r3
 *
 * SOURCE
 */

{
  file_t file = NULL;
    eaa4:	e3a03000 	mov	r3, #0
 * * DNA_OK : the operation succeeded
 *
 * SOURCE
 */

{
    eaa8:	e24dd018 	sub	sp, sp, #24
  interrupt_status_t it_status;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (data != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    eaac:	e1a08001 	mov	r8, r1
 * SOURCE
 */

{
  file_t file = NULL;
  int32_t n_data = count;
    eab0:	e58d2014 	str	r2, [sp, #20]
 *
 * SOURCE
 */

{
  file_t file = NULL;
    eab4:	e58d3010 	str	r3, [sp, #16]
  interrupt_status_t it_status;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (data != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    eab8:	1a000002 	bne	eac8 <vfs_read+0x34>
    eabc:	e59f00ec 	ldr	r0, [pc, #236]	; ebb0 <vfs_read+0x11c>
    panic (status != DNA_OK);

    *p_ret = -1;
    leave;
  }
}
    eac0:	e28dd018 	add	sp, sp, #24
    eac4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  interrupt_status_t it_status;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (data != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    eac8:	e1520003 	cmp	r2, r3
    eacc:	dafffffa 	ble	eabc <vfs_read+0x28>
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    ead0:	e6ff3070 	uxth	r3, r0
    ead4:	e35300ff 	cmp	r3, #255	; 0xff
    ead8:	e1a07000 	mov	r7, r0
    eadc:	859f00d0 	ldrhi	r0, [pc, #208]	; ebb4 <vfs_read+0x120>
    eae0:	8afffff6 	bhi	eac0 <vfs_read+0x2c>

    /*
     * Get the file associated to the fd.
     */

    status = file_get (fd, & file);
    eae4:	e28d1010 	add	r1, sp, #16
    eae8:	ebfffcb3 	bl	ddbc <file_get>
    ensure (status == DNA_OK, status);
    eaec:	e3500000 	cmp	r0, #0
    eaf0:	1afffff2 	bne	eac0 <vfs_read+0x2c>

    /*
     * Read the file.
     */

    status = file -> vnode -> volume -> cmd -> read
    eaf4:	e59d3010 	ldr	r3, [sp, #16]
    eaf8:	e28de014 	add	lr, sp, #20
    eafc:	e5931008 	ldr	r1, [r3, #8]
    eb00:	e1c341d8 	ldrd	r4, [r3, #24]
    eb04:	e5910010 	ldr	r0, [r1, #16]
    eb08:	e5932020 	ldr	r2, [r3, #32]
    eb0c:	e590c020 	ldr	ip, [r0, #32]
    eb10:	e591101c 	ldr	r1, [r1, #28]
    eb14:	e5900024 	ldr	r0, [r0, #36]	; 0x24
    eb18:	e1cd40f0 	strd	r4, [sp]
    eb1c:	e58de008 	str	lr, [sp, #8]
    eb20:	e1a03008 	mov	r3, r8
    eb24:	e59cc024 	ldr	ip, [ip, #36]	; 0x24
    eb28:	e12fff3c 	blx	ip
      (file -> vnode -> volume -> data, file -> vnode -> data, file -> data,
       data, file -> offset, & n_data);

    check (read_error, status == DNA_OK, status);
    eb2c:	e2504000 	subs	r4, r0, #0
    eb30:	0a000004 	beq	eb48 <vfs_read+0xb4>
    return DNA_OK;
  }

  rescue (read_error)
  {
    status = file_put (fd);
    eb34:	e1a00007 	mov	r0, r7
    eb38:	ebfffe6a 	bl	e4e8 <file_put>
    panic (status != DNA_OK);
    eb3c:	e3500000 	cmp	r0, #0
    eb40:	0a000016 	beq	eba0 <vfs_read+0x10c>
    eb44:	eafffffe 	b	eb44 <vfs_read+0xb0>

    /*
     * If everything went well, increasing the file offset.
     */

    it_status = cpu_trap_mask_and_backup();
    eb48:	eb000650 	bl	10490 <cpu_trap_mask_and_backup>
    eb4c:	e1a04000 	mov	r4, r0
    lock_acquire (& file -> lock);
    eb50:	e59d0010 	ldr	r0, [sp, #16]
    eb54:	eb000799 	bl	109c0 <lock_acquire>

    file -> offset += n_data;
    eb58:	e59d1010 	ldr	r1, [sp, #16]
    eb5c:	e59d0014 	ldr	r0, [sp, #20]
    eb60:	e1c121d8 	ldrd	r2, [r1, #24]
    eb64:	e0922000 	adds	r2, r2, r0
    eb68:	e0a33fc0 	adc	r3, r3, r0, asr #31
    eb6c:	e1c121f8 	strd	r2, [r1, #24]

    lock_release (& file -> lock);
    eb70:	e1a00001 	mov	r0, r1
    eb74:	eb001245 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
    eb78:	e1a00004 	mov	r0, r4
    eb7c:	eb00067c 	bl	10574 <cpu_trap_restore>

    /*
     * Release the file and return.
     */

    status = file_put (fd);
    eb80:	e1a00007 	mov	r0, r7
    eb84:	ebfffe57 	bl	e4e8 <file_put>
    panic (status != DNA_OK);
    eb88:	e3500000 	cmp	r0, #0
    eb8c:	0a000000 	beq	eb94 <vfs_read+0x100>
    eb90:	eafffffe 	b	eb90 <vfs_read+0xfc>

    *p_ret = n_data;
    eb94:	e59d3014 	ldr	r3, [sp, #20]
    eb98:	e5863000 	str	r3, [r6]
    return DNA_OK;
    eb9c:	eaffffc7 	b	eac0 <vfs_read+0x2c>
  rescue (read_error)
  {
    status = file_put (fd);
    panic (status != DNA_OK);

    *p_ret = -1;
    eba0:	e3e03000 	mvn	r3, #0
    leave;
    eba4:	e1a00004 	mov	r0, r4
  rescue (read_error)
  {
    status = file_put (fd);
    panic (status != DNA_OK);

    *p_ret = -1;
    eba8:	e5863000 	str	r3, [r6]
    leave;
    ebac:	eaffffc3 	b	eac0 <vfs_read+0x2c>
    ebb0:	0000ffff 	.word	0x0000ffff
    ebb4:	0000fef8 	.word	0x0000fef8

0000ebb8 <vnode_destroy>:
 * * DNA_NO_VNODE if the specified vnode hasn't been found.
 *
 * SOURCE
 */

{
    ebb8:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    ebbc:	e24dd00c 	sub	sp, sp, #12
    ebc0:	e1a04002 	mov	r4, r2
    ebc4:	e1a05003 	mov	r5, r3
    ebc8:	e1a06000 	mov	r6, r0
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup();
    ebcc:	eb00062f 	bl	10490 <cpu_trap_mask_and_backup>
    ebd0:	e1a07000 	mov	r7, r0
    lock_acquire (& vnode_manager . vnode_list . lock);
    ebd4:	e59f00cc 	ldr	r0, [pc, #204]	; eca8 <vnode_destroy+0xf0>
    ebd8:	eb000778 	bl	109c0 <lock_acquire>

    vnode = queue_lookup (& vnode_manager . vnode_list,
    ebdc:	e1a02004 	mov	r2, r4
    ebe0:	e58d6000 	str	r6, [sp]
    ebe4:	e1a03005 	mov	r3, r5
    ebe8:	e59f00b8 	ldr	r0, [pc, #184]	; eca8 <vnode_destroy+0xf0>
    ebec:	e59f10b8 	ldr	r1, [pc, #184]	; ecac <vnode_destroy+0xf4>
    ebf0:	eb0004be 	bl	fef0 <queue_lookup>
        vnode_id_inspector, vnid, vid);
    check (invalid_vnode, vnode != NULL, DNA_NO_VNODE);
    ebf4:	e2504000 	subs	r4, r0, #0
    ebf8:	0a000023 	beq	ec8c <vnode_destroy+0xd4>

    atomic_add (& vnode -> usage_counter, -1);
    ebfc:	e2840018 	add	r0, r4, #24
    ec00:	e3e01000 	mvn	r1, #0
    ec04:	eb0004d7 	bl	ff68 <atomic_add>

    if (vnode -> usage_counter == 0)
    ec08:	e5943018 	ldr	r3, [r4, #24]
    ec0c:	e3530000 	cmp	r3, #0
    ec10:	0a000008 	beq	ec38 <vnode_destroy+0x80>

      kernel_free (vnode);
    }
    else
    {
      vnode -> destroy = true;
    ec14:	e3a03001 	mov	r3, #1
      lock_release (& vnode_manager . vnode_list . lock);
    ec18:	e59f0088 	ldr	r0, [pc, #136]	; eca8 <vnode_destroy+0xf0>

      kernel_free (vnode);
    }
    else
    {
      vnode -> destroy = true;
    ec1c:	e5c43014 	strb	r3, [r4, #20]
      lock_release (& vnode_manager . vnode_list . lock);
    ec20:	eb00121a 	bl	13490 <lock_release>
      cpu_trap_restore(it_status);
    ec24:	e1a00007 	mov	r0, r7
    ec28:	eb000651 	bl	10574 <cpu_trap_restore>
    }

    return DNA_OK;
    ec2c:	e3a00000 	mov	r0, #0
  {
    lock_release (& vnode_manager . vnode_list . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    ec30:	e28dd00c 	add	sp, sp, #12
    ec34:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

    atomic_add (& vnode -> usage_counter, -1);

    if (vnode -> usage_counter == 0)
    {
      queue_extract (& vnode_manager . vnode_list, & vnode -> link);
    ec38:	e1a01004 	mov	r1, r4
    ec3c:	e59f0064 	ldr	r0, [pc, #100]	; eca8 <vnode_destroy+0xf0>
    ec40:	eb000168 	bl	f1e8 <queue_extract>

      lock_release (& vnode_manager . vnode_list . lock);
    ec44:	e59f005c 	ldr	r0, [pc, #92]	; eca8 <vnode_destroy+0xf0>
    ec48:	eb001210 	bl	13490 <lock_release>
      cpu_trap_restore(it_status);
    ec4c:	e1a00007 	mov	r0, r7
    ec50:	eb000647 	bl	10574 <cpu_trap_restore>

      volume = vnode -> volume;
    ec54:	e5943010 	ldr	r3, [r4, #16]
      data = vnode -> data;

      status = volume -> cmd -> destroy_vnode (volume -> data, data);
    ec58:	e594101c 	ldr	r1, [r4, #28]
    ec5c:	e5932020 	ldr	r2, [r3, #32]
    ec60:	e5930024 	ldr	r0, [r3, #36]	; 0x24
    ec64:	e5923010 	ldr	r3, [r2, #16]
    ec68:	e12fff33 	blx	r3
      ensure (status == DNA_OK, status);
    ec6c:	e2505000 	subs	r5, r0, #0
    ec70:	11a00005 	movne	r0, r5
    ec74:	1affffed 	bne	ec30 <vnode_destroy+0x78>

      kernel_free (vnode);
    ec78:	e1a00004 	mov	r0, r4
    ec7c:	eb001538 	bl	14164 <kernel_free>
      vnode -> destroy = true;
      lock_release (& vnode_manager . vnode_list . lock);
      cpu_trap_restore(it_status);
    }

    return DNA_OK;
    ec80:	e1a00005 	mov	r0, r5
  {
    lock_release (& vnode_manager . vnode_list . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    ec84:	e28dd00c 	add	sp, sp, #12
    ec88:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    return DNA_OK;
  }

  rescue (invalid_vnode)
  {
    lock_release (& vnode_manager . vnode_list . lock);
    ec8c:	e59f0014 	ldr	r0, [pc, #20]	; eca8 <vnode_destroy+0xf0>
    ec90:	eb0011fe 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
    ec94:	e1a00007 	mov	r0, r7
    ec98:	eb000635 	bl	10574 <cpu_trap_restore>
    leave;
    ec9c:	e59f000c 	ldr	r0, [pc, #12]	; ecb0 <vnode_destroy+0xf8>
  }
}
    eca0:	e28dd00c 	add	sp, sp, #12
    eca4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    eca8:	0013f574 	.word	0x0013f574
    ecac:	0000e004 	.word	0x0000e004
    ecb0:	0000fefd 	.word	0x0000fefd

0000ecb4 <vfs_umount>:
 * RESULT
 *
 * SOURCE
 */

{
    ecb4:	e92d4070 	push	{r4, r5, r6, lr}
  int64_t host_vnid = -1;
  volume_t host_volume = NULL, volume = NULL;
    ecb8:	e3a0c000 	mov	ip, #0
 *
 * SOURCE
 */

{
  int64_t host_vnid = -1;
    ecbc:	e3e04000 	mvn	r4, #0
    ecc0:	e3e05000 	mvn	r5, #0
 * RESULT
 *
 * SOURCE
 */

{
    ecc4:	e24dd018 	sub	sp, sp, #24
  {
    /*
     * Find the vnode corresponding to the path
     */

    status = vnode_walk (target, & host_volume, & host_vnid, & node_data);
    ecc8:	e28d300c 	add	r3, sp, #12
    eccc:	e28d1008 	add	r1, sp, #8
    ecd0:	e28d2010 	add	r2, sp, #16
 *
 * SOURCE
 */

{
  int64_t host_vnid = -1;
    ecd4:	e1cd41f0 	strd	r4, [sp, #16]
  volume_t host_volume = NULL, volume = NULL;
    ecd8:	e58dc008 	str	ip, [sp, #8]
  vnode_t vnode = NULL;
  void * node_data = NULL;
    ecdc:	e58dc00c 	str	ip, [sp, #12]
  {
    /*
     * Find the vnode corresponding to the path
     */

    status = vnode_walk (target, & host_volume, & host_vnid, & node_data);
    ece0:	eb00006e 	bl	eea0 <vnode_walk>
    ensure (status == DNA_OK || status == DNA_NO_VOLUME, status);
    ece4:	e59f30c4 	ldr	r3, [pc, #196]	; edb0 <vfs_umount+0xfc>
    ece8:	e1500003 	cmp	r0, r3
    ecec:	13500000 	cmpne	r0, #0
    ecf0:	1a000007 	bne	ed14 <vfs_umount+0x60>
    ensure (host_volume != NULL && host_vnid != -1, DNA_NO_VNODE);
    ecf4:	e59d3008 	ldr	r3, [sp, #8]
    ecf8:	e3530000 	cmp	r3, #0
    ecfc:	0a000003 	beq	ed10 <vfs_umount+0x5c>
    ed00:	e1cd21d0 	ldrd	r2, [sp, #16]
    ed04:	e1530005 	cmp	r3, r5
    ed08:	01520004 	cmpeq	r2, r4
    ed0c:	1a000002 	bne	ed1c <vfs_umount+0x68>
    ed10:	e59f009c 	ldr	r0, [pc, #156]	; edb4 <vfs_umount+0x100>
     * Destroy the volume
     */

    return volume_destroy (volume);
  }
}
    ed14:	e28dd018 	add	sp, sp, #24
    ed18:	e8bd8070 	pop	{r4, r5, r6, pc}

    /*
     * Check if something is mounted on this node
     */

    it_status = cpu_trap_mask_and_backup();
    ed1c:	eb0005db 	bl	10490 <cpu_trap_mask_and_backup>
    ed20:	e1a06000 	mov	r6, r0
    lock_acquire (& volume_manager . volume_list . lock);
    ed24:	e59f008c 	ldr	r0, [pc, #140]	; edb8 <vfs_umount+0x104>
    ed28:	eb000724 	bl	109c0 <lock_acquire>

    volume = queue_lookup (& volume_manager . volume_list,
    ed2c:	e1cd41d0 	ldrd	r4, [sp, #16]
    ed30:	e59d2008 	ldr	r2, [sp, #8]
    ed34:	e59f1080 	ldr	r1, [pc, #128]	; edbc <vfs_umount+0x108>
    ed38:	e1cd40f0 	strd	r4, [sp]
    ed3c:	e59f0074 	ldr	r0, [pc, #116]	; edb8 <vfs_umount+0x104>
    ed40:	eb00046a 	bl	fef0 <queue_lookup>
    ed44:	e1a04000 	mov	r4, r0
        volume_host_inspector, host_volume, host_vnid);

    lock_release (& volume_manager . volume_list . lock);
    ed48:	e59f0068 	ldr	r0, [pc, #104]	; edb8 <vfs_umount+0x104>
    ed4c:	eb0011cf 	bl	13490 <lock_release>
    cpu_trap_restore (it_status);
    ed50:	e1a00006 	mov	r0, r6
    ed54:	eb000606 	bl	10574 <cpu_trap_restore>

    ensure (volume != NULL, DNA_ERROR);
    ed58:	e3540000 	cmp	r4, #0
    ed5c:	059f005c 	ldreq	r0, [pc, #92]	; edc0 <vfs_umount+0x10c>
    ed60:	0affffeb 	beq	ed14 <vfs_umount+0x60>

    /*
     * Check if the volume is being used
     */

    it_status = cpu_trap_mask_and_backup();
    ed64:	eb0005c9 	bl	10490 <cpu_trap_mask_and_backup>
    ed68:	e1a05000 	mov	r5, r0
    lock_acquire (& vnode_manager . vnode_list . lock);
    ed6c:	e59f0050 	ldr	r0, [pc, #80]	; edc4 <vfs_umount+0x110>
    ed70:	eb000712 	bl	109c0 <lock_acquire>

    vnode = queue_lookup (& vnode_manager . vnode_list,
    ed74:	e59f104c 	ldr	r1, [pc, #76]	; edc8 <vfs_umount+0x114>
    ed78:	e1a02004 	mov	r2, r4
    ed7c:	e59f0040 	ldr	r0, [pc, #64]	; edc4 <vfs_umount+0x110>
    ed80:	eb00045a 	bl	fef0 <queue_lookup>
    ed84:	e1a06000 	mov	r6, r0
        vnode_volume_inspector, volume);

    lock_release (& vnode_manager . vnode_list . lock);
    ed88:	e59f0034 	ldr	r0, [pc, #52]	; edc4 <vfs_umount+0x110>
    ed8c:	eb0011bf 	bl	13490 <lock_release>
    cpu_trap_restore (it_status);
    ed90:	e1a00005 	mov	r0, r5
    ed94:	eb0005f6 	bl	10574 <cpu_trap_restore>

    ensure (vnode != NULL, DNA_VOLUME_IN_USE);
    ed98:	e3560000 	cmp	r6, #0
    ed9c:	059f0028 	ldreq	r0, [pc, #40]	; edcc <vfs_umount+0x118>
    eda0:	0affffdb 	beq	ed14 <vfs_umount+0x60>

    /*
     * Destroy the volume
     */

    return volume_destroy (volume);
    eda4:	e1a00004 	mov	r0, r4
    eda8:	ebfff98c 	bl	d3e0 <volume_destroy>
    edac:	eaffffd8 	b	ed14 <vfs_umount+0x60>
    edb0:	0000fefe 	.word	0x0000fefe
    edb4:	0000fefd 	.word	0x0000fefd
    edb8:	0013f58c 	.word	0x0013f58c
    edbc:	0000dad4 	.word	0x0000dad4
    edc0:	0000ffff 	.word	0x0000ffff
    edc4:	0013f574 	.word	0x0013f574
    edc8:	0000d3b8 	.word	0x0000d3b8
    edcc:	0000fef5 	.word	0x0000fef5

0000edd0 <vfs_mkdir>:
 */

{
  status_t status = DNA_OK;
  int64_t vnid = -1;
  volume_t volume = NULL;
    edd0:	e3a0c000 	mov	ip, #0
 * SOURCE
 */

{
  status_t status = DNA_OK;
  int64_t vnid = -1;
    edd4:	e3e02000 	mvn	r2, #0
    edd8:	e3e03000 	mvn	r3, #0
 * * DNA_OK if the operation succeeded.
 *
 * SOURCE
 */

{
    eddc:	e92d4030 	push	{r4, r5, lr}
    ede0:	e24dde51 	sub	sp, sp, #1296	; 0x510
    ede4:	e24dd004 	sub	sp, sp, #4
  status_t status = DNA_OK;
  int64_t vnid = -1;
    ede8:	e59f40a8 	ldr	r4, [pc, #168]	; ee98 <vfs_mkdir+0xc8>
  void * data = NULL;
  char buffer[DNA_PATH_LENGTH], token[DNA_FILENAME_LENGTH];

  watch (status_t)
  {
    ensure (path != NULL, DNA_ERROR);
    edec:	e3500000 	cmp	r0, #0
 * * DNA_OK if the operation succeeded.
 *
 * SOURCE
 */

{
    edf0:	e1a05001 	mov	r5, r1
  status_t status = DNA_OK;
  int64_t vnid = -1;
    edf4:	e28d1e51 	add	r1, sp, #1296	; 0x510
    edf8:	e18120f4 	strd	r2, [r1, r4]
  volume_t volume = NULL;
    edfc:	e58dc000 	str	ip, [sp]
  void * data = NULL;
    ee00:	e58dc004 	str	ip, [sp, #4]
  char buffer[DNA_PATH_LENGTH], token[DNA_FILENAME_LENGTH];

  watch (status_t)
  {
    ensure (path != NULL, DNA_ERROR);
    ee04:	059f0090 	ldreq	r0, [pc, #144]	; ee9c <vfs_mkdir+0xcc>
    ee08:	0a000007 	beq	ee2c <vfs_mkdir+0x5c>

    dna_strcpy (buffer, path);
    ee0c:	e1a01000 	mov	r1, r0
    ee10:	e28d0e11 	add	r0, sp, #272	; 0x110
    ee14:	eb000497 	bl	10078 <dna_strcpy>

    status = path_split (buffer, token);
    ee18:	e28d0e11 	add	r0, sp, #272	; 0x110
    ee1c:	e28d1010 	add	r1, sp, #16
    ee20:	eb000468 	bl	ffc8 <path_split>
    ensure (status == DNA_OK, status);
    ee24:	e3500000 	cmp	r0, #0
    ee28:	0a000002 	beq	ee38 <vfs_mkdir+0x68>
    status = vnode_put (volume -> id, vnid);
    ensure (status == DNA_OK, status);

    return DNA_OK;
  }
}
    ee2c:	e28dde51 	add	sp, sp, #1296	; 0x510
    ee30:	e28dd004 	add	sp, sp, #4
    ee34:	e8bd8030 	pop	{r4, r5, pc}
    dna_strcpy (buffer, path);

    status = path_split (buffer, token);
    ensure (status == DNA_OK, status);

    status = vnode_walk (buffer, & volume, & vnid, & data);
    ee38:	e28d3010 	add	r3, sp, #16
    ee3c:	e28d0e11 	add	r0, sp, #272	; 0x110
    ee40:	e1a0100d 	mov	r1, sp
    ee44:	e28d2008 	add	r2, sp, #8
    ee48:	e243300c 	sub	r3, r3, #12
    ee4c:	eb000013 	bl	eea0 <vnode_walk>
    ensure (status == DNA_OK, status);
    ee50:	e3500000 	cmp	r0, #0
    ee54:	1afffff4 	bne	ee2c <vfs_mkdir+0x5c>

    status = volume -> cmd -> mkdir (volume -> data, data, token, mode);
    ee58:	e59d1000 	ldr	r1, [sp]
    ee5c:	e28d2010 	add	r2, sp, #16
    ee60:	e5910020 	ldr	r0, [r1, #32]
    ee64:	e1a03005 	mov	r3, r5
    ee68:	e590c034 	ldr	ip, [r0, #52]	; 0x34
    ee6c:	e5910024 	ldr	r0, [r1, #36]	; 0x24
    ee70:	e59d1004 	ldr	r1, [sp, #4]
    ee74:	e12fff3c 	blx	ip
    ensure (status == DNA_OK, status);
    ee78:	e3500000 	cmp	r0, #0
    ee7c:	1affffea 	bne	ee2c <vfs_mkdir+0x5c>

    status = vnode_put (volume -> id, vnid);
    ee80:	e59d1000 	ldr	r1, [sp]
    ee84:	e28dce51 	add	ip, sp, #1296	; 0x510
    ee88:	e18c20d4 	ldrd	r2, [ip, r4]
    ee8c:	e5910004 	ldr	r0, [r1, #4]
    ee90:	ebfff965 	bl	d42c <vnode_put>
    ee94:	eaffffe4 	b	ee2c <vfs_mkdir+0x5c>
    ee98:	fffffaf8 	.word	0xfffffaf8
    ee9c:	0000ffff 	.word	0x0000ffff

0000eea0 <vnode_walk>:
 * * DNA_NO_VOLUME if no root volume is present.
 *
 * SOURCE
 */

{
    eea0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    eea4:	e1a07000 	mov	r7, r0
  bool keep_walking = false;
  int64_t vnid = -1, new_vnid = -1;
  void * data = NULL;
    eea8:	e3a0e000 	mov	lr, #0
 * SOURCE
 */

{
  bool keep_walking = false;
  int64_t vnid = -1, new_vnid = -1;
    eeac:	e3e04000 	mvn	r4, #0
    eeb0:	e3e05000 	mvn	r5, #0
 * * DNA_NO_VOLUME if no root volume is present.
 *
 * SOURCE
 */

{
    eeb4:	e24dde53 	sub	sp, sp, #1328	; 0x530
    eeb8:	e24dd00c 	sub	sp, sp, #12
  bool keep_walking = false;
  int64_t vnid = -1, new_vnid = -1;
  void * data = NULL;
  volume_t volume = NULL, new_volume = NULL;
  char token[DNA_FILENAME_LENGTH], buffer[DNA_PATH_LENGTH];
  char * path_ptr = buffer;
    eebc:	e28dcf4e 	add	ip, sp, #312	; 0x138
 * SOURCE
 */

{
  bool keep_walking = false;
  int64_t vnid = -1, new_vnid = -1;
    eec0:	e59f62c0 	ldr	r6, [pc, #704]	; f188 <vnode_walk+0x2e8>
 * * DNA_NO_VOLUME if no root volume is present.
 *
 * SOURCE
 */

{
    eec4:	e1a08002 	mov	r8, r2
  bool keep_walking = false;
  int64_t vnid = -1, new_vnid = -1;
    eec8:	e28d2e53 	add	r2, sp, #1328	; 0x530
    eecc:	e2822008 	add	r2, r2, #8
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    dna_strcpy (buffer, path);
    eed0:	e1a0000c 	mov	r0, ip
 * * DNA_NO_VOLUME if no root volume is present.
 *
 * SOURCE
 */

{
    eed4:	e1a09001 	mov	r9, r1
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    dna_strcpy (buffer, path);
    eed8:	e1a01007 	mov	r1, r7
 * SOURCE
 */

{
  bool keep_walking = false;
  int64_t vnid = -1, new_vnid = -1;
    eedc:	e18240f6 	strd	r4, [r2, r6]
 * * DNA_NO_VOLUME if no root volume is present.
 *
 * SOURCE
 */

{
    eee0:	e1a07003 	mov	r7, r3
  bool keep_walking = false;
  int64_t vnid = -1, new_vnid = -1;
  void * data = NULL;
    eee4:	e58de028 	str	lr, [sp, #40]	; 0x28
  volume_t volume = NULL, new_volume = NULL;
  char token[DNA_FILENAME_LENGTH], buffer[DNA_PATH_LENGTH];
  char * path_ptr = buffer;
    eee8:	e58dc02c 	str	ip, [sp, #44]	; 0x2c
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    dna_strcpy (buffer, path);
    eeec:	eb000461 	bl	10078 <dna_strcpy>

    /*
     * First we need to load the root volume
     */
    
    status = path_get_next_entry (& path_ptr, token);
    eef0:	e28d002c 	add	r0, sp, #44	; 0x2c
    eef4:	e28d1038 	add	r1, sp, #56	; 0x38
    eef8:	eb000118 	bl	f360 <path_get_next_entry>
    ensure (status == DNA_OK, status);
    eefc:	e3500000 	cmp	r0, #0
    ef00:	0a000002 	beq	ef10 <vnode_walk+0x70>
    *p_vnid = vnid;
    *p_data = data;

    return DNA_OK;
  }
}
    ef04:	e28dde53 	add	sp, sp, #1328	; 0x530
    ef08:	e28dd00c 	add	sp, sp, #12
    ef0c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
     * First we need to load the root volume
     */
    
    status = path_get_next_entry (& path_ptr, token);
    ensure (status == DNA_OK, status);
    ensure (dna_strlen (token) == 0, DNA_ERROR);
    ef10:	e28d0038 	add	r0, sp, #56	; 0x38
    ef14:	eb000422 	bl	ffa4 <dna_strlen>
    ef18:	e250a000 	subs	sl, r0, #0
    ef1c:	0a000003 	beq	ef30 <vnode_walk+0x90>
    ef20:	e59f0264 	ldr	r0, [pc, #612]	; f18c <vnode_walk+0x2ec>
    *p_vnid = vnid;
    *p_data = data;

    return DNA_OK;
  }
}
    ef24:	e28dde53 	add	sp, sp, #1328	; 0x530
    ef28:	e28dd00c 	add	sp, sp, #12
    ef2c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    
    status = path_get_next_entry (& path_ptr, token);
    ensure (status == DNA_OK, status);
    ensure (dna_strlen (token) == 0, DNA_ERROR);

    it_status = cpu_trap_mask_and_backup();
    ef30:	eb000556 	bl	10490 <cpu_trap_mask_and_backup>
    ef34:	e1a0b000 	mov	fp, r0
    lock_acquire (& volume_manager . volume_list . lock);
    ef38:	e59f0250 	ldr	r0, [pc, #592]	; f190 <vnode_walk+0x2f0>
    ef3c:	eb00069f 	bl	109c0 <lock_acquire>

    new_volume = queue_lookup (& volume_manager . volume_list,
    ef40:	e1a0200a 	mov	r2, sl
    ef44:	e59f1248 	ldr	r1, [pc, #584]	; f194 <vnode_walk+0x2f4>
    ef48:	e1cd40f0 	strd	r4, [sp]
    ef4c:	e59f023c 	ldr	r0, [pc, #572]	; f190 <vnode_walk+0x2f0>
    ef50:	eb0003e6 	bl	fef0 <queue_lookup>
    ef54:	e1a0a000 	mov	sl, r0
        volume_host_inspector, volume, vnid);

    lock_release (& volume_manager . volume_list . lock);
    ef58:	e59f0230 	ldr	r0, [pc, #560]	; f190 <vnode_walk+0x2f0>
    ef5c:	eb00114b 	bl	13490 <lock_release>
    cpu_trap_restore (it_status);
    ef60:	e1a0000b 	mov	r0, fp
    ef64:	eb000582 	bl	10574 <cpu_trap_restore>

    ensure (new_volume != NULL, DNA_NO_VOLUME);
    ef68:	e35a0000 	cmp	sl, #0
    ef6c:	059f0224 	ldreq	r0, [pc, #548]	; f198 <vnode_walk+0x2f8>
    ef70:	0affffe3 	beq	ef04 <vnode_walk+0x64>

    volume = new_volume;
    vnid = new_volume -> root_vnid;
    ef74:	e1ca40d8 	ldrd	r4, [sl, #8]

    status = vnode_get (volume -> id, vnid, & data);
    ef78:	e28d3028 	add	r3, sp, #40	; 0x28
    ef7c:	e59a0004 	ldr	r0, [sl, #4]
    ef80:	e1a02004 	mov	r2, r4
    ef84:	e58d3000 	str	r3, [sp]
    ef88:	e1a03005 	mov	r3, r5
    ef8c:	ebfff96c 	bl	d544 <vnode_get>
    ensure (status == DNA_OK, status);
    ef90:	e3500000 	cmp	r0, #0
    ef94:	028db030 	addeq	fp, sp, #48	; 0x30
    ef98:	1affffd9 	bne	ef04 <vnode_walk+0x64>

    /*
     * Then, we iteratively analyze the path.
     */

    while ((status = path_get_next_entry (& path_ptr, token)) == DNA_OK)
    ef9c:	e28d002c 	add	r0, sp, #44	; 0x2c
    efa0:	e28d1038 	add	r1, sp, #56	; 0x38
    efa4:	eb0000ed 	bl	f360 <path_get_next_entry>
    efa8:	e3500000 	cmp	r0, #0
    efac:	1a00005f 	bne	f130 <vnode_walk+0x290>

        /*
         * Walk the current token on the current vnode.
         */

        status = volume -> cmd -> walk
    efb0:	e59a3020 	ldr	r3, [sl, #32]
    efb4:	e59a0024 	ldr	r0, [sl, #36]	; 0x24
    efb8:	e58db000 	str	fp, [sp]
    efbc:	e593c000 	ldr	ip, [r3]
    efc0:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
    efc4:	e3a03000 	mov	r3, #0
    efc8:	e28d2038 	add	r2, sp, #56	; 0x38
    efcc:	e12fff3c 	blx	ip
          (volume -> data, data, token, NULL, & new_vnid);
        ensure (status == DNA_ALREADY_AT_ROOT || status == DNA_OK, DNA_ERROR);
    efd0:	e3c03002 	bic	r3, r0, #2
    efd4:	e6ff3073 	uxth	r3, r3
    efd8:	e3530000 	cmp	r3, #0
    efdc:	1affffcf 	bne	ef20 <vnode_walk+0x80>
        /*
        * If the walk is stuck to the volume's root directory,
        * we try to move one stage upward.
        */

        if (status == DNA_ALREADY_AT_ROOT)
    efe0:	e3500002 	cmp	r0, #2
    efe4:	1a000016 	bne	f044 <vnode_walk+0x1a4>
           *
           * Then we check if the volume has a host. In such a case, we
           * move one stage upward.
           */

          if (volume -> host_volume != NULL)
    efe8:	e59a3014 	ldr	r3, [sl, #20]
        * we try to move one stage upward.
        */

        if (status == DNA_ALREADY_AT_ROOT)
        {
          new_vnid = vnid;
    efec:	e28d0e53 	add	r0, sp, #1328	; 0x530
    eff0:	e2800008 	add	r0, r0, #8
           *
           * Then we check if the volume has a host. In such a case, we
           * move one stage upward.
           */

          if (volume -> host_volume != NULL)
    eff4:	e3530000 	cmp	r3, #0
        * we try to move one stage upward.
        */

        if (status == DNA_ALREADY_AT_ROOT)
        {
          new_vnid = vnid;
    eff8:	e18040f6 	strd	r4, [r0, r6]
           *
           * Then we check if the volume has a host. In such a case, we
           * move one stage upward.
           */

          if (volume -> host_volume != NULL)
    effc:	0affffe6 	beq	ef9c <vnode_walk+0xfc>
          {
            keep_walking = true;

            status = vnode_put (volume -> id, new_vnid);
    f000:	e1a02004 	mov	r2, r4
    f004:	e1a03005 	mov	r3, r5
    f008:	e59a0004 	ldr	r0, [sl, #4]
    f00c:	ebfff906 	bl	d42c <vnode_put>
            ensure (status == DNA_OK, status);
    f010:	e3500000 	cmp	r0, #0
    f014:	1affffba 	bne	ef04 <vnode_walk+0x64>

            vnid = volume -> host_vnid;
    f018:	e1ca41d8 	ldrd	r4, [sl, #24]
            volume = volume -> host_volume;
    f01c:	e59aa014 	ldr	sl, [sl, #20]

            status = vnode_get (volume -> id, vnid, & data);
    f020:	e28d1028 	add	r1, sp, #40	; 0x28
    f024:	e59a0004 	ldr	r0, [sl, #4]
    f028:	e1a02004 	mov	r2, r4
    f02c:	e1a03005 	mov	r3, r5
    f030:	e58d1000 	str	r1, [sp]
    f034:	ebfff942 	bl	d544 <vnode_get>
            ensure (status == DNA_OK, status);
    f038:	e3500000 	cmp	r0, #0
    f03c:	0affffdb 	beq	efb0 <vnode_walk+0x110>
    f040:	eaffffaf 	b	ef04 <vnode_walk+0x64>
      /*
       * Do we need to update the node ? If yes, put back
       * the old one, look for a vname and load the new one.
       */

      if (vnid != new_vnid)
    f044:	e28d1e53 	add	r1, sp, #1328	; 0x530
    f048:	e1cd42f0 	strd	r4, [sp, #32]
    f04c:	e1cd22d0 	ldrd	r2, [sp, #32]
    f050:	e2811008 	add	r1, r1, #8
    f054:	e18140d6 	ldrd	r4, [r1, r6]
    f058:	e1530005 	cmp	r3, r5
    f05c:	01520004 	cmpeq	r2, r4
    f060:	e59f3120 	ldr	r3, [pc, #288]	; f188 <vnode_walk+0x2e8>
    f064:	0affffcc 	beq	ef9c <vnode_walk+0xfc>
      {
        it_status = cpu_trap_mask_and_backup();
    f068:	e58d300c 	str	r3, [sp, #12]
    f06c:	eb000507 	bl	10490 <cpu_trap_mask_and_backup>
    f070:	e1a0c000 	mov	ip, r0
        lock_acquire (& volume_manager . volume_list . lock);
    f074:	e59f0114 	ldr	r0, [pc, #276]	; f190 <vnode_walk+0x2f0>
    f078:	e58dc014 	str	ip, [sp, #20]

        new_volume = queue_lookup (& volume_manager . volume_list,
    f07c:	e28d5e53 	add	r5, sp, #1328	; 0x530
       */

      if (vnid != new_vnid)
      {
        it_status = cpu_trap_mask_and_backup();
        lock_acquire (& volume_manager . volume_list . lock);
    f080:	eb00064e 	bl	109c0 <lock_acquire>

        new_volume = queue_lookup (& volume_manager . volume_list,
    f084:	e59d300c 	ldr	r3, [sp, #12]
    f088:	e2855008 	add	r5, r5, #8
    f08c:	e18540d3 	ldrd	r4, [r5, r3]
    f090:	e1a0200a 	mov	r2, sl
    f094:	e59f10f8 	ldr	r1, [pc, #248]	; f194 <vnode_walk+0x2f4>
    f098:	e59f00f0 	ldr	r0, [pc, #240]	; f190 <vnode_walk+0x2f0>
    f09c:	e1cd40f0 	strd	r4, [sp]
    f0a0:	eb000392 	bl	fef0 <queue_lookup>
    f0a4:	e1a01000 	mov	r1, r0
            volume_host_inspector, volume, new_vnid);

        lock_release (& volume_manager . volume_list . lock);
    f0a8:	e59f00e0 	ldr	r0, [pc, #224]	; f190 <vnode_walk+0x2f0>
    f0ac:	e58d1010 	str	r1, [sp, #16]
    f0b0:	eb0010f6 	bl	13490 <lock_release>
        cpu_trap_restore (it_status);
    f0b4:	e59dc014 	ldr	ip, [sp, #20]
    f0b8:	e1a0000c 	mov	r0, ip
    f0bc:	eb00052c 	bl	10574 <cpu_trap_restore>

        if (new_volume != NULL)
    f0c0:	e59d1010 	ldr	r1, [sp, #16]
    f0c4:	e59d300c 	ldr	r3, [sp, #12]
    f0c8:	e3510000 	cmp	r1, #0
    f0cc:	0a00001d 	beq	f148 <vnode_walk+0x2a8>
        {
          new_vnid = new_volume -> root_vnid;
    f0d0:	e1c140d8 	ldrd	r4, [r1, #8]

          status = vnode_get (new_volume -> id, new_vnid, & data);
    f0d4:	e28d0028 	add	r0, sp, #40	; 0x28
        lock_release (& volume_manager . volume_list . lock);
        cpu_trap_restore (it_status);

        if (new_volume != NULL)
        {
          new_vnid = new_volume -> root_vnid;
    f0d8:	e28d2e53 	add	r2, sp, #1328	; 0x530

          status = vnode_get (new_volume -> id, new_vnid, & data);
    f0dc:	e58d0000 	str	r0, [sp]
        lock_release (& volume_manager . volume_list . lock);
        cpu_trap_restore (it_status);

        if (new_volume != NULL)
        {
          new_vnid = new_volume -> root_vnid;
    f0e0:	e2822008 	add	r2, r2, #8

          status = vnode_get (new_volume -> id, new_vnid, & data);
    f0e4:	e5910004 	ldr	r0, [r1, #4]
        lock_release (& volume_manager . volume_list . lock);
        cpu_trap_restore (it_status);

        if (new_volume != NULL)
        {
          new_vnid = new_volume -> root_vnid;
    f0e8:	e18240f3 	strd	r4, [r2, r3]

          status = vnode_get (new_volume -> id, new_vnid, & data);
    f0ec:	e1a02004 	mov	r2, r4
    f0f0:	e1a03005 	mov	r3, r5
    f0f4:	e58d1010 	str	r1, [sp, #16]
    f0f8:	ebfff911 	bl	d544 <vnode_get>
          ensure (status == DNA_OK, status);
    f0fc:	e3500000 	cmp	r0, #0
    f100:	1affff7f 	bne	ef04 <vnode_walk+0x64>

          status = vnode_put (volume -> id, vnid);
    f104:	e1cd22d0 	ldrd	r2, [sp, #32]
    f108:	e59a0004 	ldr	r0, [sl, #4]
    f10c:	ebfff8c6 	bl	d42c <vnode_put>
          ensure (status == DNA_OK, status);
    f110:	e3500000 	cmp	r0, #0
    f114:	e59d1010 	ldr	r1, [sp, #16]
    f118:	1affff79 	bne	ef04 <vnode_walk+0x64>

          status = vnode_put (volume -> id, vnid);
          ensure (status == DNA_OK, status);
        }

        vnid = new_vnid;
    f11c:	e28d0e53 	add	r0, sp, #1328	; 0x530
    f120:	e2800008 	add	r0, r0, #8
    f124:	e18040d6 	ldrd	r4, [r0, r6]
    f128:	e1a0a001 	mov	sl, r1
    f12c:	eaffff9a 	b	ef9c <vnode_walk+0xfc>
     * Assign the results into the arguments, and return.
     */

    *p_volume = volume;
    *p_vnid = vnid;
    *p_data = data;
    f130:	e59d3028 	ldr	r3, [sp, #40]	; 0x28

    /*
     * Assign the results into the arguments, and return.
     */

    *p_volume = volume;
    f134:	e589a000 	str	sl, [r9]
    *p_vnid = vnid;
    *p_data = data;

    return DNA_OK;
    f138:	e3a00000 	mov	r0, #0
    /*
     * Assign the results into the arguments, and return.
     */

    *p_volume = volume;
    *p_vnid = vnid;
    f13c:	e1c840f0 	strd	r4, [r8]
    *p_data = data;
    f140:	e5873000 	str	r3, [r7]

    return DNA_OK;
    f144:	eaffff6e 	b	ef04 <vnode_walk+0x64>

          volume = new_volume;
        }
        else
        {
          status = vnode_get (volume -> id, new_vnid, & data);
    f148:	e28d4028 	add	r4, sp, #40	; 0x28
    f14c:	e28d5e53 	add	r5, sp, #1328	; 0x530
    f150:	e58d4000 	str	r4, [sp]
    f154:	e2855008 	add	r5, r5, #8
    f158:	e59a0004 	ldr	r0, [sl, #4]
    f15c:	e18320d5 	ldrd	r2, [r3, r5]
    f160:	ebfff8f7 	bl	d544 <vnode_get>
          ensure (status == DNA_OK, status);
    f164:	e3500000 	cmp	r0, #0
    f168:	1affff65 	bne	ef04 <vnode_walk+0x64>

          status = vnode_put (volume -> id, vnid);
    f16c:	e1cd22d0 	ldrd	r2, [sp, #32]
    f170:	e59a0004 	ldr	r0, [sl, #4]
    f174:	ebfff8ac 	bl	d42c <vnode_put>
          ensure (status == DNA_OK, status);
    f178:	e3500000 	cmp	r0, #0
    f17c:	1affff60 	bne	ef04 <vnode_walk+0x64>
    f180:	e1a0100a 	mov	r1, sl
    f184:	eaffffe4 	b	f11c <vnode_walk+0x27c>
    f188:	fffffaf8 	.word	0xfffffaf8
    f18c:	0000ffff 	.word	0x0000ffff
    f190:	0013f58c 	.word	0x0013f58c
    f194:	0000dad4 	.word	0x0000dad4
    f198:	0000fefe 	.word	0x0000fefe

0000f19c <dna_log2>:

  register uint32_t r = 0;

  for (int32_t i = 4; i >= 0; i -= 1)
  {
    if (value & b[i])
    f19c:	e1a02820 	lsr	r2, r0, #16
    f1a0:	e1a01802 	lsl	r1, r2, #16
    {
      value >>= S[i];
    f1a4:	e3510000 	cmp	r1, #0

#include <stdint.h>
#include <DnaTools/DnaTools.h>

uint32_t dna_log2 (uint32_t value)
{
    f1a8:	e1a03000 	mov	r3, r0

  for (int32_t i = 4; i >= 0; i -= 1)
  {
    if (value & b[i])
    {
      value >>= S[i];
    f1ac:	11a03002 	movne	r3, r2
    f1b0:	03a00000 	moveq	r0, #0
    f1b4:	13a00010 	movne	r0, #16

  register uint32_t r = 0;

  for (int32_t i = 4; i >= 0; i -= 1)
  {
    if (value & b[i])
    f1b8:	e3130cff 	tst	r3, #65280	; 0xff00
    {
      value >>= S[i];
    f1bc:	11a03423 	lsrne	r3, r3, #8
      r |= S[i];
    f1c0:	13800008 	orrne	r0, r0, #8

  register uint32_t r = 0;

  for (int32_t i = 4; i >= 0; i -= 1)
  {
    if (value & b[i])
    f1c4:	e31300f0 	tst	r3, #240	; 0xf0
    {
      value >>= S[i];
    f1c8:	11a03223 	lsrne	r3, r3, #4
      r |= S[i];
    f1cc:	13800004 	orrne	r0, r0, #4

  register uint32_t r = 0;

  for (int32_t i = 4; i >= 0; i -= 1)
  {
    if (value & b[i])
    f1d0:	e313000c 	tst	r3, #12
    {
      value >>= S[i];
    f1d4:	11a03123 	lsrne	r3, r3, #2
      r |= S[i];
    f1d8:	13800002 	orrne	r0, r0, #2

  register uint32_t r = 0;

  for (int32_t i = 4; i >= 0; i -= 1)
  {
    if (value & b[i])
    f1dc:	e3130002 	tst	r3, #2
    {
      value >>= S[i];
      r |= S[i];
    f1e0:	13800001 	orrne	r0, r0, #1
    }
  }

  return r;
}
    f1e4:	e12fff1e 	bx	lr

0000f1e8 <queue_extract>:

#include <DnaTools/DnaTools.h>
#include <Processor/Cache.h>

status_t queue_extract (queue_t * queue, void * data)
{
    f1e8:	e92d4070 	push	{r4, r5, r6, lr}
  queue_link_t * item = data;
  queue_link_t * kitem = queue -> head;

  watch (status_t)
  {
    ensure (queue != NULL && data != NULL, DNA_BAD_ARGUMENT);
    f1ec:	e2516000 	subs	r6, r1, #0

#include <DnaTools/DnaTools.h>
#include <Processor/Cache.h>

status_t queue_extract (queue_t * queue, void * data)
{
    f1f0:	e1a05000 	mov	r5, r0
  queue_link_t * item = data;
  queue_link_t * kitem = queue -> head;
    f1f4:	e5904004 	ldr	r4, [r0, #4]

  watch (status_t)
  {
    ensure (queue != NULL && data != NULL, DNA_BAD_ARGUMENT);
    f1f8:	1a000001 	bne	f204 <queue_extract+0x1c>
    f1fc:	e59f00a4 	ldr	r0, [pc, #164]	; f2a8 <queue_extract+0xc0>
    f200:	e8bd8070 	pop	{r4, r5, r6, pc}
    cpu_dcache_invalidate((void*)(&queue->status),sizeof(uint32_t));
    f204:	e280000c 	add	r0, r0, #12
    f208:	e3a01004 	mov	r1, #4
    f20c:	eb00050b 	bl	10640 <cpu_dcache_invalidate>
    ensure (queue -> status != 0, DNA_ERROR);
    f210:	e595300c 	ldr	r3, [r5, #12]
    f214:	e3530000 	cmp	r3, #0
    f218:	1a000001 	bne	f224 <queue_extract+0x3c>
    f21c:	e59f0088 	ldr	r0, [pc, #136]	; f2ac <queue_extract+0xc4>
    f220:	e8bd8070 	pop	{r4, r5, r6, pc}

    if (queue -> head == item)
    f224:	e5953004 	ldr	r3, [r5, #4]
    f228:	e1560003 	cmp	r6, r3
    f22c:	0a000018 	beq	f294 <queue_extract+0xac>
    {
      queue -> head = item -> next;
    }
    else    
    {
      cpu_dcache_invalidate((void*)&kitem->next, sizeof(struct _queue_link*));
    f230:	e1a00004 	mov	r0, r4
    f234:	e3a01004 	mov	r1, #4
    f238:	eb000500 	bl	10640 <cpu_dcache_invalidate>
      while (kitem -> next != item && kitem -> next != NULL)
    f23c:	e5943000 	ldr	r3, [r4]
    f240:	e1560003 	cmp	r6, r3
    f244:	0a000008 	beq	f26c <queue_extract+0x84>
    f248:	e3530000 	cmp	r3, #0
    f24c:	0afffff2 	beq	f21c <queue_extract+0x34>
      {
        cpu_dcache_invalidate((void*)&kitem->next, sizeof(struct _queue_link*));
    f250:	e1a00004 	mov	r0, r4
    f254:	e3a01004 	mov	r1, #4
    f258:	eb0004f8 	bl	10640 <cpu_dcache_invalidate>
        kitem = kitem -> next;
    f25c:	e5944000 	ldr	r4, [r4]
      queue -> head = item -> next;
    }
    else    
    {
      cpu_dcache_invalidate((void*)&kitem->next, sizeof(struct _queue_link*));
      while (kitem -> next != item && kitem -> next != NULL)
    f260:	e5943000 	ldr	r3, [r4]
    f264:	e1560003 	cmp	r6, r3
    f268:	1afffff6 	bne	f248 <queue_extract+0x60>
        kitem = kitem -> next;
      }

      ensure (kitem -> next == item, DNA_ERROR);

      kitem -> next = item -> next;
    f26c:	e5963000 	ldr	r3, [r6]

      if (kitem -> next == NULL)
    f270:	e3530000 	cmp	r3, #0
        kitem = kitem -> next;
      }

      ensure (kitem -> next == item, DNA_ERROR);

      kitem -> next = item -> next;
    f274:	e5843000 	str	r3, [r4]

      if (kitem -> next == NULL)
    f278:	0a000008 	beq	f2a0 <queue_extract+0xb8>
      {
        queue -> tail = kitem;
      }
    }

    item -> next = NULL;
    f27c:	e3a00000 	mov	r0, #0
    queue -> status -= 1;
    f280:	e595300c 	ldr	r3, [r5, #12]
      {
        queue -> tail = kitem;
      }
    }

    item -> next = NULL;
    f284:	e5860000 	str	r0, [r6]
    queue -> status -= 1;
    f288:	e2433001 	sub	r3, r3, #1
    f28c:	e585300c 	str	r3, [r5, #12]

    return DNA_OK;
    f290:	e8bd8070 	pop	{r4, r5, r6, pc}
    cpu_dcache_invalidate((void*)(&queue->status),sizeof(uint32_t));
    ensure (queue -> status != 0, DNA_ERROR);

    if (queue -> head == item)
    {
      queue -> head = item -> next;
    f294:	e5963000 	ldr	r3, [r6]
    f298:	e5853004 	str	r3, [r5, #4]
    f29c:	eafffff6 	b	f27c <queue_extract+0x94>

      kitem -> next = item -> next;

      if (kitem -> next == NULL)
      {
        queue -> tail = kitem;
    f2a0:	e5854008 	str	r4, [r5, #8]
    f2a4:	eafffff4 	b	f27c <queue_extract+0x94>
    f2a8:	0000fffc 	.word	0x0000fffc
    f2ac:	0000ffff 	.word	0x0000ffff

0000f2b0 <dna_strncmp>:

#include <stdint.h>
#include <DnaTools/DnaTools.h>

int32_t dna_strncmp (const char *s1, const char *s2, size_t n)
{
    f2b0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  char *s1_ptr = (char *)s1, *s2_ptr = (char *)s2;
  size_t i = 0;
    f2b4:	e3a03000 	mov	r3, #0
    f2b8:	ea000003 	b	f2cc <dna_strncmp+0x1c>
      return -1;
    }
       i++;
  }
  while ( (*s2_ptr++ != '\0') &&
             (i < n));
    f2bc:	e35c0000 	cmp	ip, #0
    f2c0:	0a000008 	beq	f2e8 <dna_strncmp+0x38>
    {
      return -1;
    }
       i++;
  }
  while ( (*s2_ptr++ != '\0') &&
    f2c4:	e1530002 	cmp	r3, r2
    f2c8:	2a000006 	bcs	f2e8 <dna_strncmp+0x38>
  char *s1_ptr = (char *)s1, *s2_ptr = (char *)s2;
  size_t i = 0;

  do
  {
    if (*s1_ptr++ != *s2_ptr)
    f2cc:	e7d1c003 	ldrb	ip, [r1, r3]
    f2d0:	e4d0e001 	ldrb	lr, [r0], #1
    {
      return -1;
    }
       i++;
    f2d4:	e2833001 	add	r3, r3, #1
  char *s1_ptr = (char *)s1, *s2_ptr = (char *)s2;
  size_t i = 0;

  do
  {
    if (*s1_ptr++ != *s2_ptr)
    f2d8:	e15c000e 	cmp	ip, lr
    f2dc:	0afffff6 	beq	f2bc <dna_strncmp+0xc>
    {
      return -1;
    f2e0:	e3e00000 	mvn	r0, #0
    f2e4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
       i++;
  }
  while ( (*s2_ptr++ != '\0') &&
             (i < n));
  
  return 0;
    f2e8:	e3a00000 	mov	r0, #0
}
    f2ec:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

0000f2f0 <queue_rem>:
 */

#include <DnaTools/DnaTools.h>
#include <Processor/Cache.h>
void * queue_rem (queue_t * queue)
{
    f2f0:	e92d4038 	push	{r3, r4, r5, lr}
    f2f4:	e1a04000 	mov	r4, r0
  queue_link_t * item = NULL;

  watch (void *)
  {
    cpu_dcache_invalidate((void*)&queue->status,sizeof(uint32_t));
    f2f8:	e3a01004 	mov	r1, #4
    f2fc:	e280000c 	add	r0, r0, #12
    f300:	eb0004ce 	bl	10640 <cpu_dcache_invalidate>
    ensure (queue -> status != 0, NULL);
    f304:	e594300c 	ldr	r3, [r4, #12]
    f308:	e3530000 	cmp	r3, #0
    f30c:	0a000011 	beq	f358 <queue_rem+0x68>

    item = queue -> head;

    queue -> status -= 1;
    f310:	e594300c 	ldr	r3, [r4, #12]
  watch (void *)
  {
    cpu_dcache_invalidate((void*)&queue->status,sizeof(uint32_t));
    ensure (queue -> status != 0, NULL);

    item = queue -> head;
    f314:	e5945004 	ldr	r5, [r4, #4]

    queue -> status -= 1;
    f318:	e2433001 	sub	r3, r3, #1
    f31c:	e584300c 	str	r3, [r4, #12]

    cpu_dcache_invalidate((void*)&(item->next), sizeof(queue_link_t)); 
    f320:	e1a00005 	mov	r0, r5
    f324:	e3a01004 	mov	r1, #4
    f328:	eb0004c4 	bl	10640 <cpu_dcache_invalidate>
    queue -> head = item -> next;
    f32c:	e5953000 	ldr	r3, [r5]

    check (queue_error, queue -> head != NULL ||
    f330:	e3530000 	cmp	r3, #0
    item = queue -> head;

    queue -> status -= 1;

    cpu_dcache_invalidate((void*)&(item->next), sizeof(queue_link_t)); 
    queue -> head = item -> next;
    f334:	e5843004 	str	r3, [r4, #4]

    check (queue_error, queue -> head != NULL ||
    f338:	0a000003 	beq	f34c <queue_rem+0x5c>
        (queue -> head == NULL && queue -> status == 0), NULL);

    item -> next = NULL;
    f33c:	e3a03000 	mov	r3, #0

    return item;
    f340:	e1a00005 	mov	r0, r5
    queue -> head = item -> next;

    check (queue_error, queue -> head != NULL ||
        (queue -> head == NULL && queue -> status == 0), NULL);

    item -> next = NULL;
    f344:	e5853000 	str	r3, [r5]
dna_log(PANIC_LEVEL, "Q(0x%x): status %d, item 0x%x",
        queue, queue -> status, item);

    leave;
  }
}
    f348:	e8bd8038 	pop	{r3, r4, r5, pc}
    queue -> status -= 1;

    cpu_dcache_invalidate((void*)&(item->next), sizeof(queue_link_t)); 
    queue -> head = item -> next;

    check (queue_error, queue -> head != NULL ||
    f34c:	e594300c 	ldr	r3, [r4, #12]
    f350:	e3530000 	cmp	r3, #0
    f354:	0afffff8 	beq	f33c <queue_rem+0x4c>
  queue_link_t * item = NULL;

  watch (void *)
  {
    cpu_dcache_invalidate((void*)&queue->status,sizeof(uint32_t));
    ensure (queue -> status != 0, NULL);
    f358:	e3a00000 	mov	r0, #0
    f35c:	e8bd8038 	pop	{r3, r4, r5, pc}

0000f360 <path_get_next_entry>:
 * * DNA_OK : the operation succeeded.
 *
 * SOURCE
 */

{
    f360:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
  char * p_start = *path, * p_end = *path;
    f364:	e590c000 	ldr	ip, [r0]
 * * DNA_OK : the operation succeeded.
 *
 * SOURCE
 */

{
    f368:	e1a05000 	mov	r5, r0
  char * p_start = *path, * p_end = *path;
  int32_t token_size = 0;

  watch (status_t)
  {
    ensure (*p_start != '\0', DNA_ERROR);
    f36c:	e5dc3000 	ldrb	r3, [ip]
    f370:	e3530000 	cmp	r3, #0
    f374:	1a000001 	bne	f380 <path_get_next_entry+0x20>
    f378:	e59f006c 	ldr	r0, [pc, #108]	; f3ec <path_get_next_entry+0x8c>
    f37c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

    /*
     * Find the first occurence of '/'
     */

    while (*p_end != '/' && *p_end != '\0')
    f380:	e353002f 	cmp	r3, #47	; 0x2f
    f384:	e1a06001 	mov	r6, r1
    f388:	e1a0400c 	mov	r4, ip
    f38c:	0a000008 	beq	f3b4 <path_get_next_entry+0x54>
    f390:	e5f43001 	ldrb	r3, [r4, #1]!
    f394:	e3530000 	cmp	r3, #0
    f398:	1353002f 	cmpne	r3, #47	; 0x2f
    f39c:	1afffffb 	bne	f390 <path_get_next_entry+0x30>
    f3a0:	e06c7004 	rsb	r7, ip, r4
    /*
     * Copy the token
     */

    token_size = p_end - p_start;
    ensure (token_size <= DNA_FILENAME_LENGTH, DNA_NAME_TOO_LONG);
    f3a4:	e3570c01 	cmp	r7, #256	; 0x100
    f3a8:	da000002 	ble	f3b8 <path_get_next_entry+0x58>
    f3ac:	e59f003c 	ldr	r0, [pc, #60]	; f3f0 <path_get_next_entry+0x90>
    }

    *path = p_end;
    return DNA_OK;
  }
}
    f3b0:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

    /*
     * Find the first occurence of '/'
     */

    while (*p_end != '/' && *p_end != '\0')
    f3b4:	e3a07000 	mov	r7, #0
     */

    token_size = p_end - p_start;
    ensure (token_size <= DNA_FILENAME_LENGTH, DNA_NAME_TOO_LONG);

    dna_memcpy (token, p_start, token_size);
    f3b8:	e1a02007 	mov	r2, r7
    f3bc:	e1a0100c 	mov	r1, ip
    f3c0:	e1a00006 	mov	r0, r6
    f3c4:	eb000332 	bl	10094 <dna_memcpy>
    token[token_size] = '\0';
    f3c8:	e3a03000 	mov	r3, #0
    f3cc:	e7c63007 	strb	r3, [r6, r7]

    /*
     * Cut the token from its original string
     */

    if (*p_end == '/')
    f3d0:	e5d42000 	ldrb	r2, [r4]
    {
      *p_end ++ = '\0';
    }

    *path = p_end;
    return DNA_OK;
    f3d4:	e3a00000 	mov	r0, #0

    /*
     * Cut the token from its original string
     */

    if (*p_end == '/')
    f3d8:	e352002f 	cmp	r2, #47	; 0x2f
    {
      *p_end ++ = '\0';
    f3dc:	05c43000 	strbeq	r3, [r4]
    f3e0:	02844001 	addeq	r4, r4, #1
    }

    *path = p_end;
    f3e4:	e5854000 	str	r4, [r5]
    return DNA_OK;
    f3e8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
    f3ec:	0000ffff 	.word	0x0000ffff
    f3f0:	0000fffa 	.word	0x0000fffa

0000f3f4 <queue_walk>:

#include <stdbool.h>
#include <DnaTools/DnaTools.h>

void queue_walk (queue_t * queue, queue_inspector_t inspector, ...)
{
    f3f4:	e92d000e 	push	{r1, r2, r3}
    f3f8:	e92d4070 	push	{r4, r5, r6, lr}
  va_list list, list_copy;
  queue_link_t * item = NULL, * old_item = NULL;

  va_start (list, inspector);

  if (queue -> status != 0)
    f3fc:	e590200c 	ldr	r2, [r0, #12]

#include <stdbool.h>
#include <DnaTools/DnaTools.h>

void queue_walk (queue_t * queue, queue_inspector_t inspector, ...)
{
    f400:	e24dd00c 	sub	sp, sp, #12
  bool result;
  va_list list, list_copy;
  queue_link_t * item = NULL, * old_item = NULL;

  va_start (list, inspector);
    f404:	e28d3020 	add	r3, sp, #32

  if (queue -> status != 0)
    f408:	e3520000 	cmp	r2, #0

#include <stdbool.h>
#include <DnaTools/DnaTools.h>

void queue_walk (queue_t * queue, queue_inspector_t inspector, ...)
{
    f40c:	e1a06000 	mov	r6, r0
  bool result;
  va_list list, list_copy;
  queue_link_t * item = NULL, * old_item = NULL;

  va_start (list, inspector);
    f410:	e58d3000 	str	r3, [sp]

#include <stdbool.h>
#include <DnaTools/DnaTools.h>

void queue_walk (queue_t * queue, queue_inspector_t inspector, ...)
{
    f414:	e59d501c 	ldr	r5, [sp, #28]
  va_list list, list_copy;
  queue_link_t * item = NULL, * old_item = NULL;

  va_start (list, inspector);

  if (queue -> status != 0)
    f418:	0a000011 	beq	f464 <queue_walk+0x70>
  {
    item = queue -> head;
    f41c:	e5904004 	ldr	r4, [r0, #4]
    while (item != NULL)
    f420:	e3540000 	cmp	r4, #0
    f424:	0a00000e 	beq	f464 <queue_walk+0x70>
    {
      result = false;

      va_copy (list_copy, list);
    f428:	e59d3000 	ldr	r3, [sp]
      result = inspector (item, list_copy);
    f42c:	e1a00004 	mov	r0, r4
    f430:	e1a01003 	mov	r1, r3
    item = queue -> head;
    while (item != NULL)
    {
      result = false;

      va_copy (list_copy, list);
    f434:	e58d3004 	str	r3, [sp, #4]
      result = inspector (item, list_copy);
    f438:	e12fff35 	blx	r5
      va_end (list_copy);

      if (result)
    f43c:	e3500000 	cmp	r0, #0
      {
        old_item = item;
        item = item -> next;
        queue_extract (queue, old_item);
      }
      else item = item -> next;
    f440:	05944000 	ldreq	r4, [r4]

      va_copy (list_copy, list);
      result = inspector (item, list_copy);
      va_end (list_copy);

      if (result)
    f444:	0afffff5 	beq	f420 <queue_walk+0x2c>
      {
        old_item = item;
        item = item -> next;
    f448:	e5943000 	ldr	r3, [r4]
        queue_extract (queue, old_item);
    f44c:	e1a01004 	mov	r1, r4
      va_end (list_copy);

      if (result)
      {
        old_item = item;
        item = item -> next;
    f450:	e1a04003 	mov	r4, r3
        queue_extract (queue, old_item);
    f454:	e1a00006 	mov	r0, r6
    f458:	ebffff62 	bl	f1e8 <queue_extract>
  va_start (list, inspector);

  if (queue -> status != 0)
  {
    item = queue -> head;
    while (item != NULL)
    f45c:	e3540000 	cmp	r4, #0
    f460:	1afffff0 	bne	f428 <queue_walk+0x34>
      else item = item -> next;
    }
  }

  va_end (list);
}
    f464:	e28dd00c 	add	sp, sp, #12
    f468:	e8bd4070 	pop	{r4, r5, r6, lr}
    f46c:	e28dd00c 	add	sp, sp, #12
    f470:	e12fff1e 	bx	lr

0000f474 <dna_memset>:

#include <stdint.h>
#include <DnaTools/DnaTools.h>

void * dna_memset (void * s, int32_t c, size_t n)
{
    f474:	e92d4008 	push	{r3, lr}
  int32_t rem = n % 4;
  int32_t quo = n >> 2;
  int32_t step = 0;
  
  for (step = 0; step < quo; step++)
    f478:	e1b0e122 	lsrs	lr, r2, #2

#include <stdint.h>
#include <DnaTools/DnaTools.h>

void * dna_memset (void * s, int32_t c, size_t n)
{
    f47c:	e1a0c000 	mov	ip, r0
  int32_t rem = n % 4;
    f480:	e2022003 	and	r2, r2, #3
  int32_t quo = n >> 2;
  int32_t step = 0;
  
  for (step = 0; step < quo; step++)
    f484:	0a000005 	beq	f4a0 <dna_memset+0x2c>
    f488:	e3a03000 	mov	r3, #0
    f48c:	e1a0010e 	lsl	r0, lr, #2
  {
    *((int32_t *)s + step) = c;
    f490:	e78c1003 	str	r1, [ip, r3]
    f494:	e2833004 	add	r3, r3, #4
{
  int32_t rem = n % 4;
  int32_t quo = n >> 2;
  int32_t step = 0;
  
  for (step = 0; step < quo; step++)
    f498:	e1530000 	cmp	r3, r0
    f49c:	1afffffb 	bne	f490 <dna_memset+0x1c>
  {
    *((int32_t *)s + step) = c;
  }

  for (step = 0; step < rem; step++)
    f4a0:	e3520000 	cmp	r2, #0
    f4a4:	0a000003 	beq	f4b8 <dna_memset+0x44>
    f4a8:	e1a0000c 	mov	r0, ip
    f4ac:	e6ef1071 	uxtb	r1, r1
    f4b0:	eb0024b0 	bl	18778 <memset>
    f4b4:	e1a0c000 	mov	ip, r0
  {
    *((char *)s + step) = (char)c;
  }
  
  return s;
}
    f4b8:	e1a0000c 	mov	r0, ip
    f4bc:	e8bd8008 	pop	{r3, pc}

0000f4c0 <dna_memcmp>:
#include <stdint.h>
#include <DnaTools/DnaTools.h>

int32_t dna_memcmp (const void *s1, const void *s2, size_t n)
{
  for (size_t i = 0; i < n; i += 1)
    f4c0:	e3520000 	cmp	r2, #0
    f4c4:	0a000012 	beq	f514 <dna_memcmp+0x54>
  {
    if (((uint8_t *)s1)[i] != ((uint8_t *)s2)[i])
    f4c8:	e5d0c000 	ldrb	ip, [r0]
    f4cc:	e5d13000 	ldrb	r3, [r1]
    f4d0:	e15c0003 	cmp	ip, r3
    f4d4:	02422001 	subeq	r2, r2, #1
    f4d8:	00802002 	addeq	r2, r0, r2
    f4dc:	0a000004 	beq	f4f4 <dna_memcmp+0x34>
    f4e0:	ea000007 	b	f504 <dna_memcmp+0x44>
    f4e4:	e5f0c001 	ldrb	ip, [r0, #1]!
    f4e8:	e5f13001 	ldrb	r3, [r1, #1]!
    f4ec:	e15c0003 	cmp	ip, r3
    f4f0:	1a000003 	bne	f504 <dna_memcmp+0x44>
#include <stdint.h>
#include <DnaTools/DnaTools.h>

int32_t dna_memcmp (const void *s1, const void *s2, size_t n)
{
  for (size_t i = 0; i < n; i += 1)
    f4f4:	e1500002 	cmp	r0, r2
    f4f8:	1afffff9 	bne	f4e4 <dna_memcmp+0x24>
        return (int32_t)(((uint8_t *)s1)[i] - ((uint8_t *)s2)[i]);
      }
    }
  }
  
  return 0;
    f4fc:	e3a00000 	mov	r0, #0
    f500:	e12fff1e 	bx	lr
{
  for (size_t i = 0; i < n; i += 1)
  {
    if (((uint8_t *)s1)[i] != ((uint8_t *)s2)[i])
    {
      if (((uint8_t *)s2)[i] > ((uint8_t *)s1)[i])
    f504:	e15c0003 	cmp	ip, r3
      {
        return (int32_t)(((uint8_t *)s2)[i] - ((uint8_t *)s1)[i]);
    f508:	306c0003 	rsbcc	r0, ip, r3
      }
      else
      {
        return (int32_t)(((uint8_t *)s1)[i] - ((uint8_t *)s2)[i]);
    f50c:	2063000c 	rsbcs	r0, r3, ip
    f510:	e12fff1e 	bx	lr
      }
    }
  }
  
  return 0;
    f514:	e1a00002 	mov	r0, r2
}
    f518:	e12fff1e 	bx	lr

0000f51c <dna_printf>:
 * Print formatted text.
 *
 * SOURCE
 */

{
    f51c:	e92d000f 	push	{r0, r1, r2, r3}
    f520:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f524:	e24ddf53 	sub	sp, sp, #332	; 0x14c
    f528:	e59d8170 	ldr	r8, [sp, #368]	; 0x170
  uint64_t unsigned_value, remainder;

  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);
    f52c:	e28d2f5d 	add	r2, sp, #372	; 0x174

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f530:	e5d83000 	ldrb	r3, [r8]
  uint64_t unsigned_value, remainder;

  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);
    f534:	e58d2024 	str	r2, [sp, #36]	; 0x24

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f538:	e3530000 	cmp	r3, #0
    f53c:	0a0001e3 	beq	fcd0 <dna_printf+0x7b4>
  char char_value, ascii[32], * string_value, buffer[256];
  int32_t ascii_index, string_length, j = 0;
  int64_t signed_value;
  uint64_t unsigned_value, remainder;

  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;
    f540:	e3a02000 	mov	r2, #0

{
  bool is_long = false, is_long_long = false;
  bool is_short = false, is_char = false;
  char char_value, ascii[32], * string_value, buffer[256];
  int32_t ascii_index, string_length, j = 0;
    f544:	e1a09002 	mov	r9, r2
    f548:	e1a0b002 	mov	fp, r2
    f54c:	e28dc048 	add	ip, sp, #72	; 0x48
 * SOURCE
 */

{
  bool is_long = false, is_long_long = false;
  bool is_short = false, is_char = false;
    f550:	e58d200c 	str	r2, [sp, #12]
 *
 * SOURCE
 */

{
  bool is_long = false, is_long_long = false;
    f554:	e58d2004 	str	r2, [sp, #4]
    f558:	e58d2008 	str	r2, [sp, #8]
    f55c:	e58dc000 	str	ip, [sp]
    f560:	e28da028 	add	sl, sp, #40	; 0x28
  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
  {
    switch (state)
    f564:	e3520001 	cmp	r2, #1
    f568:	0a000059 	beq	f6d4 <dna_printf+0x1b8>
    f56c:	e3520002 	cmp	r2, #2
    f570:	1a00006e 	bne	f730 <dna_printf+0x214>
          break;
        }

      case FORMAT :
        {
          switch (format[i])
    f574:	e2433025 	sub	r3, r3, #37	; 0x25
    f578:	e3530053 	cmp	r3, #83	; 0x53
    f57c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    f580:	ea0001a0 	b	fc08 <dna_printf+0x6ec>
    f584:	0000fa8c 	.word	0x0000fa8c
    f588:	0000fc08 	.word	0x0000fc08
    f58c:	0000fc08 	.word	0x0000fc08
    f590:	0000fc08 	.word	0x0000fc08
    f594:	0000fc08 	.word	0x0000fc08
    f598:	0000fc08 	.word	0x0000fc08
    f59c:	0000fc08 	.word	0x0000fc08
    f5a0:	0000fc08 	.word	0x0000fc08
    f5a4:	0000fc08 	.word	0x0000fc08
    f5a8:	0000f6fc 	.word	0x0000f6fc
    f5ac:	0000fc08 	.word	0x0000fc08
    f5b0:	0000f6fc 	.word	0x0000f6fc
    f5b4:	0000f6fc 	.word	0x0000f6fc
    f5b8:	0000f6fc 	.word	0x0000f6fc
    f5bc:	0000f6fc 	.word	0x0000f6fc
    f5c0:	0000f6fc 	.word	0x0000f6fc
    f5c4:	0000f6fc 	.word	0x0000f6fc
    f5c8:	0000f6fc 	.word	0x0000f6fc
    f5cc:	0000f6fc 	.word	0x0000f6fc
    f5d0:	0000f6fc 	.word	0x0000f6fc
    f5d4:	0000f6fc 	.word	0x0000f6fc
    f5d8:	0000fc08 	.word	0x0000fc08
    f5dc:	0000fc08 	.word	0x0000fc08
    f5e0:	0000fc08 	.word	0x0000fc08
    f5e4:	0000fc08 	.word	0x0000fc08
    f5e8:	0000fc08 	.word	0x0000fc08
    f5ec:	0000fc08 	.word	0x0000fc08
    f5f0:	0000fc08 	.word	0x0000fc08
    f5f4:	0000fc08 	.word	0x0000fc08
    f5f8:	0000fc08 	.word	0x0000fc08
    f5fc:	0000fc08 	.word	0x0000fc08
    f600:	0000fc08 	.word	0x0000fc08
    f604:	0000fc08 	.word	0x0000fc08
    f608:	0000fc08 	.word	0x0000fc08
    f60c:	0000fc08 	.word	0x0000fc08
    f610:	0000fc08 	.word	0x0000fc08
    f614:	0000fc08 	.word	0x0000fc08
    f618:	0000fc08 	.word	0x0000fc08
    f61c:	0000fc08 	.word	0x0000fc08
    f620:	0000fc08 	.word	0x0000fc08
    f624:	0000fc08 	.word	0x0000fc08
    f628:	0000fc08 	.word	0x0000fc08
    f62c:	0000fc08 	.word	0x0000fc08
    f630:	0000fc08 	.word	0x0000fc08
    f634:	0000fc08 	.word	0x0000fc08
    f638:	0000fc08 	.word	0x0000fc08
    f63c:	0000fc08 	.word	0x0000fc08
    f640:	0000fc08 	.word	0x0000fc08
    f644:	0000fc08 	.word	0x0000fc08
    f648:	0000fc08 	.word	0x0000fc08
    f64c:	0000fc08 	.word	0x0000fc08
    f650:	0000fc08 	.word	0x0000fc08
    f654:	0000fc08 	.word	0x0000fc08
    f658:	0000fc08 	.word	0x0000fc08
    f65c:	0000fc08 	.word	0x0000fc08
    f660:	0000fc08 	.word	0x0000fc08
    f664:	0000fc08 	.word	0x0000fc08
    f668:	0000fc08 	.word	0x0000fc08
    f66c:	0000fc08 	.word	0x0000fc08
    f670:	0000fc08 	.word	0x0000fc08
    f674:	0000fc08 	.word	0x0000fc08
    f678:	0000fc08 	.word	0x0000fc08
    f67c:	0000fa58 	.word	0x0000fa58
    f680:	0000fadc 	.word	0x0000fadc
    f684:	0000fc08 	.word	0x0000fc08
    f688:	0000fc08 	.word	0x0000fc08
    f68c:	0000fc08 	.word	0x0000fc08
    f690:	0000fab0 	.word	0x0000fab0
    f694:	0000fc08 	.word	0x0000fc08
    f698:	0000fc08 	.word	0x0000fc08
    f69c:	0000fc08 	.word	0x0000fc08
    f6a0:	0000fbdc 	.word	0x0000fbdc
    f6a4:	0000fc08 	.word	0x0000fc08
    f6a8:	0000fc08 	.word	0x0000fc08
    f6ac:	0000fc08 	.word	0x0000fc08
    f6b0:	0000f9b0 	.word	0x0000f9b0
    f6b4:	0000fc08 	.word	0x0000fc08
    f6b8:	0000fc08 	.word	0x0000fc08
    f6bc:	0000f894 	.word	0x0000f894
    f6c0:	0000fc08 	.word	0x0000fc08
    f6c4:	0000f7e0 	.word	0x0000f7e0
    f6c8:	0000fc08 	.word	0x0000fc08
    f6cc:	0000fc08 	.word	0x0000fc08
    f6d0:	0000f9b0 	.word	0x0000f9b0
          break;
        }

      case ESCAPE :
        {
          switch (format[i])
    f6d4:	e353006e 	cmp	r3, #110	; 0x6e
    f6d8:	0a000036 	beq	f7b8 <dna_printf+0x29c>
    f6dc:	e3530074 	cmp	r3, #116	; 0x74
    f6e0:	1a000029 	bne	f78c <dna_printf+0x270>
                break;
              }

            case 't' :
              {
                buffer[j] = '\t';
    f6e4:	e28d2f52 	add	r2, sp, #328	; 0x148
    f6e8:	e3a0c009 	mov	ip, #9
    f6ec:	e0823009 	add	r3, r2, r9
                j += 2;
                break;
              }
          }

          state = NORMAL;
    f6f0:	e3a02000 	mov	r2, #0
                break;
              }

            case 't' :
              {
                buffer[j] = '\t';
    f6f4:	e543c100 	strb	ip, [r3, #-256]	; 0x100
                j += 1;
    f6f8:	e2899001 	add	r9, r9, #1
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f6fc:	e5f83001 	ldrb	r3, [r8, #1]!
    f700:	e3530000 	cmp	r3, #0
    f704:	1affff96 	bne	f564 <dna_printf+0x48>
    f708:	e59d0000 	ldr	r0, [sp]
          break;
        }
    }
  }

  buffer[j] = '\0';
    f70c:	e3a03000 	mov	r3, #0
    f710:	e28def52 	add	lr, sp, #328	; 0x148
    f714:	e08e9009 	add	r9, lr, r9
    f718:	e5493100 	strb	r3, [r9, #-256]	; 0x100
  platform_debug_puts (buffer);
    f71c:	eb001328 	bl	143c4 <platform_debug_puts>

  va_end (arg);
}
    f720:	e28ddf53 	add	sp, sp, #332	; 0x14c
    f724:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    f728:	e28dd010 	add	sp, sp, #16
    f72c:	e12fff1e 	bx	lr
  {
    switch (state)
    {
      case NORMAL :
        {
          switch (format[i])
    f730:	e3530025 	cmp	r3, #37	; 0x25
    f734:	0a00000b 	beq	f768 <dna_printf+0x24c>
    f738:	e353005c 	cmp	r3, #92	; 0x5c
          {
            case '\\' :
              {
                state = ESCAPE;
    f73c:	03a02001 	moveq	r2, #1
  {
    switch (state)
    {
      case NORMAL :
        {
          switch (format[i])
    f740:	0affffed 	beq	f6fc <dna_printf+0x1e0>
                state = FORMAT;
                break;
              }

            default :
              buffer[j] = format[i];
    f744:	e28def52 	add	lr, sp, #328	; 0x148
    f748:	e08e2009 	add	r2, lr, r9
    f74c:	e5423100 	strb	r3, [r2, #-256]	; 0x100
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f750:	e5f83001 	ldrb	r3, [r8, #1]!
                break;
              }

            default :
              buffer[j] = format[i];
              j += 1;
    f754:	e2899001 	add	r9, r9, #1
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f758:	e3530000 	cmp	r3, #0
              }

            default :
              buffer[j] = format[i];
              j += 1;
              break;
    f75c:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f760:	1affff7f 	bne	f564 <dna_printf+0x48>
    f764:	eaffffe7 	b	f708 <dna_printf+0x1ec>
                break;
              }

            case '%' :
              {
                is_char = false;
    f768:	e3a0b000 	mov	fp, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f76c:	e5f83001 	ldrb	r3, [r8, #1]!
              {
                is_char = false;
                is_short = false;
                is_long = false;
                is_long_long = false;
                state = FORMAT;
    f770:	e3a02002 	mov	r2, #2
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f774:	e3530000 	cmp	r3, #0
              }

            case '%' :
              {
                is_char = false;
                is_short = false;
    f778:	e58db00c 	str	fp, [sp, #12]
                is_long = false;
                is_long_long = false;
    f77c:	e58db004 	str	fp, [sp, #4]

            case '%' :
              {
                is_char = false;
                is_short = false;
                is_long = false;
    f780:	e58db008 	str	fp, [sp, #8]
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f784:	1affff76 	bne	f564 <dna_printf+0x48>
    f788:	eaffffde 	b	f708 <dna_printf+0x1ec>
                break;
              }

            default :
              {
                buffer[j] = '\\';
    f78c:	e3a0005c 	mov	r0, #92	; 0x5c
    f790:	e28def52 	add	lr, sp, #328	; 0x148
    f794:	e08e2009 	add	r2, lr, r9
                buffer[j + 1] = format[i];
    f798:	e54230ff 	strb	r3, [r2, #-255]	; 0xff
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f79c:	e5f83001 	ldrb	r3, [r8, #1]!
                break;
              }

            default :
              {
                buffer[j] = '\\';
    f7a0:	e5420100 	strb	r0, [r2, #-256]	; 0x100
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f7a4:	e3530000 	cmp	r3, #0

            default :
              {
                buffer[j] = '\\';
                buffer[j + 1] = format[i];
                j += 2;
    f7a8:	e2899002 	add	r9, r9, #2
                break;
              }
          }

          state = NORMAL;
    f7ac:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f7b0:	1affff6b 	bne	f564 <dna_printf+0x48>
    f7b4:	eaffffd3 	b	f708 <dna_printf+0x1ec>
        {
          switch (format[i])
          {
            case 'n' :
              {
                buffer[j] = '\n';
    f7b8:	e3a0100a 	mov	r1, #10
    f7bc:	e28d0f52 	add	r0, sp, #328	; 0x148
    f7c0:	e0803009 	add	r3, r0, r9
    f7c4:	e5431100 	strb	r1, [r3, #-256]	; 0x100
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f7c8:	e5f83001 	ldrb	r3, [r8, #1]!
          switch (format[i])
          {
            case 'n' :
              {
                buffer[j] = '\n';
                j += 1;
    f7cc:	e2899001 	add	r9, r9, #1
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f7d0:	e3530000 	cmp	r3, #0
                j += 2;
                break;
              }
          }

          state = NORMAL;
    f7d4:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f7d8:	1affff61 	bne	f564 <dna_printf+0x48>
    f7dc:	eaffffc9 	b	f708 <dna_printf+0x1ec>

                /*
                 * Check the data size
                 */

                if (is_long_long)
    f7e0:	e59dc004 	ldr	ip, [sp, #4]
    f7e4:	e35c0000 	cmp	ip, #0
    f7e8:	0a00010b 	beq	fc1c <dna_printf+0x700>
                {
                  unsigned_value = va_arg (arg, unsigned long long int);
    f7ec:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    f7f0:	e2833007 	add	r3, r3, #7
    f7f4:	e3c33007 	bic	r3, r3, #7
    f7f8:	e2832008 	add	r2, r3, #8
    f7fc:	e58d2024 	str	r2, [sp, #36]	; 0x24
    f800:	e1c340d0 	ldrd	r4, [r3]
 *
 * SOURCE
 */

{
  bool is_long = false, is_long_long = false;
    f804:	e3a06000 	mov	r6, #0
    f808:	ea000000 	b	f810 <dna_printf+0x2f4>
                do
                {
                  remainder = unsigned_value % 10;
                  unsigned_value = unsigned_value / 10;
                  ascii[ascii_index] = remainder + '0';
                  ascii_index += 1;
    f80c:	e1a06003 	mov	r6, r3
                 * Compute the data
                 */

                do
                {
                  remainder = unsigned_value % 10;
    f810:	e1a00004 	mov	r0, r4
    f814:	e1a01005 	mov	r1, r5
    f818:	e3a0200a 	mov	r2, #10
    f81c:	e3a03000 	mov	r3, #0
    f820:	eb001656 	bl	15180 <__aeabi_uldivmod>
                  unsigned_value = unsigned_value / 10;
    f824:	e1a00004 	mov	r0, r4
                 * Compute the data
                 */

                do
                {
                  remainder = unsigned_value % 10;
    f828:	e1a07002 	mov	r7, r2
                  unsigned_value = unsigned_value / 10;
    f82c:	e1a01005 	mov	r1, r5
    f830:	e3a03000 	mov	r3, #0
    f834:	e3a0200a 	mov	r2, #10
    f838:	eb001650 	bl	15180 <__aeabi_uldivmod>
    f83c:	e1a04000 	mov	r4, r0
    f840:	e1a05001 	mov	r5, r1
                  ascii[ascii_index] = remainder + '0';
    f844:	e2877030 	add	r7, r7, #48	; 0x30
                  ascii_index += 1;
                }
                while (unsigned_value > 0);
    f848:	e194e005 	orrs	lr, r4, r5

                do
                {
                  remainder = unsigned_value % 10;
                  unsigned_value = unsigned_value / 10;
                  ascii[ascii_index] = remainder + '0';
    f84c:	e7ca7006 	strb	r7, [sl, r6]
                  ascii_index += 1;
    f850:	e2863001 	add	r3, r6, #1
                }
                while (unsigned_value > 0);
    f854:	1affffec 	bne	f80c <dna_printf+0x2f0>
    f858:	e59dc000 	ldr	ip, [sp]
    f85c:	e2492001 	sub	r2, r9, #1
    f860:	e08a3003 	add	r3, sl, r3
    f864:	e08c2002 	add	r2, ip, r2
                 * Echo the data into the buffer
                 */

                for (int32_t i = ascii_index - 1; i >= 0; i--)
                {
                  buffer[j] = ascii[i];
    f868:	e5731001 	ldrb	r1, [r3, #-1]!

                /*
                 * Echo the data into the buffer
                 */

                for (int32_t i = ascii_index - 1; i >= 0; i--)
    f86c:	e153000a 	cmp	r3, sl
                {
                  buffer[j] = ascii[i];
    f870:	e5e21001 	strb	r1, [r2, #1]!

                /*
                 * Echo the data into the buffer
                 */

                for (int32_t i = ascii_index - 1; i >= 0; i--)
    f874:	1afffffb 	bne	f868 <dna_printf+0x34c>
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f878:	e5f83001 	ldrb	r3, [r8, #1]!
    f87c:	e2899001 	add	r9, r9, #1
    f880:	e3530000 	cmp	r3, #0
    f884:	e0899006 	add	r9, r9, r6

                /*
                 * Return to NORMAL state
                 */

                state = NORMAL;
    f888:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f88c:	1affff34 	bne	f564 <dna_printf+0x48>
    f890:	eaffff9c 	b	f708 <dna_printf+0x1ec>
                break;
              }

            case 's' :
              {
                string_value = va_arg (arg, char *);
    f894:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    f898:	e5934000 	ldr	r4, [r3]
    f89c:	e2833004 	add	r3, r3, #4
                string_length = dna_strlen (string_value);
    f8a0:	e1a00004 	mov	r0, r4
                break;
              }

            case 's' :
              {
                string_value = va_arg (arg, char *);
    f8a4:	e58d3024 	str	r3, [sp, #36]	; 0x24
                string_length = dna_strlen (string_value);
    f8a8:	eb0001bd 	bl	ffa4 <dna_strlen>

                for (int32_t i = 0; i < string_length; i ++)
    f8ac:	e3500000 	cmp	r0, #0
    f8b0:	da0000d4 	ble	fc08 <dna_printf+0x6ec>
    f8b4:	e59dc000 	ldr	ip, [sp]
    f8b8:	e59de000 	ldr	lr, [sp]
    f8bc:	e08c1009 	add	r1, ip, r9
    f8c0:	e1813004 	orr	r3, r1, r4
    f8c4:	e289c004 	add	ip, r9, #4
    f8c8:	e3130003 	tst	r3, #3
    f8cc:	e2842004 	add	r2, r4, #4
    f8d0:	e08ec00c 	add	ip, lr, ip
    f8d4:	03a03001 	moveq	r3, #1
    f8d8:	13a03000 	movne	r3, #0
    f8dc:	e1510002 	cmp	r1, r2
    f8e0:	3154000c 	cmpcc	r4, ip
    f8e4:	23a02001 	movcs	r2, #1
    f8e8:	33a02000 	movcc	r2, #0
    f8ec:	e0033002 	and	r3, r3, r2
    f8f0:	e3500009 	cmp	r0, #9
    f8f4:	93a03000 	movls	r3, #0
    f8f8:	82033001 	andhi	r3, r3, #1
    f8fc:	e3530000 	cmp	r3, #0
    f900:	0a000024 	beq	f998 <dna_printf+0x47c>
    f904:	e3a03000 	mov	r3, #0
    f908:	e1a02003 	mov	r2, r3
    f90c:	e1a0e120 	lsr	lr, r0, #2
    f910:	e1a0510e 	lsl	r5, lr, #2
                {
                  buffer[j] = string_value[i];
    f914:	e794c003 	ldr	ip, [r4, r3]
    f918:	e2822001 	add	r2, r2, #1
    f91c:	e15e0002 	cmp	lr, r2
    f920:	e781c003 	str	ip, [r1, r3]
    f924:	e2833004 	add	r3, r3, #4
    f928:	8afffff9 	bhi	f914 <dna_printf+0x3f8>
    f92c:	e1500005 	cmp	r0, r5
    f930:	e0893005 	add	r3, r9, r5
    f934:	0a000011 	beq	f980 <dna_printf+0x464>
    f938:	e7d4c10e 	ldrb	ip, [r4, lr, lsl #2]
            case 's' :
              {
                string_value = va_arg (arg, char *);
                string_length = dna_strlen (string_value);

                for (int32_t i = 0; i < string_length; i ++)
    f93c:	e2852001 	add	r2, r5, #1
                {
                  buffer[j] = string_value[i];
    f940:	e28def52 	add	lr, sp, #328	; 0x148
    f944:	e08e1003 	add	r1, lr, r3
            case 's' :
              {
                string_value = va_arg (arg, char *);
                string_length = dna_strlen (string_value);

                for (int32_t i = 0; i < string_length; i ++)
    f948:	e1500002 	cmp	r0, r2
                {
                  buffer[j] = string_value[i];
    f94c:	e541c100 	strb	ip, [r1, #-256]	; 0x100
                  j += 1;
    f950:	e2831001 	add	r1, r3, #1
            case 's' :
              {
                string_value = va_arg (arg, char *);
                string_length = dna_strlen (string_value);

                for (int32_t i = 0; i < string_length; i ++)
    f954:	da000009 	ble	f980 <dna_printf+0x464>
                {
                  buffer[j] = string_value[i];
    f958:	e7d42002 	ldrb	r2, [r4, r2]
            case 's' :
              {
                string_value = va_arg (arg, char *);
                string_length = dna_strlen (string_value);

                for (int32_t i = 0; i < string_length; i ++)
    f95c:	e2855002 	add	r5, r5, #2
                {
                  buffer[j] = string_value[i];
    f960:	e08e1001 	add	r1, lr, r1
            case 's' :
              {
                string_value = va_arg (arg, char *);
                string_length = dna_strlen (string_value);

                for (int32_t i = 0; i < string_length; i ++)
    f964:	e1550000 	cmp	r5, r0
                {
                  buffer[j] = string_value[i];
    f968:	e5412100 	strb	r2, [r1, #-256]	; 0x100
                  j += 1;
    f96c:	e2833002 	add	r3, r3, #2
                string_value = va_arg (arg, char *);
                string_length = dna_strlen (string_value);

                for (int32_t i = 0; i < string_length; i ++)
                {
                  buffer[j] = string_value[i];
    f970:	b7d42005 	ldrblt	r2, [r4, r5]
    f974:	b28d1f52 	addlt	r1, sp, #328	; 0x148
    f978:	b0813003 	addlt	r3, r1, r3
    f97c:	b5432100 	strblt	r2, [r3, #-256]	; 0x100
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f980:	e5f83001 	ldrb	r3, [r8, #1]!
    f984:	e0809009 	add	r9, r0, r9
    f988:	e3530000 	cmp	r3, #0
                {
                  buffer[j] = string_value[i];
                  j += 1;
                }

                state = NORMAL;
    f98c:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    f990:	1afffef3 	bne	f564 <dna_printf+0x48>
    f994:	eaffff5b 	b	f708 <dna_printf+0x1ec>
                string_value = va_arg (arg, char *);
                string_length = dna_strlen (string_value);

                for (int32_t i = 0; i < string_length; i ++)
                {
                  buffer[j] = string_value[i];
    f998:	e7d42003 	ldrb	r2, [r4, r3]
    f99c:	e7c12003 	strb	r2, [r1, r3]
            case 's' :
              {
                string_value = va_arg (arg, char *);
                string_length = dna_strlen (string_value);

                for (int32_t i = 0; i < string_length; i ++)
    f9a0:	e2833001 	add	r3, r3, #1
    f9a4:	e1500003 	cmp	r0, r3
    f9a8:	1afffffa 	bne	f998 <dna_printf+0x47c>
    f9ac:	eafffff3 	b	f980 <dna_printf+0x464>

                /*
                 * Check the data size
                 */

                if (is_long_long)
    f9b0:	e59dc004 	ldr	ip, [sp, #4]
    f9b4:	e35c0000 	cmp	ip, #0
    f9b8:	0a0000a5 	beq	fc54 <dna_printf+0x738>
                {
                  unsigned_value = va_arg (arg, unsigned long long int);
    f9bc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    f9c0:	e2833007 	add	r3, r3, #7
    f9c4:	e3c33007 	bic	r3, r3, #7
    f9c8:	e2832008 	add	r2, r3, #8
    f9cc:	e58d2024 	str	r2, [sp, #36]	; 0x24
    f9d0:	e1c320d0 	ldrd	r2, [r3]
                do
                {
                  remainder = unsigned_value % 10;
                  unsigned_value = unsigned_value / 10;
                  ascii[ascii_index] = remainder + '0';
                  ascii_index += 1;
    f9d4:	e3a0e000 	mov	lr, #0
                 * Compute the data
                 */

                do
                {
                  remainder = unsigned_value & 0xf;
    f9d8:	e3a01000 	mov	r1, #0
                  unsigned_value >>= 4;
    f9dc:	e1a0c222 	lsr	ip, r2, #4
    f9e0:	e3510000 	cmp	r1, #0
                 * Compute the data
                 */

                do
                {
                  remainder = unsigned_value & 0xf;
    f9e4:	e202000f 	and	r0, r2, #15
                  unsigned_value >>= 4;
    f9e8:	e18cce03 	orr	ip, ip, r3, lsl #28
    f9ec:	e1a04223 	lsr	r4, r3, #4
    f9f0:	03500009 	cmpeq	r0, #9
    f9f4:	e1a0200c 	mov	r2, ip

                  if (remainder < 10)
                  {
                    ascii[ascii_index] = remainder + '0'; 
    f9f8:	e6ef0070 	uxtb	r0, r0
                 */

                do
                {
                  remainder = unsigned_value & 0xf;
                  unsigned_value >>= 4;
    f9fc:	e1a03004 	mov	r3, r4
    fa00:	e1a0100e 	mov	r1, lr
    fa04:	92800030 	addls	r0, r0, #48	; 0x30
    fa08:	82800057 	addhi	r0, r0, #87	; 0x57
                  {
                    ascii[ascii_index] = remainder - 10 + 'a';
                    ascii_index += 1;
                  }
                }
                while (unsigned_value > 0);
    fa0c:	e192e003 	orrs	lr, r2, r3
    fa10:	e7ca0001 	strb	r0, [sl, r1]
    fa14:	e281e001 	add	lr, r1, #1
    fa18:	1affffee 	bne	f9d8 <dna_printf+0x4bc>
    fa1c:	e59dc000 	ldr	ip, [sp]
    fa20:	e2493001 	sub	r3, r9, #1
    fa24:	e08ae00e 	add	lr, sl, lr
    fa28:	e08c3003 	add	r3, ip, r3
                 * Echo the data into the buffer
                 */

                for(int32_t i = ascii_index - 1; i >= 0; i--)
                {
                  buffer[j] = ascii[i];
    fa2c:	e57e2001 	ldrb	r2, [lr, #-1]!

                /*
                 * Echo the data into the buffer
                 */

                for(int32_t i = ascii_index - 1; i >= 0; i--)
    fa30:	e15e000a 	cmp	lr, sl
                {
                  buffer[j] = ascii[i];
    fa34:	e5e32001 	strb	r2, [r3, #1]!

                /*
                 * Echo the data into the buffer
                 */

                for(int32_t i = ascii_index - 1; i >= 0; i--)
    fa38:	1afffffb 	bne	fa2c <dna_printf+0x510>
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    fa3c:	e5f83001 	ldrb	r3, [r8, #1]!
    fa40:	e2899001 	add	r9, r9, #1
    fa44:	e3530000 	cmp	r3, #0
    fa48:	e0899001 	add	r9, r9, r1

                /*
                 * Return to NORMAL state
                 */

                state = NORMAL;
    fa4c:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    fa50:	1afffec3 	bne	f564 <dna_printf+0x48>
    fa54:	eaffff2b 	b	f708 <dna_printf+0x1ec>
                break;
              }

            case 'c' :
              {
                unsigned_value = va_arg (arg, unsigned long int);
    fa58:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
                char_value = unsigned_value;
                buffer[j] = char_value;
    fa5c:	e28def52 	add	lr, sp, #328	; 0x148
              }

            case 'c' :
              {
                unsigned_value = va_arg (arg, unsigned long int);
                char_value = unsigned_value;
    fa60:	e5931000 	ldr	r1, [r3]
                break;
              }

            case 'c' :
              {
                unsigned_value = va_arg (arg, unsigned long int);
    fa64:	e2833004 	add	r3, r3, #4
    fa68:	e58d3024 	str	r3, [sp, #36]	; 0x24
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    fa6c:	e5f83001 	ldrb	r3, [r8, #1]!

            case 'c' :
              {
                unsigned_value = va_arg (arg, unsigned long int);
                char_value = unsigned_value;
                buffer[j] = char_value;
    fa70:	e08e2009 	add	r2, lr, r9
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    fa74:	e3530000 	cmp	r3, #0
              }

            case 'c' :
              {
                unsigned_value = va_arg (arg, unsigned long int);
                char_value = unsigned_value;
    fa78:	e5421100 	strb	r1, [r2, #-256]	; 0x100
                buffer[j] = char_value;
                j += 1;
    fa7c:	e2899001 	add	r9, r9, #1
                state = NORMAL;
    fa80:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    fa84:	1afffeb6 	bne	f564 <dna_printf+0x48>
    fa88:	eaffff1e 	b	f708 <dna_printf+0x1ec>

                state = NORMAL;
                break;
              }
            case '%':
                buffer[j] = '%';
    fa8c:	e3a01025 	mov	r1, #37	; 0x25
    fa90:	e28d0f52 	add	r0, sp, #328	; 0x148
    fa94:	e0803009 	add	r3, r0, r9
    fa98:	e5431100 	strb	r1, [r3, #-256]	; 0x100
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    fa9c:	e5f83001 	ldrb	r3, [r8, #1]!
                state = NORMAL;
                break;
              }
            case '%':
                buffer[j] = '%';
                j += 1;
    faa0:	e2899001 	add	r9, r9, #1
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    faa4:	e3530000 	cmp	r3, #0
    faa8:	1afffead 	bne	f564 <dna_printf+0x48>
    faac:	eaffff15 	b	f708 <dna_printf+0x1ec>
        {
          switch (format[i])
          {
            case 'h' :
              {
                if (! is_short)
    fab0:	e59dc00c 	ldr	ip, [sp, #12]
    fab4:	e35c0000 	cmp	ip, #0
                {
                  is_short = true;
    fab8:	03a0c001 	moveq	ip, #1
    fabc:	058dc00c 	streq	ip, [sp, #12]
        {
          switch (format[i])
          {
            case 'h' :
              {
                if (! is_short)
    fac0:	0affff0d 	beq	f6fc <dna_printf+0x1e0>
                {
                  is_short = true;
                }
				else if (! is_char)
    fac4:	e35b0000 	cmp	fp, #0
    fac8:	1a00004e 	bne	fc08 <dna_printf+0x6ec>
                {
                  is_short = false;
    facc:	e3a0c000 	mov	ip, #0
                  is_char = true;
    fad0:	e3a0b001 	mov	fp, #1
                {
                  is_short = true;
                }
				else if (! is_char)
                {
                  is_short = false;
    fad4:	e58dc00c 	str	ip, [sp, #12]
    fad8:	eaffff07 	b	f6fc <dna_printf+0x1e0>

                /*
                 * Check the data size
                 */

                if (is_long_long)
    fadc:	e59dc004 	ldr	ip, [sp, #4]
    fae0:	e35c0000 	cmp	ip, #0
    fae4:	0a000068 	beq	fc8c <dna_printf+0x770>
                {
                  signed_value = va_arg (arg, long long int);
    fae8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    faec:	e2833007 	add	r3, r3, #7
    faf0:	e3c33007 	bic	r3, r3, #7
    faf4:	e2832008 	add	r2, r3, #8
    faf8:	e1c300d0 	ldrd	r0, [r3]
    fafc:	e58d2024 	str	r2, [sp, #36]	; 0x24
    fb00:	e1a03001 	mov	r3, r1
    fb04:	e1a02000 	mov	r2, r0
    fb08:	e1cd01f0 	strd	r0, [sp, #16]
 *
 * SOURCE
 */

{
  bool is_long = false, is_long_long = false;
    fb0c:	e3a06000 	mov	r6, #0
                 * Check the data sign
                 */

                if (signed_value < 0)
                {
                  unsigned_value = -1 * signed_value;
    fb10:	e59d1014 	ldr	r1, [sp, #20]
    fb14:	e1a01fc1 	asr	r1, r1, #31
    fb18:	e58d1018 	str	r1, [sp, #24]
    fb1c:	e58d101c 	str	r1, [sp, #28]
    fb20:	e1cd41d8 	ldrd	r4, [sp, #24]
    fb24:	e0244002 	eor	r4, r4, r2
    fb28:	e1cd01d8 	ldrd	r0, [sp, #24]
    fb2c:	e0255003 	eor	r5, r5, r3
    fb30:	e0544000 	subs	r4, r4, r0
    fb34:	e0c55001 	sbc	r5, r5, r1
                 * Compute the data
                 */

                do
                {
                  remainder = unsigned_value % 10;
    fb38:	e1a00004 	mov	r0, r4
    fb3c:	e1a01005 	mov	r1, r5
    fb40:	e3a0200a 	mov	r2, #10
    fb44:	e3a03000 	mov	r3, #0
    fb48:	eb00158c 	bl	15180 <__aeabi_uldivmod>
                  unsigned_value = unsigned_value / 10;
    fb4c:	e1a00004 	mov	r0, r4
                 * Compute the data
                 */

                do
                {
                  remainder = unsigned_value % 10;
    fb50:	e1a07002 	mov	r7, r2
                  unsigned_value = unsigned_value / 10;
    fb54:	e1a01005 	mov	r1, r5
    fb58:	e3a0200a 	mov	r2, #10
    fb5c:	e3a03000 	mov	r3, #0
    fb60:	eb001586 	bl	15180 <__aeabi_uldivmod>
    fb64:	e1a04000 	mov	r4, r0
    fb68:	e1a05001 	mov	r5, r1
                  ascii[ascii_index] = remainder + '0';
    fb6c:	e2877030 	add	r7, r7, #48	; 0x30
                  ascii_index += 1;
                }
                while (unsigned_value > 0);
    fb70:	e1941005 	orrs	r1, r4, r5

                do
                {
                  remainder = unsigned_value % 10;
                  unsigned_value = unsigned_value / 10;
                  ascii[ascii_index] = remainder + '0';
    fb74:	e7ca7006 	strb	r7, [sl, r6]
                  ascii_index += 1;
    fb78:	e2866001 	add	r6, r6, #1
                }
                while (unsigned_value > 0);
    fb7c:	1affffed 	bne	fb38 <dna_printf+0x61c>

                /*
                 * Adjust the sign
                 */

                if (signed_value < 0)
    fb80:	e1cd21d0 	ldrd	r2, [sp, #16]
    fb84:	e3520000 	cmp	r2, #0
    fb88:	e2d33000 	sbcs	r3, r3, #0
                {
                  ascii[ascii_index ++] = '-';
    fb8c:	b3a0202d 	movlt	r2, #45	; 0x2d
                do
                {
                  remainder = unsigned_value % 10;
                  unsigned_value = unsigned_value / 10;
                  ascii[ascii_index] = remainder + '0';
                  ascii_index += 1;
    fb90:	e1a03006 	mov	r3, r6
                 * Adjust the sign
                 */

                if (signed_value < 0)
                {
                  ascii[ascii_index ++] = '-';
    fb94:	b28dcf52 	addlt	ip, sp, #328	; 0x148
    fb98:	b08c3006 	addlt	r3, ip, r6
    fb9c:	e59dc000 	ldr	ip, [sp]
    fba0:	b5432120 	strblt	r2, [r3, #-288]	; 0x120
    fba4:	b2866001 	addlt	r6, r6, #1
    fba8:	e2492001 	sub	r2, r9, #1
    fbac:	e08c2002 	add	r2, ip, r2
    fbb0:	e08a3006 	add	r3, sl, r6
                 * Echo the data into the buffer
                 */

                for (int32_t i = ascii_index - 1; i >= 0; i--)
                {
                  buffer[j] = ascii[i];
    fbb4:	e5731001 	ldrb	r1, [r3, #-1]!

                /*
                 * Echo the data into the buffer
                 */

                for (int32_t i = ascii_index - 1; i >= 0; i--)
    fbb8:	e153000a 	cmp	r3, sl
                {
                  buffer[j] = ascii[i];
    fbbc:	e5e21001 	strb	r1, [r2, #1]!

                /*
                 * Echo the data into the buffer
                 */

                for (int32_t i = ascii_index - 1; i >= 0; i--)
    fbc0:	1afffffb 	bne	fbb4 <dna_printf+0x698>
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    fbc4:	e5f83001 	ldrb	r3, [r8, #1]!
    fbc8:	e0899006 	add	r9, r9, r6
    fbcc:	e3530000 	cmp	r3, #0

                /*
                 * Return to NORMAL state
                 */

                state = NORMAL;
    fbd0:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    fbd4:	1afffe62 	bne	f564 <dna_printf+0x48>
    fbd8:	eafffeca 	b	f708 <dna_printf+0x1ec>

                break;
              }
            case 'l' :
              {
                if (! is_long)
    fbdc:	e59dc008 	ldr	ip, [sp, #8]
    fbe0:	e35c0000 	cmp	ip, #0
                {
                  is_long = true;
    fbe4:	03a0c001 	moveq	ip, #1
    fbe8:	058dc008 	streq	ip, [sp, #8]

                break;
              }
            case 'l' :
              {
                if (! is_long)
    fbec:	0afffec2 	beq	f6fc <dna_printf+0x1e0>
                {
                  is_long = true;
                }
                else if (! is_long_long)
    fbf0:	e59dc004 	ldr	ip, [sp, #4]
    fbf4:	e35c0000 	cmp	ip, #0
                {
                  is_long = false;
    fbf8:	03a03001 	moveq	r3, #1
    fbfc:	03a0c000 	moveq	ip, #0
    fc00:	098d1008 	stmibeq	sp, {r3, ip}
    fc04:	0afffebc 	beq	f6fc <dna_printf+0x1e0>
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    fc08:	e5f83001 	ldrb	r3, [r8, #1]!
                {
                  buffer[j] = string_value[i];
                  j += 1;
                }

                state = NORMAL;
    fc0c:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    fc10:	e3530000 	cmp	r3, #0
    fc14:	1afffe52 	bne	f564 <dna_printf+0x48>
    fc18:	eafffeba 	b	f708 <dna_printf+0x1ec>

                if (is_long_long)
                {
                  unsigned_value = va_arg (arg, unsigned long long int);
                }
                else if (is_long)
    fc1c:	e59dc008 	ldr	ip, [sp, #8]
    fc20:	e35c0000 	cmp	ip, #0
    fc24:	1a000034 	bne	fcfc <dna_printf+0x7e0>
                {
                  unsigned_value = va_arg (arg, unsigned long int);
                }
                else if (is_char)
    fc28:	e35b0000 	cmp	fp, #0
    fc2c:	1a000050 	bne	fd74 <dna_printf+0x858>
                {
					 unsigned_value = (unsigned char)va_arg (arg, unsigned int);
                }
                else if (is_short)
    fc30:	e59dc00c 	ldr	ip, [sp, #12]
    fc34:	e35c0000 	cmp	ip, #0
    fc38:	0a00002f 	beq	fcfc <dna_printf+0x7e0>
                {
					 unsigned_value = (unsigned short)va_arg (arg, unsigned int);
    fc3c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    fc40:	e3a05000 	mov	r5, #0
    fc44:	e1d340b0 	ldrh	r4, [r3]
    fc48:	e2833004 	add	r3, r3, #4
    fc4c:	e58d3024 	str	r3, [sp, #36]	; 0x24
    fc50:	eafffeeb 	b	f804 <dna_printf+0x2e8>

                if (is_long_long)
                {
                  unsigned_value = va_arg (arg, unsigned long long int);
                }
                else if (is_long)
    fc54:	e59dc008 	ldr	ip, [sp, #8]
    fc58:	e35c0000 	cmp	ip, #0
    fc5c:	1a000020 	bne	fce4 <dna_printf+0x7c8>
                {
                  unsigned_value = va_arg (arg, unsigned long int);
                }
                else if (is_char)
    fc60:	e35b0000 	cmp	fp, #0
    fc64:	1a00003c 	bne	fd5c <dna_printf+0x840>
                {
					 unsigned_value = (unsigned char)va_arg (arg, unsigned int);
                }
                else if (is_short)
    fc68:	e59dc00c 	ldr	ip, [sp, #12]
    fc6c:	e35c0000 	cmp	ip, #0
    fc70:	0a00001b 	beq	fce4 <dna_printf+0x7c8>
                {
					 unsigned_value = (unsigned short)va_arg (arg, unsigned int);
    fc74:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
    fc78:	e3a03000 	mov	r3, #0
    fc7c:	e1d120b0 	ldrh	r2, [r1]
    fc80:	e2811004 	add	r1, r1, #4
    fc84:	e58d1024 	str	r1, [sp, #36]	; 0x24
    fc88:	eaffff51 	b	f9d4 <dna_printf+0x4b8>

                if (is_long_long)
                {
                  signed_value = va_arg (arg, long long int);
                }
                else if (is_long)
    fc8c:	e59dc008 	ldr	ip, [sp, #8]
    fc90:	e35c0000 	cmp	ip, #0
    fc94:	1a00001e 	bne	fd14 <dna_printf+0x7f8>
                {
                  signed_value = va_arg (arg, long int);
                }
                else if (is_char)
    fc98:	e35b0000 	cmp	fp, #0
    fc9c:	1a000025 	bne	fd38 <dna_printf+0x81c>
                {
					 signed_value = (signed char)va_arg (arg, int);
                }
                else if (is_short)
    fca0:	e59dc00c 	ldr	ip, [sp, #12]
    fca4:	e35c0000 	cmp	ip, #0
    fca8:	0a000019 	beq	fd14 <dna_printf+0x7f8>
                {
					 signed_value = (short)va_arg (arg, int);
    fcac:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    fcb0:	e1d300f0 	ldrsh	r0, [r3]
    fcb4:	e2833004 	add	r3, r3, #4
    fcb8:	e1a01fc0 	asr	r1, r0, #31
    fcbc:	e58d3024 	str	r3, [sp, #36]	; 0x24
    fcc0:	e1cd01f0 	strd	r0, [sp, #16]
    fcc4:	e1a02000 	mov	r2, r0
    fcc8:	e1a03001 	mov	r3, r1
    fccc:	eaffff8e 	b	fb0c <dna_printf+0x5f0>
    fcd0:	e28dc048 	add	ip, sp, #72	; 0x48

{
  bool is_long = false, is_long_long = false;
  bool is_short = false, is_char = false;
  char char_value, ascii[32], * string_value, buffer[256];
  int32_t ascii_index, string_length, j = 0;
    fcd4:	e1a09003 	mov	r9, r3
    fcd8:	e58dc000 	str	ip, [sp]
    fcdc:	e1a0000c 	mov	r0, ip
    fce0:	eafffe89 	b	f70c <dna_printf+0x1f0>
                {
                  unsigned_value = va_arg (arg, unsigned long long int);
                }
                else if (is_long)
                {
                  unsigned_value = va_arg (arg, unsigned long int);
    fce4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    fce8:	e5932000 	ldr	r2, [r3]
    fcec:	e2833004 	add	r3, r3, #4
    fcf0:	e58d3024 	str	r3, [sp, #36]	; 0x24
    fcf4:	e3a03000 	mov	r3, #0
    fcf8:	eaffff35 	b	f9d4 <dna_printf+0x4b8>
                {
                  unsigned_value = va_arg (arg, unsigned long long int);
                }
                else if (is_long)
                {
                  unsigned_value = va_arg (arg, unsigned long int);
    fcfc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    fd00:	e3a05000 	mov	r5, #0
    fd04:	e5934000 	ldr	r4, [r3]
    fd08:	e2833004 	add	r3, r3, #4
    fd0c:	e58d3024 	str	r3, [sp, #36]	; 0x24
    fd10:	eafffebb 	b	f804 <dna_printf+0x2e8>
                {
                  signed_value = va_arg (arg, long long int);
                }
                else if (is_long)
                {
                  signed_value = va_arg (arg, long int);
    fd14:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    fd18:	e5932000 	ldr	r2, [r3]
    fd1c:	e2833004 	add	r3, r3, #4
    fd20:	e1a00002 	mov	r0, r2
    fd24:	e1a01fc2 	asr	r1, r2, #31
    fd28:	e58d3024 	str	r3, [sp, #36]	; 0x24
    fd2c:	e1cd01f0 	strd	r0, [sp, #16]
    fd30:	e1a03001 	mov	r3, r1
    fd34:	eaffff74 	b	fb0c <dna_printf+0x5f0>
                }
                else if (is_char)
                {
					 signed_value = (signed char)va_arg (arg, int);
    fd38:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    fd3c:	e1d300d0 	ldrsb	r0, [r3]
    fd40:	e2832004 	add	r2, r3, #4
    fd44:	e1a01fc0 	asr	r1, r0, #31
    fd48:	e58d2024 	str	r2, [sp, #36]	; 0x24
    fd4c:	e1cd01f0 	strd	r0, [sp, #16]
    fd50:	e1a02000 	mov	r2, r0
    fd54:	e1a03001 	mov	r3, r1
    fd58:	eaffff6b 	b	fb0c <dna_printf+0x5f0>
                {
                  unsigned_value = va_arg (arg, unsigned long int);
                }
                else if (is_char)
                {
					 unsigned_value = (unsigned char)va_arg (arg, unsigned int);
    fd5c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    fd60:	e2832004 	add	r2, r3, #4
    fd64:	e58d2024 	str	r2, [sp, #36]	; 0x24
    fd68:	e5d32000 	ldrb	r2, [r3]
    fd6c:	e3a03000 	mov	r3, #0
    fd70:	eaffff17 	b	f9d4 <dna_printf+0x4b8>
                {
                  unsigned_value = va_arg (arg, unsigned long int);
                }
                else if (is_char)
                {
					 unsigned_value = (unsigned char)va_arg (arg, unsigned int);
    fd74:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    fd78:	e3a05000 	mov	r5, #0
    fd7c:	e2832004 	add	r2, r3, #4
    fd80:	e58d2024 	str	r2, [sp, #36]	; 0x24
    fd84:	e5d34000 	ldrb	r4, [r3]
    fd88:	eafffe9d 	b	f804 <dna_printf+0x2e8>

0000fd8c <extension_get>:

/*
 * SOURCE
 */

{
    fd8c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  watch (status_t)
  {
    for (int32_t i = 0; i < OS_N_EXTENSIONS; i++)
    fd90:	e59f606c 	ldr	r6, [pc, #108]	; fe04 <extension_get+0x78>
    fd94:	e5963000 	ldr	r3, [r6]
    fd98:	e3530000 	cmp	r3, #0
    fd9c:	da000016 	ble	fdfc <extension_get+0x70>
    fda0:	e1a07000 	mov	r7, r0
    fda4:	e1a08001 	mov	r8, r1
    fda8:	e3a04000 	mov	r4, #0
    fdac:	e59f5054 	ldr	r5, [pc, #84]	; fe08 <extension_get+0x7c>
    fdb0:	ea000003 	b	fdc4 <extension_get+0x38>
    fdb4:	e5963000 	ldr	r3, [r6]
    fdb8:	e2844001 	add	r4, r4, #1
    fdbc:	e1530004 	cmp	r3, r4
    fdc0:	da00000d 	ble	fdfc <extension_get+0x70>
    {
      if (dna_strcmp (OS_EXTENSIONS_LIST[i] -> name, name) == 0)
    fdc4:	e5b53004 	ldr	r3, [r5, #4]!
    fdc8:	e1a01007 	mov	r1, r7
    fdcc:	e5930000 	ldr	r0, [r3]
    fdd0:	eb00003a 	bl	fec0 <dna_strcmp>
    fdd4:	e3500000 	cmp	r0, #0
    fdd8:	1afffff5 	bne	fdb4 <extension_get+0x28>
      {
        *p_ext = OS_EXTENSIONS_LIST[i];
    fddc:	e59f3028 	ldr	r3, [pc, #40]	; fe0c <extension_get+0x80>
    fde0:	e7933104 	ldr	r3, [r3, r4, lsl #2]
    fde4:	e5883000 	str	r3, [r8]
        ensure ((*p_ext) -> initialize != NULL, DNA_ERROR);
    fde8:	e5933008 	ldr	r3, [r3, #8]
    fdec:	e3530000 	cmp	r3, #0
    fdf0:	0a000001 	beq	fdfc <extension_get+0x70>
      }
    }

    return DNA_ERROR;
  }
}
    fdf4:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
      if (dna_strcmp (OS_EXTENSIONS_LIST[i] -> name, name) == 0)
      {
        *p_ext = OS_EXTENSIONS_LIST[i];
        ensure ((*p_ext) -> initialize != NULL, DNA_ERROR);

        return (*p_ext) -> initialize ();
    fdf8:	e12fff13 	bx	r3
      }
    }

    return DNA_ERROR;
  }
}
    fdfc:	e59f000c 	ldr	r0, [pc, #12]	; fe10 <extension_get+0x84>
    fe00:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    fe04:	0003e930 	.word	0x0003e930
    fe08:	0003e930 	.word	0x0003e930
    fe0c:	0003e934 	.word	0x0003e934
    fe10:	0000ffff 	.word	0x0000ffff

0000fe14 <queue_add>:

#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>

status_t queue_add (queue_t * queue, void * data)
{
    fe14:	e92d4038 	push	{r3, r4, r5, lr}
    fe18:	e1a04001 	mov	r4, r1
    fe1c:	e1a05000 	mov	r5, r0
  queue_link_t * item = data;

  watch (status_t)
  {
    cpu_dcache_invalidate((void*)&(item -> next),sizeof(struct _kernel_region*));
    fe20:	e3a01004 	mov	r1, #4
    fe24:	e1a00004 	mov	r0, r4
    fe28:	eb000204 	bl	10640 <cpu_dcache_invalidate>
    check (queue_error, item -> next == NULL, DNA_ERROR);
    fe2c:	e5943000 	ldr	r3, [r4]
    fe30:	e3530000 	cmp	r3, #0
    fe34:	0a000001 	beq	fe40 <queue_add+0x2c>
  rescue (queue_error)
  {
dna_log(PANIC_LEVEL, "Q(0x%x): status %d, item 0x%x",
        queue, queue -> status, item);

    leave;
    fe38:	e59f0038 	ldr	r0, [pc, #56]	; fe78 <queue_add+0x64>
  }

}
    fe3c:	e8bd8038 	pop	{r3, r4, r5, pc}
  watch (status_t)
  {
    cpu_dcache_invalidate((void*)&(item -> next),sizeof(struct _kernel_region*));
    check (queue_error, item -> next == NULL, DNA_ERROR);

    cpu_dcache_invalidate((void*)&(queue->status),sizeof(uint32_t));
    fe40:	e285000c 	add	r0, r5, #12
    fe44:	e3a01004 	mov	r1, #4
    fe48:	eb0001fc 	bl	10640 <cpu_dcache_invalidate>
    if (queue -> status == 0)
    fe4c:	e595300c 	ldr	r3, [r5, #12]
    {        
      queue -> tail -> next = item;
      queue -> tail = item;
    }

    queue -> status += 1;
    fe50:	e595200c 	ldr	r2, [r5, #12]
  {
    cpu_dcache_invalidate((void*)&(item -> next),sizeof(struct _kernel_region*));
    check (queue_error, item -> next == NULL, DNA_ERROR);

    cpu_dcache_invalidate((void*)&(queue->status),sizeof(uint32_t));
    if (queue -> status == 0)
    fe54:	e3530000 	cmp	r3, #0
      queue -> head = item;
      queue -> tail = item;
    }
    else
    {        
      queue -> tail -> next = item;
    fe58:	15953008 	ldrne	r3, [r5, #8]
      queue -> tail = item;
    }

    queue -> status += 1;
    fe5c:	e2822001 	add	r2, r2, #1
      queue -> head = item;
      queue -> tail = item;
    }
    else
    {        
      queue -> tail -> next = item;
    fe60:	15834000 	strne	r4, [r3]
    check (queue_error, item -> next == NULL, DNA_ERROR);

    cpu_dcache_invalidate((void*)&(queue->status),sizeof(uint32_t));
    if (queue -> status == 0)
    {
      queue -> head = item;
    fe64:	05854004 	streq	r4, [r5, #4]
      queue -> tail = item;
    }
    else
    {        
      queue -> tail -> next = item;
      queue -> tail = item;
    fe68:	e5854008 	str	r4, [r5, #8]
    }

    queue -> status += 1;

    return DNA_OK;
    fe6c:	e3a00000 	mov	r0, #0
    {        
      queue -> tail -> next = item;
      queue -> tail = item;
    }

    queue -> status += 1;
    fe70:	e585200c 	str	r2, [r5, #12]

    return DNA_OK;
    fe74:	e8bd8038 	pop	{r3, r4, r5, pc}
    fe78:	0000ffff 	.word	0x0000ffff

0000fe7c <dna_strcat>:
char * dna_strcat (char *  dest, const char *  src)
{
  char * s1 = dest;
  const char * s2 = src;

  for (; *s1 != '\0'; s1++);
    fe7c:	e5d03000 	ldrb	r3, [r0]
    fe80:	e3530000 	cmp	r3, #0
    fe84:	e1a03000 	mov	r3, r0
    fe88:	0a000002 	beq	fe98 <dna_strcat+0x1c>
    fe8c:	e5f32001 	ldrb	r2, [r3, #1]!
    fe90:	e3520000 	cmp	r2, #0
    fe94:	1afffffc 	bne	fe8c <dna_strcat+0x10>
  for (; *s2 != '\0'; s2++, s1++) *s1 = *s2;
    fe98:	e5d12000 	ldrb	r2, [r1]
    fe9c:	e3520000 	cmp	r2, #0
    fea0:	0a000003 	beq	feb4 <dna_strcat+0x38>
    fea4:	e4c32001 	strb	r2, [r3], #1
    fea8:	e5f12001 	ldrb	r2, [r1, #1]!
    feac:	e3520000 	cmp	r2, #0
    feb0:	1afffffb 	bne	fea4 <dna_strcat+0x28>
  *s1 = '\0';
    feb4:	e3a02000 	mov	r2, #0
    feb8:	e5c32000 	strb	r2, [r3]

  return dest;
}
    febc:	e12fff1e 	bx	lr

0000fec0 <dna_strcmp>:

#include <stdint.h>
#include <DnaTools/DnaTools.h>

int32_t dna_strcmp (const char *s1, const char *s2)
{
    fec0:	e2411001 	sub	r1, r1, #1
    fec4:	ea000001 	b	fed0 <dna_strcmp+0x10>
    if (*s1_ptr++ != *s2_ptr)
    {
      return -1;
    }
  }
  while (*s2_ptr++ != '\0');
    fec8:	e3530000 	cmp	r3, #0
    fecc:	0a000005 	beq	fee8 <dna_strcmp+0x28>
{
  char *s1_ptr = (char *)s1, *s2_ptr = (char *)s2;

  do
  {
    if (*s1_ptr++ != *s2_ptr)
    fed0:	e4d02001 	ldrb	r2, [r0], #1
    fed4:	e5f13001 	ldrb	r3, [r1, #1]!
    fed8:	e1530002 	cmp	r3, r2
    fedc:	0afffff9 	beq	fec8 <dna_strcmp+0x8>
    {
      return -1;
    fee0:	e3e00000 	mvn	r0, #0
    fee4:	e12fff1e 	bx	lr
    }
  }
  while (*s2_ptr++ != '\0');
  
  return 0;
    fee8:	e1a00003 	mov	r0, r3
}
    feec:	e12fff1e 	bx	lr

0000fef0 <queue_lookup>:

#include <stdbool.h>
#include <DnaTools/DnaTools.h>

void * queue_lookup (queue_t * queue, queue_inspector_t inspector, ...)
{
    fef0:	e92d000e 	push	{r1, r2, r3}
    fef4:	e92d4030 	push	{r4, r5, lr}
  va_list list, list_copy;
  queue_link_t * item = NULL;

  va_start (list, inspector);

  if (queue -> status != 0)
    fef8:	e590200c 	ldr	r2, [r0, #12]

#include <stdbool.h>
#include <DnaTools/DnaTools.h>

void * queue_lookup (queue_t * queue, queue_inspector_t inspector, ...)
{
    fefc:	e24dd008 	sub	sp, sp, #8
  bool result;
  va_list list, list_copy;
  queue_link_t * item = NULL;

  va_start (list, inspector);
    ff00:	e28d3018 	add	r3, sp, #24

  if (queue -> status != 0)
    ff04:	e3520000 	cmp	r2, #0
{
  bool result;
  va_list list, list_copy;
  queue_link_t * item = NULL;

  va_start (list, inspector);
    ff08:	e58d3000 	str	r3, [sp]

#include <stdbool.h>
#include <DnaTools/DnaTools.h>

void * queue_lookup (queue_t * queue, queue_inspector_t inspector, ...)
{
    ff0c:	e59d5014 	ldr	r5, [sp, #20]
  va_list list, list_copy;
  queue_link_t * item = NULL;

  va_start (list, inspector);

  if (queue -> status != 0)
    ff10:	0a000012 	beq	ff60 <queue_lookup+0x70>
  {
    for (item = queue -> head; item != NULL; item = item -> next)
    ff14:	e5904004 	ldr	r4, [r0, #4]
    ff18:	e3540000 	cmp	r4, #0
    ff1c:	1a000003 	bne	ff30 <queue_lookup+0x40>
    ff20:	ea00000e 	b	ff60 <queue_lookup+0x70>
    ff24:	e5944000 	ldr	r4, [r4]
    ff28:	e3540000 	cmp	r4, #0
    ff2c:	0a00000b 	beq	ff60 <queue_lookup+0x70>
    {
      result = false;

      va_copy (list_copy, list);
    ff30:	e59d3000 	ldr	r3, [sp]
      result = inspector (item, list_copy);
    ff34:	e1a00004 	mov	r0, r4
    ff38:	e1a01003 	mov	r1, r3
  {
    for (item = queue -> head; item != NULL; item = item -> next)
    {
      result = false;

      va_copy (list_copy, list);
    ff3c:	e58d3004 	str	r3, [sp, #4]
      result = inspector (item, list_copy);
    ff40:	e12fff35 	blx	r5
      va_end (list_copy);

      if (result) break;
    ff44:	e3500000 	cmp	r0, #0
    ff48:	0afffff5 	beq	ff24 <queue_lookup+0x34>
    }
  }

  va_end (list);
  return item;
}
    ff4c:	e1a00004 	mov	r0, r4
    ff50:	e28dd008 	add	sp, sp, #8
    ff54:	e8bd4030 	pop	{r4, r5, lr}
    ff58:	e28dd00c 	add	sp, sp, #12
    ff5c:	e12fff1e 	bx	lr

void * queue_lookup (queue_t * queue, queue_inspector_t inspector, ...)
{
  bool result;
  va_list list, list_copy;
  queue_link_t * item = NULL;
    ff60:	e3a04000 	mov	r4, #0
    ff64:	eafffff8 	b	ff4c <queue_lookup+0x5c>

0000ff68 <atomic_add>:
#include <stdbool.h>
#include <Processor/Processor.h>


int32_t atomic_add (int32_t * p_val, int32_t offset)
{
    ff68:	e92d4070 	push	{r4, r5, r6, lr}
    ff6c:	e1a04000 	mov	r4, r0
    ff70:	e1a06001 	mov	r6, r1
  int32_t old_val = 0, new_val = 0, result = 0;

  do
  {
    cpu_dcache_invalidate((void*)p_val, sizeof(uint32_t));
    ff74:	e1a00004 	mov	r0, r4
    ff78:	e3a01004 	mov	r1, #4
    ff7c:	eb0001af 	bl	10640 <cpu_dcache_invalidate>
    old_val = *p_val;
    ff80:	e5945000 	ldr	r5, [r4]
    new_val = old_val + offset;
    result = cpu_compare_and_swap(p_val, old_val, new_val);
    ff84:	e1a00004 	mov	r0, r4
    ff88:	e1a01005 	mov	r1, r5
    ff8c:	e0852006 	add	r2, r5, r6
    ff90:	eb0001a5 	bl	1062c <cpu_compare_and_swap>
  }
  while (result != 0);
    ff94:	e3500000 	cmp	r0, #0
    ff98:	1afffff5 	bne	ff74 <atomic_add+0xc>

  return old_val;
}
    ff9c:	e1a00005 	mov	r0, r5
    ffa0:	e8bd8070 	pop	{r4, r5, r6, pc}

0000ffa4 <dna_strlen>:

size_t dna_strlen (const char *s)
{
  size_t size = 0;

  while (s[size++] != '\0');
    ffa4:	e3a03000 	mov	r3, #0
    ffa8:	ea000000 	b	ffb0 <dna_strlen+0xc>
    ffac:	e1a03001 	mov	r3, r1
    ffb0:	e7d02003 	ldrb	r2, [r0, r3]
    ffb4:	e2831001 	add	r1, r3, #1
    ffb8:	e3520000 	cmp	r2, #0
    ffbc:	1afffffa 	bne	ffac <dna_strlen+0x8>
  return size - 1;
}
    ffc0:	e1a00003 	mov	r0, r3
    ffc4:	e12fff1e 	bx	lr

0000ffc8 <path_split>:
  char * p_start = NULL, * p_end = NULL;
  int32_t token_size;

  watch (status_t)
  {
    ensure (path != NULL && token != NULL, DNA_ERROR);
    ffc8:	e3510000 	cmp	r1, #0
    ffcc:	13500000 	cmpne	r0, #0
 * RESULT
 *
 * SOURCE
 */

{
    ffd0:	e92d4038 	push	{r3, r4, r5, lr}
  char * p_start = NULL, * p_end = NULL;
  int32_t token_size;

  watch (status_t)
  {
    ensure (path != NULL && token != NULL, DNA_ERROR);
    ffd4:	e1a05001 	mov	r5, r1
    ffd8:	1a000001 	bne	ffe4 <path_split+0x1c>
    ffdc:	e59f008c 	ldr	r0, [pc, #140]	; 10070 <path_split+0xa8>
    ffe0:	e8bd8038 	pop	{r3, r4, r5, pc}
    ffe4:	e1a04000 	mov	r4, r0
    /*
     * Compute the end of the token. If the path
     * ends with '/', add '.' so as to return a valid '.' entry.
     */

    p_end = path + dna_strlen (path);
    ffe8:	ebffffed 	bl	ffa4 <dna_strlen>

    if (*p_end == '/')
    ffec:	e7d43000 	ldrb	r3, [r4, r0]
    /*
     * Compute the end of the token. If the path
     * ends with '/', add '.' so as to return a valid '.' entry.
     */

    p_end = path + dna_strlen (path);
    fff0:	e0840000 	add	r0, r4, r0

    if (*p_end == '/')
    fff4:	e353002f 	cmp	r3, #47	; 0x2f
    {
      *(p_end + 1) = '.';
    fff8:	03a0302e 	moveq	r3, #46	; 0x2e
    fffc:	05e03001 	strbeq	r3, [r0, #1]!
    /*
     * Look for the beginning of the token, that is to
     * say a '/' character.
     */

    while (*p_start != '/' && p_start != path)
   10000:	e3a03000 	mov	r3, #0
   10004:	e5d32000 	ldrb	r2, [r3]
   10008:	e352002f 	cmp	r2, #47	; 0x2f
   1000c:	0a00000d 	beq	10048 <path_split+0x80>
   10010:	e1a01003 	mov	r1, r3
   10014:	ea000001 	b	10020 <path_split+0x58>
   10018:	e1540001 	cmp	r4, r1
   1001c:	0affffee 	beq	ffdc <path_split+0x14>
   10020:	e5712001 	ldrb	r2, [r1, #-1]!
   10024:	e352002f 	cmp	r2, #47	; 0x2f
   10028:	1afffffa 	bne	10018 <path_split+0x50>
   1002c:	e1a04001 	mov	r4, r1

    /*
     * Copy the token.
     */

    token_size = p_end - p_start + 1;
   10030:	e0644000 	rsb	r4, r4, r0
   10034:	e2844001 	add	r4, r4, #1
    ensure (token_size <= DNA_FILENAME_LENGTH, DNA_NAME_TOO_LONG);
   10038:	e3540c01 	cmp	r4, #256	; 0x100
   1003c:	da000004 	ble	10054 <path_split+0x8c>
   10040:	e59f002c 	ldr	r0, [pc, #44]	; 10074 <path_split+0xac>
   10044:	e8bd8038 	pop	{r3, r4, r5, pc}
    /*
     * Look for the beginning of the token, that is to
     * say a '/' character.
     */

    while (*p_start != '/' && p_start != path)
   10048:	e1a04003 	mov	r4, r3
   1004c:	e1a01003 	mov	r1, r3
   10050:	eafffff6 	b	10030 <path_split+0x68>
     */

    token_size = p_end - p_start + 1;
    ensure (token_size <= DNA_FILENAME_LENGTH, DNA_NAME_TOO_LONG);

    dna_memcpy (token, p_start + 1, token_size);
   10054:	e2811001 	add	r1, r1, #1
   10058:	e1a00005 	mov	r0, r5
   1005c:	e1a02004 	mov	r2, r4
   10060:	eb00000b 	bl	10094 <dna_memcpy>
    token[token_size] = '\0';
   10064:	e3a00000 	mov	r0, #0
   10068:	e7c50004 	strb	r0, [r5, r4]
    *(p_start + 1) = '\0';
#else
    *(p_start + 1) = '\0';
#endif

    return DNA_OK;
   1006c:	e8bd8038 	pop	{r3, r4, r5, pc}
   10070:	0000ffff 	.word	0x0000ffff
   10074:	0000fffa 	.word	0x0000fffa

00010078 <dna_strcpy>:

#include <DnaTools/DnaTools.h>

char * dna_strcpy (char *  s1, const char *  s2)
{
  char *s1_ptr = s1, *s2_ptr = (char *)s2;
   10078:	e1a03000 	mov	r3, r0
  
  do *s1_ptr++ = *s2_ptr;
   1007c:	e5d12000 	ldrb	r2, [r1]
   10080:	e4c32001 	strb	r2, [r3], #1
  while (*s2_ptr++ != '\0');
   10084:	e4d12001 	ldrb	r2, [r1], #1
   10088:	e3520000 	cmp	r2, #0
   1008c:	1afffffa 	bne	1007c <dna_strcpy+0x4>
  
  return s1;
}
   10090:	e12fff1e 	bx	lr

00010094 <dna_memcpy>:
#include <DnaTools/DnaTools.h>
#include <Processor/Cache.h>


void * dna_memcpy (void *  s1, const void *  s2, size_t n)
{
   10094:	e92d4070 	push	{r4, r5, r6, lr}
   10098:	e1a04001 	mov	r4, r1
   1009c:	e1a06002 	mov	r6, r2
   100a0:	e1a05000 	mov	r5, r0
  cpu_dcache_invalidate((void*)s2, n);
   100a4:	e1a01002 	mov	r1, r2
   100a8:	e1a00004 	mov	r0, r4
   100ac:	eb000163 	bl	10640 <cpu_dcache_invalidate>
  for (size_t idx = 0; idx < n; idx += 1)
   100b0:	e3560000 	cmp	r6, #0
   100b4:	0a000025 	beq	10150 <dna_memcpy+0xbc>
   100b8:	e2843004 	add	r3, r4, #4
   100bc:	e2852004 	add	r2, r5, #4
   100c0:	e1540002 	cmp	r4, r2
   100c4:	31550003 	cmpcc	r5, r3
   100c8:	23a03001 	movcs	r3, #1
   100cc:	33a03000 	movcc	r3, #0
   100d0:	e1842005 	orr	r2, r4, r5
   100d4:	e3560009 	cmp	r6, #9
   100d8:	93a03000 	movls	r3, #0
   100dc:	82033001 	andhi	r3, r3, #1
   100e0:	e3120003 	tst	r2, #3
   100e4:	13a03000 	movne	r3, #0
   100e8:	02033001 	andeq	r3, r3, #1
   100ec:	e3530000 	cmp	r3, #0
   100f0:	0a000018 	beq	10158 <dna_memcpy+0xc4>
   100f4:	e3a03000 	mov	r3, #0
   100f8:	e1a02003 	mov	r2, r3
   100fc:	e1a01126 	lsr	r1, r6, #2
   10100:	e1a00101 	lsl	r0, r1, #2
  {    
    ((uint8_t *)s1)[idx] = ((uint8_t *)s2)[idx];
   10104:	e794c003 	ldr	ip, [r4, r3]
   10108:	e2822001 	add	r2, r2, #1
   1010c:	e1520001 	cmp	r2, r1
   10110:	e785c003 	str	ip, [r5, r3]
   10114:	e2833004 	add	r3, r3, #4
   10118:	3afffff9 	bcc	10104 <dna_memcpy+0x70>
   1011c:	e1560000 	cmp	r6, r0
   10120:	0a00000a 	beq	10150 <dna_memcpy+0xbc>
   10124:	e7d43101 	ldrb	r3, [r4, r1, lsl #2]


void * dna_memcpy (void *  s1, const void *  s2, size_t n)
{
  cpu_dcache_invalidate((void*)s2, n);
  for (size_t idx = 0; idx < n; idx += 1)
   10128:	e2802001 	add	r2, r0, #1
   1012c:	e1560002 	cmp	r6, r2
  {    
    ((uint8_t *)s1)[idx] = ((uint8_t *)s2)[idx];
   10130:	e7c53101 	strb	r3, [r5, r1, lsl #2]


void * dna_memcpy (void *  s1, const void *  s2, size_t n)
{
  cpu_dcache_invalidate((void*)s2, n);
  for (size_t idx = 0; idx < n; idx += 1)
   10134:	9a000005 	bls	10150 <dna_memcpy+0xbc>
   10138:	e2803002 	add	r3, r0, #2
  {    
    ((uint8_t *)s1)[idx] = ((uint8_t *)s2)[idx];
   1013c:	e7d41002 	ldrb	r1, [r4, r2]


void * dna_memcpy (void *  s1, const void *  s2, size_t n)
{
  cpu_dcache_invalidate((void*)s2, n);
  for (size_t idx = 0; idx < n; idx += 1)
   10140:	e1560003 	cmp	r6, r3
  {    
    ((uint8_t *)s1)[idx] = ((uint8_t *)s2)[idx];
   10144:	e7c51002 	strb	r1, [r5, r2]
   10148:	87d42003 	ldrbhi	r2, [r4, r3]
   1014c:	87c52003 	strbhi	r2, [r5, r3]
  }

  return s1;
}
   10150:	e1a00005 	mov	r0, r5
   10154:	e8bd8070 	pop	{r4, r5, r6, pc}
void * dna_memcpy (void *  s1, const void *  s2, size_t n)
{
  cpu_dcache_invalidate((void*)s2, n);
  for (size_t idx = 0; idx < n; idx += 1)
  {    
    ((uint8_t *)s1)[idx] = ((uint8_t *)s2)[idx];
   10158:	e7d42003 	ldrb	r2, [r4, r3]
   1015c:	e7c52003 	strb	r2, [r5, r3]


void * dna_memcpy (void *  s1, const void *  s2, size_t n)
{
  cpu_dcache_invalidate((void*)s2, n);
  for (size_t idx = 0; idx < n; idx += 1)
   10160:	e2833001 	add	r3, r3, #1
   10164:	e1530006 	cmp	r3, r6
   10168:	1afffffa 	bne	10158 <dna_memcpy+0xc4>
   1016c:	eafffff7 	b	10150 <dna_memcpy+0xbc>

00010170 <dna_atoi>:

#include <stdint.h>
#include <DnaTools/DnaTools.h>

int32_t dna_atoi (char * alpha)
{
   10170:	e92d4010 	push	{r4, lr}
   10174:	e1a04000 	mov	r4, r0
  int32_t value = 0, c = 0, index = 0;
  uint32_t len = dna_strlen (alpha), coeff = 1;
   10178:	ebffff89 	bl	ffa4 <dna_strlen>

  if (alpha == NULL) return -1;
   1017c:	e3540000 	cmp	r4, #0
   10180:	0a000016 	beq	101e0 <dna_atoi+0x70>
  if (len == 0) return -1;
   10184:	e3500000 	cmp	r0, #0
   10188:	0a000014 	beq	101e0 <dna_atoi+0x70>
  
  for (index = len - 1; index >= 0; index -= 1)
   1018c:	e2503001 	subs	r3, r0, #1
   10190:	4a000014 	bmi	101e8 <dna_atoi+0x78>
  {
    c = alpha[index] - '0';
   10194:	e7d41003 	ldrb	r1, [r4, r3]
   10198:	e2411030 	sub	r1, r1, #48	; 0x30
    if (c < 0 || c > 9) return -1;
   1019c:	e3510009 	cmp	r1, #9
   101a0:	8a00000e 	bhi	101e0 <dna_atoi+0x70>
#include <DnaTools/DnaTools.h>

int32_t dna_atoi (char * alpha)
{
  int32_t value = 0, c = 0, index = 0;
  uint32_t len = dna_strlen (alpha), coeff = 1;
   101a4:	e3a02001 	mov	r2, #1
#include <stdint.h>
#include <DnaTools/DnaTools.h>

int32_t dna_atoi (char * alpha)
{
  int32_t value = 0, c = 0, index = 0;
   101a8:	e3a0c000 	mov	ip, #0
   101ac:	ea000003 	b	101c0 <dna_atoi+0x50>
  if (alpha == NULL) return -1;
  if (len == 0) return -1;
  
  for (index = len - 1; index >= 0; index -= 1)
  {
    c = alpha[index] - '0';
   101b0:	e7d41003 	ldrb	r1, [r4, r3]
   101b4:	e2411030 	sub	r1, r1, #48	; 0x30
    if (c < 0 || c > 9) return -1;
   101b8:	e3510009 	cmp	r1, #9
   101bc:	8a000007 	bhi	101e0 <dna_atoi+0x70>
  uint32_t len = dna_strlen (alpha), coeff = 1;

  if (alpha == NULL) return -1;
  if (len == 0) return -1;
  
  for (index = len - 1; index >= 0; index -= 1)
   101c0:	e2433001 	sub	r3, r3, #1
  {
    c = alpha[index] - '0';
    if (c < 0 || c > 9) return -1;

    value += c * coeff;
    coeff *= 10;
   101c4:	e082e102 	add	lr, r2, r2, lsl #2
  uint32_t len = dna_strlen (alpha), coeff = 1;

  if (alpha == NULL) return -1;
  if (len == 0) return -1;
  
  for (index = len - 1; index >= 0; index -= 1)
   101c8:	e3730001 	cmn	r3, #1
  {
    c = alpha[index] - '0';
    if (c < 0 || c > 9) return -1;

    value += c * coeff;
   101cc:	e02cc192 	mla	ip, r2, r1, ip
    coeff *= 10;
   101d0:	e1a0208e 	lsl	r2, lr, #1
  uint32_t len = dna_strlen (alpha), coeff = 1;

  if (alpha == NULL) return -1;
  if (len == 0) return -1;
  
  for (index = len - 1; index >= 0; index -= 1)
   101d4:	1afffff5 	bne	101b0 <dna_atoi+0x40>

    value += c * coeff;
    coeff *= 10;
  }

  return value;
   101d8:	e1a0000c 	mov	r0, ip
   101dc:	e8bd8010 	pop	{r4, pc}
int32_t dna_atoi (char * alpha)
{
  int32_t value = 0, c = 0, index = 0;
  uint32_t len = dna_strlen (alpha), coeff = 1;

  if (alpha == NULL) return -1;
   101e0:	e3e00000 	mvn	r0, #0
    value += c * coeff;
    coeff *= 10;
  }

  return value;
}
   101e4:	e8bd8010 	pop	{r4, pc}
#include <stdint.h>
#include <DnaTools/DnaTools.h>

int32_t dna_atoi (char * alpha)
{
  int32_t value = 0, c = 0, index = 0;
   101e8:	e3a0c000 	mov	ip, #0
   101ec:	eafffff9 	b	101d8 <dna_atoi+0x68>

000101f0 <queue_pushback>:
{
  queue_link_t * item = data;

  watch (status_t)
  {
    check (queue_error, item -> next == NULL, DNA_ERROR);
   101f0:	e5913000 	ldr	r3, [r1]
   101f4:	e3530000 	cmp	r3, #0
  rescue (queue_error)
  {
dna_log(PANIC_LEVEL, "Q(0x%x): status %d, item 0x%x",
        queue, queue -> status, item);

    leave;
   101f8:	159f3038 	ldrne	r3, [pc, #56]	; 10238 <queue_pushback+0x48>
{
  queue_link_t * item = data;

  watch (status_t)
  {
    check (queue_error, item -> next == NULL, DNA_ERROR);
   101fc:	0a000001 	beq	10208 <queue_pushback+0x18>
        queue, queue -> status, item);

    leave;
  }

}
   10200:	e1a00003 	mov	r0, r3
   10204:	e12fff1e 	bx	lr

  watch (status_t)
  {
    check (queue_error, item -> next == NULL, DNA_ERROR);

    if (queue -> status == 0)
   10208:	e590300c 	ldr	r3, [r0, #12]
    {
      item -> next = queue -> head;
      queue -> head = item;
    }

    queue -> status += 1;
   1020c:	e590200c 	ldr	r2, [r0, #12]

  watch (status_t)
  {
    check (queue_error, item -> next == NULL, DNA_ERROR);

    if (queue -> status == 0)
   10210:	e3530000 	cmp	r3, #0
      queue -> head = item;
      queue -> tail = item;
    }
    else
    {
      item -> next = queue -> head;
   10214:	15903004 	ldrne	r3, [r0, #4]
      queue -> head = item;
    }

    queue -> status += 1;
   10218:	e2822001 	add	r2, r2, #1
      queue -> head = item;
      queue -> tail = item;
    }
    else
    {
      item -> next = queue -> head;
   1021c:	15813000 	strne	r3, [r1]
  {
    check (queue_error, item -> next == NULL, DNA_ERROR);

    if (queue -> status == 0)
    {
      queue -> head = item;
   10220:	05801004 	streq	r1, [r0, #4]
      queue -> tail = item;
   10224:	05801008 	streq	r1, [r0, #8]
    }
    else
    {
      item -> next = queue -> head;
      queue -> head = item;
   10228:	15801004 	strne	r1, [r0, #4]
    }

    queue -> status += 1;

    return DNA_OK;
   1022c:	e3a03000 	mov	r3, #0
    {
      item -> next = queue -> head;
      queue -> head = item;
    }

    queue -> status += 1;
   10230:	e580200c 	str	r2, [r0, #12]

    return DNA_OK;
   10234:	eafffff1 	b	10200 <queue_pushback+0x10>
   10238:	0000ffff 	.word	0x0000ffff

0001023c <dna_itoa>:
{
  char ascii[64];
  int32_t value = integer, index = 0, rem = 0;
  bool negative = false;

  if(value < 0)
   1023c:	e3500000 	cmp	r0, #0
#include <stdint.h>
#include <stdbool.h>
#include <DnaTools/DnaTools.h>

int32_t dna_itoa (int32_t integer, char * buffer)
{
   10240:	e92d4070 	push	{r4, r5, r6, lr}
   10244:	a1a02000 	movge	r2, r0
  bool negative = false;

  if(value < 0)
  {
    value = -1 * value;
    negative = true;
   10248:	b3a06001 	movlt	r6, #1

int32_t dna_itoa (int32_t integer, char * buffer)
{
  char ascii[64];
  int32_t value = integer, index = 0, rem = 0;
  bool negative = false;
   1024c:	a3a06000 	movge	r6, #0

  if(value < 0)
  {
    value = -1 * value;
    negative = true;
   10250:	e3a0e000 	mov	lr, #0
#include <stdint.h>
#include <stdbool.h>
#include <DnaTools/DnaTools.h>

int32_t dna_itoa (int32_t integer, char * buffer)
{
   10254:	e24dd040 	sub	sp, sp, #64	; 0x40
    negative = true;
  }

  do
  {
    rem = value % 10;
   10258:	e59f5078 	ldr	r5, [pc, #120]	; 102d8 <dna_itoa+0x9c>
  int32_t value = integer, index = 0, rem = 0;
  bool negative = false;

  if(value < 0)
  {
    value = -1 * value;
   1025c:	b2602000 	rsblt	r2, r0, #0
   10260:	e24d4001 	sub	r4, sp, #1
    negative = true;
  }

  do
  {
    rem = value % 10;
   10264:	e0cc3295 	smull	r3, ip, r5, r2
   10268:	e1a03fc2 	asr	r3, r2, #31
   1026c:	e063c14c 	rsb	ip, r3, ip, asr #2
   10270:	e1a0300c 	mov	r3, ip
   10274:	e08cc10c 	add	ip, ip, ip, lsl #2
   10278:	e042c08c 	sub	ip, r2, ip, lsl #1
    value = value / 10;
    ascii[index ++] = rem + '0';
   1027c:	e28cc030 	add	ip, ip, #48	; 0x30
  }
  while(value > 0);
   10280:	e2532000 	subs	r2, r3, #0

  do
  {
    rem = value % 10;
    value = value / 10;
    ascii[index ++] = rem + '0';
   10284:	e28ee001 	add	lr, lr, #1
   10288:	e5e4c001 	strb	ip, [r4, #1]!
  }
  while(value > 0);
   1028c:	1afffff4 	bne	10264 <dna_itoa+0x28>

  if (negative) ascii[index ++] = '-';
   10290:	e3560000 	cmp	r6, #0

  do
  {
    rem = value % 10;
    value = value / 10;
    ascii[index ++] = rem + '0';
   10294:	e1a0300e 	mov	r3, lr
  }
  while(value > 0);

  if (negative) ascii[index ++] = '-';
   10298:	13a0202d 	movne	r2, #45	; 0x2d
   1029c:	128dc040 	addne	ip, sp, #64	; 0x40
   102a0:	108c300e 	addne	r3, ip, lr
   102a4:	15432040 	strbne	r2, [r3, #-64]	; 0x40
   102a8:	e1a0400d 	mov	r4, sp

  do
  {
    rem = value % 10;
    value = value / 10;
    ascii[index ++] = rem + '0';
   102ac:	e1a02001 	mov	r2, r1
  }
  while(value > 0);

  if (negative) ascii[index ++] = '-';
   102b0:	128ee001 	addne	lr, lr, #1
   102b4:	e08d300e 	add	r3, sp, lr

  for(int32_t i = index - 1; i >= 0; i--) *buffer ++ = ascii[i];
   102b8:	e573c001 	ldrb	ip, [r3, #-1]!
   102bc:	e1530004 	cmp	r3, r4
   102c0:	e4c2c001 	strb	ip, [r2], #1
   102c4:	1afffffb 	bne	102b8 <dna_itoa+0x7c>
  *buffer = '\0';
   102c8:	e3a03000 	mov	r3, #0
   102cc:	e7c1300e 	strb	r3, [r1, lr]

  return integer;
}
   102d0:	e28dd040 	add	sp, sp, #64	; 0x40
   102d4:	e8bd8070 	pop	{r4, r5, r6, pc}
   102d8:	66666667 	.word	0x66666667

000102dc <queue_insert>:
 */

#include <DnaTools/DnaTools.h>

void queue_insert (queue_t * queue, queue_comparator_t comparator, void * data)
{
   102dc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  queue_link_t * item = data, * current = NULL, * previous = NULL;

  item -> next = NULL;
   102e0:	e3a08000 	mov	r8, #0

  if (queue -> status != 0)
   102e4:	e590300c 	ldr	r3, [r0, #12]
 */

#include <DnaTools/DnaTools.h>

void queue_insert (queue_t * queue, queue_comparator_t comparator, void * data)
{
   102e8:	e1a07000 	mov	r7, r0
  queue_link_t * item = data, * current = NULL, * previous = NULL;

  item -> next = NULL;

  if (queue -> status != 0)
   102ec:	e1530008 	cmp	r3, r8

void queue_insert (queue_t * queue, queue_comparator_t comparator, void * data)
{
  queue_link_t * item = data, * current = NULL, * previous = NULL;

  item -> next = NULL;
   102f0:	e5828000 	str	r8, [r2]
 */

#include <DnaTools/DnaTools.h>

void queue_insert (queue_t * queue, queue_comparator_t comparator, void * data)
{
   102f4:	e1a05002 	mov	r5, r2
      queue -> tail = item;
    }
  }
  else
  {
    queue -> head = item;
   102f8:	05802004 	streq	r2, [r0, #4]
    queue -> tail = item;
   102fc:	05802008 	streq	r2, [r0, #8]
{
  queue_link_t * item = data, * current = NULL, * previous = NULL;

  item -> next = NULL;

  if (queue -> status != 0)
   10300:	0a000006 	beq	10320 <queue_insert+0x44>
  {
    current = queue -> head;
   10304:	e5904004 	ldr	r4, [r0, #4]
   10308:	e1a06001 	mov	r6, r1
    while (current != NULL)
   1030c:	e1540008 	cmp	r4, r8
   10310:	1a00000b 	bne	10344 <queue_insert+0x68>
      }
    }

    if (current == NULL)
    {
      queue -> tail -> next = item;
   10314:	e5973008 	ldr	r3, [r7, #8]
   10318:	e5835000 	str	r5, [r3]
      queue -> tail = item;
   1031c:	e5875008 	str	r5, [r7, #8]
  {
    queue -> head = item;
    queue -> tail = item;
  }

  queue -> status += 1;
   10320:	e597300c 	ldr	r3, [r7, #12]
   10324:	e2833001 	add	r3, r3, #1
   10328:	e587300c 	str	r3, [r7, #12]
   1032c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        break;
      }
      else
      {
        previous = current;
        current = current -> next;
   10330:	e5943000 	ldr	r3, [r4]
  item -> next = NULL;

  if (queue -> status != 0)
  {
    current = queue -> head;
    while (current != NULL)
   10334:	e3530000 	cmp	r3, #0
   10338:	0afffff5 	beq	10314 <queue_insert+0x38>
   1033c:	e1a08004 	mov	r8, r4
        break;
      }
      else
      {
        previous = current;
        current = current -> next;
   10340:	e1a04003 	mov	r4, r3
    {
      /*
       * The comparator function is <
       */

      if (comparator (current, item))
   10344:	e1a00004 	mov	r0, r4
   10348:	e1a01005 	mov	r1, r5
   1034c:	e12fff36 	blx	r6
   10350:	e3500000 	cmp	r0, #0
   10354:	0afffff5 	beq	10330 <queue_insert+0x54>
      {
        if (current == queue -> head)
   10358:	e5973004 	ldr	r3, [r7, #4]
   1035c:	e1540003 	cmp	r4, r3
        {
          queue -> head = item;
   10360:	05875004 	streq	r5, [r7, #4]
          item -> next = current;
        }
        else
        {
          previous -> next = item;
   10364:	15885000 	strne	r5, [r8]
          item -> next = current;
   10368:	e5854000 	str	r4, [r5]
   1036c:	eaffffeb 	b	10320 <queue_insert+0x44>

00010370 <cpu_vector_transfer>:

.global cpu_vector_transfer

cpu_vector_transfer:
	@ Save registers for further use
	push		{r3-r12}
   10370:	e92d1ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}

	@ Return directly if byte_count is 0
	cmp			r2, #0x0
   10374:	e3520000 	cmp	r2, #0
	beq			_cpu_vector_xfer_end
   10378:	0a000018 	beq	103e0 <_cpu_vector_xfer_end>

	@ Test if r0 and r1 are aligned on a word frontier
	orrs		r3, r0, #0x3
   1037c:	e3903003 	orrs	r3, r0, #3
	orrs		r3, r1, #0x3
   10380:	e3913003 	orrs	r3, r1, #3

	@ If one of them is not aligned, switch to byte transfer
	mov			r11, #0x0
   10384:	e3a0b000 	mov	fp, #0
	beq			_cpu_vector_xfer_byte
   10388:	0a00000e 	beq	103c8 <_cpu_vector_xfer_byte>
	
	@ Compute the number of 8-word xfer to perform
	movs		r12, r2, lsr #0x5
   1038c:	e1b0c2a2 	lsrs	ip, r2, #5
	mov			r11, r12, lsl #0x5
   10390:	e1a0b28c 	lsl	fp, ip, #5

	@ If no 8-words are available, jump to the byte copy
	beq			_cpu_vector_xfer_word
   10394:	0a000004 	beq	103ac <_cpu_vector_xfer_word>

00010398 <_cpu_vector_xfer_do_lsm>:

	@ Perform the 8-words copy
_cpu_vector_xfer_do_lsm:
	ldmia		r0!, {r3 - r10}
   10398:	e8b007f8 	ldm	r0!, {r3, r4, r5, r6, r7, r8, r9, sl}
	stmia		r1!, {r3 - r10}
   1039c:	e8a107f8 	stmia	r1!, {r3, r4, r5, r6, r7, r8, r9, sl}
	subs		r12, r12, #1
   103a0:	e25cc001 	subs	ip, ip, #1
	bne			_cpu_vector_xfer_do_lsm
   103a4:	1afffffb 	bne	10398 <_cpu_vector_xfer_do_lsm>

	@ Substract the written 8-words from r2
	sub		r2, r2, r11
   103a8:	e042200b 	sub	r2, r2, fp

000103ac <_cpu_vector_xfer_word>:

	@ Compute the remaining number of words to copy
_cpu_vector_xfer_word:
	movs		r12, r2, lsr #0x2
   103ac:	e1b0c122 	lsrs	ip, r2, #2
	mov			r11, r12, lsl #0x2
   103b0:	e1a0b10c 	lsl	fp, ip, #2

	@ If no words are available, jump to the byte copy
	beq			_cpu_vector_xfer_byte
   103b4:	0a000003 	beq	103c8 <_cpu_vector_xfer_byte>

000103b8 <_cpu_vector_xfer_do_word>:

	@ Perform the words copy
_cpu_vector_xfer_do_word:
	ldr			r3, [r0], #4
   103b8:	e4903004 	ldr	r3, [r0], #4
	str			r3, [r1], #4
   103bc:	e4813004 	str	r3, [r1], #4
	subs		r12, r12, #1
   103c0:	e25cc001 	subs	ip, ip, #1
	bne			_cpu_vector_xfer_do_word
   103c4:	1afffffb 	bne	103b8 <_cpu_vector_xfer_do_word>

000103c8 <_cpu_vector_xfer_byte>:

	@ Compute the remaining number of bytes to copy
_cpu_vector_xfer_byte:
	subs		r12, r2, r11
   103c8:	e052c00b 	subs	ip, r2, fp

	@ If no bytes are available, jump to the end
	beq			_cpu_vector_xfer_end
   103cc:	0a000003 	beq	103e0 <_cpu_vector_xfer_end>

000103d0 <_cpu_vector_xfer_do_byte>:

	@ Perform the byte copy
_cpu_vector_xfer_do_byte:
	ldrb		r3, [r0], #1
   103d0:	e4d03001 	ldrb	r3, [r0], #1
	strb		r3, [r1], #1
   103d4:	e4c13001 	strb	r3, [r1], #1
	subs		r12, r12, #1
   103d8:	e25cc001 	subs	ip, ip, #1
	bne  		_cpu_vector_xfer_do_byte
   103dc:	1afffffb 	bne	103d0 <_cpu_vector_xfer_do_byte>

000103e0 <_cpu_vector_xfer_end>:

	@ Restore the registers and return
_cpu_vector_xfer_end:
	pop			{r3 - r12}
   103e0:	e8bd1ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
	mov pc, lr
   103e4:	e1a0f00e 	mov	pc, lr

  nop
   103e8:	e320f000 	nop	{0}
  nop
   103ec:	e320f000 	nop	{0}

000103f0 <cpu_cache_invalidate>:
    void * address, int32_t words)
{
  register int32_t count = 0;
  register uint32_t adjusted_address = (uint32_t)address & 0xFFFFFFF0UL;

  switch (cache_type) 
   103f0:	e3500000 	cmp	r0, #0
   103f4:	0a000012 	beq	10444 <cpu_cache_invalidate+0x54>
   103f8:	e3500001 	cmp	r0, #1
   103fc:	112fff1e 	bxne	lr
        break;
      }

     case CPU_CACHE_DATA :
      {
        if (words == CPU_CACHE_ALL)
   10400:	e3720001 	cmn	r2, #1
   10404:	0a00001c 	beq	1047c <cpu_cache_invalidate+0x8c>
        {
          __asm__ volatile ("mcr p15, 0, %0, c7, c6, 0" : : "r"(count));
        }
        else
        {
          count = words >> CPU_DCACHE_SIZE_LOG2;
   10408:	e1a032c2 	asr	r3, r2, #5
          count += (words - (count << CPU_DCACHE_SIZE_LOG2) != 0) ? 1 : 0;
   1040c:	e1a00283 	lsl	r0, r3, #5
   10410:	e1500002 	cmp	r0, r2
   10414:	01a02003 	moveq	r2, r3
   10418:	12832001 	addne	r2, r3, #1

          for (register int32_t i = 0; i < count; i += 1)
   1041c:	e3520000 	cmp	r2, #0
   10420:	d12fff1e 	bxle	lr
   10424:	e3a03000 	mov	r3, #0

void cpu_cache_invalidate (cpu_cache_t cache_type,
    void * address, int32_t words)
{
  register int32_t count = 0;
  register uint32_t adjusted_address = (uint32_t)address & 0xFFFFFFF0UL;
   10428:	e3c1100f 	bic	r1, r1, #15
          count = words >> CPU_DCACHE_SIZE_LOG2;
          count += (words - (count << CPU_DCACHE_SIZE_LOG2) != 0) ? 1 : 0;

          for (register int32_t i = 0; i < count; i += 1)
          {
            __asm__ volatile ("mcr p15, 0, %0, c7, c6, 1"
   1042c:	ee071f36 	mcr	15, 0, r1, cr7, cr6, {1}
        else
        {
          count = words >> CPU_DCACHE_SIZE_LOG2;
          count += (words - (count << CPU_DCACHE_SIZE_LOG2) != 0) ? 1 : 0;

          for (register int32_t i = 0; i < count; i += 1)
   10430:	e2833001 	add	r3, r3, #1
   10434:	e1530002 	cmp	r3, r2
          {
            __asm__ volatile ("mcr p15, 0, %0, c7, c6, 1"
                :
                : "r"(adjusted_address));

            adjusted_address += 4 << CPU_DCACHE_SIZE_LOG2;
   10438:	e2811080 	add	r1, r1, #128	; 0x80
        else
        {
          count = words >> CPU_DCACHE_SIZE_LOG2;
          count += (words - (count << CPU_DCACHE_SIZE_LOG2) != 0) ? 1 : 0;

          for (register int32_t i = 0; i < count; i += 1)
   1043c:	1afffffa 	bne	1042c <cpu_cache_invalidate+0x3c>
   10440:	e12fff1e 	bx	lr

  switch (cache_type) 
  {
    case CPU_CACHE_INSTRUCTION :
      {
        if (words == CPU_CACHE_ALL)
   10444:	e3720001 	cmn	r2, #1
   10448:	0a00000e 	beq	10488 <cpu_cache_invalidate+0x98>
        {
          __asm__ volatile ("mcr p15, 0, %0, c7, c5, 0" : : "r"(count));
        }
        else
        {
          count = words >> CPU_DCACHE_SIZE_LOG2;
   1044c:	e1a032c2 	asr	r3, r2, #5
          count += (words - (count << CPU_DCACHE_SIZE_LOG2) != 0) ? 1 : 0;
   10450:	e1a01283 	lsl	r1, r3, #5
   10454:	e1510002 	cmp	r1, r2
   10458:	01a02003 	moveq	r2, r3
   1045c:	12832001 	addne	r2, r3, #1

          for (register int32_t i = 0; i < count; i += 1)
   10460:	e3520000 	cmp	r2, #0
   10464:	d12fff1e 	bxle	lr
          {
            __asm__ volatile ("mcr p15, 0, %0, c7, c5, 1" : : "r"(count));
   10468:	ee072f35 	mcr	15, 0, r2, cr7, cr5, {1}
        else
        {
          count = words >> CPU_DCACHE_SIZE_LOG2;
          count += (words - (count << CPU_DCACHE_SIZE_LOG2) != 0) ? 1 : 0;

          for (register int32_t i = 0; i < count; i += 1)
   1046c:	e2800001 	add	r0, r0, #1
   10470:	e1500002 	cmp	r0, r2
   10474:	1afffffb 	bne	10468 <cpu_cache_invalidate+0x78>
   10478:	e12fff1e 	bx	lr

     case CPU_CACHE_DATA :
      {
        if (words == CPU_CACHE_ALL)
        {
          __asm__ volatile ("mcr p15, 0, %0, c7, c6, 0" : : "r"(count));
   1047c:	e3a03000 	mov	r3, #0
   10480:	ee073f16 	mcr	15, 0, r3, cr7, cr6, {0}
   10484:	e12fff1e 	bx	lr
  {
    case CPU_CACHE_INSTRUCTION :
      {
        if (words == CPU_CACHE_ALL)
        {
          __asm__ volatile ("mcr p15, 0, %0, c7, c5, 0" : : "r"(count));
   10488:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
   1048c:	e12fff1e 	bx	lr

00010490 <cpu_trap_mask_and_backup>:

interrupt_status_t cpu_trap_mask_and_backup (void)
{
  interrupt_status_t cpsr = 0;

  __asm__ volatile (
   10490:	e10f0000 	mrs	r0, CPSR
   10494:	e1a03000 	mov	r3, r0
   10498:	e38000c0 	orr	r0, r0, #192	; 0xc0
   1049c:	e129f000 	msr	CPSR_fc, r0
      :
      : "r0"
      );

  return cpsr;
}
   104a0:	e1a00003 	mov	r0, r3
   104a4:	e12fff1e 	bx	lr

000104a8 <cpu_trap_disable>:
#include <Processor/Processor.h>

void cpu_trap_disable (interrupt_id_t id)
{
   104a8:	e92d4010 	push	{r4, lr}
   104ac:	e1a04000 	mov	r4, r0
  PLATFORM_AICU_BASE -> slot[cpu_mp_id ()] . mask &= ~(1 << id);
   104b0:	eb00004c 	bl	105e8 <cpu_mp_id>
   104b4:	e3a02001 	mov	r2, #1
   104b8:	e59f3014 	ldr	r3, [pc, #20]	; 104d4 <cpu_trap_disable+0x2c>
   104bc:	e5933000 	ldr	r3, [r3]
   104c0:	e0830200 	add	r0, r3, r0, lsl #4
   104c4:	e5901104 	ldr	r1, [r0, #260]	; 0x104
   104c8:	e1c14412 	bic	r4, r1, r2, lsl r4
   104cc:	e5804104 	str	r4, [r0, #260]	; 0x104
   104d0:	e8bd8010 	pop	{r4, pc}
   104d4:	0003e964 	.word	0x0003e964

000104d8 <cpu_mp_send_ipi>:
#include <Processor/Processor.h>
#include <Platform/Platform.h>

void cpu_mp_send_ipi (int32_t target, int32_t command, void * data)
{
  cpu_write (UINT32, & (PLATFORM_IPI_BASE[target] . data), ((uint32_t)data));
   104d8:	e59f3010 	ldr	r3, [pc, #16]	; 104f0 <cpu_mp_send_ipi+0x18>
   104dc:	e5933000 	ldr	r3, [r3]
   104e0:	e083c200 	add	ip, r3, r0, lsl #4
   104e4:	e58c2004 	str	r2, [ip, #4]
  cpu_write (UINT32, & (PLATFORM_IPI_BASE[target] . command), command);
   104e8:	e7831200 	str	r1, [r3, r0, lsl #4]
   104ec:	e12fff1e 	bx	lr
   104f0:	0003e960 	.word	0x0003e960

000104f4 <cpu_mp_proceed>:
#include <Processor/Processor.h>

void cpu_mp_proceed (void)
{
  cpu_mp_synchro = 0;
   104f4:	e3a02000 	mov	r2, #0
   104f8:	e59f3004 	ldr	r3, [pc, #4]	; 10504 <cpu_mp_proceed+0x10>
   104fc:	e5832000 	str	r2, [r3]
   10500:	e12fff1e 	bx	lr
   10504:	0003dfe4 	.word	0x0003dfe4

00010508 <cpu_timer_cancel>:
#include <Platform/Platform.h>

void cpu_timer_cancel (int32_t id)
{
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[id];
  cpu_write(UINT32, & (timer -> mode), 1);
   10508:	e3a03001 	mov	r3, #1
#include <Processor/Processor.h>
#include <Platform/Platform.h>

void cpu_timer_cancel (int32_t id)
{
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[id];
   1050c:	e59f200c 	ldr	r2, [pc, #12]	; 10520 <cpu_timer_cancel+0x18>
   10510:	e5922000 	ldr	r2, [r2]
   10514:	e0820200 	add	r0, r2, r0, lsl #4
  cpu_write(UINT32, & (timer -> mode), 1);
   10518:	e5803004 	str	r3, [r0, #4]
   1051c:	e12fff1e 	bx	lr
   10520:	0003e95c 	.word	0x0003e95c

00010524 <cpu_timer_get>:
{
  uint32_t local_value = 0;
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[id];

  cpu_read (UINT32, & (timer -> value), local_value);
  *value = (bigtime_t)local_value * PLATFORM_TIMER_RES;
   10524:	e3a0300a 	mov	r3, #10
#include <Platform/Platform.h>

void cpu_timer_get (int32_t id, bigtime_t * value)
{
  uint32_t local_value = 0;
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[id];
   10528:	e59f2010 	ldr	r2, [pc, #16]	; 10540 <cpu_timer_get+0x1c>
   1052c:	e5922000 	ldr	r2, [r2]

  cpu_read (UINT32, & (timer -> value), local_value);
   10530:	e7922200 	ldr	r2, [r2, r0, lsl #4]
  *value = (bigtime_t)local_value * PLATFORM_TIMER_RES;
   10534:	e0832392 	umull	r2, r3, r2, r3
   10538:	e1c120f0 	strd	r2, [r1]
   1053c:	e12fff1e 	bx	lr
   10540:	0003e95c 	.word	0x0003e95c

00010544 <cpu_trap_enable>:
#include <Processor/Processor.h>

void cpu_trap_enable (interrupt_id_t id)
{
   10544:	e92d4010 	push	{r4, lr}
   10548:	e1a04000 	mov	r4, r0
  PLATFORM_AICU_BASE -> slot[cpu_mp_id ()] . mask |= 1 << id;
   1054c:	eb000025 	bl	105e8 <cpu_mp_id>
   10550:	e3a02001 	mov	r2, #1
   10554:	e59f3014 	ldr	r3, [pc, #20]	; 10570 <cpu_trap_enable+0x2c>
   10558:	e5933000 	ldr	r3, [r3]
   1055c:	e0830200 	add	r0, r3, r0, lsl #4
   10560:	e5901104 	ldr	r1, [r0, #260]	; 0x104
   10564:	e1814412 	orr	r4, r1, r2, lsl r4
   10568:	e5804104 	str	r4, [r0, #260]	; 0x104
   1056c:	e8bd8010 	pop	{r4, pc}
   10570:	0003e964 	.word	0x0003e964

00010574 <cpu_trap_restore>:
#include <Processor/Processor.h>

void cpu_trap_restore (interrupt_status_t backup)
{
  __asm__ volatile ("msr cpsr, %0" : : "r"(backup));
   10574:	e129f000 	msr	CPSR_fc, r0
   10578:	e12fff1e 	bx	lr

0001057c <cpu_power_wake_on_interrupt>:
#include <Processor/Processor.h>

void cpu_power_wake_on_interrupt (void)
{
   1057c:	e12fff1e 	bx	lr

00010580 <cpu_timer_set>:
#include <Platform/Platform.h>

void cpu_timer_set (int32_t id, bigtime_t deadline)
{
  bigtime_t local_deadline = 0;
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[id];
   10580:	e59f102c 	ldr	r1, [pc, #44]	; 105b4 <cpu_timer_set+0x34>

#include <Processor/Processor.h>
#include <Platform/Platform.h>

void cpu_timer_set (int32_t id, bigtime_t deadline)
{
   10584:	e92d4010 	push	{r4, lr}
  bigtime_t local_deadline = 0;
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[id];
   10588:	e5914000 	ldr	r4, [r1]

  local_deadline = deadline / PLATFORM_TIMER_RES;
   1058c:	e1a01003 	mov	r1, r3
#include <Platform/Platform.h>

void cpu_timer_set (int32_t id, bigtime_t deadline)
{
  bigtime_t local_deadline = 0;
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[id];
   10590:	e0844200 	add	r4, r4, r0, lsl #4

  local_deadline = deadline / PLATFORM_TIMER_RES;
   10594:	e3a03000 	mov	r3, #0
   10598:	e1a00002 	mov	r0, r2
   1059c:	e3a0200a 	mov	r2, #10
   105a0:	eb0012e5 	bl	1513c <__aeabi_ldivmod>

  cpu_write(UINT32, & (timer -> period), (uint32_t)local_deadline);
  cpu_write(UINT32, & (timer -> mode), 3);
   105a4:	e3a03003 	mov	r3, #3
  bigtime_t local_deadline = 0;
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[id];

  local_deadline = deadline / PLATFORM_TIMER_RES;

  cpu_write(UINT32, & (timer -> period), (uint32_t)local_deadline);
   105a8:	e5840008 	str	r0, [r4, #8]
  cpu_write(UINT32, & (timer -> mode), 3);
   105ac:	e5843004 	str	r3, [r4, #4]
   105b0:	e8bd8010 	pop	{r4, pc}
   105b4:	0003e95c 	.word	0x0003e95c

000105b8 <cpu_mp_wait>:
#include <Processor/Processor.h>
#include <Processor/Cache.h>

void cpu_mp_wait (void)
{
  cpu_mp_synchro = 1;
   105b8:	e3a03001 	mov	r3, #1
#include <stdint.h>
#include <Processor/Processor.h>
#include <Processor/Cache.h>

void cpu_mp_wait (void)
{
   105bc:	e92d4010 	push	{r4, lr}
  cpu_mp_synchro = 1;
   105c0:	e59f401c 	ldr	r4, [pc, #28]	; 105e4 <cpu_mp_wait+0x2c>
   105c4:	e5843000 	str	r3, [r4]

  /*
   * TODO: add WBFLUSH
   */
  do{
      cpu_dcache_invalidate((void*)&cpu_mp_synchro, sizeof(int32_t));
   105c8:	e59f0014 	ldr	r0, [pc, #20]	; 105e4 <cpu_mp_wait+0x2c>
   105cc:	e3a01004 	mov	r1, #4
   105d0:	eb00001a 	bl	10640 <cpu_dcache_invalidate>
  }while ((volatile int32_t)cpu_mp_synchro);
   105d4:	e5943000 	ldr	r3, [r4]
   105d8:	e3530000 	cmp	r3, #0
   105dc:	1afffff9 	bne	105c8 <cpu_mp_wait+0x10>
}
   105e0:	e8bd8010 	pop	{r4, pc}
   105e4:	0003dfe4 	.word	0x0003dfe4

000105e8 <cpu_mp_id>:

int32_t cpu_mp_id (void)
{
  register int32_t id = 0;

  __asm__ volatile (
   105e8:	ee100fb0 	mrc	15, 0, r0, cr0, cr0, {5}
      : "=r"(id)
      :
      );

  return id;
}
   105ec:	e12fff1e 	bx	lr

000105f0 <cpu_trap_attach_isr>:
#include <Processor/Processor.h>

void cpu_trap_attach_isr (int32_t cpuid, interrupt_id_t id,
    uint32_t mode, interrupt_handler_t isr)
{
  PLATFORM_AICU_BASE -> handlers[id] = (uint32_t) isr;
   105f0:	e59f200c 	ldr	r2, [pc, #12]	; 10604 <cpu_trap_attach_isr+0x14>
   105f4:	e2811004 	add	r1, r1, #4
   105f8:	e5922000 	ldr	r2, [r2]
   105fc:	e7823101 	str	r3, [r2, r1, lsl #2]
   10600:	e12fff1e 	bx	lr
   10604:	0003e964 	.word	0x0003e964

00010608 <cpu_test_and_set>:
#include<Processor/Cache.h>
long int cpu_test_and_set (volatile long int * spinlock)
{
   10608:	e92d4010 	push	{r4, lr}
  register long int ret, temp = 1; 

  cpu_dcache_invalidate((void*)spinlock,sizeof(long int));
   1060c:	e3a01004 	mov	r1, #4
#include<Processor/Cache.h>
long int cpu_test_and_set (volatile long int * spinlock)
{
   10610:	e1a04000 	mov	r4, r0
  register long int ret, temp = 1; 

  cpu_dcache_invalidate((void*)spinlock,sizeof(long int));
   10614:	eb000009 	bl	10640 <cpu_dcache_invalidate>
  __asm__ volatile
   10618:	e3a03001 	mov	r3, #1

0001061c <__start_tst>:
   1061c:	e1940f9f 	ldrex	r0, [r4]
   10620:	e3500000 	cmp	r0, #0
   10624:	01840f93 	strexeq	r0, r3, [r4]
     : "=&r" (ret), "=m" (*spinlock)
     : "r" (temp), "m" (*spinlock), "r"(spinlock)
     : "memory");

  return ret;
}
   10628:	e8bd8010 	pop	{r4, pc}

0001062c <cpu_compare_and_swap>:
     : "=&r" (ret)
     : "r" (oldval), "r" (newval), "r" (p_val)
     : "memory");

  return ret;
}
   1062c:	e1903f9f 	ldrex	r3, [r0]
   10630:	e1530001 	cmp	r3, r1
   10634:	01803f92 	strexeq	r3, r2, [r0]
   10638:	e1a00003 	mov	r0, r3
   1063c:	e12fff1e 	bx	lr

00010640 <cpu_dcache_invalidate>:
inline void cpu_dcache_invalidate(void * address, int32_t bytes)
{
    register int32_t count = 0;
    register uint32_t adjusted_address = (uint32_t)address & 0xFFFFFFE0UL; // Based on cache line size

    if (bytes == CPU_CACHE_ALL)
   10640:	e3710001 	cmn	r1, #1
   10644:	0a000015 	beq	106a0 <cpu_dcache_invalidate+0x60>
    {
        __asm__ volatile ("mcr p15, 0, %0, c7, c6, 0" : : "r"(count));
    }
    else
    {
        count = bytes >> CPU_DCACHE_SIZE_LOG2;
   10648:	e1a032c1 	asr	r3, r1, #5
#include <stdint.h>
#include <Processor/Processor.h>

inline void cpu_dcache_invalidate(void * address, int32_t bytes)
{
   1064c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
        __asm__ volatile ("mcr p15, 0, %0, c7, c6, 0" : : "r"(count));
    }
    else
    {
        count = bytes >> CPU_DCACHE_SIZE_LOG2;
        count += (bytes - (count << CPU_DCACHE_SIZE_LOG2) != 0) ? 1 : 0;
   10650:	e1a0e283 	lsl	lr, r3, #5

        if((((uint32_t)address + (bytes-1)) & 0x1F) < (bytes & 0x1FUL)){
   10654:	e241c001 	sub	ip, r1, #1
   10658:	e201201f 	and	r2, r1, #31
        __asm__ volatile ("mcr p15, 0, %0, c7, c6, 0" : : "r"(count));
    }
    else
    {
        count = bytes >> CPU_DCACHE_SIZE_LOG2;
        count += (bytes - (count << CPU_DCACHE_SIZE_LOG2) != 0) ? 1 : 0;
   1065c:	e15e0001 	cmp	lr, r1
   10660:	01a01003 	moveq	r1, r3
   10664:	12831001 	addne	r1, r3, #1

        if((((uint32_t)address + (bytes-1)) & 0x1F) < (bytes & 0x1FUL)){
   10668:	e080c00c 	add	ip, r0, ip
   1066c:	e20cc01f 	and	ip, ip, #31
   10670:	e15c0002 	cmp	ip, r2
            count++;
   10674:	32811001 	addcc	r1, r1, #1
        }


        for (register int32_t i = 0; i < count; i += 1)
   10678:	e3510000 	cmp	r1, #0
   1067c:	d49df004 	pople	{pc}		; (ldrle pc, [sp], #4)
   10680:	e3a03000 	mov	r3, #0
#include <Processor/Processor.h>

inline void cpu_dcache_invalidate(void * address, int32_t bytes)
{
    register int32_t count = 0;
    register uint32_t adjusted_address = (uint32_t)address & 0xFFFFFFE0UL; // Based on cache line size
   10684:	e3c0001f 	bic	r0, r0, #31
        }


        for (register int32_t i = 0; i < count; i += 1)
        {
            __asm__ volatile ("mcr p15, 0, %0, c7, c6, 1"
   10688:	ee070f36 	mcr	15, 0, r0, cr7, cr6, {1}
        if((((uint32_t)address + (bytes-1)) & 0x1F) < (bytes & 0x1FUL)){
            count++;
        }


        for (register int32_t i = 0; i < count; i += 1)
   1068c:	e2833001 	add	r3, r3, #1
   10690:	e1530001 	cmp	r3, r1
        {
            __asm__ volatile ("mcr p15, 0, %0, c7, c6, 1"
                    :
                    : "r"(adjusted_address));
            adjusted_address += 1 << CPU_DCACHE_SIZE_LOG2;
   10694:	e2800020 	add	r0, r0, #32
        if((((uint32_t)address + (bytes-1)) & 0x1F) < (bytes & 0x1FUL)){
            count++;
        }


        for (register int32_t i = 0; i < count; i += 1)
   10698:	1afffffa 	bne	10688 <cpu_dcache_invalidate+0x48>
   1069c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    register int32_t count = 0;
    register uint32_t adjusted_address = (uint32_t)address & 0xFFFFFFE0UL; // Based on cache line size

    if (bytes == CPU_CACHE_ALL)
    {
        __asm__ volatile ("mcr p15, 0, %0, c7, c6, 0" : : "r"(count));
   106a0:	e3a03000 	mov	r3, #0
   106a4:	ee073f16 	mcr	15, 0, r3, cr7, cr6, {0}
   106a8:	e12fff1e 	bx	lr

000106ac <cpu_destroy>:
 */

#include <Processor/Processor.h>

void cpu_destroy (void)
{
   106ac:	e12fff1e 	bx	lr

000106b0 <cpu_trap_attach_esr>:
#include <Processor/Processor.h>

void cpu_trap_attach_esr (int32_t cpuid, exception_id_t id,
    exception_handler_t isr)
{
   106b0:	e12fff1e 	bx	lr

000106b4 <cpu_mp_count>:

extern int32_t CPU_ARMV6_COUNT;

int32_t cpu_mp_count (void)
{
  return CPU_ARMV6_COUNT;
   106b4:	e59f3004 	ldr	r3, [pc, #4]	; 106c0 <cpu_mp_count+0xc>
}
   106b8:	e5930000 	ldr	r0, [r3]
   106bc:	e12fff1e 	bx	lr
   106c0:	0003e950 	.word	0x0003e950

000106c4 <cpu_stop>:
 */

#include <Processor/Processor.h>

void cpu_stop (void)
{
   106c4:	e12fff1e 	bx	lr

000106c8 <thread_wait>:

{
  status_t status = DNA_OK;
  uint32_t current_cpuid = 0;
  thread_t self = NULL;
  thread_t thread = NULL, target = NULL;
   106c8:	e3a03000 	mov	r3, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   106cc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
   106d0:	e1a02820 	lsr	r2, r0, #16
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   106d4:	e24dd01c 	sub	sp, sp, #28
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
   106d8:	e31200ff 	tst	r2, #255	; 0xff
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   106dc:	e1a04000 	mov	r4, r0
  status_t status = DNA_OK;
  uint32_t current_cpuid = 0;
  thread_t self = NULL;
  thread_t thread = NULL, target = NULL;
   106e0:	e58d3014 	str	r3, [sp, #20]
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
   106e4:	0a000002 	beq	106f4 <thread_wait+0x2c>
   106e8:	e59f01b4 	ldr	r0, [pc, #436]	; 108a4 <thread_wait+0x1dc>
  {
    lock_release (& thread_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
   106ec:	e28dd01c 	add	sp, sp, #28
   106f0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    ensure (tid . s . index >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . index < DNA_MAX_THREAD, DNA_BAD_ARGUMENT);
   106f4:	e1a06c20 	lsr	r6, r0, #24
   106f8:	e356003f 	cmp	r6, #63	; 0x3f
   106fc:	8afffff9 	bhi	106e8 <thread_wait+0x20>
   10700:	e1a05001 	mov	r5, r1

    /*
     * Get information about the current execution.
     */

    it_status = cpu_trap_mask_and_backup();
   10704:	ebffff61 	bl	10490 <cpu_trap_mask_and_backup>
     */

    lock_acquire (& thread_pool . lock);
    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
   10708:	e3a0b0d0 	mov	fp, #208	; 0xd0

    /*
     * Get information about the current execution.
     */

    it_status = cpu_trap_mask_and_backup();
   1070c:	e1a08000 	mov	r8, r0
    current_cpuid = cpu_mp_id ();
   10710:	ebffffb4 	bl	105e8 <cpu_mp_id>
     */

    lock_acquire (& thread_pool . lock);
    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
   10714:	e00b069b 	mul	fp, fp, r6

    /*
     * Get the thread corresponding to ID.
     */

    lock_acquire (& thread_pool . lock);
   10718:	e59f7188 	ldr	r7, [pc, #392]	; 108a8 <thread_wait+0x1e0>
     * Get information about the current execution.
     */

    it_status = cpu_trap_mask_and_backup();
    current_cpuid = cpu_mp_id ();
    self = cpu_pool . cpu[current_cpuid] . current_thread;
   1071c:	e59f3188 	ldr	r3, [pc, #392]	; 108ac <thread_wait+0x1e4>
   10720:	e0800180 	add	r0, r0, r0, lsl #3
   10724:	e0833300 	add	r3, r3, r0, lsl #6

    /*
     * Get the thread corresponding to ID.
     */

    lock_acquire (& thread_pool . lock);
   10728:	e1a00007 	mov	r0, r7
     * Get information about the current execution.
     */

    it_status = cpu_trap_mask_and_backup();
    current_cpuid = cpu_mp_id ();
    self = cpu_pool . cpu[current_cpuid] . current_thread;
   1072c:	e593922c 	ldr	r9, [r3, #556]	; 0x22c

    /*
     * Get the thread corresponding to ID.
     */

    lock_acquire (& thread_pool . lock);
   10730:	eb0000a2 	bl	109c0 <lock_acquire>
    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
   10734:	e087300b 	add	r3, r7, fp
   10738:	e5931024 	ldr	r1, [r3, #36]	; 0x24
   1073c:	e2832020 	add	r2, r3, #32
   10740:	e1540001 	cmp	r4, r1
   10744:	159f4164 	ldrne	r4, [pc, #356]	; 108b0 <thread_wait+0x1e8>
   10748:	0a000005 	beq	10764 <thread_wait+0x9c>
    leave;
  }

  rescue (bad_thread)
  {
    lock_release (& thread_pool . lock);
   1074c:	e59f0154 	ldr	r0, [pc, #340]	; 108a8 <thread_wait+0x1e0>
   10750:	eb000b4e 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   10754:	e1a00008 	mov	r0, r8
   10758:	ebffff85 	bl	10574 <cpu_trap_restore>
    leave;
   1075c:	e1a00004 	mov	r0, r4
   10760:	eaffffe1 	b	106ec <thread_wait+0x24>
    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
        thread -> id . raw == tid . raw, DNA_INVALID_THREAD_ID);

    lock_acquire (& thread -> lock);
   10764:	e283a01c 	add	sl, r3, #28
   10768:	e1a0000a 	mov	r0, sl
   1076c:	e58d3004 	str	r3, [sp, #4]
   10770:	e58d2008 	str	r2, [sp, #8]
   10774:	eb000091 	bl	109c0 <lock_acquire>
    lock_release (& thread_pool . lock);
   10778:	e1a00007 	mov	r0, r7
   1077c:	eb000b43 	bl	13490 <lock_release>

    /*
     * If the thread is already dead, it is not necessary to
     * go through all the rescheduling pain
     */
    cpu_dcache_invalidate((void*)&thread->info.status,sizeof(uint32_t));   
   10780:	e28b0058 	add	r0, fp, #88	; 0x58
   10784:	e3a01004 	mov	r1, #4
   10788:	e0870000 	add	r0, r7, r0
   1078c:	ebffffab 	bl	10640 <cpu_dcache_invalidate>
    if (thread -> info . status != DNA_THREAD_ENDED)
   10790:	e59d3004 	ldr	r3, [sp, #4]
   10794:	e59fc118 	ldr	ip, [pc, #280]	; 108b4 <thread_wait+0x1ec>
   10798:	e1d315b8 	ldrh	r1, [r3, #88]	; 0x58
   1079c:	e151000c 	cmp	r1, ip
   107a0:	0a000034 	beq	10878 <thread_wait+0x1b0>
    {
      lock_acquire (& thread -> wait . lock);
   107a4:	e087b00b 	add	fp, r7, fp
   107a8:	e28bb00c 	add	fp, fp, #12
   107ac:	e1a0000b 	mov	r0, fp
   107b0:	e58dc00c 	str	ip, [sp, #12]
   107b4:	eb000081 	bl	109c0 <lock_acquire>
      lock_release (& thread -> lock);
   107b8:	e1a0000a 	mov	r0, sl
   107bc:	eb000b33 	bl	13490 <lock_release>

      /*
       * If not, put ourselve in wait mode
       */

      lock_acquire (& self -> lock);
   107c0:	e2890014 	add	r0, r9, #20
   107c4:	eb00007d 	bl	109c0 <lock_acquire>

      self -> resource_queue = & thread -> wait;
      self -> info . status = DNA_THREAD_WAITING;
      self -> info . resource = DNA_RESOURCE_THREAD;
   107c8:	e3a00002 	mov	r0, #2
       */

      lock_acquire (& self -> lock);

      self -> resource_queue = & thread -> wait;
      self -> info . status = DNA_THREAD_WAITING;
   107cc:	e59f10e4 	ldr	r1, [pc, #228]	; 108b8 <thread_wait+0x1f0>
      self -> info . resource = DNA_RESOURCE_THREAD;
   107d0:	e5c90052 	strb	r0, [r9, #82]	; 0x52
       */

      lock_acquire (& self -> lock);

      self -> resource_queue = & thread -> wait;
      self -> info . status = DNA_THREAD_WAITING;
   107d4:	e1c915b0 	strh	r1, [r9, #80]	; 0x50
       * If not, put ourselve in wait mode
       */

      lock_acquire (& self -> lock);

      self -> resource_queue = & thread -> wait;
   107d8:	e589b018 	str	fp, [r9, #24]

      /*
       * Elect a potential target thread.
       */

      status = scheduler_elect (& target, true);
   107dc:	e3a01001 	mov	r1, #1
      lock_acquire (& self -> lock);

      self -> resource_queue = & thread -> wait;
      self -> info . status = DNA_THREAD_WAITING;
      self -> info . resource = DNA_RESOURCE_THREAD;
      self -> info . resource_id = tid . raw;
   107e0:	e5894054 	str	r4, [r9, #84]	; 0x54

      /*
       * Elect a potential target thread.
       */

      status = scheduler_elect (& target, true);
   107e4:	e28d0014 	add	r0, sp, #20
   107e8:	eb000794 	bl	12640 <scheduler_elect>
      ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);
   107ec:	e59fe0b0 	ldr	lr, [pc, #176]	; 108a4 <thread_wait+0x1dc>
   107f0:	e59f10c4 	ldr	r1, [pc, #196]	; 108bc <thread_wait+0x1f4>
   107f4:	e1500001 	cmp	r0, r1
   107f8:	1150000e 	cmpne	r0, lr
   107fc:	0affffba 	beq	106ec <thread_wait+0x24>

      /*
       * Add self into the ready queue.
       */

      queue_add (& thread -> wait, self);
   10800:	e1a01009 	mov	r1, r9
   10804:	e1a0000b 	mov	r0, fp
   10808:	ebfffd81 	bl	fe14 <queue_add>

      /*
       * Reschedule self.
       */

      status = scheduler_switch (target, & thread -> wait);
   1080c:	e1a0100b 	mov	r1, fp
   10810:	e59d0014 	ldr	r0, [sp, #20]
   10814:	eb00098f 	bl	12e58 <scheduler_switch>
      ensure (status == DNA_OK, status);
   10818:	e3500000 	cmp	r0, #0
   1081c:	1affffb2 	bne	106ec <thread_wait+0x24>

      /*
       * Check if the thread has not been destroyed.
       */

      lock_acquire (& thread_pool . lock);
   10820:	e1a00007 	mov	r0, r7
   10824:	eb000065 	bl	109c0 <lock_acquire>
      thread = & thread_pool . data[tid . s . group][tid . s . index];

      check (bad_thread, thread != NULL &&
   10828:	e59d2008 	ldr	r2, [sp, #8]
   1082c:	e5922004 	ldr	r2, [r2, #4]
   10830:	e1540002 	cmp	r4, r2
   10834:	159f4084 	ldrne	r4, [pc, #132]	; 108c0 <thread_wait+0x1f8>
   10838:	1affffc3 	bne	1074c <thread_wait+0x84>
        thread -> id . raw == tid . raw , DNA_THREAD_DESTROYED);

      lock_acquire (& thread -> lock);
   1083c:	e1a0000a 	mov	r0, sl
   10840:	eb00005e 	bl	109c0 <lock_acquire>
      lock_release (& thread_pool . lock);
   10844:	e1a00007 	mov	r0, r7
   10848:	eb000b10 	bl	13490 <lock_release>

      /*
       * Check if we are here as a result of thread_suspend/thread_resume.
       */

      check (bad_status,
   1084c:	e59d3004 	ldr	r3, [sp, #4]
   10850:	e59dc00c 	ldr	ip, [sp, #12]
   10854:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
   10858:	e153000c 	cmp	r3, ip
   1085c:	0a000005 	beq	10878 <thread_wait+0x1b0>
    return status;
  }

  rescue (bad_status)
  {
    lock_release (& thread -> lock);
   10860:	e1a0000a 	mov	r0, sl
   10864:	eb000b09 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   10868:	e1a00008 	mov	r0, r8
   1086c:	ebffff40 	bl	10574 <cpu_trap_restore>
    leave;
   10870:	e59f004c 	ldr	r0, [pc, #76]	; 108c4 <thread_wait+0x1fc>
   10874:	eaffff9c 	b	106ec <thread_wait+0x24>

      check (bad_status,
          thread -> info . status == DNA_THREAD_ENDED, DNA_INTERRUPTED);
    }
    
    if (value != NULL)
   10878:	e3550000 	cmp	r5, #0
    {
      *value = thread -> signature . return_value;
   1087c:	13a030d0 	movne	r3, #208	; 0xd0
   10880:	10267693 	mlane	r6, r3, r6, r7
   10884:	15963088 	ldrne	r3, [r6, #136]	; 0x88
    }

    lock_release (& thread -> lock);
   10888:	e1a0000a 	mov	r0, sl
          thread -> info . status == DNA_THREAD_ENDED, DNA_INTERRUPTED);
    }
    
    if (value != NULL)
    {
      *value = thread -> signature . return_value;
   1088c:	15853000 	strne	r3, [r5]
    }

    lock_release (& thread -> lock);
   10890:	eb000afe 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   10894:	e1a00008 	mov	r0, r8
   10898:	ebffff35 	bl	10574 <cpu_trap_restore>
    return status;
   1089c:	e3a00000 	mov	r0, #0
   108a0:	eaffff91 	b	106ec <thread_wait+0x24>
   108a4:	0000fffc 	.word	0x0000fffc
   108a8:	00184fd0 	.word	0x00184fd0
   108ac:	001883e8 	.word	0x001883e8
   108b0:	0000fcfe 	.word	0x0000fcfe
   108b4:	0000dead 	.word	0x0000dead
   108b8:	ffffb10c 	.word	0xffffb10c
   108bc:	0000ffff 	.word	0x0000ffff
   108c0:	0000fcfb 	.word	0x0000fcfb
   108c4:	0000fff9 	.word	0x0000fff9

000108c8 <core_stop>:
 * SOURCE
 */

{
  return DNA_NOT_IMPLEMENTED;
}
   108c8:	e59f0000 	ldr	r0, [pc]	; 108d0 <core_stop+0x8>
   108cc:	e12fff1e 	bx	lr
   108d0:	0000fffe 	.word	0x0000fffe

000108d4 <thread_resume>:
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
   108d4:	e1a03820 	lsr	r3, r0, #16
   108d8:	e31300ff 	tst	r3, #255	; 0xff
 * * DNA_OK: success, the thread has been rescheduled
 *
 * SOURCE
 */

{
   108dc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
   108e0:	e1a04000 	mov	r4, r0
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
   108e4:	0a000001 	beq	108f0 <thread_resume+0x1c>
   108e8:	e59f00b8 	ldr	r0, [pc, #184]	; 109a8 <thread_resume+0xd4>
  {
    cpu_trap_restore (it_status);
    lock_release (& thread_pool . lock);
    leave;
  }
}
   108ec:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    ensure (tid . s . index >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . index < DNA_MAX_THREAD, DNA_BAD_ARGUMENT);
   108f0:	e1a05c20 	lsr	r5, r0, #24
   108f4:	e355003f 	cmp	r5, #63	; 0x3f
   108f8:	8afffffa 	bhi	108e8 <thread_resume+0x14>
    /*
     * Get the thread corresponding to the current id
     * and check the thread's status.
     */

    it_status = cpu_trap_mask_and_backup();
   108fc:	ebfffee3 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& thread_pool . lock);
   10900:	e59f60a4 	ldr	r6, [pc, #164]	; 109ac <thread_resume+0xd8>
    /*
     * Get the thread corresponding to the current id
     * and check the thread's status.
     */

    it_status = cpu_trap_mask_and_backup();
   10904:	e1a08000 	mov	r8, r0
    lock_acquire (& thread_pool . lock);
   10908:	e1a00006 	mov	r0, r6
   1090c:	eb00002b 	bl	109c0 <lock_acquire>

    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
   10910:	e3a030d0 	mov	r3, #208	; 0xd0
   10914:	e0050593 	mul	r5, r3, r5
   10918:	e0867005 	add	r7, r6, r5
   1091c:	e5973024 	ldr	r3, [r7, #36]	; 0x24
   10920:	e1540003 	cmp	r4, r3
   10924:	159f4084 	ldrne	r4, [pc, #132]	; 109b0 <thread_resume+0xdc>
   10928:	0a000005 	beq	10944 <thread_resume+0x70>
    lock_release (& thread -> lock);
  }

  rescue (bad_thread)
  {
    cpu_trap_restore (it_status);
   1092c:	e1a00008 	mov	r0, r8
   10930:	ebffff0f 	bl	10574 <cpu_trap_restore>
    lock_release (& thread_pool . lock);
   10934:	e59f0070 	ldr	r0, [pc, #112]	; 109ac <thread_resume+0xd8>
   10938:	eb000ad4 	bl	13490 <lock_release>
    leave;
   1093c:	e1a00004 	mov	r0, r4
   10940:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
        thread -> id . raw == tid . raw , DNA_INVALID_THREAD_ID);

    lock_acquire (& thread -> lock);
   10944:	e287401c 	add	r4, r7, #28
   10948:	e1a00004 	mov	r0, r4
   1094c:	eb00001b 	bl	109c0 <lock_acquire>
    lock_release (& thread_pool . lock);
   10950:	e1a00006 	mov	r0, r6
   10954:	eb000acd 	bl	13490 <lock_release>

    check (bad_status,
   10958:	e1d725b8 	ldrh	r2, [r7, #88]	; 0x58
   1095c:	e59f3050 	ldr	r3, [pc, #80]	; 109b4 <thread_resume+0xe0>
   10960:	e1520003 	cmp	r2, r3
   10964:	0a000003 	beq	10978 <thread_resume+0xa4>
    return status == DNA_INVOKE_SCHEDULER ? DNA_NO_ERROR : DNA_OK;
  }

  rescue (bad_status)
  {
    lock_release (& thread -> lock);
   10968:	e1a00004 	mov	r0, r4
   1096c:	eb000ac7 	bl	13490 <lock_release>
        thread -> id . raw == tid . raw , DNA_INVALID_THREAD_ID);

    lock_acquire (& thread -> lock);
    lock_release (& thread_pool . lock);

    check (bad_status,
   10970:	e59f4040 	ldr	r4, [pc, #64]	; 109b8 <thread_resume+0xe4>
   10974:	eaffffec 	b	1092c <thread_resume+0x58>

    /*
     * Update the thread information and resume it.
     */

    thread -> info . status = DNA_THREAD_READY;
   10978:	e59f303c 	ldr	r3, [pc, #60]	; 109bc <thread_resume+0xe8>
     */

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& thread_pool . lock);

    thread = & thread_pool . data[tid . s . group][tid . s . index];
   1097c:	e2850008 	add	r0, r5, #8

    /*
     * Update the thread information and resume it.
     */

    thread -> info . status = DNA_THREAD_READY;
   10980:	e1c735b8 	strh	r3, [r7, #88]	; 0x58
    status = scheduler_dispatch (thread);
   10984:	e0860000 	add	r0, r6, r0
   10988:	eb000766 	bl	12728 <scheduler_dispatch>
   1098c:	e1a04000 	mov	r4, r0
     * Latency should NOT appear on RR or RT scheduling methods.
     * We return the dispatch status anyway, so the user can adapt
     * its code accordingly, and call thread_yield himself.
     */

    cpu_trap_restore (it_status);
   10990:	e1a00008 	mov	r0, r8
   10994:	ebfffef6 	bl	10574 <cpu_trap_restore>
    return status == DNA_INVOKE_SCHEDULER ? DNA_NO_ERROR : DNA_OK;
   10998:	e2440003 	sub	r0, r4, #3
   1099c:	e16f0f10 	clz	r0, r0
   109a0:	e1a002a0 	lsr	r0, r0, #5
   109a4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
   109a8:	0000fffc 	.word	0x0000fffc
   109ac:	00184fd0 	.word	0x00184fd0
   109b0:	0000fcfe 	.word	0x0000fcfe
   109b4:	0000d15a 	.word	0x0000d15a
   109b8:	0000ffff 	.word	0x0000ffff
   109bc:	ffffface 	.word	0xffffface

000109c0 <lock_acquire>:
 * Lock a spin lock using the cpu_test_and_set function from the HAL.
 *
 * SOURCE
 */

{
   109c0:	e92d4010 	push	{r4, lr}
   109c4:	e1a04000 	mov	r4, r0
   109c8:	e24dd008 	sub	sp, sp, #8
  while (cpu_test_and_set (lock) == 1);
   109cc:	e1a00004 	mov	r0, r4
   109d0:	ebffff0c 	bl	10608 <cpu_test_and_set>
   109d4:	e3500001 	cmp	r0, #1
   109d8:	0afffffb 	beq	109cc <lock_acquire+0xc>
  cpu_cache_sync ();
   109dc:	e3a03000 	mov	r3, #0
   109e0:	e58d3004 	str	r3, [sp, #4]
   109e4:	e59d3004 	ldr	r3, [sp, #4]
   109e8:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
}
   109ec:	e28dd008 	add	sp, sp, #8
   109f0:	e8bd8010 	pop	{r4, pc}

000109f4 <thread_idle>:
 * Ignored.
 *
 * SOURCE
 */

{
   109f4:	e92d4008 	push	{r3, lr}
  while (true)
  {
    cpu_power_wake_on_interrupt ();
   109f8:	ebfffedf 	bl	1057c <cpu_power_wake_on_interrupt>
  }
   109fc:	eafffffd 	b	109f8 <thread_idle+0x4>

00010a00 <semaphore_get_info>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   10a00:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (info != NULL, DNA_BAD_ARGUMENT);
   10a04:	e2516000 	subs	r6, r1, #0
   10a08:	0a000005 	beq	10a24 <semaphore_get_info+0x24>
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);
   10a0c:	e1a05820 	lsr	r5, r0, #16
   10a10:	e3550a01 	cmp	r5, #4096	; 0x1000
   10a14:	e1a04000 	mov	r4, r0
   10a18:	3a000003 	bcc	10a2c <semaphore_get_info+0x2c>
   10a1c:	e59f00a4 	ldr	r0, [pc, #164]	; 10ac8 <semaphore_get_info+0xc8>
  {
    lock_release (& semaphore_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
   10a20:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (info != NULL, DNA_BAD_ARGUMENT);
   10a24:	e59f00a0 	ldr	r0, [pc, #160]	; 10acc <semaphore_get_info+0xcc>
   10a28:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
   10a2c:	ebfffe97 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& semaphore_pool . lock);
   10a30:	e59f7098 	ldr	r7, [pc, #152]	; 10ad0 <semaphore_get_info+0xd0>
     * Look for the semaphore with ID id
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
   10a34:	e0855205 	add	r5, r5, r5, lsl #4
   10a38:	e1a05105 	lsl	r5, r5, #2
  watch (status_t)
  {
    ensure (info != NULL, DNA_BAD_ARGUMENT);
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
   10a3c:	e1a08000 	mov	r8, r0
     * Look for the semaphore with ID id
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
   10a40:	e0879005 	add	r9, r7, r5
  {
    ensure (info != NULL, DNA_BAD_ARGUMENT);
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& semaphore_pool . lock);
   10a44:	e1a00007 	mov	r0, r7
   10a48:	ebffffdc 	bl	109c0 <lock_acquire>
     * Look for the semaphore with ID id
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
   10a4c:	e599300c 	ldr	r3, [r9, #12]
   10a50:	e1540003 	cmp	r4, r3
   10a54:	0a000005 	beq	10a70 <semaphore_get_info+0x70>
    return status;
  }

  rescue (invalid_semaphore)
  {
    lock_release (& semaphore_pool . lock);
   10a58:	e1a00007 	mov	r0, r7
   10a5c:	eb000a8b 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   10a60:	e1a00008 	mov	r0, r8
   10a64:	ebfffec2 	bl	10574 <cpu_trap_restore>
    leave;
   10a68:	e59f0058 	ldr	r0, [pc, #88]	; 10ac8 <semaphore_get_info+0xc8>
   10a6c:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);

    lock_acquire (& sem -> lock);
   10a70:	e2854010 	add	r4, r5, #16
   10a74:	e0844007 	add	r4, r4, r7
   10a78:	e1a00004 	mov	r0, r4
   10a7c:	ebffffcf 	bl	109c0 <lock_acquire>
    lock_release (& semaphore_pool . lock);
   10a80:	e1a00007 	mov	r0, r7
   10a84:	eb000a81 	bl	13490 <lock_release>
//    cpu_dcache_inv_addr(&sem -> info.tokens);

dna_log(VERBOSE_LEVEL, "ID(%d:%d) TOKEN(%d)",
        sem -> id . s . value, sem -> id . s . index, sem -> info . tokens);

    cpu_dcache_invalidate((void*)&sem->info, sizeof(port_info_t));
   10a88:	e2890024 	add	r0, r9, #36	; 0x24
   10a8c:	e3a0102c 	mov	r1, #44	; 0x2c
   10a90:	ebfffeea 	bl	10640 <cpu_dcache_invalidate>
    *info = sem -> info;
   10a94:	e289c024 	add	ip, r9, #36	; 0x24
   10a98:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
   10a9c:	e8a6000f 	stmia	r6!, {r0, r1, r2, r3}
   10aa0:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
   10aa4:	e8a6000f 	stmia	r6!, {r0, r1, r2, r3}
   10aa8:	e89c0003 	ldm	ip, {r0, r1}
   10aac:	e8860003 	stm	r6, {r0, r1}

    lock_release (& sem -> lock);
   10ab0:	e1a00004 	mov	r0, r4
   10ab4:	eb000a75 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   10ab8:	e1a00008 	mov	r0, r8
   10abc:	ebfffeac 	bl	10574 <cpu_trap_restore>

    return status;
   10ac0:	e3a00000 	mov	r0, #0
   10ac4:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
   10ac8:	0000fdff 	.word	0x0000fdff
   10acc:	0000fffc 	.word	0x0000fffc
   10ad0:	0013f5a0 	.word	0x0013f5a0

00010ad4 <port_find>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   10ad4:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
  int32_t index;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (p_id != NULL, DNA_BAD_ARGUMENT);
   10ad8:	e2518000 	subs	r8, r1, #0
   10adc:	0a00001a 	beq	10b4c <port_find+0x78>
   10ae0:	e1a06000 	mov	r6, r0

    /*
     * Find the requested port.
     */

    it_status = cpu_trap_mask_and_backup();
   10ae4:	ebfffe69 	bl	10490 <cpu_trap_mask_and_backup>
   10ae8:	e1a09000 	mov	r9, r0
    lock_acquire (& port_pool . lock);
   10aec:	e59f0078 	ldr	r0, [pc, #120]	; 10b6c <port_find+0x98>
   10af0:	ebffffb2 	bl	109c0 <lock_acquire>

    for (index = 0; index < DNA_MAX_PORT; index += 1)
   10af4:	e3a04000 	mov	r4, #0
   10af8:	e59f5070 	ldr	r5, [pc, #112]	; 10b70 <port_find+0x9c>
   10afc:	ea000003 	b	10b10 <port_find+0x3c>
   10b00:	e2844001 	add	r4, r4, #1
   10b04:	e3540040 	cmp	r4, #64	; 0x40
   10b08:	e2855068 	add	r5, r5, #104	; 0x68
   10b0c:	0a000010 	beq	10b54 <port_find+0x80>
    {
      port = & port_pool . data[index];

      if (port != NULL && dna_strcmp (name, port -> info . name) == 0)
   10b10:	e1a00006 	mov	r0, r6
   10b14:	e1a01005 	mov	r1, r5
   10b18:	ebfffce8 	bl	fec0 <dna_strcmp>
   10b1c:	e2507000 	subs	r7, r0, #0
   10b20:	1afffff6 	bne	10b00 <port_find+0x2c>
      {
        *p_id = port -> id . raw;
   10b24:	e3a02068 	mov	r2, #104	; 0x68
   10b28:	e59f003c 	ldr	r0, [pc, #60]	; 10b6c <port_find+0x98>
   10b2c:	e0240492 	mla	r4, r2, r4, r0
   10b30:	e594200c 	ldr	r2, [r4, #12]
   10b34:	e5882000 	str	r2, [r8]
        break;
      }
    }

    lock_release (& port_pool . lock);
   10b38:	eb000a54 	bl	13490 <lock_release>
    cpu_trap_restore (it_status);
   10b3c:	e1a00009 	mov	r0, r9
   10b40:	ebfffe8b 	bl	10574 <cpu_trap_restore>

    ensure (index != DNA_MAX_PORT, DNA_UNKNOWN_PORT);
    return DNA_OK;
   10b44:	e1a00007 	mov	r0, r7
   10b48:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  int32_t index;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (p_id != NULL, DNA_BAD_ARGUMENT);
   10b4c:	e59f0020 	ldr	r0, [pc, #32]	; 10b74 <port_find+0xa0>
   10b50:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
        *p_id = port -> id . raw;
        break;
      }
    }

    lock_release (& port_pool . lock);
   10b54:	e59f0010 	ldr	r0, [pc, #16]	; 10b6c <port_find+0x98>
   10b58:	eb000a4c 	bl	13490 <lock_release>
    cpu_trap_restore (it_status);
   10b5c:	e1a00009 	mov	r0, r9
   10b60:	ebfffe83 	bl	10574 <cpu_trap_restore>

    ensure (index != DNA_MAX_PORT, DNA_UNKNOWN_PORT);
   10b64:	e59f000c 	ldr	r0, [pc, #12]	; 10b78 <port_find+0xa4>
    return DNA_OK;
  }
}
   10b68:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
   10b6c:	001835b8 	.word	0x001835b8
   10b70:	001835d0 	.word	0x001835d0
   10b74:	0000fffc 	.word	0x0000fffc
   10b78:	0000fafd 	.word	0x0000fafd

00010b7c <lock_destroy>:
 *
 * SOURCE
 */

{
  *lock = -1;
   10b7c:	e3e03000 	mvn	r3, #0
   10b80:	e5803000 	str	r3, [r0]
   10b84:	e12fff1e 	bx	lr

00010b88 <interrupt_handler_inspector>:
  isr_t service = isr;
  interrupt_handler_t handler = va_arg (list, interrupt_handler_t);

  watch (bool)
  {
    ensure (isr != NULL, false);
   10b88:	e3500000 	cmp	r0, #0
 * SOURCE
 */

{
  isr_t service = isr;
  interrupt_handler_t handler = va_arg (list, interrupt_handler_t);
   10b8c:	e5913000 	ldr	r3, [r1]

  watch (bool)
  {
    ensure (isr != NULL, false);
   10b90:	012fff1e 	bxeq	lr
    ensure (handler != NULL, false);
   10b94:	e3530000 	cmp	r3, #0

    return service -> handler == (interrupt_handler_t)handler;
   10b98:	15900004 	ldrne	r0, [r0, #4]
   10b9c:	10630000 	rsbne	r0, r3, r0
   10ba0:	116f0f10 	clzne	r0, r0
   10ba4:	11a002a0 	lsrne	r0, r0, #5
  isr_t service = isr;
  interrupt_handler_t handler = va_arg (list, interrupt_handler_t);

  watch (bool)
  {
    ensure (isr != NULL, false);
   10ba8:	01a00003 	moveq	r0, r3
    ensure (handler != NULL, false);

    return service -> handler == (interrupt_handler_t)handler;
  }
}
   10bac:	e12fff1e 	bx	lr

00010bb0 <semaphore_destroy>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   10bb0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  bool smart_to_reschedule = false;
  status_t status;

  watch (status_t)
  {
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);
   10bb4:	e1a04820 	lsr	r4, r0, #16
   10bb8:	e3540a01 	cmp	r4, #4096	; 0x1000
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   10bbc:	e1a06000 	mov	r6, r0
   10bc0:	e24dd00c 	sub	sp, sp, #12
  bool smart_to_reschedule = false;
  status_t status;

  watch (status_t)
  {
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);
   10bc4:	259f012c 	ldrcs	r0, [pc, #300]	; 10cf8 <semaphore_destroy+0x148>
   10bc8:	3a000001 	bcc	10bd4 <semaphore_destroy+0x24>
  {
    lock_release (& semaphore_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
   10bcc:	e28dd00c 	add	sp, sp, #12
   10bd0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

  watch (status_t)
  {
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
   10bd4:	ebfffe2d 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& semaphore_pool . lock);
   10bd8:	e59f511c 	ldr	r5, [pc, #284]	; 10cfc <semaphore_destroy+0x14c>
     * remove its entry from the pool.
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
   10bdc:	e1a08204 	lsl	r8, r4, #4
   10be0:	e0887004 	add	r7, r8, r4

  watch (status_t)
  {
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
   10be4:	e1a09000 	mov	r9, r0
     * remove its entry from the pool.
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
   10be8:	e1a07107 	lsl	r7, r7, #2
  watch (status_t)
  {
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& semaphore_pool . lock);
   10bec:	e1a00005 	mov	r0, r5
   10bf0:	ebffff72 	bl	109c0 <lock_acquire>
     * remove its entry from the pool.
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
   10bf4:	e0853007 	add	r3, r5, r7
   10bf8:	e593200c 	ldr	r2, [r3, #12]
   10bfc:	e1560002 	cmp	r6, r2
   10c00:	0a000006 	beq	10c20 <semaphore_destroy+0x70>
    return smart_to_reschedule ? DNA_INVOKE_SCHEDULER : DNA_OK;
  }

  rescue (invalid_semaphore)
  {
    lock_release (& semaphore_pool . lock);
   10c04:	e1a00005 	mov	r0, r5
   10c08:	eb000a20 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   10c0c:	e1a00009 	mov	r0, r9
   10c10:	ebfffe57 	bl	10574 <cpu_trap_restore>
    leave;
   10c14:	e59f00dc 	ldr	r0, [pc, #220]	; 10cf8 <semaphore_destroy+0x148>
  }
}
   10c18:	e28dd00c 	add	sp, sp, #12
   10c1c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);

    semaphore_pool . data[sid . s . index] . id . s . value = 0;
   10c20:	e3a02000 	mov	r2, #0

    lock_acquire (& sem -> waiting_queue . lock);
   10c24:	e2837014 	add	r7, r3, #20
   10c28:	e1a00007 	mov	r0, r7

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);

    semaphore_pool . data[sid . s . index] . id . s . value = 0;
   10c2c:	e1c320bc 	strh	r2, [r3, #12]
{
  thread_t thread = NULL;
  semaphore_t sem = NULL;
  semaphore_id_t sid = { .raw = id };
  interrupt_status_t it_status = 0;
  bool smart_to_reschedule = false;
   10c30:	e58d2004 	str	r2, [sp, #4]
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);

    semaphore_pool . data[sid . s . index] . id . s . value = 0;

    lock_acquire (& sem -> waiting_queue . lock);
   10c34:	ebffff61 	bl	109c0 <lock_acquire>
    lock_release (& semaphore_pool . lock);
   10c38:	e1a00005 	mov	r0, r5

    while ((thread = queue_rem (& sem -> waiting_queue)) != NULL)
    {
      lock_acquire (& thread -> lock);

      thread -> info . sem_tokens = 0;
   10c3c:	e59d6004 	ldr	r6, [sp, #4]
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);

    semaphore_pool . data[sid . s . index] . id . s . value = 0;

    lock_acquire (& sem -> waiting_queue . lock);
    lock_release (& semaphore_pool . lock);
   10c40:	eb000a12 	bl	13490 <lock_release>
    /*
     * Reschedule each waiting thread, and
     * reset its information.
     */

    while ((thread = queue_rem (& sem -> waiting_queue)) != NULL)
   10c44:	ea000001 	b	10c50 <semaphore_destroy+0xa0>

        smart_to_reschedule = smart_to_reschedule ||
          (status == DNA_INVOKE_SCHEDULER);
      }

      lock_release (& thread -> lock);
   10c48:	e1a0000a 	mov	r0, sl
   10c4c:	eb000a0f 	bl	13490 <lock_release>
    /*
     * Reschedule each waiting thread, and
     * reset its information.
     */

    while ((thread = queue_rem (& sem -> waiting_queue)) != NULL)
   10c50:	e1a00007 	mov	r0, r7
   10c54:	ebfff9a5 	bl	f2f0 <queue_rem>
   10c58:	e250b000 	subs	fp, r0, #0
    {
      lock_acquire (& thread -> lock);
   10c5c:	e28ba014 	add	sl, fp, #20
    /*
     * Reschedule each waiting thread, and
     * reset its information.
     */

    while ((thread = queue_rem (& sem -> waiting_queue)) != NULL)
   10c60:	0a000012 	beq	10cb0 <semaphore_destroy+0x100>
    {
      lock_acquire (& thread -> lock);
   10c64:	e1a0000a 	mov	r0, sl
   10c68:	ebffff54 	bl	109c0 <lock_acquire>

      thread -> info . sem_tokens = 0;
      thread -> info . resource = DNA_NO_RESOURCE;
      thread -> info . resource_id = -1;

      if (thread -> info . status == DNA_THREAD_WAITING)
   10c6c:	e59f308c 	ldr	r3, [pc, #140]	; 10d00 <semaphore_destroy+0x150>
   10c70:	e1db15b0 	ldrh	r1, [fp, #80]	; 0x50

    while ((thread = queue_rem (& sem -> waiting_queue)) != NULL)
    {
      lock_acquire (& thread -> lock);

      thread -> info . sem_tokens = 0;
   10c74:	e58b604c 	str	r6, [fp, #76]	; 0x4c
      thread -> info . resource = DNA_NO_RESOURCE;
      thread -> info . resource_id = -1;

      if (thread -> info . status == DNA_THREAD_WAITING)
   10c78:	e1510003 	cmp	r1, r3
    {
      lock_acquire (& thread -> lock);

      thread -> info . sem_tokens = 0;
      thread -> info . resource = DNA_NO_RESOURCE;
      thread -> info . resource_id = -1;
   10c7c:	e3e03000 	mvn	r3, #0
    while ((thread = queue_rem (& sem -> waiting_queue)) != NULL)
    {
      lock_acquire (& thread -> lock);

      thread -> info . sem_tokens = 0;
      thread -> info . resource = DNA_NO_RESOURCE;
   10c80:	e5cb6052 	strb	r6, [fp, #82]	; 0x52
      thread -> info . resource_id = -1;
   10c84:	e58b3054 	str	r3, [fp, #84]	; 0x54

      if (thread -> info . status == DNA_THREAD_WAITING)
   10c88:	1affffee 	bne	10c48 <semaphore_destroy+0x98>
      {
        thread -> info . status = DNA_THREAD_READY;
   10c8c:	e59f3070 	ldr	r3, [pc, #112]	; 10d04 <semaphore_destroy+0x154>
        status = scheduler_dispatch (thread);
   10c90:	e1a0000b 	mov	r0, fp
      thread -> info . resource = DNA_NO_RESOURCE;
      thread -> info . resource_id = -1;

      if (thread -> info . status == DNA_THREAD_WAITING)
      {
        thread -> info . status = DNA_THREAD_READY;
   10c94:	e1cb35b0 	strh	r3, [fp, #80]	; 0x50
        status = scheduler_dispatch (thread);
   10c98:	eb0006a2 	bl	12728 <scheduler_dispatch>

        smart_to_reschedule = smart_to_reschedule ||
   10c9c:	e59d3004 	ldr	r3, [sp, #4]
   10ca0:	e3500003 	cmp	r0, #3
   10ca4:	03833001 	orreq	r3, r3, #1
   10ca8:	e58d3004 	str	r3, [sp, #4]
   10cac:	eaffffe5 	b	10c48 <semaphore_destroy+0x98>
      }

      lock_release (& thread -> lock);
    }

    lock_acquire (& semaphore_pool . lock);
   10cb0:	e59f0044 	ldr	r0, [pc, #68]	; 10cfc <semaphore_destroy+0x14c>
   10cb4:	ebffff41 	bl	109c0 <lock_acquire>
    lock_release (& sem -> waiting_queue . lock);
   10cb8:	e1a00007 	mov	r0, r7
   10cbc:	eb0009f3 	bl	13490 <lock_release>
    /*
     * Look for the semaphore with ID id. If found,
     * remove its entry from the pool.
     */

    sem = & semaphore_pool . data[sid . s . index];
   10cc0:	e0881004 	add	r1, r8, r4
   10cc4:	e0851101 	add	r1, r5, r1, lsl #2

    /*
     * Add the freed semaphore into the semaphore queue and return.
     */

    queue_add (& semaphore_pool . semaphore, sem);
   10cc8:	e2811008 	add	r1, r1, #8
   10ccc:	e59f0034 	ldr	r0, [pc, #52]	; 10d08 <semaphore_destroy+0x158>
   10cd0:	ebfffc4f 	bl	fe14 <queue_add>

    lock_release (& semaphore_pool . lock);
   10cd4:	e59f0020 	ldr	r0, [pc, #32]	; 10cfc <semaphore_destroy+0x14c>
   10cd8:	eb0009ec 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   10cdc:	e1a00009 	mov	r0, r9
   10ce0:	ebfffe23 	bl	10574 <cpu_trap_restore>

    return smart_to_reschedule ? DNA_INVOKE_SCHEDULER : DNA_OK;
   10ce4:	e59d3004 	ldr	r3, [sp, #4]
   10ce8:	e3530000 	cmp	r3, #0
   10cec:	13a00003 	movne	r0, #3
   10cf0:	03a00000 	moveq	r0, #0
   10cf4:	eaffffb4 	b	10bcc <semaphore_destroy+0x1c>
   10cf8:	0000fdff 	.word	0x0000fdff
   10cfc:	0013f5a0 	.word	0x0013f5a0
   10d00:	0000b10c 	.word	0x0000b10c
   10d04:	ffffface 	.word	0xffffface
   10d08:	001835a8 	.word	0x001835a8

00010d0c <ipi_handler>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   10d0c:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
   10d10:	e24dd00c 	sub	sp, sp, #12
   10d14:	e1a08001 	mov	r8, r1
   10d18:	e1a09000 	mov	r9, r0
  queue_t * queue;
  bool invoke_scheduler = false;
  thread_t target = (thread_t)cookie;
   10d1c:	e58d1004 	str	r1, [sp, #4]
  int32_t cpuid = cpu_mp_id ();
   10d20:	ebfffe30 	bl	105e8 <cpu_mp_id>
  status_t status = DNA_OK;
  thread_t self = cpu_pool . cpu[cpuid] . current_thread;
   10d24:	e1a07180 	lsl	r7, r0, #3
   10d28:	e0873000 	add	r3, r7, r0
   10d2c:	e1a03303 	lsl	r3, r3, #6
   10d30:	e59f4130 	ldr	r4, [pc, #304]	; 10e68 <ipi_handler+0x15c>

{
  queue_t * queue;
  bool invoke_scheduler = false;
  thread_t target = (thread_t)cookie;
  int32_t cpuid = cpu_mp_id ();
   10d34:	e1a05000 	mov	r5, r0
  status_t status = DNA_OK;
  thread_t self = cpu_pool . cpu[cpuid] . current_thread;
  lock_release (& cpu_pool . cpu[cpuid] . ipi_lock);
   10d38:	e2830018 	add	r0, r3, #24
   10d3c:	e0840000 	add	r0, r4, r0
  queue_t * queue;
  bool invoke_scheduler = false;
  thread_t target = (thread_t)cookie;
  int32_t cpuid = cpu_mp_id ();
  status_t status = DNA_OK;
  thread_t self = cpu_pool . cpu[cpuid] . current_thread;
   10d40:	e0843003 	add	r3, r4, r3
   10d44:	e593622c 	ldr	r6, [r3, #556]	; 0x22c
  lock_release (& cpu_pool . cpu[cpuid] . ipi_lock);
   10d48:	eb0009d0 	bl	13490 <lock_release>

  switch (command)
   10d4c:	e2493cff 	sub	r3, r9, #65280	; 0xff00
   10d50:	e24330fc 	sub	r3, r3, #252	; 0xfc
   10d54:	e3530003 	cmp	r3, #3
   10d58:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   10d5c:	ea00003f 	b	10e60 <ipi_handler+0x154>
   10d60:	00010ddc 	.word	0x00010ddc
   10d64:	00010dc8 	.word	0x00010dc8
   10d68:	00010db4 	.word	0x00010db4
   10d6c:	00010d70 	.word	0x00010d70
    case DNA_IPI_DISPATCH :
      {
dna_log(VERBOSE_LEVEL, "%d DISPATCH %s",
            cpu_mp_id (), target -> info . name);

        if (self == cpu_pool . cpu[cpuid] . idle_thread)
   10d70:	e0873005 	add	r3, r7, r5
   10d74:	e0843303 	add	r3, r4, r3, lsl #6
   10d78:	e5933230 	ldr	r3, [r3, #560]	; 0x230
   10d7c:	e1530006 	cmp	r3, r6
   10d80:	0a00001a 	beq	10df0 <ipi_handler+0xe4>
        {
          invoke_scheduler = true;
        }
        else if (scheduler_dispatch (target) == DNA_INVOKE_SCHEDULER)
   10d84:	e59d0004 	ldr	r0, [sp, #4]
   10d88:	eb000666 	bl	12728 <scheduler_dispatch>
   10d8c:	e3500003 	cmp	r0, #3
{
  queue_t * queue;
  bool invoke_scheduler = false;
  thread_t target = (thread_t)cookie;
  int32_t cpuid = cpu_mp_id ();
  status_t status = DNA_OK;
   10d90:	13a00000 	movne	r0, #0

        if (self == cpu_pool . cpu[cpuid] . idle_thread)
        {
          invoke_scheduler = true;
        }
        else if (scheduler_dispatch (target) == DNA_INVOKE_SCHEDULER)
   10d94:	1a000009 	bne	10dc0 <ipi_handler+0xb4>
        {
          status = scheduler_elect (& target, false);
   10d98:	e28d0004 	add	r0, sp, #4
   10d9c:	e3a01000 	mov	r1, #0
   10da0:	eb000626 	bl	12640 <scheduler_elect>
dna_log(PANIC_LEVEL, "Unknown command: %d", command);
      status = DNA_ERROR;
      break;
  }

  if (invoke_scheduler && target != NULL)
   10da4:	e59f30c0 	ldr	r3, [pc, #192]	; 10e6c <ipi_handler+0x160>
   10da8:	e1500003 	cmp	r0, r3
   10dac:	1a000010 	bne	10df4 <ipi_handler+0xe8>
   10db0:	ea000002 	b	10dc0 <ipi_handler+0xb4>
      {
        int32_t thread_id = (int32_t) cookie;

dna_log(VERBOSE_LEVEL, "%d SUSPEND %d", cpuid, thread_id);

        thread_suspend (thread_id);
   10db4:	e1a00008 	mov	r0, r8
   10db8:	eb000baf 	bl	13c7c <thread_suspend>
{
  queue_t * queue;
  bool invoke_scheduler = false;
  thread_t target = (thread_t)cookie;
  int32_t cpuid = cpu_mp_id ();
  status_t status = DNA_OK;
   10dbc:	e3a00000 	mov	r0, #0

    status = scheduler_switch (target, queue);
  }

  return status;
}
   10dc0:	e28dd00c 	add	sp, sp, #12
   10dc4:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
      {
        int32_t id = (int32_t) cookie;

dna_log(VERBOSE_LEVEL, "%d ENABLE %d", cpuid, id);

        cpu_trap_enable (id);
   10dc8:	e1a00008 	mov	r0, r8
   10dcc:	ebfffddc 	bl	10544 <cpu_trap_enable>
{
  queue_t * queue;
  bool invoke_scheduler = false;
  thread_t target = (thread_t)cookie;
  int32_t cpuid = cpu_mp_id ();
  status_t status = DNA_OK;
   10dd0:	e3a00000 	mov	r0, #0

    status = scheduler_switch (target, queue);
  }

  return status;
}
   10dd4:	e28dd00c 	add	sp, sp, #12
   10dd8:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
      {
        int32_t id = (int32_t) cookie;

dna_log(VERBOSE_LEVEL, "%d DISABLE %d", cpuid, id);

        cpu_trap_disable (id);
   10ddc:	e1a00008 	mov	r0, r8
   10de0:	ebfffdb0 	bl	104a8 <cpu_trap_disable>
{
  queue_t * queue;
  bool invoke_scheduler = false;
  thread_t target = (thread_t)cookie;
  int32_t cpuid = cpu_mp_id ();
  status_t status = DNA_OK;
   10de4:	e3a00000 	mov	r0, #0

    status = scheduler_switch (target, queue);
  }

  return status;
}
   10de8:	e28dd00c 	add	sp, sp, #12
   10dec:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
{
  queue_t * queue;
  bool invoke_scheduler = false;
  thread_t target = (thread_t)cookie;
  int32_t cpuid = cpu_mp_id ();
  status_t status = DNA_OK;
   10df0:	e3a00000 	mov	r0, #0
dna_log(PANIC_LEVEL, "Unknown command: %d", command);
      status = DNA_ERROR;
      break;
  }

  if (invoke_scheduler && target != NULL)
   10df4:	e59d3004 	ldr	r3, [sp, #4]
   10df8:	e3530000 	cmp	r3, #0
   10dfc:	0affffef 	beq	10dc0 <ipi_handler+0xb4>
  {
    lock_acquire (& self -> lock);
    self -> info . status = DNA_THREAD_READY;

    if (self != cpu_pool . cpu[cpuid] . idle_thread)
   10e00:	e0875005 	add	r5, r7, r5
   10e04:	e0844305 	add	r4, r4, r5, lsl #6
      break;
  }

  if (invoke_scheduler && target != NULL)
  {
    lock_acquire (& self -> lock);
   10e08:	e2860014 	add	r0, r6, #20
   10e0c:	ebfffeeb 	bl	109c0 <lock_acquire>
    self -> info . status = DNA_THREAD_READY;

    if (self != cpu_pool . cpu[cpuid] . idle_thread)
   10e10:	e5942230 	ldr	r2, [r4, #560]	; 0x230
  }

  if (invoke_scheduler && target != NULL)
  {
    lock_acquire (& self -> lock);
    self -> info . status = DNA_THREAD_READY;
   10e14:	e59f3054 	ldr	r3, [pc, #84]	; 10e70 <ipi_handler+0x164>

    if (self != cpu_pool . cpu[cpuid] . idle_thread)
   10e18:	e1520006 	cmp	r2, r6
  }

  if (invoke_scheduler && target != NULL)
  {
    lock_acquire (& self -> lock);
    self -> info . status = DNA_THREAD_READY;
   10e1c:	e1c635b0 	strh	r3, [r6, #80]	; 0x50
      lock_acquire (& queue -> lock);
      queue_add (queue, self);
    }
    else
    {
      queue = NULL;
   10e20:	03a04000 	moveq	r4, #0
  if (invoke_scheduler && target != NULL)
  {
    lock_acquire (& self -> lock);
    self -> info . status = DNA_THREAD_READY;

    if (self != cpu_pool . cpu[cpuid] . idle_thread)
   10e24:	0a000008 	beq	10e4c <ipi_handler+0x140>
    {
      queue = & scheduler . queue[self -> info . affinity];
   10e28:	e5964048 	ldr	r4, [r6, #72]	; 0x48
   10e2c:	e59f3040 	ldr	r3, [pc, #64]	; 10e74 <ipi_handler+0x168>
   10e30:	e0834204 	add	r4, r3, r4, lsl #4
   10e34:	e2844004 	add	r4, r4, #4

      lock_acquire (& queue -> lock);
   10e38:	e1a00004 	mov	r0, r4
   10e3c:	ebfffedf 	bl	109c0 <lock_acquire>
      queue_add (queue, self);
   10e40:	e1a00004 	mov	r0, r4
   10e44:	e1a01006 	mov	r1, r6
   10e48:	ebfffbf1 	bl	fe14 <queue_add>
    else
    {
      queue = NULL;
    }

    status = scheduler_switch (target, queue);
   10e4c:	e1a01004 	mov	r1, r4
   10e50:	e59d0004 	ldr	r0, [sp, #4]
   10e54:	eb0007ff 	bl	12e58 <scheduler_switch>
  }

  return status;
}
   10e58:	e28dd00c 	add	sp, sp, #12
   10e5c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
        break;
      }

    default :
dna_log(PANIC_LEVEL, "Unknown command: %d", command);
      status = DNA_ERROR;
   10e60:	e59f0010 	ldr	r0, [pc, #16]	; 10e78 <ipi_handler+0x16c>
   10e64:	eaffffd5 	b	10dc0 <ipi_handler+0xb4>
   10e68:	001883e8 	.word	0x001883e8
   10e6c:	0000fcfd 	.word	0x0000fcfd
   10e70:	ffffface 	.word	0xffffface
   10e74:	0018a800 	.word	0x0018a800
   10e78:	0000ffff 	.word	0x0000ffff

00010e7c <thread_yield>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   10e7c:	e92d4070 	push	{r4, r5, r6, lr}
  status_t status = DNA_OK;
  thread_t thread = NULL, self = NULL;
   10e80:	e3a05000 	mov	r5, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   10e84:	e24dd008 	sub	sp, sp, #8
  status_t status = DNA_OK;
  thread_t thread = NULL, self = NULL;
   10e88:	e28d4008 	add	r4, sp, #8
   10e8c:	e5245004 	str	r5, [r4, #-4]!
  queue_t * queue = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup();
   10e90:	ebfffd7e 	bl	10490 <cpu_trap_mask_and_backup>
   10e94:	e1a06000 	mov	r6, r0
    self = cpu_pool . cpu[cpu_mp_id()] . current_thread;
   10e98:	ebfffdd2 	bl	105e8 <cpu_mp_id>
   10e9c:	e59f3094 	ldr	r3, [pc, #148]	; 10f38 <thread_yield+0xbc>
   10ea0:	e0802180 	add	r2, r0, r0, lsl #3
   10ea4:	e0833302 	add	r3, r3, r2, lsl #6

    status = scheduler_elect (& thread, false);
   10ea8:	e1a01005 	mov	r1, r5
   10eac:	e1a00004 	mov	r0, r4
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup();
    self = cpu_pool . cpu[cpu_mp_id()] . current_thread;
   10eb0:	e593522c 	ldr	r5, [r3, #556]	; 0x22c

    status = scheduler_elect (& thread, false);
   10eb4:	eb0005e1 	bl	12640 <scheduler_elect>
    ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);
   10eb8:	e59f207c 	ldr	r2, [pc, #124]	; 10f3c <thread_yield+0xc0>
   10ebc:	e59f307c 	ldr	r3, [pc, #124]	; 10f40 <thread_yield+0xc4>
  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup();
    self = cpu_pool . cpu[cpu_mp_id()] . current_thread;

    status = scheduler_elect (& thread, false);
   10ec0:	e1a04000 	mov	r4, r0
    ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);
   10ec4:	e1500003 	cmp	r0, r3
   10ec8:	11500002 	cmpne	r0, r2
   10ecc:	0a000016 	beq	10f2c <thread_yield+0xb0>

    if (status != DNA_NO_AVAILABLE_THREAD)
   10ed0:	e59f306c 	ldr	r3, [pc, #108]	; 10f44 <thread_yield+0xc8>
   10ed4:	e1500003 	cmp	r0, r3
   10ed8:	0a000011 	beq	10f24 <thread_yield+0xa8>
    {
      lock_acquire (& self -> lock);
   10edc:	e2850014 	add	r0, r5, #20
   10ee0:	ebfffeb6 	bl	109c0 <lock_acquire>
      self -> info . status = DNA_THREAD_READY;
      queue = & scheduler . queue[self -> info . affinity];
   10ee4:	e59f205c 	ldr	r2, [pc, #92]	; 10f48 <thread_yield+0xcc>
   10ee8:	e5954048 	ldr	r4, [r5, #72]	; 0x48
    ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);

    if (status != DNA_NO_AVAILABLE_THREAD)
    {
      lock_acquire (& self -> lock);
      self -> info . status = DNA_THREAD_READY;
   10eec:	e59f3058 	ldr	r3, [pc, #88]	; 10f4c <thread_yield+0xd0>
      queue = & scheduler . queue[self -> info . affinity];
   10ef0:	e0824204 	add	r4, r2, r4, lsl #4
   10ef4:	e2844004 	add	r4, r4, #4

      lock_acquire (& queue -> lock);
   10ef8:	e1a00004 	mov	r0, r4
    ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);

    if (status != DNA_NO_AVAILABLE_THREAD)
    {
      lock_acquire (& self -> lock);
      self -> info . status = DNA_THREAD_READY;
   10efc:	e1c535b0 	strh	r3, [r5, #80]	; 0x50
      queue = & scheduler . queue[self -> info . affinity];

      lock_acquire (& queue -> lock);
   10f00:	ebfffeae 	bl	109c0 <lock_acquire>
      queue_add (queue, self);
   10f04:	e1a00004 	mov	r0, r4
   10f08:	e1a01005 	mov	r1, r5
   10f0c:	ebfffbc0 	bl	fe14 <queue_add>

      status = scheduler_switch (thread, queue);
   10f10:	e1a01004 	mov	r1, r4
   10f14:	e59d0004 	ldr	r0, [sp, #4]
   10f18:	eb0007ce 	bl	12e58 <scheduler_switch>
      ensure (status == DNA_OK, status);
   10f1c:	e2504000 	subs	r4, r0, #0
   10f20:	1a000001 	bne	10f2c <thread_yield+0xb0>
    }

    cpu_trap_restore(it_status);
   10f24:	e1a00006 	mov	r0, r6
   10f28:	ebfffd91 	bl	10574 <cpu_trap_restore>
    return status;
  }
}
   10f2c:	e1a00004 	mov	r0, r4
   10f30:	e28dd008 	add	sp, sp, #8
   10f34:	e8bd8070 	pop	{r4, r5, r6, pc}
   10f38:	001883e8 	.word	0x001883e8
   10f3c:	0000fffc 	.word	0x0000fffc
   10f40:	0000ffff 	.word	0x0000ffff
   10f44:	0000fcfd 	.word	0x0000fcfd
   10f48:	0018a800 	.word	0x0018a800
   10f4c:	ffffface 	.word	0xffffface

00010f50 <core_create>:
 * * !DNA_OK: error creating something
 *
 * SOURCE
 */

{
   10f50:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

    thread_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_GROUP; i += 1)
    {
      for (int32_t j = 0; j < DNA_MAX_THREAD; j += 1)
   10f54:	e3a05000 	mov	r5, #0
  {
    /*
     * Initialize the thread pool.
     */

    thread_pool . counter = 1;
   10f58:	e3a03001 	mov	r3, #1
    {
      for (int32_t j = 0; j < DNA_MAX_THREAD; j += 1)
      {
        thread = & thread_pool . data[i][j];

        thread -> id . s . group = i;
   10f5c:	e1a06005 	mov	r6, r5
  {
    /*
     * Initialize the thread pool.
     */

    thread_pool . counter = 1;
   10f60:	e59f7298 	ldr	r7, [pc, #664]	; 11200 <core_create+0x2b0>
 * * !DNA_OK: error creating something
 *
 * SOURCE
 */

{
   10f64:	e24dd0ac 	sub	sp, sp, #172	; 0xac
  {
    /*
     * Initialize the thread pool.
     */

    thread_pool . counter = 1;
   10f68:	e1c730b4 	strh	r3, [r7, #4]
   10f6c:	e2874008 	add	r4, r7, #8
      for (int32_t j = 0; j < DNA_MAX_THREAD; j += 1)
      {
        thread = & thread_pool . data[i][j];

        thread -> id . s . group = i;
        thread -> id . s . index = j;
   10f70:	e5c4501f 	strb	r5, [r4, #31]

        queue_add (& thread_pool . thread[i], thread);
   10f74:	e1a01004 	mov	r1, r4
    {
      for (int32_t j = 0; j < DNA_MAX_THREAD; j += 1)
      {
        thread = & thread_pool . data[i][j];

        thread -> id . s . group = i;
   10f78:	e5c4601e 	strb	r6, [r4, #30]
        thread -> id . s . index = j;

        queue_add (& thread_pool . thread[i], thread);
   10f7c:	e59f0280 	ldr	r0, [pc, #640]	; 11204 <core_create+0x2b4>

    thread_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_GROUP; i += 1)
    {
      for (int32_t j = 0; j < DNA_MAX_THREAD; j += 1)
   10f80:	e2855001 	add	r5, r5, #1
        thread = & thread_pool . data[i][j];

        thread -> id . s . group = i;
        thread -> id . s . index = j;

        queue_add (& thread_pool . thread[i], thread);
   10f84:	ebfffba2 	bl	fe14 <queue_add>

    thread_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_GROUP; i += 1)
    {
      for (int32_t j = 0; j < DNA_MAX_THREAD; j += 1)
   10f88:	e3550040 	cmp	r5, #64	; 0x40
   10f8c:	e28440d0 	add	r4, r4, #208	; 0xd0
   10f90:	1afffff6 	bne	10f70 <core_create+0x20>

    /*
     * Initialize the alarm pool.
     */

    alarm_pool . counter = 1;
   10f94:	e3a03001 	mov	r3, #1

    for (int32_t i = 0; i < DNA_MAX_ALARM; i += 1)
   10f98:	e3a04000 	mov	r4, #0

    /*
     * Initialize the alarm pool.
     */

    alarm_pool . counter = 1;
   10f9c:	e59f5264 	ldr	r5, [pc, #612]	; 11208 <core_create+0x2b8>
   10fa0:	e1c530b4 	strh	r3, [r5, #4]
   10fa4:	e285500e 	add	r5, r5, #14

    for (int32_t i = 0; i < DNA_MAX_ALARM; i += 1)
    {
      alarm_pool . data[i] . id . s . index = i;
   10fa8:	e1a01005 	mov	r1, r5
      queue_add (& alarm_pool . alarm, & alarm_pool . data[i]);
   10fac:	e59f0258 	ldr	r0, [pc, #600]	; 1120c <core_create+0x2bc>

    alarm_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_ALARM; i += 1)
    {
      alarm_pool . data[i] . id . s . index = i;
   10fb0:	e04140b6 	strh	r4, [r1], #-6
     * Initialize the alarm pool.
     */

    alarm_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_ALARM; i += 1)
   10fb4:	e2844001 	add	r4, r4, #1
    {
      alarm_pool . data[i] . id . s . index = i;
      queue_add (& alarm_pool . alarm, & alarm_pool . data[i]);
   10fb8:	ebfffb95 	bl	fe14 <queue_add>
     * Initialize the alarm pool.
     */

    alarm_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_ALARM; i += 1)
   10fbc:	e3540040 	cmp	r4, #64	; 0x40
   10fc0:	e2855040 	add	r5, r5, #64	; 0x40
   10fc4:	1afffff7 	bne	10fa8 <core_create+0x58>

    /*
     * Initialize the semaphore pool.
     */

    semaphore_pool . counter = 1;
   10fc8:	e3a03001 	mov	r3, #1

    for (int32_t i = 0; i < DNA_MAX_SEM; i += 1)
   10fcc:	e3a04000 	mov	r4, #0

    /*
     * Initialize the semaphore pool.
     */

    semaphore_pool . counter = 1;
   10fd0:	e59f5238 	ldr	r5, [pc, #568]	; 11210 <core_create+0x2c0>
   10fd4:	e1c530b4 	strh	r3, [r5, #4]
   10fd8:	e285500e 	add	r5, r5, #14

    for (int32_t i = 0; i < DNA_MAX_SEM; i += 1)
    {
      semaphore_pool . data[i] . id . s . index = i;
   10fdc:	e1a01005 	mov	r1, r5
      queue_add (& semaphore_pool . semaphore, & semaphore_pool . data[i]);
   10fe0:	e59f022c 	ldr	r0, [pc, #556]	; 11214 <core_create+0x2c4>

    semaphore_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_SEM; i += 1)
    {
      semaphore_pool . data[i] . id . s . index = i;
   10fe4:	e04140b6 	strh	r4, [r1], #-6
     * Initialize the semaphore pool.
     */

    semaphore_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_SEM; i += 1)
   10fe8:	e2844001 	add	r4, r4, #1
    {
      semaphore_pool . data[i] . id . s . index = i;
      queue_add (& semaphore_pool . semaphore, & semaphore_pool . data[i]);
   10fec:	ebfffb88 	bl	fe14 <queue_add>
     * Initialize the semaphore pool.
     */

    semaphore_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_SEM; i += 1)
   10ff0:	e3540a01 	cmp	r4, #4096	; 0x1000
   10ff4:	e2855044 	add	r5, r5, #68	; 0x44
   10ff8:	1afffff7 	bne	10fdc <core_create+0x8c>

    /*
     * Initialize the port pool.
     */

    port_pool . counter = 1;
   10ffc:	e3a03001 	mov	r3, #1

    for (int32_t i = 0; i < DNA_MAX_PORT; i += 1)
   11000:	e3a04000 	mov	r4, #0

    /*
     * Initialize the port pool.
     */

    port_pool . counter = 1;
   11004:	e59f520c 	ldr	r5, [pc, #524]	; 11218 <core_create+0x2c8>
   11008:	e1c530b4 	strh	r3, [r5, #4]
   1100c:	e285500e 	add	r5, r5, #14

    for (int32_t i = 0; i < DNA_MAX_PORT; i += 1)
    {
      port_pool . data[i] . id . s . index = i;
   11010:	e1a01005 	mov	r1, r5
      queue_add (& port_pool . port, & port_pool . data[i]);
   11014:	e59f0200 	ldr	r0, [pc, #512]	; 1121c <core_create+0x2cc>

    port_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_PORT; i += 1)
    {
      port_pool . data[i] . id . s . index = i;
   11018:	e04140b6 	strh	r4, [r1], #-6
     * Initialize the port pool.
     */

    port_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_PORT; i += 1)
   1101c:	e2844001 	add	r4, r4, #1
    {
      port_pool . data[i] . id . s . index = i;
      queue_add (& port_pool . port, & port_pool . data[i]);
   11020:	ebfffb7b 	bl	fe14 <queue_add>
     * Initialize the port pool.
     */

    port_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_PORT; i += 1)
   11024:	e3540040 	cmp	r4, #64	; 0x40
   11028:	e2855068 	add	r5, r5, #104	; 0x68
   1102c:	1afffff7 	bne	11010 <core_create+0xc0>

    /*
     * Initialize the CPUs
     */

    DNA_THREAD_SET_DEFAULTS (thread_info);
   11030:	e28d6058 	add	r6, sp, #88	; 0x58
   11034:	e59f11e4 	ldr	r1, [pc, #484]	; 11220 <core_create+0x2d0>
   11038:	e1a00006 	mov	r0, r6
   1103c:	ebfffc0d 	bl	10078 <dna_strcpy>
   11040:	e3a09902 	mov	r9, #32768	; 0x8000
   11044:	e3a01000 	mov	r1, #0
   11048:	e3e00000 	mvn	r0, #0
   1104c:	e3a02000 	mov	r2, #0
   11050:	e3a03000 	mov	r3, #0
   11054:	e59fc1c8 	ldr	ip, [pc, #456]	; 11224 <core_create+0x2d4>
   11058:	e59f41c8 	ldr	r4, [pc, #456]	; 11228 <core_create+0x2d8>

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
   1105c:	e1a05001 	mov	r5, r1

    /*
     * Initialize the CPUs
     */

    DNA_THREAD_SET_DEFAULTS (thread_info);
   11060:	e58d1078 	str	r1, [sp, #120]	; 0x78
   11064:	e58d107c 	str	r1, [sp, #124]	; 0x7c
   11068:	e58d1084 	str	r1, [sp, #132]	; 0x84
   1106c:	e5cd108a 	strb	r1, [sp, #138]	; 0x8a
   11070:	e58d10a0 	str	r1, [sp, #160]	; 0xa0
       * Create the Idle thread
       */

      dna_strcpy (thread_info . name, "IdleThread");
      thread_info . affinity = cpu_i;
      thread_info . stack_base = NULL;
   11074:	e1a0a001 	mov	sl, r1

    /*
     * Initialize the CPUs
     */

    DNA_THREAD_SET_DEFAULTS (thread_info);
   11078:	e58d0080 	str	r0, [sp, #128]	; 0x80
   1107c:	e58d008c 	str	r0, [sp, #140]	; 0x8c
   11080:	e1cd29f0 	strd	r2, [sp, #144]	; 0x90
   11084:	e1cd29f8 	strd	r2, [sp, #152]	; 0x98
   11088:	e58d90a4 	str	r9, [sp, #164]	; 0xa4
   1108c:	e1cdc8b8 	strh	ip, [sp, #136]	; 0x88

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
   11090:	e1a0b004 	mov	fp, r4
   11094:	e28d8054 	add	r8, sp, #84	; 0x54
   11098:	ea000020 	b	11120 <core_create+0x1d0>

      /*
       * Create the Idle thread
       */

      dna_strcpy (thread_info . name, "IdleThread");
   1109c:	ebfffbf5 	bl	10078 <dna_strcpy>
      thread_info . affinity = cpu_i;
      thread_info . stack_base = NULL;
      thread_info . stack_size = DNA_IDLE_STACK_SIZE;

      status = thread_create (thread_idle, NULL, thread_info, & tid . raw);
   110a0:	e28d1060 	add	r1, sp, #96	; 0x60
   110a4:	e3a02048 	mov	r2, #72	; 0x48
   110a8:	e1a0000d 	mov	r0, sp
      /*
       * Create the Idle thread
       */

      dna_strcpy (thread_info . name, "IdleThread");
      thread_info . affinity = cpu_i;
   110ac:	e58d5080 	str	r5, [sp, #128]	; 0x80
      thread_info . stack_base = NULL;
   110b0:	e58da0a0 	str	sl, [sp, #160]	; 0xa0
      thread_info . stack_size = DNA_IDLE_STACK_SIZE;
   110b4:	e58d90a4 	str	r9, [sp, #164]	; 0xa4

      status = thread_create (thread_idle, NULL, thread_info, & tid . raw);
   110b8:	e58d8048 	str	r8, [sp, #72]	; 0x48
   110bc:	eb001d43 	bl	185d0 <memcpy>
   110c0:	e896000c 	ldm	r6, {r2, r3}
   110c4:	e59f0160 	ldr	r0, [pc, #352]	; 1122c <core_create+0x2dc>
   110c8:	e3a01000 	mov	r1, #0
   110cc:	eb000213 	bl	11920 <thread_create>
      check (cpu_initialize, status == DNA_OK, DNA_ERROR);
   110d0:	e3500000 	cmp	r0, #0
   110d4:	1a00002b 	bne	11188 <core_create+0x238>

      thread = & thread_pool . data[tid . s . group][tid . s . index];
   110d8:	e3a02b0d 	mov	r2, #13312	; 0x3400
   110dc:	e3a010d0 	mov	r1, #208	; 0xd0
   110e0:	e5dd3056 	ldrb	r3, [sp, #86]	; 0x56
      /*
       * Deal with the new thread
       */

      cpu -> id = cpu_i;
      cpu -> status = DNA_CPU_DISABLED;
   110e4:	e59f0144 	ldr	r0, [pc, #324]	; 11230 <core_create+0x2e0>
      thread_info . stack_size = DNA_IDLE_STACK_SIZE;

      status = thread_create (thread_idle, NULL, thread_info, & tid . raw);
      check (cpu_initialize, status == DNA_OK, DNA_ERROR);

      thread = & thread_pool . data[tid . s . group][tid . s . index];
   110e8:	e0030392 	mul	r3, r2, r3
   110ec:	e5dd2057 	ldrb	r2, [sp, #87]	; 0x57

      /*
       * Deal with the new thread
       */

      cpu -> id = cpu_i;
   110f0:	e58b500c 	str	r5, [fp, #12]
      thread_info . stack_size = DNA_IDLE_STACK_SIZE;

      status = thread_create (thread_idle, NULL, thread_info, & tid . raw);
      check (cpu_initialize, status == DNA_OK, DNA_ERROR);

      thread = & thread_pool . data[tid . s . group][tid . s . index];
   110f4:	e0223291 	mla	r2, r1, r2, r3
   110f8:	e2823008 	add	r3, r2, #8
   110fc:	e0873003 	add	r3, r7, r3
       * Deal with the new thread
       */

      cpu -> id = cpu_i;
      cpu -> status = DNA_CPU_DISABLED;
      cpu -> idle_thread = thread;
   11100:	e58b3230 	str	r3, [fp, #560]	; 0x230
      cpu -> current_thread = thread;
   11104:	e58b322c 	str	r3, [fp, #556]	; 0x22c

      status = thread_create (thread_idle, NULL, thread_info, & tid . raw);
      check (cpu_initialize, status == DNA_OK, DNA_ERROR);

      thread = & thread_pool . data[tid . s . group][tid . s . index];
      thread -> info . status = DNA_THREAD_READY;
   11108:	e59f3124 	ldr	r3, [pc, #292]	; 11234 <core_create+0x2e4>
   1110c:	e0872002 	add	r2, r7, r2
      /*
       * Deal with the new thread
       */

      cpu -> id = cpu_i;
      cpu -> status = DNA_CPU_DISABLED;
   11110:	e1cb01b0 	strh	r0, [fp, #16]
     * Initialize the CPUs
     */

    DNA_THREAD_SET_DEFAULTS (thread_info);

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
   11114:	e2855001 	add	r5, r5, #1

      status = thread_create (thread_idle, NULL, thread_info, & tid . raw);
      check (cpu_initialize, status == DNA_OK, DNA_ERROR);

      thread = & thread_pool . data[tid . s . group][tid . s . index];
      thread -> info . status = DNA_THREAD_READY;
   11118:	e1c235b8 	strh	r3, [r2, #88]	; 0x58
   1111c:	e28bbd09 	add	fp, fp, #576	; 0x240
     * Initialize the CPUs
     */

    DNA_THREAD_SET_DEFAULTS (thread_info);

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
   11120:	ebfffd63 	bl	106b4 <cpu_mp_count>
   11124:	e1550000 	cmp	r5, r0

      /*
       * Create the Idle thread
       */

      dna_strcpy (thread_info . name, "IdleThread");
   11128:	e59f1108 	ldr	r1, [pc, #264]	; 11238 <core_create+0x2e8>
   1112c:	e1a00006 	mov	r0, r6
     * Initialize the CPUs
     */

    DNA_THREAD_SET_DEFAULTS (thread_info);

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
   11130:	baffffd9 	blt	1109c <core_create+0x14c>
    /*
     * Create the main application thread. For now,
     * the application resides in the kernel.
     */

    dna_strcpy (thread_info . name, "Main");
   11134:	e59f1100 	ldr	r1, [pc, #256]	; 1123c <core_create+0x2ec>
   11138:	ebfffbce 	bl	10078 <dna_strcpy>
    thread_info . affinity = DNA_NO_AFFINITY;
    thread_info . stack_base = NULL;
   1113c:	e3a05000 	mov	r5, #0
     * Create the main application thread. For now,
     * the application resides in the kernel.
     */

    dna_strcpy (thread_info . name, "Main");
    thread_info . affinity = DNA_NO_AFFINITY;
   11140:	e3e0c000 	mvn	ip, #0
    thread_info . stack_base = NULL;
    thread_info . stack_size = DNA_THREAD_STACK_SIZE;
   11144:	e3a03902 	mov	r3, #32768	; 0x8000

    status = thread_create (APP_ENTRY_POINT, NULL, thread_info, & tid . raw);
   11148:	e59f20f0 	ldr	r2, [pc, #240]	; 11240 <core_create+0x2f0>
   1114c:	e28d1060 	add	r1, sp, #96	; 0x60
   11150:	e5929000 	ldr	r9, [r2]
   11154:	e1a0000d 	mov	r0, sp
   11158:	e3a02048 	mov	r2, #72	; 0x48
     * Create the main application thread. For now,
     * the application resides in the kernel.
     */

    dna_strcpy (thread_info . name, "Main");
    thread_info . affinity = DNA_NO_AFFINITY;
   1115c:	e58dc080 	str	ip, [sp, #128]	; 0x80
    thread_info . stack_base = NULL;
    thread_info . stack_size = DNA_THREAD_STACK_SIZE;
   11160:	e58d30a4 	str	r3, [sp, #164]	; 0xa4

    status = thread_create (APP_ENTRY_POINT, NULL, thread_info, & tid . raw);
   11164:	e58d8048 	str	r8, [sp, #72]	; 0x48
     * the application resides in the kernel.
     */

    dna_strcpy (thread_info . name, "Main");
    thread_info . affinity = DNA_NO_AFFINITY;
    thread_info . stack_base = NULL;
   11168:	e58d50a0 	str	r5, [sp, #160]	; 0xa0
    thread_info . stack_size = DNA_THREAD_STACK_SIZE;

    status = thread_create (APP_ENTRY_POINT, NULL, thread_info, & tid . raw);
   1116c:	eb001d17 	bl	185d0 <memcpy>
   11170:	e896000c 	ldm	r6, {r2, r3}
   11174:	e1a00009 	mov	r0, r9
   11178:	e1a01005 	mov	r1, r5
   1117c:	eb0001e7 	bl	11920 <thread_create>
    check (cpu_initialize, status == DNA_OK, DNA_ERROR);
   11180:	e3500000 	cmp	r0, #0
   11184:	0a000011 	beq	111d0 <core_create+0x280>

  rescue(cpu_initialize)
  {
    thread_t idle_thread = NULL;

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
   11188:	e3a05000 	mov	r5, #0

      if (idle_thread != NULL)
      {
        thread_destroy (idle_thread -> id . raw);

        cpu_pool . cpu[cpu_i] . idle_thread = NULL;
   1118c:	e1a06005 	mov	r6, r5

  rescue(cpu_initialize)
  {
    thread_t idle_thread = NULL;

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
   11190:	ea000008 	b	111b8 <core_create+0x268>
    {
      idle_thread = cpu_pool . cpu[cpu_i] . idle_thread;
   11194:	e5943230 	ldr	r3, [r4, #560]	; 0x230

  rescue(cpu_initialize)
  {
    thread_t idle_thread = NULL;

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
   11198:	e2855001 	add	r5, r5, #1
    {
      idle_thread = cpu_pool . cpu[cpu_i] . idle_thread;

      if (idle_thread != NULL)
   1119c:	e3530000 	cmp	r3, #0
   111a0:	0a000003 	beq	111b4 <core_create+0x264>
      {
        thread_destroy (idle_thread -> id . raw);
   111a4:	e593001c 	ldr	r0, [r3, #28]
   111a8:	eb0007e2 	bl	13138 <thread_destroy>

        cpu_pool . cpu[cpu_i] . idle_thread = NULL;
   111ac:	e5846230 	str	r6, [r4, #560]	; 0x230
        cpu_pool . cpu[cpu_i] . current_thread = NULL;
   111b0:	e584622c 	str	r6, [r4, #556]	; 0x22c
   111b4:	e2844d09 	add	r4, r4, #576	; 0x240

  rescue(cpu_initialize)
  {
    thread_t idle_thread = NULL;

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
   111b8:	ebfffd3d 	bl	106b4 <cpu_mp_count>
   111bc:	e1550000 	cmp	r5, r0
   111c0:	bafffff3 	blt	11194 <core_create+0x244>
        cpu_pool . cpu[cpu_i] . idle_thread = NULL;
        cpu_pool . cpu[cpu_i] . current_thread = NULL;
      }
    }

    leave;
   111c4:	e59f0078 	ldr	r0, [pc, #120]	; 11244 <core_create+0x2f4>
  }
}
   111c8:	e28dd0ac 	add	sp, sp, #172	; 0xac
   111cc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    thread_info . stack_size = DNA_THREAD_STACK_SIZE;

    status = thread_create (APP_ENTRY_POINT, NULL, thread_info, & tid . raw);
    check (cpu_initialize, status == DNA_OK, DNA_ERROR);

    thread = & thread_pool . data[tid . s . group][tid . s . index];
   111d0:	e3a0cb0d 	mov	ip, #13312	; 0x3400
   111d4:	e3a010d0 	mov	r1, #208	; 0xd0
   111d8:	e5dd2056 	ldrb	r2, [sp, #86]	; 0x56
   111dc:	e5dd3057 	ldrb	r3, [sp, #87]	; 0x57
   111e0:	e002029c 	mul	r2, ip, r2
   111e4:	e0232391 	mla	r3, r1, r3, r2
   111e8:	e2833008 	add	r3, r3, #8
   111ec:	e0877003 	add	r7, r7, r3
    cpu_pool . cpu[0] . current_thread = thread;
   111f0:	e59f3030 	ldr	r3, [pc, #48]	; 11228 <core_create+0x2d8>
   111f4:	e583722c 	str	r7, [r3, #556]	; 0x22c
      }
    }

    leave;
  }
}
   111f8:	e28dd0ac 	add	sp, sp, #172	; 0xac
   111fc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11200:	00184fd0 	.word	0x00184fd0
   11204:	001883d8 	.word	0x001883d8
   11208:	0018a918 	.word	0x0018a918
   1120c:	0018b920 	.word	0x0018b920
   11210:	0013f5a0 	.word	0x0013f5a0
   11214:	001835a8 	.word	0x001835a8
   11218:	001835b8 	.word	0x001835b8
   1121c:	00184fc0 	.word	0x00184fc0
   11220:	00031fa4 	.word	0x00031fa4
   11224:	ffffd15a 	.word	0xffffd15a
   11228:	001883e8 	.word	0x001883e8
   1122c:	000109f4 	.word	0x000109f4
   11230:	ffffdead 	.word	0xffffdead
   11234:	ffffface 	.word	0xffffface
   11238:	00032fd8 	.word	0x00032fd8
   1123c:	00032fe4 	.word	0x00032fe4
   11240:	0003e94c 	.word	0x0003e94c
   11244:	0000ffff 	.word	0x0000ffff

00011248 <thread_snooze>:
 *
 * SOURCE
 */

{
  int32_t alarm_id = -1;
   11248:	e3e02000 	mvn	r2, #0
  uint32_t current_cpuid = 0;
  thread_t self = NULL;
  thread_t target = NULL;
   1124c:	e3a03000 	mov	r3, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   11250:	e92d40f0 	push	{r4, r5, r6, r7, lr}
   11254:	e24dd014 	sub	sp, sp, #20
   11258:	e1a04000 	mov	r4, r0
   1125c:	e1a05001 	mov	r5, r1
  int32_t alarm_id = -1;
   11260:	e58d2008 	str	r2, [sp, #8]
  uint32_t current_cpuid = 0;
  thread_t self = NULL;
  thread_t target = NULL;
   11264:	e58d300c 	str	r3, [sp, #12]
  {
    /*
     * Disable interrupts and get current information
     */

    it_status = cpu_trap_mask_and_backup ();
   11268:	ebfffc88 	bl	10490 <cpu_trap_mask_and_backup>
   1126c:	e1a07000 	mov	r7, r0

    current_cpuid = cpu_mp_id();
   11270:	ebfffcdc 	bl	105e8 <cpu_mp_id>
    self = cpu_pool . cpu[current_cpuid] . current_thread;
   11274:	e59f30cc 	ldr	r3, [pc, #204]	; 11348 <thread_snooze+0x100>
   11278:	e0800180 	add	r0, r0, r0, lsl #3
   1127c:	e0833300 	add	r3, r3, r0, lsl #6
   11280:	e593622c 	ldr	r6, [r3, #556]	; 0x22c

    /*
     * Create the snooze alarm and elect a new thread.
     */

    status = alarm_create (value, DNA_ONE_SHOT_RELATIVE_ALARM,
   11284:	e28d3008 	add	r3, sp, #8
   11288:	e1a00004 	mov	r0, r4
   1128c:	e58d3004 	str	r3, [sp, #4]
   11290:	e1a01005 	mov	r1, r5
   11294:	e58d6000 	str	r6, [sp]
   11298:	e3a02002 	mov	r2, #2
   1129c:	e59f30a8 	ldr	r3, [pc, #168]	; 1134c <thread_snooze+0x104>
   112a0:	eb000036 	bl	11380 <alarm_create>
        thread_alarm, self, & alarm_id);
    check (alarm_error, status == DNA_OK, status);
   112a4:	e2504000 	subs	r4, r0, #0
   112a8:	1a000021 	bne	11334 <thread_snooze+0xec>

    status = scheduler_elect (& target, true);
   112ac:	e3a01001 	mov	r1, #1
   112b0:	e28d000c 	add	r0, sp, #12
   112b4:	eb0004e1 	bl	12640 <scheduler_elect>
    ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);
   112b8:	e59f4090 	ldr	r4, [pc, #144]	; 11350 <thread_snooze+0x108>
   112bc:	e59f1090 	ldr	r1, [pc, #144]	; 11354 <thread_snooze+0x10c>
   112c0:	e1500001 	cmp	r0, r1
   112c4:	11500004 	cmpne	r0, r4
   112c8:	03a05001 	moveq	r5, #1
   112cc:	13a05000 	movne	r5, #0
   112d0:	1a000001 	bne	112dc <thread_snooze+0x94>
  rescue (alarm_error)
  {
    cpu_trap_restore (it_status);
    leave;
  }
}
   112d4:	e28dd014 	add	sp, sp, #20
   112d8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

    /*
     * Update self information and switch context.
     */

    lock_acquire (& self -> lock);
   112dc:	e2860014 	add	r0, r6, #20
   112e0:	ebfffdb6 	bl	109c0 <lock_acquire>
    self -> info . status = DNA_THREAD_SLEEPING;
   112e4:	e59f306c 	ldr	r3, [pc, #108]	; 11358 <thread_snooze+0x110>

    status = scheduler_switch (target, NULL);
   112e8:	e1a01005 	mov	r1, r5
    /*
     * Update self information and switch context.
     */

    lock_acquire (& self -> lock);
    self -> info . status = DNA_THREAD_SLEEPING;
   112ec:	e1c635b0 	strh	r3, [r6, #80]	; 0x50

    status = scheduler_switch (target, NULL);
   112f0:	e59d000c 	ldr	r0, [sp, #12]
   112f4:	eb0006d7 	bl	12e58 <scheduler_switch>
    ensure (status == DNA_OK, status);
   112f8:	e3500000 	cmp	r0, #0
   112fc:	1afffff4 	bne	112d4 <thread_snooze+0x8c>
    /*
     * Cancel the alarm, just in case we came back from
     * sleeping after a thread_suspend/thread_resume combination.
     */

    status = alarm_destroy (alarm_id);
   11300:	e59d0008 	ldr	r0, [sp, #8]
   11304:	eb000768 	bl	130ac <alarm_destroy>
    ensure (status != DNA_NO_TIMER && status != DNA_BAD_ARGUMENT, status);
   11308:	e59f304c 	ldr	r3, [pc, #76]	; 1135c <thread_snooze+0x114>
    /*
     * Cancel the alarm, just in case we came back from
     * sleeping after a thread_suspend/thread_resume combination.
     */

    status = alarm_destroy (alarm_id);
   1130c:	e1a05000 	mov	r5, r0
    ensure (status != DNA_NO_TIMER && status != DNA_BAD_ARGUMENT, status);
   11310:	e1500003 	cmp	r0, r3
   11314:	11500004 	cmpne	r0, r4
   11318:	0affffed 	beq	112d4 <thread_snooze+0x8c>

    cpu_trap_restore (it_status);
   1131c:	e1a00007 	mov	r0, r7
   11320:	ebfffc93 	bl	10574 <cpu_trap_restore>
    return (status == DNA_OK) ? DNA_INTERRUPTED : DNA_OK;
   11324:	e3550000 	cmp	r5, #0
   11328:	e59f0030 	ldr	r0, [pc, #48]	; 11360 <thread_snooze+0x118>
   1132c:	13a00000 	movne	r0, #0
   11330:	eaffffe7 	b	112d4 <thread_snooze+0x8c>
  }

  rescue (alarm_error)
  {
    cpu_trap_restore (it_status);
   11334:	e1a00007 	mov	r0, r7
   11338:	ebfffc8d 	bl	10574 <cpu_trap_restore>
    leave;
   1133c:	e1a00004 	mov	r0, r4
  }
}
   11340:	e28dd014 	add	sp, sp, #20
   11344:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
   11348:	001883e8 	.word	0x001883e8
   1134c:	00012980 	.word	0x00012980
   11350:	0000fffc 	.word	0x0000fffc
   11354:	0000ffff 	.word	0x0000ffff
   11358:	ffffbedd 	.word	0xffffbedd
   1135c:	0000fbff 	.word	0x0000fbff
   11360:	0000fff9 	.word	0x0000fff9

00011364 <core_destroy>:
 * SOURCE
 */

{
  return DNA_NOT_IMPLEMENTED;
}
   11364:	e59f0000 	ldr	r0, [pc]	; 1136c <core_destroy+0x8>
   11368:	e12fff1e 	bx	lr
   1136c:	0000fffe 	.word	0x0000fffe

00011370 <lock_create>:
 *
 * SOURCE
 */

{
  *lock = 0;
   11370:	e3a03000 	mov	r3, #0
   11374:	e5803000 	str	r3, [r0]
  return DNA_OK;
}
   11378:	e1a00003 	mov	r0, r3
   1137c:	e12fff1e 	bx	lr

00011380 <alarm_create>:
 * * DNA_OK: alarm created
 *
 * SOURCE
 */

{
   11380:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11384:	e1a06000 	mov	r6, r0
   11388:	e1a07001 	mov	r7, r1
  cpu_t * cpu = NULL;
  int16_t index;
  int32_t current_cpuid = 0;
  interrupt_status_t it_status;
  alarm_t new_alarm = NULL, old_alarm = NULL;
  bigtime_t start_time = 0, updated_time = 0, updated_quantum = 0;
   1138c:	e3a04000 	mov	r4, #0
   11390:	e3a05000 	mov	r5, #0
 * * DNA_OK: alarm created
 *
 * SOURCE
 */

{
   11394:	e24dd024 	sub	sp, sp, #36	; 0x24
  alarm_t new_alarm = NULL, old_alarm = NULL;
  bigtime_t start_time = 0, updated_time = 0, updated_quantum = 0;
  
  watch (status_t)
  {
    ensure (quantum != 0, DNA_BAD_ARGUMENT);
   11398:	e1961007 	orrs	r1, r6, r7
  cpu_t * cpu = NULL;
  int16_t index;
  int32_t current_cpuid = 0;
  interrupt_status_t it_status;
  alarm_t new_alarm = NULL, old_alarm = NULL;
  bigtime_t start_time = 0, updated_time = 0, updated_quantum = 0;
   1139c:	e1cd41f0 	strd	r4, [sp, #16]
   113a0:	e1cd41f8 	strd	r4, [sp, #24]
  
  watch (status_t)
  {
    ensure (quantum != 0, DNA_BAD_ARGUMENT);
   113a4:	059f0274 	ldreq	r0, [pc, #628]	; 11620 <alarm_create+0x2a0>
   113a8:	1a000001 	bne	113b4 <alarm_create+0x34>
  rescue (bad_quantum)
  {
    cpu_trap_restore(it_status);
    leave;
  }
}
   113ac:	e28dd024 	add	sp, sp, #36	; 0x24
   113b0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

    /*
     * Deactivate interrupts and get current information.
     */

    it_status = cpu_trap_mask_and_backup();
   113b4:	e58d3004 	str	r3, [sp, #4]
   113b8:	e1a0b002 	mov	fp, r2
   113bc:	ebfffc33 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& alarm_pool . lock);
   113c0:	e59fa25c 	ldr	sl, [pc, #604]	; 11624 <alarm_create+0x2a4>

    /*
     * Deactivate interrupts and get current information.
     */

    it_status = cpu_trap_mask_and_backup();
   113c4:	e58d000c 	str	r0, [sp, #12]
    lock_acquire (& alarm_pool . lock);
   113c8:	e1a0000a 	mov	r0, sl
   113cc:	ebfffd7b 	bl	109c0 <lock_acquire>

    current_cpuid = cpu_mp_id ();
   113d0:	ebfffc84 	bl	105e8 <cpu_mp_id>
   113d4:	e1a09000 	mov	r9, r0
    cpu = & cpu_pool . cpu[current_cpuid];

    new_alarm = queue_rem (& alarm_pool . alarm);
   113d8:	e59f0248 	ldr	r0, [pc, #584]	; 11628 <alarm_create+0x2a8>
   113dc:	ebfff7c3 	bl	f2f0 <queue_rem>
    check (no_alarm, new_alarm != NULL, DNA_NO_MORE_ALARM);
   113e0:	e2508000 	subs	r8, r0, #0
   113e4:	e59d3004 	ldr	r3, [sp, #4]
   113e8:	0a000062 	beq	11578 <alarm_create+0x1f8>

    /*
     * Make the place clean.
     */

    index = new_alarm -> id . s . index;
   113ec:	e1d8c0b6 	ldrh	ip, [r8, #6]
    dna_memset (new_alarm, 0, sizeof (struct _alarm));
   113f0:	e3a01000 	mov	r1, #0
   113f4:	e3a02040 	mov	r2, #64	; 0x40
   113f8:	e98d1008 	stmib	sp, {r3, ip}
   113fc:	ebfff81c 	bl	f474 <dna_memset>
    /*
     * Fill in the information.
     */

    new_alarm -> id . s . index = index;
    new_alarm -> id . s . value = alarm_pool . counter;
   11400:	e1da20b4 	ldrh	r2, [sl, #4]

    /*
     * Fill in the information.
     */

    new_alarm -> id . s . index = index;
   11404:	e59dc008 	ldr	ip, [sp, #8]
    new_alarm -> id . s . value = alarm_pool . counter;

    alarm_pool . counter += 1;
    lock_release (& alarm_pool . lock);
   11408:	e1a0000a 	mov	r0, sl
    /*
     * Fill in the information.
     */

    new_alarm -> id . s . index = index;
    new_alarm -> id . s . value = alarm_pool . counter;
   1140c:	e1c820b4 	strh	r2, [r8, #4]

    /*
     * Fill in the information.
     */

    new_alarm -> id . s . index = index;
   11410:	e1c8c0b6 	strh	ip, [r8, #6]
    new_alarm -> id . s . value = alarm_pool . counter;

    alarm_pool . counter += 1;
   11414:	e2822001 	add	r2, r2, #1
   11418:	e1ca20b4 	strh	r2, [sl, #4]
    lock_release (& alarm_pool . lock);
   1141c:	eb00081b 	bl	13490 <lock_release>
     */

    new_alarm -> mode = mode;
    new_alarm -> thread_id = cpu -> current_thread -> id . raw;
    new_alarm -> cpu_id = current_cpuid;
    new_alarm -> is_invalid = false;
   11420:	e3a01000 	mov	r1, #0
    /*
     * Set various information.
     */

    new_alarm -> mode = mode;
    new_alarm -> thread_id = cpu -> current_thread -> id . raw;
   11424:	e59f2200 	ldr	r2, [pc, #512]	; 1162c <alarm_create+0x2ac>
   11428:	e1a0a189 	lsl	sl, r9, #3
   1142c:	e08a0009 	add	r0, sl, r9
   11430:	e0820300 	add	r0, r2, r0, lsl #6
   11434:	e590022c 	ldr	r0, [r0, #556]	; 0x22c
    new_alarm -> is_invalid = false;

    new_alarm -> lock = 0;
    new_alarm -> execution_time = 0;

    new_alarm -> callback = callback;
   11438:	e59d3004 	ldr	r3, [sp, #4]

    /*
     * Set various information.
     */

    new_alarm -> mode = mode;
   1143c:	e588b010 	str	fp, [r8, #16]
    new_alarm -> thread_id = cpu -> current_thread -> id . raw;
   11440:	e590c01c 	ldr	ip, [r0, #28]
    new_alarm -> is_invalid = false;

    new_alarm -> lock = 0;
    new_alarm -> execution_time = 0;

    new_alarm -> callback = callback;
   11444:	e5883038 	str	r3, [r8, #56]	; 0x38
    new_alarm -> data = data;
   11448:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
     */

    new_alarm -> mode = mode;
    new_alarm -> thread_id = cpu -> current_thread -> id . raw;
    new_alarm -> cpu_id = current_cpuid;
    new_alarm -> is_invalid = false;
   1144c:	e5c81014 	strb	r1, [r8, #20]

    new_alarm -> lock = 0;
   11450:	e5881018 	str	r1, [r8, #24]
    /*
     * Set various information.
     */

    new_alarm -> mode = mode;
    new_alarm -> thread_id = cpu -> current_thread -> id . raw;
   11454:	e588c008 	str	ip, [r8, #8]
    new_alarm -> cpu_id = current_cpuid;
   11458:	e588900c 	str	r9, [r8, #12]
    new_alarm -> is_invalid = false;

    new_alarm -> lock = 0;
    new_alarm -> execution_time = 0;
   1145c:	e1c843f0 	strd	r4, [r8, #48]	; 0x30

    new_alarm -> callback = callback;
    new_alarm -> data = data;
   11460:	e588303c 	str	r3, [r8, #60]	; 0x3c
    /*
     * Check and compute the deadline according to the
     * alarm mode passed as parameter.
     */

    cpu_timer_get (current_cpuid, & start_time);
   11464:	e1a00009 	mov	r0, r9
   11468:	e28d1010 	add	r1, sp, #16
   1146c:	e58d2008 	str	r2, [sp, #8]
   11470:	ebfffc2b 	bl	10524 <cpu_timer_get>

    switch (mode)
   11474:	e35b0001 	cmp	fp, #1
   11478:	e59d2008 	ldr	r2, [sp, #8]
   1147c:	3a00000b 	bcc	114b0 <alarm_create+0x130>
   11480:	e35b0002 	cmp	fp, #2
   11484:	9a000041 	bls	11590 <alarm_create+0x210>
   11488:	e35b0004 	cmp	fp, #4
   1148c:	1a000007 	bne	114b0 <alarm_create+0x130>
          break;
        }

      case DNA_ONE_SHOT_ABSOLUTE_ALARM :
        {
          check (bad_quantum, quantum > start_time, DNA_BAD_ARGUMENT);
   11490:	e1cd01d0 	ldrd	r0, [sp, #16]
   11494:	e1500006 	cmp	r0, r6
   11498:	e0d13007 	sbcs	r3, r1, r7
   1149c:	aa000048 	bge	115c4 <alarm_create+0x244>

          new_alarm -> quantum = quantum - start_time;
   114a0:	e0560000 	subs	r0, r6, r0
   114a4:	e0c71001 	sbc	r1, r7, r1
          new_alarm -> deadline = quantum;
   114a8:	e1c862f8 	strd	r6, [r8, #40]	; 0x28

      case DNA_ONE_SHOT_ABSOLUTE_ALARM :
        {
          check (bad_quantum, quantum > start_time, DNA_BAD_ARGUMENT);

          new_alarm -> quantum = quantum - start_time;
   114ac:	e1c802f0 	strd	r0, [r8, #32]

    /*
     * Deal with the new alarm
     */

    lock_acquire (& cpu -> lock);
   114b0:	e08aa009 	add	sl, sl, r9
   114b4:	e1a0a30a 	lsl	sl, sl, #6
   114b8:	e082b00a 	add	fp, r2, sl
   114bc:	e28bb014 	add	fp, fp, #20
   114c0:	e1a0000b 	mov	r0, fp
   114c4:	e58d2008 	str	r2, [sp, #8]
   114c8:	ebfffd3c 	bl	109c0 <lock_acquire>
    old_alarm = cpu -> current_alarm;
   114cc:	e59d2008 	ldr	r2, [sp, #8]
   114d0:	e082200a 	add	r2, r2, sl
   114d4:	e2826e23 	add	r6, r2, #560	; 0x230
   114d8:	e5967004 	ldr	r7, [r6, #4]

    if (cpu -> current_alarm == NULL ||
   114dc:	e3570000 	cmp	r7, #0
   114e0:	0a000040 	beq	115e8 <alarm_create+0x268>
   114e4:	e1c742d8 	ldrd	r4, [r7, #40]	; 0x28
   114e8:	e1c822d8 	ldrd	r2, [r8, #40]	; 0x28
   114ec:	e1520004 	cmp	r2, r4
   114f0:	e0d31005 	sbcs	r1, r3, r5
   114f4:	aa00002b 	bge	115a8 <alarm_create+0x228>
       * Check if we are still in the game, although
       * we spent time preparing the alarm. It should fail
       * on a 100Mhz RISC processos for an alarm < 20 usec.
       */

      cpu_timer_get (current_cpuid, & updated_time);
   114f8:	e1a00009 	mov	r0, r9
   114fc:	e28d1018 	add	r1, sp, #24
   11500:	ebfffc07 	bl	10524 <cpu_timer_get>
      updated_quantum = new_alarm -> deadline - updated_time;
   11504:	e1cd21d8 	ldrd	r2, [sp, #24]
   11508:	e1c842d8 	ldrd	r4, [r8, #40]	; 0x28
   1150c:	e0544002 	subs	r4, r4, r2
   11510:	e0c55003 	sbc	r5, r5, r3
      check (short_quantum, updated_quantum > 0, DNA_ERROR);
   11514:	e3540001 	cmp	r4, #1
   11518:	e2d52000 	sbcs	r2, r5, #0
   1151c:	ba00002d 	blt	115d8 <alarm_create+0x258>
       * alarm if this is necessary.
       */

      if (old_alarm != NULL)
      {
        cpu_timer_cancel (current_cpuid);
   11520:	e1a00009 	mov	r0, r9
   11524:	ebfffbf7 	bl	10508 <cpu_timer_cancel>
      }

      cpu -> current_alarm = new_alarm;
      cpu_timer_set (current_cpuid, updated_quantum);
   11528:	e1a00009 	mov	r0, r9
   1152c:	e1a02004 	mov	r2, r4
   11530:	e1a03005 	mov	r3, r5
      if (old_alarm != NULL)
      {
        cpu_timer_cancel (current_cpuid);
      }

      cpu -> current_alarm = new_alarm;
   11534:	e5868004 	str	r8, [r6, #4]
      cpu_timer_set (current_cpuid, updated_quantum);
   11538:	ebfffc10 	bl	10580 <cpu_timer_set>

      if (old_alarm != NULL)
      {
        queue_insert (& cpu -> alarm_queue, alarm_comparator, old_alarm);
   1153c:	e59f20e8 	ldr	r2, [pc, #232]	; 1162c <alarm_create+0x2ac>
   11540:	e28a0f8e 	add	r0, sl, #568	; 0x238
   11544:	e0820000 	add	r0, r2, r0
   11548:	e59f10e0 	ldr	r1, [pc, #224]	; 11630 <alarm_create+0x2b0>
   1154c:	e1a02007 	mov	r2, r7
   11550:	ebfffb61 	bl	102dc <queue_insert>

    /*
     * Unlock everything and return the alarm.
     */

    lock_release (& cpu -> lock);
   11554:	e1a0000b 	mov	r0, fp
   11558:	eb0007cc 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   1155c:	e59d000c 	ldr	r0, [sp, #12]
   11560:	ebfffc03 	bl	10574 <cpu_trap_restore>

    *aid = new_alarm -> id . raw;
   11564:	e5983004 	ldr	r3, [r8, #4]
   11568:	e59d104c 	ldr	r1, [sp, #76]	; 0x4c
    return DNA_OK;
   1156c:	e3a00000 	mov	r0, #0
     */

    lock_release (& cpu -> lock);
    cpu_trap_restore(it_status);

    *aid = new_alarm -> id . raw;
   11570:	e5813000 	str	r3, [r1]
    return DNA_OK;
   11574:	eaffff8c 	b	113ac <alarm_create+0x2c>
  }

  rescue (no_alarm)
  {
    lock_release (& alarm_pool . lock);
   11578:	e1a0000a 	mov	r0, sl
   1157c:	eb0007c3 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   11580:	e59d000c 	ldr	r0, [sp, #12]
   11584:	ebfffbfa 	bl	10574 <cpu_trap_restore>
    leave;
   11588:	e59f00a4 	ldr	r0, [pc, #164]	; 11634 <alarm_create+0x2b4>
   1158c:	eaffff86 	b	113ac <alarm_create+0x2c>
    {
      case DNA_PERIODIC_ALARM :
      case DNA_ONE_SHOT_RELATIVE_ALARM :
        {
          new_alarm -> quantum = quantum;
          new_alarm -> deadline = quantum + start_time;
   11590:	e1cd01d0 	ldrd	r0, [sp, #16]
   11594:	e0900006 	adds	r0, r0, r6
   11598:	e0a11007 	adc	r1, r1, r7
    switch (mode)
    {
      case DNA_PERIODIC_ALARM :
      case DNA_ONE_SHOT_RELATIVE_ALARM :
        {
          new_alarm -> quantum = quantum;
   1159c:	e1c862f0 	strd	r6, [r8, #32]
          new_alarm -> deadline = quantum + start_time;
   115a0:	e1c802f8 	strd	r0, [r8, #40]	; 0x28
          break;
   115a4:	eaffffc1 	b	114b0 <alarm_create+0x130>
    else
    {
dna_log(VERBOSE_LEVEL, "Enqueue alarm (%d:%d)",
          new_alarm -> id . s . value, new_alarm -> id . s . index);

      queue_insert (& cpu -> alarm_queue, alarm_comparator, new_alarm);
   115a8:	e59f307c 	ldr	r3, [pc, #124]	; 1162c <alarm_create+0x2ac>
   115ac:	e28a0f8e 	add	r0, sl, #568	; 0x238
   115b0:	e0830000 	add	r0, r3, r0
   115b4:	e59f1074 	ldr	r1, [pc, #116]	; 11630 <alarm_create+0x2b0>
   115b8:	e1a02008 	mov	r2, r8
   115bc:	ebfffb46 	bl	102dc <queue_insert>
   115c0:	eaffffe3 	b	11554 <alarm_create+0x1d4>
          break;
        }

      case DNA_ONE_SHOT_ABSOLUTE_ALARM :
        {
          check (bad_quantum, quantum > start_time, DNA_BAD_ARGUMENT);
   115c4:	e59f4054 	ldr	r4, [pc, #84]	; 11620 <alarm_create+0x2a0>
    lock_release (& cpu -> lock);
  }

  rescue (bad_quantum)
  {
    cpu_trap_restore(it_status);
   115c8:	e59d000c 	ldr	r0, [sp, #12]
   115cc:	ebfffbe8 	bl	10574 <cpu_trap_restore>
    leave;
   115d0:	e1a00004 	mov	r0, r4
   115d4:	eaffff74 	b	113ac <alarm_create+0x2c>
    leave;
  }

  rescue (short_quantum)
  {
    lock_release (& cpu -> lock);
   115d8:	e1a0000b 	mov	r0, fp
   115dc:	eb0007ab 	bl	13490 <lock_release>
       * on a 100Mhz RISC processos for an alarm < 20 usec.
       */

      cpu_timer_get (current_cpuid, & updated_time);
      updated_quantum = new_alarm -> deadline - updated_time;
      check (short_quantum, updated_quantum > 0, DNA_ERROR);
   115e0:	e59f4050 	ldr	r4, [pc, #80]	; 11638 <alarm_create+0x2b8>
   115e4:	eafffff7 	b	115c8 <alarm_create+0x248>
       * Check if we are still in the game, although
       * we spent time preparing the alarm. It should fail
       * on a 100Mhz RISC processos for an alarm < 20 usec.
       */

      cpu_timer_get (current_cpuid, & updated_time);
   115e8:	e1a00009 	mov	r0, r9
   115ec:	e28d1018 	add	r1, sp, #24
   115f0:	ebfffbcb 	bl	10524 <cpu_timer_get>
      updated_quantum = new_alarm -> deadline - updated_time;
   115f4:	e1cd01d8 	ldrd	r0, [sp, #24]
   115f8:	e1c822d8 	ldrd	r2, [r8, #40]	; 0x28
   115fc:	e0522000 	subs	r2, r2, r0
   11600:	e0c33001 	sbc	r3, r3, r1
      check (short_quantum, updated_quantum > 0, DNA_ERROR);
   11604:	e3520001 	cmp	r2, #1
   11608:	e2d31000 	sbcs	r1, r3, #0
   1160c:	bafffff1 	blt	115d8 <alarm_create+0x258>
      {
        cpu_timer_cancel (current_cpuid);
      }

      cpu -> current_alarm = new_alarm;
      cpu_timer_set (current_cpuid, updated_quantum);
   11610:	e1a00009 	mov	r0, r9
      if (old_alarm != NULL)
      {
        cpu_timer_cancel (current_cpuid);
      }

      cpu -> current_alarm = new_alarm;
   11614:	e5868004 	str	r8, [r6, #4]
      cpu_timer_set (current_cpuid, updated_quantum);
   11618:	ebfffbd8 	bl	10580 <cpu_timer_set>
   1161c:	eaffffcc 	b	11554 <alarm_create+0x1d4>
   11620:	0000fffc 	.word	0x0000fffc
   11624:	0018a918 	.word	0x0018a918
   11628:	0018b920 	.word	0x0018b920
   1162c:	001883e8 	.word	0x001883e8
   11630:	00012c0c 	.word	0x00012c0c
   11634:	0000fbfd 	.word	0x0000fbfd
   11638:	0000ffff 	.word	0x0000ffff

0001163c <lock_try>:
 * * DNA_OK: the lock has been taken
 *
 * SOURCE
 */

{
   1163c:	e92d4030 	push	{r4, r5, lr}
   11640:	e24dd00c 	sub	sp, sp, #12
   11644:	e1a04001 	mov	r4, r1
   11648:	e1a05000 	mov	r5, r0
  status_t status = DNA_OK;

  if (cpu_test_and_set (lock) == 1)
   1164c:	ebfffbed 	bl	10608 <cpu_test_and_set>
   11650:	e3500001 	cmp	r0, #1
   11654:	0a000009 	beq	11680 <lock_try+0x44>
    if (acquire) status = DNA_ERROR;
    else status = DNA_WOULD_BLOCK;
  }
  else 
  {
    if (! acquire) *lock = 0;
   11658:	e3540000 	cmp	r4, #0
    status = DNA_OK;
   1165c:	01a00004 	moveq	r0, r4
   11660:	13a00000 	movne	r0, #0
    if (acquire) status = DNA_ERROR;
    else status = DNA_WOULD_BLOCK;
  }
  else 
  {
    if (! acquire) *lock = 0;
   11664:	05854000 	streq	r4, [r5]
    status = DNA_OK;
  }

  cpu_cache_sync ();
   11668:	e3a03000 	mov	r3, #0
   1166c:	e58d3004 	str	r3, [sp, #4]
   11670:	e59d3004 	ldr	r3, [sp, #4]
   11674:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
  return status;
}
   11678:	e28dd00c 	add	sp, sp, #12
   1167c:	e8bd8030 	pop	{r4, r5, pc}
  status_t status = DNA_OK;

  if (cpu_test_and_set (lock) == 1)
  {
    if (acquire) status = DNA_ERROR;
    else status = DNA_WOULD_BLOCK;
   11680:	e59f300c 	ldr	r3, [pc, #12]	; 11694 <lock_try+0x58>
   11684:	e3540000 	cmp	r4, #0
   11688:	e59f0008 	ldr	r0, [pc, #8]	; 11698 <lock_try+0x5c>
   1168c:	01a00003 	moveq	r0, r3
   11690:	eafffff4 	b	11668 <lock_try+0x2c>
   11694:	0000fdfd 	.word	0x0000fdfd
   11698:	0000ffff 	.word	0x0000ffff

0001169c <port_write>:
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
   1169c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  interrupt_status_t it_status = 0;
  int8_t * message_buffer = NULL;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
   116a0:	e1a06820 	lsr	r6, r0, #16
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
   116a4:	e24dd024 	sub	sp, sp, #36	; 0x24
  interrupt_status_t it_status = 0;
  int8_t * message_buffer = NULL;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
   116a8:	e356003f 	cmp	r6, #63	; 0x3f
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
   116ac:	e1a08002 	mov	r8, r2
   116b0:	e1cd45d0 	ldrd	r4, [sp, #80]	; 0x50
   116b4:	e1a07000 	mov	r7, r0
   116b8:	e59d2048 	ldr	r2, [sp, #72]	; 0x48
  interrupt_status_t it_status = 0;
  int8_t * message_buffer = NULL;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
   116bc:	9a000002 	bls	116cc <port_write+0x30>
    if (message_buffer != NULL)
    {
      kernel_free (message_buffer);
    }

    leave;
   116c0:	e59f0248 	ldr	r0, [pc, #584]	; 11910 <port_write+0x274>
  }
}
   116c4:	e28dd024 	add	sp, sp, #36	; 0x24
   116c8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   116cc:	e3a0b068 	mov	fp, #104	; 0x68
   116d0:	e1a0a001 	mov	sl, r1

    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
   116d4:	e58d200c 	str	r2, [sp, #12]
   116d8:	e58d3008 	str	r3, [sp, #8]
   116dc:	ebfffb6b 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   116e0:	e00b069b 	mul	fp, fp, r6
    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);
   116e4:	e59f9228 	ldr	r9, [pc, #552]	; 11914 <port_write+0x278>

    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
   116e8:	e58d0014 	str	r0, [sp, #20]
    lock_acquire (& port_pool . lock);
   116ec:	e1a00009 	mov	r0, r9
   116f0:	ebfffcb2 	bl	109c0 <lock_acquire>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   116f4:	e089100b 	add	r1, r9, fp
   116f8:	e591000c 	ldr	r0, [r1, #12]
   116fc:	e1570000 	cmp	r7, r0
   11700:	0a000004 	beq	11718 <port_write+0x7c>
    leave;
  }

  rescue (bad_portid)
  {
    lock_release (& port_pool . lock);
   11704:	e1a00009 	mov	r0, r9
   11708:	eb000760 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   1170c:	e59d0014 	ldr	r0, [sp, #20]
   11710:	ebfffb97 	bl	10574 <cpu_trap_restore>
   11714:	eaffffe9 	b	116c0 <port_write+0x24>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    lock_acquire (& port -> lock);
   11718:	e28bb010 	add	fp, fp, #16
   1171c:	e08bb009 	add	fp, fp, r9
   11720:	e1a0000b 	mov	r0, fp
   11724:	e58d1010 	str	r1, [sp, #16]
   11728:	ebfffca4 	bl	109c0 <lock_acquire>
    lock_release (& port_pool . lock);
   1172c:	e1a00009 	mov	r0, r9
   11730:	eb000756 	bl	13490 <lock_release>

    read_sem = port -> read_sem;
    write_sem = port -> write_sem;
   11734:	e59d1010 	ldr	r1, [sp, #16]

    lock_release (& port -> lock);
   11738:	e1a0000b 	mov	r0, fp

    lock_acquire (& port -> lock);
    lock_release (& port_pool . lock);

    read_sem = port -> read_sem;
    write_sem = port -> write_sem;
   1173c:	e591c048 	ldr	ip, [r1, #72]	; 0x48
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    lock_acquire (& port -> lock);
    lock_release (& port_pool . lock);

    read_sem = port -> read_sem;
   11740:	e5911044 	ldr	r1, [r1, #68]	; 0x44
    write_sem = port -> write_sem;
   11744:	e58dc018 	str	ip, [sp, #24]
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    lock_acquire (& port -> lock);
    lock_release (& port_pool . lock);

    read_sem = port -> read_sem;
   11748:	e58d101c 	str	r1, [sp, #28]
    write_sem = port -> write_sem;

    lock_release (& port -> lock);
   1174c:	eb00074f 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   11750:	e59d0014 	ldr	r0, [sp, #20]
   11754:	ebfffb86 	bl	10574 <cpu_trap_restore>

    /*
     * Acquire the write semaphore.
     */

    status = semaphore_acquire (write_sem, 1, flags, timeout);
   11758:	e1cd40f0 	strd	r4, [sp]
   1175c:	e59d200c 	ldr	r2, [sp, #12]
   11760:	e59d0018 	ldr	r0, [sp, #24]
   11764:	e3a01001 	mov	r1, #1
   11768:	eb0001fb 	bl	11f5c <semaphore_acquire>
    ensure (status == DNA_OK, status);
   1176c:	e2504000 	subs	r4, r0, #0
   11770:	e59d3008 	ldr	r3, [sp, #8]
   11774:	1a000028 	bne	1181c <port_write+0x180>

    /*
     * Construct the message buffer, if necessary.
     */

    if (size != 0)
   11778:	e3530000 	cmp	r3, #0
   1177c:	0a000028 	beq	11824 <port_write+0x188>
    {
      message_buffer = kernel_malloc (size, false);
   11780:	e1a00003 	mov	r0, r3
   11784:	e1a01004 	mov	r1, r4
   11788:	eb000a40 	bl	14090 <kernel_malloc>
      check (no_mem, message_buffer != NULL, DNA_OUT_OF_MEM);
   1178c:	e250c000 	subs	ip, r0, #0
   11790:	e59d3008 	ldr	r3, [sp, #8]
   11794:	0a000024 	beq	1182c <port_write+0x190>

      dna_memcpy (message -> buffer, buffer, size);
   11798:	e594000c 	ldr	r0, [r4, #12]
   1179c:	e1a02003 	mov	r2, r3
   117a0:	e1a01008 	mov	r1, r8
   117a4:	e58d3008 	str	r3, [sp, #8]
   117a8:	e58dc010 	str	ip, [sp, #16]
   117ac:	ebfffa38 	bl	10094 <dna_memcpy>
   117b0:	e59d3008 	ldr	r3, [sp, #8]
   117b4:	e59dc010 	ldr	ip, [sp, #16]
    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   117b8:	e3a08068 	mov	r8, #104	; 0x68
    /*
     * Get the port once again, just to make sure
     * it has not been destroyed in the meantime.
     */

    it_status = cpu_trap_mask_and_backup ();
   117bc:	e58dc010 	str	ip, [sp, #16]
   117c0:	e58d3008 	str	r3, [sp, #8]
   117c4:	ebfffb31 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   117c8:	e0259698 	mla	r5, r8, r6, r9
     * Get the port once again, just to make sure
     * it has not been destroyed in the meantime.
     */

    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);
   117cc:	e59f4140 	ldr	r4, [pc, #320]	; 11914 <port_write+0x278>
    /*
     * Get the port once again, just to make sure
     * it has not been destroyed in the meantime.
     */

    it_status = cpu_trap_mask_and_backup ();
   117d0:	e58d0014 	str	r0, [sp, #20]
    lock_acquire (& port_pool . lock);
   117d4:	e1a00004 	mov	r0, r4
   117d8:	ebfffc78 	bl	109c0 <lock_acquire>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   117dc:	e595100c 	ldr	r1, [r5, #12]
   117e0:	e59dc010 	ldr	ip, [sp, #16]
   117e4:	e1570001 	cmp	r7, r1
   117e8:	0a000015 	beq	11844 <port_write+0x1a8>
    leave;
  }

  rescue (bad_portid)
  {
    lock_release (& port_pool . lock);
   117ec:	e1a00004 	mov	r0, r4
   117f0:	e58dc010 	str	ip, [sp, #16]
   117f4:	eb000725 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   117f8:	e59d0014 	ldr	r0, [sp, #20]
   117fc:	ebfffb5c 	bl	10574 <cpu_trap_restore>

    if (message_buffer != NULL)
   11800:	e59dc010 	ldr	ip, [sp, #16]
   11804:	e35c0000 	cmp	ip, #0
   11808:	0affffac 	beq	116c0 <port_write+0x24>
    {
      kernel_free (message_buffer);
   1180c:	e1a0000c 	mov	r0, ip
   11810:	eb000a53 	bl	14164 <kernel_free>
    }

    leave;
   11814:	e59f00f4 	ldr	r0, [pc, #244]	; 11910 <port_write+0x274>
   11818:	eaffffa9 	b	116c4 <port_write+0x28>
   1181c:	e1a00004 	mov	r0, r4
   11820:	eaffffa7 	b	116c4 <port_write+0x28>
  port_t port = NULL;
  port_id_t pid = { .raw = id };
  message_t message = NULL;
  status_t status;
  interrupt_status_t it_status = 0;
  int8_t * message_buffer = NULL;
   11824:	e1a0c003 	mov	ip, r3
   11828:	eaffffe2 	b	117b8 <port_write+0x11c>
    return DNA_OK;
  }

  rescue (no_mem)
  {
    semaphore_release (write_sem, 1, 0);
   1182c:	e59d0018 	ldr	r0, [sp, #24]
   11830:	e1a0200c 	mov	r2, ip
   11834:	e3a01001 	mov	r1, #1
   11838:	eb00068b 	bl	1326c <semaphore_release>
    leave;
   1183c:	e59f00d4 	ldr	r0, [pc, #212]	; 11918 <port_write+0x27c>
   11840:	eaffff9f 	b	116c4 <port_write+0x28>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    lock_acquire (& port -> lock);
   11844:	e1a0000b 	mov	r0, fp
   11848:	ebfffc5c 	bl	109c0 <lock_acquire>
    lock_release (& port_pool . lock);
   1184c:	e1a00004 	mov	r0, r4
   11850:	eb00070e 	bl	13490 <lock_release>

    check (bad_port, ! port -> closed ||
   11854:	e5d52014 	ldrb	r2, [r5, #20]
   11858:	e59d3008 	ldr	r3, [sp, #8]
   1185c:	e3520000 	cmp	r2, #0
   11860:	e59dc010 	ldr	ip, [sp, #16]
   11864:	0a000004 	beq	1187c <port_write+0x1e0>
   11868:	e0288896 	mla	r8, r6, r8, r8
   1186c:	e0844008 	add	r4, r4, r8
   11870:	e5942004 	ldr	r2, [r4, #4]
   11874:	e3520000 	cmp	r2, #0
   11878:	0a000019 	beq	118e4 <port_write+0x248>
    /*
     * Get the message from the message queue, and put
     * it the the mailbox.
     */

    message = queue_rem (& port -> message);
   1187c:	e3a02068 	mov	r2, #104	; 0x68
   11880:	e0060692 	mul	r6, r2, r6
   11884:	e2860050 	add	r0, r6, #80	; 0x50
   11888:	e0890000 	add	r0, r9, r0
   1188c:	e58d3008 	str	r3, [sp, #8]
   11890:	e58dc010 	str	ip, [sp, #16]
   11894:	ebfff695 	bl	f2f0 <queue_rem>
   11898:	e1a01000 	mov	r1, r0

    message -> code = code;
    message -> size = size;
   1189c:	e59d3008 	ldr	r3, [sp, #8]
    message -> buffer = message_buffer;
   118a0:	e59dc010 	ldr	ip, [sp, #16]

    queue_add (& port -> mailbox, message);
   118a4:	e2860060 	add	r0, r6, #96	; 0x60
     * it the the mailbox.
     */

    message = queue_rem (& port -> message);

    message -> code = code;
   118a8:	e581a004 	str	sl, [r1, #4]
    message -> size = size;
   118ac:	e5813008 	str	r3, [r1, #8]
    message -> buffer = message_buffer;
   118b0:	e581c00c 	str	ip, [r1, #12]

    queue_add (& port -> mailbox, message);
   118b4:	e0890000 	add	r0, r9, r0
   118b8:	ebfff955 	bl	fe14 <queue_add>

    lock_release (& port -> lock);
   118bc:	e1a0000b 	mov	r0, fp
   118c0:	eb0006f2 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   118c4:	e59d0014 	ldr	r0, [sp, #20]
   118c8:	ebfffb29 	bl	10574 <cpu_trap_restore>

    /*
     * Release the read semaphore, and return.
     */

    status = semaphore_release (read_sem, 1, DNA_NO_RESCHEDULE);
   118cc:	e3a01001 	mov	r1, #1
   118d0:	e1a02001 	mov	r2, r1
   118d4:	e59d001c 	ldr	r0, [sp, #28]
      kernel_free (message_buffer);
    }

    leave;
  }
}
   118d8:	e28dd024 	add	sp, sp, #36	; 0x24
   118dc:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

    /*
     * Release the read semaphore, and return.
     */

    status = semaphore_release (read_sem, 1, DNA_NO_RESCHEDULE);
   118e0:	ea000661 	b	1326c <semaphore_release>
    leave;
  }

  rescue (bad_port)
  {
    lock_release (& port -> lock);
   118e4:	e1a0000b 	mov	r0, fp
   118e8:	eb0006e8 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   118ec:	e59d0014 	ldr	r0, [sp, #20]
   118f0:	ebfffb1f 	bl	10574 <cpu_trap_restore>

    if (message_buffer != NULL)
   118f4:	e59dc010 	ldr	ip, [sp, #16]
   118f8:	e35c0000 	cmp	ip, #0
   118fc:	0a000001 	beq	11908 <port_write+0x26c>
    {
      kernel_free (message_buffer);
   11900:	e1a0000c 	mov	r0, ip
   11904:	eb000a16 	bl	14164 <kernel_free>
    }

    leave;
   11908:	e59f000c 	ldr	r0, [pc, #12]	; 1191c <port_write+0x280>
   1190c:	eaffff6c 	b	116c4 <port_write+0x28>
   11910:	0000faff 	.word	0x0000faff
   11914:	001835b8 	.word	0x001835b8
   11918:	0000fffd 	.word	0x0000fffd
   1191c:	0000ffff 	.word	0x0000ffff

00011920 <thread_create>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   11920:	e24dd008 	sub	sp, sp, #8
   11924:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  thread_t thread = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (handler != NULL && tid != NULL, DNA_BAD_ARGUMENT);
   11928:	e1a06000 	mov	r6, r0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   1192c:	e24dd014 	sub	sp, sp, #20
  thread_t thread = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (handler != NULL && tid != NULL, DNA_BAD_ARGUMENT);
   11930:	e59d0088 	ldr	r0, [sp, #136]	; 0x88
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   11934:	e28d4038 	add	r4, sp, #56	; 0x38
  thread_t thread = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (handler != NULL && tid != NULL, DNA_BAD_ARGUMENT);
   11938:	e3500000 	cmp	r0, #0
   1193c:	13560000 	cmpne	r6, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   11940:	e884000c 	stm	r4, {r2, r3}
   11944:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
   11948:	e59d7060 	ldr	r7, [sp, #96]	; 0x60
  thread_t thread = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (handler != NULL && tid != NULL, DNA_BAD_ARGUMENT);
   1194c:	1a000004 	bne	11964 <thread_create+0x44>
   11950:	e59f0194 	ldr	r0, [pc, #404]	; 11aec <thread_create+0x1cc>
  {
    cpu_trap_restore(it_status);
    lock_release (& thread_pool . lock);
    leave;
  }
}
   11954:	e28dd014 	add	sp, sp, #20
   11958:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1195c:	e28dd008 	add	sp, sp, #8
   11960:	e12fff1e 	bx	lr
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (handler != NULL && tid != NULL, DNA_BAD_ARGUMENT);
    ensure (info . group >= 0 && info . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
   11964:	e3530000 	cmp	r3, #0
   11968:	1afffff8 	bne	11950 <thread_create+0x30>

    /*
     * Check the content of the information structure.
     */

    ensure (info . affinity == DNA_NO_AFFINITY || (info . affinity >= 0
   1196c:	e3770001 	cmn	r7, #1
   11970:	e1a08001 	mov	r8, r1
   11974:	0a000004 	beq	1198c <thread_create+0x6c>
   11978:	e3570000 	cmp	r7, #0
   1197c:	bafffff3 	blt	11950 <thread_create+0x30>
   11980:	ebfffb4b 	bl	106b4 <cpu_mp_count>
   11984:	e1500007 	cmp	r0, r7
   11988:	dafffff0 	ble	11950 <thread_create+0x30>
          && info . affinity < cpu_mp_count ()), DNA_BAD_ARGUMENT);

    ensure (info . status == DNA_THREAD_SUSPENDED, DNA_BAD_ARGUMENT);
   1198c:	e1dd26b8 	ldrh	r2, [sp, #104]	; 0x68
   11990:	e59f3158 	ldr	r3, [pc, #344]	; 11af0 <thread_create+0x1d0>
   11994:	e1520003 	cmp	r2, r3
   11998:	1affffec 	bne	11950 <thread_create+0x30>
    ensure (info . resource == DNA_NO_RESOURCE, DNA_BAD_ARGUMENT);
   1199c:	e5dd506a 	ldrb	r5, [sp, #106]	; 0x6a
   119a0:	e3550000 	cmp	r5, #0
   119a4:	1affffe9 	bne	11950 <thread_create+0x30>
    ensure (info . resource_id == -1, DNA_BAD_ARGUMENT);
   119a8:	e59d206c 	ldr	r2, [sp, #108]	; 0x6c
   119ac:	e3720001 	cmn	r2, #1
   119b0:	1affffe6 	bne	11950 <thread_create+0x30>

    it_status = cpu_trap_mask_and_backup();
   119b4:	ebfffab5 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& thread_pool . lock);
   119b8:	e59fa134 	ldr	sl, [pc, #308]	; 11af4 <thread_create+0x1d4>

    ensure (info . status == DNA_THREAD_SUSPENDED, DNA_BAD_ARGUMENT);
    ensure (info . resource == DNA_NO_RESOURCE, DNA_BAD_ARGUMENT);
    ensure (info . resource_id == -1, DNA_BAD_ARGUMENT);

    it_status = cpu_trap_mask_and_backup();
   119bc:	e1a0b000 	mov	fp, r0
    lock_acquire (& thread_pool . lock);
   119c0:	e1a0000a 	mov	r0, sl
   119c4:	ebfffbfd 	bl	109c0 <lock_acquire>

    /*
     * Get an empty thread slot.
     */

    thread = queue_rem (& thread_pool . thread[info . group]);
   119c8:	e59f0128 	ldr	r0, [pc, #296]	; 11af8 <thread_create+0x1d8>
   119cc:	ebfff647 	bl	f2f0 <queue_rem>
    check (pool_error, thread != NULL, DNA_NO_MORE_SEM);
   119d0:	e2509000 	subs	r9, r0, #0
   119d4:	0a000028 	beq	11a7c <thread_create+0x15c>

    /*
     * Make the place clean.
     */

    index = thread -> id . s . index;
   119d8:	e5d9c01f 	ldrb	ip, [r9, #31]
    dna_memset (thread, 0, sizeof (struct _thread));
   119dc:	e1a01005 	mov	r1, r5
   119e0:	e3a020d0 	mov	r2, #208	; 0xd0
   119e4:	e58dc00c 	str	ip, [sp, #12]
   119e8:	ebfff6a1 	bl	f474 <dna_memset>

    thread -> id . s . index = index;
   119ec:	e59dc00c 	ldr	ip, [sp, #12]
    thread -> id . s . value = thread_pool . counter;
   119f0:	e1da20b4 	ldrh	r2, [sl, #4]
     */

    index = thread -> id . s . index;
    dna_memset (thread, 0, sizeof (struct _thread));

    thread -> id . s . index = index;
   119f4:	e5c9c01f 	strb	ip, [r9, #31]
    thread -> id . s . value = thread_pool . counter;
   119f8:	e1c921bc 	strh	r2, [r9, #28]

    /*
     * Release the pool.
     */

    lock_release (& thread_pool . lock);
   119fc:	e1a0000a 	mov	r0, sl
    dna_memset (thread, 0, sizeof (struct _thread));

    thread -> id . s . index = index;
    thread -> id . s . value = thread_pool . counter;

    thread_pool . counter += 1;
   11a00:	e2822001 	add	r2, r2, #1
   11a04:	e1ca20b4 	strh	r2, [sl, #4]

    /*
     * Release the pool.
     */

    lock_release (& thread_pool . lock);
   11a08:	eb0006a0 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   11a0c:	e1a0000b 	mov	r0, fp
   11a10:	ebfffad7 	bl	10574 <cpu_trap_restore>

    /*
     * Copy and adjust the information structure.
     */

    thread -> info = info;
   11a14:	e1a01004 	mov	r1, r4
     * Deal with the thread group. In the future, only the kernel
     * and the application server will be able to create thread for
     * a different group than self.
     */

    thread -> id . s . group = info . group;
   11a18:	e5c9501e 	strb	r5, [r9, #30]

    /*
     * Copy and adjust the information structure.
     */

    thread -> info = info;
   11a1c:	e2890020 	add	r0, r9, #32
   11a20:	e3a02050 	mov	r2, #80	; 0x50
   11a24:	eb001ae9 	bl	185d0 <memcpy>

    if (info . stack_base == NULL)
   11a28:	e59d1080 	ldr	r1, [sp, #128]	; 0x80
   11a2c:	e3510000 	cmp	r1, #0
   11a30:	0a00001b 	beq	11aa4 <thread_create+0x184>
      thread -> info . stack_base = kernel_malloc (info . stack_size, false);
      thread -> stack_allocated = true;
      check (no_mem, thread -> info . stack_base != NULL, DNA_OUT_OF_MEM);
    }

    if (info . affinity == DNA_NO_AFFINITY)
   11a34:	e3770001 	cmn	r7, #1
   11a38:	0a000016 	beq	11a98 <thread_create+0x178>
     * Fill in the signature
     */

    thread -> signature . handler = handler;
    thread -> signature . arguments = arguments;
    thread -> signature . it_restore = CPU_DEFAULT_ITRESTORE;
   11a3c:	e3a02013 	mov	r2, #19
    /*
     * Initialize the context.
     */

    cpu_context_init (& thread -> context, thread -> info . stack_base,
        thread -> info . stack_size, thread_bootstrap, & thread -> signature);
   11a40:	e2893074 	add	r3, r9, #116	; 0x74
     * Fill in the signature
     */

    thread -> signature . handler = handler;
    thread -> signature . arguments = arguments;
    thread -> signature . it_restore = CPU_DEFAULT_ITRESTORE;
   11a44:	e5892078 	str	r2, [r9, #120]	; 0x78

    /*
     * Fill in the signature
     */

    thread -> signature . handler = handler;
   11a48:	e5896074 	str	r6, [r9, #116]	; 0x74
    thread -> signature . arguments = arguments;
   11a4c:	e589807c 	str	r8, [r9, #124]	; 0x7c

    /*
     * Initialize the context.
     */

    cpu_context_init (& thread -> context, thread -> info . stack_base,
   11a50:	e58d3000 	str	r3, [sp]
   11a54:	e599206c 	ldr	r2, [r9, #108]	; 0x6c
   11a58:	e2890084 	add	r0, r9, #132	; 0x84
   11a5c:	e59f3098 	ldr	r3, [pc, #152]	; 11afc <thread_create+0x1dc>
   11a60:	e5991068 	ldr	r1, [r9, #104]	; 0x68
   11a64:	ebffb995 	bl	c0 <cpu_context_init>

    /*
     * Return the thread ID and success
     */

    *tid = thread -> id . raw;
   11a68:	e599301c 	ldr	r3, [r9, #28]
   11a6c:	e59d2088 	ldr	r2, [sp, #136]	; 0x88
    return DNA_OK;
   11a70:	e3a00000 	mov	r0, #0

    /*
     * Return the thread ID and success
     */

    *tid = thread -> id . raw;
   11a74:	e5823000 	str	r3, [r2]
    return DNA_OK;
   11a78:	eaffffb5 	b	11954 <thread_create+0x34>
    /*
     * Get an empty thread slot.
     */

    thread = queue_rem (& thread_pool . thread[info . group]);
    check (pool_error, thread != NULL, DNA_NO_MORE_SEM);
   11a7c:	e59f407c 	ldr	r4, [pc, #124]	; 11b00 <thread_create+0x1e0>
    queue_add (& thread_pool . thread[info . group], thread);
  }

  rescue (pool_error)
  {
    cpu_trap_restore(it_status);
   11a80:	e1a0000b 	mov	r0, fp
   11a84:	ebfffaba 	bl	10574 <cpu_trap_restore>
    lock_release (& thread_pool . lock);
   11a88:	e59f0064 	ldr	r0, [pc, #100]	; 11af4 <thread_create+0x1d4>
   11a8c:	eb00067f 	bl	13490 <lock_release>
    leave;
   11a90:	e1a00004 	mov	r0, r4
   11a94:	eaffffae 	b	11954 <thread_create+0x34>
      check (no_mem, thread -> info . stack_base != NULL, DNA_OUT_OF_MEM);
    }

    if (info . affinity == DNA_NO_AFFINITY)
    {
      thread -> info . affinity = cpu_mp_count ();
   11a98:	ebfffb05 	bl	106b4 <cpu_mp_count>
   11a9c:	e5890048 	str	r0, [r9, #72]	; 0x48
   11aa0:	eaffffe5 	b	11a3c <thread_create+0x11c>

    thread -> info = info;

    if (info . stack_base == NULL)
    {
      thread -> info . stack_base = kernel_malloc (info . stack_size, false);
   11aa4:	e59d0084 	ldr	r0, [sp, #132]	; 0x84
   11aa8:	eb000978 	bl	14090 <kernel_malloc>
      thread -> stack_allocated = true;
   11aac:	e3a03001 	mov	r3, #1
      check (no_mem, thread -> info . stack_base != NULL, DNA_OUT_OF_MEM);
   11ab0:	e3500000 	cmp	r0, #0

    thread -> info = info;

    if (info . stack_base == NULL)
    {
      thread -> info . stack_base = kernel_malloc (info . stack_size, false);
   11ab4:	e1a04000 	mov	r4, r0
   11ab8:	e5890068 	str	r0, [r9, #104]	; 0x68
      thread -> stack_allocated = true;
   11abc:	e5c93070 	strb	r3, [r9, #112]	; 0x70
      check (no_mem, thread -> info . stack_base != NULL, DNA_OUT_OF_MEM);
   11ac0:	1affffdb 	bne	11a34 <thread_create+0x114>
    return DNA_OK;
  }

  rescue (no_mem)
  {
    it_status = cpu_trap_mask_and_backup();
   11ac4:	ebfffa71 	bl	10490 <cpu_trap_mask_and_backup>
   11ac8:	e1a0b000 	mov	fp, r0
    lock_acquire (& thread_pool . lock);
   11acc:	e1a0000a 	mov	r0, sl
   11ad0:	ebfffbba 	bl	109c0 <lock_acquire>

    thread -> id . s . value = 0;
   11ad4:	e1c941bc 	strh	r4, [r9, #28]
    queue_add (& thread_pool . thread[info . group], thread);
   11ad8:	e1a01009 	mov	r1, r9
   11adc:	e59f0014 	ldr	r0, [pc, #20]	; 11af8 <thread_create+0x1d8>
   11ae0:	ebfff8cb 	bl	fe14 <queue_add>

    if (info . stack_base == NULL)
    {
      thread -> info . stack_base = kernel_malloc (info . stack_size, false);
      thread -> stack_allocated = true;
      check (no_mem, thread -> info . stack_base != NULL, DNA_OUT_OF_MEM);
   11ae4:	e59f4018 	ldr	r4, [pc, #24]	; 11b04 <thread_create+0x1e4>
   11ae8:	eaffffe4 	b	11a80 <thread_create+0x160>
   11aec:	0000fffc 	.word	0x0000fffc
   11af0:	0000d15a 	.word	0x0000d15a
   11af4:	00184fd0 	.word	0x00184fd0
   11af8:	001883d8 	.word	0x001883d8
   11afc:	000125d4 	.word	0x000125d4
   11b00:	0000fdfe 	.word	0x0000fdfe
   11b04:	0000fffd 	.word	0x0000fffd

00011b08 <port_get_info>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   11b08:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);
   11b0c:	e2516000 	subs	r6, r1, #0
   11b10:	0a000005 	beq	11b2c <port_get_info+0x24>
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
   11b14:	e1a05820 	lsr	r5, r0, #16
   11b18:	e355003f 	cmp	r5, #63	; 0x3f
   11b1c:	e1a04000 	mov	r4, r0
   11b20:	9a000003 	bls	11b34 <port_get_info+0x2c>
   11b24:	e59f0098 	ldr	r0, [pc, #152]	; 11bc4 <port_get_info+0xbc>
  {
    lock_release (& port_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
   11b28:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);
   11b2c:	e59f0094 	ldr	r0, [pc, #148]	; 11bc8 <port_get_info+0xc0>
   11b30:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);

    it_status = cpu_trap_mask_and_backup();
   11b34:	ebfffa55 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& port_pool . lock);
   11b38:	e59f708c 	ldr	r7, [pc, #140]	; 11bcc <port_get_info+0xc4>
  watch (status_t)
  {
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);

    it_status = cpu_trap_mask_and_backup();
   11b3c:	e1a09000 	mov	r9, r0
    lock_acquire (& port_pool . lock);
   11b40:	e1a00007 	mov	r0, r7
   11b44:	ebfffb9d 	bl	109c0 <lock_acquire>
     * Look for the port with ID id
     */

    port = & port_pool . data[pid . s . index];
    check (invalid_port, port != NULL, DNA_BAD_PORT_ID);
    check (invalid_port, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   11b48:	e3a03068 	mov	r3, #104	; 0x68
   11b4c:	e0050593 	mul	r5, r3, r5
   11b50:	e0878005 	add	r8, r7, r5
   11b54:	e598300c 	ldr	r3, [r8, #12]
   11b58:	e1540003 	cmp	r4, r3
   11b5c:	0a000005 	beq	11b78 <port_get_info+0x70>
    return status;
  }

  rescue (invalid_port)
  {
    lock_release (& port_pool . lock);
   11b60:	e1a00007 	mov	r0, r7
   11b64:	eb000649 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   11b68:	e1a00009 	mov	r0, r9
   11b6c:	ebfffa80 	bl	10574 <cpu_trap_restore>
    leave;
   11b70:	e59f004c 	ldr	r0, [pc, #76]	; 11bc4 <port_get_info+0xbc>
   11b74:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

    port = & port_pool . data[pid . s . index];
    check (invalid_port, port != NULL, DNA_BAD_PORT_ID);
    check (invalid_port, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    lock_acquire (& port -> lock);
   11b78:	e2855010 	add	r5, r5, #16
   11b7c:	e0855007 	add	r5, r5, r7
   11b80:	e1a00005 	mov	r0, r5
   11b84:	ebfffb8d 	bl	109c0 <lock_acquire>
    lock_release (& port_pool . lock);
   11b88:	e1a00007 	mov	r0, r7
   11b8c:	eb00063f 	bl	13490 <lock_release>

    /*
     * Copy the port information
     */

    *p_info = port -> info;
   11b90:	e288c018 	add	ip, r8, #24
   11b94:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
   11b98:	e8a6000f 	stmia	r6!, {r0, r1, r2, r3}
   11b9c:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
   11ba0:	e8a6000f 	stmia	r6!, {r0, r1, r2, r3}
   11ba4:	e89c0007 	ldm	ip, {r0, r1, r2}
   11ba8:	e8860007 	stm	r6, {r0, r1, r2}

    lock_release (& port -> lock);
   11bac:	e1a00005 	mov	r0, r5
   11bb0:	eb000636 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   11bb4:	e1a00009 	mov	r0, r9
   11bb8:	ebfffa6d 	bl	10574 <cpu_trap_restore>

    return status;
   11bbc:	e3a00000 	mov	r0, #0
   11bc0:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
   11bc4:	0000faff 	.word	0x0000faff
   11bc8:	0000fffc 	.word	0x0000fffc
   11bcc:	001835b8 	.word	0x001835b8

00011bd0 <alarm_handler>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   11bd0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11bd4:	e24dd04c 	sub	sp, sp, #76	; 0x4c
  queue_t alarm_garbage;
  alarm_t current_alarm = NULL, next_alarm = NULL;
  status_t status = DNA_OK;
  int32_t current_cpuid = cpu_mp_id (), liveness = 10;
   11bd8:	ebfffa82 	bl	105e8 <cpu_mp_id>
   11bdc:	e3a0100a 	mov	r1, #10
  bigtime_t start_time, quantum, current_deadline = 0, timer_delay;
  bigtime_t delta_start, delta_end, expected_deadline, expected_delay;
  volatile bool reschedule = false;
   11be0:	e3a03000 	mov	r3, #0
   11be4:	e0800180 	add	r0, r0, r0, lsl #3
   11be8:	e1a09300 	lsl	r9, r0, #6
   11bec:	e59f22a4 	ldr	r2, [pc, #676]	; 11e98 <alarm_handler+0x2c8>
   11bf0:	e2890f8e 	add	r0, r9, #568	; 0x238
   11bf4:	e082a009 	add	sl, r2, r9

{
  queue_t alarm_garbage;
  alarm_t current_alarm = NULL, next_alarm = NULL;
  status_t status = DNA_OK;
  int32_t current_cpuid = cpu_mp_id (), liveness = 10;
   11bf8:	e58d1010 	str	r1, [sp, #16]

      if (! current_alarm -> is_invalid
          && (current_alarm -> mode & DNA_PERIODIC_ALARM) != 0)
      {
        current_alarm -> deadline += current_alarm -> quantum;
        queue_insert (& cpu -> alarm_queue, alarm_comparator, current_alarm);
   11bfc:	e0821000 	add	r1, r2, r0
  alarm_t current_alarm = NULL, next_alarm = NULL;
  status_t status = DNA_OK;
  int32_t current_cpuid = cpu_mp_id (), liveness = 10;
  bigtime_t start_time, quantum, current_deadline = 0, timer_delay;
  bigtime_t delta_start, delta_end, expected_deadline, expected_delay;
  volatile bool reschedule = false;
   11c00:	e5cd301f 	strb	r3, [sp, #31]
 */

{
  queue_t alarm_garbage;
  alarm_t current_alarm = NULL, next_alarm = NULL;
  status_t status = DNA_OK;
   11c04:	e58d300c 	str	r3, [sp, #12]
  bool process_next_alarm = true;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];

  watch (status_t)
  {
    DNA_QUEUE_SET_DEFAULTS (alarm_garbage);
   11c08:	e58d3038 	str	r3, [sp, #56]	; 0x38
   11c0c:	e58d0008 	str	r0, [sp, #8]
   11c10:	e28aa014 	add	sl, sl, #20

    do
    {
      cpu_timer_get (cpu -> id, & start_time);
   11c14:	e0829009 	add	r9, r2, r9

      if (! current_alarm -> is_invalid
          && (current_alarm -> mode & DNA_PERIODIC_ALARM) != 0)
      {
        current_alarm -> deadline += current_alarm -> quantum;
        queue_insert (& cpu -> alarm_queue, alarm_comparator, current_alarm);
   11c18:	e58d1014 	str	r1, [sp, #20]
  bool process_next_alarm = true;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];

  watch (status_t)
  {
    DNA_QUEUE_SET_DEFAULTS (alarm_garbage);
   11c1c:	e58d303c 	str	r3, [sp, #60]	; 0x3c
   11c20:	e58d3040 	str	r3, [sp, #64]	; 0x40
   11c24:	e58d3044 	str	r3, [sp, #68]	; 0x44

    do
    {
      cpu_timer_get (cpu -> id, & start_time);
   11c28:	e599000c 	ldr	r0, [r9, #12]
   11c2c:	e28d1020 	add	r1, sp, #32
   11c30:	ebfffa3b 	bl	10524 <cpu_timer_get>
      /*
       * Lock the processor to access its queue and
       * its current alarm.
       */

      lock_acquire (& cpu -> lock);
   11c34:	e1a0000a 	mov	r0, sl
   11c38:	ebfffb60 	bl	109c0 <lock_acquire>
      current_alarm = cpu -> current_alarm;
   11c3c:	e5998234 	ldr	r8, [r9, #564]	; 0x234

      /*
       * Check if the current alarm is valid.
       */

      check (no_alarm, current_alarm != NULL, DNA_ERROR);
   11c40:	e3580000 	cmp	r8, #0
   11c44:	0a00008e 	beq	11e84 <alarm_handler+0x2b4>
      lock_acquire (& current_alarm -> lock);
   11c48:	e288b018 	add	fp, r8, #24
   11c4c:	e1a0000b 	mov	r0, fp
   11c50:	ebfffb5a 	bl	109c0 <lock_acquire>
dna_log(VERBOSE_LEVEL, "(%d:%d), %lld/%lld, of 0x%x @ %lld",
          current_alarm -> id . s . value, current_alarm -> id . s . index,
          current_alarm -> deadline, current_alarm -> quantum,
          current_alarm -> thread_id, start_time);

      current_deadline = current_alarm -> deadline;
   11c54:	e1c822d8 	ldrd	r2, [r8, #40]	; 0x28
   11c58:	e1cd20f0 	strd	r2, [sp]
      /*
       * Check if the alarm is valid. If so, check if
       * it is periodical and restart it if necessary.
       */

      if (! current_alarm -> is_invalid
   11c5c:	e5d83014 	ldrb	r3, [r8, #20]
   11c60:	e3530000 	cmp	r3, #0
   11c64:	1a000002 	bne	11c74 <alarm_handler+0xa4>
          && (current_alarm -> mode & DNA_PERIODIC_ALARM) != 0)
   11c68:	e5983010 	ldr	r3, [r8, #16]
   11c6c:	e3130001 	tst	r3, #1
   11c70:	1a00006d 	bne	11e2c <alarm_handler+0x25c>
        current_alarm -> deadline += current_alarm -> quantum;
        queue_insert (& cpu -> alarm_queue, alarm_comparator, current_alarm);
      }
      else
      {
        queue_add (& alarm_garbage, current_alarm);
   11c74:	e1a01008 	mov	r1, r8
   11c78:	e28d0038 	add	r0, sp, #56	; 0x38
   11c7c:	ebfff864 	bl	fe14 <queue_add>
   11c80:	e59f2210 	ldr	r2, [pc, #528]	; 11e98 <alarm_handler+0x2c8>
   11c84:	e59d1008 	ldr	r1, [sp, #8]
   11c88:	e0827001 	add	r7, r2, r1
      }

      lock_release (& current_alarm -> lock);
   11c8c:	e1a0000b 	mov	r0, fp
   11c90:	eb0005fe 	bl	13490 <lock_release>

      /*
       * Look through the next alarm if no reschedule is needed.
       */

      while ((next_alarm = queue_rem (& cpu -> alarm_queue)) != NULL)
   11c94:	ea000009 	b	11cc0 <alarm_handler+0xf0>
      {
        lock_acquire (& next_alarm -> lock);
   11c98:	e1a00006 	mov	r0, r6
   11c9c:	ebfffb47 	bl	109c0 <lock_acquire>

        if (! next_alarm -> is_invalid)
   11ca0:	e5d43014 	ldrb	r3, [r4, #20]
   11ca4:	e3530000 	cmp	r3, #0
   11ca8:	0a00002b 	beq	11d5c <alarm_handler+0x18c>
        {
          lock_release (& next_alarm -> lock);
          break;
        }

        queue_add (& alarm_garbage, next_alarm);
   11cac:	e1a01004 	mov	r1, r4
   11cb0:	e28d0038 	add	r0, sp, #56	; 0x38
   11cb4:	ebfff856 	bl	fe14 <queue_add>
        lock_release (& next_alarm -> lock);
   11cb8:	e1a00006 	mov	r0, r6
   11cbc:	eb0005f3 	bl	13490 <lock_release>

      /*
       * Look through the next alarm if no reschedule is needed.
       */

      while ((next_alarm = queue_rem (& cpu -> alarm_queue)) != NULL)
   11cc0:	e1a00007 	mov	r0, r7
   11cc4:	ebfff589 	bl	f2f0 <queue_rem>
   11cc8:	e2504000 	subs	r4, r0, #0
      {
        lock_acquire (& next_alarm -> lock);
   11ccc:	e2846018 	add	r6, r4, #24

      /*
       * Look through the next alarm if no reschedule is needed.
       */

      while ((next_alarm = queue_rem (& cpu -> alarm_queue)) != NULL)
   11cd0:	1afffff0 	bne	11c98 <alarm_handler+0xc8>
       * Unlock the processor since we do not need its
       * data anymore.
       */
        
      cpu -> current_alarm = next_alarm;
      lock_release (& cpu -> lock);
   11cd4:	e1a0000a 	mov	r0, sl
      /*
       * Unlock the processor since we do not need its
       * data anymore.
       */
        
      cpu -> current_alarm = next_alarm;
   11cd8:	e5894234 	str	r4, [r9, #564]	; 0x234
      lock_release (& cpu -> lock);
   11cdc:	eb0005eb 	bl	13490 <lock_release>

      /*
       * Execute the alarm, and compute its WCET.
	   *    if and only if it is still valid.
       */
	  if (!current_alarm->is_invalid){
   11ce0:	e5d83014 	ldrb	r3, [r8, #20]
   11ce4:	e3530000 	cmp	r3, #0
   11ce8:	0a00003c 	beq	11de0 <alarm_handler+0x210>

      /*
       * Update the reschedule flag.
       */

      reschedule = reschedule || status == DNA_INVOKE_SCHEDULER;
   11cec:	e5dd301f 	ldrb	r3, [sp, #31]
   11cf0:	e21330ff 	ands	r3, r3, #255	; 0xff
   11cf4:	059d000c 	ldreq	r0, [sp, #12]
   11cf8:	02403003 	subeq	r3, r0, #3
   11cfc:	016f3f13 	clzeq	r3, r3
   11d00:	01a032a3 	lsreq	r3, r3, #5
    }
    while (process_next_alarm);
   11d04:	e3540000 	cmp	r4, #0

      /*
       * Update the reschedule flag.
       */

      reschedule = reschedule || status == DNA_INVOKE_SCHEDULER;
   11d08:	e5cd301f 	strb	r3, [sp, #31]
    }
    while (process_next_alarm);
   11d0c:	1affffc5 	bne	11c28 <alarm_handler+0x58>
   11d10:	ea000006 	b	11d30 <alarm_handler+0x160>
     * Parse the garbage and delete its content.
     */

    while ((current_alarm = queue_rem (& alarm_garbage)) != NULL)
    {
      current_alarm -> id . s . value = 0;
   11d14:	e1c540b4 	strh	r4, [r5, #4]

      lock_acquire (& alarm_pool . lock);
   11d18:	ebfffb28 	bl	109c0 <lock_acquire>
      queue_add (& alarm_pool . alarm, current_alarm);
   11d1c:	e1a01005 	mov	r1, r5
   11d20:	e59f0174 	ldr	r0, [pc, #372]	; 11e9c <alarm_handler+0x2cc>
   11d24:	ebfff83a 	bl	fe14 <queue_add>
      lock_release (& alarm_pool . lock);
   11d28:	e59f0170 	ldr	r0, [pc, #368]	; 11ea0 <alarm_handler+0x2d0>
   11d2c:	eb0005d7 	bl	13490 <lock_release>

    /*
     * Parse the garbage and delete its content.
     */

    while ((current_alarm = queue_rem (& alarm_garbage)) != NULL)
   11d30:	e28d0038 	add	r0, sp, #56	; 0x38
   11d34:	ebfff56d 	bl	f2f0 <queue_rem>
   11d38:	e2505000 	subs	r5, r0, #0
    {
      current_alarm -> id . s . value = 0;

      lock_acquire (& alarm_pool . lock);
   11d3c:	e59f015c 	ldr	r0, [pc, #348]	; 11ea0 <alarm_handler+0x2d0>

    /*
     * Parse the garbage and delete its content.
     */

    while ((current_alarm = queue_rem (& alarm_garbage)) != NULL)
   11d40:	1afffff3 	bne	11d14 <alarm_handler+0x144>
      lock_acquire (& alarm_pool . lock);
      queue_add (& alarm_pool . alarm, current_alarm);
      lock_release (& alarm_pool . lock);
    }

    return reschedule ? DNA_INVOKE_SCHEDULER : DNA_OK;
   11d44:	e5dd001f 	ldrb	r0, [sp, #31]
   11d48:	e3500000 	cmp	r0, #0
   11d4c:	13a00003 	movne	r0, #3
   11d50:	03a00000 	moveq	r0, #0
  rescue (no_alarm)
  {
    lock_release (& cpu -> lock);
    leave;
  }
}
   11d54:	e28dd04c 	add	sp, sp, #76	; 0x4c
   11d58:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
      {
        lock_acquire (& next_alarm -> lock);

        if (! next_alarm -> is_invalid)
        {
          lock_release (& next_alarm -> lock);
   11d5c:	e1a00006 	mov	r0, r6
   11d60:	eb0005ca 	bl	13490 <lock_release>
       * Unlock the processor since we do not need its
       * data anymore.
       */
        
      cpu -> current_alarm = next_alarm;
      lock_release (& cpu -> lock);
   11d64:	e1a0000a 	mov	r0, sl
      /*
       * Unlock the processor since we do not need its
       * data anymore.
       */
        
      cpu -> current_alarm = next_alarm;
   11d68:	e5894234 	str	r4, [r9, #564]	; 0x234
      lock_release (& cpu -> lock);
   11d6c:	eb0005c7 	bl	13490 <lock_release>
        /*
         * If we are dealing with the same alarm as the current one,
         * we need to decrease the liveness counter.
         */

        liveness = current_alarm == next_alarm ? liveness - 1 : 10;
   11d70:	e1580004 	cmp	r8, r4
   11d74:	0a000037 	beq	11e58 <alarm_handler+0x288>
   11d78:	e3a0300a 	mov	r3, #10
   11d7c:	e58d3010 	str	r3, [sp, #16]

        /*
         * Compute the delays and the expected deadline.
         */

        timer_delay = start_time - current_deadline;
   11d80:	e1cd22d0 	ldrd	r2, [sp, #32]
        expected_deadline = start_time + timer_delay
          + current_alarm -> execution_time;
        expected_delay = expected_deadline - next_alarm -> deadline;
   11d84:	e1c402d8 	ldrd	r0, [r4, #40]	; 0x28

        /*
         * Compute the delays and the expected deadline.
         */

        timer_delay = start_time - current_deadline;
   11d88:	e1cd40d0 	ldrd	r4, [sp]
   11d8c:	e0524004 	subs	r4, r2, r4
   11d90:	e0c35005 	sbc	r5, r3, r5
        expected_deadline = start_time + timer_delay
   11d94:	e0944002 	adds	r4, r4, r2
   11d98:	e1c863d0 	ldrd	r6, [r8, #48]	; 0x30
   11d9c:	e0a55003 	adc	r5, r5, r3
   11da0:	e0942006 	adds	r2, r4, r6
   11da4:	e0a53007 	adc	r3, r5, r7
          + current_alarm -> execution_time;
        expected_delay = expected_deadline - next_alarm -> deadline;
   11da8:	e0522000 	subs	r2, r2, r0
   11dac:	e0c33001 	sbc	r3, r3, r1
        /*
         * If the deadline is way out of base, restart the loop,
         * otherwise program the timer.
         */

        if (expected_delay > 0)
   11db0:	e3520001 	cmp	r2, #1
   11db4:	e2d31000 	sbcs	r1, r3, #0
        {
dna_log(VERBOSE_LEVEL, "Over by %d ns, alarm (%d:%d) from thread 0x%x.",
              (int32_t) expected_delay, next_alarm -> id . s . value,
              next_alarm -> id . s . index, next_alarm -> thread_id);

          process_next_alarm = true;
   11db8:	a3a04001 	movge	r4, #1
        /*
         * If the deadline is way out of base, restart the loop,
         * otherwise program the timer.
         */

        if (expected_delay > 0)
   11dbc:	aaffffc7 	bge	11ce0 <alarm_handler+0x110>

          process_next_alarm = true;
        }
        else
        {
          cpu_timer_set (cpu -> id, -1 * expected_delay);
   11dc0:	e2722000 	rsbs	r2, r2, #0
   11dc4:	e2e33000 	rsc	r3, r3, #0
   11dc8:	e599000c 	ldr	r0, [r9, #12]
   11dcc:	ebfff9eb 	bl	10580 <cpu_timer_set>

      /*
       * Execute the alarm, and compute its WCET.
	   *    if and only if it is still valid.
       */
	  if (!current_alarm->is_invalid){
   11dd0:	e5d83014 	ldrb	r3, [r8, #20]
      current_deadline = current_alarm -> deadline;

      check (false_alarm, process_next_alarm ||
          current_deadline < start_time, DNA_ERROR);

      process_next_alarm = false;
   11dd4:	e3a04000 	mov	r4, #0

      /*
       * Execute the alarm, and compute its WCET.
	   *    if and only if it is still valid.
       */
	  if (!current_alarm->is_invalid){
   11dd8:	e3530000 	cmp	r3, #0
   11ddc:	1affffc2 	bne	11cec <alarm_handler+0x11c>
		   cpu_timer_get (cpu -> id, & delta_start);
   11de0:	e28d1028 	add	r1, sp, #40	; 0x28
   11de4:	e599000c 	ldr	r0, [r9, #12]
   11de8:	ebfff9cd 	bl	10524 <cpu_timer_get>
		   status = current_alarm -> callback (current_alarm -> data);
   11dec:	e5983038 	ldr	r3, [r8, #56]	; 0x38
   11df0:	e598003c 	ldr	r0, [r8, #60]	; 0x3c
   11df4:	e12fff33 	blx	r3
		   cpu_timer_get (cpu -> id, & delta_end);
   11df8:	e28d1030 	add	r1, sp, #48	; 0x30
       * Execute the alarm, and compute its WCET.
	   *    if and only if it is still valid.
       */
	  if (!current_alarm->is_invalid){
		   cpu_timer_get (cpu -> id, & delta_start);
		   status = current_alarm -> callback (current_alarm -> data);
   11dfc:	e58d000c 	str	r0, [sp, #12]
		   cpu_timer_get (cpu -> id, & delta_end);
   11e00:	e599000c 	ldr	r0, [r9, #12]
   11e04:	ebfff9c6 	bl	10524 <cpu_timer_get>

		   quantum = delta_end - delta_start;
   11e08:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
   11e0c:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
		   if (quantum > current_alarm -> execution_time)
   11e10:	e1c863d0 	ldrd	r6, [r8, #48]	; 0x30
	  if (!current_alarm->is_invalid){
		   cpu_timer_get (cpu -> id, & delta_start);
		   status = current_alarm -> callback (current_alarm -> data);
		   cpu_timer_get (cpu -> id, & delta_end);

		   quantum = delta_end - delta_start;
   11e14:	e0500002 	subs	r0, r0, r2
   11e18:	e0c11003 	sbc	r1, r1, r3
		   if (quantum > current_alarm -> execution_time)
   11e1c:	e1560000 	cmp	r6, r0
   11e20:	e0d72001 	sbcs	r2, r7, r1
		   {
				current_alarm -> execution_time = quantum;
   11e24:	b1c803f0 	strdlt	r0, [r8, #48]	; 0x30
   11e28:	eaffffaf 	b	11cec <alarm_handler+0x11c>
       */

      if (! current_alarm -> is_invalid
          && (current_alarm -> mode & DNA_PERIODIC_ALARM) != 0)
      {
        current_alarm -> deadline += current_alarm -> quantum;
   11e2c:	e1cd00d0 	ldrd	r0, [sp]
   11e30:	e1c822d0 	ldrd	r2, [r8, #32]
   11e34:	e0922000 	adds	r2, r2, r0
   11e38:	e0a33001 	adc	r3, r3, r1
        queue_insert (& cpu -> alarm_queue, alarm_comparator, current_alarm);
   11e3c:	e59d0014 	ldr	r0, [sp, #20]
       */

      if (! current_alarm -> is_invalid
          && (current_alarm -> mode & DNA_PERIODIC_ALARM) != 0)
      {
        current_alarm -> deadline += current_alarm -> quantum;
   11e40:	e1c822f8 	strd	r2, [r8, #40]	; 0x28
        queue_insert (& cpu -> alarm_queue, alarm_comparator, current_alarm);
   11e44:	e59f1058 	ldr	r1, [pc, #88]	; 11ea4 <alarm_handler+0x2d4>
   11e48:	e1a02008 	mov	r2, r8
   11e4c:	e1a07000 	mov	r7, r0
   11e50:	ebfff921 	bl	102dc <queue_insert>
   11e54:	eaffff8c 	b	11c8c <alarm_handler+0xbc>
         * we need to decrease the liveness counter.
         */

        liveness = current_alarm == next_alarm ? liveness - 1 : 10;

        if (liveness == 0)
   11e58:	e59d0010 	ldr	r0, [sp, #16]
   11e5c:	e2500001 	subs	r0, r0, #1
   11e60:	e58d0010 	str	r0, [sp, #16]
   11e64:	1affffc5 	bne	11d80 <alarm_handler+0x1b0>
        {
dna_log(PANIC_LEVEL,
              "Can't stabilize alarm (%d:%d) after 10 cycle, abandon.",
              next_alarm -> id . s . value, next_alarm -> id . s . index);

          lock_acquire (& next_alarm -> lock);
   11e68:	e1a0000b 	mov	r0, fp
   11e6c:	ebfffad3 	bl	109c0 <lock_acquire>
          next_alarm -> is_invalid = next_alarm -> is_invalid || liveness == 0;
   11e70:	e3a03001 	mov	r3, #1
          lock_release (& next_alarm -> lock);
   11e74:	e1a0000b 	mov	r0, fp
dna_log(PANIC_LEVEL,
              "Can't stabilize alarm (%d:%d) after 10 cycle, abandon.",
              next_alarm -> id . s . value, next_alarm -> id . s . index);

          lock_acquire (& next_alarm -> lock);
          next_alarm -> is_invalid = next_alarm -> is_invalid || liveness == 0;
   11e78:	e5c83014 	strb	r3, [r8, #20]
          lock_release (& next_alarm -> lock);
   11e7c:	eb000583 	bl	13490 <lock_release>
   11e80:	eaffffbe 	b	11d80 <alarm_handler+0x1b0>
    cpu_timer_set (cpu -> id, quantum);
  }

  rescue (no_alarm)
  {
    lock_release (& cpu -> lock);
   11e84:	e1a0000a 	mov	r0, sl
   11e88:	eb000580 	bl	13490 <lock_release>
    leave;
   11e8c:	e59f0014 	ldr	r0, [pc, #20]	; 11ea8 <alarm_handler+0x2d8>
  }
}
   11e90:	e28dd04c 	add	sp, sp, #76	; 0x4c
   11e94:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11e98:	001883e8 	.word	0x001883e8
   11e9c:	0018b920 	.word	0x0018b920
   11ea0:	0018a918 	.word	0x0018a918
   11ea4:	00012c0c 	.word	0x00012c0c
   11ea8:	0000ffff 	.word	0x0000ffff

00011eac <semaphore_alarm>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   11eac:	e92d4038 	push	{r3, r4, r5, lr}
  thread_t thread = data;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (thread != NULL, DNA_BAD_ARGUMENT);
   11eb0:	e2504000 	subs	r4, r0, #0
   11eb4:	0a000008 	beq	11edc <semaphore_alarm+0x30>
    ensure (thread -> resource_queue != NULL, DNA_ERROR);
   11eb8:	e5940018 	ldr	r0, [r4, #24]
   11ebc:	e3500000 	cmp	r0, #0
   11ec0:	0a000003 	beq	11ed4 <semaphore_alarm+0x28>
    ensure (thread -> info . status == DNA_THREAD_WAITING, DNA_ERROR);
   11ec4:	e1d425b0 	ldrh	r2, [r4, #80]	; 0x50
   11ec8:	e59f307c 	ldr	r3, [pc, #124]	; 11f4c <semaphore_alarm+0xa0>
   11ecc:	e1520003 	cmp	r2, r3
   11ed0:	0a000003 	beq	11ee4 <semaphore_alarm+0x38>
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (thread != NULL, DNA_BAD_ARGUMENT);
    ensure (thread -> resource_queue != NULL, DNA_ERROR);
   11ed4:	e59f0074 	ldr	r0, [pc, #116]	; 11f50 <semaphore_alarm+0xa4>
   11ed8:	e8bd8038 	pop	{r3, r4, r5, pc}
  thread_t thread = data;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (thread != NULL, DNA_BAD_ARGUMENT);
   11edc:	e59f0070 	ldr	r0, [pc, #112]	; 11f54 <semaphore_alarm+0xa8>
   11ee0:	e8bd8038 	pop	{r3, r4, r5, pc}
    ensure (thread -> resource_queue != NULL, DNA_ERROR);
    ensure (thread -> info . status == DNA_THREAD_WAITING, DNA_ERROR);
    ensure (thread -> info . resource == DNA_RESOURCE_SEMAPHORE, DNA_ERROR);
   11ee4:	e5d43052 	ldrb	r3, [r4, #82]	; 0x52
   11ee8:	e3530001 	cmp	r3, #1
   11eec:	1afffff8 	bne	11ed4 <semaphore_alarm+0x28>
    /*
     * Lock the thread's resource queue.
     * Extract the thread from the waiting list.
     */

    lock_acquire (& thread -> resource_queue -> lock);
   11ef0:	ebfffab2 	bl	109c0 <lock_acquire>
    status = queue_extract (thread -> resource_queue, thread);
   11ef4:	e1a01004 	mov	r1, r4
   11ef8:	e5940018 	ldr	r0, [r4, #24]
   11efc:	ebfff4b9 	bl	f1e8 <queue_extract>
   11f00:	e1a05000 	mov	r5, r0
    lock_release (& thread -> resource_queue -> lock);
   11f04:	e5940018 	ldr	r0, [r4, #24]
   11f08:	eb000560 	bl	13490 <lock_release>

    /*
     * If the thread was waiting, we can dispatch it
     */

    if (status == DNA_OK)
   11f0c:	e3550000 	cmp	r5, #0
   11f10:	0a000001 	beq	11f1c <semaphore_alarm+0x70>
   11f14:	e1a00005 	mov	r0, r5
      status = scheduler_dispatch (thread);
    }

    return status;
  }
}
   11f18:	e8bd8038 	pop	{r3, r4, r5, pc}
     * If the thread was waiting, we can dispatch it
     */

    if (status == DNA_OK)
    {
      lock_acquire (& thread -> lock);
   11f1c:	e2840014 	add	r0, r4, #20
   11f20:	ebfffaa6 	bl	109c0 <lock_acquire>

      thread -> resource_queue = NULL;
      thread -> info . sem_tokens = 0;
      thread -> info . resource = DNA_NO_RESOURCE;
      thread -> info . resource_id = -1;
   11f24:	e3e02000 	mvn	r2, #0

      thread -> info . status = DNA_THREAD_READY;
   11f28:	e59f3028 	ldr	r3, [pc, #40]	; 11f58 <semaphore_alarm+0xac>

    if (status == DNA_OK)
    {
      lock_acquire (& thread -> lock);

      thread -> resource_queue = NULL;
   11f2c:	e5845018 	str	r5, [r4, #24]
      thread -> info . sem_tokens = 0;
   11f30:	e584504c 	str	r5, [r4, #76]	; 0x4c
      thread -> info . resource = DNA_NO_RESOURCE;
   11f34:	e5c45052 	strb	r5, [r4, #82]	; 0x52
      thread -> info . resource_id = -1;
   11f38:	e5842054 	str	r2, [r4, #84]	; 0x54

      thread -> info . status = DNA_THREAD_READY;
   11f3c:	e1c435b0 	strh	r3, [r4, #80]	; 0x50
      status = scheduler_dispatch (thread);
   11f40:	e1a00004 	mov	r0, r4
    }

    return status;
  }
}
   11f44:	e8bd4038 	pop	{r3, r4, r5, lr}
      thread -> info . sem_tokens = 0;
      thread -> info . resource = DNA_NO_RESOURCE;
      thread -> info . resource_id = -1;

      thread -> info . status = DNA_THREAD_READY;
      status = scheduler_dispatch (thread);
   11f48:	ea0001f6 	b	12728 <scheduler_dispatch>
   11f4c:	0000b10c 	.word	0x0000b10c
   11f50:	0000ffff 	.word	0x0000ffff
   11f54:	0000fffc 	.word	0x0000fffc
   11f58:	ffffface 	.word	0xffffface

00011f5c <semaphore_acquire>:
 * SOURCE
 */

{
  bool has_alarm = false, can_interrupt = false;
  thread_t self = NULL, thread = NULL;
   11f5c:	e3a03000 	mov	r3, #0
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
   11f60:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t current_cpuid = 0;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tokens > 0, DNA_BAD_ARGUMENT);
   11f64:	e2516000 	subs	r6, r1, #0
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
   11f68:	e24dd03c 	sub	sp, sp, #60	; 0x3c
  bool has_alarm = false, can_interrupt = false;
  thread_t self = NULL, thread = NULL;
   11f6c:	e58d3028 	str	r3, [sp, #40]	; 0x28
   11f70:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  semaphore_t sem = NULL;
  semaphore_id_t sid = { .raw = id };
  status_t status = DNA_OK, alarm_status = DNA_OK;
   11f74:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
  int32_t alarm, rem_tokens;
  alarm_mode_t alarm_mode = DNA_ONE_SHOT_RELATIVE_ALARM;;
  uint32_t current_cpuid = 0;
  interrupt_status_t it_status = 0;
   11f78:	e58d3034 	str	r3, [sp, #52]	; 0x34

  watch (status_t)
  {
    ensure (tokens > 0, DNA_BAD_ARGUMENT);
   11f7c:	da00000c 	ble	11fb4 <semaphore_acquire+0x58>
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);
   11f80:	e1a05820 	lsr	r5, r0, #16
   11f84:	e3550a01 	cmp	r5, #4096	; 0x1000
   11f88:	e1a04000 	mov	r4, r0
   11f8c:	259f0410 	ldrcs	r0, [pc, #1040]	; 123a4 <semaphore_acquire+0x448>
   11f90:	3a00000a 	bcc	11fc0 <semaphore_acquire+0x64>
    sem -> info . tokens = rem_tokens + tokens;
    lock_release (& sem -> lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
   11f94:	e28dd03c 	add	sp, sp, #60	; 0x3c
   11f98:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
     */

    if ((flags & DNA_RELATIVE_TIMEOUT) != 0)
    {
      has_alarm = true;
      alarm_mode = DNA_ONE_SHOT_RELATIVE_ALARM;
   11f9c:	e3a09002 	mov	r9, #2
    {
      has_alarm = true;
      alarm_mode = DNA_ONE_SHOT_ABSOLUTE_ALARM;
    }

    ensure (! has_alarm || (has_alarm && timeout >= 0), DNA_BAD_ARGUMENT);
   11fa0:	e1cd06d0 	ldrd	r0, [sp, #96]	; 0x60
   11fa4:	e3500000 	cmp	r0, #0
   11fa8:	e2d11000 	sbcs	r1, r1, #0
   11fac:	a3a0b001 	movge	fp, #1
   11fb0:	aa000008 	bge	11fd8 <semaphore_acquire+0x7c>
  uint32_t current_cpuid = 0;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tokens > 0, DNA_BAD_ARGUMENT);
   11fb4:	e59f03ec 	ldr	r0, [pc, #1004]	; 123a8 <semaphore_acquire+0x44c>
    sem -> info . tokens = rem_tokens + tokens;
    lock_release (& sem -> lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
   11fb8:	e28dd03c 	add	sp, sp, #60	; 0x3c
   11fbc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

    /*
     * Check the flags for a timeout parameter.
     */

    if ((flags & DNA_RELATIVE_TIMEOUT) != 0)
   11fc0:	e3120002 	tst	r2, #2
   11fc4:	1afffff4 	bne	11f9c <semaphore_acquire+0x40>
    {
      has_alarm = true;
      alarm_mode = DNA_ONE_SHOT_RELATIVE_ALARM;
    }
    else if ((flags & DNA_ABSOLUTE_TIMEOUT) != 0)
   11fc8:	e212b004 	ands	fp, r2, #4
    {
      has_alarm = true;
      alarm_mode = DNA_ONE_SHOT_ABSOLUTE_ALARM;
   11fcc:	13a09004 	movne	r9, #4
   11fd0:	1afffff2 	bne	11fa0 <semaphore_acquire+0x44>
  thread_t self = NULL, thread = NULL;
  semaphore_t sem = NULL;
  semaphore_id_t sid = { .raw = id };
  status_t status = DNA_OK, alarm_status = DNA_OK;
  int32_t alarm, rem_tokens;
  alarm_mode_t alarm_mode = DNA_ONE_SHOT_RELATIVE_ALARM;;
   11fd4:	e3a09002 	mov	r9, #2
    /*
     * Disable the interrupts, and get the current
     * execution environment (cpuid, self_id).
     */

    it_status = cpu_trap_mask_and_backup();
   11fd8:	e58d200c 	str	r2, [sp, #12]
   11fdc:	ebfff92b 	bl	10490 <cpu_trap_mask_and_backup>
   11fe0:	e58d0034 	str	r0, [sp, #52]	; 0x34
    current_cpuid = cpu_mp_id();
   11fe4:	ebfff97f 	bl	105e8 <cpu_mp_id>
    self = cpu_pool . cpu[current_cpuid] . current_thread;
   11fe8:	e59f33bc 	ldr	r3, [pc, #956]	; 123ac <semaphore_acquire+0x450>
   11fec:	e0800180 	add	r0, r0, r0, lsl #3
   11ff0:	e0833300 	add	r3, r3, r0, lsl #6

    /*
     * Look for the semaphore with ID sid.
     */

    lock_acquire (& semaphore_pool . lock);
   11ff4:	e59f73b4 	ldr	r7, [pc, #948]	; 123b0 <semaphore_acquire+0x454>
     * execution environment (cpuid, self_id).
     */

    it_status = cpu_trap_mask_and_backup();
    current_cpuid = cpu_mp_id();
    self = cpu_pool . cpu[current_cpuid] . current_thread;
   11ff8:	e593322c 	ldr	r3, [r3, #556]	; 0x22c

    /*
     * Look for the semaphore with ID sid.
     */

    lock_acquire (& semaphore_pool . lock);
   11ffc:	e1a00007 	mov	r0, r7

    sem = & semaphore_pool . data[sid . s . index];
    check (bad_semid, sem != NULL, DNA_BAD_SEM_ID);
    check (bad_semid, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
   12000:	e1a08205 	lsl	r8, r5, #4
     * execution environment (cpuid, self_id).
     */

    it_status = cpu_trap_mask_and_backup();
    current_cpuid = cpu_mp_id();
    self = cpu_pool . cpu[current_cpuid] . current_thread;
   12004:	e58d3028 	str	r3, [sp, #40]	; 0x28

    /*
     * Look for the semaphore with ID sid.
     */

    lock_acquire (& semaphore_pool . lock);
   12008:	ebfffa6c 	bl	109c0 <lock_acquire>

    sem = & semaphore_pool . data[sid . s . index];
    check (bad_semid, sem != NULL, DNA_BAD_SEM_ID);
    check (bad_semid, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
   1200c:	e0883005 	add	r3, r8, r5
   12010:	e1a03103 	lsl	r3, r3, #2
   12014:	e087c003 	add	ip, r7, r3
   12018:	e59c100c 	ldr	r1, [ip, #12]
   1201c:	e1540001 	cmp	r4, r1
   12020:	159f437c 	ldrne	r4, [pc, #892]	; 123a4 <semaphore_acquire+0x448>
   12024:	0a000005 	beq	12040 <semaphore_acquire+0xe4>
    return status;
  }

  rescue (bad_semid)
  {
    lock_release (& semaphore_pool . lock);
   12028:	e59f0380 	ldr	r0, [pc, #896]	; 123b0 <semaphore_acquire+0x454>
   1202c:	eb000517 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   12030:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
   12034:	ebfff94e 	bl	10574 <cpu_trap_restore>
    leave;
   12038:	e1a00004 	mov	r0, r4
   1203c:	eaffffd4 	b	11f94 <semaphore_acquire+0x38>
    check (bad_semid, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);

dna_log(VERBOSE_LEVEL, "%s(#%d), %d:%d(#%d)", self -> info . name,
        tokens, sid . s . value, sid . s . index, sem -> info . tokens);

    lock_acquire (& sem -> lock);
   12040:	e283a010 	add	sl, r3, #16
   12044:	e08aa007 	add	sl, sl, r7
   12048:	e1a0000a 	mov	r0, sl
   1204c:	e58dc010 	str	ip, [sp, #16]
   12050:	e58d3014 	str	r3, [sp, #20]
   12054:	ebfffa59 	bl	109c0 <lock_acquire>
    lock_release (& semaphore_pool . lock);
   12058:	e1a00007 	mov	r0, r7
   1205c:	eb00050b 	bl	13490 <lock_release>

    /*
     * Remove the necessary tokens and decide what
     * to do next depending on the result.
     */
    cpu_dcache_invalidate((void*)&(sem->info.tokens), sizeof(int32_t));
   12060:	e59d3014 	ldr	r3, [sp, #20]
   12064:	e3a01004 	mov	r1, #4
   12068:	e0870003 	add	r0, r7, r3
   1206c:	e2800044 	add	r0, r0, #68	; 0x44
   12070:	ebfff972 	bl	10640 <cpu_dcache_invalidate>
    rem_tokens = sem -> info . tokens - tokens;
   12074:	e59dc010 	ldr	ip, [sp, #16]

    if (rem_tokens >= 0)
   12078:	e59d200c 	ldr	r2, [sp, #12]
    /*
     * Remove the necessary tokens and decide what
     * to do next depending on the result.
     */
    cpu_dcache_invalidate((void*)&(sem->info.tokens), sizeof(int32_t));
    rem_tokens = sem -> info . tokens - tokens;
   1207c:	e59c0044 	ldr	r0, [ip, #68]	; 0x44

    if (rem_tokens >= 0)
   12080:	e0501006 	subs	r1, r0, r6
    /*
     * Remove the necessary tokens and decide what
     * to do next depending on the result.
     */
    cpu_dcache_invalidate((void*)&(sem->info.tokens), sizeof(int32_t));
    rem_tokens = sem -> info . tokens - tokens;
   12084:	e58d0018 	str	r0, [sp, #24]

    if (rem_tokens >= 0)
   12088:	e58d101c 	str	r1, [sp, #28]
   1208c:	4a000011 	bmi	120d8 <semaphore_acquire+0x17c>

    /*
     * If the acquire succeeded, set the latest holder as self.
     */
    
    if (status == DNA_OK)
   12090:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
    {
      /*
       * Everything is OK, take the requested tokens.
       */

      sem -> info . tokens -= tokens;
   12094:	e58c1044 	str	r1, [ip, #68]	; 0x44

    /*
     * If the acquire succeeded, set the latest holder as self.
     */
    
    if (status == DNA_OK)
   12098:	e3530000 	cmp	r3, #0
   1209c:	1a000004 	bne	120b4 <semaphore_acquire+0x158>
   120a0:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
    {
      sem -> info . latest_holder = self -> id . raw;
   120a4:	e0885005 	add	r5, r8, r5
   120a8:	e591301c 	ldr	r3, [r1, #28]
   120ac:	e0877105 	add	r7, r7, r5, lsl #2
   120b0:	e5873048 	str	r3, [r7, #72]	; 0x48
    }

    lock_release (& sem -> lock);
   120b4:	e1a0000a 	mov	r0, sl
   120b8:	eb0004f4 	bl	13490 <lock_release>
    cpu_dcache_invalidate((void*)&it_status,sizeof(interrupt_status_t));
   120bc:	e28d0034 	add	r0, sp, #52	; 0x34
   120c0:	e3a01004 	mov	r1, #4
   120c4:	ebfff95d 	bl	10640 <cpu_dcache_invalidate>
    cpu_trap_restore(it_status);
   120c8:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
   120cc:	ebfff928 	bl	10574 <cpu_trap_restore>
    return status;
   120d0:	e1dd02b6 	ldrh	r0, [sp, #38]	; 0x26
   120d4:	eaffffae 	b	11f94 <semaphore_acquire+0x38>

      sem -> info . tokens -= tokens;
    }
    else
    {
      check (quick_abort, (! has_alarm) ||
   120d8:	e35b0000 	cmp	fp, #0
   120dc:	0a000009 	beq	12108 <semaphore_acquire+0x1ac>
   120e0:	e1cd26d0 	ldrd	r2, [sp, #96]	; 0x60
   120e4:	e1923003 	orrs	r3, r2, r3
   120e8:	1a000080 	bne	122f0 <semaphore_acquire+0x394>
   120ec:	e59f42c0 	ldr	r4, [pc, #704]	; 123b4 <semaphore_acquire+0x458>
    leave;
  }

  rescue (quick_abort)
  {
    lock_release (& sem -> lock);
   120f0:	e1a0000a 	mov	r0, sl
   120f4:	eb0004e5 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   120f8:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
   120fc:	ebfff91c 	bl	10574 <cpu_trap_restore>
    leave;
   12100:	e1a00004 	mov	r0, r4
   12104:	eaffffa2 	b	11f94 <semaphore_acquire+0x38>

      /*
       * Update self information.
       */

      lock_acquire (& self -> lock);
   12108:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
      /*
       * Not enough tokens. Set the sem -> tokens to 0.
       * Create the alarm if necessary.
       */

      sem -> info . tokens = 0;
   1210c:	e58cb044 	str	fp, [ip, #68]	; 0x44

      /*
       * Update self information.
       */

      lock_acquire (& self -> lock);
   12110:	e2800014 	add	r0, r0, #20
   12114:	e58d200c 	str	r2, [sp, #12]
   12118:	ebfffa28 	bl	109c0 <lock_acquire>

      if (can_interrupt || has_alarm)
   1211c:	e59d200c 	ldr	r2, [sp, #12]
   12120:	e3120008 	tst	r2, #8
   12124:	1a00006b 	bne	122d8 <semaphore_acquire+0x37c>
      {
        self -> resource_queue = & sem -> waiting_queue;
      }
      else
      {
        self -> resource_queue = NULL;
   12128:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
   1212c:	e28a9004 	add	r9, sl, #4
   12130:	e583b018 	str	fp, [r3, #24]
      }

      self -> info . sem_tokens = -1 * rem_tokens;
      self -> info . status = DNA_THREAD_WAITING;
      self -> info . resource = DNA_RESOURCE_SEMAPHORE;
   12134:	e3a01001 	mov	r1, #1
      else
      {
        self -> resource_queue = NULL;
      }

      self -> info . sem_tokens = -1 * rem_tokens;
   12138:	e59d201c 	ldr	r2, [sp, #28]
      self -> info . status = DNA_THREAD_WAITING;
   1213c:	e59f0274 	ldr	r0, [pc, #628]	; 123b8 <semaphore_acquire+0x45c>
      else
      {
        self -> resource_queue = NULL;
      }

      self -> info . sem_tokens = -1 * rem_tokens;
   12140:	e262c000 	rsb	ip, r2, #0
      self -> info . status = DNA_THREAD_WAITING;
      self -> info . resource = DNA_RESOURCE_SEMAPHORE;
      self -> info . resource_id = sem -> id . raw;
   12144:	e0882005 	add	r2, r8, r5
        self -> resource_queue = NULL;
      }

      self -> info . sem_tokens = -1 * rem_tokens;
      self -> info . status = DNA_THREAD_WAITING;
      self -> info . resource = DNA_RESOURCE_SEMAPHORE;
   12148:	e5c31052 	strb	r1, [r3, #82]	; 0x52
      {
        self -> resource_queue = NULL;
      }

      self -> info . sem_tokens = -1 * rem_tokens;
      self -> info . status = DNA_THREAD_WAITING;
   1214c:	e1c305b0 	strh	r0, [r3, #80]	; 0x50
      else
      {
        self -> resource_queue = NULL;
      }

      self -> info . sem_tokens = -1 * rem_tokens;
   12150:	e583c04c 	str	ip, [r3, #76]	; 0x4c
      self -> info . status = DNA_THREAD_WAITING;
      self -> info . resource = DNA_RESOURCE_SEMAPHORE;
      self -> info . resource_id = sem -> id . raw;
   12154:	e0872102 	add	r2, r7, r2, lsl #2
   12158:	e592200c 	ldr	r2, [r2, #12]

      /*
       * Look for a potential target thread.
       */

      lock_acquire (& sem -> waiting_queue . lock);
   1215c:	e1a00009 	mov	r0, r9
      }

      self -> info . sem_tokens = -1 * rem_tokens;
      self -> info . status = DNA_THREAD_WAITING;
      self -> info . resource = DNA_RESOURCE_SEMAPHORE;
      self -> info . resource_id = sem -> id . raw;
   12160:	e5832054 	str	r2, [r3, #84]	; 0x54

      /*
       * Look for a potential target thread.
       */

      lock_acquire (& sem -> waiting_queue . lock);
   12164:	e58d1014 	str	r1, [sp, #20]
   12168:	ebfffa14 	bl	109c0 <lock_acquire>
      lock_release (& sem -> lock);
   1216c:	e1a0000a 	mov	r0, sl
   12170:	eb0004c6 	bl	13490 <lock_release>

      status = scheduler_elect (& thread, true);
   12174:	e59d1014 	ldr	r1, [sp, #20]
   12178:	e28d002c 	add	r0, sp, #44	; 0x2c
   1217c:	eb00012f 	bl	12640 <scheduler_elect>
      ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);
   12180:	e59f2234 	ldr	r2, [pc, #564]	; 123bc <semaphore_acquire+0x460>
   12184:	e59f321c 	ldr	r3, [pc, #540]	; 123a8 <semaphore_acquire+0x44c>
       */

      lock_acquire (& sem -> waiting_queue . lock);
      lock_release (& sem -> lock);

      status = scheduler_elect (& thread, true);
   12188:	e1cd02b6 	strh	r0, [sp, #38]	; 0x26
      ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);
   1218c:	e1500002 	cmp	r0, r2
   12190:	11500003 	cmpne	r0, r3
      }

      self -> info . sem_tokens = -1 * rem_tokens;
      self -> info . status = DNA_THREAD_WAITING;
      self -> info . resource = DNA_RESOURCE_SEMAPHORE;
      self -> info . resource_id = sem -> id . raw;
   12194:	e59f2214 	ldr	r2, [pc, #532]	; 123b0 <semaphore_acquire+0x454>

      lock_acquire (& sem -> waiting_queue . lock);
      lock_release (& sem -> lock);

      status = scheduler_elect (& thread, true);
      ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);
   12198:	0affff7d 	beq	11f94 <semaphore_acquire+0x38>

      /*
       * Add self in the ready queue.
       */

      queue_add (& sem -> waiting_queue, self);
   1219c:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
   121a0:	e1a00009 	mov	r0, r9
   121a4:	e58d200c 	str	r2, [sp, #12]
   121a8:	e58d3014 	str	r3, [sp, #20]
   121ac:	ebfff718 	bl	fe14 <queue_add>

      /*
       * Reschedule self.
       */
      cpu_dcache_invalidate((void*)&thread, sizeof(thread_t));
   121b0:	e28d002c 	add	r0, sp, #44	; 0x2c
   121b4:	e3a01004 	mov	r1, #4
   121b8:	ebfff920 	bl	10640 <cpu_dcache_invalidate>
      cpu_dcache_invalidate((void*)&sem->waiting_queue, sizeof(queue_t));
   121bc:	e1a00009 	mov	r0, r9
   121c0:	e3a01010 	mov	r1, #16
   121c4:	ebfff91d 	bl	10640 <cpu_dcache_invalidate>
      status = scheduler_switch (thread, & sem -> waiting_queue);
   121c8:	e1a01009 	mov	r1, r9
   121cc:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
   121d0:	eb000320 	bl	12e58 <scheduler_switch>
   121d4:	e28d1038 	add	r1, sp, #56	; 0x38
   121d8:	e16101b2 	strh	r0, [r1, #-18]!	; 0xffffffee
      cpu_dcache_invalidate((void*)&status, sizeof(status_t));
   121dc:	e1a00001 	mov	r0, r1
   121e0:	e3a01002 	mov	r1, #2
   121e4:	ebfff915 	bl	10640 <cpu_dcache_invalidate>
      ensure (status == DNA_OK, status);
   121e8:	e1dd02b6 	ldrh	r0, [sp, #38]	; 0x26
   121ec:	e59d200c 	ldr	r2, [sp, #12]
   121f0:	e3500000 	cmp	r0, #0
   121f4:	1affff66 	bne	11f94 <semaphore_acquire+0x38>

      /*
       * Check if the semaphore still exist.
       */

      lock_acquire (& semaphore_pool . lock);
   121f8:	e1a00002 	mov	r0, r2
   121fc:	ebfff9ef 	bl	109c0 <lock_acquire>

      sem = & semaphore_pool . data[sid . s . index];
      check (bad_semid, sem != NULL, DNA_SEM_DESTROYED);
      check (bad_semid, sem -> id . raw == sid . raw, DNA_SEM_DESTROYED);
   12200:	e3a01044 	mov	r1, #68	; 0x44
   12204:	e59d200c 	ldr	r2, [sp, #12]
   12208:	e0212591 	mla	r1, r1, r5, r2
   1220c:	e591100c 	ldr	r1, [r1, #12]
   12210:	e1540001 	cmp	r4, r1
   12214:	159f41a4 	ldrne	r4, [pc, #420]	; 123c0 <semaphore_acquire+0x464>
   12218:	1affff82 	bne	12028 <semaphore_acquire+0xcc>

      lock_acquire (& sem -> lock);
   1221c:	e1a0000a 	mov	r0, sl
   12220:	ebfff9e6 	bl	109c0 <lock_acquire>
      lock_release (& semaphore_pool . lock);
   12224:	e59d200c 	ldr	r2, [sp, #12]
   12228:	e1a00002 	mov	r0, r2
   1222c:	eb000497 	bl	13490 <lock_release>

      /*
       * If there is an alarm programmed, cancel it.
       */

      if (has_alarm)
   12230:	e35b0000 	cmp	fp, #0
   12234:	0a00003b 	beq	12328 <semaphore_acquire+0x3cc>
      {
        alarm_status = alarm_destroy (alarm);
   12238:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
   1223c:	eb00039a 	bl	130ac <alarm_destroy>
        check (quick_abort, status != DNA_NO_TIMER, status);
   12240:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
   12244:	e59f1178 	ldr	r1, [pc, #376]	; 123c4 <semaphore_acquire+0x468>
       * If there is an alarm programmed, cancel it.
       */

      if (has_alarm)
      {
        alarm_status = alarm_destroy (alarm);
   12248:	e1a04000 	mov	r4, r0
        check (quick_abort, status != DNA_NO_TIMER, status);
   1224c:	e1520001 	cmp	r2, r1
   12250:	e59d3014 	ldr	r3, [sp, #20]
   12254:	0a000050 	beq	1239c <semaphore_acquire+0x440>
        check (quick_abort, status != DNA_BAD_ARGUMENT, status);
   12258:	e1520003 	cmp	r2, r3
   1225c:	0a00004e 	beq	1239c <semaphore_acquire+0x440>

      /*
       * Check if we have not been interrupted with a
       * thread_suspend/thread_resume combination.
       */
      cpu_dcache_invalidate((void*)&self,sizeof(thread_t*));
   12260:	e28d0028 	add	r0, sp, #40	; 0x28
   12264:	e3a01004 	mov	r1, #4
   12268:	ebfff8f4 	bl	10640 <cpu_dcache_invalidate>
      cpu_dcache_invalidate((void*)&self->info.resource,sizeof(thread_resource_t));
   1226c:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
   12270:	e3a01001 	mov	r1, #1
   12274:	e2800052 	add	r0, r0, #82	; 0x52
   12278:	ebfff8f0 	bl	10640 <cpu_dcache_invalidate>
      check (acquire_interrupted,
   1227c:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
   12280:	e5d13052 	ldrb	r3, [r1, #82]	; 0x52
   12284:	e3530000 	cmp	r3, #0
   12288:	1a000028 	bne	12330 <semaphore_acquire+0x3d4>
       * Although a status equal to DNA_UNKNOWN_ALARM means that the alarm
       * has already been fired, the semaphore could perfectly have been
       * V()-ed in the meantime. Hence, we need to recheck the sem tokens.
       */

      if (has_alarm && alarm_status == DNA_UNKNOWN_ALARM)
   1228c:	e59f3134 	ldr	r3, [pc, #308]	; 123c8 <semaphore_acquire+0x46c>
   12290:	e1540003 	cmp	r4, r3
   12294:	13a04000 	movne	r4, #0
   12298:	020b4001 	andeq	r4, fp, #1
   1229c:	e3540000 	cmp	r4, #0
   122a0:	0a000006 	beq	122c0 <semaphore_acquire+0x364>
      {
        check (acquire_timed_out,
   122a4:	e3a04044 	mov	r4, #68	; 0x44
   122a8:	e0247594 	mla	r4, r4, r5, r7
   122ac:	e5943044 	ldr	r3, [r4, #68]	; 0x44
   122b0:	e1560003 	cmp	r6, r3
            sem -> info . tokens >= tokens, DNA_TIMED_OUT);
        sem -> info . tokens -= tokens;
   122b4:	d0663003 	rsble	r3, r6, r3
   122b8:	d5843044 	strle	r3, [r4, #68]	; 0x44
       * V()-ed in the meantime. Hence, we need to recheck the sem tokens.
       */

      if (has_alarm && alarm_status == DNA_UNKNOWN_ALARM)
      {
        check (acquire_timed_out,
   122bc:	ca00002c 	bgt	12374 <semaphore_acquire+0x418>
            sem -> info . tokens >= tokens, DNA_TIMED_OUT);
        sem -> info . tokens -= tokens;
      }

      status = DNA_OK;
   122c0:	e3a03000 	mov	r3, #0
   122c4:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
   122c8:	eaffff75 	b	120a4 <semaphore_acquire+0x148>

      /*
       * Update self information.
       */

      lock_acquire (& self -> lock);
   122cc:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
   122d0:	e2800014 	add	r0, r0, #20
   122d4:	ebfff9b9 	bl	109c0 <lock_acquire>

      if (can_interrupt || has_alarm)
      {
        self -> resource_queue = & sem -> waiting_queue;
   122d8:	e0889005 	add	r9, r8, r5
   122dc:	e0879109 	add	r9, r7, r9, lsl #2
   122e0:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
   122e4:	e2899014 	add	r9, r9, #20
   122e8:	e5839018 	str	r9, [r3, #24]
   122ec:	eaffff90 	b	12134 <semaphore_acquire+0x1d8>
      /*
       * Not enough tokens. Set the sem -> tokens to 0.
       * Create the alarm if necessary.
       */

      sem -> info . tokens = 0;
   122f0:	e3a01000 	mov	r1, #0

      if (has_alarm)
      {
        status = alarm_create (timeout, alarm_mode,
   122f4:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
   122f8:	e28d3030 	add	r3, sp, #48	; 0x30
   122fc:	e88d0009 	stm	sp, {r0, r3}
   12300:	e1a02009 	mov	r2, r9
      /*
       * Not enough tokens. Set the sem -> tokens to 0.
       * Create the alarm if necessary.
       */

      sem -> info . tokens = 0;
   12304:	e58c1044 	str	r1, [ip, #68]	; 0x44

      if (has_alarm)
      {
        status = alarm_create (timeout, alarm_mode,
   12308:	e59f30bc 	ldr	r3, [pc, #188]	; 123cc <semaphore_acquire+0x470>
   1230c:	e1cd06d0 	ldrd	r0, [sp, #96]	; 0x60
   12310:	ebfffc1a 	bl	11380 <alarm_create>
            semaphore_alarm, self, & alarm);
        check (quick_abort, status == DNA_OK, status);
   12314:	e3500000 	cmp	r0, #0

      sem -> info . tokens = 0;

      if (has_alarm)
      {
        status = alarm_create (timeout, alarm_mode,
   12318:	e1cd02b6 	strh	r0, [sp, #38]	; 0x26
            semaphore_alarm, self, & alarm);
        check (quick_abort, status == DNA_OK, status);
   1231c:	0affffea 	beq	122cc <semaphore_acquire+0x370>
   12320:	e1a04000 	mov	r4, r0
   12324:	eaffff71 	b	120f0 <semaphore_acquire+0x194>
{
  bool has_alarm = false, can_interrupt = false;
  thread_t self = NULL, thread = NULL;
  semaphore_t sem = NULL;
  semaphore_id_t sid = { .raw = id };
  status_t status = DNA_OK, alarm_status = DNA_OK;
   12328:	e1a0400b 	mov	r4, fp
   1232c:	eaffffcb 	b	12260 <semaphore_acquire+0x304>
    leave;
  }

  rescue (acquire_interrupted)
  {
    lock_acquire (& self -> lock);
   12330:	e2810014 	add	r0, r1, #20
   12334:	ebfff9a1 	bl	109c0 <lock_acquire>
    self -> resource_queue = NULL;
   12338:	e3a03000 	mov	r3, #0
    self -> info . sem_tokens = 0;
    self -> info . resource = DNA_NO_RESOURCE;
    self -> info . resource_id = -1;
   1233c:	e3e02000 	mvn	r2, #0
  }

  rescue (acquire_interrupted)
  {
    lock_acquire (& self -> lock);
    self -> resource_queue = NULL;
   12340:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
   12344:	e5803018 	str	r3, [r0, #24]
    self -> info . sem_tokens = 0;
   12348:	e580304c 	str	r3, [r0, #76]	; 0x4c
    self -> info . resource = DNA_NO_RESOURCE;
   1234c:	e5c03052 	strb	r3, [r0, #82]	; 0x52
    self -> info . resource_id = -1;
   12350:	e5802054 	str	r2, [r0, #84]	; 0x54
    lock_release (& self -> lock);
   12354:	e2800014 	add	r0, r0, #20
   12358:	eb00044c 	bl	13490 <lock_release>

    lock_release (& sem -> lock);
   1235c:	e1a0000a 	mov	r0, sl
   12360:	eb00044a 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   12364:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
   12368:	ebfff881 	bl	10574 <cpu_trap_restore>
    leave;
   1236c:	e59f005c 	ldr	r0, [pc, #92]	; 123d0 <semaphore_acquire+0x474>
   12370:	eaffff07 	b	11f94 <semaphore_acquire+0x38>
  }

  rescue (acquire_timed_out)
  {
    queue_extract (& sem -> waiting_queue, self);
   12374:	e1a00009 	mov	r0, r9
   12378:	ebfff39a 	bl	f1e8 <queue_extract>
    sem -> info . tokens = rem_tokens + tokens;
   1237c:	e59d5018 	ldr	r5, [sp, #24]
    lock_release (& sem -> lock);
   12380:	e1a0000a 	mov	r0, sl
  }

  rescue (acquire_timed_out)
  {
    queue_extract (& sem -> waiting_queue, self);
    sem -> info . tokens = rem_tokens + tokens;
   12384:	e5845044 	str	r5, [r4, #68]	; 0x44
    lock_release (& sem -> lock);
   12388:	eb000440 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   1238c:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
   12390:	ebfff877 	bl	10574 <cpu_trap_restore>
    leave;
   12394:	e59f0038 	ldr	r0, [pc, #56]	; 123d4 <semaphore_acquire+0x478>
   12398:	eafffefd 	b	11f94 <semaphore_acquire+0x38>
   1239c:	e1a04002 	mov	r4, r2
   123a0:	eaffff52 	b	120f0 <semaphore_acquire+0x194>
   123a4:	0000fdff 	.word	0x0000fdff
   123a8:	0000fffc 	.word	0x0000fffc
   123ac:	001883e8 	.word	0x001883e8
   123b0:	0013f5a0 	.word	0x0013f5a0
   123b4:	0000fdfd 	.word	0x0000fdfd
   123b8:	ffffb10c 	.word	0xffffb10c
   123bc:	0000ffff 	.word	0x0000ffff
   123c0:	0000fdfb 	.word	0x0000fdfb
   123c4:	0000fbff 	.word	0x0000fbff
   123c8:	0000fbfe 	.word	0x0000fbfe
   123cc:	00011eac 	.word	0x00011eac
   123d0:	0000fff9 	.word	0x0000fff9
   123d4:	0000fdfc 	.word	0x0000fdfc

000123d8 <thread_exit>:
 * * value : the thread's return value
 *
 * SOURCE
 */

{
   123d8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  uint32_t current_cpuid = 0;
  thread_t self = NULL;
  thread_t target = NULL, p = NULL;
   123dc:	e3a05000 	mov	r5, #0
 * * value : the thread's return value
 *
 * SOURCE
 */

{
   123e0:	e24dd008 	sub	sp, sp, #8
   123e4:	e1a08000 	mov	r8, r0
  uint32_t current_cpuid = 0;
  thread_t self = NULL;
  thread_t target = NULL, p = NULL;
   123e8:	e58d5004 	str	r5, [sp, #4]
   */

#if 0
  it_status = cpu_trap_mask_and_backup();
#endif
  cpu_trap_mask_and_backup();
   123ec:	ebfff827 	bl	10490 <cpu_trap_mask_and_backup>

  current_cpuid = cpu_mp_id();
   123f0:	ebfff87c 	bl	105e8 <cpu_mp_id>
  self = cpu_pool . cpu[current_cpuid] . current_thread;
   123f4:	e59f3098 	ldr	r3, [pc, #152]	; 12494 <thread_exit+0xbc>
   123f8:	e0800180 	add	r0, r0, r0, lsl #3
   123fc:	e0833300 	add	r3, r3, r0, lsl #6
   12400:	e593422c 	ldr	r4, [r3, #556]	; 0x22c

  /*
   * And we place the return value in our structure
   */

  lock_acquire (& self -> lock);
   12404:	e2847014 	add	r7, r4, #20
   12408:	e1a00007 	mov	r0, r7
   1240c:	ebfff96b 	bl	109c0 <lock_acquire>

  /*
   * Mark self as ended.
   */

  self -> info . status = DNA_THREAD_ENDED;
   12410:	e59f3080 	ldr	r3, [pc, #128]	; 12498 <thread_exit+0xc0>

  lock_acquire (& self -> wait . lock);
   12414:	e2846004 	add	r6, r4, #4
  /*
   * And we place the return value in our structure
   */

  lock_acquire (& self -> lock);
  self -> signature . return_value = value;
   12418:	e5848080 	str	r8, [r4, #128]	; 0x80

  /*
   * Mark self as ended.
   */

  self -> info . status = DNA_THREAD_ENDED;
   1241c:	e1c435b0 	strh	r3, [r4, #80]	; 0x50

  lock_acquire (& self -> wait . lock);
   12420:	e1a00006 	mov	r0, r6
   12424:	ebfff965 	bl	109c0 <lock_acquire>
  lock_release (& self -> lock);
   12428:	e1a00007 	mov	r0, r7
   1242c:	eb000417 	bl	13490 <lock_release>
  while ((p = queue_rem (& self -> wait)) != NULL)
  {
    lock_acquire (& p -> lock);

    p -> resource_queue = NULL;
    p -> info . status = DNA_THREAD_READY;
   12430:	e59f8064 	ldr	r8, [pc, #100]	; 1249c <thread_exit+0xc4>
    p -> info . resource = DNA_NO_RESOURCE;
    p -> info . resource_id = -1;
   12434:	e3e07000 	mvn	r7, #0

  /*
   * Then we can wake up the waiting threads
   */

  while ((p = queue_rem (& self -> wait)) != NULL)
   12438:	ea000006 	b	12458 <thread_exit+0x80>
  {
    lock_acquire (& p -> lock);
   1243c:	ebfff95f 	bl	109c0 <lock_acquire>

    p -> resource_queue = NULL;
   12440:	e5845018 	str	r5, [r4, #24]
    p -> info . status = DNA_THREAD_READY;
   12444:	e1c485b0 	strh	r8, [r4, #80]	; 0x50
    p -> info . resource = DNA_NO_RESOURCE;
   12448:	e5c45052 	strb	r5, [r4, #82]	; 0x52
    p -> info . resource_id = -1;
   1244c:	e5847054 	str	r7, [r4, #84]	; 0x54

    scheduler_dispatch (p);
   12450:	e1a00004 	mov	r0, r4
   12454:	eb0000b3 	bl	12728 <scheduler_dispatch>

  /*
   * Then we can wake up the waiting threads
   */

  while ((p = queue_rem (& self -> wait)) != NULL)
   12458:	e1a00006 	mov	r0, r6
   1245c:	ebfff3a3 	bl	f2f0 <queue_rem>
   12460:	e2504000 	subs	r4, r0, #0
  {
    lock_acquire (& p -> lock);
   12464:	e2840014 	add	r0, r4, #20

  /*
   * Then we can wake up the waiting threads
   */

  while ((p = queue_rem (& self -> wait)) != NULL)
   12468:	1afffff3 	bne	1243c <thread_exit+0x64>
    p -> info . resource_id = -1;

    scheduler_dispatch (p);
  }

  lock_release (& self -> wait . lock);
   1246c:	e1a00006 	mov	r0, r6
   12470:	eb000406 	bl	13490 <lock_release>

  /*
   * Elect a the next thread and run it
   */

  scheduler_elect (& target, true);
   12474:	e28d0004 	add	r0, sp, #4
   12478:	e3a01001 	mov	r1, #1
   1247c:	eb00006f 	bl	12640 <scheduler_elect>
  scheduler_switch (target, NULL);
   12480:	e1a01004 	mov	r1, r4
   12484:	e59d0004 	ldr	r0, [sp, #4]
   12488:	eb000272 	bl	12e58 <scheduler_switch>
}
   1248c:	e28dd008 	add	sp, sp, #8
   12490:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
   12494:	001883e8 	.word	0x001883e8
   12498:	ffffdead 	.word	0xffffdead
   1249c:	ffffface 	.word	0xffffface

000124a0 <port_destroy>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   124a0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  interrupt_status_t it_status = 0;
  status_t status;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
   124a4:	e1a04820 	lsr	r4, r0, #16
   124a8:	e354003f 	cmp	r4, #63	; 0x3f
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   124ac:	e1a05000 	mov	r5, r0
  interrupt_status_t it_status = 0;
  status_t status;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
   124b0:	9a000001 	bls	124bc <port_destroy+0x1c>
   124b4:	e59f010c 	ldr	r0, [pc, #268]	; 125c8 <port_destroy+0x128>
  {
    lock_release (& port_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
   124b8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
     * remove its entry from the pool.
     */

    port = & port_pool . data[pid . s . index];
    check (invalid_port, port != NULL, DNA_BAD_PORT_ID);
    check (invalid_port, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   124bc:	e3a06068 	mov	r6, #104	; 0x68

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);

    it_status = cpu_trap_mask_and_backup();
   124c0:	ebfff7f2 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& port_pool . lock);
   124c4:	e59f7100 	ldr	r7, [pc, #256]	; 125cc <port_destroy+0x12c>

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);

    it_status = cpu_trap_mask_and_backup();
   124c8:	e1a08000 	mov	r8, r0
     * remove its entry from the pool.
     */

    port = & port_pool . data[pid . s . index];
    check (invalid_port, port != NULL, DNA_BAD_PORT_ID);
    check (invalid_port, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   124cc:	e0267496 	mla	r6, r6, r4, r7
  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& port_pool . lock);
   124d0:	e1a00007 	mov	r0, r7
   124d4:	ebfff939 	bl	109c0 <lock_acquire>
     * remove its entry from the pool.
     */

    port = & port_pool . data[pid . s . index];
    check (invalid_port, port != NULL, DNA_BAD_PORT_ID);
    check (invalid_port, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   124d8:	e596300c 	ldr	r3, [r6, #12]
   124dc:	e1550003 	cmp	r5, r3
   124e0:	0a000005 	beq	124fc <port_destroy+0x5c>
    return DNA_OK;
  }

  rescue (invalid_port)
  {
    lock_release (& port_pool . lock);
   124e4:	e1a00007 	mov	r0, r7
   124e8:	eb0003e8 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   124ec:	e1a00008 	mov	r0, r8
   124f0:	ebfff81f 	bl	10574 <cpu_trap_restore>
    leave;
   124f4:	e59f00cc 	ldr	r0, [pc, #204]	; 125c8 <port_destroy+0x128>
   124f8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

    port = & port_pool . data[pid . s . index];
    check (invalid_port, port != NULL, DNA_BAD_PORT_ID);
    check (invalid_port, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    port -> id . s . value = 0;
   124fc:	e3a02000 	mov	r2, #0

    lock_release (& port_pool . lock);
   12500:	e1a00007 	mov	r0, r7

    port = & port_pool . data[pid . s . index];
    check (invalid_port, port != NULL, DNA_BAD_PORT_ID);
    check (invalid_port, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    port -> id . s . value = 0;
   12504:	e1c620bc 	strh	r2, [r6, #12]

    lock_release (& port_pool . lock);
   12508:	eb0003e0 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   1250c:	e1a00008 	mov	r0, r8
   12510:	ebfff817 	bl	10574 <cpu_trap_restore>

    /*
     * Destroy the port's semaphore.
     */

    status = semaphore_destroy (port -> read_sem);
   12514:	e5960044 	ldr	r0, [r6, #68]	; 0x44
   12518:	ebfff9a4 	bl	10bb0 <semaphore_destroy>
    panic (status != DNA_OK);
   1251c:	e3500000 	cmp	r0, #0
   12520:	0a000000 	beq	12528 <port_destroy+0x88>
   12524:	eafffffe 	b	12524 <port_destroy+0x84>

    status = semaphore_destroy (port -> write_sem);
   12528:	e5960048 	ldr	r0, [r6, #72]	; 0x48
   1252c:	ebfff99f 	bl	10bb0 <semaphore_destroy>
    panic (status != DNA_OK);
   12530:	e3500000 	cmp	r0, #0
   12534:	1a000010 	bne	1257c <port_destroy+0xdc>

    /*
     * Delete the port's memory and its messages.
     */

    for (int32_t i = 0; i < port -> info . capacity; i += 1)
   12538:	e5963038 	ldr	r3, [r6, #56]	; 0x38
   1253c:	e3530000 	cmp	r3, #0
   12540:	da00000e 	ble	12580 <port_destroy+0xe0>
   12544:	e1a05000 	mov	r5, r0
   12548:	e1a08006 	mov	r8, r6
   1254c:	e596304c 	ldr	r3, [r6, #76]	; 0x4c
    {
      if (port -> data[i] . buffer != NULL)
   12550:	e0832205 	add	r2, r3, r5, lsl #4
   12554:	e592000c 	ldr	r0, [r2, #12]

    /*
     * Delete the port's memory and its messages.
     */

    for (int32_t i = 0; i < port -> info . capacity; i += 1)
   12558:	e2855001 	add	r5, r5, #1
    {
      if (port -> data[i] . buffer != NULL)
   1255c:	e3500000 	cmp	r0, #0
   12560:	0a000001 	beq	1256c <port_destroy+0xcc>
      {
        kernel_free (port -> data[i] . buffer);
   12564:	eb0006fe 	bl	14164 <kernel_free>
   12568:	e598304c 	ldr	r3, [r8, #76]	; 0x4c

    /*
     * Delete the port's memory and its messages.
     */

    for (int32_t i = 0; i < port -> info . capacity; i += 1)
   1256c:	e5982038 	ldr	r2, [r8, #56]	; 0x38
   12570:	e1520005 	cmp	r2, r5
   12574:	cafffff5 	bgt	12550 <port_destroy+0xb0>
   12578:	ea000001 	b	12584 <port_destroy+0xe4>

    status = semaphore_destroy (port -> read_sem);
    panic (status != DNA_OK);

    status = semaphore_destroy (port -> write_sem);
    panic (status != DNA_OK);
   1257c:	eafffffe 	b	1257c <port_destroy+0xdc>
   12580:	e596304c 	ldr	r3, [r6, #76]	; 0x4c
      {
        kernel_free (port -> data[i] . buffer);
      }
    }

    kernel_free (port -> data);
   12584:	e1a00003 	mov	r0, r3
   12588:	eb0006f5 	bl	14164 <kernel_free>

    /*
     * Add the port back to the pool.
     */

    it_status = cpu_trap_mask_and_backup();
   1258c:	ebfff7bf 	bl	10490 <cpu_trap_mask_and_backup>
   12590:	e1a05000 	mov	r5, r0
    lock_acquire (& port_pool . lock);
   12594:	e59f0030 	ldr	r0, [pc, #48]	; 125cc <port_destroy+0x12c>
   12598:	ebfff908 	bl	109c0 <lock_acquire>
    /*
     * Look for the port with ID id. If found,
     * remove its entry from the pool.
     */

    port = & port_pool . data[pid . s . index];
   1259c:	e3a01068 	mov	r1, #104	; 0x68
   125a0:	e0217491 	mla	r1, r1, r4, r7
     */

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& port_pool . lock);

    queue_add (& port_pool . port, port);
   125a4:	e59f0024 	ldr	r0, [pc, #36]	; 125d0 <port_destroy+0x130>
   125a8:	e2811008 	add	r1, r1, #8
   125ac:	ebfff618 	bl	fe14 <queue_add>

    lock_release (& port_pool . lock);
   125b0:	e59f0014 	ldr	r0, [pc, #20]	; 125cc <port_destroy+0x12c>
   125b4:	eb0003b5 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   125b8:	e1a00005 	mov	r0, r5
   125bc:	ebfff7ec 	bl	10574 <cpu_trap_restore>

    return DNA_OK;
   125c0:	e3a00000 	mov	r0, #0
   125c4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
   125c8:	0000faff 	.word	0x0000faff
   125cc:	001835b8 	.word	0x001835b8
   125d0:	00184fc0 	.word	0x00184fc0

000125d4 <thread_bootstrap>:
 * Ignored.
 *
 * SOURCE
 */

{
   125d4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
   125d8:	e1a04000 	mov	r4, r0
  thread_signature_t * signature = (thread_signature_t *) p_signature;

  /*
   * Unlock threads HERE
   */
  uint32_t current_cpuid = cpu_mp_id ();
   125dc:	ebfff801 	bl	105e8 <cpu_mp_id>
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];

  if(cpu-> prev_thread)
   125e0:	e59f6054 	ldr	r6, [pc, #84]	; 1263c <thread_bootstrap+0x68>
   125e4:	e1a07180 	lsl	r7, r0, #3
   125e8:	e0873000 	add	r3, r7, r0
   125ec:	e0863303 	add	r3, r6, r3, lsl #6
  thread_signature_t * signature = (thread_signature_t *) p_signature;

  /*
   * Unlock threads HERE
   */
  uint32_t current_cpuid = cpu_mp_id ();
   125f0:	e1a05000 	mov	r5, r0
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];

  if(cpu-> prev_thread)
   125f4:	e5930228 	ldr	r0, [r3, #552]	; 0x228
   125f8:	e3500000 	cmp	r0, #0
   125fc:	0a000001 	beq	12608 <thread_bootstrap+0x34>
    lock_release (& (cpu-> prev_thread -> lock));
   12600:	e2800014 	add	r0, r0, #20
   12604:	eb0003a1 	bl	13490 <lock_release>
  lock_release (& (cpu-> current_thread -> lock));
   12608:	e0875005 	add	r5, r7, r5
   1260c:	e0866305 	add	r6, r6, r5, lsl #6
   12610:	e596022c 	ldr	r0, [r6, #556]	; 0x22c
   12614:	e2800014 	add	r0, r0, #20
   12618:	eb00039c 	bl	13490 <lock_release>

  /*
   * Activate interruption
   */
  cpu_trap_restore(signature->it_restore);
   1261c:	e5940004 	ldr	r0, [r4, #4]
   12620:	ebfff7d3 	bl	10574 <cpu_trap_restore>


  /*
   * Call handler, declared by thread_create
   */
  thread_exit (signature -> handler (signature -> arguments));
   12624:	e5943000 	ldr	r3, [r4]
   12628:	e5940008 	ldr	r0, [r4, #8]
   1262c:	e12fff33 	blx	r3
   12630:	ebffff68 	bl	123d8 <thread_exit>
  return 0;
}
   12634:	e3a00000 	mov	r0, #0
   12638:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
   1263c:	001883e8 	.word	0x001883e8

00012640 <scheduler_elect>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   12640:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
   12644:	e1a04000 	mov	r4, r0
   12648:	e1a09001 	mov	r9, r1
  queue_t * queue = NULL;
  thread_t thread = NULL;
  int32_t current_cpuid = cpu_mp_id();
   1264c:	ebfff7e5 	bl	105e8 <cpu_mp_id>

  watch (status_t)
  {
    ensure (p_thread != NULL, DNA_BAD_ARGUMENT);
   12650:	e3540000 	cmp	r4, #0
   12654:	0a000010 	beq	1269c <scheduler_elect+0x5c>

    /*
     * Check the local queue.
     */

    queue = & scheduler . queue[current_cpuid];
   12658:	e59f80b4 	ldr	r8, [pc, #180]	; 12714 <scheduler_elect+0xd4>
   1265c:	e1a07000 	mov	r7, r0
   12660:	e0885200 	add	r5, r8, r0, lsl #4
   12664:	e2855004 	add	r5, r5, #4

    lock_acquire (& queue -> lock);
   12668:	e1a00005 	mov	r0, r5
   1266c:	ebfff8d3 	bl	109c0 <lock_acquire>
    thread = queue_rem (queue);
   12670:	e1a00005 	mov	r0, r5
   12674:	ebfff31d 	bl	f2f0 <queue_rem>

    check (thread_found, thread == NULL, DNA_OK);
   12678:	e2506000 	subs	r6, r0, #0
   1267c:	0a000008 	beq	126a4 <scheduler_elect+0x64>
    return DNA_ERROR;
  }

  rescue (thread_found)
  {
    lock_acquire (& thread -> lock);
   12680:	e2860014 	add	r0, r6, #20
   12684:	ebfff8cd 	bl	109c0 <lock_acquire>
    if(queue) lock_release (& queue -> lock);
   12688:	e1a00005 	mov	r0, r5
   1268c:	eb00037f 	bl	13490 <lock_release>

    *p_thread = thread;
   12690:	e5846000 	str	r6, [r4]
    leave;
   12694:	e3a00000 	mov	r0, #0
   12698:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  thread_t thread = NULL;
  int32_t current_cpuid = cpu_mp_id();

  watch (status_t)
  {
    ensure (p_thread != NULL, DNA_BAD_ARGUMENT);
   1269c:	e59f0074 	ldr	r0, [pc, #116]	; 12718 <scheduler_elect+0xd8>
   126a0:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

    lock_acquire (& queue -> lock);
    thread = queue_rem (queue);

    check (thread_found, thread == NULL, DNA_OK);
    lock_release (& queue -> lock);
   126a4:	e1a00005 	mov	r0, r5
   126a8:	eb000378 	bl	13490 <lock_release>

    /*
     * Check the global queue.
     */

    queue = & scheduler . queue[cpu_mp_count ()];
   126ac:	ebfff800 	bl	106b4 <cpu_mp_count>
   126b0:	e0880200 	add	r0, r8, r0, lsl #4
   126b4:	e2805004 	add	r5, r0, #4

    lock_acquire (& queue -> lock);
   126b8:	e1a00005 	mov	r0, r5
   126bc:	ebfff8bf 	bl	109c0 <lock_acquire>
    thread = queue_rem (queue);
   126c0:	e1a00005 	mov	r0, r5
   126c4:	ebfff309 	bl	f2f0 <queue_rem>

    check (thread_found, thread == NULL, DNA_OK);
   126c8:	e2506000 	subs	r6, r0, #0
   126cc:	1affffeb 	bne	12680 <scheduler_elect+0x40>
    lock_release (& queue -> lock);
   126d0:	e1a00005 	mov	r0, r5
   126d4:	eb00036d 	bl	13490 <lock_release>

    /*
     * Return the IDLE thread if requested.
     */

    ensure (with_idle, DNA_NO_AVAILABLE_THREAD);
   126d8:	e3590000 	cmp	r9, #0
   126dc:	1a000001 	bne	126e8 <scheduler_elect+0xa8>
   126e0:	e59f0034 	ldr	r0, [pc, #52]	; 1271c <scheduler_elect+0xdc>
   126e4:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

    queue = NULL;

    thread = cpu_pool . cpu[current_cpuid] . idle_thread;
   126e8:	e59f3030 	ldr	r3, [pc, #48]	; 12720 <scheduler_elect+0xe0>
   126ec:	e0877187 	add	r7, r7, r7, lsl #3
   126f0:	e0833307 	add	r3, r3, r7, lsl #6
   126f4:	e5936230 	ldr	r6, [r3, #560]	; 0x230
    check (thread_found, thread == NULL, DNA_OK);
   126f8:	e3560000 	cmp	r6, #0
   126fc:	0a000002 	beq	1270c <scheduler_elect+0xcc>
    return DNA_ERROR;
  }

  rescue (thread_found)
  {
    lock_acquire (& thread -> lock);
   12700:	e2860014 	add	r0, r6, #20
   12704:	ebfff8ad 	bl	109c0 <lock_acquire>
   12708:	eaffffe0 	b	12690 <scheduler_elect+0x50>
    queue = NULL;

    thread = cpu_pool . cpu[current_cpuid] . idle_thread;
    check (thread_found, thread == NULL, DNA_OK);

    return DNA_ERROR;
   1270c:	e59f0010 	ldr	r0, [pc, #16]	; 12724 <scheduler_elect+0xe4>
   12710:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
   12714:	0018a800 	.word	0x0018a800
   12718:	0000fffc 	.word	0x0000fffc
   1271c:	0000fcfd 	.word	0x0000fcfd
   12720:	001883e8 	.word	0x001883e8
   12724:	0000ffff 	.word	0x0000ffff

00012728 <scheduler_dispatch>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   12728:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
   1272c:	e1a05000 	mov	r5, r0

    /*
     * Look for an available processor.
     */

    lock_acquire (& cpu_pool . queue . lock);
   12730:	e59f00ec 	ldr	r0, [pc, #236]	; 12824 <scheduler_dispatch+0xfc>
 */

{
  cpu_t * cpu = NULL;
  status_t status = DNA_OK;
  int32_t affinity = thread -> info . affinity;
   12734:	e5954048 	ldr	r4, [r5, #72]	; 0x48

    /*
     * Look for an available processor.
     */

    lock_acquire (& cpu_pool . queue . lock);
   12738:	ebfff8a0 	bl	109c0 <lock_acquire>

    if (affinity == cpu_mp_count ())
   1273c:	ebfff7dc 	bl	106b4 <cpu_mp_count>
   12740:	e1500004 	cmp	r0, r4
   12744:	0a00002b 	beq	127f8 <scheduler_dispatch+0xd0>
    {
      cpu = queue_rem (& cpu_pool . queue);
    }
    else
    {
      status = queue_extract (& cpu_pool . queue, & cpu_pool . cpu[affinity]);
   12748:	e59f30d8 	ldr	r3, [pc, #216]	; 12828 <scheduler_dispatch+0x100>
   1274c:	e0846184 	add	r6, r4, r4, lsl #3
   12750:	e0836306 	add	r6, r3, r6, lsl #6
   12754:	e1a01006 	mov	r1, r6
   12758:	e2830b09 	add	r0, r3, #9216	; 0x2400
   1275c:	ebfff2a1 	bl	f1e8 <queue_extract>
      cpu = status == DNA_OK ? & cpu_pool . cpu[affinity] : NULL;
   12760:	e2507000 	subs	r7, r0, #0
   12764:	1a00000d 	bne	127a0 <scheduler_dispatch+0x78>
    }

    lock_release (& cpu_pool . queue . lock);
   12768:	e59f00b4 	ldr	r0, [pc, #180]	; 12824 <scheduler_dispatch+0xfc>
   1276c:	eb000347 	bl	13490 <lock_release>

    /*
     * Check if we can send the thread to a distant CPU.
     */

    if (cpu != NULL && cpu -> id != cpu_mp_id ())
   12770:	e5967004 	ldr	r7, [r6, #4]
   12774:	ebfff79b 	bl	105e8 <cpu_mp_id>
   12778:	e1570000 	cmp	r7, r0
   1277c:	0a000024 	beq	12814 <scheduler_dispatch+0xec>
    {
dna_log(INFO_LEVEL, "(%d) %s => CPU(%d)", cpu_mp_id (),
          thread -> info . name, cpu -> id);

      lock_acquire (& cpu -> ipi_lock);
   12780:	e2860010 	add	r0, r6, #16
   12784:	ebfff88d 	bl	109c0 <lock_acquire>
      cpu_mp_send_ipi (cpu -> id, DNA_IPI_DISPATCH, thread);
   12788:	e5960004 	ldr	r0, [r6, #4]
   1278c:	e1a02005 	mov	r2, r5
   12790:	e59f1094 	ldr	r1, [pc, #148]	; 1282c <scheduler_dispatch+0x104>
   12794:	ebfff74f 	bl	104d8 <cpu_mp_send_ipi>
   12798:	e3a00000 	mov	r0, #0
   1279c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
    {
      status = queue_extract (& cpu_pool . queue, & cpu_pool . cpu[affinity]);
      cpu = status == DNA_OK ? & cpu_pool . cpu[affinity] : NULL;
    }

    lock_release (& cpu_pool . queue . lock);
   127a0:	e59f007c 	ldr	r0, [pc, #124]	; 12824 <scheduler_dispatch+0xfc>
   127a4:	eb000339 	bl	13490 <lock_release>
      lock_acquire (& cpu -> ipi_lock);
      cpu_mp_send_ipi (cpu -> id, DNA_IPI_DISPATCH, thread);
    }
    else
    {
      lock_acquire (& scheduler . queue[affinity] . lock);
   127a8:	e59f6080 	ldr	r6, [pc, #128]	; 12830 <scheduler_dispatch+0x108>
   127ac:	e0866204 	add	r6, r6, r4, lsl #4
   127b0:	e2866004 	add	r6, r6, #4
   127b4:	e1a00006 	mov	r0, r6
   127b8:	ebfff880 	bl	109c0 <lock_acquire>
      queue_add (& scheduler . queue[affinity], thread);
   127bc:	e1a01005 	mov	r1, r5
   127c0:	e1a00006 	mov	r0, r6
   127c4:	ebfff592 	bl	fe14 <queue_add>

      lock_release (& scheduler . queue[affinity] . lock);
   127c8:	e1a00006 	mov	r0, r6
   127cc:	eb00032f 	bl	13490 <lock_release>
      lock_release (& thread -> lock);
   127d0:	e2850014 	add	r0, r5, #20
   127d4:	eb00032d 	bl	13490 <lock_release>
      /*
       * If the thread is compatible with the current CPU,
       * we return DNA_INVOKE_SCHEDULER to indicate potential reschedule.
       */

      if (affinity == cpu_mp_count () || affinity == cpu_mp_id ())
   127d8:	ebfff7b5 	bl	106b4 <cpu_mp_count>
   127dc:	e1500004 	cmp	r0, r4
   127e0:	0a00000d 	beq	1281c <scheduler_dispatch+0xf4>
   127e4:	ebfff77f 	bl	105e8 <cpu_mp_id>
      {
dna_log(INFO_LEVEL, "%s => Q(%d)", thread -> info . name, affinity);
        status = DNA_INVOKE_SCHEDULER;
   127e8:	e1500004 	cmp	r0, r4
   127ec:	11a00007 	movne	r0, r7
   127f0:	03a00003 	moveq	r0, #3
   127f4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

    lock_acquire (& cpu_pool . queue . lock);

    if (affinity == cpu_mp_count ())
    {
      cpu = queue_rem (& cpu_pool . queue);
   127f8:	e59f0024 	ldr	r0, [pc, #36]	; 12824 <scheduler_dispatch+0xfc>
   127fc:	ebfff2bb 	bl	f2f0 <queue_rem>
   12800:	e1a06000 	mov	r6, r0
    {
      status = queue_extract (& cpu_pool . queue, & cpu_pool . cpu[affinity]);
      cpu = status == DNA_OK ? & cpu_pool . cpu[affinity] : NULL;
    }

    lock_release (& cpu_pool . queue . lock);
   12804:	e59f0018 	ldr	r0, [pc, #24]	; 12824 <scheduler_dispatch+0xfc>
   12808:	eb000320 	bl	13490 <lock_release>

    /*
     * Check if we can send the thread to a distant CPU.
     */

    if (cpu != NULL && cpu -> id != cpu_mp_id ())
   1280c:	e3560000 	cmp	r6, #0
   12810:	1affffd6 	bne	12770 <scheduler_dispatch+0x48>
 * SOURCE
 */

{
  cpu_t * cpu = NULL;
  status_t status = DNA_OK;
   12814:	e3a07000 	mov	r7, #0
   12818:	eaffffe2 	b	127a8 <scheduler_dispatch+0x80>
       */

      if (affinity == cpu_mp_count () || affinity == cpu_mp_id ())
      {
dna_log(INFO_LEVEL, "%s => Q(%d)", thread -> info . name, affinity);
        status = DNA_INVOKE_SCHEDULER;
   1281c:	e3a00003 	mov	r0, #3
   12820:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
   12824:	0018a7f0 	.word	0x0018a7f0
   12828:	001883f0 	.word	0x001883f0
   1282c:	0000ffff 	.word	0x0000ffff
   12830:	0018a800 	.word	0x0018a800

00012834 <thread_get_info>:
 */

{
  thread_t thread = NULL;
  thread_id_t tid = { .raw = id };
  bigtime_t current_time = 0, delta = 0;
   12834:	e3a02000 	mov	r2, #0
   12838:	e3a03000 	mov	r3, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   1283c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
   12840:	e1a04000 	mov	r4, r0
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
   12844:	e1a00820 	lsr	r0, r0, #16
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   12848:	e24dd008 	sub	sp, sp, #8
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
   1284c:	e31000ff 	tst	r0, #255	; 0xff
 */

{
  thread_t thread = NULL;
  thread_id_t tid = { .raw = id };
  bigtime_t current_time = 0, delta = 0;
   12850:	e1cd20f0 	strd	r2, [sp]
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
   12854:	0a000002 	beq	12864 <thread_get_info+0x30>
   12858:	e59f010c 	ldr	r0, [pc, #268]	; 1296c <thread_get_info+0x138>
  {
    cpu_trap_restore (it_status);
    lock_release (& thread_pool . lock);
    leave;
  }
}
   1285c:	e28dd008 	add	sp, sp, #8
   12860:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    ensure (tid . s . index >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . index < DNA_MAX_THREAD, DNA_BAD_ARGUMENT);
   12864:	e1a05c24 	lsr	r5, r4, #24
   12868:	e355003f 	cmp	r5, #63	; 0x3f
   1286c:	8afffff9 	bhi	12858 <thread_get_info+0x24>
    ensure (info != NULL, DNA_BAD_ARGUMENT);
   12870:	e3510000 	cmp	r1, #0
   12874:	e1a06001 	mov	r6, r1
   12878:	0afffff6 	beq	12858 <thread_get_info+0x24>
    /*
     * Get the thread corresponding to the current id
     * and check if it is valid.
     */

    it_status = cpu_trap_mask_and_backup();
   1287c:	ebfff703 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& thread_pool . lock);
   12880:	e59f90e8 	ldr	r9, [pc, #232]	; 12970 <thread_get_info+0x13c>
    /*
     * Get the thread corresponding to the current id
     * and check if it is valid.
     */

    it_status = cpu_trap_mask_and_backup();
   12884:	e1a07000 	mov	r7, r0
    lock_acquire (& thread_pool . lock);
   12888:	e1a00009 	mov	r0, r9
   1288c:	ebfff84b 	bl	109c0 <lock_acquire>

    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
   12890:	e3a030d0 	mov	r3, #208	; 0xd0
   12894:	e0030593 	mul	r3, r3, r5
   12898:	e089a003 	add	sl, r9, r3
   1289c:	e59a2024 	ldr	r2, [sl, #36]	; 0x24
   128a0:	e1540002 	cmp	r4, r2
   128a4:	0a000005 	beq	128c0 <thread_get_info+0x8c>
    return DNA_OK;
  }

  rescue (bad_thread)
  {
    cpu_trap_restore (it_status);
   128a8:	e1a00007 	mov	r0, r7
   128ac:	ebfff730 	bl	10574 <cpu_trap_restore>
    lock_release (& thread_pool . lock);
   128b0:	e1a00009 	mov	r0, r9
   128b4:	eb0002f5 	bl	13490 <lock_release>
    leave;
   128b8:	e59f00b4 	ldr	r0, [pc, #180]	; 12974 <thread_get_info+0x140>
   128bc:	eaffffe6 	b	1285c <thread_get_info+0x28>
    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
        thread -> id . raw == tid . raw , DNA_INVALID_THREAD_ID);

    lock_acquire (& thread -> lock);
   128c0:	e0893003 	add	r3, r9, r3
   128c4:	e283801c 	add	r8, r3, #28
   128c8:	e1a00008 	mov	r0, r8
   128cc:	ebfff83b 	bl	109c0 <lock_acquire>
    lock_release (& thread_pool . lock);
   128d0:	e1a00009 	mov	r0, r9
   128d4:	eb0002ed 	bl	13490 <lock_release>

    /*
     * Copy the thread information
     */

    *info = thread -> info;
   128d8:	e3a02050 	mov	r2, #80	; 0x50
   128dc:	e28a1028 	add	r1, sl, #40	; 0x28
   128e0:	e1a00006 	mov	r0, r6
   128e4:	eb001739 	bl	185d0 <memcpy>

    if (thread -> info . affinity == cpu_mp_count ())
   128e8:	e59a4050 	ldr	r4, [sl, #80]	; 0x50
   128ec:	ebfff770 	bl	106b4 <cpu_mp_count>
   128f0:	e1540000 	cmp	r4, r0
    {
      info -> affinity = DNA_NO_AFFINITY;
   128f4:	03e03000 	mvneq	r3, #0
   128f8:	05863028 	streq	r3, [r6, #40]	; 0x28

    /*
     * Update the time of the running thread
     */

    if (thread -> info . status == DNA_THREAD_RUNNING)
   128fc:	e3a030d0 	mov	r3, #208	; 0xd0
   12900:	e0299593 	mla	r9, r3, r5, r9
   12904:	e59f306c 	ldr	r3, [pc, #108]	; 12978 <thread_get_info+0x144>
   12908:	e1d925b8 	ldrh	r2, [r9, #88]	; 0x58
   1290c:	e1520003 	cmp	r2, r3
   12910:	0a000005 	beq	1292c <thread_get_info+0xf8>
      cpu_timer_get (thread -> info . cpu_id, & current_time);
      delta = current_time - cpu_pool . cpu[thread -> info . cpu_id] . lap_date;
      info -> kernel_time += delta;
    }

    lock_release (& thread -> lock);
   12914:	e1a00008 	mov	r0, r8
   12918:	eb0002dc 	bl	13490 <lock_release>
    cpu_trap_restore (it_status);
   1291c:	e1a00007 	mov	r0, r7
   12920:	ebfff713 	bl	10574 <cpu_trap_restore>

    return DNA_OK;
   12924:	e3a00000 	mov	r0, #0
   12928:	eaffffcb 	b	1285c <thread_get_info+0x28>
     * Update the time of the running thread
     */

    if (thread -> info . status == DNA_THREAD_RUNNING)
    {
      cpu_timer_get (thread -> info . cpu_id, & current_time);
   1292c:	e5990048 	ldr	r0, [r9, #72]	; 0x48
   12930:	e1a0100d 	mov	r1, sp
   12934:	ebfff6fa 	bl	10524 <cpu_timer_get>
      delta = current_time - cpu_pool . cpu[thread -> info . cpu_id] . lap_date;
   12938:	e1cd20d0 	ldrd	r2, [sp]
      info -> kernel_time += delta;
   1293c:	e1c643d8 	ldrd	r4, [r6, #56]	; 0x38
     */

    if (thread -> info . status == DNA_THREAD_RUNNING)
    {
      cpu_timer_get (thread -> info . cpu_id, & current_time);
      delta = current_time - cpu_pool . cpu[thread -> info . cpu_id] . lap_date;
   12940:	e5991048 	ldr	r1, [r9, #72]	; 0x48
   12944:	e59f0030 	ldr	r0, [pc, #48]	; 1297c <thread_get_info+0x148>
   12948:	e0811181 	add	r1, r1, r1, lsl #3
   1294c:	e0801301 	add	r1, r0, r1, lsl #6
   12950:	e1c102d0 	ldrd	r0, [r1, #32]
   12954:	e0522000 	subs	r2, r2, r0
   12958:	e0c33001 	sbc	r3, r3, r1
      info -> kernel_time += delta;
   1295c:	e0922004 	adds	r2, r2, r4
   12960:	e0a33005 	adc	r3, r3, r5
   12964:	e1c623f8 	strd	r2, [r6, #56]	; 0x38
   12968:	eaffffe9 	b	12914 <thread_get_info+0xe0>
   1296c:	0000fffc 	.word	0x0000fffc
   12970:	00184fd0 	.word	0x00184fd0
   12974:	0000fcfe 	.word	0x0000fcfe
   12978:	0000beef 	.word	0x0000beef
   1297c:	001883e8 	.word	0x001883e8

00012980 <thread_alarm>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   12980:	e92d4038 	push	{r3, r4, r5, lr}
  status_t status = DNA_OK;
  thread_t thread = data;

  watch (status_t)
  {
    ensure (thread != NULL, DNA_BAD_ARGUMENT);
   12984:	e2504000 	subs	r4, r0, #0
   12988:	0a00000d 	beq	129c4 <thread_alarm+0x44>

    lock_acquire (& thread -> lock);
   1298c:	e2845014 	add	r5, r4, #20
   12990:	e1a00005 	mov	r0, r5
   12994:	ebfff809 	bl	109c0 <lock_acquire>

    switch (thread -> info . status)
   12998:	e1d435b0 	ldrh	r3, [r4, #80]	; 0x50
   1299c:	e59f2048 	ldr	r2, [pc, #72]	; 129ec <thread_alarm+0x6c>
   129a0:	e1530002 	cmp	r3, r2
   129a4:	0a00000b 	beq	129d8 <thread_alarm+0x58>
   129a8:	e59f2040 	ldr	r2, [pc, #64]	; 129f0 <thread_alarm+0x70>
    {
      case DNA_THREAD_SUSPENDED :
        {
dna_log(VERBOSE_LEVEL, "thread 0x%x already supended", thread -> id);
          
          lock_release (& thread -> lock);
   129ac:	e1a00005 	mov	r0, r5
  {
    ensure (thread != NULL, DNA_BAD_ARGUMENT);

    lock_acquire (& thread -> lock);

    switch (thread -> info . status)
   129b0:	e1530002 	cmp	r3, r2
   129b4:	1a000004 	bne	129cc <thread_alarm+0x4c>
    {
      case DNA_THREAD_SUSPENDED :
        {
dna_log(VERBOSE_LEVEL, "thread 0x%x already supended", thread -> id);
          
          lock_release (& thread -> lock);
   129b8:	eb0002b4 	bl	13490 <lock_release>
 *
 * SOURCE
 */

{
  status_t status = DNA_OK;
   129bc:	e3a00000 	mov	r0, #0
      case DNA_THREAD_SUSPENDED :
        {
dna_log(VERBOSE_LEVEL, "thread 0x%x already supended", thread -> id);
          
          lock_release (& thread -> lock);
          break;
   129c0:	e8bd8038 	pop	{r3, r4, r5, pc}
  status_t status = DNA_OK;
  thread_t thread = data;

  watch (status_t)
  {
    ensure (thread != NULL, DNA_BAD_ARGUMENT);
   129c4:	e59f0028 	ldr	r0, [pc, #40]	; 129f4 <thread_alarm+0x74>
        }
    }

    return status;
  }
}
   129c8:	e8bd8038 	pop	{r3, r4, r5, pc}
      default :
        {
dna_log(PANIC_LEVEL, "status %x not handled.",
              thread -> info . status);

          lock_release (& thread -> lock);
   129cc:	eb0002af 	bl	13490 <lock_release>
          status = DNA_ERROR;
   129d0:	e59f0020 	ldr	r0, [pc, #32]	; 129f8 <thread_alarm+0x78>
          break;
   129d4:	e8bd8038 	pop	{r3, r4, r5, pc}

      case DNA_THREAD_SLEEPING :
        {
dna_log(VERBOSE_LEVEL, "thread 0x%x sleeping, resuming", thread -> id);
 
          thread -> info . status = DNA_THREAD_READY;
   129d8:	e59f301c 	ldr	r3, [pc, #28]	; 129fc <thread_alarm+0x7c>
          status = scheduler_dispatch (thread);
   129dc:	e1a00004 	mov	r0, r4

      case DNA_THREAD_SLEEPING :
        {
dna_log(VERBOSE_LEVEL, "thread 0x%x sleeping, resuming", thread -> id);
 
          thread -> info . status = DNA_THREAD_READY;
   129e0:	e1c435b0 	strh	r3, [r4, #80]	; 0x50
        }
    }

    return status;
  }
}
   129e4:	e8bd4038 	pop	{r3, r4, r5, lr}
      case DNA_THREAD_SLEEPING :
        {
dna_log(VERBOSE_LEVEL, "thread 0x%x sleeping, resuming", thread -> id);
 
          thread -> info . status = DNA_THREAD_READY;
          status = scheduler_dispatch (thread);
   129e8:	eaffff4e 	b	12728 <scheduler_dispatch>
   129ec:	0000bedd 	.word	0x0000bedd
   129f0:	0000d15a 	.word	0x0000d15a
   129f4:	0000fffc 	.word	0x0000fffc
   129f8:	0000ffff 	.word	0x0000ffff
   129fc:	ffffface 	.word	0xffffface

00012a00 <interrupt_demultiplexer>:
 * * DNA_OK: the operation is successfull
 *
 * SOURCE
 */

{
   12a00:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
   12a04:	e24dd00c 	sub	sp, sp, #12
   12a08:	e1a06000 	mov	r6, r0
  queue_link_t * isr;
  status_t status;
  int32_t current_cpuid = cpu_mp_id (), itn = (int32_t) data;
   12a0c:	ebfff6f5 	bl	105e8 <cpu_mp_id>
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
  queue_t * queue = & cpu -> isr[itn];
  thread_t thread, self = cpu -> current_thread;
   12a10:	e59f713c 	ldr	r7, [pc, #316]	; 12b54 <interrupt_demultiplexer+0x154>
   12a14:	e0800180 	add	r0, r0, r0, lsl #3
   12a18:	e0873300 	add	r3, r7, r0, lsl #6

  watch (int32_t)
  {
    ensure (itn < CPU_TRAP_COUNT, DNA_BAD_ARGUMENT);
   12a1c:	e356001f 	cmp	r6, #31
  queue_link_t * isr;
  status_t status;
  int32_t current_cpuid = cpu_mp_id (), itn = (int32_t) data;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
  queue_t * queue = & cpu -> isr[itn];
  thread_t thread, self = cpu -> current_thread;
   12a20:	e593822c 	ldr	r8, [r3, #556]	; 0x22c

  watch (int32_t)
  {
    ensure (itn < CPU_TRAP_COUNT, DNA_BAD_ARGUMENT);
   12a24:	c59f012c 	ldrgt	r0, [pc, #300]	; 12b58 <interrupt_demultiplexer+0x158>
   12a28:	da000001 	ble	12a34 <interrupt_demultiplexer+0x34>
      }
    }

    return DNA_OK;
  }
}
   12a2c:	e28dd00c 	add	sp, sp, #12
   12a30:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
{
  queue_link_t * isr;
  status_t status;
  int32_t current_cpuid = cpu_mp_id (), itn = (int32_t) data;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
  queue_t * queue = & cpu -> isr[itn];
   12a34:	e0864100 	add	r4, r6, r0, lsl #2
   12a38:	e2844002 	add	r4, r4, #2
   12a3c:	e1a04204 	lsl	r4, r4, #4
   12a40:	e2849008 	add	r9, r4, #8
   12a44:	e0899007 	add	r9, r9, r7

    /*
     * Look for the corresponding handler
     */

    lock_acquire (& queue -> lock);
   12a48:	e1a00009 	mov	r0, r9
    status = DNA_UNHANDLED_INTERRUPT;

    for (isr = queue -> head; isr != NULL; isr = isr -> next)
   12a4c:	e0874004 	add	r4, r7, r4

    /*
     * Look for the corresponding handler
     */

    lock_acquire (& queue -> lock);
   12a50:	ebfff7da 	bl	109c0 <lock_acquire>
    status = DNA_UNHANDLED_INTERRUPT;

    for (isr = queue -> head; isr != NULL; isr = isr -> next)
   12a54:	e594400c 	ldr	r4, [r4, #12]
   12a58:	e3540000 	cmp	r4, #0
   12a5c:	1a000003 	bne	12a70 <interrupt_demultiplexer+0x70>
   12a60:	ea000037 	b	12b44 <interrupt_demultiplexer+0x144>
   12a64:	e5944000 	ldr	r4, [r4]
   12a68:	e3540000 	cmp	r4, #0
   12a6c:	0a00000d 	beq	12aa8 <interrupt_demultiplexer+0xa8>
    {
      status = ((isr_t)isr) -> handler (data);
   12a70:	e5943004 	ldr	r3, [r4, #4]
   12a74:	e1a00006 	mov	r0, r6
   12a78:	e12fff33 	blx	r3
   12a7c:	e6ff5070 	uxth	r5, r0

      if (status == DNA_INVOKE_SCHEDULER || status == DNA_HANDLED_INTERRUPT)
   12a80:	e3550003 	cmp	r5, #3
   12a84:	13550005 	cmpne	r5, #5
   12a88:	1afffff5 	bne	12a64 <interrupt_demultiplexer+0x64>
      {
        break;
      }
    }

    lock_release (& queue -> lock);
   12a8c:	e1a00009 	mov	r0, r9
   12a90:	eb00027e 	bl	13490 <lock_release>

    /*
     * If necessary, invoke the scheduler.
     */

    if (status == DNA_INVOKE_SCHEDULER)
   12a94:	e3550003 	cmp	r5, #3
   12a98:	0a000005 	beq	12ab4 <interrupt_demultiplexer+0xb4>
        status = scheduler_switch (thread, queue);
        ensure (status == DNA_OK, status);
      }
    }

    return DNA_OK;
   12a9c:	e3a00000 	mov	r0, #0
  }
}
   12aa0:	e28dd00c 	add	sp, sp, #12
   12aa4:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
      {
        break;
      }
    }

    lock_release (& queue -> lock);
   12aa8:	e1a00009 	mov	r0, r9
   12aac:	eb000277 	bl	13490 <lock_release>
   12ab0:	eafffff9 	b	12a9c <interrupt_demultiplexer+0x9c>
     * If necessary, invoke the scheduler.
     */

    if (status == DNA_INVOKE_SCHEDULER)
    {
      status = scheduler_elect (& thread, false);
   12ab4:	e28d0004 	add	r0, sp, #4
   12ab8:	e3a01000 	mov	r1, #0
   12abc:	ebfffedf 	bl	12640 <scheduler_elect>
      ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);
   12ac0:	e59f2090 	ldr	r2, [pc, #144]	; 12b58 <interrupt_demultiplexer+0x158>
   12ac4:	e59f3090 	ldr	r3, [pc, #144]	; 12b5c <interrupt_demultiplexer+0x15c>
   12ac8:	e1500003 	cmp	r0, r3
   12acc:	11500002 	cmpne	r0, r2
   12ad0:	0affffd5 	beq	12a2c <interrupt_demultiplexer+0x2c>

      if (status != DNA_NO_AVAILABLE_THREAD)
   12ad4:	e59f3084 	ldr	r3, [pc, #132]	; 12b60 <interrupt_demultiplexer+0x160>
   12ad8:	e1500003 	cmp	r0, r3
   12adc:	0affffee 	beq	12a9c <interrupt_demultiplexer+0x9c>
      {
        lock_acquire (& self -> lock);
   12ae0:	e2880014 	add	r0, r8, #20
   12ae4:	ebfff7b5 	bl	109c0 <lock_acquire>
        self -> info . status = DNA_THREAD_READY;
   12ae8:	e59f3074 	ldr	r3, [pc, #116]	; 12b64 <interrupt_demultiplexer+0x164>
   12aec:	e1c835b0 	strh	r3, [r8, #80]	; 0x50

        if (self != cpu_pool . cpu[cpu_mp_id()] . idle_thread)
   12af0:	ebfff6bc 	bl	105e8 <cpu_mp_id>
   12af4:	e0800180 	add	r0, r0, r0, lsl #3
   12af8:	e0877300 	add	r7, r7, r0, lsl #6
   12afc:	e5973230 	ldr	r3, [r7, #560]	; 0x230
   12b00:	e1530008 	cmp	r3, r8
   12b04:	0a000008 	beq	12b2c <interrupt_demultiplexer+0x12c>
        {
          queue = & scheduler . queue[self -> info . affinity];
   12b08:	e5989048 	ldr	r9, [r8, #72]	; 0x48
   12b0c:	e59f3054 	ldr	r3, [pc, #84]	; 12b68 <interrupt_demultiplexer+0x168>
   12b10:	e0839209 	add	r9, r3, r9, lsl #4
   12b14:	e2899004 	add	r9, r9, #4
          lock_acquire (& queue -> lock);
   12b18:	e1a00009 	mov	r0, r9
   12b1c:	ebfff7a7 	bl	109c0 <lock_acquire>
          queue_add (queue, self);
   12b20:	e1a00009 	mov	r0, r9
   12b24:	e1a01008 	mov	r1, r8
   12b28:	ebfff4b9 	bl	fe14 <queue_add>
        }

        status = scheduler_switch (thread, queue);
   12b2c:	e1a01009 	mov	r1, r9
   12b30:	e59d0004 	ldr	r0, [sp, #4]
   12b34:	eb0000c7 	bl	12e58 <scheduler_switch>
        ensure (status == DNA_OK, status);
   12b38:	e3500000 	cmp	r0, #0
   12b3c:	1affffba 	bne	12a2c <interrupt_demultiplexer+0x2c>
   12b40:	eaffffd5 	b	12a9c <interrupt_demultiplexer+0x9c>
      {
        break;
      }
    }

    lock_release (& queue -> lock);
   12b44:	e1a00009 	mov	r0, r9
   12b48:	eb000250 	bl	13490 <lock_release>
        status = scheduler_switch (thread, queue);
        ensure (status == DNA_OK, status);
      }
    }

    return DNA_OK;
   12b4c:	e1a00004 	mov	r0, r4
   12b50:	eaffffb5 	b	12a2c <interrupt_demultiplexer+0x2c>
   12b54:	001883e8 	.word	0x001883e8
   12b58:	0000fffc 	.word	0x0000fffc
   12b5c:	0000ffff 	.word	0x0000ffff
   12b60:	0000fcfd 	.word	0x0000fcfd
   12b64:	ffffface 	.word	0xffffface
   12b68:	0018a800 	.word	0x0018a800

00012b6c <core_start>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   12b6c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  uint32_t current_cpuid = cpu_mp_id ();
   12b70:	ebfff69c 	bl	105e8 <cpu_mp_id>
  thread_t thread = cpu_pool . cpu[current_cpuid] . current_thread;
   12b74:	e59f607c 	ldr	r6, [pc, #124]	; 12bf8 <core_start+0x8c>
   12b78:	e0807180 	add	r7, r0, r0, lsl #3
   12b7c:	e1a07307 	lsl	r7, r7, #6
   12b80:	e0868007 	add	r8, r6, r7
   12b84:	e598422c 	ldr	r4, [r8, #556]	; 0x22c
 *
 * SOURCE
 */

{
  uint32_t current_cpuid = cpu_mp_id ();
   12b88:	e1a05000 	mov	r5, r0
  thread_t thread = cpu_pool . cpu[current_cpuid] . current_thread;

  watch (status_t)
  {
    ensure (thread != NULL, DNA_ERROR);
   12b8c:	e3540000 	cmp	r4, #0
   12b90:	0a00000b 	beq	12bc4 <core_start+0x58>

    lock_acquire (& thread -> lock);
   12b94:	e2840014 	add	r0, r4, #20
   12b98:	ebfff788 	bl	109c0 <lock_acquire>

    if (current_cpuid == 0)
   12b9c:	e3550000 	cmp	r5, #0
   12ba0:	1a000009 	bne	12bcc <core_start+0x60>
    {
      cpu_pool . cpu[current_cpuid] . status = DNA_CPU_RUNNING;
   12ba4:	e59f3050 	ldr	r3, [pc, #80]	; 12bfc <core_start+0x90>
   12ba8:	e1c631b0 	strh	r3, [r6, #16]
      lock_acquire (& cpu_pool . queue . lock);
      queue_add (& cpu_pool . queue, & cpu_pool . cpu[current_cpuid]);
      lock_release (& cpu_pool . queue . lock);
    }

    thread -> info . status = DNA_THREAD_RUNNING;
   12bac:	e59f3048 	ldr	r3, [pc, #72]	; 12bfc <core_start+0x90>
    cpu_context_load (& thread -> context);
   12bb0:	e2840084 	add	r0, r4, #132	; 0x84
      lock_acquire (& cpu_pool . queue . lock);
      queue_add (& cpu_pool . queue, & cpu_pool . cpu[current_cpuid]);
      lock_release (& cpu_pool . queue . lock);
    }

    thread -> info . status = DNA_THREAD_RUNNING;
   12bb4:	e1c435b0 	strh	r3, [r4, #80]	; 0x50
    cpu_context_load (& thread -> context);
   12bb8:	ebffb550 	bl	100 <cpu_context_load>

    return DNA_OK;
   12bbc:	e3a00000 	mov	r0, #0
   12bc0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  uint32_t current_cpuid = cpu_mp_id ();
  thread_t thread = cpu_pool . cpu[current_cpuid] . current_thread;

  watch (status_t)
  {
    ensure (thread != NULL, DNA_ERROR);
   12bc4:	e59f0034 	ldr	r0, [pc, #52]	; 12c00 <core_start+0x94>
    thread -> info . status = DNA_THREAD_RUNNING;
    cpu_context_load (& thread -> context);

    return DNA_OK;
  }
}
   12bc8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    {
      cpu_pool . cpu[current_cpuid] . status = DNA_CPU_RUNNING;
    }
    else
    {
      cpu_pool . cpu[current_cpuid] . status = DNA_CPU_READY;
   12bcc:	e59f3030 	ldr	r3, [pc, #48]	; 12c04 <core_start+0x98>
      lock_acquire (& cpu_pool . queue . lock);
   12bd0:	e59f0030 	ldr	r0, [pc, #48]	; 12c08 <core_start+0x9c>
    {
      cpu_pool . cpu[current_cpuid] . status = DNA_CPU_RUNNING;
    }
    else
    {
      cpu_pool . cpu[current_cpuid] . status = DNA_CPU_READY;
   12bd4:	e1c831b0 	strh	r3, [r8, #16]
      lock_acquire (& cpu_pool . queue . lock);
   12bd8:	ebfff778 	bl	109c0 <lock_acquire>
      queue_add (& cpu_pool . queue, & cpu_pool . cpu[current_cpuid]);
   12bdc:	e2871008 	add	r1, r7, #8
   12be0:	e0861001 	add	r1, r6, r1
   12be4:	e59f001c 	ldr	r0, [pc, #28]	; 12c08 <core_start+0x9c>
   12be8:	ebfff489 	bl	fe14 <queue_add>
      lock_release (& cpu_pool . queue . lock);
   12bec:	e59f0014 	ldr	r0, [pc, #20]	; 12c08 <core_start+0x9c>
   12bf0:	eb000226 	bl	13490 <lock_release>
   12bf4:	eaffffec 	b	12bac <core_start+0x40>
   12bf8:	001883e8 	.word	0x001883e8
   12bfc:	ffffbeef 	.word	0xffffbeef
   12c00:	0000ffff 	.word	0x0000ffff
   12c04:	ffffface 	.word	0xffffface
   12c08:	0018a7f0 	.word	0x0018a7f0

00012c0c <alarm_comparator>:
  alarm_t alarm1 = item1;
  alarm_t alarm2 = item2;
  
  watch (bool)
  {
    ensure (alarm1 != NULL && alarm2 != NULL, false);
   12c0c:	e3510000 	cmp	r1, #0
   12c10:	13500000 	cmpne	r0, #0
   12c14:	0a000008 	beq	12c3c <alarm_comparator+0x30>
    return alarm2 -> deadline < alarm1 -> deadline;
   12c18:	e1c022d8 	ldrd	r2, [r0, #40]	; 0x28
 * item2 < item1.
 *
 * SOURCE
 */

{
   12c1c:	e92d0030 	push	{r4, r5}
  alarm_t alarm2 = item2;
  
  watch (bool)
  {
    ensure (alarm1 != NULL && alarm2 != NULL, false);
    return alarm2 -> deadline < alarm1 -> deadline;
   12c20:	e1c142d8 	ldrd	r4, [r1, #40]	; 0x28
   12c24:	e1540002 	cmp	r4, r2
   12c28:	e0d51003 	sbcs	r1, r5, r3
   12c2c:	b3a00001 	movlt	r0, #1
  }
}
   12c30:	e8bd0030 	pop	{r4, r5}
  alarm_t alarm2 = item2;
  
  watch (bool)
  {
    ensure (alarm1 != NULL && alarm2 != NULL, false);
    return alarm2 -> deadline < alarm1 -> deadline;
   12c34:	a3a00000 	movge	r0, #0
  }
}
   12c38:	e12fff1e 	bx	lr
  alarm_t alarm1 = item1;
  alarm_t alarm2 = item2;
  
  watch (bool)
  {
    ensure (alarm1 != NULL && alarm2 != NULL, false);
   12c3c:	e3a00000 	mov	r0, #0
   12c40:	e12fff1e 	bx	lr

00012c44 <port_read>:
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
   12c44:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  status_t status;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
   12c48:	e1a06820 	lsr	r6, r0, #16
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
   12c4c:	e24dd024 	sub	sp, sp, #36	; 0x24
  status_t status;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
   12c50:	e356003f 	cmp	r6, #63	; 0x3f
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
   12c54:	e1a07000 	mov	r7, r0
   12c58:	e1cd45d0 	ldrd	r4, [sp, #80]	; 0x50
   12c5c:	e1a0b002 	mov	fp, r2
  status_t status;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
   12c60:	859f01e4 	ldrhi	r0, [pc, #484]	; 12e4c <port_read+0x208>
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
   12c64:	e59d2048 	ldr	r2, [sp, #72]	; 0x48
  status_t status;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
   12c68:	9a000001 	bls	12c74 <port_read+0x30>
  {
    lock_release (& port_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
   12c6c:	e28dd024 	add	sp, sp, #36	; 0x24
   12c70:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   12c74:	e1a08001 	mov	r8, r1

    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
   12c78:	e58d200c 	str	r2, [sp, #12]
   12c7c:	e58d3008 	str	r3, [sp, #8]
   12c80:	ebfff602 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   12c84:	e3a0a068 	mov	sl, #104	; 0x68
    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);
   12c88:	e59f91c0 	ldr	r9, [pc, #448]	; 12e50 <port_read+0x20c>

    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
   12c8c:	e58d0014 	str	r0, [sp, #20]
    lock_acquire (& port_pool . lock);
   12c90:	e1a00009 	mov	r0, r9
   12c94:	ebfff749 	bl	109c0 <lock_acquire>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   12c98:	e000069a 	mul	r0, sl, r6
   12c9c:	e0891000 	add	r1, r9, r0
   12ca0:	e591e00c 	ldr	lr, [r1, #12]
   12ca4:	e157000e 	cmp	r7, lr
   12ca8:	0a000006 	beq	12cc8 <port_read+0x84>
    leave;
  }

  rescue (bad_portid)
  {
    lock_release (& port_pool . lock);
   12cac:	e59f019c 	ldr	r0, [pc, #412]	; 12e50 <port_read+0x20c>
   12cb0:	eb0001f6 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   12cb4:	e59d0014 	ldr	r0, [sp, #20]
   12cb8:	ebfff62d 	bl	10574 <cpu_trap_restore>
    leave;
   12cbc:	e59f0188 	ldr	r0, [pc, #392]	; 12e4c <port_read+0x208>
  }
}
   12cc0:	e28dd024 	add	sp, sp, #36	; 0x24
   12cc4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    lock_acquire (& port -> lock);
   12cc8:	e2800010 	add	r0, r0, #16
   12ccc:	e0800009 	add	r0, r0, r9
   12cd0:	e58d1010 	str	r1, [sp, #16]
   12cd4:	e58d0018 	str	r0, [sp, #24]
   12cd8:	ebfff738 	bl	109c0 <lock_acquire>
    lock_release (& port_pool . lock);
   12cdc:	e1a00009 	mov	r0, r9
   12ce0:	eb0001ea 	bl	13490 <lock_release>

    check (bad_port, ! port -> closed ||
   12ce4:	e59d1010 	ldr	r1, [sp, #16]
   12ce8:	e59d200c 	ldr	r2, [sp, #12]
   12cec:	e5d11014 	ldrb	r1, [r1, #20]
   12cf0:	e59d3008 	ldr	r3, [sp, #8]
   12cf4:	e3510000 	cmp	r1, #0
   12cf8:	0a00000a 	beq	12d28 <port_read+0xe4>
   12cfc:	e02aaa96 	mla	sl, r6, sl, sl
   12d00:	e089a00a 	add	sl, r9, sl
   12d04:	e59a1004 	ldr	r1, [sl, #4]
   12d08:	e3510000 	cmp	r1, #0
   12d0c:	1a000005 	bne	12d28 <port_read+0xe4>
    return DNA_OK;
  }

  rescue (bad_port)
  {
    lock_release (& port -> lock);
   12d10:	e59d0018 	ldr	r0, [sp, #24]
   12d14:	eb0001dd 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   12d18:	e59d0014 	ldr	r0, [sp, #20]
   12d1c:	ebfff614 	bl	10574 <cpu_trap_restore>
    leave;
   12d20:	e59f012c 	ldr	r0, [pc, #300]	; 12e54 <port_read+0x210>
   12d24:	eaffffd0 	b	12c6c <port_read+0x28>
    lock_release (& port_pool . lock);

    check (bad_port, ! port -> closed ||
        port -> mailbox . status != 0, DNA_ERROR);

    read_sem = port -> read_sem;
   12d28:	e3a01068 	mov	r1, #104	; 0x68
   12d2c:	e02a9691 	mla	sl, r1, r6, r9
    write_sem = port -> write_sem;
   12d30:	e59ac048 	ldr	ip, [sl, #72]	; 0x48
    lock_release (& port_pool . lock);

    check (bad_port, ! port -> closed ||
        port -> mailbox . status != 0, DNA_ERROR);

    read_sem = port -> read_sem;
   12d34:	e59a1044 	ldr	r1, [sl, #68]	; 0x44
    write_sem = port -> write_sem;

    lock_release (& port -> lock);
   12d38:	e59d0018 	ldr	r0, [sp, #24]

    check (bad_port, ! port -> closed ||
        port -> mailbox . status != 0, DNA_ERROR);

    read_sem = port -> read_sem;
    write_sem = port -> write_sem;
   12d3c:	e58dc01c 	str	ip, [sp, #28]

    lock_release (& port -> lock);
   12d40:	e58d1010 	str	r1, [sp, #16]
   12d44:	e58d200c 	str	r2, [sp, #12]
   12d48:	e58d3008 	str	r3, [sp, #8]
   12d4c:	eb0001cf 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   12d50:	e59d0014 	ldr	r0, [sp, #20]
   12d54:	ebfff606 	bl	10574 <cpu_trap_restore>

    /*
     * Acquire the semaphore.
     */

    status = semaphore_acquire (read_sem, 1, flags, timeout);
   12d58:	e59d1010 	ldr	r1, [sp, #16]
   12d5c:	e1cd40f0 	strd	r4, [sp]
   12d60:	e1a00001 	mov	r0, r1
   12d64:	e59d200c 	ldr	r2, [sp, #12]
   12d68:	e3a01001 	mov	r1, #1
   12d6c:	ebfffc7a 	bl	11f5c <semaphore_acquire>
    ensure (status == DNA_OK, status);
   12d70:	e3500000 	cmp	r0, #0
    lock_release (& port_pool . lock);

    check (bad_port, ! port -> closed ||
        port -> mailbox . status != 0, DNA_ERROR);

    read_sem = port -> read_sem;
   12d74:	e59f40d4 	ldr	r4, [pc, #212]	; 12e50 <port_read+0x20c>
    /*
     * Acquire the semaphore.
     */

    status = semaphore_acquire (read_sem, 1, flags, timeout);
    ensure (status == DNA_OK, status);
   12d78:	1affffbb 	bne	12c6c <port_read+0x28>
    /*
     * Get the port once again, just to make sure
     * it has not been destroyed in the meantime.
     */

    it_status = cpu_trap_mask_and_backup ();
   12d7c:	ebfff5c3 	bl	10490 <cpu_trap_mask_and_backup>
   12d80:	e58d0014 	str	r0, [sp, #20]
    lock_acquire (& port_pool . lock);
   12d84:	e1a00004 	mov	r0, r4
   12d88:	ebfff70c 	bl	109c0 <lock_acquire>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   12d8c:	e59a200c 	ldr	r2, [sl, #12]
   12d90:	e1570002 	cmp	r7, r2
   12d94:	1affffc4 	bne	12cac <port_read+0x68>

    lock_acquire (& port -> lock);
   12d98:	e59d0018 	ldr	r0, [sp, #24]
   12d9c:	ebfff707 	bl	109c0 <lock_acquire>
    lock_release (& port_pool . lock);
   12da0:	e1a00004 	mov	r0, r4
   12da4:	eb0001b9 	bl	13490 <lock_release>

    check (bad_port, ! port -> closed ||
   12da8:	e5da2014 	ldrb	r2, [sl, #20]
   12dac:	e59d3008 	ldr	r3, [sp, #8]
   12db0:	e3520000 	cmp	r2, #0
   12db4:	0a000005 	beq	12dd0 <port_read+0x18c>
   12db8:	e3a01068 	mov	r1, #104	; 0x68
   12dbc:	e2862001 	add	r2, r6, #1
   12dc0:	e0244291 	mla	r4, r1, r2, r4
   12dc4:	e5942004 	ldr	r2, [r4, #4]
   12dc8:	e3520000 	cmp	r2, #0
   12dcc:	0affffcf 	beq	12d10 <port_read+0xcc>
    /*
     * Get the message from the mailbox, and
     * put it back in the message queue.
     */

    message = queue_rem (& port -> mailbox);
   12dd0:	e3a02068 	mov	r2, #104	; 0x68
   12dd4:	e0060692 	mul	r6, r2, r6
   12dd8:	e2860060 	add	r0, r6, #96	; 0x60
   12ddc:	e0890000 	add	r0, r9, r0
   12de0:	e58d3008 	str	r3, [sp, #8]
   12de4:	ebfff141 	bl	f2f0 <queue_rem>
    check (bad_port, message != NULL, DNA_ERROR);
   12de8:	e2501000 	subs	r1, r0, #0
    /*
     * Get the message from the mailbox, and
     * put it back in the message queue.
     */

    message = queue_rem (& port -> mailbox);
   12dec:	e59f405c 	ldr	r4, [pc, #92]	; 12e50 <port_read+0x20c>
    check (bad_port, message != NULL, DNA_ERROR);
   12df0:	e59d3008 	ldr	r3, [sp, #8]
   12df4:	0affffc5 	beq	12d10 <port_read+0xcc>

    *p_code = message -> code;
   12df8:	e591e004 	ldr	lr, [r1, #4]
#if 0
    data_size = size >= message -> size ? message -> size : size;
#endif
    dna_memcpy (buffer, message -> buffer, size);
   12dfc:	e1a02003 	mov	r2, r3
     */

    message = queue_rem (& port -> mailbox);
    check (bad_port, message != NULL, DNA_ERROR);

    *p_code = message -> code;
   12e00:	e588e000 	str	lr, [r8]
#if 0
    data_size = size >= message -> size ? message -> size : size;
#endif
    dna_memcpy (buffer, message -> buffer, size);
   12e04:	e1a0000b 	mov	r0, fp
   12e08:	e591100c 	ldr	r1, [r1, #12]
   12e0c:	ebfff4a0 	bl	10094 <dna_memcpy>

    queue_add (& port -> message, port);
   12e10:	e2860050 	add	r0, r6, #80	; 0x50
     */

    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
   12e14:	e2861008 	add	r1, r6, #8
#if 0
    data_size = size >= message -> size ? message -> size : size;
#endif
    dna_memcpy (buffer, message -> buffer, size);

    queue_add (& port -> message, port);
   12e18:	e0841001 	add	r1, r4, r1
   12e1c:	e0840000 	add	r0, r4, r0
   12e20:	ebfff3fb 	bl	fe14 <queue_add>

    lock_release (& port -> lock);
   12e24:	e59d0018 	ldr	r0, [sp, #24]
   12e28:	eb000198 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   12e2c:	e59d0014 	ldr	r0, [sp, #20]
   12e30:	ebfff5cf 	bl	10574 <cpu_trap_restore>

    /*
     * Delete the message, release the write semaphore, and return.
     */

    status = semaphore_release (write_sem, 1, DNA_NO_RESCHEDULE);
   12e34:	e3a01001 	mov	r1, #1
   12e38:	e1a02001 	mov	r2, r1
   12e3c:	e59d001c 	ldr	r0, [sp, #28]
  {
    lock_release (& port_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
   12e40:	e28dd024 	add	sp, sp, #36	; 0x24
   12e44:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

    /*
     * Delete the message, release the write semaphore, and return.
     */

    status = semaphore_release (write_sem, 1, DNA_NO_RESCHEDULE);
   12e48:	ea000107 	b	1326c <semaphore_release>
   12e4c:	0000faff 	.word	0x0000faff
   12e50:	001835b8 	.word	0x001835b8
   12e54:	0000ffff 	.word	0x0000ffff

00012e58 <scheduler_switch>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   12e58:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   12e5c:	e24dd014 	sub	sp, sp, #20
   12e60:	e1a08000 	mov	r8, r0
   12e64:	e1a06001 	mov	r6, r1
  uint32_t current_cpuid = cpu_mp_id ();
   12e68:	ebfff5de 	bl	105e8 <cpu_mp_id>
  bigtime_t current_time = 0, delta = 0;
   12e6c:	e3a02000 	mov	r2, #0
   12e70:	e3a03000 	mov	r3, #0
  extern uint32_t __scheduler_switch_end;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
  thread_t self = cpu -> current_thread;
   12e74:	e1a07180 	lsl	r7, r0, #3
   12e78:	e0871000 	add	r1, r7, r0
   12e7c:	e59f4144 	ldr	r4, [pc, #324]	; 12fc8 <__scheduler_switch_end+0x88>
   12e80:	e1a01301 	lsl	r1, r1, #6

  watch (status_t)
  {
    ensure (thread != NULL, DNA_BAD_ARGUMENT);
   12e84:	e3580000 	cmp	r8, #0
{
  uint32_t current_cpuid = cpu_mp_id ();
  bigtime_t current_time = 0, delta = 0;
  extern uint32_t __scheduler_switch_end;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
  thread_t self = cpu -> current_thread;
   12e88:	e084a001 	add	sl, r4, r1
 *
 * SOURCE
 */

{
  uint32_t current_cpuid = cpu_mp_id ();
   12e8c:	e1a09000 	mov	r9, r0
  bigtime_t current_time = 0, delta = 0;
  extern uint32_t __scheduler_switch_end;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
  thread_t self = cpu -> current_thread;
   12e90:	e59ab22c 	ldr	fp, [sl, #556]	; 0x22c
 * SOURCE
 */

{
  uint32_t current_cpuid = cpu_mp_id ();
  bigtime_t current_time = 0, delta = 0;
   12e94:	e1cd20f8 	strd	r2, [sp, #8]
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
  thread_t self = cpu -> current_thread;

  watch (status_t)
  {
    ensure (thread != NULL, DNA_BAD_ARGUMENT);
   12e98:	059f012c 	ldreq	r0, [pc, #300]	; 12fcc <__scheduler_switch_end+0x8c>
   12e9c:	0a000034 	beq	12f74 <__scheduler_switch_end+0x34>

{
  uint32_t current_cpuid = cpu_mp_id ();
  bigtime_t current_time = 0, delta = 0;
  extern uint32_t __scheduler_switch_end;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
   12ea0:	e2813008 	add	r3, r1, #8
   12ea4:	e0833004 	add	r3, r3, r4

    /*
     * Compute the correct times if necessary
     */

    cpu_timer_get (current_cpuid, & current_time);
   12ea8:	e28d1008 	add	r1, sp, #8

{
  uint32_t current_cpuid = cpu_mp_id ();
  bigtime_t current_time = 0, delta = 0;
  extern uint32_t __scheduler_switch_end;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
   12eac:	e58d3004 	str	r3, [sp, #4]

    /*
     * Compute the correct times if necessary
     */

    cpu_timer_get (current_cpuid, & current_time);
   12eb0:	ebfff59b 	bl	10524 <cpu_timer_get>
    delta = current_time - cpu -> lap_date;
   12eb4:	e1ca02d0 	ldrd	r0, [sl, #32]
   12eb8:	e1cd20d8 	ldrd	r2, [sp, #8]
   12ebc:	e0522000 	subs	r2, r2, r0
   12ec0:	e0c33001 	sbc	r3, r3, r1

    /*
     * Update the status of the target thread
     */

    thread -> info . status = DNA_THREAD_RUNNING;
   12ec4:	e59f5104 	ldr	r5, [pc, #260]	; 12fd0 <__scheduler_switch_end+0x90>
     * Compute the correct times if necessary
     */

    cpu_timer_get (current_cpuid, & current_time);
    delta = current_time - cpu -> lap_date;
    self -> info . kernel_time += delta;
   12ec8:	e1cb05d8 	ldrd	r0, [fp, #88]	; 0x58
   12ecc:	e0922000 	adds	r2, r2, r0
   12ed0:	e0a33001 	adc	r3, r3, r1
   12ed4:	e1cb25f8 	strd	r2, [fp, #88]	; 0x58
    thread -> info . cpu_id = current_cpuid;

    /*
     * Save the current context
     */
    cpu_context_save (& self -> context, & __scheduler_switch_end);
   12ed8:	e28b0084 	add	r0, fp, #132	; 0x84
     */

    cpu_timer_get (current_cpuid, & current_time);
    delta = current_time - cpu -> lap_date;
    self -> info . kernel_time += delta;
    cpu->prev_thread = self;
   12edc:	e58ab228 	str	fp, [sl, #552]	; 0x228
    thread -> info . cpu_id = current_cpuid;

    /*
     * Save the current context
     */
    cpu_context_save (& self -> context, & __scheduler_switch_end);
   12ee0:	e59f10ec 	ldr	r1, [pc, #236]	; 12fd4 <__scheduler_switch_end+0x94>
    /*
     * Update the status of the target thread
     */

    thread -> info . status = DNA_THREAD_RUNNING;
    thread -> info . cpu_id = current_cpuid;
   12ee4:	e5889040 	str	r9, [r8, #64]	; 0x40

    /*
     * Update the status of the target thread
     */

    thread -> info . status = DNA_THREAD_RUNNING;
   12ee8:	e1c855b0 	strh	r5, [r8, #80]	; 0x50
    thread -> info . cpu_id = current_cpuid;

    /*
     * Save the current context
     */
    cpu_context_save (& self -> context, & __scheduler_switch_end);
   12eec:	ebffb467 	bl	90 <cpu_context_save>
    /*
     * Check if self is IDLE. In this case, remove CPU
     * from the available list. If target is IDLE, restore
     * the processor status to READY.
     */
    if (self == cpu -> idle_thread)
   12ef0:	e59a3230 	ldr	r3, [sl, #560]	; 0x230
   12ef4:	e153000b 	cmp	r3, fp
   12ef8:	0a00001f 	beq	12f7c <__scheduler_switch_end+0x3c>
      queue_extract (& cpu_pool . queue, cpu);
      lock_release (& cpu_pool . queue . lock);

      cpu -> status = DNA_CPU_RUNNING;
    }
    else if (thread == cpu -> idle_thread)
   12efc:	e1580003 	cmp	r8, r3
   12f00:	0a000026 	beq	12fa0 <__scheduler_switch_end+0x60>

    /*
     * Update the processor's status
     */

    cpu -> lap_date = current_time;
   12f04:	e1cd20d8 	ldrd	r2, [sp, #8]
   12f08:	e0879009 	add	r9, r7, r9
   12f0c:	e0849309 	add	r9, r4, r9, lsl #6

    /*
     * Release the queue's lock if queue is not NULL.
     */

    if (queue != NULL)
   12f10:	e3560000 	cmp	r6, #0
    /*
     * Update the processor's status
     */

    cpu -> lap_date = current_time;
    cpu -> current_thread = thread;
   12f14:	e589822c 	str	r8, [r9, #556]	; 0x22c

    /*
     * Update the processor's status
     */

    cpu -> lap_date = current_time;
   12f18:	e1c922f0 	strd	r2, [r9, #32]

    /*
     * Release the queue's lock if queue is not NULL.
     */

    if (queue != NULL)
   12f1c:	0a000001 	beq	12f28 <scheduler_switch+0xd0>
    {
      lock_release (& queue -> lock);
   12f20:	e1a00006 	mov	r0, r6
   12f24:	eb000159 	bl	13490 <lock_release>

    /*
     * Load the target context
     */

    cpu_dcache_invalidate((void*)&thread->context, CPU_CONTEXT_SIZE);
   12f28:	e2888084 	add	r8, r8, #132	; 0x84
   12f2c:	e1a00008 	mov	r0, r8
   12f30:	e3a0104c 	mov	r1, #76	; 0x4c
   12f34:	ebfff5c1 	bl	10640 <cpu_dcache_invalidate>
    cpu_context_load (& thread -> context);
   12f38:	e1a00008 	mov	r0, r8
   12f3c:	ebffb46f 	bl	100 <cpu_context_load>

00012f40 <__scheduler_switch_end>:
    /*
     * FIXME: Find a better idea for what follows 
     */

    __asm__ volatile ("__scheduler_switch_end:");
    cpu_dcache_invalidate(NULL, CPU_CACHE_ALL);
   12f40:	e3e01000 	mvn	r1, #0
   12f44:	e3a00000 	mov	r0, #0
   12f48:	ebfff5bc 	bl	10640 <cpu_dcache_invalidate>

    cpu = & cpu_pool . cpu[cpu_mp_id()];
   12f4c:	ebfff5a5 	bl	105e8 <cpu_mp_id>

    /*
     * prev and current threads are necessarily set here
     */
    lock_release (& (cpu-> prev_thread -> lock));
   12f50:	e0800180 	add	r0, r0, r0, lsl #3
   12f54:	e0844300 	add	r4, r4, r0, lsl #6
   12f58:	e5b40228 	ldr	r0, [r4, #552]!	; 0x228
   12f5c:	e2800014 	add	r0, r0, #20
   12f60:	eb00014a 	bl	13490 <lock_release>
    lock_release (& (cpu-> current_thread -> lock));
   12f64:	e5940004 	ldr	r0, [r4, #4]
   12f68:	e2800014 	add	r0, r0, #20
   12f6c:	eb000147 	bl	13490 <lock_release>
     * Contrary to what I thought at first, we cannot 
     * check if self is running the IDLE thread here, because
     * in the case of the CPU0 (the boot CPU), swithching to IDLE
     * would not branch here but directly in the IDLE thread handler.
     */
    return DNA_OK;
   12f70:	e3a00000 	mov	r0, #0
  }
}
   12f74:	e28dd014 	add	sp, sp, #20
   12f78:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
     */
    if (self == cpu -> idle_thread)
    {
dna_log(VERBOSE_LEVEL, "CPU(%d) << RUNNING", cpu -> id);

      lock_acquire (& cpu_pool . queue . lock);
   12f7c:	e59f0054 	ldr	r0, [pc, #84]	; 12fd8 <__scheduler_switch_end+0x98>
   12f80:	ebfff68e 	bl	109c0 <lock_acquire>
      queue_extract (& cpu_pool . queue, cpu);
   12f84:	e59d1004 	ldr	r1, [sp, #4]
   12f88:	e59f0048 	ldr	r0, [pc, #72]	; 12fd8 <__scheduler_switch_end+0x98>
   12f8c:	ebfff095 	bl	f1e8 <queue_extract>
      lock_release (& cpu_pool . queue . lock);
   12f90:	e59f0040 	ldr	r0, [pc, #64]	; 12fd8 <__scheduler_switch_end+0x98>
   12f94:	eb00013d 	bl	13490 <lock_release>

      cpu -> status = DNA_CPU_RUNNING;
   12f98:	e1ca51b0 	strh	r5, [sl, #16]
   12f9c:	eaffffd8 	b	12f04 <scheduler_switch+0xac>
    }
    else if (thread == cpu -> idle_thread)
    {
dna_log(VERBOSE_LEVEL, "CPU(%d) >> READY", cpu -> id);
      cpu -> status = DNA_CPU_READY;
   12fa0:	e59f3034 	ldr	r3, [pc, #52]	; 12fdc <__scheduler_switch_end+0x9c>

      lock_acquire (& cpu_pool . queue . lock);
   12fa4:	e59f002c 	ldr	r0, [pc, #44]	; 12fd8 <__scheduler_switch_end+0x98>
      cpu -> status = DNA_CPU_RUNNING;
    }
    else if (thread == cpu -> idle_thread)
    {
dna_log(VERBOSE_LEVEL, "CPU(%d) >> READY", cpu -> id);
      cpu -> status = DNA_CPU_READY;
   12fa8:	e1ca31b0 	strh	r3, [sl, #16]

      lock_acquire (& cpu_pool . queue . lock);
   12fac:	ebfff683 	bl	109c0 <lock_acquire>
      queue_add (& cpu_pool . queue, cpu);
   12fb0:	e59d1004 	ldr	r1, [sp, #4]
   12fb4:	e59f001c 	ldr	r0, [pc, #28]	; 12fd8 <__scheduler_switch_end+0x98>
   12fb8:	ebfff395 	bl	fe14 <queue_add>
      lock_release (& cpu_pool . queue . lock);
   12fbc:	e59f0014 	ldr	r0, [pc, #20]	; 12fd8 <__scheduler_switch_end+0x98>
   12fc0:	eb000132 	bl	13490 <lock_release>
   12fc4:	eaffffce 	b	12f04 <scheduler_switch+0xac>
   12fc8:	001883e8 	.word	0x001883e8
   12fcc:	0000fffc 	.word	0x0000fffc
   12fd0:	ffffbeef 	.word	0xffffbeef
   12fd4:	00012f40 	.word	0x00012f40
   12fd8:	0018a7f0 	.word	0x0018a7f0
   12fdc:	ffffface 	.word	0xffffface

00012fe0 <semaphore_create>:
  semaphore_t semaphore = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (name != NULL && id != NULL, DNA_BAD_ARGUMENT);
   12fe0:	e3520000 	cmp	r2, #0
   12fe4:	13500000 	cmpne	r0, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   12fe8:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  semaphore_t semaphore = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (name != NULL && id != NULL, DNA_BAD_ARGUMENT);
   12fec:	e1a05000 	mov	r5, r0
   12ff0:	e1a04002 	mov	r4, r2
   12ff4:	03a06001 	moveq	r6, #1
   12ff8:	13a06000 	movne	r6, #0
   12ffc:	1a000001 	bne	13008 <semaphore_create+0x28>
   13000:	e59f0094 	ldr	r0, [pc, #148]	; 1309c <semaphore_create+0xbc>
  {
    cpu_trap_restore(it_status);
    lock_release (& semaphore_pool . lock);
    leave;
  }
}
   13004:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13008:	e1a07001 	mov	r7, r1

  watch (status_t)
  {
    ensure (name != NULL && id != NULL, DNA_BAD_ARGUMENT);

    it_status = cpu_trap_mask_and_backup();
   1300c:	ebfff51f 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& semaphore_pool . lock);
   13010:	e59f9088 	ldr	r9, [pc, #136]	; 130a0 <semaphore_create+0xc0>

  watch (status_t)
  {
    ensure (name != NULL && id != NULL, DNA_BAD_ARGUMENT);

    it_status = cpu_trap_mask_and_backup();
   13014:	e1a0a000 	mov	sl, r0
    lock_acquire (& semaphore_pool . lock);
   13018:	e1a00009 	mov	r0, r9
   1301c:	ebfff667 	bl	109c0 <lock_acquire>

    /*
     * Get an empty semaphore slot.
     */

    semaphore = queue_rem (& semaphore_pool . semaphore);
   13020:	e59f007c 	ldr	r0, [pc, #124]	; 130a4 <semaphore_create+0xc4>
   13024:	ebfff0b1 	bl	f2f0 <queue_rem>
    check (pool_error, semaphore != NULL, DNA_NO_MORE_SEM);
   13028:	e2508000 	subs	r8, r0, #0
   1302c:	0a000014 	beq	13084 <semaphore_create+0xa4>
    /*
     * Make the place clean.
     */

    index = semaphore -> id . s . index;
    dna_memset (semaphore, 0, sizeof (struct _semaphore));
   13030:	e1a01006 	mov	r1, r6
   13034:	e3a02044 	mov	r2, #68	; 0x44

    /*
     * Make the place clean.
     */

    index = semaphore -> id . s . index;
   13038:	e1d8b0b6 	ldrh	fp, [r8, #6]
    dna_memset (semaphore, 0, sizeof (struct _semaphore));
   1303c:	ebfff10c 	bl	f474 <dna_memset>

    semaphore -> id . s . index = index;
    semaphore -> id . s . value = semaphore_pool . counter;
   13040:	e1d930b4 	ldrh	r3, [r9, #4]

    /*
     * Release the pool.
     */

    lock_release (& semaphore_pool . lock);
   13044:	e1a00009 	mov	r0, r9

    index = semaphore -> id . s . index;
    dna_memset (semaphore, 0, sizeof (struct _semaphore));

    semaphore -> id . s . index = index;
    semaphore -> id . s . value = semaphore_pool . counter;
   13048:	e1c830b4 	strh	r3, [r8, #4]
     */

    index = semaphore -> id . s . index;
    dna_memset (semaphore, 0, sizeof (struct _semaphore));

    semaphore -> id . s . index = index;
   1304c:	e1c8b0b6 	strh	fp, [r8, #6]
    semaphore -> id . s . value = semaphore_pool . counter;

    semaphore_pool . counter += 1;
   13050:	e2833001 	add	r3, r3, #1
   13054:	e1c930b4 	strh	r3, [r9, #4]

    /*
     * Release the pool.
     */

    lock_release (& semaphore_pool . lock);
   13058:	eb00010c 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   1305c:	e1a0000a 	mov	r0, sl
   13060:	ebfff543 	bl	10574 <cpu_trap_restore>

    /*
     * Fill in the information.
     */

    dna_strcpy (semaphore -> info . name, name);
   13064:	e1a01005 	mov	r1, r5
   13068:	e288001c 	add	r0, r8, #28
   1306c:	ebfff401 	bl	10078 <dna_strcpy>

dna_log(VERBOSE_LEVEL, "ID(%d:%d) TOKEN(%d)",
        semaphore -> id . s . value, semaphore -> id . s . index,
        semaphore -> info . tokens);

    *id = semaphore -> id . raw;
   13070:	e5983004 	ldr	r3, [r8, #4]
    /*
     * Fill in the information.
     */

    dna_strcpy (semaphore -> info . name, name);
    semaphore -> info . tokens = tokens;
   13074:	e588703c 	str	r7, [r8, #60]	; 0x3c
dna_log(VERBOSE_LEVEL, "ID(%d:%d) TOKEN(%d)",
        semaphore -> id . s . value, semaphore -> id . s . index,
        semaphore -> info . tokens);

    *id = semaphore -> id . raw;
    return DNA_OK;
   13078:	e1a00006 	mov	r0, r6

dna_log(VERBOSE_LEVEL, "ID(%d:%d) TOKEN(%d)",
        semaphore -> id . s . value, semaphore -> id . s . index,
        semaphore -> info . tokens);

    *id = semaphore -> id . raw;
   1307c:	e5843000 	str	r3, [r4]
    return DNA_OK;
   13080:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  }

  rescue (pool_error)
  {
    cpu_trap_restore(it_status);
   13084:	e1a0000a 	mov	r0, sl
   13088:	ebfff539 	bl	10574 <cpu_trap_restore>
    lock_release (& semaphore_pool . lock);
   1308c:	e1a00009 	mov	r0, r9
   13090:	eb0000fe 	bl	13490 <lock_release>
    leave;
   13094:	e59f000c 	ldr	r0, [pc, #12]	; 130a8 <semaphore_create+0xc8>
   13098:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1309c:	0000fffc 	.word	0x0000fffc
   130a0:	0013f5a0 	.word	0x0013f5a0
   130a4:	001835a8 	.word	0x001835a8
   130a8:	0000fdfe 	.word	0x0000fdfe

000130ac <alarm_destroy>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   130ac:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
   130b0:	e1a05000 	mov	r5, r0
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup();
   130b4:	ebfff4f5 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& alarm_pool . lock);
   130b8:	e59f4070 	ldr	r4, [pc, #112]	; 13130 <alarm_destroy+0x84>
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup();
   130bc:	e1a07000 	mov	r7, r0
    lock_acquire (& alarm_pool . lock);
   130c0:	e1a00004 	mov	r0, r4
   130c4:	ebfff63d 	bl	109c0 <lock_acquire>

    alarm = & alarm_pool . data[alarm_id . s . index];
   130c8:	e1a03825 	lsr	r3, r5, #16
    check (alarm_error, alarm != NULL, DNA_UNKNOWN_ALARM);
    check (alarm_error, alarm -> id . raw == alarm_id . raw, DNA_UNKNOWN_ALARM);
   130cc:	e1a03303 	lsl	r3, r3, #6
   130d0:	e0846003 	add	r6, r4, r3
   130d4:	e596200c 	ldr	r2, [r6, #12]
   130d8:	e1550002 	cmp	r5, r2
   130dc:	0a000005 	beq	130f8 <alarm_destroy+0x4c>
    return status;
  }

  rescue (alarm_error)
  {
    lock_release (& alarm_pool . lock);
   130e0:	e1a00004 	mov	r0, r4
   130e4:	eb0000e9 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   130e8:	e1a00007 	mov	r0, r7
   130ec:	ebfff520 	bl	10574 <cpu_trap_restore>
    leave;
   130f0:	e59f003c 	ldr	r0, [pc, #60]	; 13134 <alarm_destroy+0x88>
  }
}
   130f4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

    alarm = & alarm_pool . data[alarm_id . s . index];
    check (alarm_error, alarm != NULL, DNA_UNKNOWN_ALARM);
    check (alarm_error, alarm -> id . raw == alarm_id . raw, DNA_UNKNOWN_ALARM);

    lock_acquire (& alarm -> lock);
   130f8:	e2833020 	add	r3, r3, #32
   130fc:	e0835004 	add	r5, r3, r4
   13100:	e1a00005 	mov	r0, r5
   13104:	ebfff62d 	bl	109c0 <lock_acquire>
    lock_release (& alarm_pool . lock);
   13108:	e1a00004 	mov	r0, r4
   1310c:	eb0000df 	bl	13490 <lock_release>

    alarm -> is_invalid = true;
   13110:	e3a03001 	mov	r3, #1
    lock_release (& alarm -> lock);
   13114:	e1a00005 	mov	r0, r5
    check (alarm_error, alarm -> id . raw == alarm_id . raw, DNA_UNKNOWN_ALARM);

    lock_acquire (& alarm -> lock);
    lock_release (& alarm_pool . lock);

    alarm -> is_invalid = true;
   13118:	e5c6301c 	strb	r3, [r6, #28]
    lock_release (& alarm -> lock);
   1311c:	eb0000db 	bl	13490 <lock_release>

    cpu_trap_restore(it_status);
   13120:	e1a00007 	mov	r0, r7
   13124:	ebfff512 	bl	10574 <cpu_trap_restore>
    return status;
   13128:	e3a00000 	mov	r0, #0
   1312c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
   13130:	0018a918 	.word	0x0018a918
   13134:	0000fbfe 	.word	0x0000fbfe

00013138 <thread_destroy>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   13138:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
   1313c:	e1a03820 	lsr	r3, r0, #16
   13140:	e31300ff 	tst	r3, #255	; 0xff
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   13144:	e1a04000 	mov	r4, r0
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
   13148:	0a000001 	beq	13154 <thread_destroy+0x1c>
   1314c:	e59f00fc 	ldr	r0, [pc, #252]	; 13250 <thread_destroy+0x118>
  {
    lock_release (& thread_pool . lock);
    cpu_trap_restore (it_status);
    leave;
  }
}
   13150:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    ensure (tid . s . index >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . index < DNA_MAX_THREAD, DNA_BAD_ARGUMENT);
   13154:	e1a05c20 	lsr	r5, r0, #24
   13158:	e355003f 	cmp	r5, #63	; 0x3f
   1315c:	8afffffa 	bhi	1314c <thread_destroy+0x14>

    /*
     * Get some information about the execution.
     */

    it_status = cpu_trap_mask_and_backup ();
   13160:	ebfff4ca 	bl	10490 <cpu_trap_mask_and_backup>

    /*
     * Get the thread corresponding to ID and check the thread's status.
     */

    lock_acquire (& thread_pool . lock);
   13164:	e59f60e8 	ldr	r6, [pc, #232]	; 13254 <thread_destroy+0x11c>

    /*
     * Get some information about the execution.
     */

    it_status = cpu_trap_mask_and_backup ();
   13168:	e1a09000 	mov	r9, r0

    /*
     * Get the thread corresponding to ID and check the thread's status.
     */

    lock_acquire (& thread_pool . lock);
   1316c:	e1a00006 	mov	r0, r6
   13170:	ebfff612 	bl	109c0 <lock_acquire>
    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
   13174:	e3a030d0 	mov	r3, #208	; 0xd0
   13178:	e0030593 	mul	r3, r3, r5
   1317c:	e0867003 	add	r7, r6, r3
   13180:	e2878020 	add	r8, r7, #32
   13184:	e5982004 	ldr	r2, [r8, #4]
   13188:	e1540002 	cmp	r4, r2
   1318c:	159f40c4 	ldrne	r4, [pc, #196]	; 13258 <thread_destroy+0x120>
   13190:	0a000005 	beq	131ac <thread_destroy+0x74>
    lock_release (& thread -> lock);
  }

  rescue (bad_thread)
  {
    lock_release (& thread_pool . lock);
   13194:	e59f00b8 	ldr	r0, [pc, #184]	; 13254 <thread_destroy+0x11c>
   13198:	eb0000bc 	bl	13490 <lock_release>
    cpu_trap_restore (it_status);
   1319c:	e1a00009 	mov	r0, r9
   131a0:	ebfff4f3 	bl	10574 <cpu_trap_restore>
    leave;
   131a4:	e1a00004 	mov	r0, r4
   131a8:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
        thread -> id . raw == tid . raw , DNA_INVALID_THREAD_ID);

    lock_acquire (& thread -> lock);
   131ac:	e287401c 	add	r4, r7, #28
   131b0:	e1a00004 	mov	r0, r4
   131b4:	ebfff601 	bl	109c0 <lock_acquire>

    check (bad_status,
   131b8:	e1d735b8 	ldrh	r3, [r7, #88]	; 0x58
   131bc:	e59f1098 	ldr	r1, [pc, #152]	; 1325c <thread_destroy+0x124>
   131c0:	e59f2098 	ldr	r2, [pc, #152]	; 13260 <thread_destroy+0x128>
    return DNA_OK;
  }

  rescue (bad_status)
  {
    lock_release (& thread -> lock);
   131c4:	e1a00004 	mov	r0, r4
    check (bad_thread, thread != NULL &&
        thread -> id . raw == tid . raw , DNA_INVALID_THREAD_ID);

    lock_acquire (& thread -> lock);

    check (bad_status,
   131c8:	e1530001 	cmp	r3, r1
   131cc:	11530002 	cmpne	r3, r2
   131d0:	13a03001 	movne	r3, #1
   131d4:	03a03000 	moveq	r3, #0
   131d8:	0a000002 	beq	131e8 <thread_destroy+0xb0>
    return DNA_OK;
  }

  rescue (bad_status)
  {
    lock_release (& thread -> lock);
   131dc:	eb0000ab 	bl	13490 <lock_release>
    check (bad_thread, thread != NULL &&
        thread -> id . raw == tid . raw , DNA_INVALID_THREAD_ID);

    lock_acquire (& thread -> lock);

    check (bad_status,
   131e0:	e59f407c 	ldr	r4, [pc, #124]	; 13264 <thread_destroy+0x12c>
   131e4:	eaffffea 	b	13194 <thread_destroy+0x5c>
    /*
     * Erase the thread's entry in the thread pool
     * and free its memory. Do an early unlock of the pool.
     */

    thread -> id . s . value = 0;
   131e8:	e1c830b4 	strh	r3, [r8, #4]
    lock_release (& thread -> lock);
   131ec:	eb0000a7 	bl	13490 <lock_release>

    lock_release (& thread_pool . lock);
   131f0:	e1a00006 	mov	r0, r6
   131f4:	eb0000a5 	bl	13490 <lock_release>
    cpu_trap_restore (it_status);
   131f8:	e1a00009 	mov	r0, r9
   131fc:	ebfff4dc 	bl	10574 <cpu_trap_restore>

    if (thread -> stack_allocated)
   13200:	e5d73078 	ldrb	r3, [r7, #120]	; 0x78
   13204:	e3530000 	cmp	r3, #0
   13208:	0a000001 	beq	13214 <thread_destroy+0xdc>
    {
      kernel_free (thread -> info . stack_base);
   1320c:	e5970070 	ldr	r0, [r7, #112]	; 0x70
   13210:	eb0003d3 	bl	14164 <kernel_free>

    /*
     * Add the freed thread into the thread queue and return.
     */

    it_status = cpu_trap_mask_and_backup ();
   13214:	ebfff49d 	bl	10490 <cpu_trap_mask_and_backup>
   13218:	e1a04000 	mov	r4, r0
    lock_acquire (& thread_pool . lock);
   1321c:	e59f0030 	ldr	r0, [pc, #48]	; 13254 <thread_destroy+0x11c>
   13220:	ebfff5e6 	bl	109c0 <lock_acquire>
    /*
     * Get the thread corresponding to ID and check the thread's status.
     */

    lock_acquire (& thread_pool . lock);
    thread = & thread_pool . data[tid . s . group][tid . s . index];
   13224:	e3a010d0 	mov	r1, #208	; 0xd0
   13228:	e0216591 	mla	r1, r1, r5, r6
     */

    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& thread_pool . lock);

    queue_add (& thread_pool . thread[tid . s . group], thread);
   1322c:	e59f0034 	ldr	r0, [pc, #52]	; 13268 <thread_destroy+0x130>
   13230:	e2811008 	add	r1, r1, #8
   13234:	ebfff2f6 	bl	fe14 <queue_add>

    lock_release (& thread_pool . lock);
   13238:	e59f0014 	ldr	r0, [pc, #20]	; 13254 <thread_destroy+0x11c>
   1323c:	eb000093 	bl	13490 <lock_release>
    cpu_trap_restore (it_status);
   13240:	e1a00004 	mov	r0, r4
   13244:	ebfff4ca 	bl	10574 <cpu_trap_restore>

    return DNA_OK;
   13248:	e3a00000 	mov	r0, #0
   1324c:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
   13250:	0000fffc 	.word	0x0000fffc
   13254:	00184fd0 	.word	0x00184fd0
   13258:	0000fcfe 	.word	0x0000fcfe
   1325c:	0000d15a 	.word	0x0000d15a
   13260:	0000dead 	.word	0x0000dead
   13264:	0000ffff 	.word	0x0000ffff
   13268:	001883d8 	.word	0x001883d8

0001326c <semaphore_release>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   1326c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  status_t status = DNA_OK;
  bool smart_to_reschedule = false;

  watch (status_t)
  {
    ensure (tokens > 0, DNA_BAD_ARGUMENT);
   13270:	e251b000 	subs	fp, r1, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   13274:	e24dd01c 	sub	sp, sp, #28
  status_t status = DNA_OK;
  bool smart_to_reschedule = false;

  watch (status_t)
  {
    ensure (tokens > 0, DNA_BAD_ARGUMENT);
   13278:	d59f01f8 	ldrle	r0, [pc, #504]	; 13478 <semaphore_release+0x20c>
   1327c:	da000004 	ble	13294 <semaphore_release+0x28>
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);
   13280:	e1a04820 	lsr	r4, r0, #16
   13284:	e3540a01 	cmp	r4, #4096	; 0x1000
   13288:	e1a06000 	mov	r6, r0
   1328c:	259f01e8 	ldrcs	r0, [pc, #488]	; 1347c <semaphore_release+0x210>
   13290:	3a000001 	bcc	1329c <semaphore_release+0x30>
  {
    lock_release (& semaphore_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
   13294:	e28dd01c 	add	sp, sp, #28
   13298:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1329c:	e1a05002 	mov	r5, r2
  watch (status_t)
  {
    ensure (tokens > 0, DNA_BAD_ARGUMENT);
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
   132a0:	ebfff47a 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& semaphore_pool . lock);
   132a4:	e59f71d4 	ldr	r7, [pc, #468]	; 13480 <semaphore_release+0x214>
     * Look for the semaphore with ID id
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
   132a8:	e1a02204 	lsl	r2, r4, #4
  watch (status_t)
  {
    ensure (tokens > 0, DNA_BAD_ARGUMENT);
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
   132ac:	e58d0008 	str	r0, [sp, #8]
    lock_acquire (& semaphore_pool . lock);
   132b0:	e1a00007 	mov	r0, r7
     * Look for the semaphore with ID id
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
   132b4:	e58d2004 	str	r2, [sp, #4]
  {
    ensure (tokens > 0, DNA_BAD_ARGUMENT);
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& semaphore_pool . lock);
   132b8:	ebfff5c0 	bl	109c0 <lock_acquire>
     * Look for the semaphore with ID id
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
   132bc:	e59d2004 	ldr	r2, [sp, #4]
   132c0:	e0823004 	add	r3, r2, r4
   132c4:	e1a03103 	lsl	r3, r3, #2
   132c8:	e0872003 	add	r2, r7, r3
   132cc:	e592200c 	ldr	r2, [r2, #12]
   132d0:	e1560002 	cmp	r6, r2
   132d4:	0a000005 	beq	132f0 <semaphore_release+0x84>
    leave;
  }

  rescue (invalid_semaphore)
  {
    lock_release (& semaphore_pool . lock);
   132d8:	e1a00007 	mov	r0, r7
   132dc:	eb00006b 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   132e0:	e59d0008 	ldr	r0, [sp, #8]
   132e4:	ebfff4a2 	bl	10574 <cpu_trap_restore>
    leave;
   132e8:	e59f018c 	ldr	r0, [pc, #396]	; 1347c <semaphore_release+0x210>
   132ec:	eaffffe8 	b	13294 <semaphore_release+0x28>
  thread_t thread = NULL;
  semaphore_t sem = NULL;
  semaphore_id_t sid = { .raw = id };
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;
  bool smart_to_reschedule = false;
   132f0:	e3a08000 	mov	r8, #0
      cpu_dcache_invalidate((void*)&thread->info.sem_tokens, sizeof(uint32_t));
      if (thread -> info . sem_tokens <= tokens)
      {
       tokens -= thread -> info . sem_tokens;

        thread -> resource_queue = NULL;
   132f4:	e1a06008 	mov	r6, r8

dna_log(VERBOSE_LEVEL, "%d tokens on ID(%d:%d) TOKEN(%d)",
        tokens, sid . s . value,
        sid . s . index, sem -> info . tokens);

    lock_acquire (& sem -> lock);
   132f8:	e2833010 	add	r3, r3, #16
   132fc:	e0833007 	add	r3, r3, r7
   13300:	e1a00003 	mov	r0, r3
   13304:	e58d3010 	str	r3, [sp, #16]
   13308:	ebfff5ac 	bl	109c0 <lock_acquire>
    /*
     * Decide what to do according to the number
     * of tokens required by a potential waiting thread
     */

    lock_acquire (& sem -> waiting_queue . lock);
   1330c:	e59d3010 	ldr	r3, [sp, #16]
dna_log(VERBOSE_LEVEL, "%d tokens on ID(%d:%d) TOKEN(%d)",
        tokens, sid . s . value,
        sid . s . index, sem -> info . tokens);

    lock_acquire (& sem -> lock);
    lock_release (& semaphore_pool . lock);
   13310:	e1a00007 	mov	r0, r7
    /*
     * Decide what to do according to the number
     * of tokens required by a potential waiting thread
     */

    lock_acquire (& sem -> waiting_queue . lock);
   13314:	e2833004 	add	r3, r3, #4
   13318:	e58d300c 	str	r3, [sp, #12]
dna_log(VERBOSE_LEVEL, "%d tokens on ID(%d:%d) TOKEN(%d)",
        tokens, sid . s . value,
        sid . s . index, sem -> info . tokens);

    lock_acquire (& sem -> lock);
    lock_release (& semaphore_pool . lock);
   1331c:	eb00005b 	bl	13490 <lock_release>
    /*
     * Decide what to do according to the number
     * of tokens required by a potential waiting thread
     */

    lock_acquire (& sem -> waiting_queue . lock);
   13320:	e59d000c 	ldr	r0, [sp, #12]
   13324:	ebfff5a5 	bl	109c0 <lock_acquire>
        thread -> resource_queue = NULL;
        thread -> info . sem_tokens = 0;
        thread -> info . resource = DNA_NO_RESOURCE;
        thread -> info . resource_id = -1;

        thread -> info . status = DNA_THREAD_READY;
   13328:	e59da00c 	ldr	sl, [sp, #12]
   1332c:	e58d4014 	str	r4, [sp, #20]
    {
      /*
       * Check if a thread is available.
       */

      if ((thread = queue_rem (& sem -> waiting_queue)) == NULL)
   13330:	e1a0000a 	mov	r0, sl
   13334:	ebffefed 	bl	f2f0 <queue_rem>
   13338:	e2504000 	subs	r4, r0, #0
      }

      /*
       * Lock the thread and check its status.
       */
      lock_acquire (& thread -> lock);
   1333c:	e2849014 	add	r9, r4, #20
    {
      /*
       * Check if a thread is available.
       */

      if ((thread = queue_rem (& sem -> waiting_queue)) == NULL)
   13340:	0a00001c 	beq	133b8 <semaphore_release+0x14c>
      }

      /*
       * Lock the thread and check its status.
       */
      lock_acquire (& thread -> lock);
   13344:	e1a00009 	mov	r0, r9
   13348:	ebfff59c 	bl	109c0 <lock_acquire>

      cpu_dcache_invalidate((void*)(&thread->info.status),sizeof(uint32_t));    
   1334c:	e2840050 	add	r0, r4, #80	; 0x50
   13350:	e3a01004 	mov	r1, #4
   13354:	ebfff4b9 	bl	10640 <cpu_dcache_invalidate>
      check (invalid_thread_status,
   13358:	e1d425b0 	ldrh	r2, [r4, #80]	; 0x50
   1335c:	e59f3120 	ldr	r3, [pc, #288]	; 13484 <semaphore_release+0x218>
          DNA_ERROR);

      /*
       * Check the number of tokens it requests.
       */
      cpu_dcache_invalidate((void*)&thread->info.sem_tokens, sizeof(uint32_t));
   13360:	e284004c 	add	r0, r4, #76	; 0x4c
       * Lock the thread and check its status.
       */
      lock_acquire (& thread -> lock);

      cpu_dcache_invalidate((void*)(&thread->info.status),sizeof(uint32_t));    
      check (invalid_thread_status,
   13364:	e1520003 	cmp	r2, r3
   13368:	1a00002d 	bne	13424 <semaphore_release+0x1b8>
          DNA_ERROR);

      /*
       * Check the number of tokens it requests.
       */
      cpu_dcache_invalidate((void*)&thread->info.sem_tokens, sizeof(uint32_t));
   1336c:	e3a01004 	mov	r1, #4
   13370:	ebfff4b2 	bl	10640 <cpu_dcache_invalidate>
      if (thread -> info . sem_tokens <= tokens)
   13374:	e594204c 	ldr	r2, [r4, #76]	; 0x4c
   13378:	e152000b 	cmp	r2, fp
   1337c:	ca000032 	bgt	1344c <semaphore_release+0x1e0>
       tokens -= thread -> info . sem_tokens;

        thread -> resource_queue = NULL;
        thread -> info . sem_tokens = 0;
        thread -> info . resource = DNA_NO_RESOURCE;
        thread -> info . resource_id = -1;
   13380:	e3e03000 	mvn	r3, #0
   13384:	e5843054 	str	r3, [r4, #84]	; 0x54

        thread -> info . status = DNA_THREAD_READY;
   13388:	e59f30f8 	ldr	r3, [pc, #248]	; 13488 <semaphore_release+0x21c>
      cpu_dcache_invalidate((void*)&thread->info.sem_tokens, sizeof(uint32_t));
      if (thread -> info . sem_tokens <= tokens)
      {
       tokens -= thread -> info . sem_tokens;

        thread -> resource_queue = NULL;
   1338c:	e5846018 	str	r6, [r4, #24]
        thread -> info . sem_tokens = 0;
   13390:	e584604c 	str	r6, [r4, #76]	; 0x4c
        thread -> info . resource = DNA_NO_RESOURCE;
   13394:	e5c46052 	strb	r6, [r4, #82]	; 0x52
        thread -> info . resource_id = -1;

        thread -> info . status = DNA_THREAD_READY;
   13398:	e1c435b0 	strh	r3, [r4, #80]	; 0x50
        status = scheduler_dispatch (thread);
   1339c:	e1a00004 	mov	r0, r4
       * Check the number of tokens it requests.
       */
      cpu_dcache_invalidate((void*)&thread->info.sem_tokens, sizeof(uint32_t));
      if (thread -> info . sem_tokens <= tokens)
      {
       tokens -= thread -> info . sem_tokens;
   133a0:	e062b00b 	rsb	fp, r2, fp
        thread -> info . sem_tokens = 0;
        thread -> info . resource = DNA_NO_RESOURCE;
        thread -> info . resource_id = -1;

        thread -> info . status = DNA_THREAD_READY;
        status = scheduler_dispatch (thread);
   133a4:	ebfffcdf 	bl	12728 <scheduler_dispatch>

        smart_to_reschedule = smart_to_reschedule ||
   133a8:	e3500003 	cmp	r0, #3
   133ac:	03888001 	orreq	r8, r8, #1
     * of tokens required by a potential waiting thread
     */

    lock_acquire (& sem -> waiting_queue . lock);

    while (tokens != 0)
   133b0:	e35b0000 	cmp	fp, #0
   133b4:	1affffdd 	bne	13330 <semaphore_release+0xc4>
   133b8:	e59d4014 	ldr	r4, [sp, #20]

        break;
      }
    }

    lock_release (& sem -> waiting_queue . lock);
   133bc:	e59d000c 	ldr	r0, [sp, #12]
   133c0:	eb000032 	bl	13490 <lock_release>
    /*
     * Add the remaining number of token
     * and release the sem lock
     */
    {
    cpu_dcache_invalidate((void*)& sem -> info . tokens, sizeof(uint32_t));
   133c4:	e59d2004 	ldr	r2, [sp, #4]
   133c8:	e3a01004 	mov	r1, #4
   133cc:	e0824004 	add	r4, r2, r4
   133d0:	e1a04104 	lsl	r4, r4, #2
   133d4:	e0870004 	add	r0, r7, r4
   133d8:	e2800044 	add	r0, r0, #68	; 0x44
    sem -> info . tokens += tokens;
   133dc:	e0874004 	add	r4, r7, r4
    /*
     * Add the remaining number of token
     * and release the sem lock
     */
    {
    cpu_dcache_invalidate((void*)& sem -> info . tokens, sizeof(uint32_t));
   133e0:	ebfff496 	bl	10640 <cpu_dcache_invalidate>
    sem -> info . tokens += tokens;
   133e4:	e5943044 	ldr	r3, [r4, #68]	; 0x44
    }

    lock_release (& sem -> lock);
   133e8:	e59d0010 	ldr	r0, [sp, #16]
     * Add the remaining number of token
     * and release the sem lock
     */
    {
    cpu_dcache_invalidate((void*)& sem -> info . tokens, sizeof(uint32_t));
    sem -> info . tokens += tokens;
   133ec:	e083c00b 	add	ip, r3, fp
   133f0:	e584c044 	str	ip, [r4, #68]	; 0x44
    }

    lock_release (& sem -> lock);
   133f4:	eb000025 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   133f8:	e59d0008 	ldr	r0, [sp, #8]
   133fc:	ebfff45c 	bl	10574 <cpu_trap_restore>

    /*
     * Now we deal with the reschedule
     */

    if ((flags & DNA_NO_RESCHEDULE) == 0 && smart_to_reschedule)
   13400:	e2155001 	ands	r5, r5, #1
    {
      thread_yield ();
    }

    return DNA_OK;
   13404:	13a00000 	movne	r0, #0

    /*
     * Now we deal with the reschedule
     */

    if ((flags & DNA_NO_RESCHEDULE) == 0 && smart_to_reschedule)
   13408:	1affffa1 	bne	13294 <semaphore_release+0x28>
   1340c:	e3580000 	cmp	r8, #0
    {
      thread_yield ();
    }

    return DNA_OK;
   13410:	01a00008 	moveq	r0, r8

    /*
     * Now we deal with the reschedule
     */

    if ((flags & DNA_NO_RESCHEDULE) == 0 && smart_to_reschedule)
   13414:	0affff9e 	beq	13294 <semaphore_release+0x28>
    {
      thread_yield ();
   13418:	ebfff697 	bl	10e7c <thread_yield>
    }

    return DNA_OK;
   1341c:	e1a00005 	mov	r0, r5
   13420:	eaffff9b 	b	13294 <semaphore_release+0x28>
  }

  rescue (invalid_thread_status)
  {
    lock_release (& thread -> lock);
   13424:	e1a00009 	mov	r0, r9
   13428:	eb000018 	bl	13490 <lock_release>
    lock_release (& sem -> waiting_queue . lock);
   1342c:	e59d000c 	ldr	r0, [sp, #12]
   13430:	eb000016 	bl	13490 <lock_release>
    lock_release (& sem -> lock);
   13434:	e59d0010 	ldr	r0, [sp, #16]
   13438:	eb000014 	bl	13490 <lock_release>

    cpu_trap_restore(it_status);
   1343c:	e59d0008 	ldr	r0, [sp, #8]
   13440:	ebfff44b 	bl	10574 <cpu_trap_restore>
    leave;
   13444:	e59f0040 	ldr	r0, [pc, #64]	; 1348c <semaphore_release+0x220>
   13448:	eaffff91 	b	13294 <semaphore_release+0x28>
   1344c:	e1a0a004 	mov	sl, r4
        smart_to_reschedule = smart_to_reschedule ||
          (status == DNA_INVOKE_SCHEDULER);
      }
      else
      {
        thread -> info . sem_tokens -= tokens;
   13450:	e06b2002 	rsb	r2, fp, r2
   13454:	e58a204c 	str	r2, [sl, #76]	; 0x4c
        lock_release (& thread -> lock);
   13458:	e1a00009 	mov	r0, r9
   1345c:	e59d4014 	ldr	r4, [sp, #20]
   13460:	eb00000a 	bl	13490 <lock_release>

        tokens = 0;
        queue_pushback (& sem -> waiting_queue, thread);
   13464:	e59d000c 	ldr	r0, [sp, #12]
   13468:	e1a0100a 	mov	r1, sl
   1346c:	ebfff35f 	bl	101f0 <queue_pushback>
      else
      {
        thread -> info . sem_tokens -= tokens;
        lock_release (& thread -> lock);

        tokens = 0;
   13470:	e3a0b000 	mov	fp, #0
        queue_pushback (& sem -> waiting_queue, thread);

        break;
   13474:	eaffffd0 	b	133bc <semaphore_release+0x150>
   13478:	0000fffc 	.word	0x0000fffc
   1347c:	0000fdff 	.word	0x0000fdff
   13480:	0013f5a0 	.word	0x0013f5a0
   13484:	0000b10c 	.word	0x0000b10c
   13488:	ffffface 	.word	0xffffface
   1348c:	0000ffff 	.word	0x0000ffff

00013490 <lock_release>:
 *
 * SOURCE
 */

{
  *lock = 0;
   13490:	e3a03000 	mov	r3, #0
 * Set the lock value to 0.
 *
 * SOURCE
 */

{
   13494:	e24dd008 	sub	sp, sp, #8
  *lock = 0;
   13498:	e5803000 	str	r3, [r0]
  cpu_cache_sync ();
   1349c:	e58d3004 	str	r3, [sp, #4]
   134a0:	e59d3004 	ldr	r3, [sp, #4]
   134a4:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
}
   134a8:	e28dd008 	add	sp, sp, #8
   134ac:	e12fff1e 	bx	lr

000134b0 <interrupt_attach>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   134b0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  queue_t * queue = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (id < CPU_TRAP_COUNT, DNA_BAD_ARGUMENT);
   134b4:	e351001f 	cmp	r1, #31
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   134b8:	e24dd014 	sub	sp, sp, #20
   134bc:	e1a04001 	mov	r4, r1
   134c0:	e5dd7038 	ldrb	r7, [sp, #56]	; 0x38
  queue_t * queue = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (id < CPU_TRAP_COUNT, DNA_BAD_ARGUMENT);
   134c4:	9a000002 	bls	134d4 <interrupt_attach+0x24>
   134c8:	e59f017c 	ldr	r0, [pc, #380]	; 1364c <interrupt_attach+0x19c>
    cpu_trap_restore(it_status);

    kernel_free (isr);
    leave;
  }
}
   134cc:	e28dd014 	add	sp, sp, #20
   134d0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   134d4:	e1a05000 	mov	r5, r0
   134d8:	e1a08002 	mov	r8, r2
   134dc:	e1a06003 	mov	r6, r3
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (id < CPU_TRAP_COUNT, DNA_BAD_ARGUMENT);
    ensure (cpuid < cpu_mp_count (), DNA_BAD_ARGUMENT);
   134e0:	ebfff473 	bl	106b4 <cpu_mp_count>
   134e4:	e1500005 	cmp	r0, r5
   134e8:	dafffff6 	ble	134c8 <interrupt_attach+0x18>

    /*
     * Create the new ISR
     */

    isr = kernel_malloc (sizeof (struct _isr), true);
   134ec:	e3a00008 	mov	r0, #8
   134f0:	e3a01001 	mov	r1, #1
   134f4:	eb0002e5 	bl	14090 <kernel_malloc>
    ensure (isr != NULL, DNA_OUT_OF_MEM);
   134f8:	e250a000 	subs	sl, r0, #0
   134fc:	059f014c 	ldreq	r0, [pc, #332]	; 13650 <interrupt_attach+0x1a0>
   13500:	0afffff1 	beq	134cc <interrupt_attach+0x1c>
    /*
     * Add the new ISR in the appropriate queue
     */

    it_status = cpu_trap_mask_and_backup();
    queue = & cpu_pool . cpu[cpuid] . isr[id];
   13504:	e1a03185 	lsl	r3, r5, #3
     */

    isr = kernel_malloc (sizeof (struct _isr), true);
    ensure (isr != NULL, DNA_OUT_OF_MEM);

    isr -> handler = handler;
   13508:	e58a6004 	str	r6, [sl, #4]
    /*
     * Add the new ISR in the appropriate queue
     */

    it_status = cpu_trap_mask_and_backup();
    queue = & cpu_pool . cpu[cpuid] . isr[id];
   1350c:	e58d3008 	str	r3, [sp, #8]

    /*
     * Add the new ISR in the appropriate queue
     */

    it_status = cpu_trap_mask_and_backup();
   13510:	ebfff3de 	bl	10490 <cpu_trap_mask_and_backup>
    queue = & cpu_pool . cpu[cpuid] . isr[id];
   13514:	e59d3008 	ldr	r3, [sp, #8]
   13518:	e59fb134 	ldr	fp, [pc, #308]	; 13654 <interrupt_attach+0x1a4>
   1351c:	e0832005 	add	r2, r3, r5
   13520:	e0842102 	add	r2, r4, r2, lsl #2
   13524:	e1a09202 	lsl	r9, r2, #4
   13528:	e2899028 	add	r9, r9, #40	; 0x28
   1352c:	e08b9009 	add	r9, fp, r9

    /*
     * Add the new ISR in the appropriate queue
     */

    it_status = cpu_trap_mask_and_backup();
   13530:	e58d000c 	str	r0, [sp, #12]
    queue = & cpu_pool . cpu[cpuid] . isr[id];

    lock_acquire (& queue -> lock);
   13534:	e1a00009 	mov	r0, r9
   13538:	e58d2004 	str	r2, [sp, #4]
   1353c:	ebfff51f 	bl	109c0 <lock_acquire>
    queue_add (queue, isr);
   13540:	e1a00009 	mov	r0, r9
   13544:	e1a0100a 	mov	r1, sl
   13548:	ebfff231 	bl	fe14 <queue_add>

    check (not_alone, ! bypass_demux ||
   1354c:	e3570000 	cmp	r7, #0
   13550:	e59d2004 	ldr	r2, [sp, #4]
   13554:	0a00000f 	beq	13598 <interrupt_attach+0xe8>
   13558:	e2822003 	add	r2, r2, #3
   1355c:	e08b2202 	add	r2, fp, r2, lsl #4
   13560:	e5922004 	ldr	r2, [r2, #4]
   13564:	e3520001 	cmp	r2, #1
   13568:	0a000027 	beq	1360c <interrupt_attach+0x15c>
    return DNA_OK;
  }

  rescue (not_alone)
  {
    queue_extract (queue, isr);
   1356c:	e1a0100a 	mov	r1, sl
   13570:	e1a00009 	mov	r0, r9
   13574:	ebffef1b 	bl	f1e8 <queue_extract>
    lock_release (& queue -> lock);
   13578:	e1a00009 	mov	r0, r9
   1357c:	ebffffc3 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   13580:	e59d000c 	ldr	r0, [sp, #12]
   13584:	ebfff3fa 	bl	10574 <cpu_trap_restore>

    kernel_free (isr);
   13588:	e1a0000a 	mov	r0, sl
   1358c:	eb0002f4 	bl	14164 <kernel_free>
    leave;
   13590:	e59f00c0 	ldr	r0, [pc, #192]	; 13658 <interrupt_attach+0x1a8>
   13594:	eaffffcc 	b	134cc <interrupt_attach+0x1c>
    queue_add (queue, isr);

    check (not_alone, ! bypass_demux ||
        (bypass_demux && queue -> status == 1), DNA_ERROR);

    if (queue -> status == 1)
   13598:	e2823003 	add	r3, r2, #3
   1359c:	e08b3203 	add	r3, fp, r3, lsl #4
   135a0:	e5933004 	ldr	r3, [r3, #4]
   135a4:	e3530001 	cmp	r3, #1
   135a8:	0a000005 	beq	135c4 <interrupt_attach+0x114>
        lock_acquire (& cpu_pool . cpu[cpuid] . ipi_lock);
        cpu_mp_send_ipi (cpuid, DNA_IPI_TRAP_ENABLE, (void *) id);
      }
    }

    lock_release (& queue -> lock);
   135ac:	e1a00009 	mov	r0, r9
   135b0:	ebffffb6 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   135b4:	e59d000c 	ldr	r0, [sp, #12]
   135b8:	ebfff3ed 	bl	10574 <cpu_trap_restore>

    return DNA_OK;
   135bc:	e3a00000 	mov	r0, #0
   135c0:	eaffffc1 	b	134cc <interrupt_attach+0x1c>
      {
        cpu_trap_attach_isr (cpuid, id, mode, handler);
      }
      else
      {
        cpu_trap_attach_isr (cpuid, id, mode, interrupt_demultiplexer);
   135c4:	e1a02008 	mov	r2, r8
   135c8:	e1a00005 	mov	r0, r5
   135cc:	e1a01004 	mov	r1, r4
   135d0:	e59f3084 	ldr	r3, [pc, #132]	; 1365c <interrupt_attach+0x1ac>
   135d4:	ebfff405 	bl	105f0 <cpu_trap_attach_isr>
      }

      if (cpuid == cpu_mp_id ())
   135d8:	ebfff402 	bl	105e8 <cpu_mp_id>
   135dc:	e1500005 	cmp	r0, r5
   135e0:	0a000016 	beq	13640 <interrupt_attach+0x190>
      {
        cpu_trap_enable (id);
      }
      else
      {
        lock_acquire (& cpu_pool . cpu[cpuid] . ipi_lock);
   135e4:	e59d3008 	ldr	r3, [sp, #8]
   135e8:	e0830005 	add	r0, r3, r5
   135ec:	e08b0300 	add	r0, fp, r0, lsl #6
   135f0:	e2800018 	add	r0, r0, #24
   135f4:	ebfff4f1 	bl	109c0 <lock_acquire>
        cpu_mp_send_ipi (cpuid, DNA_IPI_TRAP_ENABLE, (void *) id);
   135f8:	e1a00005 	mov	r0, r5
   135fc:	e1a02004 	mov	r2, r4
   13600:	e59f1048 	ldr	r1, [pc, #72]	; 13650 <interrupt_attach+0x1a0>
   13604:	ebfff3b3 	bl	104d8 <cpu_mp_send_ipi>
   13608:	eaffffe7 	b	135ac <interrupt_attach+0xfc>
    queue_add (queue, isr);

    check (not_alone, ! bypass_demux ||
        (bypass_demux && queue -> status == 1), DNA_ERROR);

    if (queue -> status == 1)
   1360c:	e3a03024 	mov	r3, #36	; 0x24
   13610:	e0234593 	mla	r3, r3, r5, r4
   13614:	e2833003 	add	r3, r3, #3
   13618:	e08b3203 	add	r3, fp, r3, lsl #4
   1361c:	e5933004 	ldr	r3, [r3, #4]
   13620:	e3530001 	cmp	r3, #1
   13624:	1affffe0 	bne	135ac <interrupt_attach+0xfc>
    {
      if (bypass_demux)
      {
        cpu_trap_attach_isr (cpuid, id, mode, handler);
   13628:	e1a02008 	mov	r2, r8
   1362c:	e1a03006 	mov	r3, r6
   13630:	e1a00005 	mov	r0, r5
   13634:	e1a01004 	mov	r1, r4
   13638:	ebfff3ec 	bl	105f0 <cpu_trap_attach_isr>
   1363c:	eaffffe5 	b	135d8 <interrupt_attach+0x128>
        cpu_trap_attach_isr (cpuid, id, mode, interrupt_demultiplexer);
      }

      if (cpuid == cpu_mp_id ())
      {
        cpu_trap_enable (id);
   13640:	e1a00004 	mov	r0, r4
   13644:	ebfff3be 	bl	10544 <cpu_trap_enable>
   13648:	eaffffd7 	b	135ac <interrupt_attach+0xfc>
   1364c:	0000fffc 	.word	0x0000fffc
   13650:	0000fffd 	.word	0x0000fffd
   13654:	001883e8 	.word	0x001883e8
   13658:	0000ffff 	.word	0x0000ffff
   1365c:	00012a00 	.word	0x00012a00

00013660 <port_close>:
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
   13660:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  port_id_t pid = { .raw = id };
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
   13664:	e1a05820 	lsr	r5, r0, #16
   13668:	e355003f 	cmp	r5, #63	; 0x3f
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
   1366c:	e1a04000 	mov	r4, r0
  port_id_t pid = { .raw = id };
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
   13670:	9a000001 	bls	1367c <port_close+0x1c>
   13674:	e59f007c 	ldr	r0, [pc, #124]	; 136f8 <port_close+0x98>
  {
    lock_release (& port_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
   13678:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup();
   1367c:	ebfff383 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& port_pool . lock);
   13680:	e59f6074 	ldr	r6, [pc, #116]	; 136fc <port_close+0x9c>

    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup();
   13684:	e1a08000 	mov	r8, r0
    lock_acquire (& port_pool . lock);
   13688:	e1a00006 	mov	r0, r6
   1368c:	ebfff4cb 	bl	109c0 <lock_acquire>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   13690:	e3a03068 	mov	r3, #104	; 0x68
   13694:	e0050593 	mul	r5, r3, r5
   13698:	e0867005 	add	r7, r6, r5
   1369c:	e597300c 	ldr	r3, [r7, #12]
   136a0:	e1540003 	cmp	r4, r3
   136a4:	0a000005 	beq	136c0 <port_close+0x60>
    return DNA_OK;
  }

  rescue (bad_portid)
  {
    lock_release (& port_pool . lock);
   136a8:	e1a00006 	mov	r0, r6
   136ac:	ebffff77 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   136b0:	e1a00008 	mov	r0, r8
   136b4:	ebfff3ae 	bl	10574 <cpu_trap_restore>
    leave;
   136b8:	e59f0038 	ldr	r0, [pc, #56]	; 136f8 <port_close+0x98>
   136bc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    lock_acquire (& port -> lock);
   136c0:	e2855010 	add	r5, r5, #16
   136c4:	e0855006 	add	r5, r5, r6
   136c8:	e1a00005 	mov	r0, r5
   136cc:	ebfff4bb 	bl	109c0 <lock_acquire>
    lock_release (& port_pool . lock);
   136d0:	e1a00006 	mov	r0, r6
   136d4:	ebffff6d 	bl	13490 <lock_release>

    /*
     * Close the port and return.
     */

    port -> closed = true;
   136d8:	e3a03001 	mov	r3, #1

    lock_release (& port -> lock);
   136dc:	e1a00005 	mov	r0, r5

    /*
     * Close the port and return.
     */

    port -> closed = true;
   136e0:	e5c73014 	strb	r3, [r7, #20]

    lock_release (& port -> lock);
   136e4:	ebffff69 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   136e8:	e1a00008 	mov	r0, r8
   136ec:	ebfff3a0 	bl	10574 <cpu_trap_restore>

    return DNA_OK;
   136f0:	e3a00000 	mov	r0, #0
   136f4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
   136f8:	0000faff 	.word	0x0000faff
   136fc:	001835b8 	.word	0x001835b8

00013700 <interrupt_detach>:
 * * DNA_OK: the operation is successful
 *
 * SOURCE
 */

{
   13700:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  queue_t * queue = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (id < CPU_TRAP_COUNT, DNA_BAD_ARGUMENT);
   13704:	e351001f 	cmp	r1, #31
 * * DNA_OK: the operation is successful
 *
 * SOURCE
 */

{
   13708:	e24dd00c 	sub	sp, sp, #12
   1370c:	e1a04001 	mov	r4, r1
  queue_t * queue = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (id < CPU_TRAP_COUNT, DNA_BAD_ARGUMENT);
   13710:	9a000002 	bls	13720 <interrupt_detach+0x20>

  rescue (no_isr)
  {
    lock_release (& queue -> lock);
    cpu_trap_restore(it_status);
    leave;
   13714:	e59f00e0 	ldr	r0, [pc, #224]	; 137fc <interrupt_detach+0xfc>
  }
}
   13718:	e28dd00c 	add	sp, sp, #12
   1371c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
   13720:	e1a05000 	mov	r5, r0
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (id < CPU_TRAP_COUNT, DNA_BAD_ARGUMENT);
    ensure (cpuid < cpu_mp_count (), DNA_BAD_ARGUMENT);
   13724:	e58d2004 	str	r2, [sp, #4]
   13728:	ebfff3e1 	bl	106b4 <cpu_mp_count>
   1372c:	e1500005 	cmp	r0, r5
   13730:	dafffff7 	ble	13714 <interrupt_detach+0x14>

    /*
     * Remove the ISR from the appropriate queue.
     */

    it_status = cpu_trap_mask_and_backup();
   13734:	ebfff355 	bl	10490 <cpu_trap_mask_and_backup>
    queue = & cpu_pool . cpu[cpuid] . isr[id];
   13738:	e0859185 	add	r9, r5, r5, lsl #3
   1373c:	e0848109 	add	r8, r4, r9, lsl #2
   13740:	e1a06208 	lsl	r6, r8, #4
   13744:	e59f70b4 	ldr	r7, [pc, #180]	; 13800 <interrupt_detach+0x100>
   13748:	e2866028 	add	r6, r6, #40	; 0x28
   1374c:	e0866007 	add	r6, r6, r7

    /*
     * Remove the ISR from the appropriate queue.
     */

    it_status = cpu_trap_mask_and_backup();
   13750:	e1a0a000 	mov	sl, r0
    queue = & cpu_pool . cpu[cpuid] . isr[id];
    lock_acquire (& queue -> lock);
   13754:	e1a00006 	mov	r0, r6
   13758:	ebfff498 	bl	109c0 <lock_acquire>

    isr = queue_lookup (queue, interrupt_handler_inspector, handler);
   1375c:	e1a00006 	mov	r0, r6
   13760:	e59d2004 	ldr	r2, [sp, #4]
   13764:	e59f1098 	ldr	r1, [pc, #152]	; 13804 <interrupt_detach+0x104>
   13768:	ebfff1e0 	bl	fef0 <queue_lookup>
    check (no_isr, isr != NULL, DNA_BAD_ARGUMENT);
   1376c:	e250b000 	subs	fp, r0, #0
    return DNA_OK;
  }

  rescue (no_isr)
  {
    lock_release (& queue -> lock);
   13770:	e1a00006 	mov	r0, r6
    it_status = cpu_trap_mask_and_backup();
    queue = & cpu_pool . cpu[cpuid] . isr[id];
    lock_acquire (& queue -> lock);

    isr = queue_lookup (queue, interrupt_handler_inspector, handler);
    check (no_isr, isr != NULL, DNA_BAD_ARGUMENT);
   13774:	0a00000e 	beq	137b4 <interrupt_detach+0xb4>
    /*
     * If there is no more handler for the specified
     * interrupt, disable it.
     */

    if (queue -> status == 0)
   13778:	e2888003 	add	r8, r8, #3
    lock_acquire (& queue -> lock);

    isr = queue_lookup (queue, interrupt_handler_inspector, handler);
    check (no_isr, isr != NULL, DNA_BAD_ARGUMENT);

    queue_extract (queue, isr);
   1377c:	e1a0100b 	mov	r1, fp
    /*
     * If there is no more handler for the specified
     * interrupt, disable it.
     */

    if (queue -> status == 0)
   13780:	e0878208 	add	r8, r7, r8, lsl #4
    lock_acquire (& queue -> lock);

    isr = queue_lookup (queue, interrupt_handler_inspector, handler);
    check (no_isr, isr != NULL, DNA_BAD_ARGUMENT);

    queue_extract (queue, isr);
   13784:	ebffee97 	bl	f1e8 <queue_extract>
    /*
     * If there is no more handler for the specified
     * interrupt, disable it.
     */

    if (queue -> status == 0)
   13788:	e5983004 	ldr	r3, [r8, #4]
   1378c:	e3530000 	cmp	r3, #0
   13790:	0a00000b 	beq	137c4 <interrupt_detach+0xc4>
        lock_acquire (& cpu_pool . cpu[cpuid] . ipi_lock);
        cpu_mp_send_ipi (cpuid, DNA_IPI_TRAP_DISABLE, (void *) id);
      }
    }

    lock_release (& queue -> lock);
   13794:	e1a00006 	mov	r0, r6
   13798:	ebffff3c 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   1379c:	e1a0000a 	mov	r0, sl
   137a0:	ebfff373 	bl	10574 <cpu_trap_restore>

    kernel_free (isr);
   137a4:	e1a0000b 	mov	r0, fp
   137a8:	eb00026d 	bl	14164 <kernel_free>
    return DNA_OK;
   137ac:	e3a00000 	mov	r0, #0
   137b0:	eaffffd8 	b	13718 <interrupt_detach+0x18>
  }

  rescue (no_isr)
  {
    lock_release (& queue -> lock);
   137b4:	ebffff35 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   137b8:	e1a0000a 	mov	r0, sl
   137bc:	ebfff36c 	bl	10574 <cpu_trap_restore>
   137c0:	eaffffd3 	b	13714 <interrupt_detach+0x14>
     * interrupt, disable it.
     */

    if (queue -> status == 0)
    {
      if (cpuid == cpu_mp_id ())
   137c4:	ebfff387 	bl	105e8 <cpu_mp_id>
   137c8:	e1500005 	cmp	r0, r5
   137cc:	0a000007 	beq	137f0 <interrupt_detach+0xf0>
      {
        cpu_trap_disable (id);
      }
      else
      {
        lock_acquire (& cpu_pool . cpu[cpuid] . ipi_lock);
   137d0:	e0870309 	add	r0, r7, r9, lsl #6
   137d4:	e2800018 	add	r0, r0, #24
   137d8:	ebfff478 	bl	109c0 <lock_acquire>
        cpu_mp_send_ipi (cpuid, DNA_IPI_TRAP_DISABLE, (void *) id);
   137dc:	e1a00005 	mov	r0, r5
   137e0:	e1a02004 	mov	r2, r4
   137e4:	e59f1010 	ldr	r1, [pc, #16]	; 137fc <interrupt_detach+0xfc>
   137e8:	ebfff33a 	bl	104d8 <cpu_mp_send_ipi>
   137ec:	eaffffe8 	b	13794 <interrupt_detach+0x94>

    if (queue -> status == 0)
    {
      if (cpuid == cpu_mp_id ())
      {
        cpu_trap_disable (id);
   137f0:	e1a00004 	mov	r0, r4
   137f4:	ebfff32b 	bl	104a8 <cpu_trap_disable>
   137f8:	eaffffe5 	b	13794 <interrupt_detach+0x94>
   137fc:	0000fffc 	.word	0x0000fffc
   13800:	001883e8 	.word	0x001883e8
   13804:	00010b88 	.word	0x00010b88

00013808 <port_create>:
  status_t status;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (name != NULL && p_id != NULL, DNA_BAD_ARGUMENT);
   13808:	e3520000 	cmp	r2, #0
   1380c:	13500000 	cmpne	r0, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   13810:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  status_t status;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (name != NULL && p_id != NULL, DNA_BAD_ARGUMENT);
   13814:	e1a05000 	mov	r5, r0
   13818:	e1a06002 	mov	r6, r2
   1381c:	03a04001 	moveq	r4, #1
   13820:	13a04000 	movne	r4, #0
   13824:	1a000001 	bne	13830 <port_create+0x28>
   13828:	e59f0154 	ldr	r0, [pc, #340]	; 13984 <port_create+0x17c>
   1382c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ensure (queue_length > 0, DNA_BAD_ARGUMENT);
   13830:	e3510000 	cmp	r1, #0
   13834:	e1a07001 	mov	r7, r1
   13838:	dafffffa 	ble	13828 <port_create+0x20>

    it_status = cpu_trap_mask_and_backup();
   1383c:	ebfff313 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& port_pool . lock);
   13840:	e59f9140 	ldr	r9, [pc, #320]	; 13988 <port_create+0x180>
  watch (status_t)
  {
    ensure (name != NULL && p_id != NULL, DNA_BAD_ARGUMENT);
    ensure (queue_length > 0, DNA_BAD_ARGUMENT);

    it_status = cpu_trap_mask_and_backup();
   13844:	e1a0a000 	mov	sl, r0
    lock_acquire (& port_pool . lock);
   13848:	e1a00009 	mov	r0, r9
   1384c:	ebfff45b 	bl	109c0 <lock_acquire>

    /*
     * Get an empty port slot.
     */

    port = queue_rem (& port_pool . port);
   13850:	e59f0134 	ldr	r0, [pc, #308]	; 1398c <port_create+0x184>
   13854:	ebffeea5 	bl	f2f0 <queue_rem>
    check (pool_error, port != NULL, DNA_NO_MORE_PORT);
   13858:	e2508000 	subs	r8, r0, #0
   1385c:	0a000044 	beq	13974 <port_create+0x16c>
    /*
     * Make the place clean.
     */

    index = port -> id . s . index;
    dna_memset (port, 0, sizeof (struct _port));
   13860:	e1a01004 	mov	r1, r4
   13864:	e3a02068 	mov	r2, #104	; 0x68

    /*
     * Make the place clean.
     */

    index = port -> id . s . index;
   13868:	e1d8b0b6 	ldrh	fp, [r8, #6]
    dna_memset (port, 0, sizeof (struct _port));
   1386c:	ebffef00 	bl	f474 <dna_memset>

    port -> id . s . index = index;
    port -> id . s . value = port_pool . counter;
   13870:	e1d920b4 	ldrh	r2, [r9, #4]

    semaphore_pool . counter += 1;
   13874:	e59f3114 	ldr	r3, [pc, #276]	; 13990 <port_create+0x188>

    index = port -> id . s . index;
    dna_memset (port, 0, sizeof (struct _port));

    port -> id . s . index = index;
    port -> id . s . value = port_pool . counter;
   13878:	e1c820b4 	strh	r2, [r8, #4]

    semaphore_pool . counter += 1;
   1387c:	e1d320b4 	ldrh	r2, [r3, #4]

    lock_release (& port_pool . lock);
   13880:	e1a00009 	mov	r0, r9
    dna_memset (port, 0, sizeof (struct _port));

    port -> id . s . index = index;
    port -> id . s . value = port_pool . counter;

    semaphore_pool . counter += 1;
   13884:	e2822001 	add	r2, r2, #1
     */

    index = port -> id . s . index;
    dna_memset (port, 0, sizeof (struct _port));

    port -> id . s . index = index;
   13888:	e1c8b0b6 	strh	fp, [r8, #6]
    port -> id . s . value = port_pool . counter;

    semaphore_pool . counter += 1;
   1388c:	e1c320b4 	strh	r2, [r3, #4]

    lock_release (& port_pool . lock);
   13890:	ebfffefe 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   13894:	e1a0000a 	mov	r0, sl
   13898:	ebfff335 	bl	10574 <cpu_trap_restore>
    /*
     * Creating the messages.
     */

    port -> data = kernel_malloc
      (sizeof (struct _message) * queue_length, true);
   1389c:	e3a01001 	mov	r1, #1
   138a0:	e1a00207 	lsl	r0, r7, #4
   138a4:	eb0001f9 	bl	14090 <kernel_malloc>
    check (no_mem, port -> data != NULL, DNA_OUT_OF_MEM);
   138a8:	e3500000 	cmp	r0, #0

    /*
     * Creating the messages.
     */

    port -> data = kernel_malloc
   138ac:	e5880044 	str	r0, [r8, #68]	; 0x44
      (sizeof (struct _message) * queue_length, true);
    check (no_mem, port -> data != NULL, DNA_OUT_OF_MEM);
   138b0:	11a01000 	movne	r1, r0
   138b4:	12889048 	addne	r9, r8, #72	; 0x48
   138b8:	1a000001 	bne	138c4 <port_create+0xbc>
   138bc:	ea00002e 	b	1397c <port_create+0x174>
   138c0:	e5981044 	ldr	r1, [r8, #68]	; 0x44

    for (int32_t i = 0; i < queue_length; i += 1)
    {
      queue_add (& port -> message, & port -> data[i]);
   138c4:	e0811204 	add	r1, r1, r4, lsl #4
   138c8:	e1a00009 	mov	r0, r9

    port -> data = kernel_malloc
      (sizeof (struct _message) * queue_length, true);
    check (no_mem, port -> data != NULL, DNA_OUT_OF_MEM);

    for (int32_t i = 0; i < queue_length; i += 1)
   138cc:	e2844001 	add	r4, r4, #1
    {
      queue_add (& port -> message, & port -> data[i]);
   138d0:	ebfff14f 	bl	fe14 <queue_add>

    port -> data = kernel_malloc
      (sizeof (struct _message) * queue_length, true);
    check (no_mem, port -> data != NULL, DNA_OUT_OF_MEM);

    for (int32_t i = 0; i < queue_length; i += 1)
   138d4:	e1540007 	cmp	r4, r7
   138d8:	1afffff8 	bne	138c0 <port_create+0xb8>

    /*
     * Creating the semaphores.
     */

    status = semaphore_create (name, queue_length, & port -> write_sem);
   138dc:	e1a00005 	mov	r0, r5
   138e0:	e1a01004 	mov	r1, r4
   138e4:	e2882040 	add	r2, r8, #64	; 0x40
   138e8:	ebfffdbc 	bl	12fe0 <semaphore_create>
    check (wsem_error, status == DNA_OK, status);
   138ec:	e2507000 	subs	r7, r0, #0
   138f0:	0a00000e 	beq	13930 <port_create+0x128>
    semaphore_destroy (port -> write_sem);
  }

  rescue (wsem_error)
  {
    kernel_free (port -> data);
   138f4:	e5980044 	ldr	r0, [r8, #68]	; 0x44
   138f8:	eb000219 	bl	14164 <kernel_free>
  }

  rescue (no_mem)
  {
    it_status = cpu_trap_mask_and_backup();
   138fc:	ebfff2e3 	bl	10490 <cpu_trap_mask_and_backup>
   13900:	e1a0a000 	mov	sl, r0
    lock_acquire (& port_pool . lock);
   13904:	e59f007c 	ldr	r0, [pc, #124]	; 13988 <port_create+0x180>
   13908:	ebfff42c 	bl	109c0 <lock_acquire>

    queue_add (& port_pool . port, port);
   1390c:	e1a01008 	mov	r1, r8
   13910:	e59f0074 	ldr	r0, [pc, #116]	; 1398c <port_create+0x184>
   13914:	ebfff13e 	bl	fe14 <queue_add>
  }

  rescue (pool_error)
  {
    lock_release (& port_pool . lock);
   13918:	e59f0068 	ldr	r0, [pc, #104]	; 13988 <port_create+0x180>
   1391c:	ebfffedb 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   13920:	e1a0000a 	mov	r0, sl
   13924:	ebfff312 	bl	10574 <cpu_trap_restore>
    leave;
   13928:	e1a00007 	mov	r0, r7
   1392c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
     */

    status = semaphore_create (name, queue_length, & port -> write_sem);
    check (wsem_error, status == DNA_OK, status);

    status = semaphore_create (name, 0, & port -> read_sem);
   13930:	e1a01007 	mov	r1, r7
   13934:	e1a00005 	mov	r0, r5
   13938:	e288203c 	add	r2, r8, #60	; 0x3c
   1393c:	ebfffda7 	bl	12fe0 <semaphore_create>
    check (rsem_error, status == DNA_OK, status);
   13940:	e2507000 	subs	r7, r0, #0
   13944:	0a000002 	beq	13954 <port_create+0x14c>
    return DNA_OK;
  }

  rescue (rsem_error)
  {
    semaphore_destroy (port -> write_sem);
   13948:	e5980040 	ldr	r0, [r8, #64]	; 0x40
   1394c:	ebfff497 	bl	10bb0 <semaphore_destroy>
   13950:	eaffffe7 	b	138f4 <port_create+0xec>
    check (wsem_error, status == DNA_OK, status);

    status = semaphore_create (name, 0, & port -> read_sem);
    check (rsem_error, status == DNA_OK, status);

    dna_strcpy (port -> info . name, name);
   13954:	e1a01005 	mov	r1, r5
   13958:	e2880010 	add	r0, r8, #16
   1395c:	ebfff1c5 	bl	10078 <dna_strcpy>

    /*
     * Return the port information.
     */

    *p_id = port -> id . raw;
   13960:	e5983004 	ldr	r3, [r8, #4]

    status = semaphore_create (name, 0, & port -> read_sem);
    check (rsem_error, status == DNA_OK, status);

    dna_strcpy (port -> info . name, name);
    port -> info . capacity = queue_length;
   13964:	e5884030 	str	r4, [r8, #48]	; 0x30
    /*
     * Return the port information.
     */

    *p_id = port -> id . raw;
    return DNA_OK;
   13968:	e1a00007 	mov	r0, r7

    /*
     * Return the port information.
     */

    *p_id = port -> id . raw;
   1396c:	e5863000 	str	r3, [r6]
    return DNA_OK;
   13970:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    /*
     * Get an empty port slot.
     */

    port = queue_rem (& port_pool . port);
    check (pool_error, port != NULL, DNA_NO_MORE_PORT);
   13974:	e59f7018 	ldr	r7, [pc, #24]	; 13994 <port_create+0x18c>
   13978:	eaffffe6 	b	13918 <port_create+0x110>
     * Creating the messages.
     */

    port -> data = kernel_malloc
      (sizeof (struct _message) * queue_length, true);
    check (no_mem, port -> data != NULL, DNA_OUT_OF_MEM);
   1397c:	e59f7014 	ldr	r7, [pc, #20]	; 13998 <port_create+0x190>
   13980:	eaffffdd 	b	138fc <port_create+0xf4>
   13984:	0000fffc 	.word	0x0000fffc
   13988:	001835b8 	.word	0x001835b8
   1398c:	00184fc0 	.word	0x00184fc0
   13990:	0013f5a0 	.word	0x0013f5a0
   13994:	0000fafe 	.word	0x0000fafe
   13998:	0000fffd 	.word	0x0000fffd

0001399c <thread_find>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   1399c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int32_t current_cpuid, index;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid != NULL, DNA_BAD_ARGUMENT);
   139a0:	e3510000 	cmp	r1, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
   139a4:	e24dd014 	sub	sp, sp, #20
  int32_t current_cpuid, index;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid != NULL, DNA_BAD_ARGUMENT);
   139a8:	e58d1008 	str	r1, [sp, #8]
   139ac:	059f00f4 	ldreq	r0, [pc, #244]	; 13aa8 <thread_find+0x10c>
   139b0:	0a00002c 	beq	13a68 <thread_find+0xcc>
   139b4:	e1a07000 	mov	r7, r0

    /*
     * Gather information about the current execution.
     */

    it_status = cpu_trap_mask_and_backup();
   139b8:	ebfff2b4 	bl	10490 <cpu_trap_mask_and_backup>
   139bc:	e58d000c 	str	r0, [sp, #12]
    current_cpuid = cpu_mp_id ();
   139c0:	ebfff308 	bl	105e8 <cpu_mp_id>
    self = cpu_pool . cpu[current_cpuid] . current_thread;
   139c4:	e59f30e0 	ldr	r3, [pc, #224]	; 13aac <thread_find+0x110>
   139c8:	e0800180 	add	r0, r0, r0, lsl #3
   139cc:	e0833300 	add	r3, r3, r0, lsl #6
    /*
     * Find the requested thread. It can be either self,
     * or a thread in self's group.
     */

    if (name == NULL)
   139d0:	e3570000 	cmp	r7, #0
     * Gather information about the current execution.
     */

    it_status = cpu_trap_mask_and_backup();
    current_cpuid = cpu_mp_id ();
    self = cpu_pool . cpu[current_cpuid] . current_thread;
   139d4:	e593b22c 	ldr	fp, [r3, #556]	; 0x22c
    /*
     * Find the requested thread. It can be either self,
     * or a thread in self's group.
     */

    if (name == NULL)
   139d8:	0a00002b 	beq	13a8c <thread_find+0xf0>
   139dc:	e59f60cc 	ldr	r6, [pc, #204]	; 13ab0 <thread_find+0x114>
    }
    else
    {
      lock_acquire (& thread_pool . lock);

      for (index = 0; index < DNA_MAX_THREAD; index += 1)
   139e0:	e3a04000 	mov	r4, #0
      *tid = self -> id . raw;
      cpu_trap_restore (it_status);
    }
    else
    {
      lock_acquire (& thread_pool . lock);
   139e4:	e1a00006 	mov	r0, r6

      for (index = 0; index < DNA_MAX_THREAD; index += 1)
      {
        thread = & thread_pool . data[self -> id . s . group][index];

        if (thread -> id . s . value != 0 &&
   139e8:	e1a08006 	mov	r8, r6
      *tid = self -> id . raw;
      cpu_trap_restore (it_status);
    }
    else
    {
      lock_acquire (& thread_pool . lock);
   139ec:	ebfff3f3 	bl	109c0 <lock_acquire>

      for (index = 0; index < DNA_MAX_THREAD; index += 1)
      {
        thread = & thread_pool . data[self -> id . s . group][index];

        if (thread -> id . s . value != 0 &&
   139f0:	e3a090d0 	mov	r9, #208	; 0xd0
   139f4:	e3a0ab0d 	mov	sl, #13312	; 0x3400
   139f8:	ea000001 	b	13a04 <thread_find+0x68>
    }
    else
    {
      lock_acquire (& thread_pool . lock);

      for (index = 0; index < DNA_MAX_THREAD; index += 1)
   139fc:	e3540040 	cmp	r4, #64	; 0x40
   13a00:	0a00001a 	beq	13a70 <thread_find+0xd4>
      {
        thread = & thread_pool . data[self -> id . s . group][index];
   13a04:	e5db301e 	ldrb	r3, [fp, #30]

        if (thread -> id . s . value != 0 &&
   13a08:	e003039a 	mul	r3, sl, r3
   13a0c:	e0233499 	mla	r3, r9, r4, r3
   13a10:	e0865003 	add	r5, r6, r3
   13a14:	e1d512b4 	ldrh	r1, [r5, #36]	; 0x24
    }
    else
    {
      lock_acquire (& thread_pool . lock);

      for (index = 0; index < DNA_MAX_THREAD; index += 1)
   13a18:	e2844001 	add	r4, r4, #1
      {
        thread = & thread_pool . data[self -> id . s . group][index];

        if (thread -> id . s . value != 0 &&
   13a1c:	e3510000 	cmp	r1, #0
   13a20:	e2855020 	add	r5, r5, #32
   13a24:	0afffff4 	beq	139fc <thread_find+0x60>
            dna_strcmp (name, thread -> info . name) == 0)
   13a28:	e2831028 	add	r1, r3, #40	; 0x28
   13a2c:	e0881001 	add	r1, r8, r1
   13a30:	e1a00007 	mov	r0, r7
   13a34:	ebfff121 	bl	fec0 <dna_strcmp>

      for (index = 0; index < DNA_MAX_THREAD; index += 1)
      {
        thread = & thread_pool . data[self -> id . s . group][index];

        if (thread -> id . s . value != 0 &&
   13a38:	e2503000 	subs	r3, r0, #0
   13a3c:	1affffee 	bne	139fc <thread_find+0x60>
            dna_strcmp (name, thread -> info . name) == 0)
        {
          *tid = thread -> id . raw;
   13a40:	e5952004 	ldr	r2, [r5, #4]
   13a44:	e59d1008 	ldr	r1, [sp, #8]
          break;
        }
      }

      lock_release (& thread_pool . lock);
   13a48:	e59f0060 	ldr	r0, [pc, #96]	; 13ab0 <thread_find+0x114>
        thread = & thread_pool . data[self -> id . s . group][index];

        if (thread -> id . s . value != 0 &&
            dna_strcmp (name, thread -> info . name) == 0)
        {
          *tid = thread -> id . raw;
   13a4c:	e5812000 	str	r2, [r1]
          break;
        }
      }

      lock_release (& thread_pool . lock);
   13a50:	e58d3004 	str	r3, [sp, #4]
   13a54:	ebfffe8d 	bl	13490 <lock_release>
      cpu_trap_restore (it_status);
   13a58:	e59d000c 	ldr	r0, [sp, #12]
   13a5c:	ebfff2c4 	bl	10574 <cpu_trap_restore>

      ensure (index != DNA_MAX_THREAD, DNA_UNKNOWN_THREAD);
    }

    return DNA_OK;
   13a60:	e59d3004 	ldr	r3, [sp, #4]
   13a64:	e1a00003 	mov	r0, r3
  }
}
   13a68:	e28dd014 	add	sp, sp, #20
   13a6c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
          *tid = thread -> id . raw;
          break;
        }
      }

      lock_release (& thread_pool . lock);
   13a70:	e59f0038 	ldr	r0, [pc, #56]	; 13ab0 <thread_find+0x114>
   13a74:	ebfffe85 	bl	13490 <lock_release>
      cpu_trap_restore (it_status);
   13a78:	e59d000c 	ldr	r0, [sp, #12]
   13a7c:	ebfff2bc 	bl	10574 <cpu_trap_restore>

      ensure (index != DNA_MAX_THREAD, DNA_UNKNOWN_THREAD);
   13a80:	e59f002c 	ldr	r0, [pc, #44]	; 13ab4 <thread_find+0x118>
    }

    return DNA_OK;
  }
}
   13a84:	e28dd014 	add	sp, sp, #20
   13a88:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
     * or a thread in self's group.
     */

    if (name == NULL)
    {
      *tid = self -> id . raw;
   13a8c:	e59b301c 	ldr	r3, [fp, #28]
   13a90:	e59d2008 	ldr	r2, [sp, #8]
      cpu_trap_restore (it_status);
   13a94:	e59d000c 	ldr	r0, [sp, #12]
     * or a thread in self's group.
     */

    if (name == NULL)
    {
      *tid = self -> id . raw;
   13a98:	e5823000 	str	r3, [r2]
      cpu_trap_restore (it_status);
   13a9c:	ebfff2b4 	bl	10574 <cpu_trap_restore>
      cpu_trap_restore (it_status);

      ensure (index != DNA_MAX_THREAD, DNA_UNKNOWN_THREAD);
    }

    return DNA_OK;
   13aa0:	e1a00007 	mov	r0, r7
   13aa4:	eaffffef 	b	13a68 <thread_find+0xcc>
   13aa8:	0000fffc 	.word	0x0000fffc
   13aac:	001883e8 	.word	0x001883e8
   13ab0:	00184fd0 	.word	0x00184fd0
   13ab4:	0000fcff 	.word	0x0000fcff

00013ab8 <port_poll>:
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
   13ab8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  status_t status;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
   13abc:	e1a04820 	lsr	r4, r0, #16
   13ac0:	e354003f 	cmp	r4, #63	; 0x3f
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
   13ac4:	e1a0a000 	mov	sl, r0
   13ac8:	e24dd014 	sub	sp, sp, #20
  status_t status;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
   13acc:	859f019c 	ldrhi	r0, [pc, #412]	; 13c70 <port_poll+0x1b8>
   13ad0:	9a000001 	bls	13adc <port_poll+0x24>
  {
    lock_release (& port_pool . lock);
    cpu_trap_restore (it_status);
    leave;
  }
}
   13ad4:	e28dd014 	add	sp, sp, #20
   13ad8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   13adc:	e3a08068 	mov	r8, #104	; 0x68
   13ae0:	e1a0b001 	mov	fp, r1

    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
   13ae4:	e58d200c 	str	r2, [sp, #12]
   13ae8:	e58d3008 	str	r3, [sp, #8]
   13aec:	ebfff267 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   13af0:	e0070498 	mul	r7, r8, r4
    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);
   13af4:	e59f5178 	ldr	r5, [pc, #376]	; 13c74 <port_poll+0x1bc>

    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
   13af8:	e1a06000 	mov	r6, r0
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   13afc:	e0859007 	add	r9, r5, r7
    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);
   13b00:	e1a00005 	mov	r0, r5
   13b04:	ebfff3ad 	bl	109c0 <lock_acquire>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   13b08:	e599100c 	ldr	r1, [r9, #12]
   13b0c:	e15a0001 	cmp	sl, r1
   13b10:	0a000006 	beq	13b30 <port_poll+0x78>
    leave;
  }

  rescue (bad_portid)
  {
    lock_release (& port_pool . lock);
   13b14:	e59f0158 	ldr	r0, [pc, #344]	; 13c74 <port_poll+0x1bc>
   13b18:	ebfffe5c 	bl	13490 <lock_release>
    cpu_trap_restore (it_status);
   13b1c:	e1a00006 	mov	r0, r6
   13b20:	ebfff293 	bl	10574 <cpu_trap_restore>
    leave;
   13b24:	e59f0144 	ldr	r0, [pc, #324]	; 13c70 <port_poll+0x1b8>
  }
}
   13b28:	e28dd014 	add	sp, sp, #20
   13b2c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    lock_acquire (& port -> lock);
   13b30:	e2877010 	add	r7, r7, #16
   13b34:	e0877005 	add	r7, r7, r5
   13b38:	e1a00007 	mov	r0, r7
   13b3c:	ebfff39f 	bl	109c0 <lock_acquire>
    lock_release (& port_pool . lock);
   13b40:	e1a00005 	mov	r0, r5
   13b44:	ebfffe51 	bl	13490 <lock_release>

    check (bad_port, ! port -> closed ||
   13b48:	e5d91014 	ldrb	r1, [r9, #20]
   13b4c:	e59d200c 	ldr	r2, [sp, #12]
   13b50:	e3510000 	cmp	r1, #0
   13b54:	e59d3008 	ldr	r3, [sp, #8]
   13b58:	0a00000a 	beq	13b88 <port_poll+0xd0>
   13b5c:	e0288894 	mla	r8, r4, r8, r8
   13b60:	e0858008 	add	r8, r5, r8
   13b64:	e5981004 	ldr	r1, [r8, #4]
   13b68:	e3510000 	cmp	r1, #0
   13b6c:	1a000005 	bne	13b88 <port_poll+0xd0>
    return DNA_OK;
  }

  rescue (bad_port)
  {
    lock_release (& port -> lock);
   13b70:	e1a00007 	mov	r0, r7
   13b74:	ebfffe45 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   13b78:	e1a00006 	mov	r0, r6
   13b7c:	ebfff27c 	bl	10574 <cpu_trap_restore>
    leave;
   13b80:	e59f00f0 	ldr	r0, [pc, #240]	; 13c78 <port_poll+0x1c0>
   13b84:	eaffffd2 	b	13ad4 <port_poll+0x1c>
    lock_release (& port_pool . lock);

    check (bad_port, ! port -> closed ||
        port -> mailbox . status != 0, DNA_ERROR);

    read_sem = port -> read_sem;
   13b88:	e3a01068 	mov	r1, #104	; 0x68
   13b8c:	e0285491 	mla	r8, r1, r4, r5

    lock_release (& port -> lock);
   13b90:	e1a00007 	mov	r0, r7
    lock_release (& port_pool . lock);

    check (bad_port, ! port -> closed ||
        port -> mailbox . status != 0, DNA_ERROR);

    read_sem = port -> read_sem;
   13b94:	e5989044 	ldr	r9, [r8, #68]	; 0x44

    lock_release (& port -> lock);
   13b98:	e58d200c 	str	r2, [sp, #12]
   13b9c:	e58d3008 	str	r3, [sp, #8]
   13ba0:	ebfffe3a 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   13ba4:	e1a00006 	mov	r0, r6
   13ba8:	ebfff271 	bl	10574 <cpu_trap_restore>

    /*
     * Acquire the semaphore.
     */

    status = semaphore_acquire (read_sem, 1, flags, timeout);
   13bac:	e59d200c 	ldr	r2, [sp, #12]
   13bb0:	e59d3008 	ldr	r3, [sp, #8]
   13bb4:	e1a00009 	mov	r0, r9
   13bb8:	e1cd20f0 	strd	r2, [sp]
   13bbc:	e3a01001 	mov	r1, #1
   13bc0:	e1a0200b 	mov	r2, fp
   13bc4:	ebfff8e4 	bl	11f5c <semaphore_acquire>
    ensure (status == DNA_OK, status);
   13bc8:	e3500000 	cmp	r0, #0
    lock_release (& port_pool . lock);

    check (bad_port, ! port -> closed ||
        port -> mailbox . status != 0, DNA_ERROR);

    read_sem = port -> read_sem;
   13bcc:	e59fb0a0 	ldr	fp, [pc, #160]	; 13c74 <port_poll+0x1bc>
    /*
     * Acquire the semaphore.
     */

    status = semaphore_acquire (read_sem, 1, flags, timeout);
    ensure (status == DNA_OK, status);
   13bd0:	1affffbf 	bne	13ad4 <port_poll+0x1c>
    /*
     * Get the port once again, just to make sure
     * it has not been destroyed in the meantime.
     */

    it_status = cpu_trap_mask_and_backup ();
   13bd4:	ebfff22d 	bl	10490 <cpu_trap_mask_and_backup>
   13bd8:	e1a06000 	mov	r6, r0
    lock_acquire (& port_pool . lock);
   13bdc:	e1a0000b 	mov	r0, fp
   13be0:	ebfff376 	bl	109c0 <lock_acquire>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
   13be4:	e598300c 	ldr	r3, [r8, #12]
   13be8:	e15a0003 	cmp	sl, r3
   13bec:	1affffc8 	bne	13b14 <port_poll+0x5c>

    lock_acquire (& port -> lock);
   13bf0:	e1a00007 	mov	r0, r7
   13bf4:	ebfff371 	bl	109c0 <lock_acquire>
    lock_release (& port_pool . lock);
   13bf8:	e1a0000b 	mov	r0, fp
   13bfc:	ebfffe23 	bl	13490 <lock_release>

    check (bad_port, ! port -> closed ||
   13c00:	e5d83014 	ldrb	r3, [r8, #20]
   13c04:	e3530000 	cmp	r3, #0
   13c08:	0a000005 	beq	13c24 <port_poll+0x16c>
   13c0c:	e3a02068 	mov	r2, #104	; 0x68
   13c10:	e2843001 	add	r3, r4, #1
   13c14:	e02ab392 	mla	sl, r2, r3, fp
   13c18:	e59a3004 	ldr	r3, [sl, #4]
   13c1c:	e3530000 	cmp	r3, #0
   13c20:	0affffd2 	beq	13b70 <port_poll+0xb8>

    /*
     * Get the message size from the message queue.
     */

    message = queue_rem (& port -> mailbox);
   13c24:	e3a03068 	mov	r3, #104	; 0x68
   13c28:	e0245493 	mla	r4, r3, r4, r5
   13c2c:	e2844060 	add	r4, r4, #96	; 0x60
   13c30:	e1a00004 	mov	r0, r4
   13c34:	ebffedad 	bl	f2f0 <queue_rem>
    check (bad_port, message != NULL, DNA_ERROR);
   13c38:	e2501000 	subs	r1, r0, #0
   13c3c:	0affffcb 	beq	13b70 <port_poll+0xb8>

#if 0
    data_size = message -> size;
#endif
    queue_pushback (& port -> mailbox, message);
   13c40:	e1a00004 	mov	r0, r4
   13c44:	ebfff169 	bl	101f0 <queue_pushback>

    lock_release (& port -> lock);
   13c48:	e1a00007 	mov	r0, r7
   13c4c:	ebfffe0f 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   13c50:	e1a00006 	mov	r0, r6
   13c54:	ebfff246 	bl	10574 <cpu_trap_restore>

    /*
     * Release the semaphore and return.
     */

    status = semaphore_release (read_sem, 1, DNA_NO_RESCHEDULE);
   13c58:	e3a01001 	mov	r1, #1
   13c5c:	e1a00009 	mov	r0, r9
   13c60:	e1a02001 	mov	r2, r1
  {
    lock_release (& port_pool . lock);
    cpu_trap_restore (it_status);
    leave;
  }
}
   13c64:	e28dd014 	add	sp, sp, #20
   13c68:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

    /*
     * Release the semaphore and return.
     */

    status = semaphore_release (read_sem, 1, DNA_NO_RESCHEDULE);
   13c6c:	eafffd7e 	b	1326c <semaphore_release>
   13c70:	0000faff 	.word	0x0000faff
   13c74:	001835b8 	.word	0x001835b8
   13c78:	0000ffff 	.word	0x0000ffff

00013c7c <thread_suspend>:
 */

{
  queue_t * queue = NULL;
  status_t status, result;
  thread_t target = NULL;
   13c7c:	e3a03000 	mov	r3, #0
 * * DNA_OK: the operation succeeded.
 *
 * SOURCE
 */

{
   13c80:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
   13c84:	e1a02820 	lsr	r2, r0, #16
 * * DNA_OK: the operation succeeded.
 *
 * SOURCE
 */

{
   13c88:	e24dd014 	sub	sp, sp, #20
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
   13c8c:	e31200ff 	tst	r2, #255	; 0xff
 * * DNA_OK: the operation succeeded.
 *
 * SOURCE
 */

{
   13c90:	e1a04000 	mov	r4, r0
  queue_t * queue = NULL;
  status_t status, result;
  thread_t target = NULL;
   13c94:	e58d300c 	str	r3, [sp, #12]
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
   13c98:	0a000002 	beq	13ca8 <thread_suspend+0x2c>
   13c9c:	e59f020c 	ldr	r0, [pc, #524]	; 13eb0 <thread_suspend+0x234>
  {
    lock_release (& thread_pool . lock);
    cpu_trap_restore (it_status);
    leave;
  }
}
   13ca0:	e28dd014 	add	sp, sp, #20
   13ca4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    ensure (tid . s . index >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . index < DNA_MAX_THREAD, DNA_BAD_ARGUMENT);
   13ca8:	e1a05c20 	lsr	r5, r0, #24
   13cac:	e355003f 	cmp	r5, #63	; 0x3f
   13cb0:	8afffff9 	bhi	13c9c <thread_suspend+0x20>

    /*
     * Get some information about the execution.
     */

    it_status = cpu_trap_mask_and_backup ();
   13cb4:	ebfff1f5 	bl	10490 <cpu_trap_mask_and_backup>
   13cb8:	e58d0004 	str	r0, [sp, #4]
    current_cpuid = cpu_mp_id ();
   13cbc:	ebfff249 	bl	105e8 <cpu_mp_id>
   13cc0:	e3a030d0 	mov	r3, #208	; 0xd0
   13cc4:	e0050593 	mul	r5, r3, r5
    do
    {
      lock_acquire (& thread_pool . lock);
      thread = & thread_pool . data[tid . s . group][tid . s . index];

      check (bad_thread, thread != NULL &&
   13cc8:	e1a0a005 	mov	sl, r5
   13ccc:	e59f91e0 	ldr	r9, [pc, #480]	; 13eb4 <thread_suspend+0x238>
   13cd0:	e2855008 	add	r5, r5, #8

      /*
       * Lock the thread and check its status.
       */

      lock_acquire (& thread -> lock);
   13cd4:	e089700a 	add	r7, r9, sl
    /*
     * Get some information about the execution.
     */

    it_status = cpu_trap_mask_and_backup ();
    current_cpuid = cpu_mp_id ();
   13cd8:	e58d0000 	str	r0, [sp]
   13cdc:	e089b005 	add	fp, r9, r5

      /*
       * Lock the thread and check its status.
       */

      lock_acquire (& thread -> lock);
   13ce0:	e287701c 	add	r7, r7, #28
    do
    {
      lock_acquire (& thread_pool . lock);
      thread = & thread_pool . data[tid . s . group][tid . s . index];

      check (bad_thread, thread != NULL &&
   13ce4:	e089500a 	add	r5, r9, sl
   13ce8:	e2856020 	add	r6, r5, #32
     * in several different ways.
     */

    do
    {
      lock_acquire (& thread_pool . lock);
   13cec:	e59f01c0 	ldr	r0, [pc, #448]	; 13eb4 <thread_suspend+0x238>
   13cf0:	ebfff332 	bl	109c0 <lock_acquire>
      thread = & thread_pool . data[tid . s . group][tid . s . index];

      check (bad_thread, thread != NULL &&
   13cf4:	e5963004 	ldr	r3, [r6, #4]
   13cf8:	e1540003 	cmp	r4, r3
   13cfc:	1a00005e 	bne	13e7c <thread_suspend+0x200>

      /*
       * Lock the thread and check its status.
       */

      lock_acquire (& thread -> lock);
   13d00:	e1a00007 	mov	r0, r7
   13d04:	ebfff32d 	bl	109c0 <lock_acquire>
      lock_release (& thread_pool . lock);
   13d08:	e59f01a4 	ldr	r0, [pc, #420]	; 13eb4 <thread_suspend+0x238>
   13d0c:	ebfffddf 	bl	13490 <lock_release>

      check (thread_error,
   13d10:	e59f81a0 	ldr	r8, [pc, #416]	; 13eb8 <thread_suspend+0x23c>
   13d14:	e1d535b8 	ldrh	r3, [r5, #88]	; 0x58
   13d18:	e59f219c 	ldr	r2, [pc, #412]	; 13ebc <thread_suspend+0x240>
   13d1c:	e285c058 	add	ip, r5, #88	; 0x58
   13d20:	e1530002 	cmp	r3, r2
   13d24:	11530008 	cmpne	r3, r8
   13d28:	03a08001 	moveq	r8, #1
   13d2c:	13a08000 	movne	r8, #0
   13d30:	0a000048 	beq	13e58 <thread_suspend+0x1dc>

      /*
       * Discriminate in function of its status.
       */

      switch (thread -> info . status)
   13d34:	e59f2184 	ldr	r2, [pc, #388]	; 13ec0 <thread_suspend+0x244>
   13d38:	e1530002 	cmp	r3, r2
   13d3c:	0a000040 	beq	13e44 <thread_suspend+0x1c8>
   13d40:	9a00001b 	bls	13db4 <thread_suspend+0x138>
   13d44:	e59f2178 	ldr	r2, [pc, #376]	; 13ec4 <thread_suspend+0x248>
   13d48:	e1530002 	cmp	r3, r2
   13d4c:	0a000026 	beq	13dec <thread_suspend+0x170>
   13d50:	e59f2170 	ldr	r2, [pc, #368]	; 13ec8 <thread_suspend+0x24c>
   13d54:	e1530002 	cmp	r3, r2
   13d58:	1affffe1 	bne	13ce4 <thread_suspend+0x68>
            break;
          }

        case DNA_THREAD_READY :
          {
            queue = & scheduler . queue[thread -> info . affinity];
   13d5c:	e59f3168 	ldr	r3, [pc, #360]	; 13ecc <thread_suspend+0x250>
   13d60:	e5956050 	ldr	r6, [r5, #80]	; 0x50
            /*
             * Apply the banker's algorithm to lock both the thread
             * and the ready queue.
             */

            result = lock_try (& queue -> lock, true);
   13d64:	e3a01001 	mov	r1, #1
            break;
          }

        case DNA_THREAD_READY :
          {
            queue = & scheduler . queue[thread -> info . affinity];
   13d68:	e0836206 	add	r6, r3, r6, lsl #4
   13d6c:	e2866004 	add	r6, r6, #4
            /*
             * Apply the banker's algorithm to lock both the thread
             * and the ready queue.
             */

            result = lock_try (& queue -> lock, true);
   13d70:	e1a00006 	mov	r0, r6
   13d74:	ebfff630 	bl	1163c <lock_try>

            if (result != DNA_ERROR)
   13d78:	e59f3150 	ldr	r3, [pc, #336]	; 13ed0 <thread_suspend+0x254>
   13d7c:	e1500003 	cmp	r0, r3
   13d80:	0a000017 	beq	13de4 <thread_suspend+0x168>

            if (result != DNA_ERROR)
            {
dna_log(VERBOSE_LEVEL, "Local WAIT suspend %d.", thread -> id);

              queue_extract (queue, thread);
   13d84:	e1a0100b 	mov	r1, fp
   13d88:	e1a00006 	mov	r0, r6
   13d8c:	ebffed15 	bl	f1e8 <queue_extract>
              lock_release (& queue -> lock);
   13d90:	e1a00006 	mov	r0, r6
   13d94:	ebfffdbd 	bl	13490 <lock_release>

              thread -> info . status = DNA_THREAD_SUSPENDED;
   13d98:	e59f3134 	ldr	r3, [pc, #308]	; 13ed4 <thread_suspend+0x258>
   13d9c:	e1c535b8 	strh	r3, [r5, #88]	; 0x58
              restart_stabilization_loop = false;
            }

            lock_release (& thread -> lock);
   13da0:	e1a00007 	mov	r0, r7
   13da4:	ebfffdb9 	bl	13490 <lock_release>
dna_log(PANIC_LEVEL, "Unknown thread status.");
            break;
          }
      }
    }
    while (restart_stabilization_loop);
   13da8:	e3580000 	cmp	r8, #0
   13dac:	1affffcc 	bne	13ce4 <thread_suspend+0x68>
   13db0:	ea00001f 	b	13e34 <thread_suspend+0x1b8>

      /*
       * Discriminate in function of its status.
       */

      switch (thread -> info . status)
   13db4:	e59f211c 	ldr	r2, [pc, #284]	; 13ed8 <thread_suspend+0x25c>
   13db8:	e1530002 	cmp	r3, r2
   13dbc:	1affffc8 	bne	13ce4 <thread_suspend+0x68>
            break;
          }

        case DNA_THREAD_WAITING :
          {
            queue = thread -> resource_queue;
   13dc0:	e5956020 	ldr	r6, [r5, #32]
            /*
             * Apply the banker's algorithm to lock both the thread
             * and the resource queue.
             */

            check (thread_error, queue != NULL, DNA_ERROR);
   13dc4:	e3560000 	cmp	r6, #0
   13dc8:	0a000022 	beq	13e58 <thread_suspend+0x1dc>
            result = lock_try (& queue -> lock, true);
   13dcc:	e1a00006 	mov	r0, r6
   13dd0:	e3a01001 	mov	r1, #1
   13dd4:	ebfff618 	bl	1163c <lock_try>

            if (result != DNA_ERROR)
   13dd8:	e59f30f0 	ldr	r3, [pc, #240]	; 13ed0 <thread_suspend+0x254>
   13ddc:	e1500003 	cmp	r0, r3
   13de0:	1affffe7 	bne	13d84 <thread_suspend+0x108>
   13de4:	e3a08001 	mov	r8, #1
   13de8:	eaffffec 	b	13da0 <thread_suspend+0x124>

      switch (thread -> info . status)
      {
        case DNA_THREAD_RUNNING :
          {
            if (thread -> info . cpu_id == current_cpuid)
   13dec:	e5954048 	ldr	r4, [r5, #72]	; 0x48
   13df0:	e59d3000 	ldr	r3, [sp]
   13df4:	e1530004 	cmp	r3, r4
   13df8:	1a000021 	bne	13e84 <thread_suspend+0x208>
            {
dna_log(VERBOSE_LEVEL, "Local RUN suspend 0x%x.", thread -> id);

              thread -> info . status = DNA_THREAD_SUSPENDED;
   13dfc:	e59f30d0 	ldr	r3, [pc, #208]	; 13ed4 <thread_suspend+0x258>

              status = scheduler_elect (& target, true);
   13e00:	e28d000c 	add	r0, sp, #12
          {
            if (thread -> info . cpu_id == current_cpuid)
            {
dna_log(VERBOSE_LEVEL, "Local RUN suspend 0x%x.", thread -> id);

              thread -> info . status = DNA_THREAD_SUSPENDED;
   13e04:	e1cc30b0 	strh	r3, [ip]

              status = scheduler_elect (& target, true);
   13e08:	e3a01001 	mov	r1, #1
   13e0c:	ebfffa0b 	bl	12640 <scheduler_elect>
              check (thread_error, status != DNA_BAD_ARGUMENT, status);
   13e10:	e59f3098 	ldr	r3, [pc, #152]	; 13eb0 <thread_suspend+0x234>
            {
dna_log(VERBOSE_LEVEL, "Local RUN suspend 0x%x.", thread -> id);

              thread -> info . status = DNA_THREAD_SUSPENDED;

              status = scheduler_elect (& target, true);
   13e14:	e1a04000 	mov	r4, r0
              check (thread_error, status != DNA_BAD_ARGUMENT, status);
   13e18:	e1500003 	cmp	r0, r3
   13e1c:	0a00000e 	beq	13e5c <thread_suspend+0x1e0>

              status = scheduler_switch (target, NULL);
   13e20:	e1a01008 	mov	r1, r8
   13e24:	e59d000c 	ldr	r0, [sp, #12]
   13e28:	ebfffc0a 	bl	12e58 <scheduler_switch>
              check (thread_error, status == DNA_OK, status);
   13e2c:	e2504000 	subs	r4, r0, #0
   13e30:	1a000009 	bne	13e5c <thread_suspend+0x1e0>
          }
      }
    }
    while (restart_stabilization_loop);

    cpu_trap_restore (it_status);
   13e34:	e59d0004 	ldr	r0, [sp, #4]
   13e38:	ebfff1cd 	bl	10574 <cpu_trap_restore>
    return DNA_OK;
   13e3c:	e3a00000 	mov	r0, #0
   13e40:	eaffff96 	b	13ca0 <thread_suspend+0x24>
            /*
             * We don't cancel the alarm here, thread_snooze uses
             * alarm_destroy to check wether the alarm has fired or not.
             */

            thread -> info . status = DNA_THREAD_SUSPENDED;
   13e44:	e59f3088 	ldr	r3, [pc, #136]	; 13ed4 <thread_suspend+0x258>
            lock_release (& thread -> lock);
   13e48:	e1a00007 	mov	r0, r7
            /*
             * We don't cancel the alarm here, thread_snooze uses
             * alarm_destroy to check wether the alarm has fired or not.
             */

            thread -> info . status = DNA_THREAD_SUSPENDED;
   13e4c:	e1cc30b0 	strh	r3, [ip]
            lock_release (& thread -> lock);
   13e50:	ebfffd8e 	bl	13490 <lock_release>

            restart_stabilization_loop = false;
            break;
   13e54:	eafffff6 	b	13e34 <thread_suspend+0x1b8>
       */

      lock_acquire (& thread -> lock);
      lock_release (& thread_pool . lock);

      check (thread_error,
   13e58:	e59f4070 	ldr	r4, [pc, #112]	; 13ed0 <thread_suspend+0x254>
    return DNA_OK;
  }

  rescue (thread_error)
  {
    lock_release (& thread -> lock);
   13e5c:	e1a00007 	mov	r0, r7
   13e60:	ebfffd8a 	bl	13490 <lock_release>
  }

  rescue (bad_thread)
  {
    lock_release (& thread_pool . lock);
   13e64:	e59f0048 	ldr	r0, [pc, #72]	; 13eb4 <thread_suspend+0x238>
   13e68:	ebfffd88 	bl	13490 <lock_release>
    cpu_trap_restore (it_status);
   13e6c:	e59d0004 	ldr	r0, [sp, #4]
   13e70:	ebfff1bf 	bl	10574 <cpu_trap_restore>
    leave;
   13e74:	e1a00004 	mov	r0, r4
   13e78:	eaffff88 	b	13ca0 <thread_suspend+0x24>
    do
    {
      lock_acquire (& thread_pool . lock);
      thread = & thread_pool . data[tid . s . group][tid . s . index];

      check (bad_thread, thread != NULL &&
   13e7c:	e59f4058 	ldr	r4, [pc, #88]	; 13edc <thread_suspend+0x260>
   13e80:	eafffff7 	b	13e64 <thread_suspend+0x1e8>
            {
dna_log(VERBOSE_LEVEL, "Remote suspend %d on %d.",
                  thread -> id, thread -> info . cpu_id);

              next_cpuid = thread -> info . cpu_id;
              lock_release (& thread -> lock);
   13e84:	e1a00007 	mov	r0, r7
   13e88:	ebfffd80 	bl	13490 <lock_release>

              lock_acquire (& cpu_pool . cpu[next_cpuid] . ipi_lock);
   13e8c:	e59f304c 	ldr	r3, [pc, #76]	; 13ee0 <thread_suspend+0x264>
   13e90:	e0840184 	add	r0, r4, r4, lsl #3
   13e94:	e0830300 	add	r0, r3, r0, lsl #6
   13e98:	ebfff2c8 	bl	109c0 <lock_acquire>
              cpu_mp_send_ipi (next_cpuid, DNA_IPI_SUSPEND,
   13e9c:	e1a00004 	mov	r0, r4
   13ea0:	e5962004 	ldr	r2, [r6, #4]
   13ea4:	e59f1038 	ldr	r1, [pc, #56]	; 13ee4 <thread_suspend+0x268>
   13ea8:	ebfff18a 	bl	104d8 <cpu_mp_send_ipi>
   13eac:	eaffffe0 	b	13e34 <thread_suspend+0x1b8>
   13eb0:	0000fffc 	.word	0x0000fffc
   13eb4:	00184fd0 	.word	0x00184fd0
   13eb8:	0000d15a 	.word	0x0000d15a
   13ebc:	0000dead 	.word	0x0000dead
   13ec0:	0000bedd 	.word	0x0000bedd
   13ec4:	0000beef 	.word	0x0000beef
   13ec8:	0000face 	.word	0x0000face
   13ecc:	0018a800 	.word	0x0018a800
   13ed0:	0000ffff 	.word	0x0000ffff
   13ed4:	ffffd15a 	.word	0xffffd15a
   13ed8:	0000b10c 	.word	0x0000b10c
   13edc:	0000fcfe 	.word	0x0000fcfe
   13ee0:	00188400 	.word	0x00188400
   13ee4:	0000fffe 	.word	0x0000fffe

00013ee8 <memory_stop>:
 */

{

  return DNA_NOT_IMPLEMENTED;
}
   13ee8:	e59f0000 	ldr	r0, [pc]	; 13ef0 <memory_stop+0x8>
   13eec:	e12fff1e 	bx	lr
   13ef0:	0000fffe 	.word	0x0000fffe

00013ef4 <kernel_region_destroy>:

  /*
   * Remove the region from the list of created regions
   */

  if (region -> next != NULL)
   13ef4:	e5903008 	ldr	r3, [r0, #8]
 * Always return DNA_OK.
 *
 * SOURCE
 */

{
   13ef8:	e92d4030 	push	{r4, r5, lr}

  /*
   * Remove the region from the list of created regions
   */

  if (region -> next != NULL)
   13efc:	e3530000 	cmp	r3, #0
  {
    region -> next -> prev = region -> prev;
    region -> next = NULL;
   13f00:	13a02000 	movne	r2, #0
   * Remove the region from the list of created regions
   */

  if (region -> next != NULL)
  {
    region -> next -> prev = region -> prev;
   13f04:	1590100c 	ldrne	r1, [r0, #12]
   13f08:	1583100c 	strne	r1, [r3, #12]
    region -> next = NULL;
  }

  if (region -> prev != NULL)
   13f0c:	e590300c 	ldr	r3, [r0, #12]
   */

  if (region -> next != NULL)
  {
    region -> next -> prev = region -> prev;
    region -> next = NULL;
   13f10:	15802008 	strne	r2, [r0, #8]
  }

  if (region -> prev != NULL)
   13f14:	e3530000 	cmp	r3, #0
  {
    region -> prev -> next = region -> next;
   13f18:	13a02000 	movne	r2, #0
    region -> prev = NULL;
  }
  else
  {
    kernel_allocator . next_created_region = region -> next;
   13f1c:	059f4168 	ldreq	r4, [pc, #360]	; 1408c <kernel_region_destroy+0x198>
   13f20:	159f4164 	ldrne	r4, [pc, #356]	; 1408c <kernel_region_destroy+0x198>
    region -> next = NULL;
  }

  if (region -> prev != NULL)
  {
    region -> prev -> next = region -> next;
   13f24:	15832008 	strne	r2, [r3, #8]
    region -> prev = NULL;
  }
  else
  {
    kernel_allocator . next_created_region = region -> next;
   13f28:	05843004 	streq	r3, [r4, #4]

  /*
   * Add the region as a free region
   */

  ptr = kernel_allocator . next_free_region;
   13f2c:	e5943008 	ldr	r3, [r4, #8]
  }

  if (region -> prev != NULL)
  {
    region -> prev -> next = region -> next;
    region -> prev = NULL;
   13f30:	1580200c 	strne	r2, [r0, #12]

  /*
   * Add the region as a free region
   */

  ptr = kernel_allocator . next_free_region;
   13f34:	e59f2150 	ldr	r2, [pc, #336]	; 1408c <kernel_region_destroy+0x198>

  if (ptr == NULL) kernel_allocator . next_free_region = region;
   13f38:	e3530000 	cmp	r3, #0
   13f3c:	05820008 	streq	r0, [r2, #8]
   13f40:	0a000020 	beq	13fc8 <kernel_region_destroy+0xd4>
  else {
    vregion = (uint32_t)region;
   13f44:	e1a0e000 	mov	lr, r0
    vrsize = region -> nblocks * DNA_KERNEL_BLOCK_SIZE;
   13f48:	e1a05003 	mov	r5, r3
   13f4c:	e590c000 	ldr	ip, [r0]

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
        else kernel_allocator . next_free_region = ptr -> next;
        if (ptr -> next != NULL) ptr -> next -> prev = ptr -> prev;
      }
      else if (vregion + vrsize == vptr) {
   13f50:	e080c28c 	add	ip, r0, ip, lsl #5
     * with connexes regions
     */

    while (ptr != NULL) {
      vptr = (uint32_t)ptr;
      vpsize = ptr -> nblocks * DNA_KERNEL_BLOCK_SIZE;
   13f54:	e5932000 	ldr	r2, [r3]

      if (vptr + vpsize == vregion) {
   13f58:	e0831282 	add	r1, r3, r2, lsl #5
   13f5c:	e151000e 	cmp	r1, lr
   13f60:	0a00001a 	beq	13fd0 <kernel_region_destroy+0xdc>

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
        else kernel_allocator . next_free_region = ptr -> next;
        if (ptr -> next != NULL) ptr -> next -> prev = ptr -> prev;
      }
      else if (vregion + vrsize == vptr) {
   13f64:	e15c0003 	cmp	ip, r3
   13f68:	0a000028 	beq	14010 <kernel_region_destroy+0x11c>
   13f6c:	e5933008 	ldr	r3, [r3, #8]
    /*
     * First, we increase the new region size
     * with connexes regions
     */

    while (ptr != NULL) {
   13f70:	e3530000 	cmp	r3, #0
   13f74:	1afffff6 	bne	13f54 <kernel_region_destroy+0x60>
   13f78:	e1a03000 	mov	r3, r0
   13f7c:	e1a02005 	mov	r2, r5
   13f80:	e5845008 	str	r5, [r4, #8]
     * Then, we order it in term of worst fit.
     * This way, alloc only take the first in the list.
     */

    ptr = kernel_allocator . next_free_region;
    if (ptr == NULL) {
   13f84:	e3520000 	cmp	r2, #0
    /*
     * Then, we order it in term of worst fit.
     * This way, alloc only take the first in the list.
     */

    ptr = kernel_allocator . next_free_region;
   13f88:	e59f10fc 	ldr	r1, [pc, #252]	; 1408c <kernel_region_destroy+0x198>
    if (ptr == NULL) {
   13f8c:	0a00003a 	beq	1407c <kernel_region_destroy+0x188>
   13f90:	e593c000 	ldr	ip, [r3]
   13f94:	ea000002 	b	13fa4 <kernel_region_destroy+0xb0>
      region -> next = NULL;
      kernel_allocator . next_free_region = region;
    }
    else {
      while (ptr -> next != NULL) {
        if (ptr -> nblocks <= region -> nblocks)  break;
   13f98:	e150000c 	cmp	r0, ip
   13f9c:	da000029 	ble	14048 <kernel_region_destroy+0x154>
        ptr = ptr -> next;
   13fa0:	e1a02001 	mov	r2, r1
      region -> prev = NULL;
      region -> next = NULL;
      kernel_allocator . next_free_region = region;
    }
    else {
      while (ptr -> next != NULL) {
   13fa4:	e5921008 	ldr	r1, [r2, #8]
        if (ptr -> nblocks <= region -> nblocks)  break;
   13fa8:	e5920000 	ldr	r0, [r2]
      region -> prev = NULL;
      region -> next = NULL;
      kernel_allocator . next_free_region = region;
    }
    else {
      while (ptr -> next != NULL) {
   13fac:	e3510000 	cmp	r1, #0
   13fb0:	1afffff8 	bne	13f98 <kernel_region_destroy+0xa4>
        if (ptr -> nblocks <= region -> nblocks)  break;
        ptr = ptr -> next;
      }
      
      if (ptr -> nblocks <= region -> nblocks) {
   13fb4:	e150000c 	cmp	r0, ip
        if (ptr -> prev != NULL) ptr -> prev -> next = region;
        else kernel_allocator . next_free_region = region;
        ptr -> prev = region;
      }
      else {
        ptr -> next = region;
   13fb8:	c5823008 	strgt	r3, [r2, #8]
        region -> prev = ptr;
   13fbc:	c583200c 	strgt	r2, [r3, #12]
        region -> next = NULL;
   13fc0:	c5831008 	strgt	r1, [r3, #8]
      while (ptr -> next != NULL) {
        if (ptr -> nblocks <= region -> nblocks)  break;
        ptr = ptr -> next;
      }
      
      if (ptr -> nblocks <= region -> nblocks) {
   13fc4:	da00001f 	ble	14048 <kernel_region_destroy+0x154>
      }
    }
  }  

  return DNA_OK;
}
   13fc8:	e3a00000 	mov	r0, #0
   13fcc:	e8bd8030 	pop	{r4, r5, pc}

      if (vptr + vpsize == vregion) {
        ptr -> nblocks += region -> nblocks;
        region = ptr;

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
   13fd0:	e593100c 	ldr	r1, [r3, #12]
    while (ptr != NULL) {
      vptr = (uint32_t)ptr;
      vpsize = ptr -> nblocks * DNA_KERNEL_BLOCK_SIZE;

      if (vptr + vpsize == vregion) {
        ptr -> nblocks += region -> nblocks;
   13fd4:	e5900000 	ldr	r0, [r0]
        region = ptr;

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
   13fd8:	e3510000 	cmp	r1, #0
        else kernel_allocator . next_free_region = ptr -> next;
   13fdc:	05935008 	ldreq	r5, [r3, #8]
    while (ptr != NULL) {
      vptr = (uint32_t)ptr;
      vpsize = ptr -> nblocks * DNA_KERNEL_BLOCK_SIZE;

      if (vptr + vpsize == vregion) {
        ptr -> nblocks += region -> nblocks;
   13fe0:	e0822000 	add	r2, r2, r0
   13fe4:	e5832000 	str	r2, [r3]
        region = ptr;

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
        else kernel_allocator . next_free_region = ptr -> next;
   13fe8:	01a02005 	moveq	r2, r5

      if (vptr + vpsize == vregion) {
        ptr -> nblocks += region -> nblocks;
        region = ptr;

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
   13fec:	15932008 	ldrne	r2, [r3, #8]
   13ff0:	15812008 	strne	r2, [r1, #8]
   13ff4:	15932008 	ldrne	r2, [r3, #8]
        else kernel_allocator . next_free_region = ptr -> next;
        if (ptr -> next != NULL) ptr -> next -> prev = ptr -> prev;
   13ff8:	e3520000 	cmp	r2, #0
   13ffc:	0a00001b 	beq	14070 <kernel_region_destroy+0x17c>
   14000:	e1a00003 	mov	r0, r3
   14004:	e582100c 	str	r1, [r2, #12]
   14008:	e1a03002 	mov	r3, r2
   1400c:	eaffffd0 	b	13f54 <kernel_region_destroy+0x60>
      }
      else if (vregion + vrsize == vptr) {
        region -> nblocks += ptr -> nblocks;

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
   14010:	e59c300c 	ldr	r3, [ip, #12]
        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
        else kernel_allocator . next_free_region = ptr -> next;
        if (ptr -> next != NULL) ptr -> next -> prev = ptr -> prev;
      }
      else if (vregion + vrsize == vptr) {
        region -> nblocks += ptr -> nblocks;
   14014:	e5901000 	ldr	r1, [r0]

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
   14018:	e3530000 	cmp	r3, #0
        else kernel_allocator . next_free_region = ptr -> next;
   1401c:	059c5008 	ldreq	r5, [ip, #8]
        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
        else kernel_allocator . next_free_region = ptr -> next;
        if (ptr -> next != NULL) ptr -> next -> prev = ptr -> prev;
      }
      else if (vregion + vrsize == vptr) {
        region -> nblocks += ptr -> nblocks;
   14020:	e0812002 	add	r2, r1, r2
   14024:	e5802000 	str	r2, [r0]

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
        else kernel_allocator . next_free_region = ptr -> next;
   14028:	01a02005 	moveq	r2, r5
        if (ptr -> next != NULL) ptr -> next -> prev = ptr -> prev;
      }
      else if (vregion + vrsize == vptr) {
        region -> nblocks += ptr -> nblocks;

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
   1402c:	159c2008 	ldrne	r2, [ip, #8]
   14030:	15832008 	strne	r2, [r3, #8]
   14034:	159c2008 	ldrne	r2, [ip, #8]
        else kernel_allocator . next_free_region = ptr -> next;
        if (ptr -> next != NULL) ptr -> next -> prev = ptr -> prev;
   14038:	e3520000 	cmp	r2, #0
   1403c:	0affffcd 	beq	13f78 <kernel_region_destroy+0x84>
   14040:	e582300c 	str	r3, [r2, #12]
   14044:	eaffffef 	b	14008 <kernel_region_destroy+0x114>
        if (ptr -> nblocks <= region -> nblocks)  break;
        ptr = ptr -> next;
      }
      
      if (ptr -> nblocks <= region -> nblocks) {
        region -> prev = ptr -> prev;
   14048:	e592100c 	ldr	r1, [r2, #12]
      }
    }
  }  

  return DNA_OK;
}
   1404c:	e3a00000 	mov	r0, #0
        if (ptr -> nblocks <= region -> nblocks)  break;
        ptr = ptr -> next;
      }
      
      if (ptr -> nblocks <= region -> nblocks) {
        region -> prev = ptr -> prev;
   14050:	e583100c 	str	r1, [r3, #12]
        region -> next = ptr;

        if (ptr -> prev != NULL) ptr -> prev -> next = region;
   14054:	e592100c 	ldr	r1, [r2, #12]
        ptr = ptr -> next;
      }
      
      if (ptr -> nblocks <= region -> nblocks) {
        region -> prev = ptr -> prev;
        region -> next = ptr;
   14058:	e5832008 	str	r2, [r3, #8]

        if (ptr -> prev != NULL) ptr -> prev -> next = region;
   1405c:	e3510000 	cmp	r1, #0
   14060:	15813008 	strne	r3, [r1, #8]
        else kernel_allocator . next_free_region = region;
   14064:	05843008 	streq	r3, [r4, #8]
        ptr -> prev = region;
   14068:	e582300c 	str	r3, [r2, #12]
      }
    }
  }  

  return DNA_OK;
}
   1406c:	e8bd8030 	pop	{r4, r5, pc}
   14070:	e5845008 	str	r5, [r4, #8]
   14074:	e1a02005 	mov	r2, r5
   14078:	eaffffc1 	b	13f84 <kernel_region_destroy+0x90>
     */

    ptr = kernel_allocator . next_free_region;
    if (ptr == NULL) {
      region -> prev = NULL;
      region -> next = NULL;
   1407c:	e5832008 	str	r2, [r3, #8]
     * This way, alloc only take the first in the list.
     */

    ptr = kernel_allocator . next_free_region;
    if (ptr == NULL) {
      region -> prev = NULL;
   14080:	e583200c 	str	r2, [r3, #12]
      region -> next = NULL;
      kernel_allocator . next_free_region = region;
   14084:	e5813008 	str	r3, [r1, #8]
   14088:	eaffffce 	b	13fc8 <kernel_region_destroy+0xd4>
   1408c:	0018b930 	.word	0x0018b930

00014090 <kernel_malloc>:
 * * NULL in case of failure.
 *
 * SOURCE
 */

{
   14090:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  uint8_t * area = NULL;
  kernel_region_t region = NULL;
   14094:	e3a05000 	mov	r5, #0
 * * NULL in case of failure.
 *
 * SOURCE
 */

{
   14098:	e24dd008 	sub	sp, sp, #8
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (void *)
  {
    check (invalid_argument, size != 0, NULL);
   1409c:	e3500000 	cmp	r0, #0
 * SOURCE
 */

{
  uint8_t * area = NULL;
  kernel_region_t region = NULL;
   140a0:	e58d5004 	str	r5, [sp, #4]
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (void *)
  {
    check (invalid_argument, size != 0, NULL);
   140a4:	0a00001b 	beq	14118 <kernel_malloc+0x88>

    nblocks = size / DNA_KERNEL_BLOCK_SIZE;
   140a8:	e1a032a0 	lsr	r3, r0, #5
    nblocks += (((size - nblocks * DNA_KERNEL_BLOCK_SIZE) != 0) ? 1 : 0) + 1;
   140ac:	e1500283 	cmp	r0, r3, lsl #5
   140b0:	13a08002 	movne	r8, #2
   140b4:	03a08001 	moveq	r8, #1
   140b8:	e1a06001 	mov	r6, r1
   140bc:	e0888003 	add	r8, r8, r3

    it_status = cpu_trap_mask_and_backup();
   140c0:	ebfff0f2 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& kernel_allocator . lock);
   140c4:	e59f4094 	ldr	r4, [pc, #148]	; 14160 <kernel_malloc+0xd0>
    check (invalid_argument, size != 0, NULL);

    nblocks = size / DNA_KERNEL_BLOCK_SIZE;
    nblocks += (((size - nblocks * DNA_KERNEL_BLOCK_SIZE) != 0) ? 1 : 0) + 1;

    it_status = cpu_trap_mask_and_backup();
   140c8:	e1a07000 	mov	r7, r0
    lock_acquire (& kernel_allocator . lock);
   140cc:	e1a00004 	mov	r0, r4
   140d0:	ebfff23a 	bl	109c0 <lock_acquire>

    status = kernel_region_create (nblocks, & region);
   140d4:	e1a00008 	mov	r0, r8
   140d8:	e28d1004 	add	r1, sp, #4
   140dc:	eb00005f 	bl	14260 <kernel_region_create>
    check (create_failed, status == DNA_OK, NULL);   
   140e0:	e2508000 	subs	r8, r0, #0
   140e4:	1a000017 	bne	14148 <kernel_malloc+0xb8>

    kernel_allocator . nblocks -= region -> nblocks;
   140e8:	e59d5004 	ldr	r5, [sp, #4]
   140ec:	e514200c 	ldr	r2, [r4, #-12]
   140f0:	e4953020 	ldr	r3, [r5], #32
    area = (uint8_t *)(region) + DNA_KERNEL_BLOCK_SIZE;

    lock_release (& kernel_allocator . lock);
   140f4:	e1a00004 	mov	r0, r4
    lock_acquire (& kernel_allocator . lock);

    status = kernel_region_create (nblocks, & region);
    check (create_failed, status == DNA_OK, NULL);   

    kernel_allocator . nblocks -= region -> nblocks;
   140f8:	e0633002 	rsb	r3, r3, r2
   140fc:	e504300c 	str	r3, [r4, #-12]
    area = (uint8_t *)(region) + DNA_KERNEL_BLOCK_SIZE;

    lock_release (& kernel_allocator . lock);
   14100:	ebfffce2 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   14104:	e1a00007 	mov	r0, r7
   14108:	ebfff119 	bl	10574 <cpu_trap_restore>

    if (erase) dna_memset (area, 0,
   1410c:	e3560000 	cmp	r6, #0
        DNA_KERNEL_BLOCK_SIZE * (region -> nblocks - 1));

    return (void *)area;
   14110:	01a00005 	moveq	r0, r5
    area = (uint8_t *)(region) + DNA_KERNEL_BLOCK_SIZE;

    lock_release (& kernel_allocator . lock);
    cpu_trap_restore(it_status);

    if (erase) dna_memset (area, 0,
   14114:	1a000001 	bne	14120 <kernel_malloc+0x90>

  rescue (invalid_argument)
  {
    leave;
  }
}
   14118:	e28dd008 	add	sp, sp, #8
   1411c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

    lock_release (& kernel_allocator . lock);
    cpu_trap_restore(it_status);

    if (erase) dna_memset (area, 0,
        DNA_KERNEL_BLOCK_SIZE * (region -> nblocks - 1));
   14120:	e59d3004 	ldr	r3, [sp, #4]
    area = (uint8_t *)(region) + DNA_KERNEL_BLOCK_SIZE;

    lock_release (& kernel_allocator . lock);
    cpu_trap_restore(it_status);

    if (erase) dna_memset (area, 0,
   14124:	e1a01008 	mov	r1, r8
        DNA_KERNEL_BLOCK_SIZE * (region -> nblocks - 1));
   14128:	e5932000 	ldr	r2, [r3]
    area = (uint8_t *)(region) + DNA_KERNEL_BLOCK_SIZE;

    lock_release (& kernel_allocator . lock);
    cpu_trap_restore(it_status);

    if (erase) dna_memset (area, 0,
   1412c:	e1a00005 	mov	r0, r5
        DNA_KERNEL_BLOCK_SIZE * (region -> nblocks - 1));
   14130:	e2422001 	sub	r2, r2, #1
    area = (uint8_t *)(region) + DNA_KERNEL_BLOCK_SIZE;

    lock_release (& kernel_allocator . lock);
    cpu_trap_restore(it_status);

    if (erase) dna_memset (area, 0,
   14134:	e1a02282 	lsl	r2, r2, #5
   14138:	ebffeccd 	bl	f474 <dna_memset>
        DNA_KERNEL_BLOCK_SIZE * (region -> nblocks - 1));

    return (void *)area;
   1413c:	e1a00005 	mov	r0, r5

  rescue (invalid_argument)
  {
    leave;
  }
}
   14140:	e28dd008 	add	sp, sp, #8
   14144:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    return (void *)area;
  }

  rescue (create_failed)
  {
    lock_release (& kernel_allocator . lock);
   14148:	e1a00004 	mov	r0, r4
   1414c:	ebfffccf 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   14150:	e1a00007 	mov	r0, r7
   14154:	ebfff106 	bl	10574 <cpu_trap_restore>
  }

  rescue (invalid_argument)
  {
    leave;
   14158:	e1a00005 	mov	r0, r5
   1415c:	eaffffed 	b	14118 <kernel_malloc+0x88>
   14160:	0018b93c 	.word	0x0018b93c

00014164 <kernel_free>:
  int32_t region_nblocks;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    check (invalid_argument, area != NULL, DNA_ERROR);
   14164:	e3500000 	cmp	r0, #0
   14168:	0a000015 	beq	141c4 <kernel_free+0x60>

    region = (kernel_region_t)((uint32_t)area - DNA_KERNEL_BLOCK_SIZE);
    region -> status = DNA_KERNEL_FREE_REGION;
   1416c:	e59f2058 	ldr	r2, [pc, #88]	; 141cc <kernel_free+0x68>
 * * DNA_OK if the operation succeeded.
 *
 * SOURCE
 */

{
   14170:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
  watch (status_t)
  {
    check (invalid_argument, area != NULL, DNA_ERROR);

    region = (kernel_region_t)((uint32_t)area - DNA_KERNEL_BLOCK_SIZE);
    region -> status = DNA_KERNEL_FREE_REGION;
   14174:	e500201c 	str	r2, [r0, #-28]
    region_nblocks = region -> nblocks;
   14178:	e5107020 	ldr	r7, [r0, #-32]

  watch (status_t)
  {
    check (invalid_argument, area != NULL, DNA_ERROR);

    region = (kernel_region_t)((uint32_t)area - DNA_KERNEL_BLOCK_SIZE);
   1417c:	e2405020 	sub	r5, r0, #32
    region -> status = DNA_KERNEL_FREE_REGION;
    region_nblocks = region -> nblocks;

    it_status = cpu_trap_mask_and_backup();
   14180:	ebfff0c2 	bl	10490 <cpu_trap_mask_and_backup>
    lock_acquire (& kernel_allocator . lock);
   14184:	e59f4044 	ldr	r4, [pc, #68]	; 141d0 <kernel_free+0x6c>

    region = (kernel_region_t)((uint32_t)area - DNA_KERNEL_BLOCK_SIZE);
    region -> status = DNA_KERNEL_FREE_REGION;
    region_nblocks = region -> nblocks;

    it_status = cpu_trap_mask_and_backup();
   14188:	e1a06000 	mov	r6, r0
    lock_acquire (& kernel_allocator . lock);
   1418c:	e1a00004 	mov	r0, r4
   14190:	ebfff20a 	bl	109c0 <lock_acquire>

    status = kernel_region_destroy (region);
   14194:	e1a00005 	mov	r0, r5
   14198:	ebffff55 	bl	13ef4 <kernel_region_destroy>
    if (status == DNA_OK) kernel_allocator . nblocks += region_nblocks;
   1419c:	e2505000 	subs	r5, r0, #0
   141a0:	0514300c 	ldreq	r3, [r4, #-12]

    lock_release (& kernel_allocator . lock);
   141a4:	e59f0024 	ldr	r0, [pc, #36]	; 141d0 <kernel_free+0x6c>

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& kernel_allocator . lock);

    status = kernel_region_destroy (region);
    if (status == DNA_OK) kernel_allocator . nblocks += region_nblocks;
   141a8:	00837007 	addeq	r7, r3, r7
   141ac:	0504700c 	streq	r7, [r4, #-12]

    lock_release (& kernel_allocator . lock);
   141b0:	ebfffcb6 	bl	13490 <lock_release>
    cpu_trap_restore(it_status);
   141b4:	e1a00006 	mov	r0, r6
   141b8:	ebfff0ed 	bl	10574 <cpu_trap_restore>
    region_nblocks = region -> nblocks;

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& kernel_allocator . lock);

    status = kernel_region_destroy (region);
   141bc:	e1a00005 	mov	r0, r5
    if (status == DNA_OK) kernel_allocator . nblocks += region_nblocks;

    lock_release (& kernel_allocator . lock);
    cpu_trap_restore(it_status);

    return status;
   141c0:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
  }

  rescue (invalid_argument)
  {
    leave;
   141c4:	e59f0008 	ldr	r0, [pc, #8]	; 141d4 <kernel_free+0x70>
   141c8:	e12fff1e 	bx	lr
   141cc:	0000beef 	.word	0x0000beef
   141d0:	0018b93c 	.word	0x0018b93c
   141d4:	0000ffff 	.word	0x0000ffff

000141d8 <memory_destroy>:
 */

{

  return DNA_NOT_IMPLEMENTED;
}
   141d8:	e59f0000 	ldr	r0, [pc]	; 141e0 <memory_destroy+0x8>
   141dc:	e12fff1e 	bx	lr
   141e0:	0000fffe 	.word	0x0000fffe

000141e4 <memory_create>:
 * - Initializes the kernel allocator.
 *
 * SOURCE
 */

{
   141e4:	e92d4008 	push	{r3, lr}

  /*
   * Initializes the BSS to 0
   */

  bss_size = (size_t) (CPU_BSS_END - CPU_BSS_START);
   141e8:	e59f2058 	ldr	r2, [pc, #88]	; 14248 <memory_create+0x64>
   141ec:	e59f3058 	ldr	r3, [pc, #88]	; 1424c <memory_create+0x68>
   141f0:	e5920000 	ldr	r0, [r2]
   141f4:	e5932000 	ldr	r2, [r3]
  dna_memset ((void *) CPU_BSS_START, 0, bss_size);
   141f8:	e3a01000 	mov	r1, #0
   141fc:	e0602002 	rsb	r2, r0, r2
   14200:	ebffec9b 	bl	f474 <dna_memset>
   */

  heap_size = OS_KERNEL_HEAP_SIZE / DNA_KERNEL_BLOCK_SIZE;

  region = (kernel_region_t) OS_KERNEL_HEAP_ADDRESS;
  region -> next = NULL;
   14204:	e3a00000 	mov	r0, #0

  /*
   * Initializes the kernel allocator
   */

  heap_size = OS_KERNEL_HEAP_SIZE / DNA_KERNEL_BLOCK_SIZE;
   14208:	e59f2040 	ldr	r2, [pc, #64]	; 14250 <memory_create+0x6c>

  region = (kernel_region_t) OS_KERNEL_HEAP_ADDRESS;
   1420c:	e59f3040 	ldr	r3, [pc, #64]	; 14254 <memory_create+0x70>

  /*
   * Initializes the kernel allocator
   */

  heap_size = OS_KERNEL_HEAP_SIZE / DNA_KERNEL_BLOCK_SIZE;
   14210:	e5921000 	ldr	r1, [r2]

  region = (kernel_region_t) OS_KERNEL_HEAP_ADDRESS;
   14214:	e5933000 	ldr	r3, [r3]
  region -> next = NULL;
  region -> prev = NULL;
  region -> nblocks = heap_size - 1;
  region -> status = DNA_KERNEL_FREE_REGION;

  kernel_allocator . next_free_region = region;
   14218:	e59f2038 	ldr	r2, [pc, #56]	; 14258 <memory_create+0x74>

  /*
   * Initializes the kernel allocator
   */

  heap_size = OS_KERNEL_HEAP_SIZE / DNA_KERNEL_BLOCK_SIZE;
   1421c:	e1a012a1 	lsr	r1, r1, #5

  region = (kernel_region_t) OS_KERNEL_HEAP_ADDRESS;
  region -> next = NULL;
  region -> prev = NULL;
  region -> nblocks = heap_size - 1;
  region -> status = DNA_KERNEL_FREE_REGION;
   14220:	e59fc034 	ldr	ip, [pc, #52]	; 1425c <memory_create+0x78>
  heap_size = OS_KERNEL_HEAP_SIZE / DNA_KERNEL_BLOCK_SIZE;

  region = (kernel_region_t) OS_KERNEL_HEAP_ADDRESS;
  region -> next = NULL;
  region -> prev = NULL;
  region -> nblocks = heap_size - 1;
   14224:	e241e001 	sub	lr, r1, #1
   14228:	e583e000 	str	lr, [r3]
  region -> status = DNA_KERNEL_FREE_REGION;
   1422c:	e583c004 	str	ip, [r3, #4]
   */

  heap_size = OS_KERNEL_HEAP_SIZE / DNA_KERNEL_BLOCK_SIZE;

  region = (kernel_region_t) OS_KERNEL_HEAP_ADDRESS;
  region -> next = NULL;
   14230:	e5830008 	str	r0, [r3, #8]
  region -> prev = NULL;
   14234:	e583000c 	str	r0, [r3, #12]
  region -> nblocks = heap_size - 1;
  region -> status = DNA_KERNEL_FREE_REGION;

  kernel_allocator . next_free_region = region;
  kernel_allocator . next_created_region = NULL;
  kernel_allocator . nblocks = heap_size;
   14238:	e5821000 	str	r1, [r2]
  region -> prev = NULL;
  region -> nblocks = heap_size - 1;
  region -> status = DNA_KERNEL_FREE_REGION;

  kernel_allocator . next_free_region = region;
  kernel_allocator . next_created_region = NULL;
   1423c:	e9820009 	stmib	r2, {r0, r3}
  kernel_allocator . nblocks = heap_size;
  kernel_allocator . lock = 0;
   14240:	e582000c 	str	r0, [r2, #12]

  return DNA_OK;
}
   14244:	e8bd8008 	pop	{r3, pc}
   14248:	0003e954 	.word	0x0003e954
   1424c:	0003e958 	.word	0x0003e958
   14250:	0003e940 	.word	0x0003e940
   14254:	0003e938 	.word	0x0003e938
   14258:	0018b930 	.word	0x0018b930
   1425c:	0000beef 	.word	0x0000beef

00014260 <kernel_region_create>:
 * of the memory, NULL otherwise.
 *
 * SOURCE
 */

{
   14260:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  kernel_region_t current_region = kernel_allocator . next_free_region;
   14264:	e59f413c 	ldr	r4, [pc, #316]	; 143a8 <kernel_region_create+0x148>
   14268:	e594c008 	ldr	ip, [r4, #8]
  kernel_region_t next_region = NULL, rptr = NULL, aptr = NULL;

  watch (status_t)
  {
    check (error_state, current_region != NULL, DNA_ERROR);
   1426c:	e35c0000 	cmp	ip, #0
   14270:	0a000033 	beq	14344 <kernel_region_create+0xe4>
    check (error_state, p_region != NULL, DNA_ERROR);
   14274:	e3510000 	cmp	r1, #0
   14278:	0a000031 	beq	14344 <kernel_region_create+0xe4>
    check (error_state, current_region -> nblocks > required_nblocks,
   1427c:	e59c2000 	ldr	r2, [ip]
   14280:	e1520000 	cmp	r2, r0
   14284:	9a00002c 	bls	1433c <kernel_region_create+0xdc>

    /*
     * Allocate the new region
     */

    if (current_region -> next != NULL) current_region -> next -> prev = NULL;
   14288:	e59c3008 	ldr	r3, [ip, #8]
   1428c:	e3530000 	cmp	r3, #0
   14290:	0a000036 	beq	14370 <kernel_region_create+0x110>
   14294:	e3a0e000 	mov	lr, #0
    kernel_allocator . next_free_region = current_region -> next;

    next_region = (kernel_region_t)((uint8_t *)current_region +
        (required_nblocks * DNA_KERNEL_BLOCK_SIZE));

    next_region -> status = DNA_KERNEL_FREE_REGION;
   14298:	e59f710c 	ldr	r7, [pc, #268]	; 143ac <kernel_region_create+0x14c>
    next_region -> nblocks = current_region -> nblocks - required_nblocks;
   1429c:	e0602002 	rsb	r2, r0, r2
     */

    if (current_region -> next != NULL) current_region -> next -> prev = NULL;
    kernel_allocator . next_free_region = current_region -> next;

    next_region = (kernel_region_t)((uint8_t *)current_region +
   142a0:	e08c5280 	add	r5, ip, r0, lsl #5
    next_region -> status = DNA_KERNEL_FREE_REGION;
    next_region -> nblocks = current_region -> nblocks - required_nblocks;

    current_region -> prev = NULL;
    current_region -> next = NULL;
    current_region -> status = DNA_KERNEL_ALLOCATED_REGION;
   142a4:	e59f6104 	ldr	r6, [pc, #260]	; 143b0 <kernel_region_create+0x150>

    /*
     * Allocate the new region
     */

    if (current_region -> next != NULL) current_region -> next -> prev = NULL;
   142a8:	e583e00c 	str	lr, [r3, #12]
    kernel_allocator . next_free_region = current_region -> next;
   142ac:	e5843008 	str	r3, [r4, #8]

    next_region = (kernel_region_t)((uint8_t *)current_region +
        (required_nblocks * DNA_KERNEL_BLOCK_SIZE));

    next_region -> status = DNA_KERNEL_FREE_REGION;
   142b0:	e5857004 	str	r7, [r5, #4]
    next_region -> nblocks = current_region -> nblocks - required_nblocks;
   142b4:	e78c2280 	str	r2, [ip, r0, lsl #5]

    current_region -> prev = NULL;
    current_region -> next = NULL;
    current_region -> status = DNA_KERNEL_ALLOCATED_REGION;
    current_region -> nblocks = required_nblocks;
   142b8:	e58c0000 	str	r0, [ip]
        (required_nblocks * DNA_KERNEL_BLOCK_SIZE));

    next_region -> status = DNA_KERNEL_FREE_REGION;
    next_region -> nblocks = current_region -> nblocks - required_nblocks;

    current_region -> prev = NULL;
   142bc:	e58ce00c 	str	lr, [ip, #12]
    current_region -> next = NULL;
   142c0:	e58ce008 	str	lr, [ip, #8]
   142c4:	e79ce280 	ldr	lr, [ip, r0, lsl #5]
    current_region -> status = DNA_KERNEL_ALLOCATED_REGION;
   142c8:	e58c6004 	str	r6, [ip, #4]
   142cc:	ea000002 	b	142dc <kernel_region_create+0x7c>
    }
    else
    {
      while (rptr -> next != NULL)
      {
        if (rptr -> nblocks <= next_region -> nblocks) break;
   142d0:	e150000e 	cmp	r0, lr
   142d4:	da00001c 	ble	1434c <kernel_region_create+0xec>
        rptr = rptr -> next;
   142d8:	e1a03002 	mov	r3, r2
      next_region -> prev = NULL;
      next_region -> next = NULL;
    }
    else
    {
      while (rptr -> next != NULL)
   142dc:	e5932008 	ldr	r2, [r3, #8]
      {
        if (rptr -> nblocks <= next_region -> nblocks) break;
   142e0:	e5930000 	ldr	r0, [r3]
      next_region -> prev = NULL;
      next_region -> next = NULL;
    }
    else
    {
      while (rptr -> next != NULL)
   142e4:	e3520000 	cmp	r2, #0
   142e8:	1afffff8 	bne	142d0 <kernel_region_create+0x70>
      {
        if (rptr -> nblocks <= next_region -> nblocks) break;
        rptr = rptr -> next;
      }

      if (rptr -> nblocks <= next_region -> nblocks)
   142ec:	e150000e 	cmp	r0, lr
          kernel_allocator . next_free_region = next_region;
        }
      }
      else
      {
        next_region -> next = NULL;
   142f0:	c5852008 	strgt	r2, [r5, #8]
        next_region -> prev = rptr;
   142f4:	c585300c 	strgt	r3, [r5, #12]
        rptr -> next = next_region;
   142f8:	c5835008 	strgt	r5, [r3, #8]
      {
        if (rptr -> nblocks <= next_region -> nblocks) break;
        rptr = rptr -> next;
      }

      if (rptr -> nblocks <= next_region -> nblocks)
   142fc:	da000012 	ble	1434c <kernel_region_create+0xec>

    /*
     * Add the allocated region to the list of created regions
     */

    aptr = kernel_allocator . next_created_region;
   14300:	e5942004 	ldr	r2, [r4, #4]
   14304:	e59f309c 	ldr	r3, [pc, #156]	; 143a8 <kernel_region_create+0x148>

    if (aptr == NULL)
   14308:	e3520000 	cmp	r2, #0
    {
      kernel_allocator . next_created_region = current_region;
   1430c:	0583c004 	streq	ip, [r3, #4]
     * Add the allocated region to the list of created regions
     */

    aptr = kernel_allocator . next_created_region;

    if (aptr == NULL)
   14310:	1a000001 	bne	1431c <kernel_region_create+0xbc>
   14314:	ea000005 	b	14330 <kernel_region_create+0xd0>
    {
      kernel_allocator . next_created_region = current_region;
    }
    else
    {
      while (aptr -> next != NULL) aptr = aptr -> next;
   14318:	e1a02003 	mov	r2, r3
   1431c:	e5923008 	ldr	r3, [r2, #8]
   14320:	e3530000 	cmp	r3, #0
   14324:	1afffffb 	bne	14318 <kernel_region_create+0xb8>
      aptr -> next = current_region;
   14328:	e582c008 	str	ip, [r2, #8]
      current_region -> prev = aptr;
   1432c:	e58c200c 	str	r2, [ip, #12]
    }

    *p_region = current_region;
   14330:	e581c000 	str	ip, [r1]
    return DNA_OK;
   14334:	e3a00000 	mov	r0, #0
   14338:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

  watch (status_t)
  {
    check (error_state, current_region != NULL, DNA_ERROR);
    check (error_state, p_region != NULL, DNA_ERROR);
    check (error_state, current_region -> nblocks > required_nblocks,
   1433c:	e59f0070 	ldr	r0, [pc, #112]	; 143b4 <kernel_region_create+0x154>
   14340:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  kernel_region_t current_region = kernel_allocator . next_free_region;
  kernel_region_t next_region = NULL, rptr = NULL, aptr = NULL;

  watch (status_t)
  {
    check (error_state, current_region != NULL, DNA_ERROR);
   14344:	e59f006c 	ldr	r0, [pc, #108]	; 143b8 <kernel_region_create+0x158>
   14348:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
        rptr = rptr -> next;
      }

      if (rptr -> nblocks <= next_region -> nblocks)
      {
        next_region -> prev = rptr -> prev;
   1434c:	e593200c 	ldr	r2, [r3, #12]
   14350:	e585200c 	str	r2, [r5, #12]
        rptr -> prev = next_region;
   14354:	e583500c 	str	r5, [r3, #12]
        next_region -> next = rptr;

        if (next_region -> prev != NULL)
   14358:	e595200c 	ldr	r2, [r5, #12]

      if (rptr -> nblocks <= next_region -> nblocks)
      {
        next_region -> prev = rptr -> prev;
        rptr -> prev = next_region;
        next_region -> next = rptr;
   1435c:	e5853008 	str	r3, [r5, #8]

        if (next_region -> prev != NULL)
   14360:	e3520000 	cmp	r2, #0
        {
          next_region -> prev -> next = next_region;
   14364:	15825008 	strne	r5, [r2, #8]
        }
        else
        {
          kernel_allocator . next_free_region = next_region;
   14368:	05845008 	streq	r5, [r4, #8]
   1436c:	eaffffe3 	b	14300 <kernel_region_create+0xa0>
    kernel_allocator . next_free_region = current_region -> next;

    next_region = (kernel_region_t)((uint8_t *)current_region +
        (required_nblocks * DNA_KERNEL_BLOCK_SIZE));

    next_region -> status = DNA_KERNEL_FREE_REGION;
   14370:	e59f6034 	ldr	r6, [pc, #52]	; 143ac <kernel_region_create+0x14c>
    next_region -> nblocks = current_region -> nblocks - required_nblocks;

    current_region -> prev = NULL;
    current_region -> next = NULL;
    current_region -> status = DNA_KERNEL_ALLOCATED_REGION;
   14374:	e59f5034 	ldr	r5, [pc, #52]	; 143b0 <kernel_region_create+0x150>
     */

    if (current_region -> next != NULL) current_region -> next -> prev = NULL;
    kernel_allocator . next_free_region = current_region -> next;

    next_region = (kernel_region_t)((uint8_t *)current_region +
   14378:	e08ce280 	add	lr, ip, r0, lsl #5
        (required_nblocks * DNA_KERNEL_BLOCK_SIZE));

    next_region -> status = DNA_KERNEL_FREE_REGION;
    next_region -> nblocks = current_region -> nblocks - required_nblocks;
   1437c:	e0602002 	rsb	r2, r0, r2
    kernel_allocator . next_free_region = current_region -> next;

    next_region = (kernel_region_t)((uint8_t *)current_region +
        (required_nblocks * DNA_KERNEL_BLOCK_SIZE));

    next_region -> status = DNA_KERNEL_FREE_REGION;
   14380:	e58e6004 	str	r6, [lr, #4]
    next_region -> nblocks = current_region -> nblocks - required_nblocks;
   14384:	e78c2280 	str	r2, [ip, r0, lsl #5]

    current_region -> prev = NULL;
    current_region -> next = NULL;
   14388:	e58c3008 	str	r3, [ip, #8]
    current_region -> status = DNA_KERNEL_ALLOCATED_REGION;
    current_region -> nblocks = required_nblocks;
   1438c:	e58c0000 	str	r0, [ip]
    next_region -> status = DNA_KERNEL_FREE_REGION;
    next_region -> nblocks = current_region -> nblocks - required_nblocks;

    current_region -> prev = NULL;
    current_region -> next = NULL;
    current_region -> status = DNA_KERNEL_ALLOCATED_REGION;
   14390:	e58c5004 	str	r5, [ip, #4]
        (required_nblocks * DNA_KERNEL_BLOCK_SIZE));

    next_region -> status = DNA_KERNEL_FREE_REGION;
    next_region -> nblocks = current_region -> nblocks - required_nblocks;

    current_region -> prev = NULL;
   14394:	e58c300c 	str	r3, [ip, #12]

    rptr = kernel_allocator . next_free_region;

    if (rptr == NULL)
    {
      kernel_allocator . next_free_region = next_region;
   14398:	e584e008 	str	lr, [r4, #8]
      next_region -> prev = NULL;
   1439c:	e58e300c 	str	r3, [lr, #12]
      next_region -> next = NULL;
   143a0:	e58e3008 	str	r3, [lr, #8]
   143a4:	eaffffd5 	b	14300 <kernel_region_create+0xa0>
   143a8:	0018b930 	.word	0x0018b930
   143ac:	0000beef 	.word	0x0000beef
   143b0:	0000dead 	.word	0x0000dead
   143b4:	0000fffd 	.word	0x0000fffd
   143b8:	0000ffff 	.word	0x0000ffff

000143bc <memory_start>:
 */

{

  return DNA_OK;
}
   143bc:	e3a00000 	mov	r0, #0
   143c0:	e12fff1e 	bx	lr

000143c4 <platform_debug_puts>:

void platform_debug_puts (char * string)
{
  char * p = string;

  while (*p != '\0')
   143c4:	e5d03000 	ldrb	r3, [r0]
   143c8:	e3530000 	cmp	r3, #0
   143cc:	012fff1e 	bxeq	lr
   143d0:	e59f1014 	ldr	r1, [pc, #20]	; 143ec <platform_debug_puts+0x28>
  {
    cpu_write (UINT8, PLATFORM_DEBUG_CHARPORT, *p++);
   143d4:	e5912000 	ldr	r2, [r1]
   143d8:	e5c23000 	strb	r3, [r2]

void platform_debug_puts (char * string)
{
  char * p = string;

  while (*p != '\0')
   143dc:	e5f03001 	ldrb	r3, [r0, #1]!
   143e0:	e3530000 	cmp	r3, #0
   143e4:	1afffffa 	bne	143d4 <platform_debug_puts+0x10>
   143e8:	e12fff1e 	bx	lr
   143ec:	0003e948 	.word	0x0003e948

000143f0 <system_kickstart>:
 * FUNCTION
 *
 * SOURCE
 */

{
   143f0:	e92d4070 	push	{r4, r5, r6, lr}
  watch (status_t)
  {
    if (cpu_mp_id() == 0)
   143f4:	ebfff07b 	bl	105e8 <cpu_mp_id>
   143f8:	e3500000 	cmp	r0, #0
   143fc:	1a000018 	bne	14464 <system_kickstart+0x74>

      /*
       * Create the components
       */

      status = memory_component . create ();
   14400:	e59f5070 	ldr	r5, [pc, #112]	; 14478 <system_kickstart+0x88>
   14404:	e5953004 	ldr	r3, [r5, #4]
   14408:	e12fff33 	blx	r3
      ensure (status == DNA_OK, status);
   1440c:	e3500000 	cmp	r0, #0
   14410:	18bd8070 	popne	{r4, r5, r6, pc}

      status = core_component . create ();
   14414:	e59f4060 	ldr	r4, [pc, #96]	; 1447c <system_kickstart+0x8c>
   14418:	e5943004 	ldr	r3, [r4, #4]
   1441c:	e12fff33 	blx	r3
      ensure (status == DNA_OK, status);
   14420:	e3500000 	cmp	r0, #0
   14424:	18bd8070 	popne	{r4, r5, r6, pc}

      status = vfs_component . create ();
   14428:	e59f6050 	ldr	r6, [pc, #80]	; 14480 <system_kickstart+0x90>
   1442c:	e5963004 	ldr	r3, [r6, #4]
   14430:	e12fff33 	blx	r3
      ensure (status == DNA_OK, status);
   14434:	e3500000 	cmp	r0, #0
   14438:	18bd8070 	popne	{r4, r5, r6, pc}
       * be in IDLE state to proceed correclty. TODO we should
       * probably find a way to wait ...
       */

      dna_log(INFO_LEVEL, "Starting DNA Operating System");
      cpu_mp_proceed ();
   1443c:	ebfff02c 	bl	104f4 <cpu_mp_proceed>

      status = memory_component . start ();
   14440:	e595300c 	ldr	r3, [r5, #12]
   14444:	e12fff33 	blx	r3
      ensure (status == DNA_OK, status);
   14448:	e3500000 	cmp	r0, #0
   1444c:	18bd8070 	popne	{r4, r5, r6, pc}

      status = vfs_component . start ();
   14450:	e596300c 	ldr	r3, [r6, #12]
   14454:	e12fff33 	blx	r3
      ensure (status == DNA_OK, status);
   14458:	e3500000 	cmp	r0, #0
   1445c:	0a000002 	beq	1446c <system_kickstart+0x7c>
   14460:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else cpu_mp_wait();
   14464:	ebfff053 	bl	105b8 <cpu_mp_wait>
   14468:	e59f400c 	ldr	r4, [pc, #12]	; 1447c <system_kickstart+0x8c>

    return core_component . start ();
   1446c:	e594300c 	ldr	r3, [r4, #12]
  }
}
   14470:	e8bd4070 	pop	{r4, r5, r6, lr}
      status = vfs_component . start ();
      ensure (status == DNA_OK, status);
    }
    else cpu_mp_wait();

    return core_component . start ();
   14474:	e12fff13 	bx	r3
   14478:	0003dffc 	.word	0x0003dffc
   1447c:	0003dfe8 	.word	0x0003dfe8
   14480:	0003dfd0 	.word	0x0003dfd0

00014484 <__aeabi_uidiv>:
	ARM_FUNC_ALIAS aeabi_uidiv udivsi3

	/* Note: if called via udivsi3_skip_div0_test, this will unnecessarily
	   check for division-by-zero a second time.  */
LSYM(udivsi3_skip_div0_test):
	subs	r2, r1, #1
   14484:	e2512001 	subs	r2, r1, #1
	do_it	eq
	RETc(eq)
   14488:	012fff1e 	bxeq	lr
	bcc	LSYM(Ldiv0)
   1448c:	3a000036 	bcc	1456c <__aeabi_uidiv+0xe8>
	cmp	r0, r1
   14490:	e1500001 	cmp	r0, r1
	bls	11f
   14494:	9a000022 	bls	14524 <__aeabi_uidiv+0xa0>
	tst	r1, r2
   14498:	e1110002 	tst	r1, r2
	beq	12f
   1449c:	0a000023 	beq	14530 <__aeabi_uidiv+0xac>
	mov	\divisor, \divisor, lsl \result
	mov	\curbit, \curbit, lsl \result
	mov	\result, #0
	
#else /* __ARM_ARCH__ < 5 */

   144a0:	e311020e 	tst	r1, #-536870912	; 0xe0000000
   144a4:	01a01181 	lsleq	r1, r1, #3
   144a8:	03a03008 	moveq	r3, #8
   144ac:	13a03001 	movne	r3, #1
   144b0:	e3510201 	cmp	r1, #268435456	; 0x10000000
   144b4:	31510000 	cmpcc	r1, r0
   144b8:	31a01201 	lslcc	r1, r1, #4
   144bc:	31a03203 	lslcc	r3, r3, #4
   144c0:	3afffffa 	bcc	144b0 <__aeabi_uidiv+0x2c>
   144c4:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   144c8:	31510000 	cmpcc	r1, r0
   144cc:	31a01081 	lslcc	r1, r1, #1
   144d0:	31a03083 	lslcc	r3, r3, #1
   144d4:	3afffffa 	bcc	144c4 <__aeabi_uidiv+0x40>
   144d8:	e3a02000 	mov	r2, #0
   144dc:	e1500001 	cmp	r0, r1
   144e0:	20400001 	subcs	r0, r0, r1
   144e4:	21822003 	orrcs	r2, r2, r3
   144e8:	e15000a1 	cmp	r0, r1, lsr #1
   144ec:	204000a1 	subcs	r0, r0, r1, lsr #1
   144f0:	218220a3 	orrcs	r2, r2, r3, lsr #1
   144f4:	e1500121 	cmp	r0, r1, lsr #2
   144f8:	20400121 	subcs	r0, r0, r1, lsr #2
   144fc:	21822123 	orrcs	r2, r2, r3, lsr #2
   14500:	e15001a1 	cmp	r0, r1, lsr #3
   14504:	204001a1 	subcs	r0, r0, r1, lsr #3
   14508:	218221a3 	orrcs	r2, r2, r3, lsr #3
   1450c:	e3500000 	cmp	r0, #0
   14510:	11b03223 	lsrsne	r3, r3, #4
   14514:	11a01221 	lsrne	r1, r1, #4
   14518:	1affffef 	bne	144dc <__aeabi_uidiv+0x58>
	tst	r1, r2
	beq	12f
	
	ARM_DIV_BODY r0, r1, r2, r3
	
	mov	r0, r2
   1451c:	e1a00002 	mov	r0, r2
	RET	
   14520:	e12fff1e 	bx	lr

11:	do_it	eq, e
	moveq	r0, #1
   14524:	03a00001 	moveq	r0, #1
	movne	r0, #0
   14528:	13a00000 	movne	r0, #0
	RET
   1452c:	e12fff1e 	bx	lr

	clz	\order, \divisor
	rsb	\order, \order, #31

#else

   14530:	e3510801 	cmp	r1, #65536	; 0x10000
   14534:	21a01821 	lsrcs	r1, r1, #16
   14538:	23a02010 	movcs	r2, #16
   1453c:	33a02000 	movcc	r2, #0
   14540:	e3510c01 	cmp	r1, #256	; 0x100
   14544:	21a01421 	lsrcs	r1, r1, #8
   14548:	22822008 	addcs	r2, r2, #8
   1454c:	e3510010 	cmp	r1, #16
   14550:	21a01221 	lsrcs	r1, r1, #4
   14554:	22822004 	addcs	r2, r2, #4
   14558:	e3510004 	cmp	r1, #4
   1455c:	82822003 	addhi	r2, r2, #3
   14560:	908220a1 	addls	r2, r2, r1, lsr #1
	movne	r0, #0
	RET

12:	ARM_DIV2_ORDER r1, r2

	mov	r0, r0, lsr r2
   14564:	e1a00230 	lsr	r0, r0, r2
	RET
   14568:	e12fff1e 	bx	lr

#endif /* ARM version */

	DIV_FUNC_END udivsi3 unsigned
   1456c:	e3500000 	cmp	r0, #0
   14570:	13e00000 	mvnne	r0, #0
   14574:	ea000059 	b	146e0 <__aeabi_idiv0>

00014578 <__aeabi_uidivmod>:
	udiv	r0, r0, r1
	mls     r1, r0, r1, r2
	RET
#else
ARM_FUNC_START aeabi_uidivmod
	cmp	r1, #0
   14578:	e3510000 	cmp	r1, #0
	beq	LSYM(Ldiv0)
   1457c:	0afffffa 	beq	1456c <__aeabi_uidiv+0xe8>
	stmfd	sp!, { r0, r1, lr }
   14580:	e92d4003 	push	{r0, r1, lr}
	bl	LSYM(udivsi3_skip_div0_test)
   14584:	ebffffbe 	bl	14484 <__aeabi_uidiv>
	ldmfd	sp!, { r1, r2, lr }
   14588:	e8bd4006 	pop	{r1, r2, lr}
	mul	r3, r2, r0
   1458c:	e0030092 	mul	r3, r2, r0
	sub	r1, r1, r3
   14590:	e0411003 	sub	r1, r1, r3
	RET
   14594:	e12fff1e 	bx	lr

00014598 <__aeabi_idiv>:
#else /* ARM/Thumb-2 version.  */
	
	ARM_FUNC_START divsi3	
	ARM_FUNC_ALIAS aeabi_idiv divsi3

	cmp	r1, #0
   14598:	e3510000 	cmp	r1, #0
	beq	LSYM(Ldiv0)
   1459c:	0a000043 	beq	146b0 <.divsi3_skip_div0_test+0x110>

000145a0 <.divsi3_skip_div0_test>:
LSYM(divsi3_skip_div0_test):
	eor	ip, r0, r1			@ save the sign of the result.
   145a0:	e020c001 	eor	ip, r0, r1
	do_it	mi
	rsbmi	r1, r1, #0			@ loops below use unsigned.
   145a4:	42611000 	rsbmi	r1, r1, #0
	subs	r2, r1, #1			@ division by 1 or -1 ?
   145a8:	e2512001 	subs	r2, r1, #1
	beq	10f
   145ac:	0a000027 	beq	14650 <.divsi3_skip_div0_test+0xb0>
	movs	r3, r0
   145b0:	e1b03000 	movs	r3, r0
	do_it	mi
	rsbmi	r3, r0, #0			@ positive dividend value
   145b4:	42603000 	rsbmi	r3, r0, #0
	cmp	r3, r1
   145b8:	e1530001 	cmp	r3, r1
	bls	11f
   145bc:	9a000026 	bls	1465c <.divsi3_skip_div0_test+0xbc>
	tst	r1, r2				@ divisor is power of 2 ?
   145c0:	e1110002 	tst	r1, r2
	beq	12f
   145c4:	0a000028 	beq	1466c <.divsi3_skip_div0_test+0xcc>
	mov	\divisor, \divisor, lsl \result
	mov	\curbit, \curbit, lsl \result
	mov	\result, #0
	
#else /* __ARM_ARCH__ < 5 */

   145c8:	e311020e 	tst	r1, #-536870912	; 0xe0000000
   145cc:	01a01181 	lsleq	r1, r1, #3
   145d0:	03a02008 	moveq	r2, #8
   145d4:	13a02001 	movne	r2, #1
   145d8:	e3510201 	cmp	r1, #268435456	; 0x10000000
   145dc:	31510003 	cmpcc	r1, r3
   145e0:	31a01201 	lslcc	r1, r1, #4
   145e4:	31a02202 	lslcc	r2, r2, #4
   145e8:	3afffffa 	bcc	145d8 <.divsi3_skip_div0_test+0x38>
   145ec:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
   145f0:	31510003 	cmpcc	r1, r3
   145f4:	31a01081 	lslcc	r1, r1, #1
   145f8:	31a02082 	lslcc	r2, r2, #1
   145fc:	3afffffa 	bcc	145ec <.divsi3_skip_div0_test+0x4c>
   14600:	e3a00000 	mov	r0, #0
   14604:	e1530001 	cmp	r3, r1
   14608:	20433001 	subcs	r3, r3, r1
   1460c:	21800002 	orrcs	r0, r0, r2
   14610:	e15300a1 	cmp	r3, r1, lsr #1
   14614:	204330a1 	subcs	r3, r3, r1, lsr #1
   14618:	218000a2 	orrcs	r0, r0, r2, lsr #1
   1461c:	e1530121 	cmp	r3, r1, lsr #2
   14620:	20433121 	subcs	r3, r3, r1, lsr #2
   14624:	21800122 	orrcs	r0, r0, r2, lsr #2
   14628:	e15301a1 	cmp	r3, r1, lsr #3
   1462c:	204331a1 	subcs	r3, r3, r1, lsr #3
   14630:	218001a2 	orrcs	r0, r0, r2, lsr #3
   14634:	e3530000 	cmp	r3, #0
   14638:	11b02222 	lsrsne	r2, r2, #4
   1463c:	11a01221 	lsrne	r1, r1, #4
   14640:	1affffef 	bne	14604 <.divsi3_skip_div0_test+0x64>
	tst	r1, r2				@ divisor is power of 2 ?
	beq	12f

	ARM_DIV_BODY r3, r1, r0, r2
	
	cmp	ip, #0
   14644:	e35c0000 	cmp	ip, #0
	do_it	mi
	rsbmi	r0, r0, #0
   14648:	42600000 	rsbmi	r0, r0, #0
	RET	
   1464c:	e12fff1e 	bx	lr

10:	teq	ip, r0				@ same sign ?
   14650:	e13c0000 	teq	ip, r0
	do_it	mi
	rsbmi	r0, r0, #0
   14654:	42600000 	rsbmi	r0, r0, #0
	RET	
   14658:	e12fff1e 	bx	lr

11:	do_it	lo
	movlo	r0, #0
   1465c:	33a00000 	movcc	r0, #0
	do_it	eq,t
	moveq	r0, ip, asr #31
   14660:	01a00fcc 	asreq	r0, ip, #31
	orreq	r0, r0, #1
   14664:	03800001 	orreq	r0, r0, #1
	RET
   14668:	e12fff1e 	bx	lr

	clz	\order, \divisor
	rsb	\order, \order, #31

#else

   1466c:	e3510801 	cmp	r1, #65536	; 0x10000
   14670:	21a01821 	lsrcs	r1, r1, #16
   14674:	23a02010 	movcs	r2, #16
   14678:	33a02000 	movcc	r2, #0
   1467c:	e3510c01 	cmp	r1, #256	; 0x100
   14680:	21a01421 	lsrcs	r1, r1, #8
   14684:	22822008 	addcs	r2, r2, #8
   14688:	e3510010 	cmp	r1, #16
   1468c:	21a01221 	lsrcs	r1, r1, #4
   14690:	22822004 	addcs	r2, r2, #4
   14694:	e3510004 	cmp	r1, #4
   14698:	82822003 	addhi	r2, r2, #3
   1469c:	908220a1 	addls	r2, r2, r1, lsr #1
	orreq	r0, r0, #1
	RET

12:	ARM_DIV2_ORDER r1, r2

	cmp	ip, #0
   146a0:	e35c0000 	cmp	ip, #0
	mov	r0, r3, lsr r2
   146a4:	e1a00233 	lsr	r0, r3, r2
	do_it	mi
	rsbmi	r0, r0, #0
   146a8:	42600000 	rsbmi	r0, r0, #0
	RET
   146ac:	e12fff1e 	bx	lr

#endif /* ARM version */
	
	DIV_FUNC_END divsi3 signed
   146b0:	e3500000 	cmp	r0, #0
   146b4:	c3e00102 	mvngt	r0, #-2147483648	; 0x80000000
   146b8:	b3a00102 	movlt	r0, #-2147483648	; 0x80000000
   146bc:	ea000007 	b	146e0 <__aeabi_idiv0>

000146c0 <__aeabi_idivmod>:
	sdiv	r0, r0, r1
	mls     r1, r0, r1, r2
	RET
#else
ARM_FUNC_START aeabi_idivmod
	cmp	r1, #0
   146c0:	e3510000 	cmp	r1, #0
	beq	LSYM(Ldiv0)
   146c4:	0afffff9 	beq	146b0 <.divsi3_skip_div0_test+0x110>
	stmfd	sp!, { r0, r1, lr }
   146c8:	e92d4003 	push	{r0, r1, lr}
	bl	LSYM(divsi3_skip_div0_test)
   146cc:	ebffffb3 	bl	145a0 <.divsi3_skip_div0_test>
	ldmfd	sp!, { r1, r2, lr }
   146d0:	e8bd4006 	pop	{r1, r2, lr}
	mul	r3, r2, r0
   146d4:	e0030092 	mul	r3, r2, r0
	sub	r1, r1, r3
   146d8:	e0411003 	sub	r1, r1, r3
	RET
   146dc:	e12fff1e 	bx	lr

000146e0 <__aeabi_idiv0>:
#ifdef __ARM_EABI__
	WEAK aeabi_idiv0
	WEAK aeabi_ldiv0
	FUNC_START aeabi_idiv0
	FUNC_START aeabi_ldiv0
	RET
   146e0:	e12fff1e 	bx	lr

000146e4 <__aeabi_drsub>:

#ifdef L_arm_addsubdf3

ARM_FUNC_START aeabi_drsub

	eor	xh, xh, #0x80000000	@ flip sign bit of first arg
   146e4:	e2211102 	eor	r1, r1, #-2147483648	; 0x80000000
	b	1f	
   146e8:	ea000000 	b	146f0 <__adddf3>

000146ec <__aeabi_dsub>:

ARM_FUNC_START subdf3
ARM_FUNC_ALIAS aeabi_dsub subdf3

	eor	yh, yh, #0x80000000	@ flip sign bit of second arg
   146ec:	e2233102 	eor	r3, r3, #-2147483648	; 0x80000000

000146f0 <__adddf3>:
#endif

ARM_FUNC_START adddf3
ARM_FUNC_ALIAS aeabi_dadd adddf3

1:	do_push	{r4, r5, lr}
   146f0:	e92d4030 	push	{r4, r5, lr}

	@ Look for zeroes, equal values, INF, or NAN.
	shift1	lsl, r4, xh, #1
   146f4:	e1a04081 	lsl	r4, r1, #1
	shift1	lsl, r5, yh, #1
   146f8:	e1a05083 	lsl	r5, r3, #1
	teq	r4, r5
   146fc:	e1340005 	teq	r4, r5
	do_it	eq
	teqeq	xl, yl
   14700:	01300002 	teqeq	r0, r2
	do_it	ne, ttt
	COND(orr,s,ne)	ip, r4, xl
   14704:	1194c000 	orrsne	ip, r4, r0
	COND(orr,s,ne)	ip, r5, yl
   14708:	1195c002 	orrsne	ip, r5, r2
	COND(mvn,s,ne)	ip, r4, asr #21
   1470c:	11f0cac4 	mvnsne	ip, r4, asr #21
	COND(mvn,s,ne)	ip, r5, asr #21
   14710:	11f0cac5 	mvnsne	ip, r5, asr #21
	beq	LSYM(Lad_s)
   14714:	0a00008c 	beq	1494c <__adddf3+0x25c>

	@ Compute exponent difference.  Make largest exponent in r4,
	@ corresponding arg in xh-xl, and positive exponent difference in r5.
	shift1	lsr, r4, r4, #21
   14718:	e1a04aa4 	lsr	r4, r4, #21
	rsbs	r5, r4, r5, lsr #21
   1471c:	e0745aa5 	rsbs	r5, r4, r5, lsr #21
	do_it	lt
	rsblt	r5, r5, #0
   14720:	b2655000 	rsblt	r5, r5, #0
	ble	1f
   14724:	da000006 	ble	14744 <__adddf3+0x54>
	add	r4, r4, r5
   14728:	e0844005 	add	r4, r4, r5
	eor	yl, xl, yl
   1472c:	e0202002 	eor	r2, r0, r2
	eor	yh, xh, yh
   14730:	e0213003 	eor	r3, r1, r3
	eor	xl, yl, xl
   14734:	e0220000 	eor	r0, r2, r0
	eor	xh, yh, xh
   14738:	e0231001 	eor	r1, r3, r1
	eor	yl, xl, yl
   1473c:	e0202002 	eor	r2, r0, r2
	eor	yh, xh, yh
   14740:	e0213003 	eor	r3, r1, r3
1:
	@ If exponent difference is too large, return largest argument
	@ already in xh-xl.  We need up to 54 bit to handle proper rounding
	@ of 0x1p54 - 1.1.
	cmp	r5, #54
   14744:	e3550036 	cmp	r5, #54	; 0x36
	do_it	hi
	RETLDM	"r4, r5" hi
   14748:	88bd4030 	pophi	{r4, r5, lr}
   1474c:	812fff1e 	bxhi	lr

	@ Convert mantissa to signed integer.
	tst	xh, #0x80000000
   14750:	e3110102 	tst	r1, #-2147483648	; 0x80000000
	mov	xh, xh, lsl #12
   14754:	e1a01601 	lsl	r1, r1, #12
	mov	ip, #0x00100000
   14758:	e3a0c601 	mov	ip, #1048576	; 0x100000
	orr	xh, ip, xh, lsr #12
   1475c:	e18c1621 	orr	r1, ip, r1, lsr #12
	beq	1f
   14760:	0a000001 	beq	1476c <__adddf3+0x7c>
#if defined(__thumb2__)
	negs	xl, xl
	sbc	xh, xh, xh, lsl #1
#else
	rsbs	xl, xl, #0
   14764:	e2700000 	rsbs	r0, r0, #0
	rsc	xh, xh, #0
   14768:	e2e11000 	rsc	r1, r1, #0
#endif
1:
	tst	yh, #0x80000000
   1476c:	e3130102 	tst	r3, #-2147483648	; 0x80000000
	mov	yh, yh, lsl #12
   14770:	e1a03603 	lsl	r3, r3, #12
	orr	yh, ip, yh, lsr #12
   14774:	e18c3623 	orr	r3, ip, r3, lsr #12
	beq	1f
   14778:	0a000001 	beq	14784 <__adddf3+0x94>
#if defined(__thumb2__)
	negs	yl, yl
	sbc	yh, yh, yh, lsl #1
#else
	rsbs	yl, yl, #0
   1477c:	e2722000 	rsbs	r2, r2, #0
	rsc	yh, yh, #0
   14780:	e2e33000 	rsc	r3, r3, #0
#endif
1:
	@ If exponent == difference, one or both args were denormalized.
	@ Since this is not common case, rescale them off line.
	teq	r4, r5
   14784:	e1340005 	teq	r4, r5
	beq	LSYM(Lad_d)
   14788:	0a000069 	beq	14934 <__adddf3+0x244>
LSYM(Lad_x):

	@ Compensate for the exponent overlapping the mantissa MSB added later
	sub	r4, r4, #1
   1478c:	e2444001 	sub	r4, r4, #1

	@ Shift yh-yl right per r5, add to xh-xl, keep leftover bits into ip.
	rsbs	lr, r5, #32
   14790:	e275e020 	rsbs	lr, r5, #32
	blt	1f
   14794:	ba000005 	blt	147b0 <__adddf3+0xc0>
	shift1	lsl, ip, yl, lr
   14798:	e1a0ce12 	lsl	ip, r2, lr
	shiftop adds xl xl yl lsr r5 yl
   1479c:	e0900532 	adds	r0, r0, r2, lsr r5
	adc	xh, xh, #0
   147a0:	e2a11000 	adc	r1, r1, #0
	shiftop adds xl xl yh lsl lr yl
   147a4:	e0900e13 	adds	r0, r0, r3, lsl lr
	shiftop adcs xh xh yh asr r5 yh
   147a8:	e0b11553 	adcs	r1, r1, r3, asr r5
	b	2f
   147ac:	ea000006 	b	147cc <__adddf3+0xdc>
1:	sub	r5, r5, #32
   147b0:	e2455020 	sub	r5, r5, #32
	add	lr, lr, #32
   147b4:	e28ee020 	add	lr, lr, #32
	cmp	yl, #1
   147b8:	e3520001 	cmp	r2, #1
	shift1	lsl,ip, yh, lr
   147bc:	e1a0ce13 	lsl	ip, r3, lr
	do_it	cs
	orrcs	ip, ip, #2		@ 2 not 1, to allow lsr #1 later
   147c0:	238cc002 	orrcs	ip, ip, #2
	shiftop adds xl xl yh asr r5 yh
   147c4:	e0900553 	adds	r0, r0, r3, asr r5
	adcs	xh, xh, yh, asr #31
   147c8:	e0b11fc3 	adcs	r1, r1, r3, asr #31
2:
	@ We now have a result in xh-xl-ip.
	@ Keep absolute value in xh-xl-ip, sign in r5 (the n bit was set above)
	and	r5, xh, #0x80000000
   147cc:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
	bpl	LSYM(Lad_p)
   147d0:	5a000002 	bpl	147e0 <__adddf3+0xf0>
	mov	lr, #0
	negs	ip, ip
	sbcs	xl, lr, xl
	sbc	xh, lr, xh
#else
	rsbs	ip, ip, #0
   147d4:	e27cc000 	rsbs	ip, ip, #0
	rscs	xl, xl, #0
   147d8:	e2f00000 	rscs	r0, r0, #0
	rsc	xh, xh, #0
   147dc:	e2e11000 	rsc	r1, r1, #0
#endif

	@ Determine how to normalize the result.
LSYM(Lad_p):
	cmp	xh, #0x00100000
   147e0:	e3510601 	cmp	r1, #1048576	; 0x100000
	bcc	LSYM(Lad_a)
   147e4:	3a00000f 	bcc	14828 <__adddf3+0x138>
	cmp	xh, #0x00200000
   147e8:	e3510602 	cmp	r1, #2097152	; 0x200000
	bcc	LSYM(Lad_e)
   147ec:	3a000006 	bcc	1480c <__adddf3+0x11c>

	@ Result needs to be shifted right.
	movs	xh, xh, lsr #1
   147f0:	e1b010a1 	lsrs	r1, r1, #1
	movs	xl, xl, rrx
   147f4:	e1b00060 	rrxs	r0, r0
	mov	ip, ip, rrx
   147f8:	e1a0c06c 	rrx	ip, ip
	add	r4, r4, #1
   147fc:	e2844001 	add	r4, r4, #1

	@ Make sure we did not bust our exponent.
	mov	r2, r4, lsl #21
   14800:	e1a02a84 	lsl	r2, r4, #21
	cmn	r2, #(2 << 21)
   14804:	e3720501 	cmn	r2, #4194304	; 0x400000
	bcs	LSYM(Lad_o)
   14808:	2a00006b 	bcs	149bc <__adddf3+0x2cc>
	@ Our result is now properly aligned into xh-xl, remaining bits in ip.
	@ Round with MSB of ip. If halfway between two numbers, round towards
	@ LSB of xl = 0.
	@ Pack final result together.
LSYM(Lad_e):
	cmp	ip, #0x80000000
   1480c:	e35c0102 	cmp	ip, #-2147483648	; 0x80000000
	do_it	eq
	COND(mov,s,eq)	ip, xl, lsr #1
   14810:	01b0c0a0 	lsrseq	ip, r0, #1
	adcs	xl, xl, #0
   14814:	e2b00000 	adcs	r0, r0, #0
	adc	xh, xh, r4, lsl #20
   14818:	e0a11a04 	adc	r1, r1, r4, lsl #20
	orr	xh, xh, r5
   1481c:	e1811005 	orr	r1, r1, r5
	RETLDM	"r4, r5"
   14820:	e8bd4030 	pop	{r4, r5, lr}
   14824:	e12fff1e 	bx	lr

	@ Result must be shifted left and exponent adjusted.
LSYM(Lad_a):
	movs	ip, ip, lsl #1
   14828:	e1b0c08c 	lsls	ip, ip, #1
	adcs	xl, xl, xl
   1482c:	e0b00000 	adcs	r0, r0, r0
	adc	xh, xh, xh
   14830:	e0a11001 	adc	r1, r1, r1
	tst	xh, #0x00100000
   14834:	e3110601 	tst	r1, #1048576	; 0x100000
	sub	r4, r4, #1
   14838:	e2444001 	sub	r4, r4, #1
	bne	LSYM(Lad_e)
   1483c:	1afffff2 	bne	1480c <__adddf3+0x11c>
	@ No rounding necessary since ip will always be 0 at this point.
LSYM(Lad_l):

#if __ARM_ARCH__ < 5

	teq	xh, #0
   14840:	e3310000 	teq	r1, #0
	movne	r3, #20
   14844:	13a03014 	movne	r3, #20
	moveq	r3, #52
   14848:	03a03034 	moveq	r3, #52	; 0x34
	moveq	xh, xl
   1484c:	01a01000 	moveq	r1, r0
	moveq	xl, #0
   14850:	03a00000 	moveq	r0, #0
	mov	r2, xh
   14854:	e1a02001 	mov	r2, r1
	cmp	r2, #(1 << 16)
   14858:	e3520801 	cmp	r2, #65536	; 0x10000
	movhs	r2, r2, lsr #16
   1485c:	21a02822 	lsrcs	r2, r2, #16
	subhs	r3, r3, #16
   14860:	22433010 	subcs	r3, r3, #16
	cmp	r2, #(1 << 8)
   14864:	e3520c01 	cmp	r2, #256	; 0x100
	movhs	r2, r2, lsr #8
   14868:	21a02422 	lsrcs	r2, r2, #8
	subhs	r3, r3, #8
   1486c:	22433008 	subcs	r3, r3, #8
	cmp	r2, #(1 << 4)
   14870:	e3520010 	cmp	r2, #16
	movhs	r2, r2, lsr #4
   14874:	21a02222 	lsrcs	r2, r2, #4
	subhs	r3, r3, #4
   14878:	22433004 	subcs	r3, r3, #4
	cmp	r2, #(1 << 2)
   1487c:	e3520004 	cmp	r2, #4
	subhs	r3, r3, #2
   14880:	22433002 	subcs	r3, r3, #2
	sublo	r3, r3, r2, lsr #1
   14884:	304330a2 	subcc	r3, r3, r2, lsr #1
	sub	r3, r3, r2, lsr #3
   14888:	e04331a2 	sub	r3, r3, r2, lsr #3
	sub	r3, r3, #11

#endif

	@ determine how to shift the value.
	subs	r2, r3, #32
   1488c:	e2532020 	subs	r2, r3, #32
	bge	2f
   14890:	aa000007 	bge	148b4 <__adddf3+0x1c4>
	adds	r2, r2, #12
   14894:	e292200c 	adds	r2, r2, #12
	ble	1f
   14898:	da000004 	ble	148b0 <__adddf3+0x1c0>

	@ shift value left 21 to 31 bits, or actually right 11 to 1 bits
	@ since a register switch happened above.
	add	ip, r2, #20
   1489c:	e282c014 	add	ip, r2, #20
	rsb	r2, r2, #12
   148a0:	e262200c 	rsb	r2, r2, #12
	shift1	lsl, xl, xh, ip
   148a4:	e1a00c11 	lsl	r0, r1, ip
	shift1	lsr, xh, xh, r2
   148a8:	e1a01231 	lsr	r1, r1, r2
	b	3f
   148ac:	ea000004 	b	148c4 <__adddf3+0x1d4>

	@ actually shift value left 1 to 20 bits, which might also represent
	@ 32 to 52 bits if counting the register switch that happened earlier.
1:	add	r2, r2, #20
   148b0:	e2822014 	add	r2, r2, #20
2:	do_it	le
	rsble	ip, r2, #32
   148b4:	d262c020 	rsble	ip, r2, #32
	shift1	lsl, xh, xh, r2
   148b8:	e1a01211 	lsl	r1, r1, r2
	lsr	ip, xl, ip
	itt	le
	orrle	xh, xh, ip
	lslle	xl, xl, r2
#else
	orrle	xh, xh, xl, lsr ip
   148bc:	d1811c30 	orrle	r1, r1, r0, lsr ip
	movle	xl, xl, lsl r2
   148c0:	d1a00210 	lslle	r0, r0, r2
#endif

	@ adjust exponent accordingly.
3:	subs	r4, r4, r3
   148c4:	e0544003 	subs	r4, r4, r3
	do_it	ge, tt
	addge	xh, xh, r4, lsl #20
   148c8:	a0811a04 	addge	r1, r1, r4, lsl #20
	orrge	xh, xh, r5
   148cc:	a1811005 	orrge	r1, r1, r5
	RETLDM	"r4, r5" ge
   148d0:	a8bd4030 	popge	{r4, r5, lr}
   148d4:	a12fff1e 	bxge	lr

	@ Exponent too small, denormalize result.
	@ Find out proper shift value.
	mvn	r4, r4
   148d8:	e1e04004 	mvn	r4, r4
	subs	r4, r4, #31
   148dc:	e254401f 	subs	r4, r4, #31
	bge	2f
   148e0:	aa00000f 	bge	14924 <__adddf3+0x234>
	adds	r4, r4, #12
   148e4:	e294400c 	adds	r4, r4, #12
	bgt	1f
   148e8:	ca000006 	bgt	14908 <__adddf3+0x218>

	@ shift result right of 1 to 20 bits, sign is in r5.
	add	r4, r4, #20
   148ec:	e2844014 	add	r4, r4, #20
	rsb	r2, r4, #32
   148f0:	e2642020 	rsb	r2, r4, #32
	shift1	lsr, xl, xl, r4
   148f4:	e1a00430 	lsr	r0, r0, r4
	shiftop orr xl xl xh lsl r2 yh
   148f8:	e1800211 	orr	r0, r0, r1, lsl r2
	shiftop orr xh r5 xh lsr r4 yh
   148fc:	e1851431 	orr	r1, r5, r1, lsr r4
	RETLDM	"r4, r5"
   14900:	e8bd4030 	pop	{r4, r5, lr}
   14904:	e12fff1e 	bx	lr

	@ shift result right of 21 to 31 bits, or left 11 to 1 bits after
	@ a register switch from xh to xl.
1:	rsb	r4, r4, #12
   14908:	e264400c 	rsb	r4, r4, #12
	rsb	r2, r4, #32
   1490c:	e2642020 	rsb	r2, r4, #32
	shift1	lsr, xl, xl, r2
   14910:	e1a00230 	lsr	r0, r0, r2
	shiftop orr xl xl xh lsl r4 yh
   14914:	e1800411 	orr	r0, r0, r1, lsl r4
	mov	xh, r5
   14918:	e1a01005 	mov	r1, r5
	RETLDM	"r4, r5"
   1491c:	e8bd4030 	pop	{r4, r5, lr}
   14920:	e12fff1e 	bx	lr

	@ Shift value right of 32 to 64 bits, or 0 to 32 bits after a switch
	@ from xh to xl.
2:	shift1	lsr, xl, xh, r4
   14924:	e1a00431 	lsr	r0, r1, r4
	mov	xh, r5
   14928:	e1a01005 	mov	r1, r5
	RETLDM	"r4, r5"
   1492c:	e8bd4030 	pop	{r4, r5, lr}
   14930:	e12fff1e 	bx	lr

	@ Adjust exponents for denormalized arguments.
	@ Note that r4 must not remain equal to 0.
LSYM(Lad_d):
	teq	r4, #0
   14934:	e3340000 	teq	r4, #0
	eor	yh, yh, #0x00100000
   14938:	e2233601 	eor	r3, r3, #1048576	; 0x100000
	do_it	eq, te
	eoreq	xh, xh, #0x00100000
   1493c:	02211601 	eoreq	r1, r1, #1048576	; 0x100000
	addeq	r4, r4, #1
   14940:	02844001 	addeq	r4, r4, #1
	subne	r5, r5, #1
   14944:	12455001 	subne	r5, r5, #1
	b	LSYM(Lad_x)
   14948:	eaffff8f 	b	1478c <__adddf3+0x9c>


LSYM(Lad_s):
	mvns	ip, r4, asr #21
   1494c:	e1f0cac4 	mvns	ip, r4, asr #21
	do_it	ne
	COND(mvn,s,ne)	ip, r5, asr #21
   14950:	11f0cac5 	mvnsne	ip, r5, asr #21
	beq	LSYM(Lad_i)
   14954:	0a00001d 	beq	149d0 <__adddf3+0x2e0>

	teq	r4, r5
   14958:	e1340005 	teq	r4, r5
	do_it	eq
	teqeq	xl, yl
   1495c:	01300002 	teqeq	r0, r2
	beq	1f
   14960:	0a000004 	beq	14978 <__adddf3+0x288>

	@ Result is x + 0.0 = x or 0.0 + y = y.
	orrs	ip, r4, xl
   14964:	e194c000 	orrs	ip, r4, r0
	do_it	eq, t
	moveq	xh, yh
   14968:	01a01003 	moveq	r1, r3
	moveq	xl, yl
   1496c:	01a00002 	moveq	r0, r2
	RETLDM	"r4, r5"
   14970:	e8bd4030 	pop	{r4, r5, lr}
   14974:	e12fff1e 	bx	lr

1:	teq	xh, yh
   14978:	e1310003 	teq	r1, r3

	@ Result is x - x = 0.
	do_it	ne, tt
	movne	xh, #0
   1497c:	13a01000 	movne	r1, #0
	movne	xl, #0
   14980:	13a00000 	movne	r0, #0
	RETLDM	"r4, r5" ne
   14984:	18bd4030 	popne	{r4, r5, lr}
   14988:	112fff1e 	bxne	lr

	@ Result is x + x = 2x.
	movs	ip, r4, lsr #21
   1498c:	e1b0caa4 	lsrs	ip, r4, #21
	bne	2f
   14990:	1a000004 	bne	149a8 <__adddf3+0x2b8>
	movs	xl, xl, lsl #1
   14994:	e1b00080 	lsls	r0, r0, #1
	adcs	xh, xh, xh
   14998:	e0b11001 	adcs	r1, r1, r1
	do_it	cs
	orrcs	xh, xh, #0x80000000
   1499c:	23811102 	orrcs	r1, r1, #-2147483648	; 0x80000000
	RETLDM	"r4, r5"
   149a0:	e8bd4030 	pop	{r4, r5, lr}
   149a4:	e12fff1e 	bx	lr
2:	adds	r4, r4, #(2 << 21)
   149a8:	e2944501 	adds	r4, r4, #4194304	; 0x400000
	do_it	cc, t
	addcc	xh, xh, #(1 << 20)
   149ac:	32811601 	addcc	r1, r1, #1048576	; 0x100000
	RETLDM	"r4, r5" cc
   149b0:	38bd4030 	popcc	{r4, r5, lr}
   149b4:	312fff1e 	bxcc	lr
	and	r5, xh, #0x80000000
   149b8:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000

	@ Overflow: return INF.
LSYM(Lad_o):
	orr	xh, r5, #0x7f000000
   149bc:	e385147f 	orr	r1, r5, #2130706432	; 0x7f000000
	orr	xh, xh, #0x00f00000
   149c0:	e381160f 	orr	r1, r1, #15728640	; 0xf00000
	mov	xl, #0
   149c4:	e3a00000 	mov	r0, #0
	RETLDM	"r4, r5"
   149c8:	e8bd4030 	pop	{r4, r5, lr}
   149cc:	e12fff1e 	bx	lr
	@   if yh-yl != INF/NAN: return xh-xl (which is INF/NAN)
	@   if either is NAN: return NAN
	@   if opposite sign: return NAN
	@   otherwise return xh-xl (which is INF or -INF)
LSYM(Lad_i):
	mvns	ip, r4, asr #21
   149d0:	e1f0cac4 	mvns	ip, r4, asr #21
	do_it	ne, te
	movne	xh, yh
   149d4:	11a01003 	movne	r1, r3
	movne	xl, yl
   149d8:	11a00002 	movne	r0, r2
	COND(mvn,s,eq)	ip, r5, asr #21
   149dc:	01f0cac5 	mvnseq	ip, r5, asr #21
	do_it	ne, t
	movne	yh, xh
   149e0:	11a03001 	movne	r3, r1
	movne	yl, xl
   149e4:	11a02000 	movne	r2, r0
	orrs	r4, xl, xh, lsl #12
   149e8:	e1904601 	orrs	r4, r0, r1, lsl #12
	do_it	eq, te
	COND(orr,s,eq)	r5, yl, yh, lsl #12
   149ec:	01925603 	orrseq	r5, r2, r3, lsl #12
	teqeq	xh, yh
   149f0:	01310003 	teqeq	r1, r3
	orrne	xh, xh, #0x00080000	@ quiet NAN
   149f4:	13811702 	orrne	r1, r1, #524288	; 0x80000
	RETLDM	"r4, r5"
   149f8:	e8bd4030 	pop	{r4, r5, lr}
   149fc:	e12fff1e 	bx	lr

00014a00 <__aeabi_ui2d>:
	FUNC_END adddf3

ARM_FUNC_START floatunsidf
ARM_FUNC_ALIAS aeabi_ui2d floatunsidf

	teq	r0, #0
   14a00:	e3300000 	teq	r0, #0
	do_it	eq, t
	moveq	r1, #0
   14a04:	03a01000 	moveq	r1, #0
	RETc(eq)
   14a08:	012fff1e 	bxeq	lr
	do_push	{r4, r5, lr}
   14a0c:	e92d4030 	push	{r4, r5, lr}
	mov	r4, #0x400		@ initial exponent
   14a10:	e3a04b01 	mov	r4, #1024	; 0x400
	add	r4, r4, #(52-1 - 1)
   14a14:	e2844032 	add	r4, r4, #50	; 0x32
	mov	r5, #0			@ sign bit is 0
   14a18:	e3a05000 	mov	r5, #0
	.ifnc	xl, r0
	mov	xl, r0
	.endif
	mov	xh, #0
   14a1c:	e3a01000 	mov	r1, #0
	b	LSYM(Lad_l)
   14a20:	eaffff86 	b	14840 <__adddf3+0x150>

00014a24 <__aeabi_i2d>:
	FUNC_END floatunsidf

ARM_FUNC_START floatsidf
ARM_FUNC_ALIAS aeabi_i2d floatsidf

	teq	r0, #0
   14a24:	e3300000 	teq	r0, #0
	do_it	eq, t
	moveq	r1, #0
   14a28:	03a01000 	moveq	r1, #0
	RETc(eq)
   14a2c:	012fff1e 	bxeq	lr
	do_push	{r4, r5, lr}
   14a30:	e92d4030 	push	{r4, r5, lr}
	mov	r4, #0x400		@ initial exponent
   14a34:	e3a04b01 	mov	r4, #1024	; 0x400
	add	r4, r4, #(52-1 - 1)
   14a38:	e2844032 	add	r4, r4, #50	; 0x32
	ands	r5, r0, #0x80000000	@ sign bit in r5
   14a3c:	e2105102 	ands	r5, r0, #-2147483648	; 0x80000000
	do_it	mi
	rsbmi	r0, r0, #0		@ absolute value
   14a40:	42600000 	rsbmi	r0, r0, #0
	.ifnc	xl, r0
	mov	xl, r0
	.endif
	mov	xh, #0
   14a44:	e3a01000 	mov	r1, #0
	b	LSYM(Lad_l)
   14a48:	eaffff7c 	b	14840 <__adddf3+0x150>

00014a4c <__aeabi_f2d>:
	FUNC_END floatsidf

ARM_FUNC_START extendsfdf2
ARM_FUNC_ALIAS aeabi_f2d extendsfdf2

	movs	r2, r0, lsl #1		@ toss sign bit
   14a4c:	e1b02080 	lsls	r2, r0, #1
	mov	xh, r2, asr #3		@ stretch exponent
   14a50:	e1a011c2 	asr	r1, r2, #3
	mov	xh, xh, rrx		@ retrieve sign bit
   14a54:	e1a01061 	rrx	r1, r1
	mov	xl, r2, lsl #28		@ retrieve remaining bits
   14a58:	e1a00e02 	lsl	r0, r2, #28
	do_it	ne, ttt
	COND(and,s,ne)	r3, r2, #0xff000000	@ isolate exponent
   14a5c:	121234ff 	andsne	r3, r2, #-16777216	; 0xff000000
	teqne	r3, #0xff000000		@ if not 0, check if INF or NAN
   14a60:	133304ff 	teqne	r3, #-16777216	; 0xff000000
	eorne	xh, xh, #0x38000000	@ fixup exponent otherwise.
   14a64:	1221130e 	eorne	r1, r1, #939524096	; 0x38000000
	RETc(ne)			@ and return it.
   14a68:	112fff1e 	bxne	lr

	teq	r2, #0			@ if actually 0
   14a6c:	e3320000 	teq	r2, #0
	do_it	ne, e
	teqne	r3, #0xff000000		@ or INF or NAN
   14a70:	133304ff 	teqne	r3, #-16777216	; 0xff000000
	RETc(eq)			@ we are done already.
   14a74:	012fff1e 	bxeq	lr

	@ value was denormalized.  We can normalize it now.
	do_push	{r4, r5, lr}
   14a78:	e92d4030 	push	{r4, r5, lr}
	mov	r4, #0x380		@ setup corresponding exponent
   14a7c:	e3a04d0e 	mov	r4, #896	; 0x380
	and	r5, xh, #0x80000000	@ move sign bit in r5
   14a80:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
	bic	xh, xh, #0x80000000
   14a84:	e3c11102 	bic	r1, r1, #-2147483648	; 0x80000000
	b	LSYM(Lad_l)
   14a88:	eaffff6c 	b	14840 <__adddf3+0x150>

00014a8c <__aeabi_ul2d>:
	FUNC_END extendsfdf2

ARM_FUNC_START floatundidf
ARM_FUNC_ALIAS aeabi_ul2d floatundidf

	orrs	r2, r0, r1
   14a8c:	e1902001 	orrs	r2, r0, r1
	do_it	eq
	RETc(eq)
   14a90:	012fff1e 	bxeq	lr

	do_push	{r4, r5, lr}
   14a94:	e92d4030 	push	{r4, r5, lr}

	mov	r5, #0
   14a98:	e3a05000 	mov	r5, #0
	b	2f
   14a9c:	ea000006 	b	14abc <__aeabi_l2d+0x1c>

00014aa0 <__aeabi_l2d>:

ARM_FUNC_START floatdidf
ARM_FUNC_ALIAS aeabi_l2d floatdidf

	orrs	r2, r0, r1
   14aa0:	e1902001 	orrs	r2, r0, r1
	do_it	eq
	RETc(eq)
   14aa4:	012fff1e 	bxeq	lr

	do_push	{r4, r5, lr}
   14aa8:	e92d4030 	push	{r4, r5, lr}

	ands	r5, ah, #0x80000000	@ sign bit in r5
   14aac:	e2115102 	ands	r5, r1, #-2147483648	; 0x80000000
	bpl	2f
   14ab0:	5a000001 	bpl	14abc <__aeabi_l2d+0x1c>
#if defined(__thumb2__)
	negs	al, al
	sbc	ah, ah, ah, lsl #1
#else
	rsbs	al, al, #0
   14ab4:	e2700000 	rsbs	r0, r0, #0
	rsc	ah, ah, #0
   14ab8:	e2e11000 	rsc	r1, r1, #0
#endif
2:
	mov	r4, #0x400		@ initial exponent
   14abc:	e3a04b01 	mov	r4, #1024	; 0x400
	add	r4, r4, #(52-1 - 1)
   14ac0:	e2844032 	add	r4, r4, #50	; 0x32
	mov	ip, al
	mov	xh, ah
	mov	xl, ip
	.endif

	movs	ip, xh, lsr #22
   14ac4:	e1b0cb21 	lsrs	ip, r1, #22
	beq	LSYM(Lad_p)
   14ac8:	0affff44 	beq	147e0 <__adddf3+0xf0>

	@ The value is too big.  Scale it down a bit...
	mov	r2, #3
   14acc:	e3a02003 	mov	r2, #3
	movs	ip, ip, lsr #3
   14ad0:	e1b0c1ac 	lsrs	ip, ip, #3
	do_it	ne
	addne	r2, r2, #3
   14ad4:	12822003 	addne	r2, r2, #3
	movs	ip, ip, lsr #3
   14ad8:	e1b0c1ac 	lsrs	ip, ip, #3
	do_it	ne
	addne	r2, r2, #3
   14adc:	12822003 	addne	r2, r2, #3
	add	r2, r2, ip, lsr #3
   14ae0:	e08221ac 	add	r2, r2, ip, lsr #3

	rsb	r3, r2, #32
   14ae4:	e2623020 	rsb	r3, r2, #32
	shift1	lsl, ip, xl, r3
   14ae8:	e1a0c310 	lsl	ip, r0, r3
	shift1	lsr, xl, xl, r2
   14aec:	e1a00230 	lsr	r0, r0, r2
	shiftop orr xl xl xh lsl r3 lr
   14af0:	e1800311 	orr	r0, r0, r1, lsl r3
	shift1	lsr, xh, xh, r2
   14af4:	e1a01231 	lsr	r1, r1, r2
	add	r4, r4, r2
   14af8:	e0844002 	add	r4, r4, r2
	b	LSYM(Lad_p)
   14afc:	eaffff37 	b	147e0 <__adddf3+0xf0>

00014b00 <__aeabi_dmul>:

#ifdef L_arm_muldivdf3

ARM_FUNC_START muldf3
ARM_FUNC_ALIAS aeabi_dmul muldf3
	do_push	{r4, r5, r6, lr}
   14b00:	e92d4070 	push	{r4, r5, r6, lr}

	@ Mask out exponents, trap any zero/denormal/INF/NAN.
	mov	ip, #0xff
   14b04:	e3a0c0ff 	mov	ip, #255	; 0xff
	orr	ip, ip, #0x700
   14b08:	e38ccc07 	orr	ip, ip, #1792	; 0x700
	ands	r4, ip, xh, lsr #20
   14b0c:	e01c4a21 	ands	r4, ip, r1, lsr #20
	do_it	ne, tte
	COND(and,s,ne)	r5, ip, yh, lsr #20
   14b10:	101c5a23 	andsne	r5, ip, r3, lsr #20
	teqne	r4, ip
   14b14:	1134000c 	teqne	r4, ip
	teqne	r5, ip
   14b18:	1135000c 	teqne	r5, ip
	bleq	LSYM(Lml_s)
   14b1c:	0b000075 	bleq	14cf8 <__aeabi_dmul+0x1f8>

	@ Add exponents together
	add	r4, r4, r5
   14b20:	e0844005 	add	r4, r4, r5

	@ Determine final sign.
	eor	r6, xh, yh
   14b24:	e0216003 	eor	r6, r1, r3

	@ Convert mantissa to unsigned integer.
	@ If power of two, branch to a separate path.
	bic	xh, xh, ip, lsl #21
   14b28:	e1c11a8c 	bic	r1, r1, ip, lsl #21
	bic	yh, yh, ip, lsl #21
   14b2c:	e1c33a8c 	bic	r3, r3, ip, lsl #21
	orrs	r5, xl, xh, lsl #12
   14b30:	e1905601 	orrs	r5, r0, r1, lsl #12
	do_it	ne
	COND(orr,s,ne)	r5, yl, yh, lsl #12
   14b34:	11925603 	orrsne	r5, r2, r3, lsl #12
	orr	xh, xh, #0x00100000
   14b38:	e3811601 	orr	r1, r1, #1048576	; 0x100000
	orr	yh, yh, #0x00100000
   14b3c:	e3833601 	orr	r3, r3, #1048576	; 0x100000
	beq	LSYM(Lml_1)
   14b40:	0a00001d 	beq	14bbc <__aeabi_dmul+0xbc>
	ldmfd	sp!, {yl, r7, r8, r9, sl, fp}

#else

	@ Here is the actual multiplication.
	umull	ip, lr, xl, yl
   14b44:	e08ec290 	umull	ip, lr, r0, r2
	mov	r5, #0
   14b48:	e3a05000 	mov	r5, #0
	umlal	lr, r5, xh, yl
   14b4c:	e0a5e291 	umlal	lr, r5, r1, r2
	and	yl, r6, #0x80000000
   14b50:	e2062102 	and	r2, r6, #-2147483648	; 0x80000000
	umlal	lr, r5, xl, yh
   14b54:	e0a5e390 	umlal	lr, r5, r0, r3
	mov	r6, #0
   14b58:	e3a06000 	mov	r6, #0
	umlal	r5, r6, xh, yh
   14b5c:	e0a65391 	umlal	r5, r6, r1, r3

#endif

	@ The LSBs in ip are only significant for the final rounding.
	@ Fold them into lr.
	teq	ip, #0
   14b60:	e33c0000 	teq	ip, #0
	do_it	ne
	orrne	lr, lr, #1
   14b64:	138ee001 	orrne	lr, lr, #1

	@ Adjust result upon the MSB position.
	sub	r4, r4, #0xff
   14b68:	e24440ff 	sub	r4, r4, #255	; 0xff
	cmp	r6, #(1 << (20-11))
   14b6c:	e3560c02 	cmp	r6, #512	; 0x200
	sbc	r4, r4, #0x300
   14b70:	e2c44c03 	sbc	r4, r4, #768	; 0x300
	bcs	1f
   14b74:	2a000002 	bcs	14b84 <__aeabi_dmul+0x84>
	movs	lr, lr, lsl #1
   14b78:	e1b0e08e 	lsls	lr, lr, #1
	adcs	r5, r5, r5
   14b7c:	e0b55005 	adcs	r5, r5, r5
	adc	r6, r6, r6
   14b80:	e0a66006 	adc	r6, r6, r6
1:
	@ Shift to final position, add sign to result.
	orr	xh, yl, r6, lsl #11
   14b84:	e1821586 	orr	r1, r2, r6, lsl #11
	orr	xh, xh, r5, lsr #21
   14b88:	e1811aa5 	orr	r1, r1, r5, lsr #21
	mov	xl, r5, lsl #11
   14b8c:	e1a00585 	lsl	r0, r5, #11
	orr	xl, xl, lr, lsr #21
   14b90:	e1800aae 	orr	r0, r0, lr, lsr #21
	mov	lr, lr, lsl #11
   14b94:	e1a0e58e 	lsl	lr, lr, #11

	@ Check exponent range for under/overflow.
	subs	ip, r4, #(254 - 1)
   14b98:	e254c0fd 	subs	ip, r4, #253	; 0xfd
	do_it	hi
	cmphi	ip, #0x700
   14b9c:	835c0c07 	cmphi	ip, #1792	; 0x700
	bhi	LSYM(Lml_u)
   14ba0:	8a000011 	bhi	14bec <__aeabi_dmul+0xec>

	@ Round the result, merge final exponent.
	cmp	lr, #0x80000000
   14ba4:	e35e0102 	cmp	lr, #-2147483648	; 0x80000000
	do_it	eq
	COND(mov,s,eq)	lr, xl, lsr #1
   14ba8:	01b0e0a0 	lsrseq	lr, r0, #1
	adcs	xl, xl, #0
   14bac:	e2b00000 	adcs	r0, r0, #0
	adc	xh, xh, r4, lsl #20
   14bb0:	e0a11a04 	adc	r1, r1, r4, lsl #20
	RETLDM	"r4, r5, r6"
   14bb4:	e8bd4070 	pop	{r4, r5, r6, lr}
   14bb8:	e12fff1e 	bx	lr

	@ Multiplication by 0x1p*: let''s shortcut a lot of code.
LSYM(Lml_1):
	and	r6, r6, #0x80000000
   14bbc:	e2066102 	and	r6, r6, #-2147483648	; 0x80000000
	orr	xh, r6, xh
   14bc0:	e1861001 	orr	r1, r6, r1
	orr	xl, xl, yl
   14bc4:	e1800002 	orr	r0, r0, r2
	eor	xh, xh, yh
   14bc8:	e0211003 	eor	r1, r1, r3
	subs	r4, r4, ip, lsr #1
   14bcc:	e05440ac 	subs	r4, r4, ip, lsr #1
	do_it	gt, tt
	COND(rsb,s,gt)	r5, r4, ip
   14bd0:	c074500c 	rsbsgt	r5, r4, ip
	orrgt	xh, xh, r4, lsl #20
   14bd4:	c1811a04 	orrgt	r1, r1, r4, lsl #20
	RETLDM	"r4, r5, r6" gt
   14bd8:	c8bd4070 	popgt	{r4, r5, r6, lr}
   14bdc:	c12fff1e 	bxgt	lr

	@ Under/overflow: fix things up for the code below.
	orr	xh, xh, #0x00100000
   14be0:	e3811601 	orr	r1, r1, #1048576	; 0x100000
	mov	lr, #0
   14be4:	e3a0e000 	mov	lr, #0
	subs	r4, r4, #1
   14be8:	e2544001 	subs	r4, r4, #1

LSYM(Lml_u):
	@ Overflow?
	bgt	LSYM(Lml_o)
   14bec:	ca00005d 	bgt	14d68 <__aeabi_dmul+0x268>

	@ Check if denormalized result is possible, otherwise return signed 0.
	cmn	r4, #(53 + 1)
   14bf0:	e3740036 	cmn	r4, #54	; 0x36
	do_it	le, tt
	movle	xl, #0
   14bf4:	d3a00000 	movle	r0, #0
	bicle	xh, xh, #0x7fffffff
   14bf8:	d2011102 	andle	r1, r1, #-2147483648	; 0x80000000
	RETLDM	"r4, r5, r6" le
   14bfc:	d8bd4070 	pople	{r4, r5, r6, lr}
   14c00:	d12fff1e 	bxle	lr

	@ Find out proper shift value.
	rsb	r4, r4, #0
   14c04:	e2644000 	rsb	r4, r4, #0
	subs	r4, r4, #32
   14c08:	e2544020 	subs	r4, r4, #32
	bge	2f
   14c0c:	aa00001a 	bge	14c7c <__aeabi_dmul+0x17c>
	adds	r4, r4, #12
   14c10:	e294400c 	adds	r4, r4, #12
	bgt	1f
   14c14:	ca00000c 	bgt	14c4c <__aeabi_dmul+0x14c>

	@ shift result right of 1 to 20 bits, preserve sign bit, round, etc.
	add	r4, r4, #20
   14c18:	e2844014 	add	r4, r4, #20
	rsb	r5, r4, #32
   14c1c:	e2645020 	rsb	r5, r4, #32
	shift1	lsl, r3, xl, r5
   14c20:	e1a03510 	lsl	r3, r0, r5
	shift1	lsr, xl, xl, r4
   14c24:	e1a00430 	lsr	r0, r0, r4
	shiftop orr xl xl xh lsl r5 r2
   14c28:	e1800511 	orr	r0, r0, r1, lsl r5
	and	r2, xh, #0x80000000
   14c2c:	e2012102 	and	r2, r1, #-2147483648	; 0x80000000
	bic	xh, xh, #0x80000000
   14c30:	e3c11102 	bic	r1, r1, #-2147483648	; 0x80000000
	adds	xl, xl, r3, lsr #31
   14c34:	e0900fa3 	adds	r0, r0, r3, lsr #31
	shiftop adc xh r2 xh lsr r4 r6
   14c38:	e0a21431 	adc	r1, r2, r1, lsr r4
	orrs	lr, lr, r3, lsl #1
   14c3c:	e19ee083 	orrs	lr, lr, r3, lsl #1
	do_it	eq
	biceq	xl, xl, r3, lsr #31
   14c40:	01c00fa3 	biceq	r0, r0, r3, lsr #31
	RETLDM	"r4, r5, r6"
   14c44:	e8bd4070 	pop	{r4, r5, r6, lr}
   14c48:	e12fff1e 	bx	lr

	@ shift result right of 21 to 31 bits, or left 11 to 1 bits after
	@ a register switch from xh to xl. Then round.
1:	rsb	r4, r4, #12
   14c4c:	e264400c 	rsb	r4, r4, #12
	rsb	r5, r4, #32
   14c50:	e2645020 	rsb	r5, r4, #32
	shift1	lsl, r3, xl, r4
   14c54:	e1a03410 	lsl	r3, r0, r4
	shift1	lsr, xl, xl, r5
   14c58:	e1a00530 	lsr	r0, r0, r5
	shiftop orr xl xl xh lsl r4 r2
   14c5c:	e1800411 	orr	r0, r0, r1, lsl r4
	bic	xh, xh, #0x7fffffff
   14c60:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
	adds	xl, xl, r3, lsr #31
   14c64:	e0900fa3 	adds	r0, r0, r3, lsr #31
	adc	xh, xh, #0
   14c68:	e2a11000 	adc	r1, r1, #0
	orrs	lr, lr, r3, lsl #1
   14c6c:	e19ee083 	orrs	lr, lr, r3, lsl #1
	do_it	eq
	biceq	xl, xl, r3, lsr #31
   14c70:	01c00fa3 	biceq	r0, r0, r3, lsr #31
	RETLDM	"r4, r5, r6"
   14c74:	e8bd4070 	pop	{r4, r5, r6, lr}
   14c78:	e12fff1e 	bx	lr

	@ Shift value right of 32 to 64 bits, or 0 to 32 bits after a switch
	@ from xh to xl.  Leftover bits are in r3-r6-lr for rounding.
2:	rsb	r5, r4, #32
   14c7c:	e2645020 	rsb	r5, r4, #32
	shiftop orr lr lr xl lsl r5 r2
   14c80:	e18ee510 	orr	lr, lr, r0, lsl r5
	shift1	lsr, r3, xl, r4
   14c84:	e1a03430 	lsr	r3, r0, r4
	shiftop orr r3 r3 xh lsl r5 r2
   14c88:	e1833511 	orr	r3, r3, r1, lsl r5
	shift1	lsr, xl, xh, r4
   14c8c:	e1a00431 	lsr	r0, r1, r4
	bic	xh, xh, #0x7fffffff
   14c90:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
	shiftop bic xl xl xh lsr r4 r2
   14c94:	e1c00431 	bic	r0, r0, r1, lsr r4
	add	xl, xl, r3, lsr #31
   14c98:	e0800fa3 	add	r0, r0, r3, lsr #31
	orrs	lr, lr, r3, lsl #1
   14c9c:	e19ee083 	orrs	lr, lr, r3, lsl #1
	do_it	eq
	biceq	xl, xl, r3, lsr #31
   14ca0:	01c00fa3 	biceq	r0, r0, r3, lsr #31
	RETLDM	"r4, r5, r6"
   14ca4:	e8bd4070 	pop	{r4, r5, r6, lr}
   14ca8:	e12fff1e 	bx	lr

	@ One or both arguments are denormalized.
	@ Scale them leftwards and preserve sign bit.
LSYM(Lml_d):
	teq	r4, #0
   14cac:	e3340000 	teq	r4, #0
	bne	2f
   14cb0:	1a000008 	bne	14cd8 <__aeabi_dmul+0x1d8>
	and	r6, xh, #0x80000000
   14cb4:	e2016102 	and	r6, r1, #-2147483648	; 0x80000000
1:	movs	xl, xl, lsl #1
   14cb8:	e1b00080 	lsls	r0, r0, #1
	adc	xh, xh, xh
   14cbc:	e0a11001 	adc	r1, r1, r1
	tst	xh, #0x00100000
   14cc0:	e3110601 	tst	r1, #1048576	; 0x100000
	do_it	eq
	subeq	r4, r4, #1
   14cc4:	02444001 	subeq	r4, r4, #1
	beq	1b
   14cc8:	0afffffa 	beq	14cb8 <__aeabi_dmul+0x1b8>
	orr	xh, xh, r6
   14ccc:	e1811006 	orr	r1, r1, r6
	teq	r5, #0
   14cd0:	e3350000 	teq	r5, #0
	do_it	ne
	RETc(ne)
   14cd4:	112fff1e 	bxne	lr
2:	and	r6, yh, #0x80000000
   14cd8:	e2036102 	and	r6, r3, #-2147483648	; 0x80000000
3:	movs	yl, yl, lsl #1
   14cdc:	e1b02082 	lsls	r2, r2, #1
	adc	yh, yh, yh
   14ce0:	e0a33003 	adc	r3, r3, r3
	tst	yh, #0x00100000
   14ce4:	e3130601 	tst	r3, #1048576	; 0x100000
	do_it	eq
	subeq	r5, r5, #1
   14ce8:	02455001 	subeq	r5, r5, #1
	beq	3b
   14cec:	0afffffa 	beq	14cdc <__aeabi_dmul+0x1dc>
	orr	yh, yh, r6
   14cf0:	e1833006 	orr	r3, r3, r6
	RET
   14cf4:	e12fff1e 	bx	lr

LSYM(Lml_s):
	@ Isolate the INF and NAN cases away
	teq	r4, ip
   14cf8:	e134000c 	teq	r4, ip
	and	r5, ip, yh, lsr #20
   14cfc:	e00c5a23 	and	r5, ip, r3, lsr #20
	do_it	ne
	teqne	r5, ip
   14d00:	1135000c 	teqne	r5, ip
	beq	1f
   14d04:	0a000007 	beq	14d28 <__aeabi_dmul+0x228>

	@ Here, one or more arguments are either denormalized or zero.
	orrs	r6, xl, xh, lsl #1
   14d08:	e1906081 	orrs	r6, r0, r1, lsl #1
	do_it	ne
	COND(orr,s,ne)	r6, yl, yh, lsl #1
   14d0c:	11926083 	orrsne	r6, r2, r3, lsl #1
	bne	LSYM(Lml_d)
   14d10:	1affffe5 	bne	14cac <__aeabi_dmul+0x1ac>

	@ Result is 0, but determine sign anyway.
LSYM(Lml_z):
	eor	xh, xh, yh
   14d14:	e0211003 	eor	r1, r1, r3
	and	xh, xh, #0x80000000
   14d18:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
	mov	xl, #0
   14d1c:	e3a00000 	mov	r0, #0
	RETLDM	"r4, r5, r6"
   14d20:	e8bd4070 	pop	{r4, r5, r6, lr}
   14d24:	e12fff1e 	bx	lr

1:	@ One or both args are INF or NAN.
	orrs	r6, xl, xh, lsl #1
   14d28:	e1906081 	orrs	r6, r0, r1, lsl #1
	do_it	eq, te
	moveq	xl, yl
   14d2c:	01a00002 	moveq	r0, r2
	moveq	xh, yh
   14d30:	01a01003 	moveq	r1, r3
	COND(orr,s,ne)	r6, yl, yh, lsl #1
   14d34:	11926083 	orrsne	r6, r2, r3, lsl #1
	beq	LSYM(Lml_n)		@ 0 * INF or INF * 0 -> NAN
   14d38:	0a000010 	beq	14d80 <__aeabi_dmul+0x280>
	teq	r4, ip
   14d3c:	e134000c 	teq	r4, ip
	bne	1f
   14d40:	1a000001 	bne	14d4c <__aeabi_dmul+0x24c>
	orrs	r6, xl, xh, lsl #12
   14d44:	e1906601 	orrs	r6, r0, r1, lsl #12
	bne	LSYM(Lml_n)		@ NAN * <anything> -> NAN
   14d48:	1a00000c 	bne	14d80 <__aeabi_dmul+0x280>
1:	teq	r5, ip
   14d4c:	e135000c 	teq	r5, ip
	bne	LSYM(Lml_i)
   14d50:	1a000003 	bne	14d64 <__aeabi_dmul+0x264>
	orrs	r6, yl, yh, lsl #12
   14d54:	e1926603 	orrs	r6, r2, r3, lsl #12
	do_it	ne, t
	movne	xl, yl
   14d58:	11a00002 	movne	r0, r2
	movne	xh, yh
   14d5c:	11a01003 	movne	r1, r3
	bne	LSYM(Lml_n)		@ <anything> * NAN -> NAN
   14d60:	1a000006 	bne	14d80 <__aeabi_dmul+0x280>

	@ Result is INF, but we need to determine its sign.
LSYM(Lml_i):
	eor	xh, xh, yh
   14d64:	e0211003 	eor	r1, r1, r3

	@ Overflow: return INF (sign already in xh).
LSYM(Lml_o):
	and	xh, xh, #0x80000000
   14d68:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
	orr	xh, xh, #0x7f000000
   14d6c:	e381147f 	orr	r1, r1, #2130706432	; 0x7f000000
	orr	xh, xh, #0x00f00000
   14d70:	e381160f 	orr	r1, r1, #15728640	; 0xf00000
	mov	xl, #0
   14d74:	e3a00000 	mov	r0, #0
	RETLDM	"r4, r5, r6"
   14d78:	e8bd4070 	pop	{r4, r5, r6, lr}
   14d7c:	e12fff1e 	bx	lr

	@ Return a quiet NAN.
LSYM(Lml_n):
	orr	xh, xh, #0x7f000000
   14d80:	e381147f 	orr	r1, r1, #2130706432	; 0x7f000000
	orr	xh, xh, #0x00f80000
   14d84:	e381173e 	orr	r1, r1, #16252928	; 0xf80000
	RETLDM	"r4, r5, r6"
   14d88:	e8bd4070 	pop	{r4, r5, r6, lr}
   14d8c:	e12fff1e 	bx	lr

00014d90 <__aeabi_ddiv>:
	FUNC_END muldf3

ARM_FUNC_START divdf3
ARM_FUNC_ALIAS aeabi_ddiv divdf3
	
	do_push	{r4, r5, r6, lr}
   14d90:	e92d4070 	push	{r4, r5, r6, lr}

	@ Mask out exponents, trap any zero/denormal/INF/NAN.
	mov	ip, #0xff
   14d94:	e3a0c0ff 	mov	ip, #255	; 0xff
	orr	ip, ip, #0x700
   14d98:	e38ccc07 	orr	ip, ip, #1792	; 0x700
	ands	r4, ip, xh, lsr #20
   14d9c:	e01c4a21 	ands	r4, ip, r1, lsr #20
	do_it	ne, tte
	COND(and,s,ne)	r5, ip, yh, lsr #20
   14da0:	101c5a23 	andsne	r5, ip, r3, lsr #20
	teqne	r4, ip
   14da4:	1134000c 	teqne	r4, ip
	teqne	r5, ip
   14da8:	1135000c 	teqne	r5, ip
	bleq	LSYM(Ldv_s)
   14dac:	0b00005e 	bleq	14f2c <__aeabi_ddiv+0x19c>

	@ Subtract divisor exponent from dividend''s.
	sub	r4, r4, r5
   14db0:	e0444005 	sub	r4, r4, r5

	@ Preserve final sign into lr.
	eor	lr, xh, yh
   14db4:	e021e003 	eor	lr, r1, r3

	@ Convert mantissa to unsigned integer.
	@ Dividend -> r5-r6, divisor -> yh-yl.
	orrs	r5, yl, yh, lsl #12
   14db8:	e1925603 	orrs	r5, r2, r3, lsl #12
	mov	xh, xh, lsl #12
   14dbc:	e1a01601 	lsl	r1, r1, #12
	beq	LSYM(Ldv_1)
   14dc0:	0a00004c 	beq	14ef8 <__aeabi_ddiv+0x168>
	mov	yh, yh, lsl #12
   14dc4:	e1a03603 	lsl	r3, r3, #12
	mov	r5, #0x10000000
   14dc8:	e3a05201 	mov	r5, #268435456	; 0x10000000
	orr	yh, r5, yh, lsr #4
   14dcc:	e1853223 	orr	r3, r5, r3, lsr #4
	orr	yh, yh, yl, lsr #24
   14dd0:	e1833c22 	orr	r3, r3, r2, lsr #24
	mov	yl, yl, lsl #8
   14dd4:	e1a02402 	lsl	r2, r2, #8
	orr	r5, r5, xh, lsr #4
   14dd8:	e1855221 	orr	r5, r5, r1, lsr #4
	orr	r5, r5, xl, lsr #24
   14ddc:	e1855c20 	orr	r5, r5, r0, lsr #24
	mov	r6, xl, lsl #8
   14de0:	e1a06400 	lsl	r6, r0, #8

	@ Initialize xh with final sign bit.
	and	xh, lr, #0x80000000
   14de4:	e20e1102 	and	r1, lr, #-2147483648	; 0x80000000

	@ Ensure result will land to known bit position.
	@ Apply exponent bias accordingly.
	cmp	r5, yh
   14de8:	e1550003 	cmp	r5, r3
	do_it	eq
	cmpeq	r6, yl
   14dec:	01560002 	cmpeq	r6, r2
	adc	r4, r4, #(255 - 2)
   14df0:	e2a440fd 	adc	r4, r4, #253	; 0xfd
	add	r4, r4, #0x300
   14df4:	e2844c03 	add	r4, r4, #768	; 0x300
	bcs	1f
   14df8:	2a000001 	bcs	14e04 <__aeabi_ddiv+0x74>
	movs	yh, yh, lsr #1
   14dfc:	e1b030a3 	lsrs	r3, r3, #1
	mov	yl, yl, rrx
   14e00:	e1a02062 	rrx	r2, r2
1:
	@ Perform first subtraction to align result to a nibble.
	subs	r6, r6, yl
   14e04:	e0566002 	subs	r6, r6, r2
	sbc	r5, r5, yh
   14e08:	e0c55003 	sbc	r5, r5, r3
	movs	yh, yh, lsr #1
   14e0c:	e1b030a3 	lsrs	r3, r3, #1
	mov	yl, yl, rrx
   14e10:	e1a02062 	rrx	r2, r2
	mov	xl, #0x00100000
   14e14:	e3a00601 	mov	r0, #1048576	; 0x100000
	mov	ip, #0x00080000
   14e18:	e3a0c702 	mov	ip, #524288	; 0x80000

	@ The actual division loop.
1:	subs	lr, r6, yl
   14e1c:	e056e002 	subs	lr, r6, r2
	sbcs	lr, r5, yh
   14e20:	e0d5e003 	sbcs	lr, r5, r3
	do_it	cs, tt
	subcs	r6, r6, yl
   14e24:	20466002 	subcs	r6, r6, r2
	movcs	r5, lr
   14e28:	21a0500e 	movcs	r5, lr
	orrcs	xl, xl, ip
   14e2c:	2180000c 	orrcs	r0, r0, ip
	movs	yh, yh, lsr #1
   14e30:	e1b030a3 	lsrs	r3, r3, #1
	mov	yl, yl, rrx
   14e34:	e1a02062 	rrx	r2, r2
	subs	lr, r6, yl
   14e38:	e056e002 	subs	lr, r6, r2
	sbcs	lr, r5, yh
   14e3c:	e0d5e003 	sbcs	lr, r5, r3
	do_it	cs, tt
	subcs	r6, r6, yl
   14e40:	20466002 	subcs	r6, r6, r2
	movcs	r5, lr
   14e44:	21a0500e 	movcs	r5, lr
	orrcs	xl, xl, ip, lsr #1
   14e48:	218000ac 	orrcs	r0, r0, ip, lsr #1
	movs	yh, yh, lsr #1
   14e4c:	e1b030a3 	lsrs	r3, r3, #1
	mov	yl, yl, rrx
   14e50:	e1a02062 	rrx	r2, r2
	subs	lr, r6, yl
   14e54:	e056e002 	subs	lr, r6, r2
	sbcs	lr, r5, yh
   14e58:	e0d5e003 	sbcs	lr, r5, r3
	do_it	cs, tt
	subcs	r6, r6, yl
   14e5c:	20466002 	subcs	r6, r6, r2
	movcs	r5, lr
   14e60:	21a0500e 	movcs	r5, lr
	orrcs	xl, xl, ip, lsr #2
   14e64:	2180012c 	orrcs	r0, r0, ip, lsr #2
	movs	yh, yh, lsr #1
   14e68:	e1b030a3 	lsrs	r3, r3, #1
	mov	yl, yl, rrx
   14e6c:	e1a02062 	rrx	r2, r2
	subs	lr, r6, yl
   14e70:	e056e002 	subs	lr, r6, r2
	sbcs	lr, r5, yh
   14e74:	e0d5e003 	sbcs	lr, r5, r3
	do_it	cs, tt
	subcs	r6, r6, yl
   14e78:	20466002 	subcs	r6, r6, r2
	movcs	r5, lr
   14e7c:	21a0500e 	movcs	r5, lr
	orrcs	xl, xl, ip, lsr #3
   14e80:	218001ac 	orrcs	r0, r0, ip, lsr #3

	orrs	lr, r5, r6
   14e84:	e195e006 	orrs	lr, r5, r6
	beq	2f
   14e88:	0a00000d 	beq	14ec4 <__aeabi_ddiv+0x134>
	mov	r5, r5, lsl #4
   14e8c:	e1a05205 	lsl	r5, r5, #4
	orr	r5, r5, r6, lsr #28
   14e90:	e1855e26 	orr	r5, r5, r6, lsr #28
	mov	r6, r6, lsl #4
   14e94:	e1a06206 	lsl	r6, r6, #4
	mov	yh, yh, lsl #3
   14e98:	e1a03183 	lsl	r3, r3, #3
	orr	yh, yh, yl, lsr #29
   14e9c:	e1833ea2 	orr	r3, r3, r2, lsr #29
	mov	yl, yl, lsl #3
   14ea0:	e1a02182 	lsl	r2, r2, #3
	movs	ip, ip, lsr #4
   14ea4:	e1b0c22c 	lsrs	ip, ip, #4
	bne	1b
   14ea8:	1affffdb 	bne	14e1c <__aeabi_ddiv+0x8c>

	@ We are done with a word of the result.
	@ Loop again for the low word if this pass was for the high word.
	tst	xh, #0x00100000
   14eac:	e3110601 	tst	r1, #1048576	; 0x100000
	bne	3f
   14eb0:	1a000006 	bne	14ed0 <__aeabi_ddiv+0x140>
	orr	xh, xh, xl
   14eb4:	e1811000 	orr	r1, r1, r0
	mov	xl, #0
   14eb8:	e3a00000 	mov	r0, #0
	mov	ip, #0x80000000
   14ebc:	e3a0c102 	mov	ip, #-2147483648	; 0x80000000
	b	1b
   14ec0:	eaffffd5 	b	14e1c <__aeabi_ddiv+0x8c>
2:
	@ Be sure result starts in the high word.
	tst	xh, #0x00100000
   14ec4:	e3110601 	tst	r1, #1048576	; 0x100000
	do_it	eq, t
	orreq	xh, xh, xl
   14ec8:	01811000 	orreq	r1, r1, r0
	moveq	xl, #0
   14ecc:	03a00000 	moveq	r0, #0
3:
	@ Check exponent range for under/overflow.
	subs	ip, r4, #(254 - 1)
   14ed0:	e254c0fd 	subs	ip, r4, #253	; 0xfd
	do_it	hi
	cmphi	ip, #0x700
   14ed4:	835c0c07 	cmphi	ip, #1792	; 0x700
	bhi	LSYM(Lml_u)
   14ed8:	8affff43 	bhi	14bec <__aeabi_dmul+0xec>

	@ Round the result, merge final exponent.
	subs	ip, r5, yh
   14edc:	e055c003 	subs	ip, r5, r3
	do_it	eq, t
	COND(sub,s,eq)	ip, r6, yl
   14ee0:	0056c002 	subseq	ip, r6, r2
	COND(mov,s,eq)	ip, xl, lsr #1
   14ee4:	01b0c0a0 	lsrseq	ip, r0, #1
	adcs	xl, xl, #0
   14ee8:	e2b00000 	adcs	r0, r0, #0
	adc	xh, xh, r4, lsl #20
   14eec:	e0a11a04 	adc	r1, r1, r4, lsl #20
	RETLDM	"r4, r5, r6"
   14ef0:	e8bd4070 	pop	{r4, r5, r6, lr}
   14ef4:	e12fff1e 	bx	lr

	@ Division by 0x1p*: shortcut a lot of code.
LSYM(Ldv_1):
	and	lr, lr, #0x80000000
   14ef8:	e20ee102 	and	lr, lr, #-2147483648	; 0x80000000
	orr	xh, lr, xh, lsr #12
   14efc:	e18e1621 	orr	r1, lr, r1, lsr #12
	adds	r4, r4, ip, lsr #1
   14f00:	e09440ac 	adds	r4, r4, ip, lsr #1
	do_it	gt, tt
	COND(rsb,s,gt)	r5, r4, ip
   14f04:	c074500c 	rsbsgt	r5, r4, ip
	orrgt	xh, xh, r4, lsl #20
   14f08:	c1811a04 	orrgt	r1, r1, r4, lsl #20
	RETLDM	"r4, r5, r6" gt
   14f0c:	c8bd4070 	popgt	{r4, r5, r6, lr}
   14f10:	c12fff1e 	bxgt	lr

	orr	xh, xh, #0x00100000
   14f14:	e3811601 	orr	r1, r1, #1048576	; 0x100000
	mov	lr, #0
   14f18:	e3a0e000 	mov	lr, #0
	subs	r4, r4, #1
   14f1c:	e2544001 	subs	r4, r4, #1
	b	LSYM(Lml_u)
   14f20:	eaffff31 	b	14bec <__aeabi_dmul+0xec>

	@ Result mightt need to be denormalized: put remainder bits
	@ in lr for rounding considerations.
LSYM(Ldv_u):
	orr	lr, r5, r6
   14f24:	e185e006 	orr	lr, r5, r6
	b	LSYM(Lml_u)
   14f28:	eaffff2f 	b	14bec <__aeabi_dmul+0xec>

	@ One or both arguments is either INF, NAN or zero.
LSYM(Ldv_s):
	and	r5, ip, yh, lsr #20
   14f2c:	e00c5a23 	and	r5, ip, r3, lsr #20
	teq	r4, ip
   14f30:	e134000c 	teq	r4, ip
	do_it	eq
	teqeq	r5, ip
   14f34:	0135000c 	teqeq	r5, ip
	beq	LSYM(Lml_n)		@ INF/NAN / INF/NAN -> NAN
   14f38:	0affff90 	beq	14d80 <__aeabi_dmul+0x280>
	teq	r4, ip
   14f3c:	e134000c 	teq	r4, ip
	bne	1f
   14f40:	1a000006 	bne	14f60 <__aeabi_ddiv+0x1d0>
	orrs	r4, xl, xh, lsl #12
   14f44:	e1904601 	orrs	r4, r0, r1, lsl #12
	bne	LSYM(Lml_n)		@ NAN / <anything> -> NAN
   14f48:	1affff8c 	bne	14d80 <__aeabi_dmul+0x280>
	teq	r5, ip
   14f4c:	e135000c 	teq	r5, ip
	bne	LSYM(Lml_i)		@ INF / <anything> -> INF
   14f50:	1affff83 	bne	14d64 <__aeabi_dmul+0x264>
	mov	xl, yl
   14f54:	e1a00002 	mov	r0, r2
	mov	xh, yh
   14f58:	e1a01003 	mov	r1, r3
	b	LSYM(Lml_n)		@ INF / (INF or NAN) -> NAN
   14f5c:	eaffff87 	b	14d80 <__aeabi_dmul+0x280>
1:	teq	r5, ip
   14f60:	e135000c 	teq	r5, ip
	bne	2f
   14f64:	1a000004 	bne	14f7c <__aeabi_ddiv+0x1ec>
	orrs	r5, yl, yh, lsl #12
   14f68:	e1925603 	orrs	r5, r2, r3, lsl #12
	beq	LSYM(Lml_z)		@ <anything> / INF -> 0
   14f6c:	0affff68 	beq	14d14 <__aeabi_dmul+0x214>
	mov	xl, yl
   14f70:	e1a00002 	mov	r0, r2
	mov	xh, yh
   14f74:	e1a01003 	mov	r1, r3
	b	LSYM(Lml_n)		@ <anything> / NAN -> NAN
   14f78:	eaffff80 	b	14d80 <__aeabi_dmul+0x280>
2:	@ If both are nonzero, we need to normalize and resume above.
	orrs	r6, xl, xh, lsl #1
   14f7c:	e1906081 	orrs	r6, r0, r1, lsl #1
	do_it	ne
	COND(orr,s,ne)	r6, yl, yh, lsl #1
   14f80:	11926083 	orrsne	r6, r2, r3, lsl #1
	bne	LSYM(Lml_d)
   14f84:	1affff48 	bne	14cac <__aeabi_dmul+0x1ac>
	@ One or both arguments are 0.
	orrs	r4, xl, xh, lsl #1
   14f88:	e1904081 	orrs	r4, r0, r1, lsl #1
	bne	LSYM(Lml_i)		@ <non_zero> / 0 -> INF
   14f8c:	1affff74 	bne	14d64 <__aeabi_dmul+0x264>
	orrs	r5, yl, yh, lsl #1
   14f90:	e1925083 	orrs	r5, r2, r3, lsl #1
	bne	LSYM(Lml_z)		@ 0 / <non_zero> -> 0
   14f94:	1affff5e 	bne	14d14 <__aeabi_dmul+0x214>
	b	LSYM(Lml_n)		@ 0 / 0 -> NAN
   14f98:	eaffff78 	b	14d80 <__aeabi_dmul+0x280>

00014f9c <__gedf2>:

@ Note: only r0 (return value) and ip are clobbered here.

ARM_FUNC_START gtdf2
ARM_FUNC_ALIAS gedf2 gtdf2
	mov	ip, #-1
   14f9c:	e3e0c000 	mvn	ip, #0
	b	1f
   14fa0:	ea000002 	b	14fb0 <__cmpdf2+0x4>

00014fa4 <__ledf2>:

ARM_FUNC_START ltdf2
ARM_FUNC_ALIAS ledf2 ltdf2
	mov	ip, #1
   14fa4:	e3a0c001 	mov	ip, #1
	b	1f
   14fa8:	ea000000 	b	14fb0 <__cmpdf2+0x4>

00014fac <__cmpdf2>:

ARM_FUNC_START cmpdf2
ARM_FUNC_ALIAS nedf2 cmpdf2
ARM_FUNC_ALIAS eqdf2 cmpdf2
	mov	ip, #1			@ how should we specify unordered here?
   14fac:	e3a0c001 	mov	ip, #1

1:	str	ip, [sp, #-4]!
   14fb0:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)

	@ Trap any INF/NAN first.
	mov	ip, xh, lsl #1
   14fb4:	e1a0c081 	lsl	ip, r1, #1
	mvns	ip, ip, asr #21
   14fb8:	e1f0cacc 	mvns	ip, ip, asr #21
	mov	ip, yh, lsl #1
   14fbc:	e1a0c083 	lsl	ip, r3, #1
	do_it	ne
	COND(mvn,s,ne)	ip, ip, asr #21
   14fc0:	11f0cacc 	mvnsne	ip, ip, asr #21
	beq	3f
   14fc4:	0a00000e 	beq	15004 <__cmpdf2+0x58>

	@ Test for equality.
	@ Note that 0.0 is equal to -0.0.
2:	add	sp, sp, #4
   14fc8:	e28dd004 	add	sp, sp, #4
	orrs	ip, xl, xh, lsl #1	@ if x == 0.0 or -0.0
   14fcc:	e190c081 	orrs	ip, r0, r1, lsl #1
	do_it	eq, e
	COND(orr,s,eq)	ip, yl, yh, lsl #1	@ and y == 0.0 or -0.0
   14fd0:	0192c083 	orrseq	ip, r2, r3, lsl #1
	teqne	xh, yh			@ or xh == yh
   14fd4:	11310003 	teqne	r1, r3
	do_it	eq, tt
	teqeq	xl, yl			@ and xl == yl
   14fd8:	01300002 	teqeq	r0, r2
	moveq	r0, #0			@ then equal.
   14fdc:	03a00000 	moveq	r0, #0
	RETc(eq)
   14fe0:	012fff1e 	bxeq	lr

	@ Clear C flag
	cmn	r0, #0
   14fe4:	e3700000 	cmn	r0, #0

	@ Compare sign, 
	teq	xh, yh
   14fe8:	e1310003 	teq	r1, r3

	@ Compare values if same sign
	do_it	pl
	cmppl	xh, yh
   14fec:	51510003 	cmppl	r1, r3
	do_it	eq
	cmpeq	xl, yl
   14ff0:	01500002 	cmpeq	r0, r2

	@ Result:
	do_it	cs, e
	movcs	r0, yh, asr #31
   14ff4:	21a00fc3 	asrcs	r0, r3, #31
	mvncc	r0, yh, asr #31
   14ff8:	31e00fc3 	mvncc	r0, r3, asr #31
	orr	r0, r0, #1
   14ffc:	e3800001 	orr	r0, r0, #1
	RET
   15000:	e12fff1e 	bx	lr

	@ Look for a NAN.
3:	mov	ip, xh, lsl #1
   15004:	e1a0c081 	lsl	ip, r1, #1
	mvns	ip, ip, asr #21
   15008:	e1f0cacc 	mvns	ip, ip, asr #21
	bne	4f
   1500c:	1a000001 	bne	15018 <__cmpdf2+0x6c>
	orrs	ip, xl, xh, lsl #12
   15010:	e190c601 	orrs	ip, r0, r1, lsl #12
	bne	5f			@ x is NAN
   15014:	1a000004 	bne	1502c <__cmpdf2+0x80>
4:	mov	ip, yh, lsl #1
   15018:	e1a0c083 	lsl	ip, r3, #1
	mvns	ip, ip, asr #21
   1501c:	e1f0cacc 	mvns	ip, ip, asr #21
	bne	2b
   15020:	1affffe8 	bne	14fc8 <__cmpdf2+0x1c>
	orrs	ip, yl, yh, lsl #12
   15024:	e192c603 	orrs	ip, r2, r3, lsl #12
	beq	2b			@ y is not NAN
   15028:	0affffe6 	beq	14fc8 <__cmpdf2+0x1c>
5:	ldr	r0, [sp], #4		@ unordered return code
   1502c:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
	RET
   15030:	e12fff1e 	bx	lr

00015034 <__aeabi_cdrcmple>:
	FUNC_END eqdf2
	FUNC_END cmpdf2

ARM_FUNC_START aeabi_cdrcmple

	mov	ip, r0
   15034:	e1a0c000 	mov	ip, r0
	mov	r0, r2
   15038:	e1a00002 	mov	r0, r2
	mov	r2, ip
   1503c:	e1a0200c 	mov	r2, ip
	mov	ip, r1
   15040:	e1a0c001 	mov	ip, r1
	mov	r1, r3
   15044:	e1a01003 	mov	r1, r3
	mov	r3, ip
   15048:	e1a0300c 	mov	r3, ip
	b	6f
   1504c:	eaffffff 	b	15050 <__aeabi_cdcmpeq>

00015050 <__aeabi_cdcmpeq>:
ARM_FUNC_START aeabi_cdcmpeq
ARM_FUNC_ALIAS aeabi_cdcmple aeabi_cdcmpeq

	@ The status-returning routines are required to preserve all
	@ registers except ip, lr, and cpsr.
6:	do_push	{r0, lr}
   15050:	e92d4001 	push	{r0, lr}
	ARM_CALL cmpdf2
   15054:	ebffffd4 	bl	14fac <__cmpdf2>
	@ Set the Z flag correctly, and the C flag unconditionally.
	cmp	r0, #0
   15058:	e3500000 	cmp	r0, #0
	@ Clear the C flag if the return value was -1, indicating
	@ that the first operand was smaller than the second.
	do_it	mi
	cmnmi	r0, #0
   1505c:	43700000 	cmnmi	r0, #0
	RETLDM	"r0"
   15060:	e8bd4001 	pop	{r0, lr}
   15064:	e12fff1e 	bx	lr

00015068 <__aeabi_dcmpeq>:
	FUNC_END aeabi_cdcmpeq
	FUNC_END aeabi_cdrcmple
	
ARM_FUNC_START	aeabi_dcmpeq

	str	lr, [sp, #-8]!
   15068:	e52de008 	str	lr, [sp, #-8]!
	ARM_CALL aeabi_cdcmple
   1506c:	ebfffff7 	bl	15050 <__aeabi_cdcmpeq>
	do_it	eq, e
	moveq	r0, #1	@ Equal to.
   15070:	03a00001 	moveq	r0, #1
	movne	r0, #0	@ Less than, greater than, or unordered.
   15074:	13a00000 	movne	r0, #0
	RETLDM
   15078:	e49de008 	ldr	lr, [sp], #8
   1507c:	e12fff1e 	bx	lr

00015080 <__aeabi_dcmplt>:

	FUNC_END aeabi_dcmpeq

ARM_FUNC_START	aeabi_dcmplt

	str	lr, [sp, #-8]!
   15080:	e52de008 	str	lr, [sp, #-8]!
	ARM_CALL aeabi_cdcmple
   15084:	ebfffff1 	bl	15050 <__aeabi_cdcmpeq>
	do_it	cc, e
	movcc	r0, #1	@ Less than.
   15088:	33a00001 	movcc	r0, #1
	movcs	r0, #0	@ Equal to, greater than, or unordered.
   1508c:	23a00000 	movcs	r0, #0
	RETLDM
   15090:	e49de008 	ldr	lr, [sp], #8
   15094:	e12fff1e 	bx	lr

00015098 <__aeabi_dcmple>:

	FUNC_END aeabi_dcmplt

ARM_FUNC_START	aeabi_dcmple

	str	lr, [sp, #-8]!
   15098:	e52de008 	str	lr, [sp, #-8]!
	ARM_CALL aeabi_cdcmple
   1509c:	ebffffeb 	bl	15050 <__aeabi_cdcmpeq>
	do_it	ls, e
	movls	r0, #1  @ Less than or equal to.
   150a0:	93a00001 	movls	r0, #1
	movhi	r0, #0	@ Greater than or unordered.
   150a4:	83a00000 	movhi	r0, #0
	RETLDM
   150a8:	e49de008 	ldr	lr, [sp], #8
   150ac:	e12fff1e 	bx	lr

000150b0 <__aeabi_dcmpge>:

	FUNC_END aeabi_dcmple

ARM_FUNC_START	aeabi_dcmpge

	str	lr, [sp, #-8]!
   150b0:	e52de008 	str	lr, [sp, #-8]!
	ARM_CALL aeabi_cdrcmple
   150b4:	ebffffde 	bl	15034 <__aeabi_cdrcmple>
	do_it	ls, e
	movls	r0, #1	@ Operand 2 is less than or equal to operand 1.
   150b8:	93a00001 	movls	r0, #1
	movhi	r0, #0	@ Operand 2 greater than operand 1, or unordered.
   150bc:	83a00000 	movhi	r0, #0
	RETLDM
   150c0:	e49de008 	ldr	lr, [sp], #8
   150c4:	e12fff1e 	bx	lr

000150c8 <__aeabi_dcmpgt>:

	FUNC_END aeabi_dcmpge

ARM_FUNC_START	aeabi_dcmpgt

	str	lr, [sp, #-8]!
   150c8:	e52de008 	str	lr, [sp, #-8]!
	ARM_CALL aeabi_cdrcmple
   150cc:	ebffffd8 	bl	15034 <__aeabi_cdrcmple>
	do_it	cc, e
	movcc	r0, #1	@ Operand 2 is less than operand 1.
   150d0:	33a00001 	movcc	r0, #1
	movcs	r0, #0  @ Operand 2 is greater than or equal to operand 1,
   150d4:	23a00000 	movcs	r0, #0
			@ or they are unordered.
	RETLDM
   150d8:	e49de008 	ldr	lr, [sp], #8
   150dc:	e12fff1e 	bx	lr

000150e0 <__aeabi_d2iz>:

ARM_FUNC_START fixdfsi
ARM_FUNC_ALIAS aeabi_d2iz fixdfsi

	@ check exponent range.
	mov	r2, xh, lsl #1
   150e0:	e1a02081 	lsl	r2, r1, #1
	adds	r2, r2, #(1 << 21)
   150e4:	e2922602 	adds	r2, r2, #2097152	; 0x200000
	bcs	2f			@ value is INF or NAN
   150e8:	2a00000c 	bcs	15120 <__aeabi_d2iz+0x40>
	bpl	1f			@ value is too small
   150ec:	5a000009 	bpl	15118 <__aeabi_d2iz+0x38>
	mov	r3, #(0xfffffc00 + 31)
   150f0:	e3e03e3e 	mvn	r3, #992	; 0x3e0
	subs	r2, r3, r2, asr #21
   150f4:	e0532ac2 	subs	r2, r3, r2, asr #21
	bls	3f			@ value is too large
   150f8:	9a00000a 	bls	15128 <__aeabi_d2iz+0x48>

	@ scale value
	mov	r3, xh, lsl #11
   150fc:	e1a03581 	lsl	r3, r1, #11
	orr	r3, r3, #0x80000000
   15100:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
	orr	r3, r3, xl, lsr #21
   15104:	e1833aa0 	orr	r3, r3, r0, lsr #21
	tst	xh, #0x80000000		@ the sign bit
   15108:	e3110102 	tst	r1, #-2147483648	; 0x80000000
	shift1	lsr, r0, r3, r2
   1510c:	e1a00233 	lsr	r0, r3, r2
	do_it	ne
	rsbne	r0, r0, #0
   15110:	12600000 	rsbne	r0, r0, #0
	RET
   15114:	e12fff1e 	bx	lr

1:	mov	r0, #0
   15118:	e3a00000 	mov	r0, #0
	RET
   1511c:	e12fff1e 	bx	lr

2:	orrs	xl, xl, xh, lsl #12
   15120:	e1900601 	orrs	r0, r0, r1, lsl #12
	bne	4f			@ x is NAN.
   15124:	1a000002 	bne	15134 <__aeabi_d2iz+0x54>
3:	ands	r0, xh, #0x80000000	@ the sign bit
   15128:	e2110102 	ands	r0, r1, #-2147483648	; 0x80000000
	do_it	eq
	moveq	r0, #0x7fffffff		@ maximum signed positive si
   1512c:	03e00102 	mvneq	r0, #-2147483648	; 0x80000000
	RET
   15130:	e12fff1e 	bx	lr

4:	mov	r0, #0			@ How should we convert NAN?
   15134:	e3a00000 	mov	r0, #0
	RET
   15138:	e12fff1e 	bx	lr

0001513c <__aeabi_ldivmod>:
	.endif
	b	SYM (__aeabi_ldiv0) __PLT__
1:
#else
	/* Note: Thumb-1 code calls via an ARM shim on processors which
	   support ARM mode.  */
   1513c:	e3530000 	cmp	r3, #0
   15140:	03520000 	cmpeq	r2, #0
   15144:	1a000006 	bne	15164 <__aeabi_ldivmod+0x28>
   15148:	e3510000 	cmp	r1, #0
   1514c:	03500000 	cmpeq	r0, #0
   15150:	b3a01102 	movlt	r1, #-2147483648	; 0x80000000
   15154:	b3a00000 	movlt	r0, #0
   15158:	c3e01102 	mvngt	r1, #-2147483648	; 0x80000000
   1515c:	c3e00000 	mvngt	r0, #0
   15160:	eafffd5e 	b	146e0 <__aeabi_idiv0>
	cmp	yyh, #0
   15164:	e24dd008 	sub	sp, sp, #8
	cmpeq	yyl, #0
	bne	2f
	cmp	xxh, #0
	cmpeq	xxl, #0
	.ifc \signed, unsigned
   15168:	e92d6000 	push	{sp, lr}
	movne	xxh, #0xffffffff
	movne	xxl, #0xffffffff
	.else
   1516c:	eb000012 	bl	151bc <__gnu_ldivmod_helper>
	movlt	xxh, #0x80000000
   15170:	e59de004 	ldr	lr, [sp, #4]
	movlt	xxl, #0
   15174:	e28dd008 	add	sp, sp, #8
	movgt	xxh, #0x7fffffff
   15178:	e8bd000c 	pop	{r2, r3}
	movgt	xxl, #0xffffffff
   1517c:	e12fff1e 	bx	lr

00015180 <__aeabi_uldivmod>:
	.endif
	b	SYM (__aeabi_ldiv0) __PLT__
1:
#else
	/* Note: Thumb-1 code calls via an ARM shim on processors which
	   support ARM mode.  */
   15180:	e3530000 	cmp	r3, #0
   15184:	03520000 	cmpeq	r2, #0
   15188:	1a000004 	bne	151a0 <__aeabi_uldivmod+0x20>
   1518c:	e3510000 	cmp	r1, #0
   15190:	03500000 	cmpeq	r0, #0
   15194:	13e01000 	mvnne	r1, #0
   15198:	13e00000 	mvnne	r0, #0
   1519c:	eafffd4f 	b	146e0 <__aeabi_idiv0>

ARM_FUNC_START aeabi_uldivmod
	cfi_start	__aeabi_uldivmod, LSYM(Lend_aeabi_uldivmod)
	test_div_by_zero unsigned

	sub sp, sp, #8
   151a0:	e24dd008 	sub	sp, sp, #8
#if defined(__thumb2__)
	mov ip, sp
	push {ip, lr}
#else
	do_push {sp, lr}
   151a4:	e92d6000 	push	{sp, lr}
#endif
98:	cfi_push 98b - __aeabi_uldivmod, 0xe, -0xc, 0x10
	bl SYM(__gnu_uldivmod_helper) __PLT__
   151a8:	eb000014 	bl	15200 <__gnu_uldivmod_helper>
	ldr lr, [sp, #4]
   151ac:	e59de004 	ldr	lr, [sp, #4]
	add sp, sp, #8
   151b0:	e28dd008 	add	sp, sp, #8
	do_pop {r2, r3}
   151b4:	e8bd000c 	pop	{r2, r3}
	RET
   151b8:	e12fff1e 	bx	lr

000151bc <__gnu_ldivmod_helper>:

long long
__gnu_ldivmod_helper (long long a, 
		      long long b, 
		      long long *remainder)
{
   151bc:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
   151c0:	e59d9020 	ldr	r9, [sp, #32]
   151c4:	e1a08002 	mov	r8, r2
   151c8:	e1a0a003 	mov	sl, r3
   151cc:	e1a06000 	mov	r6, r0
   151d0:	e1a07001 	mov	r7, r1
  long long quotient;

  quotient = __divdi3 (a, b);
   151d4:	eb000019 	bl	15240 <__divdi3>
   151d8:	e1a02000 	mov	r2, r0
  *remainder = a - b * quotient;
   151dc:	e0030198 	mul	r3, r8, r1
   151e0:	e0854098 	umull	r4, r5, r8, r0
   151e4:	e022329a 	mla	r2, sl, r2, r3
   151e8:	e0564004 	subs	r4, r6, r4
   151ec:	e0825005 	add	r5, r2, r5
   151f0:	e0c75005 	sbc	r5, r7, r5
   151f4:	e8890030 	stm	r9, {r4, r5}
  return quotient;
}
   151f8:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}
   151fc:	e12fff1e 	bx	lr

00015200 <__gnu_uldivmod_helper>:

unsigned long long
__gnu_uldivmod_helper (unsigned long long a, 
		       unsigned long long b,
		       unsigned long long *remainder)
{
   15200:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
   15204:	e59d9020 	ldr	r9, [sp, #32]
   15208:	e1a06000 	mov	r6, r0
   1520c:	e1a07001 	mov	r7, r1
   15210:	e1a08002 	mov	r8, r2
   15214:	e1a04003 	mov	r4, r3
  unsigned long long quotient;

  quotient = __udivdi3 (a, b);
   15218:	eb000139 	bl	15704 <__udivdi3>
  *remainder = a - b * quotient;
   1521c:	e0030490 	mul	r3, r0, r4
   15220:	e0854890 	umull	r4, r5, r0, r8
   15224:	e0283891 	mla	r8, r1, r8, r3
   15228:	e0564004 	subs	r4, r6, r4
   1522c:	e0885005 	add	r5, r8, r5
   15230:	e0c75005 	sbc	r5, r7, r5
   15234:	e8890030 	stm	r9, {r4, r5}
  return quotient;
}
   15238:	e8bd43f8 	pop	{r3, r4, r5, r6, r7, r8, r9, lr}
   1523c:	e12fff1e 	bx	lr

00015240 <__divdi3>:
#endif

#ifdef L_divdi3
DWtype
__divdi3 (DWtype u, DWtype v)
{
   15240:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  Wtype c = 0;
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
   15244:	e3510000 	cmp	r1, #0
#endif

#ifdef L_divdi3
DWtype
__divdi3 (DWtype u, DWtype v)
{
   15248:	e24dd014 	sub	sp, sp, #20
   1524c:	a1a04000 	movge	r4, r0
   15250:	a1a05001 	movge	r5, r1
  Wtype c = 0;
   15254:	a3a06000 	movge	r6, #0
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
   15258:	ba0000e1 	blt	155e4 <__divdi3+0x3a4>
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
   1525c:	e3530000 	cmp	r3, #0
   15260:	ba0000db 	blt	155d4 <__divdi3+0x394>
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
   15264:	e3530000 	cmp	r3, #0
static inline __attribute__ ((__always_inline__))
#endif
UDWtype
__udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)
{
  const DWunion nn = {.ll = n};
   15268:	e1a0c004 	mov	ip, r4
   1526c:	e1a0b005 	mov	fp, r5
  const DWunion dd = {.ll = d};
   15270:	e1a0a002 	mov	sl, r2
  DWunion rr;
  UWtype d0, d1, n0, n1, n2;
  UWtype q0, q1;
  UWtype b, bm;

  d0 = dd.s.low;
   15274:	e1a07002 	mov	r7, r2
  d1 = dd.s.high;
  n0 = nn.s.low;
   15278:	e1a08004 	mov	r8, r4
  n1 = nn.s.high;
   1527c:	e1a09005 	mov	r9, r5
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
   15280:	1a000040 	bne	15388 <__divdi3+0x148>
    {
      if (d0 > n1)
   15284:	e1520005 	cmp	r2, r5
   15288:	9a000096 	bls	154e8 <__divdi3+0x2a8>
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   1528c:	e1a00002 	mov	r0, r2
   15290:	eb000237 	bl	15b74 <__clzsi2>

	  if (bm != 0)
   15294:	e3500000 	cmp	r0, #0
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   15298:	12603020 	rsbne	r3, r0, #32
	  if (bm != 0)
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
   1529c:	11a0701a 	lslne	r7, sl, r0
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   152a0:	11a03334 	lsrne	r3, r4, r3
   152a4:	11839015 	orrne	r9, r3, r5, lsl r0
	      n0 = n0 << bm;
   152a8:	11a08014 	lslne	r8, r4, r0
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   152ac:	e1a04827 	lsr	r4, r7, #16
   152b0:	e1a01004 	mov	r1, r4
   152b4:	e1a00009 	mov	r0, r9
   152b8:	ebfffc71 	bl	14484 <__aeabi_uidiv>
   152bc:	e1a0a000 	mov	sl, r0
   152c0:	e1a01004 	mov	r1, r4
   152c4:	e1a00009 	mov	r0, r9
   152c8:	ebfffcaa 	bl	14578 <__aeabi_uidivmod>
   152cc:	e1a0b807 	lsl	fp, r7, #16
   152d0:	e1a0b82b 	lsr	fp, fp, #16
   152d4:	e0000a9b 	mul	r0, fp, sl
   152d8:	e1a03828 	lsr	r3, r8, #16
   152dc:	e1831801 	orr	r1, r3, r1, lsl #16
   152e0:	e1500001 	cmp	r0, r1
   152e4:	9a000007 	bls	15308 <__divdi3+0xc8>
   152e8:	e0911007 	adds	r1, r1, r7
   152ec:	e24a2001 	sub	r2, sl, #1
   152f0:	2a000003 	bcs	15304 <__divdi3+0xc4>
   152f4:	e1500001 	cmp	r0, r1
   152f8:	824aa002 	subhi	sl, sl, #2
   152fc:	80811007 	addhi	r1, r1, r7
   15300:	8a000000 	bhi	15308 <__divdi3+0xc8>
   15304:	e1a0a002 	mov	sl, r2
   15308:	e0609001 	rsb	r9, r0, r1
   1530c:	e1a00009 	mov	r0, r9
   15310:	e1a01004 	mov	r1, r4
   15314:	ebfffc5a 	bl	14484 <__aeabi_uidiv>
   15318:	e1a05000 	mov	r5, r0
   1531c:	e1a01004 	mov	r1, r4
   15320:	e1a00009 	mov	r0, r9
   15324:	ebfffc93 	bl	14578 <__aeabi_uidivmod>
   15328:	e00b0b95 	mul	fp, r5, fp
   1532c:	e1a08808 	lsl	r8, r8, #16
   15330:	e1a08828 	lsr	r8, r8, #16
   15334:	e1881801 	orr	r1, r8, r1, lsl #16
   15338:	e15b0001 	cmp	fp, r1
   1533c:	9a000006 	bls	1535c <__divdi3+0x11c>
   15340:	e0917007 	adds	r7, r1, r7
   15344:	e2453001 	sub	r3, r5, #1
   15348:	2a000002 	bcs	15358 <__divdi3+0x118>
   1534c:	e15b0007 	cmp	fp, r7
   15350:	82455002 	subhi	r5, r5, #2
   15354:	8a000000 	bhi	1535c <__divdi3+0x11c>
   15358:	e1a05003 	mov	r5, r3
   1535c:	e3a04000 	mov	r4, #0
   15360:	e185a80a 	orr	sl, r5, sl, lsl #16
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;

  w = __udivmoddi4 (uu.ll, vv.ll, (UDWtype *) 0);
  if (c)
   15364:	e3560000 	cmp	r6, #0
	    }
	}
    }

  const DWunion ww = {{.low = q0, .high = q1}};
  return ww.ll;
   15368:	e1a0000a 	mov	r0, sl
   1536c:	e1a01004 	mov	r1, r4
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;

  w = __udivmoddi4 (uu.ll, vv.ll, (UDWtype *) 0);
  if (c)
   15370:	0a000001 	beq	1537c <__divdi3+0x13c>
    w = -w;
   15374:	e27a0000 	rsbs	r0, sl, #0
   15378:	e2e41000 	rsc	r1, r4, #0

  return w;
}
   1537c:	e28dd014 	add	sp, sp, #20
   15380:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15384:	e12fff1e 	bx	lr
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
   15388:	e1530005 	cmp	r3, r5
   1538c:	83a04000 	movhi	r4, #0
   15390:	81a0a004 	movhi	sl, r4
   15394:	8afffff2 	bhi	15364 <__divdi3+0x124>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   15398:	e1a00003 	mov	r0, r3
   1539c:	e58dc008 	str	ip, [sp, #8]
   153a0:	e58d300c 	str	r3, [sp, #12]
   153a4:	eb0001f2 	bl	15b74 <__clzsi2>
	  if (bm == 0)
   153a8:	e2504000 	subs	r4, r0, #0
   153ac:	e59d100c 	ldr	r1, [sp, #12]
   153b0:	e59dc008 	ldr	ip, [sp, #8]
   153b4:	0a0000c5 	beq	156d0 <__divdi3+0x490>
	  else
	    {
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;
   153b8:	e2643020 	rsb	r3, r4, #32

	      d1 = (d1 << bm) | (d0 >> b);
   153bc:	e1a0533a 	lsr	r5, sl, r3
   153c0:	e1855411 	orr	r5, r5, r1, lsl r4
	      d0 = d0 << bm;
	      n2 = n1 >> b;
   153c4:	e1a0233b 	lsr	r2, fp, r3
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   153c8:	e1a07825 	lsr	r7, r5, #16
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   153cc:	e1a03338 	lsr	r3, r8, r3
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   153d0:	e1a01007 	mov	r1, r7
   153d4:	e1a00002 	mov	r0, r2
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   153d8:	e183b41b 	orr	fp, r3, fp, lsl r4
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   153dc:	e58d200c 	str	r2, [sp, #12]
   153e0:	ebfffc27 	bl	14484 <__aeabi_uidiv>
   153e4:	e1a03000 	mov	r3, r0
   153e8:	e59d200c 	ldr	r2, [sp, #12]
   153ec:	e1a01007 	mov	r1, r7
   153f0:	e1a00002 	mov	r0, r2
   153f4:	e58d3004 	str	r3, [sp, #4]
   153f8:	ebfffc5e 	bl	14578 <__aeabi_uidivmod>
   153fc:	e1a09805 	lsl	r9, r5, #16
   15400:	e59d3004 	ldr	r3, [sp, #4]
   15404:	e1a09829 	lsr	r9, r9, #16
   15408:	e0000399 	mul	r0, r9, r3
   1540c:	e1a0282b 	lsr	r2, fp, #16
   15410:	e1821801 	orr	r1, r2, r1, lsl #16
   15414:	e1500001 	cmp	r0, r1
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
   15418:	e1a0a41a 	lsl	sl, sl, r4
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   1541c:	9a000006 	bls	1543c <__divdi3+0x1fc>
   15420:	e0911005 	adds	r1, r1, r5
   15424:	e2432001 	sub	r2, r3, #1
   15428:	2a0000b1 	bcs	156f4 <__divdi3+0x4b4>
   1542c:	e1500001 	cmp	r0, r1
   15430:	82433002 	subhi	r3, r3, #2
   15434:	80811005 	addhi	r1, r1, r5
   15438:	9a0000ad 	bls	156f4 <__divdi3+0x4b4>
   1543c:	e0602001 	rsb	r2, r0, r1
   15440:	e1a00002 	mov	r0, r2
   15444:	e1a01007 	mov	r1, r7
   15448:	e58d3004 	str	r3, [sp, #4]
   1544c:	e58d200c 	str	r2, [sp, #12]
   15450:	ebfffc0b 	bl	14484 <__aeabi_uidiv>
   15454:	e1a0c000 	mov	ip, r0
   15458:	e59d200c 	ldr	r2, [sp, #12]
   1545c:	e1a01007 	mov	r1, r7
   15460:	e1a00002 	mov	r0, r2
   15464:	e58dc008 	str	ip, [sp, #8]
   15468:	ebfffc42 	bl	14578 <__aeabi_uidivmod>
   1546c:	e59dc008 	ldr	ip, [sp, #8]
   15470:	e009099c 	mul	r9, ip, r9
   15474:	e1a0b80b 	lsl	fp, fp, #16
   15478:	e1a0e82b 	lsr	lr, fp, #16
   1547c:	e18e1801 	orr	r1, lr, r1, lsl #16
   15480:	e1590001 	cmp	r9, r1
   15484:	e59d3004 	ldr	r3, [sp, #4]
   15488:	9a000006 	bls	154a8 <__divdi3+0x268>
   1548c:	e0911005 	adds	r1, r1, r5
   15490:	e24c2001 	sub	r2, ip, #1
   15494:	2a000094 	bcs	156ec <__divdi3+0x4ac>
   15498:	e1590001 	cmp	r9, r1
   1549c:	824cc002 	subhi	ip, ip, #2
   154a0:	80811005 	addhi	r1, r1, r5
   154a4:	9a000090 	bls	156ec <__divdi3+0x4ac>
   154a8:	e18cc803 	orr	ip, ip, r3, lsl #16
	      umul_ppmm (m1, m0, q0, d0);
   154ac:	e0832a9c 	umull	r2, r3, ip, sl
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   154b0:	e0699001 	rsb	r9, r9, r1
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   154b4:	e1590003 	cmp	r9, r3
   154b8:	3a000007 	bcc	154dc <__divdi3+0x29c>
   154bc:	03a03001 	moveq	r3, #1
   154c0:	13a03000 	movne	r3, #0
   154c4:	e1520418 	cmp	r2, r8, lsl r4
   154c8:	93a04000 	movls	r4, #0
   154cc:	82034001 	andhi	r4, r3, #1
   154d0:	e3540000 	cmp	r4, #0
   154d4:	01a0a00c 	moveq	sl, ip
   154d8:	0affffa1 	beq	15364 <__divdi3+0x124>
		{
		  q0--;
   154dc:	e24ca001 	sub	sl, ip, #1
		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
   154e0:	e3a04000 	mov	r4, #0
   154e4:	eaffff9e 	b	15364 <__divdi3+0x124>
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
   154e8:	e3520000 	cmp	r2, #0
   154ec:	1a000003 	bne	15500 <__divdi3+0x2c0>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
   154f0:	e1a01002 	mov	r1, r2
   154f4:	e3a00001 	mov	r0, #1
   154f8:	ebfffbe1 	bl	14484 <__aeabi_uidiv>
   154fc:	e1a07000 	mov	r7, r0

	  count_leading_zeros (bm, d0);
   15500:	e1a00007 	mov	r0, r7
   15504:	eb00019a 	bl	15b74 <__clzsi2>

	  if (bm == 0)
   15508:	e2503000 	subs	r3, r0, #0
   1550c:	1a000038 	bne	155f4 <__divdi3+0x3b4>
		 leading quotient digit q1 = 1).

		 This special case is necessary, not an optimization.
		 (Shifts counts of W_TYPE_SIZE are undefined.)  */

	      n1 -= d0;
   15510:	e3a04001 	mov	r4, #1
   15514:	e1a0b807 	lsl	fp, r7, #16
   15518:	e0679009 	rsb	r9, r7, r9
   1551c:	e1a0b82b 	lsr	fp, fp, #16
   15520:	e1a05827 	lsr	r5, r7, #16
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   15524:	e1a01005 	mov	r1, r5
   15528:	e1a00009 	mov	r0, r9
   1552c:	ebfffbd4 	bl	14484 <__aeabi_uidiv>
   15530:	e1a0a000 	mov	sl, r0
   15534:	e1a01005 	mov	r1, r5
   15538:	e1a00009 	mov	r0, r9
   1553c:	ebfffc0d 	bl	14578 <__aeabi_uidivmod>
   15540:	e0000a9b 	mul	r0, fp, sl
   15544:	e1a03828 	lsr	r3, r8, #16
   15548:	e1831801 	orr	r1, r3, r1, lsl #16
   1554c:	e1500001 	cmp	r0, r1
   15550:	9a000006 	bls	15570 <__divdi3+0x330>
   15554:	e0911007 	adds	r1, r1, r7
   15558:	e24a2001 	sub	r2, sl, #1
   1555c:	2a000060 	bcs	156e4 <__divdi3+0x4a4>
   15560:	e1500001 	cmp	r0, r1
   15564:	824aa002 	subhi	sl, sl, #2
   15568:	80811007 	addhi	r1, r1, r7
   1556c:	9a00005c 	bls	156e4 <__divdi3+0x4a4>
   15570:	e0603001 	rsb	r3, r0, r1
   15574:	e1a00003 	mov	r0, r3
   15578:	e1a01005 	mov	r1, r5
   1557c:	e58d3004 	str	r3, [sp, #4]
   15580:	ebfffbbf 	bl	14484 <__aeabi_uidiv>
   15584:	e1a09000 	mov	r9, r0
   15588:	e59d3004 	ldr	r3, [sp, #4]
   1558c:	e1a01005 	mov	r1, r5
   15590:	e1a00003 	mov	r0, r3
   15594:	ebfffbf7 	bl	14578 <__aeabi_uidivmod>
   15598:	e00b0b99 	mul	fp, r9, fp
   1559c:	e1a08808 	lsl	r8, r8, #16
   155a0:	e1a08828 	lsr	r8, r8, #16
   155a4:	e1881801 	orr	r1, r8, r1, lsl #16
   155a8:	e15b0001 	cmp	fp, r1
   155ac:	9a000006 	bls	155cc <__divdi3+0x38c>
   155b0:	e0917007 	adds	r7, r1, r7
   155b4:	e2493001 	sub	r3, r9, #1
   155b8:	2a000002 	bcs	155c8 <__divdi3+0x388>
   155bc:	e15b0007 	cmp	fp, r7
   155c0:	82499002 	subhi	r9, r9, #2
   155c4:	8a000000 	bhi	155cc <__divdi3+0x38c>
   155c8:	e1a09003 	mov	r9, r3
   155cc:	e189a80a 	orr	sl, r9, sl, lsl #16
   155d0:	eaffff63 	b	15364 <__divdi3+0x124>
  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;
   155d4:	e2722000 	rsbs	r2, r2, #0

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    c = ~c,
   155d8:	e1e06006 	mvn	r6, r6
    vv.ll = -vv.ll;
   155dc:	e2e33000 	rsc	r3, r3, #0
   155e0:	eaffff1f 	b	15264 <__divdi3+0x24>
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
   155e4:	e2704000 	rsbs	r4, r0, #0
   155e8:	e2e15000 	rsc	r5, r1, #0
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
   155ec:	e3e06000 	mvn	r6, #0
   155f0:	eaffff19 	b	1525c <__divdi3+0x1c>
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
   155f4:	e1a07317 	lsl	r7, r7, r3
	    }
	  else
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;
   155f8:	e2632020 	rsb	r2, r3, #32

	      d0 = d0 << bm;
	      n2 = n1 >> b;
   155fc:	e1a04239 	lsr	r4, r9, r2
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   15600:	e1a05827 	lsr	r5, r7, #16

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   15604:	e1a02238 	lsr	r2, r8, r2
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   15608:	e1a01005 	mov	r1, r5
   1560c:	e1a00004 	mov	r0, r4

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   15610:	e1829319 	orr	r9, r2, r9, lsl r3
	      n0 = n0 << bm;
   15614:	e1a08318 	lsl	r8, r8, r3

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   15618:	ebfffb99 	bl	14484 <__aeabi_uidiv>
   1561c:	e1a0a000 	mov	sl, r0
   15620:	e1a01005 	mov	r1, r5
   15624:	e1a00004 	mov	r0, r4
   15628:	ebfffbd2 	bl	14578 <__aeabi_uidivmod>
   1562c:	e1a0b807 	lsl	fp, r7, #16
   15630:	e1a0b82b 	lsr	fp, fp, #16
   15634:	e0000a9b 	mul	r0, fp, sl
   15638:	e1a03829 	lsr	r3, r9, #16
   1563c:	e1831801 	orr	r1, r3, r1, lsl #16
   15640:	e1500001 	cmp	r0, r1
   15644:	9a000006 	bls	15664 <__divdi3+0x424>
   15648:	e0911007 	adds	r1, r1, r7
   1564c:	e24a3001 	sub	r3, sl, #1
   15650:	2a000029 	bcs	156fc <__divdi3+0x4bc>
   15654:	e1500001 	cmp	r0, r1
   15658:	824aa002 	subhi	sl, sl, #2
   1565c:	80811007 	addhi	r1, r1, r7
   15660:	9a000025 	bls	156fc <__divdi3+0x4bc>
   15664:	e0603001 	rsb	r3, r0, r1
   15668:	e1a00003 	mov	r0, r3
   1566c:	e1a01005 	mov	r1, r5
   15670:	e58d3004 	str	r3, [sp, #4]
   15674:	ebfffb82 	bl	14484 <__aeabi_uidiv>
   15678:	e1a04000 	mov	r4, r0
   1567c:	e59d3004 	ldr	r3, [sp, #4]
   15680:	e1a01005 	mov	r1, r5
   15684:	e1a00003 	mov	r0, r3
   15688:	ebfffbba 	bl	14578 <__aeabi_uidivmod>
   1568c:	e003049b 	mul	r3, fp, r4
   15690:	e1a09809 	lsl	r9, r9, #16
   15694:	e1a09829 	lsr	r9, r9, #16
   15698:	e1891801 	orr	r1, r9, r1, lsl #16
   1569c:	e1530001 	cmp	r3, r1
   156a0:	9a000007 	bls	156c4 <__divdi3+0x484>
   156a4:	e0911007 	adds	r1, r1, r7
   156a8:	e2442001 	sub	r2, r4, #1
   156ac:	2a000003 	bcs	156c0 <__divdi3+0x480>
   156b0:	e1530001 	cmp	r3, r1
   156b4:	82444002 	subhi	r4, r4, #2
   156b8:	80811007 	addhi	r1, r1, r7
   156bc:	8a000000 	bhi	156c4 <__divdi3+0x484>
   156c0:	e1a04002 	mov	r4, r2
   156c4:	e0639001 	rsb	r9, r3, r1
   156c8:	e184480a 	orr	r4, r4, sl, lsl #16
   156cc:	eaffff94 	b	15524 <__divdi3+0x2e4>
	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
   156d0:	e1510005 	cmp	r1, r5
   156d4:	215a000c 	cmpcs	sl, ip
   156d8:	93a0a001 	movls	sl, #1
   156dc:	83a0a000 	movhi	sl, #0
   156e0:	eaffff1f 	b	15364 <__divdi3+0x124>
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   156e4:	e1a0a002 	mov	sl, r2
   156e8:	eaffffa0 	b	15570 <__divdi3+0x330>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   156ec:	e1a0c002 	mov	ip, r2
   156f0:	eaffff6c 	b	154a8 <__divdi3+0x268>
   156f4:	e1a03002 	mov	r3, r2
   156f8:	eaffff4f 	b	1543c <__divdi3+0x1fc>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   156fc:	e1a0a003 	mov	sl, r3
   15700:	eaffffd7 	b	15664 <__divdi3+0x424>

00015704 <__udivdi3>:
#endif

#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
   15704:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
   15708:	e3530000 	cmp	r3, #0
#endif

#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
   1570c:	e24dd00c 	sub	sp, sp, #12
   15710:	e1a07003 	mov	r7, r3
   15714:	e1a09000 	mov	r9, r0
   15718:	e1a05001 	mov	r5, r1
   1571c:	e1a06002 	mov	r6, r2
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
   15720:	1a00003d 	bne	1581c <__udivdi3+0x118>
    {
      if (d0 > n1)
   15724:	e1520001 	cmp	r2, r1
   15728:	e1a04002 	mov	r4, r2
   1572c:	e1a0a000 	mov	sl, r0
   15730:	9a000085 	bls	1594c <__udivdi3+0x248>
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
   15734:	e1a00002 	mov	r0, r2
   15738:	e1a08001 	mov	r8, r1
   1573c:	eb00010c 	bl	15b74 <__clzsi2>

	  if (bm != 0)
   15740:	e3500000 	cmp	r0, #0
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   15744:	12608020 	rsbne	r8, r0, #32
	  if (bm != 0)
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
   15748:	11a04016 	lslne	r4, r6, r0
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
   1574c:	11a08839 	lsrne	r8, r9, r8
   15750:	11888015 	orrne	r8, r8, r5, lsl r0
	      n0 = n0 << bm;
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   15754:	e1a0b824 	lsr	fp, r4, #16
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
	      n0 = n0 << bm;
   15758:	11a0a019 	lslne	sl, r9, r0
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   1575c:	e1a0100b 	mov	r1, fp
   15760:	e1a00008 	mov	r0, r8
   15764:	ebfffb46 	bl	14484 <__aeabi_uidiv>
   15768:	e1a06000 	mov	r6, r0
   1576c:	e1a0100b 	mov	r1, fp
   15770:	e1a00008 	mov	r0, r8
   15774:	ebfffb7f 	bl	14578 <__aeabi_uidivmod>
   15778:	e1a07804 	lsl	r7, r4, #16
   1577c:	e1a07827 	lsr	r7, r7, #16
   15780:	e0000697 	mul	r0, r7, r6
   15784:	e1a0382a 	lsr	r3, sl, #16
   15788:	e1831801 	orr	r1, r3, r1, lsl #16
   1578c:	e1500001 	cmp	r0, r1
   15790:	9a000007 	bls	157b4 <__udivdi3+0xb0>
   15794:	e0911004 	adds	r1, r1, r4
   15798:	e2462001 	sub	r2, r6, #1
   1579c:	2a000003 	bcs	157b0 <__udivdi3+0xac>
   157a0:	e1500001 	cmp	r0, r1
   157a4:	82466002 	subhi	r6, r6, #2
   157a8:	80811004 	addhi	r1, r1, r4
   157ac:	8a000000 	bhi	157b4 <__udivdi3+0xb0>
   157b0:	e1a06002 	mov	r6, r2
   157b4:	e0608001 	rsb	r8, r0, r1
   157b8:	e1a00008 	mov	r0, r8
   157bc:	e1a0100b 	mov	r1, fp
   157c0:	ebfffb2f 	bl	14484 <__aeabi_uidiv>
   157c4:	e1a05000 	mov	r5, r0
   157c8:	e1a0100b 	mov	r1, fp
   157cc:	e1a00008 	mov	r0, r8
   157d0:	ebfffb68 	bl	14578 <__aeabi_uidivmod>
   157d4:	e0070795 	mul	r7, r5, r7
   157d8:	e1a0a80a 	lsl	sl, sl, #16
   157dc:	e1a0a82a 	lsr	sl, sl, #16
   157e0:	e18a1801 	orr	r1, sl, r1, lsl #16
   157e4:	e1570001 	cmp	r7, r1
   157e8:	9a000005 	bls	15804 <__udivdi3+0x100>
   157ec:	e0914004 	adds	r4, r1, r4
   157f0:	e2453001 	sub	r3, r5, #1
   157f4:	2a0000cc 	bcs	15b2c <__udivdi3+0x428>
   157f8:	e1570004 	cmp	r7, r4
   157fc:	82455002 	subhi	r5, r5, #2
   15800:	9a0000c9 	bls	15b2c <__udivdi3+0x428>
   15804:	e3a08000 	mov	r8, #0
   15808:	e1850806 	orr	r0, r5, r6, lsl #16
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
   1580c:	e1a01008 	mov	r1, r8
   15810:	e28dd00c 	add	sp, sp, #12
   15814:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15818:	e12fff1e 	bx	lr
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
   1581c:	e1530001 	cmp	r3, r1
   15820:	83a08000 	movhi	r8, #0
   15824:	81a00008 	movhi	r0, r8
   15828:	8afffff7 	bhi	1580c <__udivdi3+0x108>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
   1582c:	e1a00003 	mov	r0, r3
   15830:	eb0000cf 	bl	15b74 <__clzsi2>
	  if (bm == 0)
   15834:	e2508000 	subs	r8, r0, #0
   15838:	0a00007e 	beq	15a38 <__udivdi3+0x334>
	  else
	    {
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;
   1583c:	e2683020 	rsb	r3, r8, #32

	      d1 = (d1 << bm) | (d0 >> b);
   15840:	e1a02336 	lsr	r2, r6, r3
   15844:	e1827817 	orr	r7, r2, r7, lsl r8
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   15848:	e1a04827 	lsr	r4, r7, #16

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
   1584c:	e1a02335 	lsr	r2, r5, r3
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   15850:	e1a01004 	mov	r1, r4
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   15854:	e1a03339 	lsr	r3, r9, r3
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   15858:	e1a00002 	mov	r0, r2
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   1585c:	e1835815 	orr	r5, r3, r5, lsl r8
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   15860:	e58d2004 	str	r2, [sp, #4]
   15864:	ebfffb06 	bl	14484 <__aeabi_uidiv>
   15868:	e1a0b000 	mov	fp, r0
   1586c:	e59d2004 	ldr	r2, [sp, #4]
   15870:	e1a01004 	mov	r1, r4
   15874:	e1a00002 	mov	r0, r2
   15878:	ebfffb3e 	bl	14578 <__aeabi_uidivmod>
   1587c:	e1a0a807 	lsl	sl, r7, #16
   15880:	e1a0a82a 	lsr	sl, sl, #16
   15884:	e0000b9a 	mul	r0, sl, fp
   15888:	e1a03825 	lsr	r3, r5, #16
   1588c:	e1831801 	orr	r1, r3, r1, lsl #16
   15890:	e1500001 	cmp	r0, r1
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
   15894:	e1a06816 	lsl	r6, r6, r8
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   15898:	9a000003 	bls	158ac <__udivdi3+0x1a8>
   1589c:	e0911007 	adds	r1, r1, r7
   158a0:	e24b2001 	sub	r2, fp, #1
   158a4:	3a0000ab 	bcc	15b58 <__udivdi3+0x454>
   158a8:	e1a0b002 	mov	fp, r2
   158ac:	e0603001 	rsb	r3, r0, r1
   158b0:	e1a00003 	mov	r0, r3
   158b4:	e1a01004 	mov	r1, r4
   158b8:	e58d3004 	str	r3, [sp, #4]
   158bc:	ebfffaf0 	bl	14484 <__aeabi_uidiv>
   158c0:	e1a02000 	mov	r2, r0
   158c4:	e59d3004 	ldr	r3, [sp, #4]
   158c8:	e1a01004 	mov	r1, r4
   158cc:	e1a00003 	mov	r0, r3
   158d0:	e58d2004 	str	r2, [sp, #4]
   158d4:	ebfffb27 	bl	14578 <__aeabi_uidivmod>
   158d8:	e59d2004 	ldr	r2, [sp, #4]
   158dc:	e00a0a92 	mul	sl, r2, sl
   158e0:	e1a05805 	lsl	r5, r5, #16
   158e4:	e1a05825 	lsr	r5, r5, #16
   158e8:	e1851801 	orr	r1, r5, r1, lsl #16
   158ec:	e15a0001 	cmp	sl, r1
   158f0:	9a000003 	bls	15904 <__udivdi3+0x200>
   158f4:	e0911007 	adds	r1, r1, r7
   158f8:	e2423001 	sub	r3, r2, #1
   158fc:	3a000090 	bcc	15b44 <__udivdi3+0x440>
   15900:	e1a02003 	mov	r2, r3
   15904:	e182080b 	orr	r0, r2, fp, lsl #16
	      umul_ppmm (m1, m0, q0, d0);
   15908:	e0854690 	umull	r4, r5, r0, r6
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   1590c:	e06aa001 	rsb	sl, sl, r1
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
   15910:	e15a0005 	cmp	sl, r5
   15914:	3a000006 	bcc	15934 <__udivdi3+0x230>
   15918:	03a03001 	moveq	r3, #1
   1591c:	13a03000 	movne	r3, #0
   15920:	e1540819 	cmp	r4, r9, lsl r8
   15924:	93a08000 	movls	r8, #0
   15928:	82038001 	andhi	r8, r3, #1
   1592c:	e3580000 	cmp	r8, #0
   15930:	0affffb5 	beq	1580c <__udivdi3+0x108>
		{
		  q0--;
		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
   15934:	e3a08000 	mov	r8, #0
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
   15938:	e1a01008 	mov	r1, r8
	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
		{
		  q0--;
   1593c:	e2400001 	sub	r0, r0, #1
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
   15940:	e28dd00c 	add	sp, sp, #12
   15944:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15948:	e12fff1e 	bx	lr
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
   1594c:	e3520000 	cmp	r2, #0
   15950:	1a000003 	bne	15964 <__udivdi3+0x260>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
   15954:	e1a01002 	mov	r1, r2
   15958:	e3a00001 	mov	r0, #1
   1595c:	ebfffac8 	bl	14484 <__aeabi_uidiv>
   15960:	e1a04000 	mov	r4, r0

	  count_leading_zeros (bm, d0);
   15964:	e1a00004 	mov	r0, r4
   15968:	eb000081 	bl	15b74 <__clzsi2>

	  if (bm == 0)
   1596c:	e2503000 	subs	r3, r0, #0
   15970:	1a000038 	bne	15a58 <__udivdi3+0x354>
		 leading quotient digit q1 = 1).

		 This special case is necessary, not an optimization.
		 (Shifts counts of W_TYPE_SIZE are undefined.)  */

	      n1 -= d0;
   15974:	e3a08001 	mov	r8, #1
   15978:	e1a07804 	lsl	r7, r4, #16
   1597c:	e0645005 	rsb	r5, r4, r5
   15980:	e1a07827 	lsr	r7, r7, #16
   15984:	e1a0b824 	lsr	fp, r4, #16
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   15988:	e1a0100b 	mov	r1, fp
   1598c:	e1a00005 	mov	r0, r5
   15990:	ebfffabb 	bl	14484 <__aeabi_uidiv>
   15994:	e1a06000 	mov	r6, r0
   15998:	e1a0100b 	mov	r1, fp
   1599c:	e1a00005 	mov	r0, r5
   159a0:	ebfffaf4 	bl	14578 <__aeabi_uidivmod>
   159a4:	e0000697 	mul	r0, r7, r6
   159a8:	e1a0382a 	lsr	r3, sl, #16
   159ac:	e1831801 	orr	r1, r3, r1, lsl #16
   159b0:	e1500001 	cmp	r0, r1
   159b4:	9a000006 	bls	159d4 <__udivdi3+0x2d0>
   159b8:	e0911004 	adds	r1, r1, r4
   159bc:	e2462001 	sub	r2, r6, #1
   159c0:	2a00005b 	bcs	15b34 <__udivdi3+0x430>
   159c4:	e1500001 	cmp	r0, r1
   159c8:	82466002 	subhi	r6, r6, #2
   159cc:	80811004 	addhi	r1, r1, r4
   159d0:	9a000057 	bls	15b34 <__udivdi3+0x430>
   159d4:	e0609001 	rsb	r9, r0, r1
   159d8:	e1a00009 	mov	r0, r9
   159dc:	e1a0100b 	mov	r1, fp
   159e0:	ebfffaa7 	bl	14484 <__aeabi_uidiv>
   159e4:	e1a05000 	mov	r5, r0
   159e8:	e1a0100b 	mov	r1, fp
   159ec:	e1a00009 	mov	r0, r9
   159f0:	ebfffae0 	bl	14578 <__aeabi_uidivmod>
   159f4:	e0070795 	mul	r7, r5, r7
   159f8:	e1a0a80a 	lsl	sl, sl, #16
   159fc:	e1a0a82a 	lsr	sl, sl, #16
   15a00:	e18a1801 	orr	r1, sl, r1, lsl #16
   15a04:	e1570001 	cmp	r7, r1
   15a08:	9a000005 	bls	15a24 <__udivdi3+0x320>
   15a0c:	e0914004 	adds	r4, r1, r4
   15a10:	e2453001 	sub	r3, r5, #1
   15a14:	2a000048 	bcs	15b3c <__udivdi3+0x438>
   15a18:	e1570004 	cmp	r7, r4
   15a1c:	82455002 	subhi	r5, r5, #2
   15a20:	9a000045 	bls	15b3c <__udivdi3+0x438>
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
   15a24:	e1a01008 	mov	r1, r8
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   15a28:	e1850806 	orr	r0, r5, r6, lsl #16
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
   15a2c:	e28dd00c 	add	sp, sp, #12
   15a30:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15a34:	e12fff1e 	bx	lr
	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
   15a38:	e1570005 	cmp	r7, r5
   15a3c:	21560009 	cmpcs	r6, r9
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
   15a40:	e1a01008 	mov	r1, r8
	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
   15a44:	93a00001 	movls	r0, #1
   15a48:	83a00000 	movhi	r0, #0
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
   15a4c:	e28dd00c 	add	sp, sp, #12
   15a50:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15a54:	e12fff1e 	bx	lr
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
   15a58:	e1a04314 	lsl	r4, r4, r3
	    }
	  else
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;
   15a5c:	e2632020 	rsb	r2, r3, #32

	      d0 = d0 << bm;
	      n2 = n1 >> b;
   15a60:	e1a08235 	lsr	r8, r5, r2
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   15a64:	e1a0b824 	lsr	fp, r4, #16

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   15a68:	e1a02239 	lsr	r2, r9, r2
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   15a6c:	e1a0100b 	mov	r1, fp
   15a70:	e1a00008 	mov	r0, r8

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
   15a74:	e1825315 	orr	r5, r2, r5, lsl r3
	      n0 = n0 << bm;
   15a78:	e1a0a319 	lsl	sl, r9, r3

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   15a7c:	ebfffa80 	bl	14484 <__aeabi_uidiv>
   15a80:	e1a06000 	mov	r6, r0
   15a84:	e1a0100b 	mov	r1, fp
   15a88:	e1a00008 	mov	r0, r8
   15a8c:	ebfffab9 	bl	14578 <__aeabi_uidivmod>
   15a90:	e1a07804 	lsl	r7, r4, #16
   15a94:	e1a07827 	lsr	r7, r7, #16
   15a98:	e0000697 	mul	r0, r7, r6
   15a9c:	e1a03825 	lsr	r3, r5, #16
   15aa0:	e1831801 	orr	r1, r3, r1, lsl #16
   15aa4:	e1500001 	cmp	r0, r1
   15aa8:	9a000006 	bls	15ac8 <__udivdi3+0x3c4>
   15aac:	e0911004 	adds	r1, r1, r4
   15ab0:	e2463001 	sub	r3, r6, #1
   15ab4:	2a00002c 	bcs	15b6c <__udivdi3+0x468>
   15ab8:	e1500001 	cmp	r0, r1
   15abc:	82466002 	subhi	r6, r6, #2
   15ac0:	80811004 	addhi	r1, r1, r4
   15ac4:	9a000028 	bls	15b6c <__udivdi3+0x468>
   15ac8:	e0609001 	rsb	r9, r0, r1
   15acc:	e1a00009 	mov	r0, r9
   15ad0:	e1a0100b 	mov	r1, fp
   15ad4:	ebfffa6a 	bl	14484 <__aeabi_uidiv>
   15ad8:	e1a08000 	mov	r8, r0
   15adc:	e1a0100b 	mov	r1, fp
   15ae0:	e1a00009 	mov	r0, r9
   15ae4:	ebfffaa3 	bl	14578 <__aeabi_uidivmod>
   15ae8:	e0030897 	mul	r3, r7, r8
   15aec:	e1a05805 	lsl	r5, r5, #16
   15af0:	e1a05825 	lsr	r5, r5, #16
   15af4:	e1851801 	orr	r1, r5, r1, lsl #16
   15af8:	e1530001 	cmp	r3, r1
   15afc:	9a000007 	bls	15b20 <__udivdi3+0x41c>
   15b00:	e0911004 	adds	r1, r1, r4
   15b04:	e2482001 	sub	r2, r8, #1
   15b08:	2a000003 	bcs	15b1c <__udivdi3+0x418>
   15b0c:	e1530001 	cmp	r3, r1
   15b10:	82488002 	subhi	r8, r8, #2
   15b14:	80811004 	addhi	r1, r1, r4
   15b18:	8a000000 	bhi	15b20 <__udivdi3+0x41c>
   15b1c:	e1a08002 	mov	r8, r2
   15b20:	e0635001 	rsb	r5, r3, r1
   15b24:	e1888806 	orr	r8, r8, r6, lsl #16
   15b28:	eaffff96 	b	15988 <__udivdi3+0x284>
	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
	      n0 = n0 << bm;
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   15b2c:	e1a05003 	mov	r5, r3
   15b30:	eaffff33 	b	15804 <__udivdi3+0x100>
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
   15b34:	e1a06002 	mov	r6, r2
   15b38:	eaffffa5 	b	159d4 <__udivdi3+0x2d0>
   15b3c:	e1a05003 	mov	r5, r3
   15b40:	eaffffb7 	b	15a24 <__udivdi3+0x320>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
   15b44:	e15a0001 	cmp	sl, r1
   15b48:	82422002 	subhi	r2, r2, #2
   15b4c:	80811007 	addhi	r1, r1, r7
   15b50:	8affff6b 	bhi	15904 <__udivdi3+0x200>
   15b54:	eaffff69 	b	15900 <__udivdi3+0x1fc>
   15b58:	e1500001 	cmp	r0, r1
   15b5c:	824bb002 	subhi	fp, fp, #2
   15b60:	80811007 	addhi	r1, r1, r7
   15b64:	8affff50 	bhi	158ac <__udivdi3+0x1a8>
   15b68:	eaffff4e 	b	158a8 <__udivdi3+0x1a4>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
   15b6c:	e1a06003 	mov	r6, r3
   15b70:	eaffffd4 	b	15ac8 <__udivdi3+0x3c4>

00015b74 <__clzsi2>:
ARM_FUNC_START clzsi2
# if defined(HAVE_ARM_CLZ)
	clz	r0, r0
	RET
# else
	mov	r1, #28
   15b74:	e3a0101c 	mov	r1, #28
	cmp	r0, #0x10000
   15b78:	e3500801 	cmp	r0, #65536	; 0x10000
	do_it	cs, t
	movcs	r0, r0, lsr #16
   15b7c:	21a00820 	lsrcs	r0, r0, #16
	subcs	r1, r1, #16
   15b80:	22411010 	subcs	r1, r1, #16
	cmp	r0, #0x100
   15b84:	e3500c01 	cmp	r0, #256	; 0x100
	do_it	cs, t
	movcs	r0, r0, lsr #8
   15b88:	21a00420 	lsrcs	r0, r0, #8
	subcs	r1, r1, #8
   15b8c:	22411008 	subcs	r1, r1, #8
	cmp	r0, #0x10
   15b90:	e3500010 	cmp	r0, #16
	do_it	cs, t
	movcs	r0, r0, lsr #4
   15b94:	21a00220 	lsrcs	r0, r0, #4
	subcs	r1, r1, #4
   15b98:	22411004 	subcs	r1, r1, #4
	adr	r2, 1f
   15b9c:	e28f2008 	add	r2, pc, #8
	ldrb	r0, [r2, r0]
   15ba0:	e7d20000 	ldrb	r0, [r2, r0]
	add	r0, r0, r1
   15ba4:	e0800001 	add	r0, r0, r1
	RET
   15ba8:	e12fff1e 	bx	lr
   15bac:	02020304 	.word	0x02020304
   15bb0:	01010101 	.word	0x01010101
	...

00015bbc <close>:
#include <VirtualFileSystem/VirtualFileSystem.h>

int
_DEFUN (_close, (fildes),
        int fildes)
{
   15bbc:	e92d4800 	push	{fp, lr}
   15bc0:	e28db004 	add	fp, sp, #4
   15bc4:	e24dd010 	sub	sp, sp, #16
   15bc8:	e50b0010 	str	r0, [fp, #-16]
	status_t status = DNA_OK;
   15bcc:	e3a03000 	mov	r3, #0
   15bd0:	e14b30b6 	strh	r3, [fp, #-6]

  status = vfs_close (fildes);
   15bd4:	e51b3010 	ldr	r3, [fp, #-16]
   15bd8:	e1a03803 	lsl	r3, r3, #16
   15bdc:	e1a03823 	lsr	r3, r3, #16
   15be0:	e1a03803 	lsl	r3, r3, #16
   15be4:	e1a03843 	asr	r3, r3, #16
   15be8:	e1a00003 	mov	r0, r3
   15bec:	ebffe315 	bl	e848 <vfs_close>
   15bf0:	e1a03000 	mov	r3, r0
   15bf4:	e14b30b6 	strh	r3, [fp, #-6]

	if (status == DNA_OK) return 0;
   15bf8:	e15b30b6 	ldrh	r3, [fp, #-6]
   15bfc:	e3530000 	cmp	r3, #0
   15c00:	1a000001 	bne	15c0c <close+0x50>
   15c04:	e3a03000 	mov	r3, #0
   15c08:	ea000000 	b	15c10 <close+0x54>
	else return -1;
   15c0c:	e3e03000 	mvn	r3, #0
}
   15c10:	e1a00003 	mov	r0, r3
   15c14:	e24bd004 	sub	sp, fp, #4
   15c18:	e8bd4800 	pop	{fp, lr}
   15c1c:	e12fff1e 	bx	lr

00015c20 <exit>:
 */

void
_DEFUN (exit, (code),
	int code)
{
   15c20:	e92d4800 	push	{fp, lr}
   15c24:	e28db004 	add	fp, sp, #4
   15c28:	e24dd008 	sub	sp, sp, #8
   15c2c:	e50b0008 	str	r0, [fp, #-8]
#ifdef _LITE_EXIT
  /* Refer to comments in __atexit.c for more details of lite exit.  */
  void __call_exitprocs _PARAMS ((int, _PTR)) __attribute__((weak));
  if (__call_exitprocs)
#endif
    __call_exitprocs (code, NULL);
   15c30:	e51b0008 	ldr	r0, [fp, #-8]
   15c34:	e3a01000 	mov	r1, #0
   15c38:	eb00268d 	bl	1f674 <__call_exitprocs>

  if (_GLOBAL_REENT->__cleanup)
   15c3c:	e59f3034 	ldr	r3, [pc, #52]	; 15c78 <exit+0x58>
   15c40:	e5933000 	ldr	r3, [r3]
   15c44:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
   15c48:	e3530000 	cmp	r3, #0
   15c4c:	0a000007 	beq	15c70 <exit+0x50>
    (*_GLOBAL_REENT->__cleanup) (_GLOBAL_REENT);
   15c50:	e59f3020 	ldr	r3, [pc, #32]	; 15c78 <exit+0x58>
   15c54:	e5933000 	ldr	r3, [r3]
   15c58:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
   15c5c:	e59f2014 	ldr	r2, [pc, #20]	; 15c78 <exit+0x58>
   15c60:	e5922000 	ldr	r2, [r2]
   15c64:	e1a00002 	mov	r0, r2
   15c68:	e1a0e00f 	mov	lr, pc
   15c6c:	e12fff13 	bx	r3
  _exit (code);
   15c70:	e51b0008 	ldr	r0, [fp, #-8]
   15c74:	eb002f1d 	bl	218f0 <_exit>
   15c78:	00033004 	.word	0x00033004

00015c7c <__sflush_r>:
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   15c7c:	e92d48f0 	push	{r4, r5, r6, r7, fp, lr}
   15c80:	e28db014 	add	fp, sp, #20
   15c84:	e24dd020 	sub	sp, sp, #32
   15c88:	e50b0028 	str	r0, [fp, #-40]	; 0x28
   15c8c:	e1a04001 	mov	r4, r1
  register unsigned char *p;
  register int n, t;

  t = fp->_flags;
   15c90:	e1d430bc 	ldrh	r3, [r4, #12]
   15c94:	e1a03803 	lsl	r3, r3, #16
   15c98:	e1a06843 	asr	r6, r3, #16
  if ((t & __SWR) == 0)
   15c9c:	e2063008 	and	r3, r6, #8
   15ca0:	e3530000 	cmp	r3, #0
   15ca4:	1a0000bf 	bne	15fa8 <__sflush_r+0x32c>
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
   15ca8:	e1d430bc 	ldrh	r3, [r4, #12]
   15cac:	e3833b02 	orr	r3, r3, #2048	; 0x800
   15cb0:	e1a03803 	lsl	r3, r3, #16
   15cb4:	e1a03823 	lsr	r3, r3, #16
   15cb8:	e1c430bc 	strh	r3, [r4, #12]
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   15cbc:	e5943004 	ldr	r3, [r4, #4]
   15cc0:	e3530000 	cmp	r3, #0
   15cc4:	ca000002 	bgt	15cd4 <__sflush_r+0x58>
   15cc8:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
   15ccc:	e3530000 	cmp	r3, #0
   15cd0:	da0000b2 	ble	15fa0 <__sflush_r+0x324>
   15cd4:	e5943028 	ldr	r3, [r4, #40]	; 0x28
   15cd8:	e3530000 	cmp	r3, #0
   15cdc:	0a0000af 	beq	15fa0 <__sflush_r+0x324>
#endif

	  /* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
   15ce0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   15ce4:	e5933000 	ldr	r3, [r3]
   15ce8:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	  ptr->_errno = 0;
   15cec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   15cf0:	e3a02000 	mov	r2, #0
   15cf4:	e5832000 	str	r2, [r3]
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
   15cf8:	e1d430bc 	ldrh	r3, [r4, #12]
   15cfc:	e1a03803 	lsl	r3, r3, #16
   15d00:	e1a03823 	lsr	r3, r3, #16
   15d04:	e2033a01 	and	r3, r3, #4096	; 0x1000
   15d08:	e3530000 	cmp	r3, #0
   15d0c:	0a000004 	beq	15d24 <__sflush_r+0xa8>
	    curoff = fp->_offset;
   15d10:	e2843050 	add	r3, r4, #80	; 0x50
   15d14:	e893000c 	ldm	r3, {r2, r3}
   15d18:	e50b201c 	str	r2, [fp, #-28]
   15d1c:	e50b3018 	str	r3, [fp, #-24]
   15d20:	ea00002d 	b	15ddc <__sflush_r+0x160>
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   15d24:	e594c028 	ldr	ip, [r4, #40]	; 0x28
   15d28:	e594301c 	ldr	r3, [r4, #28]
   15d2c:	e3a02001 	mov	r2, #1
   15d30:	e58d2000 	str	r2, [sp]
   15d34:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
   15d38:	e1a01003 	mov	r1, r3
   15d3c:	e3a02000 	mov	r2, #0
   15d40:	e3a03000 	mov	r3, #0
   15d44:	e1a0e00f 	mov	lr, pc
   15d48:	e12fff1c 	bx	ip
   15d4c:	e50b001c 	str	r0, [fp, #-28]
   15d50:	e50b1018 	str	r1, [fp, #-24]
	      if (curoff == -1L && ptr->_errno != 0)
   15d54:	e24b101c 	sub	r1, fp, #28
   15d58:	e8910003 	ldm	r1, {r0, r1}
   15d5c:	e3e02000 	mvn	r2, #0
   15d60:	e3e03000 	mvn	r3, #0
   15d64:	e1510003 	cmp	r1, r3
   15d68:	01500002 	cmpeq	r0, r2
   15d6c:	1a00001a 	bne	15ddc <__sflush_r+0x160>
   15d70:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   15d74:	e5933000 	ldr	r3, [r3]
   15d78:	e3530000 	cmp	r3, #0
   15d7c:	0a000016 	beq	15ddc <__sflush_r+0x160>
		{
		  int result = EOF;
   15d80:	e3e03000 	mvn	r3, #0
   15d84:	e50b3020 	str	r3, [fp, #-32]
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
   15d88:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   15d8c:	e5933000 	ldr	r3, [r3]
   15d90:	e353001d 	cmp	r3, #29
   15d94:	0a000003 	beq	15da8 <__sflush_r+0x12c>
   15d98:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   15d9c:	e5933000 	ldr	r3, [r3]
   15da0:	e3530016 	cmp	r3, #22
   15da4:	1a000005 	bne	15dc0 <__sflush_r+0x144>
		    {
		      result = 0;
   15da8:	e3a03000 	mov	r3, #0
   15dac:	e50b3020 	str	r3, [fp, #-32]
		      ptr->_errno = tmp_errno;
   15db0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   15db4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   15db8:	e5832000 	str	r2, [r3]
   15dbc:	ea000004 	b	15dd4 <__sflush_r+0x158>
		    }
		  else
		    fp->_flags |= __SERR;
   15dc0:	e1d430bc 	ldrh	r3, [r4, #12]
   15dc4:	e3833040 	orr	r3, r3, #64	; 0x40
   15dc8:	e1a03803 	lsl	r3, r3, #16
   15dcc:	e1a03823 	lsr	r3, r3, #16
   15dd0:	e1c430bc 	strh	r3, [r4, #12]
		  return result;
   15dd4:	e51b3020 	ldr	r3, [fp, #-32]
   15dd8:	ea00009c 	b	16050 <__sflush_r+0x3d4>
		}
            }
          if (fp->_flags & __SRD)
   15ddc:	e1d430bc 	ldrh	r3, [r4, #12]
   15de0:	e1a03803 	lsl	r3, r3, #16
   15de4:	e1a03823 	lsr	r3, r3, #16
   15de8:	e2033004 	and	r3, r3, #4
   15dec:	e3530000 	cmp	r3, #0
   15df0:	0a000014 	beq	15e48 <__sflush_r+0x1cc>
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
   15df4:	e5943004 	ldr	r3, [r4, #4]
   15df8:	e1a02003 	mov	r2, r3
   15dfc:	e1a03fc2 	asr	r3, r2, #31
   15e00:	e24b101c 	sub	r1, fp, #28
   15e04:	e8910003 	ldm	r1, {r0, r1}
   15e08:	e0502002 	subs	r2, r0, r2
   15e0c:	e0c13003 	sbc	r3, r1, r3
   15e10:	e50b201c 	str	r2, [fp, #-28]
   15e14:	e50b3018 	str	r3, [fp, #-24]
              if (HASUB (fp))
   15e18:	e5943030 	ldr	r3, [r4, #48]	; 0x30
   15e1c:	e3530000 	cmp	r3, #0
   15e20:	0a000008 	beq	15e48 <__sflush_r+0x1cc>
                curoff -= fp->_ur;
   15e24:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
   15e28:	e1a02003 	mov	r2, r3
   15e2c:	e1a03fc2 	asr	r3, r2, #31
   15e30:	e24b101c 	sub	r1, fp, #28
   15e34:	e8910003 	ldm	r1, {r0, r1}
   15e38:	e0502002 	subs	r2, r0, r2
   15e3c:	e0c13003 	sbc	r3, r1, r3
   15e40:	e50b201c 	str	r2, [fp, #-28]
   15e44:	e50b3018 	str	r3, [fp, #-24]
#ifdef __LARGE64_FILES
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
   15e48:	e594c028 	ldr	ip, [r4, #40]	; 0x28
   15e4c:	e594301c 	ldr	r3, [r4, #28]
   15e50:	e3a02000 	mov	r2, #0
   15e54:	e58d2000 	str	r2, [sp]
   15e58:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
   15e5c:	e1a01003 	mov	r1, r3
   15e60:	e24b301c 	sub	r3, fp, #28
   15e64:	e893000c 	ldm	r3, {r2, r3}
   15e68:	e1a0e00f 	mov	lr, pc
   15e6c:	e12fff1c 	bx	ip
   15e70:	e50b001c 	str	r0, [fp, #-28]
   15e74:	e50b1018 	str	r1, [fp, #-24]
	  if (curoff != -1 || ptr->_errno == 0
   15e78:	e24b101c 	sub	r1, fp, #28
   15e7c:	e8910003 	ldm	r1, {r0, r1}
   15e80:	e3e02000 	mvn	r2, #0
   15e84:	e3e03000 	mvn	r3, #0
   15e88:	e1510003 	cmp	r1, r3
   15e8c:	01500002 	cmpeq	r0, r2
   15e90:	1a00000b 	bne	15ec4 <__sflush_r+0x248>
   15e94:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   15e98:	e5933000 	ldr	r3, [r3]
   15e9c:	e3530000 	cmp	r3, #0
   15ea0:	0a000007 	beq	15ec4 <__sflush_r+0x248>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
   15ea4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   15ea8:	e5933000 	ldr	r3, [r3]
   15eac:	e353001d 	cmp	r3, #29
   15eb0:	0a000003 	beq	15ec4 <__sflush_r+0x248>
   15eb4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   15eb8:	e5933000 	ldr	r3, [r3]
   15ebc:	e3530016 	cmp	r3, #22
   15ec0:	1a00002f 	bne	15f84 <__sflush_r+0x308>
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   15ec4:	e1d430bc 	ldrh	r3, [r4, #12]
   15ec8:	e3c33b02 	bic	r3, r3, #2048	; 0x800
   15ecc:	e1a03803 	lsl	r3, r3, #16
   15ed0:	e1a03823 	lsr	r3, r3, #16
   15ed4:	e1c430bc 	strh	r3, [r4, #12]
#endif
	      fp->_r = 0;
   15ed8:	e3a03000 	mov	r3, #0
   15edc:	e5843004 	str	r3, [r4, #4]
	      fp->_p = fp->_bf._base;
   15ee0:	e5943010 	ldr	r3, [r4, #16]
   15ee4:	e5843000 	str	r3, [r4]
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   15ee8:	e1d430bc 	ldrh	r3, [r4, #12]
   15eec:	e1a03803 	lsl	r3, r3, #16
   15ef0:	e1a03823 	lsr	r3, r3, #16
   15ef4:	e2033a01 	and	r3, r3, #4096	; 0x1000
   15ef8:	e3530000 	cmp	r3, #0
   15efc:	0a00000e 	beq	15f3c <__sflush_r+0x2c0>
   15f00:	e24b101c 	sub	r1, fp, #28
   15f04:	e8910003 	ldm	r1, {r0, r1}
   15f08:	e3e02000 	mvn	r2, #0
   15f0c:	e3e03000 	mvn	r3, #0
   15f10:	e1510003 	cmp	r1, r3
   15f14:	01500002 	cmpeq	r0, r2
   15f18:	1a000003 	bne	15f2c <__sflush_r+0x2b0>
   15f1c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   15f20:	e5933000 	ldr	r3, [r3]
   15f24:	e3530000 	cmp	r3, #0
   15f28:	1a000003 	bne	15f3c <__sflush_r+0x2c0>
		fp->_offset = curoff;
   15f2c:	e24b301c 	sub	r3, fp, #28
   15f30:	e893000c 	ldm	r3, {r2, r3}
   15f34:	e5842050 	str	r2, [r4, #80]	; 0x50
   15f38:	e5843054 	str	r3, [r4, #84]	; 0x54
	      ptr->_errno = tmp_errno;
   15f3c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   15f40:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   15f44:	e5832000 	str	r2, [r3]
	      if (HASUB (fp))
   15f48:	e5943030 	ldr	r3, [r4, #48]	; 0x30
   15f4c:	e3530000 	cmp	r3, #0
   15f50:	0a00000a 	beq	15f80 <__sflush_r+0x304>
		FREEUB (ptr, fp);
   15f54:	e5942030 	ldr	r2, [r4, #48]	; 0x30
   15f58:	e2843040 	add	r3, r4, #64	; 0x40
   15f5c:	e1520003 	cmp	r2, r3
   15f60:	0a000003 	beq	15f74 <__sflush_r+0x2f8>
   15f64:	e5943030 	ldr	r3, [r4, #48]	; 0x30
   15f68:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
   15f6c:	e1a01003 	mov	r1, r3
   15f70:	eb000246 	bl	16890 <_free_r>
   15f74:	e3a03000 	mov	r3, #0
   15f78:	e5843030 	str	r3, [r4, #48]	; 0x30
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
	      if (HASUB (fp))
   15f7c:	ea000007 	b	15fa0 <__sflush_r+0x324>
   15f80:	ea000006 	b	15fa0 <__sflush_r+0x324>
		FREEUB (ptr, fp);
	    }
	  else
	    {
	      fp->_flags |= __SERR;
   15f84:	e1d430bc 	ldrh	r3, [r4, #12]
   15f88:	e3833040 	orr	r3, r3, #64	; 0x40
   15f8c:	e1a03803 	lsl	r3, r3, #16
   15f90:	e1a03823 	lsr	r3, r3, #16
   15f94:	e1c430bc 	strh	r3, [r4, #12]
	      return EOF;
   15f98:	e3e03000 	mvn	r3, #0
   15f9c:	ea00002b 	b	16050 <__sflush_r+0x3d4>
	    }
	}
      return 0;
   15fa0:	e3a03000 	mov	r3, #0
   15fa4:	ea000029 	b	16050 <__sflush_r+0x3d4>
    }
  if ((p = fp->_bf._base) == NULL)
   15fa8:	e5945010 	ldr	r5, [r4, #16]
   15fac:	e3550000 	cmp	r5, #0
   15fb0:	1a000001 	bne	15fbc <__sflush_r+0x340>
    {
      /* Nothing to flush.  */
      return 0;
   15fb4:	e3a03000 	mov	r3, #0
   15fb8:	ea000024 	b	16050 <__sflush_r+0x3d4>
    }
  n = fp->_p - p;		/* write this much */
   15fbc:	e5943000 	ldr	r3, [r4]
   15fc0:	e1a02003 	mov	r2, r3
   15fc4:	e1a03005 	mov	r3, r5
   15fc8:	e0637002 	rsb	r7, r3, r2
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
   15fcc:	e5845000 	str	r5, [r4]
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   15fd0:	e2063003 	and	r3, r6, #3
   15fd4:	e3530000 	cmp	r3, #0
   15fd8:	1a000001 	bne	15fe4 <__sflush_r+0x368>
   15fdc:	e5943014 	ldr	r3, [r4, #20]
   15fe0:	ea000000 	b	15fe8 <__sflush_r+0x36c>
   15fe4:	e3a03000 	mov	r3, #0
   15fe8:	e5843008 	str	r3, [r4, #8]

  while (n > 0)
   15fec:	ea000014 	b	16044 <__sflush_r+0x3c8>
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
   15ff0:	e594c024 	ldr	ip, [r4, #36]	; 0x24
   15ff4:	e594301c 	ldr	r3, [r4, #28]
   15ff8:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
   15ffc:	e1a01003 	mov	r1, r3
   16000:	e1a02005 	mov	r2, r5
   16004:	e1a03007 	mov	r3, r7
   16008:	e1a0e00f 	mov	lr, pc
   1600c:	e12fff1c 	bx	ip
   16010:	e1a06000 	mov	r6, r0
      if (t <= 0)
   16014:	e3560000 	cmp	r6, #0
   16018:	ca000006 	bgt	16038 <__sflush_r+0x3bc>
	{
          fp->_flags |= __SERR;
   1601c:	e1d430bc 	ldrh	r3, [r4, #12]
   16020:	e3833040 	orr	r3, r3, #64	; 0x40
   16024:	e1a03803 	lsl	r3, r3, #16
   16028:	e1a03823 	lsr	r3, r3, #16
   1602c:	e1c430bc 	strh	r3, [r4, #12]
          return EOF;
   16030:	e3e03000 	mvn	r3, #0
   16034:	ea000005 	b	16050 <__sflush_r+0x3d4>
	}
      p += t;
   16038:	e1a03006 	mov	r3, r6
   1603c:	e0855003 	add	r5, r5, r3
      n -= t;
   16040:	e0667007 	rsb	r7, r6, r7
   * write function.
   */
  fp->_p = p;
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
   16044:	e3570000 	cmp	r7, #0
   16048:	caffffe8 	bgt	15ff0 <__sflush_r+0x374>
          return EOF;
	}
      p += t;
      n -= t;
    }
  return 0;
   1604c:	e3a03000 	mov	r3, #0
}
   16050:	e1a00003 	mov	r0, r3
   16054:	e24bd014 	sub	sp, fp, #20
   16058:	e8bd48f0 	pop	{r4, r5, r6, r7, fp, lr}
   1605c:	e12fff1e 	bx	lr

00016060 <_fflush_r>:

int
_DEFUN(_fflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   16060:	e92d4810 	push	{r4, fp, lr}
   16064:	e28db008 	add	fp, sp, #8
   16068:	e24dd014 	sub	sp, sp, #20
   1606c:	e50b0018 	str	r0, [fp, #-24]
   16070:	e1a04001 	mov	r4, r1
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
   16074:	e51b3018 	ldr	r3, [fp, #-24]
   16078:	e50b3010 	str	r3, [fp, #-16]
   1607c:	e51b3010 	ldr	r3, [fp, #-16]
   16080:	e3530000 	cmp	r3, #0
   16084:	0a000005 	beq	160a0 <_fflush_r+0x40>
   16088:	e51b3010 	ldr	r3, [fp, #-16]
   1608c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   16090:	e3530000 	cmp	r3, #0
   16094:	1a000001 	bne	160a0 <_fflush_r+0x40>
   16098:	e51b0010 	ldr	r0, [fp, #-16]
   1609c:	eb00013a 	bl	1658c <__sinit>

  if (!fp->_flags)
   160a0:	e1d430bc 	ldrh	r3, [r4, #12]
   160a4:	e3530000 	cmp	r3, #0
   160a8:	1a000001 	bne	160b4 <_fflush_r+0x54>
    return 0;
   160ac:	e3a03000 	mov	r3, #0
   160b0:	ea000016 	b	16110 <_fflush_r+0xb0>

  _newlib_flockfile_start (fp);
   160b4:	e1d430bc 	ldrh	r3, [r4, #12]
   160b8:	e1a03803 	lsl	r3, r3, #16
   160bc:	e1a03823 	lsr	r3, r3, #16
   160c0:	e2033c02 	and	r3, r3, #512	; 0x200
   160c4:	e3530000 	cmp	r3, #0
   160c8:	1a000002 	bne	160d8 <_fflush_r+0x78>
   160cc:	e284305c 	add	r3, r4, #92	; 0x5c
   160d0:	e1a00003 	mov	r0, r3
   160d4:	eb0004e9 	bl	17480 <_dna_lock_acquire>
  ret = __sflush_r (ptr, fp);
   160d8:	e51b0018 	ldr	r0, [fp, #-24]
   160dc:	e1a01004 	mov	r1, r4
   160e0:	ebfffee5 	bl	15c7c <__sflush_r>
   160e4:	e50b0014 	str	r0, [fp, #-20]
  _newlib_flockfile_end (fp);
   160e8:	e1d430bc 	ldrh	r3, [r4, #12]
   160ec:	e1a03803 	lsl	r3, r3, #16
   160f0:	e1a03823 	lsr	r3, r3, #16
   160f4:	e2033c02 	and	r3, r3, #512	; 0x200
   160f8:	e3530000 	cmp	r3, #0
   160fc:	1a000002 	bne	1610c <_fflush_r+0xac>
   16100:	e284305c 	add	r3, r4, #92	; 0x5c
   16104:	e1a00003 	mov	r0, r3
   16108:	eb000543 	bl	1761c <_dna_lock_release>
  return ret;
   1610c:	e51b3014 	ldr	r3, [fp, #-20]
}
   16110:	e1a00003 	mov	r0, r3
   16114:	e24bd008 	sub	sp, fp, #8
   16118:	e8bd4810 	pop	{r4, fp, lr}
   1611c:	e12fff1e 	bx	lr

00016120 <fflush>:
#ifndef _REENT_ONLY

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
   16120:	e92d4800 	push	{fp, lr}
   16124:	e28db004 	add	fp, sp, #4
   16128:	e1a03000 	mov	r3, r0
  if (fp == NULL)
   1612c:	e3530000 	cmp	r3, #0
   16130:	1a000006 	bne	16150 <fflush+0x30>
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);
   16134:	e59f303c 	ldr	r3, [pc, #60]	; 16178 <fflush+0x58>
   16138:	e5933000 	ldr	r3, [r3]
   1613c:	e1a00003 	mov	r0, r3
   16140:	e59f1034 	ldr	r1, [pc, #52]	; 1617c <fflush+0x5c>
   16144:	eb0003c1 	bl	17050 <_fwalk_reent>
   16148:	e1a03000 	mov	r3, r0
   1614c:	ea000005 	b	16168 <fflush+0x48>

  return _fflush_r (_REENT, fp);
   16150:	e59f2028 	ldr	r2, [pc, #40]	; 16180 <fflush+0x60>
   16154:	e5922000 	ldr	r2, [r2]
   16158:	e1a00002 	mov	r0, r2
   1615c:	e1a01003 	mov	r1, r3
   16160:	ebffffbe 	bl	16060 <_fflush_r>
   16164:	e1a03000 	mov	r3, r0
}
   16168:	e1a00003 	mov	r0, r3
   1616c:	e24bd004 	sub	sp, fp, #4
   16170:	e8bd4800 	pop	{fp, lr}
   16174:	e12fff1e 	bx	lr
   16178:	00033004 	.word	0x00033004
   1617c:	00016060 	.word	0x00016060
   16180:	0003e460 	.word	0x0003e460

00016184 <std>:
_DEFUN(std, (ptr, flags, file, data),
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
   16184:	e92d4800 	push	{fp, lr}
   16188:	e28db004 	add	fp, sp, #4
   1618c:	e24dd010 	sub	sp, sp, #16
   16190:	e50b0008 	str	r0, [fp, #-8]
   16194:	e50b100c 	str	r1, [fp, #-12]
   16198:	e50b2010 	str	r2, [fp, #-16]
   1619c:	e50b3014 	str	r3, [fp, #-20]
  ptr->_p = 0;
   161a0:	e51b3008 	ldr	r3, [fp, #-8]
   161a4:	e3a02000 	mov	r2, #0
   161a8:	e5832000 	str	r2, [r3]
  ptr->_r = 0;
   161ac:	e51b3008 	ldr	r3, [fp, #-8]
   161b0:	e3a02000 	mov	r2, #0
   161b4:	e5832004 	str	r2, [r3, #4]
  ptr->_w = 0;
   161b8:	e51b3008 	ldr	r3, [fp, #-8]
   161bc:	e3a02000 	mov	r2, #0
   161c0:	e5832008 	str	r2, [r3, #8]
  ptr->_flags = flags;
   161c4:	e51b300c 	ldr	r3, [fp, #-12]
   161c8:	e1a03803 	lsl	r3, r3, #16
   161cc:	e1a02823 	lsr	r2, r3, #16
   161d0:	e51b3008 	ldr	r3, [fp, #-8]
   161d4:	e1c320bc 	strh	r2, [r3, #12]
  ptr->_flags2 = 0;
   161d8:	e51b3008 	ldr	r3, [fp, #-8]
   161dc:	e3a02000 	mov	r2, #0
   161e0:	e583206c 	str	r2, [r3, #108]	; 0x6c
  ptr->_file = file;
   161e4:	e51b3010 	ldr	r3, [fp, #-16]
   161e8:	e1a03803 	lsl	r3, r3, #16
   161ec:	e1a02823 	lsr	r2, r3, #16
   161f0:	e51b3008 	ldr	r3, [fp, #-8]
   161f4:	e1c320be 	strh	r2, [r3, #14]
  ptr->_bf._base = 0;
   161f8:	e51b3008 	ldr	r3, [fp, #-8]
   161fc:	e3a02000 	mov	r2, #0
   16200:	e5832010 	str	r2, [r3, #16]
  ptr->_bf._size = 0;
   16204:	e51b3008 	ldr	r3, [fp, #-8]
   16208:	e3a02000 	mov	r2, #0
   1620c:	e5832014 	str	r2, [r3, #20]
  ptr->_lbfsize = 0;
   16210:	e51b3008 	ldr	r3, [fp, #-8]
   16214:	e3a02000 	mov	r2, #0
   16218:	e5832018 	str	r2, [r3, #24]
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   1621c:	e51b3008 	ldr	r3, [fp, #-8]
   16220:	e2833064 	add	r3, r3, #100	; 0x64
   16224:	e1a00003 	mov	r0, r3
   16228:	e3a01000 	mov	r1, #0
   1622c:	e3a02008 	mov	r2, #8
   16230:	eb000950 	bl	18778 <memset>
  ptr->_cookie = ptr;
   16234:	e51b3008 	ldr	r3, [fp, #-8]
   16238:	e51b2008 	ldr	r2, [fp, #-8]
   1623c:	e583201c 	str	r2, [r3, #28]
  ptr->_read = __sread;
   16240:	e51b3008 	ldr	r3, [fp, #-8]
   16244:	e59f2040 	ldr	r2, [pc, #64]	; 1628c <std+0x108>
   16248:	e5832020 	str	r2, [r3, #32]
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   1624c:	e51b3008 	ldr	r3, [fp, #-8]
   16250:	e59f2038 	ldr	r2, [pc, #56]	; 16290 <std+0x10c>
   16254:	e5832024 	str	r2, [r3, #36]	; 0x24
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   16258:	e51b3008 	ldr	r3, [fp, #-8]
   1625c:	e59f2030 	ldr	r2, [pc, #48]	; 16294 <std+0x110>
   16260:	e5832028 	str	r2, [r3, #40]	; 0x28
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   16264:	e51b3008 	ldr	r3, [fp, #-8]
   16268:	e59f2028 	ldr	r2, [pc, #40]	; 16298 <std+0x114>
   1626c:	e583202c 	str	r2, [r3, #44]	; 0x2c
#else /* _STDIO_CLOSE_STD_STREAMS */
  ptr->_close = NULL;
#endif /* _STDIO_CLOSE_STD_STREAMS */
#if !defined(__SINGLE_THREAD__) && !defined(_REENT_SMALL)
  __lock_init_recursive (ptr->_lock);
   16270:	e51b3008 	ldr	r3, [fp, #-8]
   16274:	e283305c 	add	r3, r3, #92	; 0x5c
   16278:	e1a00003 	mov	r0, r3
   1627c:	eb00042e 	bl	1733c <_dna_lock_init>

#ifdef __SCLE
  if (__stextmode (ptr->_file))
    ptr->_flags |= __SCLE;
#endif
}
   16280:	e24bd004 	sub	sp, fp, #4
   16284:	e8bd4800 	pop	{fp, lr}
   16288:	e12fff1e 	bx	lr
   1628c:	00018f48 	.word	0x00018f48
   16290:	00019010 	.word	0x00019010
   16294:	000190bc 	.word	0x000190bc
   16298:	00019170 	.word	0x00019170

0001629c <__sfmoreglue>:

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   1629c:	e92d4810 	push	{r4, fp, lr}
   162a0:	e28db008 	add	fp, sp, #8
   162a4:	e24dd014 	sub	sp, sp, #20
   162a8:	e50b0018 	str	r0, [fp, #-24]
   162ac:	e1a04001 	mov	r4, r1
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
   162b0:	e2443001 	sub	r3, r4, #1
   162b4:	e1a02003 	mov	r2, r3
   162b8:	e1a03002 	mov	r3, r2
   162bc:	e1a03183 	lsl	r3, r3, #3
   162c0:	e0623003 	rsb	r3, r2, r3
   162c4:	e1a03203 	lsl	r3, r3, #4
   162c8:	e2833080 	add	r3, r3, #128	; 0x80
       struct _reent *d _AND
       register int n)
{
  struct glue_with_file *g;

  g = (struct glue_with_file *)
   162cc:	e51b0018 	ldr	r0, [fp, #-24]
   162d0:	e1a01003 	mov	r1, r3
   162d4:	eb0005f6 	bl	17ab4 <_malloc_r>
   162d8:	e50b0010 	str	r0, [fp, #-16]
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
   162dc:	e51b3010 	ldr	r3, [fp, #-16]
   162e0:	e3530000 	cmp	r3, #0
   162e4:	1a000001 	bne	162f0 <__sfmoreglue+0x54>
    return NULL;
   162e8:	e3a03000 	mov	r3, #0
   162ec:	ea000014 	b	16344 <__sfmoreglue+0xa8>
  g->glue._next = NULL;
   162f0:	e51b3010 	ldr	r3, [fp, #-16]
   162f4:	e3a02000 	mov	r2, #0
   162f8:	e5832000 	str	r2, [r3]
  g->glue._niobs = n;
   162fc:	e51b3010 	ldr	r3, [fp, #-16]
   16300:	e5834004 	str	r4, [r3, #4]
  g->glue._iobs = &g->file;
   16304:	e51b3010 	ldr	r3, [fp, #-16]
   16308:	e2832010 	add	r2, r3, #16
   1630c:	e51b3010 	ldr	r3, [fp, #-16]
   16310:	e5832008 	str	r2, [r3, #8]
  memset (&g->file, 0, n * sizeof (FILE));
   16314:	e51b3010 	ldr	r3, [fp, #-16]
   16318:	e2831010 	add	r1, r3, #16
   1631c:	e1a02004 	mov	r2, r4
   16320:	e1a03002 	mov	r3, r2
   16324:	e1a03183 	lsl	r3, r3, #3
   16328:	e0623003 	rsb	r3, r2, r3
   1632c:	e1a03203 	lsl	r3, r3, #4
   16330:	e1a00001 	mov	r0, r1
   16334:	e3a01000 	mov	r1, #0
   16338:	e1a02003 	mov	r2, r3
   1633c:	eb00090d 	bl	18778 <memset>
  return &g->glue;
   16340:	e51b3010 	ldr	r3, [fp, #-16]
}
   16344:	e1a00003 	mov	r0, r3
   16348:	e24bd008 	sub	sp, fp, #8
   1634c:	e8bd4810 	pop	{r4, fp, lr}
   16350:	e12fff1e 	bx	lr

00016354 <__sfp>:
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   16354:	e92d4800 	push	{fp, lr}
   16358:	e28db004 	add	fp, sp, #4
   1635c:	e24dd018 	sub	sp, sp, #24
   16360:	e50b0018 	str	r0, [fp, #-24]
  FILE *fp;
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();
   16364:	eb0000bd 	bl	16660 <__sfp_lock_acquire>

  if (!_GLOBAL_REENT->__sdidinit)
   16368:	e59f31c4 	ldr	r3, [pc, #452]	; 16534 <__sfp+0x1e0>
   1636c:	e5933000 	ldr	r3, [r3]
   16370:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   16374:	e3530000 	cmp	r3, #0
   16378:	1a000003 	bne	1638c <__sfp+0x38>
    __sinit (_GLOBAL_REENT);
   1637c:	e59f31b0 	ldr	r3, [pc, #432]	; 16534 <__sfp+0x1e0>
   16380:	e5933000 	ldr	r3, [r3]
   16384:	e1a00003 	mov	r0, r3
   16388:	eb00007f 	bl	1658c <__sinit>
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
   1638c:	e59f31a0 	ldr	r3, [pc, #416]	; 16534 <__sfp+0x1e0>
   16390:	e5933000 	ldr	r3, [r3]
   16394:	e2833e2e 	add	r3, r3, #736	; 0x2e0
   16398:	e50b3010 	str	r3, [fp, #-16]
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   1639c:	e51b3010 	ldr	r3, [fp, #-16]
   163a0:	e5933008 	ldr	r3, [r3, #8]
   163a4:	e50b3008 	str	r3, [fp, #-8]
   163a8:	e51b3010 	ldr	r3, [fp, #-16]
   163ac:	e5933004 	ldr	r3, [r3, #4]
   163b0:	e50b300c 	str	r3, [fp, #-12]
   163b4:	ea00003b 	b	164a8 <__sfp+0x154>
	if (fp->_flags == 0)
   163b8:	e51b3008 	ldr	r3, [fp, #-8]
   163bc:	e1d330bc 	ldrh	r3, [r3, #12]
   163c0:	e3530000 	cmp	r3, #0
   163c4:	1a000034 	bne	1649c <__sfp+0x148>
	  goto found;
   163c8:	e1a00000 	nop			; (mov r0, r0)
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
  return NULL;

found:
  fp->_file = -1;		/* no file */
   163cc:	e51b3008 	ldr	r3, [fp, #-8]
   163d0:	e3e02000 	mvn	r2, #0
   163d4:	e1c320be 	strh	r2, [r3, #14]
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
   163d8:	e51b3008 	ldr	r3, [fp, #-8]
   163dc:	e3a02001 	mov	r2, #1
   163e0:	e1c320bc 	strh	r2, [r3, #12]
  fp->_flags2 = 0;
   163e4:	e51b3008 	ldr	r3, [fp, #-8]
   163e8:	e3a02000 	mov	r2, #0
   163ec:	e583206c 	str	r2, [r3, #108]	; 0x6c
#ifndef __SINGLE_THREAD__
  __lock_init_recursive (fp->_lock);
   163f0:	e51b3008 	ldr	r3, [fp, #-8]
   163f4:	e283305c 	add	r3, r3, #92	; 0x5c
   163f8:	e1a00003 	mov	r0, r3
   163fc:	eb0003ce 	bl	1733c <_dna_lock_init>
#endif
  _newlib_sfp_lock_end ();
   16400:	eb00009e 	bl	16680 <__sfp_lock_release>

  fp->_p = NULL;		/* no current pointer */
   16404:	e51b3008 	ldr	r3, [fp, #-8]
   16408:	e3a02000 	mov	r2, #0
   1640c:	e5832000 	str	r2, [r3]
  fp->_w = 0;			/* nothing to read or write */
   16410:	e51b3008 	ldr	r3, [fp, #-8]
   16414:	e3a02000 	mov	r2, #0
   16418:	e5832008 	str	r2, [r3, #8]
  fp->_r = 0;
   1641c:	e51b3008 	ldr	r3, [fp, #-8]
   16420:	e3a02000 	mov	r2, #0
   16424:	e5832004 	str	r2, [r3, #4]
  fp->_bf._base = NULL;		/* no buffer */
   16428:	e51b3008 	ldr	r3, [fp, #-8]
   1642c:	e3a02000 	mov	r2, #0
   16430:	e5832010 	str	r2, [r3, #16]
  fp->_bf._size = 0;
   16434:	e51b3008 	ldr	r3, [fp, #-8]
   16438:	e3a02000 	mov	r2, #0
   1643c:	e5832014 	str	r2, [r3, #20]
  fp->_lbfsize = 0;		/* not line buffered */
   16440:	e51b3008 	ldr	r3, [fp, #-8]
   16444:	e3a02000 	mov	r2, #0
   16448:	e5832018 	str	r2, [r3, #24]
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   1644c:	e51b3008 	ldr	r3, [fp, #-8]
   16450:	e2833064 	add	r3, r3, #100	; 0x64
   16454:	e1a00003 	mov	r0, r3
   16458:	e3a01000 	mov	r1, #0
   1645c:	e3a02008 	mov	r2, #8
   16460:	eb0008c4 	bl	18778 <memset>
  /* fp->_cookie = <any>; */	/* caller sets cookie, _read/_write etc */
  fp->_ub._base = NULL;		/* no ungetc buffer */
   16464:	e51b3008 	ldr	r3, [fp, #-8]
   16468:	e3a02000 	mov	r2, #0
   1646c:	e5832030 	str	r2, [r3, #48]	; 0x30
  fp->_ub._size = 0;
   16470:	e51b3008 	ldr	r3, [fp, #-8]
   16474:	e3a02000 	mov	r2, #0
   16478:	e5832034 	str	r2, [r3, #52]	; 0x34
  fp->_lb._base = NULL;		/* no line buffer */
   1647c:	e51b3008 	ldr	r3, [fp, #-8]
   16480:	e3a02000 	mov	r2, #0
   16484:	e5832044 	str	r2, [r3, #68]	; 0x44
  fp->_lb._size = 0;
   16488:	e51b3008 	ldr	r3, [fp, #-8]
   1648c:	e3a02000 	mov	r2, #0
   16490:	e5832048 	str	r2, [r3, #72]	; 0x48

  return fp;
   16494:	e51b3008 	ldr	r3, [fp, #-8]
   16498:	ea000021 	b	16524 <__sfp+0x1d0>

  if (!_GLOBAL_REENT->__sdidinit)
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   1649c:	e51b3008 	ldr	r3, [fp, #-8]
   164a0:	e2833070 	add	r3, r3, #112	; 0x70
   164a4:	e50b3008 	str	r3, [fp, #-8]
   164a8:	e51b300c 	ldr	r3, [fp, #-12]
   164ac:	e2433001 	sub	r3, r3, #1
   164b0:	e50b300c 	str	r3, [fp, #-12]
   164b4:	e51b300c 	ldr	r3, [fp, #-12]
   164b8:	e3530000 	cmp	r3, #0
   164bc:	aaffffbd 	bge	163b8 <__sfp+0x64>
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
   164c0:	e51b3010 	ldr	r3, [fp, #-16]
   164c4:	e5933000 	ldr	r3, [r3]
   164c8:	e3530000 	cmp	r3, #0
   164cc:	1a000010 	bne	16514 <__sfp+0x1c0>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
   164d0:	e51b0018 	ldr	r0, [fp, #-24]
   164d4:	e3a01004 	mov	r1, #4
   164d8:	ebffff6f 	bl	1629c <__sfmoreglue>
   164dc:	e1a02000 	mov	r2, r0
   164e0:	e51b3010 	ldr	r3, [fp, #-16]
   164e4:	e5832000 	str	r2, [r3]
   164e8:	e51b3010 	ldr	r3, [fp, #-16]
   164ec:	e5933000 	ldr	r3, [r3]
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
   164f0:	e3530000 	cmp	r3, #0
   164f4:	1a000006 	bne	16514 <__sfp+0x1c0>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
   164f8:	e1a00000 	nop			; (mov r0, r0)
    }
  _newlib_sfp_lock_exit ();
   164fc:	eb00005f 	bl	16680 <__sfp_lock_release>
  d->_errno = ENOMEM;
   16500:	e51b3018 	ldr	r3, [fp, #-24]
   16504:	e3a0200c 	mov	r2, #12
   16508:	e5832000 	str	r2, [r3]
  return NULL;
   1650c:	e3a03000 	mov	r3, #0
   16510:	ea000003 	b	16524 <__sfp+0x1d0>

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
   16514:	e51b3010 	ldr	r3, [fp, #-16]
   16518:	e5933000 	ldr	r3, [r3]
   1651c:	e50b3010 	str	r3, [fp, #-16]
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
   16520:	eaffff9d 	b	1639c <__sfp+0x48>
  fp->_ub._size = 0;
  fp->_lb._base = NULL;		/* no line buffer */
  fp->_lb._size = 0;

  return fp;
}
   16524:	e1a00003 	mov	r0, r3
   16528:	e24bd004 	sub	sp, fp, #4
   1652c:	e8bd4800 	pop	{fp, lr}
   16530:	e12fff1e 	bx	lr
   16534:	00033004 	.word	0x00033004

00016538 <_cleanup_r>:
 */

_VOID
_DEFUN(_cleanup_r, (ptr),
       struct _reent *ptr)
{
   16538:	e92d4800 	push	{fp, lr}
   1653c:	e28db004 	add	fp, sp, #4
   16540:	e24dd008 	sub	sp, sp, #8
   16544:	e50b0008 	str	r0, [fp, #-8]
  _CAST_VOID _fwalk(ptr, fclose);
   16548:	e51b0008 	ldr	r0, [fp, #-8]
   1654c:	e59f100c 	ldr	r1, [pc, #12]	; 16560 <_cleanup_r+0x28>
   16550:	eb000294 	bl	16fa8 <_fwalk>
  /* _CAST_VOID _fwalk (ptr, fflush); */	/* `cheating' */
}
   16554:	e24bd004 	sub	sp, fp, #4
   16558:	e8bd4800 	pop	{fp, lr}
   1655c:	e12fff1e 	bx	lr
   16560:	00021ad4 	.word	0x00021ad4

00016564 <_cleanup>:

#ifndef _REENT_ONLY
_VOID
_DEFUN_VOID(_cleanup)
{
   16564:	e92d4800 	push	{fp, lr}
   16568:	e28db004 	add	fp, sp, #4
  _cleanup_r (_GLOBAL_REENT);
   1656c:	e59f3014 	ldr	r3, [pc, #20]	; 16588 <_cleanup+0x24>
   16570:	e5933000 	ldr	r3, [r3]
   16574:	e1a00003 	mov	r0, r3
   16578:	ebffffee 	bl	16538 <_cleanup_r>
}
   1657c:	e24bd004 	sub	sp, fp, #4
   16580:	e8bd4800 	pop	{fp, lr}
   16584:	e12fff1e 	bx	lr
   16588:	00033004 	.word	0x00033004

0001658c <__sinit>:
 */

_VOID
_DEFUN(__sinit, (s),
       struct _reent *s)
{
   1658c:	e92d4800 	push	{fp, lr}
   16590:	e28db004 	add	fp, sp, #4
   16594:	e24dd008 	sub	sp, sp, #8
   16598:	e50b0008 	str	r0, [fp, #-8]
  __sinit_lock_acquire ();
   1659c:	eb00003f 	bl	166a0 <__sinit_lock_acquire>

  if (s->__sdidinit)
   165a0:	e51b3008 	ldr	r3, [fp, #-8]
   165a4:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   165a8:	e3530000 	cmp	r3, #0
   165ac:	0a000001 	beq	165b8 <__sinit+0x2c>
    {
      __sinit_lock_release ();
   165b0:	eb000042 	bl	166c0 <__sinit_lock_release>
      return;
   165b4:	ea000025 	b	16650 <__sinit+0xc4>
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   165b8:	e51b3008 	ldr	r3, [fp, #-8]
   165bc:	e59f2098 	ldr	r2, [pc, #152]	; 1665c <__sinit+0xd0>
   165c0:	e583203c 	str	r2, [r3, #60]	; 0x3c

  s->__sglue._next = NULL;
   165c4:	e51b3008 	ldr	r3, [fp, #-8]
   165c8:	e3a02000 	mov	r2, #0
   165cc:	e58322e0 	str	r2, [r3, #736]	; 0x2e0
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
   165d0:	e51b3008 	ldr	r3, [fp, #-8]
   165d4:	e3a02003 	mov	r2, #3
   165d8:	e58322e4 	str	r2, [r3, #740]	; 0x2e4
  s->__sglue._iobs = &s->__sf[0];
   165dc:	e51b3008 	ldr	r3, [fp, #-8]
   165e0:	e2832e2f 	add	r2, r3, #752	; 0x2f0
   165e4:	e51b3008 	ldr	r3, [fp, #-8]
   165e8:	e58322e8 	str	r2, [r3, #744]	; 0x2e8
  s->_stdin = __sfp(s);
  s->_stdout = __sfp(s);
  s->_stderr = __sfp(s);
#endif

  std (s->_stdin,  __SRD, 0, s);
   165ec:	e51b3008 	ldr	r3, [fp, #-8]
   165f0:	e5933004 	ldr	r3, [r3, #4]
   165f4:	e1a00003 	mov	r0, r3
   165f8:	e3a01004 	mov	r1, #4
   165fc:	e3a02000 	mov	r2, #0
   16600:	e51b3008 	ldr	r3, [fp, #-8]
   16604:	ebfffede 	bl	16184 <std>
     requires both stdin and stdout to be line-buffered, but tradition
     leaves stdin alone on systems without fcntl.  */
#ifdef HAVE_FCNTL
  std (s->_stdout, __SWR, 1, s);
#else
  std (s->_stdout, __SWR | __SLBF, 1, s);
   16608:	e51b3008 	ldr	r3, [fp, #-8]
   1660c:	e5933008 	ldr	r3, [r3, #8]
   16610:	e1a00003 	mov	r0, r3
   16614:	e3a01009 	mov	r1, #9
   16618:	e3a02001 	mov	r2, #1
   1661c:	e51b3008 	ldr	r3, [fp, #-8]
   16620:	ebfffed7 	bl	16184 <std>
#endif

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);
   16624:	e51b3008 	ldr	r3, [fp, #-8]
   16628:	e593300c 	ldr	r3, [r3, #12]
   1662c:	e1a00003 	mov	r0, r3
   16630:	e3a01012 	mov	r1, #18
   16634:	e3a02002 	mov	r2, #2
   16638:	e51b3008 	ldr	r3, [fp, #-8]
   1663c:	ebfffed0 	bl	16184 <std>

  s->__sdidinit = 1;
   16640:	e51b3008 	ldr	r3, [fp, #-8]
   16644:	e3a02001 	mov	r2, #1
   16648:	e5832038 	str	r2, [r3, #56]	; 0x38

  __sinit_lock_release ();
   1664c:	eb00001b 	bl	166c0 <__sinit_lock_release>
}
   16650:	e24bd004 	sub	sp, fp, #4
   16654:	e8bd4800 	pop	{fp, lr}
   16658:	e12fff1e 	bx	lr
   1665c:	00016538 	.word	0x00016538

00016660 <__sfp_lock_acquire>:
__LOCK_INIT_RECURSIVE(static, __sfp_lock);
__LOCK_INIT_RECURSIVE(static, __sinit_lock);

_VOID
_DEFUN_VOID(__sfp_lock_acquire)
{
   16660:	e92d4800 	push	{fp, lr}
   16664:	e28db004 	add	fp, sp, #4
  __lock_acquire_recursive (__sfp_lock);
   16668:	e59f000c 	ldr	r0, [pc, #12]	; 1667c <__sfp_lock_acquire+0x1c>
   1666c:	eb000383 	bl	17480 <_dna_lock_acquire>
}
   16670:	e24bd004 	sub	sp, fp, #4
   16674:	e8bd4800 	pop	{fp, lr}
   16678:	e12fff1e 	bx	lr
   1667c:	0003e010 	.word	0x0003e010

00016680 <__sfp_lock_release>:

_VOID
_DEFUN_VOID(__sfp_lock_release)
{
   16680:	e92d4800 	push	{fp, lr}
   16684:	e28db004 	add	fp, sp, #4
  __lock_release_recursive (__sfp_lock);
   16688:	e59f000c 	ldr	r0, [pc, #12]	; 1669c <__sfp_lock_release+0x1c>
   1668c:	eb0003e2 	bl	1761c <_dna_lock_release>
}
   16690:	e24bd004 	sub	sp, fp, #4
   16694:	e8bd4800 	pop	{fp, lr}
   16698:	e12fff1e 	bx	lr
   1669c:	0003e010 	.word	0x0003e010

000166a0 <__sinit_lock_acquire>:

_VOID
_DEFUN_VOID(__sinit_lock_acquire)
{
   166a0:	e92d4800 	push	{fp, lr}
   166a4:	e28db004 	add	fp, sp, #4
  __lock_acquire_recursive (__sinit_lock);
   166a8:	e59f000c 	ldr	r0, [pc, #12]	; 166bc <__sinit_lock_acquire+0x1c>
   166ac:	eb000373 	bl	17480 <_dna_lock_acquire>
}
   166b0:	e24bd004 	sub	sp, fp, #4
   166b4:	e8bd4800 	pop	{fp, lr}
   166b8:	e12fff1e 	bx	lr
   166bc:	0003e018 	.word	0x0003e018

000166c0 <__sinit_lock_release>:

_VOID
_DEFUN_VOID(__sinit_lock_release)
{
   166c0:	e92d4800 	push	{fp, lr}
   166c4:	e28db004 	add	fp, sp, #4
  __lock_release_recursive (__sinit_lock);
   166c8:	e59f000c 	ldr	r0, [pc, #12]	; 166dc <__sinit_lock_release+0x1c>
   166cc:	eb0003d2 	bl	1761c <_dna_lock_release>
}
   166d0:	e24bd004 	sub	sp, fp, #4
   166d4:	e8bd4800 	pop	{fp, lr}
   166d8:	e12fff1e 	bx	lr
   166dc:	0003e018 	.word	0x0003e018

000166e0 <__fp_lock>:

/* Walkable file locking routine.  */
static int
_DEFUN(__fp_lock, (ptr),
       FILE * ptr)
{
   166e0:	e92d4800 	push	{fp, lr}
   166e4:	e28db004 	add	fp, sp, #4
   166e8:	e24dd008 	sub	sp, sp, #8
   166ec:	e50b0008 	str	r0, [fp, #-8]
  _flockfile (ptr);
   166f0:	e51b3008 	ldr	r3, [fp, #-8]
   166f4:	e1d330bc 	ldrh	r3, [r3, #12]
   166f8:	e1a03803 	lsl	r3, r3, #16
   166fc:	e1a03823 	lsr	r3, r3, #16
   16700:	e2033c02 	and	r3, r3, #512	; 0x200
   16704:	e3530000 	cmp	r3, #0
   16708:	1a000003 	bne	1671c <__fp_lock+0x3c>
   1670c:	e51b3008 	ldr	r3, [fp, #-8]
   16710:	e283305c 	add	r3, r3, #92	; 0x5c
   16714:	e1a00003 	mov	r0, r3
   16718:	eb000358 	bl	17480 <_dna_lock_acquire>

  return 0;
   1671c:	e3a03000 	mov	r3, #0
}
   16720:	e1a00003 	mov	r0, r3
   16724:	e24bd004 	sub	sp, fp, #4
   16728:	e8bd4800 	pop	{fp, lr}
   1672c:	e12fff1e 	bx	lr

00016730 <__fp_unlock>:

/* Walkable file unlocking routine.  */
static int
_DEFUN(__fp_unlock, (ptr),
       FILE * ptr)
{
   16730:	e92d4800 	push	{fp, lr}
   16734:	e28db004 	add	fp, sp, #4
   16738:	e24dd008 	sub	sp, sp, #8
   1673c:	e50b0008 	str	r0, [fp, #-8]
  _funlockfile (ptr);
   16740:	e51b3008 	ldr	r3, [fp, #-8]
   16744:	e1d330bc 	ldrh	r3, [r3, #12]
   16748:	e1a03803 	lsl	r3, r3, #16
   1674c:	e1a03823 	lsr	r3, r3, #16
   16750:	e2033c02 	and	r3, r3, #512	; 0x200
   16754:	e3530000 	cmp	r3, #0
   16758:	1a000003 	bne	1676c <__fp_unlock+0x3c>
   1675c:	e51b3008 	ldr	r3, [fp, #-8]
   16760:	e283305c 	add	r3, r3, #92	; 0x5c
   16764:	e1a00003 	mov	r0, r3
   16768:	eb0003ab 	bl	1761c <_dna_lock_release>

  return 0;
   1676c:	e3a03000 	mov	r3, #0
}
   16770:	e1a00003 	mov	r0, r3
   16774:	e24bd004 	sub	sp, fp, #4
   16778:	e8bd4800 	pop	{fp, lr}
   1677c:	e12fff1e 	bx	lr

00016780 <__fp_lock_all>:

_VOID
_DEFUN_VOID(__fp_lock_all)
{
   16780:	e92d4800 	push	{fp, lr}
   16784:	e28db004 	add	fp, sp, #4
  __sfp_lock_acquire ();
   16788:	ebffffb4 	bl	16660 <__sfp_lock_acquire>

  _CAST_VOID _fwalk (_REENT, __fp_lock);
   1678c:	e59f3018 	ldr	r3, [pc, #24]	; 167ac <__fp_lock_all+0x2c>
   16790:	e5933000 	ldr	r3, [r3]
   16794:	e1a00003 	mov	r0, r3
   16798:	e59f1010 	ldr	r1, [pc, #16]	; 167b0 <__fp_lock_all+0x30>
   1679c:	eb000201 	bl	16fa8 <_fwalk>
}
   167a0:	e24bd004 	sub	sp, fp, #4
   167a4:	e8bd4800 	pop	{fp, lr}
   167a8:	e12fff1e 	bx	lr
   167ac:	0003e460 	.word	0x0003e460
   167b0:	000166e0 	.word	0x000166e0

000167b4 <__fp_unlock_all>:

_VOID
_DEFUN_VOID(__fp_unlock_all)
{
   167b4:	e92d4800 	push	{fp, lr}
   167b8:	e28db004 	add	fp, sp, #4
  _CAST_VOID _fwalk (_REENT, __fp_unlock);
   167bc:	e59f301c 	ldr	r3, [pc, #28]	; 167e0 <__fp_unlock_all+0x2c>
   167c0:	e5933000 	ldr	r3, [r3]
   167c4:	e1a00003 	mov	r0, r3
   167c8:	e59f1014 	ldr	r1, [pc, #20]	; 167e4 <__fp_unlock_all+0x30>
   167cc:	eb0001f5 	bl	16fa8 <_fwalk>

  __sfp_lock_release ();
   167d0:	ebffffaa 	bl	16680 <__sfp_lock_release>
}
   167d4:	e24bd004 	sub	sp, fp, #4
   167d8:	e8bd4800 	pop	{fp, lr}
   167dc:	e12fff1e 	bx	lr
   167e0:	0003e460 	.word	0x0003e460
   167e4:	00016730 	.word	0x00016730

000167e8 <_fprintf_r>:
int
_DEFUN(_fprintf_r, (ptr, fp, fmt),
       struct _reent *ptr _AND
       FILE *fp _AND
       const char *fmt _DOTS)
{
   167e8:	e92d000c 	push	{r2, r3}
   167ec:	e92d4800 	push	{fp, lr}
   167f0:	e28db004 	add	fp, sp, #4
   167f4:	e24dd010 	sub	sp, sp, #16
   167f8:	e50b0010 	str	r0, [fp, #-16]
   167fc:	e50b1014 	str	r1, [fp, #-20]
  int ret;
  va_list ap;

  va_start (ap, fmt);
   16800:	e28b3008 	add	r3, fp, #8
   16804:	e50b300c 	str	r3, [fp, #-12]
  ret = _vfprintf_r (ptr, fp, fmt, ap);
   16808:	e51b0010 	ldr	r0, [fp, #-16]
   1680c:	e51b1014 	ldr	r1, [fp, #-20]
   16810:	e59b2004 	ldr	r2, [fp, #4]
   16814:	e51b300c 	ldr	r3, [fp, #-12]
   16818:	eb0016af 	bl	1c2dc <_vfprintf_r>
   1681c:	e50b0008 	str	r0, [fp, #-8]
  va_end (ap);
  return ret;
   16820:	e51b3008 	ldr	r3, [fp, #-8]
}
   16824:	e1a00003 	mov	r0, r3
   16828:	e24bd004 	sub	sp, fp, #4
   1682c:	e8bd4800 	pop	{fp, lr}
   16830:	e28dd008 	add	sp, sp, #8
   16834:	e12fff1e 	bx	lr

00016838 <fprintf>:

int
_DEFUN(fprintf, (fp, fmt),
       FILE *fp _AND
       const char *fmt _DOTS)
{
   16838:	e92d000e 	push	{r1, r2, r3}
   1683c:	e92d4800 	push	{fp, lr}
   16840:	e28db004 	add	fp, sp, #4
   16844:	e24dd014 	sub	sp, sp, #20
   16848:	e50b0014 	str	r0, [fp, #-20]
  int ret;
  va_list ap;

  va_start (ap, fmt);
   1684c:	e28b3008 	add	r3, fp, #8
   16850:	e50b3010 	str	r3, [fp, #-16]
  ret = _vfprintf_r (_REENT, fp, fmt, ap);
   16854:	e59f3030 	ldr	r3, [pc, #48]	; 1688c <fprintf+0x54>
   16858:	e5933000 	ldr	r3, [r3]
   1685c:	e1a00003 	mov	r0, r3
   16860:	e51b1014 	ldr	r1, [fp, #-20]
   16864:	e59b2004 	ldr	r2, [fp, #4]
   16868:	e51b3010 	ldr	r3, [fp, #-16]
   1686c:	eb00169a 	bl	1c2dc <_vfprintf_r>
   16870:	e50b000c 	str	r0, [fp, #-12]
  va_end (ap);
  return ret;
   16874:	e51b300c 	ldr	r3, [fp, #-12]
}
   16878:	e1a00003 	mov	r0, r3
   1687c:	e24bd004 	sub	sp, fp, #4
   16880:	e8bd4800 	pop	{fp, lr}
   16884:	e28dd00c 	add	sp, sp, #12
   16888:	e12fff1e 	bx	lr
   1688c:	0003e460 	.word	0x0003e460

00016890 <_free_r>:
#if __STD_C
void fREe(RARG Void_t* mem)
#else
void fREe(RARG mem) RDECL Void_t* mem;
#endif
{
   16890:	e92d4800 	push	{fp, lr}
   16894:	e28db004 	add	fp, sp, #4
   16898:	e24dd030 	sub	sp, sp, #48	; 0x30
   1689c:	e50b0030 	str	r0, [fp, #-48]	; 0x30
   168a0:	e50b1034 	str	r1, [fp, #-52]	; 0x34
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
   168a4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   168a8:	e3530000 	cmp	r3, #0
   168ac:	1a000000 	bne	168b4 <_free_r+0x24>
    return;
   168b0:	ea000146 	b	16dd0 <_free_r+0x540>

  MALLOC_LOCK;
   168b4:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   168b8:	eb000824 	bl	18950 <__malloc_lock>

  p = mem2chunk(mem);
   168bc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   168c0:	e2433008 	sub	r3, r3, #8
   168c4:	e50b3008 	str	r3, [fp, #-8]
  hd = p->size;
   168c8:	e51b3008 	ldr	r3, [fp, #-8]
   168cc:	e5933004 	ldr	r3, [r3, #4]
   168d0:	e50b301c 	str	r3, [fp, #-28]
  }
#endif
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
   168d4:	e51b301c 	ldr	r3, [fp, #-28]
   168d8:	e3c33001 	bic	r3, r3, #1
   168dc:	e50b300c 	str	r3, [fp, #-12]
  next = chunk_at_offset(p, sz);
   168e0:	e51b2008 	ldr	r2, [fp, #-8]
   168e4:	e51b300c 	ldr	r3, [fp, #-12]
   168e8:	e0823003 	add	r3, r2, r3
   168ec:	e50b3020 	str	r3, [fp, #-32]
  nextsz = chunksize(next);
   168f0:	e51b3020 	ldr	r3, [fp, #-32]
   168f4:	e5933004 	ldr	r3, [r3, #4]
   168f8:	e3c33003 	bic	r3, r3, #3
   168fc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
  
  if (next == top)                            /* merge with top */
   16900:	e59f34d4 	ldr	r3, [pc, #1236]	; 16ddc <_free_r+0x54c>
   16904:	e5932008 	ldr	r2, [r3, #8]
   16908:	e51b3020 	ldr	r3, [fp, #-32]
   1690c:	e1520003 	cmp	r2, r3
   16910:	1a000033 	bne	169e4 <_free_r+0x154>
  {
    sz += nextsz;
   16914:	e51b200c 	ldr	r2, [fp, #-12]
   16918:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1691c:	e0823003 	add	r3, r2, r3
   16920:	e50b300c 	str	r3, [fp, #-12]

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
   16924:	e51b301c 	ldr	r3, [fp, #-28]
   16928:	e2033001 	and	r3, r3, #1
   1692c:	e3530000 	cmp	r3, #0
   16930:	1a000017 	bne	16994 <_free_r+0x104>
    {
      prevsz = p->prev_size;
   16934:	e51b3008 	ldr	r3, [fp, #-8]
   16938:	e5933000 	ldr	r3, [r3]
   1693c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      p = chunk_at_offset(p, -prevsz);
   16940:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   16944:	e2633000 	rsb	r3, r3, #0
   16948:	e51b2008 	ldr	r2, [fp, #-8]
   1694c:	e0823003 	add	r3, r2, r3
   16950:	e50b3008 	str	r3, [fp, #-8]
      sz += prevsz;
   16954:	e51b200c 	ldr	r2, [fp, #-12]
   16958:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1695c:	e0823003 	add	r3, r2, r3
   16960:	e50b300c 	str	r3, [fp, #-12]
      unlink(p, bck, fwd);
   16964:	e51b3008 	ldr	r3, [fp, #-8]
   16968:	e593300c 	ldr	r3, [r3, #12]
   1696c:	e50b3010 	str	r3, [fp, #-16]
   16970:	e51b3008 	ldr	r3, [fp, #-8]
   16974:	e5933008 	ldr	r3, [r3, #8]
   16978:	e50b3014 	str	r3, [fp, #-20]
   1697c:	e51b3014 	ldr	r3, [fp, #-20]
   16980:	e51b2010 	ldr	r2, [fp, #-16]
   16984:	e583200c 	str	r2, [r3, #12]
   16988:	e51b3010 	ldr	r3, [fp, #-16]
   1698c:	e51b2014 	ldr	r2, [fp, #-20]
   16990:	e5832008 	str	r2, [r3, #8]
    }

    set_head(p, sz | PREV_INUSE);
   16994:	e51b300c 	ldr	r3, [fp, #-12]
   16998:	e3832001 	orr	r2, r3, #1
   1699c:	e51b3008 	ldr	r3, [fp, #-8]
   169a0:	e5832004 	str	r2, [r3, #4]
    top = p;
   169a4:	e59f3430 	ldr	r3, [pc, #1072]	; 16ddc <_free_r+0x54c>
   169a8:	e51b2008 	ldr	r2, [fp, #-8]
   169ac:	e5832008 	str	r2, [r3, #8]
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
   169b0:	e59f3428 	ldr	r3, [pc, #1064]	; 16de0 <_free_r+0x550>
   169b4:	e5933000 	ldr	r3, [r3]
   169b8:	e51b200c 	ldr	r2, [fp, #-12]
   169bc:	e1520003 	cmp	r2, r3
   169c0:	3a000004 	bcc	169d8 <_free_r+0x148>
      malloc_trim(RCALL top_pad); 
   169c4:	e59f3418 	ldr	r3, [pc, #1048]	; 16de4 <_free_r+0x554>
   169c8:	e5933000 	ldr	r3, [r3]
   169cc:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   169d0:	e1a01003 	mov	r1, r3
   169d4:	eb000105 	bl	16df0 <_malloc_trim_r>
    MALLOC_UNLOCK;
   169d8:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   169dc:	eb0007e5 	bl	18978 <__malloc_unlock>
    return;
   169e0:	ea0000fa 	b	16dd0 <_free_r+0x540>
  }

  set_head(next, nextsz);                    /* clear inuse bit */
   169e4:	e51b3020 	ldr	r3, [fp, #-32]
   169e8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   169ec:	e5832004 	str	r2, [r3, #4]

  islr = 0;
   169f0:	e3a03000 	mov	r3, #0
   169f4:	e50b3018 	str	r3, [fp, #-24]

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
   169f8:	e51b301c 	ldr	r3, [fp, #-28]
   169fc:	e2033001 	and	r3, r3, #1
   16a00:	e3530000 	cmp	r3, #0
   16a04:	1a00001f 	bne	16a88 <_free_r+0x1f8>
  {
    prevsz = p->prev_size;
   16a08:	e51b3008 	ldr	r3, [fp, #-8]
   16a0c:	e5933000 	ldr	r3, [r3]
   16a10:	e50b3028 	str	r3, [fp, #-40]	; 0x28
    p = chunk_at_offset(p, -prevsz);
   16a14:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   16a18:	e2633000 	rsb	r3, r3, #0
   16a1c:	e51b2008 	ldr	r2, [fp, #-8]
   16a20:	e0823003 	add	r3, r2, r3
   16a24:	e50b3008 	str	r3, [fp, #-8]
    sz += prevsz;
   16a28:	e51b200c 	ldr	r2, [fp, #-12]
   16a2c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   16a30:	e0823003 	add	r3, r2, r3
   16a34:	e50b300c 	str	r3, [fp, #-12]
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
   16a38:	e51b3008 	ldr	r3, [fp, #-8]
   16a3c:	e5932008 	ldr	r2, [r3, #8]
   16a40:	e59f33a0 	ldr	r3, [pc, #928]	; 16de8 <_free_r+0x558>
   16a44:	e1520003 	cmp	r2, r3
   16a48:	1a000002 	bne	16a58 <_free_r+0x1c8>
      islr = 1;
   16a4c:	e3a03001 	mov	r3, #1
   16a50:	e50b3018 	str	r3, [fp, #-24]
   16a54:	ea00000b 	b	16a88 <_free_r+0x1f8>
    else
      unlink(p, bck, fwd);
   16a58:	e51b3008 	ldr	r3, [fp, #-8]
   16a5c:	e593300c 	ldr	r3, [r3, #12]
   16a60:	e50b3010 	str	r3, [fp, #-16]
   16a64:	e51b3008 	ldr	r3, [fp, #-8]
   16a68:	e5933008 	ldr	r3, [r3, #8]
   16a6c:	e50b3014 	str	r3, [fp, #-20]
   16a70:	e51b3014 	ldr	r3, [fp, #-20]
   16a74:	e51b2010 	ldr	r2, [fp, #-16]
   16a78:	e583200c 	str	r2, [r3, #12]
   16a7c:	e51b3010 	ldr	r3, [fp, #-16]
   16a80:	e51b2014 	ldr	r2, [fp, #-20]
   16a84:	e5832008 	str	r2, [r3, #8]
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   16a88:	e51b2020 	ldr	r2, [fp, #-32]
   16a8c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   16a90:	e0823003 	add	r3, r2, r3
   16a94:	e5933004 	ldr	r3, [r3, #4]
   16a98:	e2033001 	and	r3, r3, #1
   16a9c:	e3530000 	cmp	r3, #0
   16aa0:	1a000027 	bne	16b44 <_free_r+0x2b4>
  {
    sz += nextsz;
   16aa4:	e51b200c 	ldr	r2, [fp, #-12]
   16aa8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   16aac:	e0823003 	add	r3, r2, r3
   16ab0:	e50b300c 	str	r3, [fp, #-12]
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   16ab4:	e51b3018 	ldr	r3, [fp, #-24]
   16ab8:	e3530000 	cmp	r3, #0
   16abc:	1a000014 	bne	16b14 <_free_r+0x284>
   16ac0:	e51b3020 	ldr	r3, [fp, #-32]
   16ac4:	e5932008 	ldr	r2, [r3, #8]
   16ac8:	e59f3318 	ldr	r3, [pc, #792]	; 16de8 <_free_r+0x558>
   16acc:	e1520003 	cmp	r2, r3
   16ad0:	1a00000f 	bne	16b14 <_free_r+0x284>
    {
      islr = 1;
   16ad4:	e3a03001 	mov	r3, #1
   16ad8:	e50b3018 	str	r3, [fp, #-24]
      link_last_remainder(p);   
   16adc:	e59f2304 	ldr	r2, [pc, #772]	; 16de8 <_free_r+0x558>
   16ae0:	e59f3300 	ldr	r3, [pc, #768]	; 16de8 <_free_r+0x558>
   16ae4:	e51b1008 	ldr	r1, [fp, #-8]
   16ae8:	e583100c 	str	r1, [r3, #12]
   16aec:	e593300c 	ldr	r3, [r3, #12]
   16af0:	e5823008 	str	r3, [r2, #8]
   16af4:	e51b3008 	ldr	r3, [fp, #-8]
   16af8:	e59f22e8 	ldr	r2, [pc, #744]	; 16de8 <_free_r+0x558>
   16afc:	e583200c 	str	r2, [r3, #12]
   16b00:	e51b3008 	ldr	r3, [fp, #-8]
   16b04:	e593200c 	ldr	r2, [r3, #12]
   16b08:	e51b3008 	ldr	r3, [fp, #-8]
   16b0c:	e5832008 	str	r2, [r3, #8]
   16b10:	ea00000b 	b	16b44 <_free_r+0x2b4>
    }
    else
      unlink(next, bck, fwd);
   16b14:	e51b3020 	ldr	r3, [fp, #-32]
   16b18:	e593300c 	ldr	r3, [r3, #12]
   16b1c:	e50b3010 	str	r3, [fp, #-16]
   16b20:	e51b3020 	ldr	r3, [fp, #-32]
   16b24:	e5933008 	ldr	r3, [r3, #8]
   16b28:	e50b3014 	str	r3, [fp, #-20]
   16b2c:	e51b3014 	ldr	r3, [fp, #-20]
   16b30:	e51b2010 	ldr	r2, [fp, #-16]
   16b34:	e583200c 	str	r2, [r3, #12]
   16b38:	e51b3010 	ldr	r3, [fp, #-16]
   16b3c:	e51b2014 	ldr	r2, [fp, #-20]
   16b40:	e5832008 	str	r2, [r3, #8]
  }


  set_head(p, sz | PREV_INUSE);
   16b44:	e51b300c 	ldr	r3, [fp, #-12]
   16b48:	e3832001 	orr	r2, r3, #1
   16b4c:	e51b3008 	ldr	r3, [fp, #-8]
   16b50:	e5832004 	str	r2, [r3, #4]
  set_foot(p, sz);
   16b54:	e51b2008 	ldr	r2, [fp, #-8]
   16b58:	e51b300c 	ldr	r3, [fp, #-12]
   16b5c:	e0823003 	add	r3, r2, r3
   16b60:	e51b200c 	ldr	r2, [fp, #-12]
   16b64:	e5832000 	str	r2, [r3]
  if (!islr)
   16b68:	e51b3018 	ldr	r3, [fp, #-24]
   16b6c:	e3530000 	cmp	r3, #0
   16b70:	1a000094 	bne	16dc8 <_free_r+0x538>
    frontlink(p, sz, idx, bck, fwd);  
   16b74:	e51b300c 	ldr	r3, [fp, #-12]
   16b78:	e3530c02 	cmp	r3, #512	; 0x200
   16b7c:	2a000026 	bcs	16c1c <_free_r+0x38c>
   16b80:	e51b300c 	ldr	r3, [fp, #-12]
   16b84:	e1a031a3 	lsr	r3, r3, #3
   16b88:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   16b8c:	e59f2248 	ldr	r2, [pc, #584]	; 16ddc <_free_r+0x54c>
   16b90:	e59f3244 	ldr	r3, [pc, #580]	; 16ddc <_free_r+0x54c>
   16b94:	e5931004 	ldr	r1, [r3, #4]
   16b98:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   16b9c:	e2830003 	add	r0, r3, #3
   16ba0:	e3530000 	cmp	r3, #0
   16ba4:	b1a03000 	movlt	r3, r0
   16ba8:	a1a03003 	movge	r3, r3
   16bac:	e1a03143 	asr	r3, r3, #2
   16bb0:	e3a00001 	mov	r0, #1
   16bb4:	e1a03310 	lsl	r3, r0, r3
   16bb8:	e1813003 	orr	r3, r1, r3
   16bbc:	e5823004 	str	r3, [r2, #4]
   16bc0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   16bc4:	e1a03083 	lsl	r3, r3, #1
   16bc8:	e1a02103 	lsl	r2, r3, #2
   16bcc:	e59f3208 	ldr	r3, [pc, #520]	; 16ddc <_free_r+0x54c>
   16bd0:	e0823003 	add	r3, r2, r3
   16bd4:	e50b3010 	str	r3, [fp, #-16]
   16bd8:	e51b3010 	ldr	r3, [fp, #-16]
   16bdc:	e5933008 	ldr	r3, [r3, #8]
   16be0:	e50b3014 	str	r3, [fp, #-20]
   16be4:	e51b3008 	ldr	r3, [fp, #-8]
   16be8:	e51b2010 	ldr	r2, [fp, #-16]
   16bec:	e583200c 	str	r2, [r3, #12]
   16bf0:	e51b3008 	ldr	r3, [fp, #-8]
   16bf4:	e51b2014 	ldr	r2, [fp, #-20]
   16bf8:	e5832008 	str	r2, [r3, #8]
   16bfc:	e51b3010 	ldr	r3, [fp, #-16]
   16c00:	e51b2008 	ldr	r2, [fp, #-8]
   16c04:	e5832008 	str	r2, [r3, #8]
   16c08:	e51b3010 	ldr	r3, [fp, #-16]
   16c0c:	e5932008 	ldr	r2, [r3, #8]
   16c10:	e51b3014 	ldr	r3, [fp, #-20]
   16c14:	e583200c 	str	r2, [r3, #12]
   16c18:	ea00006a 	b	16dc8 <_free_r+0x538>
   16c1c:	e51b300c 	ldr	r3, [fp, #-12]
   16c20:	e1a034a3 	lsr	r3, r3, #9
   16c24:	e3530000 	cmp	r3, #0
   16c28:	1a000002 	bne	16c38 <_free_r+0x3a8>
   16c2c:	e51b300c 	ldr	r3, [fp, #-12]
   16c30:	e1a031a3 	lsr	r3, r3, #3
   16c34:	ea000029 	b	16ce0 <_free_r+0x450>
   16c38:	e51b300c 	ldr	r3, [fp, #-12]
   16c3c:	e1a034a3 	lsr	r3, r3, #9
   16c40:	e3530004 	cmp	r3, #4
   16c44:	8a000003 	bhi	16c58 <_free_r+0x3c8>
   16c48:	e51b300c 	ldr	r3, [fp, #-12]
   16c4c:	e1a03323 	lsr	r3, r3, #6
   16c50:	e2833038 	add	r3, r3, #56	; 0x38
   16c54:	ea000021 	b	16ce0 <_free_r+0x450>
   16c58:	e51b300c 	ldr	r3, [fp, #-12]
   16c5c:	e1a034a3 	lsr	r3, r3, #9
   16c60:	e3530014 	cmp	r3, #20
   16c64:	8a000003 	bhi	16c78 <_free_r+0x3e8>
   16c68:	e51b300c 	ldr	r3, [fp, #-12]
   16c6c:	e1a034a3 	lsr	r3, r3, #9
   16c70:	e283305b 	add	r3, r3, #91	; 0x5b
   16c74:	ea000019 	b	16ce0 <_free_r+0x450>
   16c78:	e51b300c 	ldr	r3, [fp, #-12]
   16c7c:	e1a034a3 	lsr	r3, r3, #9
   16c80:	e3530054 	cmp	r3, #84	; 0x54
   16c84:	8a000003 	bhi	16c98 <_free_r+0x408>
   16c88:	e51b300c 	ldr	r3, [fp, #-12]
   16c8c:	e1a03623 	lsr	r3, r3, #12
   16c90:	e283306e 	add	r3, r3, #110	; 0x6e
   16c94:	ea000011 	b	16ce0 <_free_r+0x450>
   16c98:	e51b300c 	ldr	r3, [fp, #-12]
   16c9c:	e1a034a3 	lsr	r3, r3, #9
   16ca0:	e3530f55 	cmp	r3, #340	; 0x154
   16ca4:	8a000003 	bhi	16cb8 <_free_r+0x428>
   16ca8:	e51b300c 	ldr	r3, [fp, #-12]
   16cac:	e1a037a3 	lsr	r3, r3, #15
   16cb0:	e2833077 	add	r3, r3, #119	; 0x77
   16cb4:	ea000009 	b	16ce0 <_free_r+0x450>
   16cb8:	e51b300c 	ldr	r3, [fp, #-12]
   16cbc:	e1a024a3 	lsr	r2, r3, #9
   16cc0:	e59f3124 	ldr	r3, [pc, #292]	; 16dec <_free_r+0x55c>
   16cc4:	e1520003 	cmp	r2, r3
   16cc8:	8a000003 	bhi	16cdc <_free_r+0x44c>
   16ccc:	e51b300c 	ldr	r3, [fp, #-12]
   16cd0:	e1a03923 	lsr	r3, r3, #18
   16cd4:	e283307c 	add	r3, r3, #124	; 0x7c
   16cd8:	ea000000 	b	16ce0 <_free_r+0x450>
   16cdc:	e3a0307e 	mov	r3, #126	; 0x7e
   16ce0:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   16ce4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   16ce8:	e1a03083 	lsl	r3, r3, #1
   16cec:	e1a02103 	lsl	r2, r3, #2
   16cf0:	e59f30e4 	ldr	r3, [pc, #228]	; 16ddc <_free_r+0x54c>
   16cf4:	e0823003 	add	r3, r2, r3
   16cf8:	e50b3010 	str	r3, [fp, #-16]
   16cfc:	e51b3010 	ldr	r3, [fp, #-16]
   16d00:	e5933008 	ldr	r3, [r3, #8]
   16d04:	e50b3014 	str	r3, [fp, #-20]
   16d08:	e51b2014 	ldr	r2, [fp, #-20]
   16d0c:	e51b3010 	ldr	r3, [fp, #-16]
   16d10:	e1520003 	cmp	r2, r3
   16d14:	1a00000d 	bne	16d50 <_free_r+0x4c0>
   16d18:	e59f20bc 	ldr	r2, [pc, #188]	; 16ddc <_free_r+0x54c>
   16d1c:	e59f30b8 	ldr	r3, [pc, #184]	; 16ddc <_free_r+0x54c>
   16d20:	e5931004 	ldr	r1, [r3, #4]
   16d24:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   16d28:	e2830003 	add	r0, r3, #3
   16d2c:	e3530000 	cmp	r3, #0
   16d30:	b1a03000 	movlt	r3, r0
   16d34:	a1a03003 	movge	r3, r3
   16d38:	e1a03143 	asr	r3, r3, #2
   16d3c:	e3a00001 	mov	r0, #1
   16d40:	e1a03310 	lsl	r3, r0, r3
   16d44:	e1813003 	orr	r3, r1, r3
   16d48:	e5823004 	str	r3, [r2, #4]
   16d4c:	ea000010 	b	16d94 <_free_r+0x504>
   16d50:	ea000002 	b	16d60 <_free_r+0x4d0>
   16d54:	e51b3014 	ldr	r3, [fp, #-20]
   16d58:	e5933008 	ldr	r3, [r3, #8]
   16d5c:	e50b3014 	str	r3, [fp, #-20]
   16d60:	e51b2014 	ldr	r2, [fp, #-20]
   16d64:	e51b3010 	ldr	r3, [fp, #-16]
   16d68:	e1520003 	cmp	r2, r3
   16d6c:	0a000005 	beq	16d88 <_free_r+0x4f8>
   16d70:	e51b3014 	ldr	r3, [fp, #-20]
   16d74:	e5933004 	ldr	r3, [r3, #4]
   16d78:	e3c32003 	bic	r2, r3, #3
   16d7c:	e51b300c 	ldr	r3, [fp, #-12]
   16d80:	e1520003 	cmp	r2, r3
   16d84:	8afffff2 	bhi	16d54 <_free_r+0x4c4>
   16d88:	e51b3014 	ldr	r3, [fp, #-20]
   16d8c:	e593300c 	ldr	r3, [r3, #12]
   16d90:	e50b3010 	str	r3, [fp, #-16]
   16d94:	e51b3008 	ldr	r3, [fp, #-8]
   16d98:	e51b2010 	ldr	r2, [fp, #-16]
   16d9c:	e583200c 	str	r2, [r3, #12]
   16da0:	e51b3008 	ldr	r3, [fp, #-8]
   16da4:	e51b2014 	ldr	r2, [fp, #-20]
   16da8:	e5832008 	str	r2, [r3, #8]
   16dac:	e51b3010 	ldr	r3, [fp, #-16]
   16db0:	e51b2008 	ldr	r2, [fp, #-8]
   16db4:	e5832008 	str	r2, [r3, #8]
   16db8:	e51b3010 	ldr	r3, [fp, #-16]
   16dbc:	e5932008 	ldr	r2, [r3, #8]
   16dc0:	e51b3014 	ldr	r3, [fp, #-20]
   16dc4:	e583200c 	str	r2, [r3, #12]

  MALLOC_UNLOCK;
   16dc8:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   16dcc:	eb0006e9 	bl	18978 <__malloc_unlock>

#endif /* MALLOC_PROVIDED */
}
   16dd0:	e24bd004 	sub	sp, fp, #4
   16dd4:	e8bd4800 	pop	{fp, lr}
   16dd8:	e12fff1e 	bx	lr
   16ddc:	0003e468 	.word	0x0003e468
   16de0:	0003e870 	.word	0x0003e870
   16de4:	0013e9e0 	.word	0x0013e9e0
   16de8:	0003e470 	.word	0x0003e470
   16dec:	00000554 	.word	0x00000554

00016df0 <_malloc_trim_r>:
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
   16df0:	e92d4800 	push	{fp, lr}
   16df4:	e28db004 	add	fp, sp, #4
   16df8:	e24dd020 	sub	sp, sp, #32
   16dfc:	e50b0020 	str	r0, [fp, #-32]
   16e00:	e50b1024 	str	r1, [fp, #-36]	; 0x24
  long  top_size;        /* Amount of top-most memory */
  long  extra;           /* Amount to release */
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;
   16e04:	e3a03a01 	mov	r3, #4096	; 0x1000
   16e08:	e50b3008 	str	r3, [fp, #-8]

  MALLOC_LOCK;
   16e0c:	e51b0020 	ldr	r0, [fp, #-32]
   16e10:	eb0006ce 	bl	18950 <__malloc_lock>

  top_size = chunksize(top);
   16e14:	e59f3180 	ldr	r3, [pc, #384]	; 16f9c <_malloc_trim_r+0x1ac>
   16e18:	e5933008 	ldr	r3, [r3, #8]
   16e1c:	e5933004 	ldr	r3, [r3, #4]
   16e20:	e3c33003 	bic	r3, r3, #3
   16e24:	e50b300c 	str	r3, [fp, #-12]
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
   16e28:	e51b200c 	ldr	r2, [fp, #-12]
   16e2c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   16e30:	e0632002 	rsb	r2, r3, r2
   16e34:	e51b3008 	ldr	r3, [fp, #-8]
   16e38:	e0823003 	add	r3, r2, r3
   16e3c:	e2433011 	sub	r3, r3, #17
   16e40:	e1a00003 	mov	r0, r3
   16e44:	e51b1008 	ldr	r1, [fp, #-8]
   16e48:	ebfff58d 	bl	14484 <__aeabi_uidiv>
   16e4c:	e1a03000 	mov	r3, r0
   16e50:	e2433001 	sub	r3, r3, #1
   16e54:	e51b2008 	ldr	r2, [fp, #-8]
   16e58:	e0030392 	mul	r3, r2, r3
   16e5c:	e50b3010 	str	r3, [fp, #-16]

  if (extra < (long)pagesz)  /* Not enough memory to release */
   16e60:	e51b2008 	ldr	r2, [fp, #-8]
   16e64:	e51b3010 	ldr	r3, [fp, #-16]
   16e68:	e1520003 	cmp	r2, r3
   16e6c:	da000003 	ble	16e80 <_malloc_trim_r+0x90>
  {
    MALLOC_UNLOCK;
   16e70:	e51b0020 	ldr	r0, [fp, #-32]
   16e74:	eb0006bf 	bl	18978 <__malloc_unlock>
    return 0;
   16e78:	e3a03000 	mov	r3, #0
   16e7c:	ea000042 	b	16f8c <_malloc_trim_r+0x19c>
  }

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
   16e80:	e51b0020 	ldr	r0, [fp, #-32]
   16e84:	e3a01000 	mov	r1, #0
   16e88:	eb0007c8 	bl	18db0 <_sbrk_r>
   16e8c:	e50b0014 	str	r0, [fp, #-20]
    if (current_brk != (char*)(top) + top_size)
   16e90:	e59f3104 	ldr	r3, [pc, #260]	; 16f9c <_malloc_trim_r+0x1ac>
   16e94:	e5932008 	ldr	r2, [r3, #8]
   16e98:	e51b300c 	ldr	r3, [fp, #-12]
   16e9c:	e0822003 	add	r2, r2, r3
   16ea0:	e51b3014 	ldr	r3, [fp, #-20]
   16ea4:	e1520003 	cmp	r2, r3
   16ea8:	0a000003 	beq	16ebc <_malloc_trim_r+0xcc>
    {
      MALLOC_UNLOCK;
   16eac:	e51b0020 	ldr	r0, [fp, #-32]
   16eb0:	eb0006b0 	bl	18978 <__malloc_unlock>
      return 0;     /* Apparently we don't own memory; must fail */
   16eb4:	e3a03000 	mov	r3, #0
   16eb8:	ea000033 	b	16f8c <_malloc_trim_r+0x19c>
    }

    else
    {
      new_brk = (char*)(MORECORE (-extra));
   16ebc:	e51b3010 	ldr	r3, [fp, #-16]
   16ec0:	e2633000 	rsb	r3, r3, #0
   16ec4:	e51b0020 	ldr	r0, [fp, #-32]
   16ec8:	e1a01003 	mov	r1, r3
   16ecc:	eb0007b7 	bl	18db0 <_sbrk_r>
   16ed0:	e50b0018 	str	r0, [fp, #-24]
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
   16ed4:	e51b3018 	ldr	r3, [fp, #-24]
   16ed8:	e3730001 	cmn	r3, #1
   16edc:	1a00001a 	bne	16f4c <_malloc_trim_r+0x15c>
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
   16ee0:	e51b0020 	ldr	r0, [fp, #-32]
   16ee4:	e3a01000 	mov	r1, #0
   16ee8:	eb0007b0 	bl	18db0 <_sbrk_r>
   16eec:	e50b0014 	str	r0, [fp, #-20]
        top_size = current_brk - (char*)top;
   16ef0:	e51b2014 	ldr	r2, [fp, #-20]
   16ef4:	e59f30a0 	ldr	r3, [pc, #160]	; 16f9c <_malloc_trim_r+0x1ac>
   16ef8:	e5933008 	ldr	r3, [r3, #8]
   16efc:	e0633002 	rsb	r3, r3, r2
   16f00:	e50b300c 	str	r3, [fp, #-12]
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
   16f04:	e51b300c 	ldr	r3, [fp, #-12]
   16f08:	e353000f 	cmp	r3, #15
   16f0c:	da00000a 	ble	16f3c <_malloc_trim_r+0x14c>
        {
          sbrked_mem = current_brk - sbrk_base;
   16f10:	e51b2014 	ldr	r2, [fp, #-20]
   16f14:	e59f3084 	ldr	r3, [pc, #132]	; 16fa0 <_malloc_trim_r+0x1b0>
   16f18:	e5933000 	ldr	r3, [r3]
   16f1c:	e0632002 	rsb	r2, r3, r2
   16f20:	e59f307c 	ldr	r3, [pc, #124]	; 16fa4 <_malloc_trim_r+0x1b4>
   16f24:	e5832000 	str	r2, [r3]
          set_head(top, top_size | PREV_INUSE);
   16f28:	e59f306c 	ldr	r3, [pc, #108]	; 16f9c <_malloc_trim_r+0x1ac>
   16f2c:	e5933008 	ldr	r3, [r3, #8]
   16f30:	e51b200c 	ldr	r2, [fp, #-12]
   16f34:	e3822001 	orr	r2, r2, #1
   16f38:	e5832004 	str	r2, [r3, #4]
        }
        check_chunk(top);
	MALLOC_UNLOCK;
   16f3c:	e51b0020 	ldr	r0, [fp, #-32]
   16f40:	eb00068c 	bl	18978 <__malloc_unlock>
        return 0; 
   16f44:	e3a03000 	mov	r3, #0
   16f48:	ea00000f 	b	16f8c <_malloc_trim_r+0x19c>
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
   16f4c:	e59f3048 	ldr	r3, [pc, #72]	; 16f9c <_malloc_trim_r+0x1ac>
   16f50:	e5933008 	ldr	r3, [r3, #8]
   16f54:	e51b100c 	ldr	r1, [fp, #-12]
   16f58:	e51b2010 	ldr	r2, [fp, #-16]
   16f5c:	e0622001 	rsb	r2, r2, r1
   16f60:	e3822001 	orr	r2, r2, #1
   16f64:	e5832004 	str	r2, [r3, #4]
        sbrked_mem -= extra;
   16f68:	e59f3034 	ldr	r3, [pc, #52]	; 16fa4 <_malloc_trim_r+0x1b4>
   16f6c:	e5932000 	ldr	r2, [r3]
   16f70:	e51b3010 	ldr	r3, [fp, #-16]
   16f74:	e0632002 	rsb	r2, r3, r2
   16f78:	e59f3024 	ldr	r3, [pc, #36]	; 16fa4 <_malloc_trim_r+0x1b4>
   16f7c:	e5832000 	str	r2, [r3]
        check_chunk(top);
	MALLOC_UNLOCK;
   16f80:	e51b0020 	ldr	r0, [fp, #-32]
   16f84:	eb00067b 	bl	18978 <__malloc_unlock>
        return 1;
   16f88:	e3a03001 	mov	r3, #1
      }
    }
  }
}
   16f8c:	e1a00003 	mov	r0, r3
   16f90:	e24bd004 	sub	sp, fp, #4
   16f94:	e8bd4800 	pop	{fp, lr}
   16f98:	e12fff1e 	bx	lr
   16f9c:	0003e468 	.word	0x0003e468
   16fa0:	0003e874 	.word	0x0003e874
   16fa4:	0013e9ec 	.word	0x0013e9ec

00016fa8 <_fwalk>:

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
   16fa8:	e92d49f0 	push	{r4, r5, r6, r7, r8, fp, lr}
   16fac:	e28db018 	add	fp, sp, #24
   16fb0:	e24dd00c 	sub	sp, sp, #12
   16fb4:	e50b0020 	str	r0, [fp, #-32]
   16fb8:	e1a08001 	mov	r8, r1
  register FILE *fp;
  register int n, ret = 0;
   16fbc:	e3a06000 	mov	r6, #0
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   16fc0:	e51b3020 	ldr	r3, [fp, #-32]
   16fc4:	e2835e2e 	add	r5, r3, #736	; 0x2e0
   16fc8:	ea000019 	b	17034 <_fwalk+0x8c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   16fcc:	e5954008 	ldr	r4, [r5, #8]
   16fd0:	e5957004 	ldr	r7, [r5, #4]
   16fd4:	ea000012 	b	17024 <_fwalk+0x7c>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   16fd8:	e1d430bc 	ldrh	r3, [r4, #12]
   16fdc:	e3530000 	cmp	r3, #0
   16fe0:	0a00000e 	beq	17020 <_fwalk+0x78>
   16fe4:	e1d430bc 	ldrh	r3, [r4, #12]
   16fe8:	e1a03803 	lsl	r3, r3, #16
   16fec:	e1a03843 	asr	r3, r3, #16
   16ff0:	e3530001 	cmp	r3, #1
   16ff4:	0a000009 	beq	17020 <_fwalk+0x78>
   16ff8:	e1d430be 	ldrh	r3, [r4, #14]
   16ffc:	e1a03803 	lsl	r3, r3, #16
   17000:	e1a03843 	asr	r3, r3, #16
   17004:	e3730001 	cmn	r3, #1
   17008:	0a000004 	beq	17020 <_fwalk+0x78>
	ret |= (*function) (fp);
   1700c:	e1a00004 	mov	r0, r4
   17010:	e1a0e00f 	mov	lr, pc
   17014:	e12fff18 	bx	r8
   17018:	e1a03000 	mov	r3, r0
   1701c:	e1866003 	orr	r6, r6, r3
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   17020:	e2844070 	add	r4, r4, #112	; 0x70
   17024:	e2477001 	sub	r7, r7, #1
   17028:	e3570000 	cmp	r7, #0
   1702c:	aaffffe9 	bge	16fd8 <_fwalk+0x30>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   17030:	e5955000 	ldr	r5, [r5]
   17034:	e3550000 	cmp	r5, #0
   17038:	1affffe3 	bne	16fcc <_fwalk+0x24>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*function) (fp);

  return ret;
   1703c:	e1a03006 	mov	r3, r6
}
   17040:	e1a00003 	mov	r0, r3
   17044:	e24bd018 	sub	sp, fp, #24
   17048:	e8bd49f0 	pop	{r4, r5, r6, r7, r8, fp, lr}
   1704c:	e12fff1e 	bx	lr

00017050 <_fwalk_reent>:
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
   17050:	e92d49f0 	push	{r4, r5, r6, r7, r8, fp, lr}
   17054:	e28db018 	add	fp, sp, #24
   17058:	e24dd00c 	sub	sp, sp, #12
   1705c:	e50b0020 	str	r0, [fp, #-32]
   17060:	e1a08001 	mov	r8, r1
  register FILE *fp;
  register int n, ret = 0;
   17064:	e3a06000 	mov	r6, #0
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   17068:	e51b3020 	ldr	r3, [fp, #-32]
   1706c:	e2835e2e 	add	r5, r3, #736	; 0x2e0
   17070:	ea00001d 	b	170ec <_fwalk_reent+0x9c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   17074:	e5954008 	ldr	r4, [r5, #8]
   17078:	e5957004 	ldr	r7, [r5, #4]
   1707c:	ea000016 	b	170dc <_fwalk_reent+0x8c>
      if (fp->_flags != 0)
   17080:	e1d430bc 	ldrh	r3, [r4, #12]
   17084:	e3530000 	cmp	r3, #0
   17088:	0a000012 	beq	170d8 <_fwalk_reent+0x88>
        {
          if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   1708c:	e1d430bc 	ldrh	r3, [r4, #12]
   17090:	e3530000 	cmp	r3, #0
   17094:	0a00000f 	beq	170d8 <_fwalk_reent+0x88>
   17098:	e1d430bc 	ldrh	r3, [r4, #12]
   1709c:	e1a03803 	lsl	r3, r3, #16
   170a0:	e1a03843 	asr	r3, r3, #16
   170a4:	e3530001 	cmp	r3, #1
   170a8:	0a00000a 	beq	170d8 <_fwalk_reent+0x88>
   170ac:	e1d430be 	ldrh	r3, [r4, #14]
   170b0:	e1a03803 	lsl	r3, r3, #16
   170b4:	e1a03843 	asr	r3, r3, #16
   170b8:	e3730001 	cmn	r3, #1
   170bc:	0a000005 	beq	170d8 <_fwalk_reent+0x88>
            ret |= (*reent_function) (ptr, fp);
   170c0:	e51b0020 	ldr	r0, [fp, #-32]
   170c4:	e1a01004 	mov	r1, r4
   170c8:	e1a0e00f 	mov	lr, pc
   170cc:	e12fff18 	bx	r8
   170d0:	e1a03000 	mov	r3, r0
   170d4:	e1866003 	orr	r6, r6, r3
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   170d8:	e2844070 	add	r4, r4, #112	; 0x70
   170dc:	e2477001 	sub	r7, r7, #1
   170e0:	e3570000 	cmp	r7, #0
   170e4:	aaffffe5 	bge	17080 <_fwalk_reent+0x30>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   170e8:	e5955000 	ldr	r5, [r5]
   170ec:	e3550000 	cmp	r5, #0
   170f0:	1affffdf 	bne	17074 <_fwalk_reent+0x24>
        {
          if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
            ret |= (*reent_function) (ptr, fp);
        }

  return ret;
   170f4:	e1a03006 	mov	r3, r6
}
   170f8:	e1a00003 	mov	r0, r3
   170fc:	e24bd018 	sub	sp, fp, #24
   17100:	e8bd49f0 	pop	{r4, r5, r6, r7, r8, fp, lr}
   17104:	e12fff1e 	bx	lr

00017108 <_fwrite_r>:
       struct _reent * ptr _AND
       _CONST _PTR buf _AND
       size_t size     _AND
       size_t count    _AND
       FILE * fp)
{
   17108:	e92d4800 	push	{fp, lr}
   1710c:	e28db004 	add	fp, sp, #4
   17110:	e24dd030 	sub	sp, sp, #48	; 0x30
   17114:	e50b0028 	str	r0, [fp, #-40]	; 0x28
   17118:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
   1711c:	e50b2030 	str	r2, [fp, #-48]	; 0x30
   17120:	e50b3034 	str	r3, [fp, #-52]	; 0x34
  size_t n;
#ifdef _FVWRITE_IN_STREAMIO
  struct __suio uio;
  struct __siov iov;

  iov.iov_base = buf;
   17124:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17128:	e50b3020 	str	r3, [fp, #-32]
  uio.uio_resid = iov.iov_len = n = count * size;
   1712c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   17130:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   17134:	e0030392 	mul	r3, r2, r3
   17138:	e50b3008 	str	r3, [fp, #-8]
   1713c:	e51b3008 	ldr	r3, [fp, #-8]
   17140:	e50b301c 	str	r3, [fp, #-28]
   17144:	e51b301c 	ldr	r3, [fp, #-28]
   17148:	e50b3010 	str	r3, [fp, #-16]
  uio.uio_iov = &iov;
   1714c:	e24b3020 	sub	r3, fp, #32
   17150:	e50b3018 	str	r3, [fp, #-24]
  uio.uio_iovcnt = 1;
   17154:	e3a03001 	mov	r3, #1
   17158:	e50b3014 	str	r3, [fp, #-20]
   * The usual case is success (__sfvwrite_r returns 0);
   * skip the divide if this happens, since divides are
   * generally slow and since this occurs whenever size==0.
   */

  CHECK_INIT(ptr, fp);
   1715c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   17160:	e50b300c 	str	r3, [fp, #-12]
   17164:	e51b300c 	ldr	r3, [fp, #-12]
   17168:	e3530000 	cmp	r3, #0
   1716c:	0a000005 	beq	17188 <_fwrite_r+0x80>
   17170:	e51b300c 	ldr	r3, [fp, #-12]
   17174:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   17178:	e3530000 	cmp	r3, #0
   1717c:	1a000001 	bne	17188 <_fwrite_r+0x80>
   17180:	e51b000c 	ldr	r0, [fp, #-12]
   17184:	ebfffd00 	bl	1658c <__sinit>

  _newlib_flockfile_start (fp);
   17188:	e59b3004 	ldr	r3, [fp, #4]
   1718c:	e1d330bc 	ldrh	r3, [r3, #12]
   17190:	e1a03803 	lsl	r3, r3, #16
   17194:	e1a03823 	lsr	r3, r3, #16
   17198:	e2033c02 	and	r3, r3, #512	; 0x200
   1719c:	e3530000 	cmp	r3, #0
   171a0:	1a000003 	bne	171b4 <_fwrite_r+0xac>
   171a4:	e59b3004 	ldr	r3, [fp, #4]
   171a8:	e283305c 	add	r3, r3, #92	; 0x5c
   171ac:	e1a00003 	mov	r0, r3
   171b0:	eb0000b2 	bl	17480 <_dna_lock_acquire>
  ORIENT (fp, -1);
   171b4:	e59b3004 	ldr	r3, [fp, #4]
   171b8:	e1d330bc 	ldrh	r3, [r3, #12]
   171bc:	e1a03803 	lsl	r3, r3, #16
   171c0:	e1a03823 	lsr	r3, r3, #16
   171c4:	e2033a02 	and	r3, r3, #8192	; 0x2000
   171c8:	e3530000 	cmp	r3, #0
   171cc:	1a00000b 	bne	17200 <_fwrite_r+0xf8>
   171d0:	e59b3004 	ldr	r3, [fp, #4]
   171d4:	e1d330bc 	ldrh	r3, [r3, #12]
   171d8:	e3833a02 	orr	r3, r3, #8192	; 0x2000
   171dc:	e1a03803 	lsl	r3, r3, #16
   171e0:	e1a02823 	lsr	r2, r3, #16
   171e4:	e59b3004 	ldr	r3, [fp, #4]
   171e8:	e1c320bc 	strh	r2, [r3, #12]
   171ec:	e59b3004 	ldr	r3, [fp, #4]
   171f0:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
   171f4:	e3c32a02 	bic	r2, r3, #8192	; 0x2000
   171f8:	e59b3004 	ldr	r3, [fp, #4]
   171fc:	e583206c 	str	r2, [r3, #108]	; 0x6c
  if (__sfvwrite_r (ptr, fp, &uio) == 0)
   17200:	e24b3018 	sub	r3, fp, #24
   17204:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
   17208:	e59b1004 	ldr	r1, [fp, #4]
   1720c:	e1a02003 	mov	r2, r3
   17210:	eb002a3d 	bl	21b0c <__sfvwrite_r>
   17214:	e1a03000 	mov	r3, r0
   17218:	e3530000 	cmp	r3, #0
   1721c:	1a00000c 	bne	17254 <_fwrite_r+0x14c>
    {
      _newlib_flockfile_exit (fp);
   17220:	e59b3004 	ldr	r3, [fp, #4]
   17224:	e1d330bc 	ldrh	r3, [r3, #12]
   17228:	e1a03803 	lsl	r3, r3, #16
   1722c:	e1a03823 	lsr	r3, r3, #16
   17230:	e2033c02 	and	r3, r3, #512	; 0x200
   17234:	e3530000 	cmp	r3, #0
   17238:	1a000003 	bne	1724c <_fwrite_r+0x144>
   1723c:	e59b3004 	ldr	r3, [fp, #4]
   17240:	e283305c 	add	r3, r3, #92	; 0x5c
   17244:	e1a00003 	mov	r0, r3
   17248:	eb0000f3 	bl	1761c <_dna_lock_release>
      return count;
   1724c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   17250:	ea000011 	b	1729c <_fwrite_r+0x194>
    }
  _newlib_flockfile_end (fp);
   17254:	e59b3004 	ldr	r3, [fp, #4]
   17258:	e1d330bc 	ldrh	r3, [r3, #12]
   1725c:	e1a03803 	lsl	r3, r3, #16
   17260:	e1a03823 	lsr	r3, r3, #16
   17264:	e2033c02 	and	r3, r3, #512	; 0x200
   17268:	e3530000 	cmp	r3, #0
   1726c:	1a000003 	bne	17280 <_fwrite_r+0x178>
   17270:	e59b3004 	ldr	r3, [fp, #4]
   17274:	e283305c 	add	r3, r3, #92	; 0x5c
   17278:	e1a00003 	mov	r0, r3
   1727c:	eb0000e6 	bl	1761c <_dna_lock_release>
  return (n - uio.uio_resid) / size;
   17280:	e51b3010 	ldr	r3, [fp, #-16]
   17284:	e51b2008 	ldr	r2, [fp, #-8]
   17288:	e0633002 	rsb	r3, r3, r2
   1728c:	e1a00003 	mov	r0, r3
   17290:	e51b1030 	ldr	r1, [fp, #-48]	; 0x30
   17294:	ebfff47a 	bl	14484 <__aeabi_uidiv>
   17298:	e1a03000 	mov	r3, r0

ret:
  _newlib_flockfile_end (fp);
  return i / size;
#endif
}
   1729c:	e1a00003 	mov	r0, r3
   172a0:	e24bd004 	sub	sp, fp, #4
   172a4:	e8bd4800 	pop	{fp, lr}
   172a8:	e12fff1e 	bx	lr

000172ac <fwrite>:
_DEFUN(fwrite, (buf, size, count, fp),
       _CONST _PTR buf _AND
       size_t size     _AND
       size_t count    _AND
       FILE * fp)
{
   172ac:	e92d4800 	push	{fp, lr}
   172b0:	e28db004 	add	fp, sp, #4
   172b4:	e24dd018 	sub	sp, sp, #24
   172b8:	e50b0008 	str	r0, [fp, #-8]
   172bc:	e50b100c 	str	r1, [fp, #-12]
   172c0:	e50b2010 	str	r2, [fp, #-16]
   172c4:	e50b3014 	str	r3, [fp, #-20]
  return _fwrite_r (_REENT, buf, size, count, fp);
   172c8:	e59f3030 	ldr	r3, [pc, #48]	; 17300 <fwrite+0x54>
   172cc:	e5933000 	ldr	r3, [r3]
   172d0:	e51b2014 	ldr	r2, [fp, #-20]
   172d4:	e58d2000 	str	r2, [sp]
   172d8:	e1a00003 	mov	r0, r3
   172dc:	e51b1008 	ldr	r1, [fp, #-8]
   172e0:	e51b200c 	ldr	r2, [fp, #-12]
   172e4:	e51b3010 	ldr	r3, [fp, #-16]
   172e8:	ebffff86 	bl	17108 <_fwrite_r>
   172ec:	e1a03000 	mov	r3, r0
}
   172f0:	e1a00003 	mov	r0, r3
   172f4:	e24bd004 	sub	sp, fp, #4
   172f8:	e8bd4800 	pop	{fp, lr}
   172fc:	e12fff1e 	bx	lr
   17300:	0003e460 	.word	0x0003e460

00017304 <gettimeofday>:

int
_DEFUN (_gettimeofday, (ptimeval, ptimezone),
        struct timeval  *ptimeval  _AND
        void *ptimezone)
{
   17304:	e92d4800 	push	{fp, lr}
   17308:	e28db004 	add	fp, sp, #4
   1730c:	e24dd008 	sub	sp, sp, #8
   17310:	e50b0008 	str	r0, [fp, #-8]
   17314:	e50b100c 	str	r1, [fp, #-12]
  errno = ENOSYS;
   17318:	eb00296c 	bl	218d0 <__errno>
   1731c:	e1a03000 	mov	r3, r0
   17320:	e3a02058 	mov	r2, #88	; 0x58
   17324:	e5832000 	str	r2, [r3]
  return -1;
   17328:	e3e03000 	mvn	r3, #0
}
   1732c:	e1a00003 	mov	r0, r3
   17330:	e24bd004 	sub	sp, fp, #4
   17334:	e8bd4800 	pop	{fp, lr}
   17338:	e12fff1e 	bx	lr

0001733c <_dna_lock_init>:
volatile int32_t __sanity_sem = -1;

void
_DEFUN (_dna_lock_init, (lock),
        dna_lock_t * lock)
{
   1733c:	e92d4810 	push	{r4, fp, lr}
   17340:	e28db008 	add	fp, sp, #8
   17344:	e24dd014 	sub	sp, sp, #20
   17348:	e50b0010 	str	r0, [fp, #-16]
//  cpu_dcache_inv_addr(&__sanity_sem);
  semaphore_acquire (__sanity_sem, 1, 0, -1);
   1734c:	e59f308c 	ldr	r3, [pc, #140]	; 173e0 <_dna_lock_init+0xa4>
   17350:	e5932000 	ldr	r2, [r3]
   17354:	e3e03000 	mvn	r3, #0
   17358:	e3e04000 	mvn	r4, #0
   1735c:	e88d0018 	stm	sp, {r3, r4}
   17360:	e1a00002 	mov	r0, r2
   17364:	e3a01001 	mov	r1, #1
   17368:	e3a02000 	mov	r2, #0
   1736c:	ebffeafa 	bl	11f5c <semaphore_acquire>

  if (lock -> id == -1 || lock -> id == 0) {
   17370:	e51b3010 	ldr	r3, [fp, #-16]
   17374:	e5933000 	ldr	r3, [r3]
   17378:	e3730001 	cmn	r3, #1
   1737c:	0a000003 	beq	17390 <_dna_lock_init+0x54>
   17380:	e51b3010 	ldr	r3, [fp, #-16]
   17384:	e5933000 	ldr	r3, [r3]
   17388:	e3530000 	cmp	r3, #0
   1738c:	1a000008 	bne	173b4 <_dna_lock_init+0x78>
    // TODO: comparing with 0 because impure_data structure is initialized with 0 ...
    semaphore_create ("libc_mutex", 1, & lock -> id);
   17390:	e51b3010 	ldr	r3, [fp, #-16]
   17394:	e59f0048 	ldr	r0, [pc, #72]	; 173e4 <_dna_lock_init+0xa8>
   17398:	e3a01001 	mov	r1, #1
   1739c:	e1a02003 	mov	r2, r3
   173a0:	ebffef0e 	bl	12fe0 <semaphore_create>
    lock -> count = 0;
   173a4:	e51b3010 	ldr	r3, [fp, #-16]
   173a8:	e3a02000 	mov	r2, #0
   173ac:	e5832004 	str	r2, [r3, #4]
   173b0:	ea000001 	b	173bc <_dna_lock_init+0x80>
  }
  else {
    dna_printf("_dna_lock_init: warning, already initiliazed.\n");
   173b4:	e59f002c 	ldr	r0, [pc, #44]	; 173e8 <_dna_lock_init+0xac>
   173b8:	ebffe057 	bl	f51c <dna_printf>
  }
//  cpu_dcache_inv_addr(&__sanity_sem);
  semaphore_release (__sanity_sem, 1, DNA_NO_RESCHEDULE);
   173bc:	e59f301c 	ldr	r3, [pc, #28]	; 173e0 <_dna_lock_init+0xa4>
   173c0:	e5933000 	ldr	r3, [r3]
   173c4:	e1a00003 	mov	r0, r3
   173c8:	e3a01001 	mov	r1, #1
   173cc:	e3a02001 	mov	r2, #1
   173d0:	ebffefa5 	bl	1326c <semaphore_release>
}
   173d4:	e24bd008 	sub	sp, fp, #8
   173d8:	e8bd4810 	pop	{r4, fp, lr}
   173dc:	e12fff1e 	bx	lr
   173e0:	0003e464 	.word	0x0003e464
   173e4:	00033008 	.word	0x00033008
   173e8:	00033014 	.word	0x00033014

000173ec <_dna_lock_close>:

void
_DEFUN (_dna_lock_close, (lock),
        dna_lock_t * lock)
{
   173ec:	e92d4810 	push	{r4, fp, lr}
   173f0:	e28db008 	add	fp, sp, #8
   173f4:	e24dd014 	sub	sp, sp, #20
   173f8:	e50b0010 	str	r0, [fp, #-16]
//  cpu_dcache_inv_addr(&__sanity_sem);
  semaphore_acquire (__sanity_sem, 1, 0, -1);
   173fc:	e59f3078 	ldr	r3, [pc, #120]	; 1747c <_dna_lock_close+0x90>
   17400:	e5932000 	ldr	r2, [r3]
   17404:	e3e03000 	mvn	r3, #0
   17408:	e3e04000 	mvn	r4, #0
   1740c:	e88d0018 	stm	sp, {r3, r4}
   17410:	e1a00002 	mov	r0, r2
   17414:	e3a01001 	mov	r1, #1
   17418:	e3a02000 	mov	r2, #0
   1741c:	ebffeace 	bl	11f5c <semaphore_acquire>

  if (lock -> id != -1)
   17420:	e51b3010 	ldr	r3, [fp, #-16]
   17424:	e5933000 	ldr	r3, [r3]
   17428:	e3730001 	cmn	r3, #1
   1742c:	0a000009 	beq	17458 <_dna_lock_close+0x6c>
  {
    semaphore_destroy (lock -> id);
   17430:	e51b3010 	ldr	r3, [fp, #-16]
   17434:	e5933000 	ldr	r3, [r3]
   17438:	e1a00003 	mov	r0, r3
   1743c:	ebffe5db 	bl	10bb0 <semaphore_destroy>
    lock -> id = -1;
   17440:	e51b3010 	ldr	r3, [fp, #-16]
   17444:	e3e02000 	mvn	r2, #0
   17448:	e5832000 	str	r2, [r3]
    lock -> count = 0;
   1744c:	e51b3010 	ldr	r3, [fp, #-16]
   17450:	e3a02000 	mov	r2, #0
   17454:	e5832004 	str	r2, [r3, #4]
  }
//  cpu_dcache_inv_addr(&__sanity_sem);
  semaphore_release (__sanity_sem, 1, DNA_NO_RESCHEDULE);
   17458:	e59f301c 	ldr	r3, [pc, #28]	; 1747c <_dna_lock_close+0x90>
   1745c:	e5933000 	ldr	r3, [r3]
   17460:	e1a00003 	mov	r0, r3
   17464:	e3a01001 	mov	r1, #1
   17468:	e3a02001 	mov	r2, #1
   1746c:	ebffef7e 	bl	1326c <semaphore_release>
}
   17470:	e24bd008 	sub	sp, fp, #8
   17474:	e8bd4810 	pop	{r4, fp, lr}
   17478:	e12fff1e 	bx	lr
   1747c:	0003e464 	.word	0x0003e464

00017480 <_dna_lock_acquire>:

void
_DEFUN (_dna_lock_acquire, (lock),
        dna_lock_t * lock)
{
   17480:	e92d4810 	push	{r4, fp, lr}
   17484:	e28db008 	add	fp, sp, #8
   17488:	e24dd044 	sub	sp, sp, #68	; 0x44
   1748c:	e50b0040 	str	r0, [fp, #-64]	; 0x40
  int32_t thread_id = -1;
   17490:	e3e03000 	mvn	r3, #0
   17494:	e50b3014 	str	r3, [fp, #-20]
  semaphore_info_t sem_info;
  status_t status = DNA_OK;
   17498:	e3a03000 	mov	r3, #0
   1749c:	e14b30be 	strh	r3, [fp, #-14]

  /*
   * We need to check the validity of the lock
   */
  cpu_dcache_invalidate((void*)&__sanity_sem, sizeof(volatile int32_t));
   174a0:	e59f0168 	ldr	r0, [pc, #360]	; 17610 <_dna_lock_acquire+0x190>
   174a4:	e3a01004 	mov	r1, #4
   174a8:	ebffe464 	bl	10640 <cpu_dcache_invalidate>
  semaphore_acquire (__sanity_sem, 1, 0, -1);
   174ac:	e59f315c 	ldr	r3, [pc, #348]	; 17610 <_dna_lock_acquire+0x190>
   174b0:	e5932000 	ldr	r2, [r3]
   174b4:	e3e03000 	mvn	r3, #0
   174b8:	e3e04000 	mvn	r4, #0
   174bc:	e88d0018 	stm	sp, {r3, r4}
   174c0:	e1a00002 	mov	r0, r2
   174c4:	e3a01001 	mov	r1, #1
   174c8:	e3a02000 	mov	r2, #0
   174cc:	ebffeaa2 	bl	11f5c <semaphore_acquire>
//  cpu_dcache_inv_addr((void*)&lock->id);
  cpu_dcache_invalidate((void*)&lock->id,sizeof(int32_t));
   174d0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   174d4:	e1a00003 	mov	r0, r3
   174d8:	e3a01004 	mov	r1, #4
   174dc:	ebffe457 	bl	10640 <cpu_dcache_invalidate>
  if (lock -> id == -1)
   174e0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   174e4:	e5933000 	ldr	r3, [r3]
   174e8:	e3730001 	cmn	r3, #1
   174ec:	1a000007 	bne	17510 <_dna_lock_acquire+0x90>
  {
    // TODO: semaphore should be initiliazed in a static way
    // (temporary solution for malloc)
    semaphore_create ("libc_mutex_static", 1, & lock -> id);
   174f0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   174f4:	e59f0118 	ldr	r0, [pc, #280]	; 17614 <_dna_lock_acquire+0x194>
   174f8:	e3a01001 	mov	r1, #1
   174fc:	e1a02003 	mov	r2, r3
   17500:	ebffeeb6 	bl	12fe0 <semaphore_create>
    lock -> count = 0;
   17504:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   17508:	e3a02000 	mov	r2, #0
   1750c:	e5832004 	str	r2, [r3, #4]
  }

  cpu_dcache_invalidate((void*)&__sanity_sem, sizeof(volatile int32_t));
   17510:	e59f00f8 	ldr	r0, [pc, #248]	; 17610 <_dna_lock_acquire+0x190>
   17514:	e3a01004 	mov	r1, #4
   17518:	ebffe448 	bl	10640 <cpu_dcache_invalidate>
  semaphore_release (__sanity_sem, 1, DNA_NO_RESCHEDULE);
   1751c:	e59f30ec 	ldr	r3, [pc, #236]	; 17610 <_dna_lock_acquire+0x190>
   17520:	e5933000 	ldr	r3, [r3]
   17524:	e1a00003 	mov	r0, r3
   17528:	e3a01001 	mov	r1, #1
   1752c:	e3a02001 	mov	r2, #1
   17530:	ebffef4d 	bl	1326c <semaphore_release>

  /*
   * And then we proceed
   */

  thread_find (NULL, & thread_id);
   17534:	e24b3014 	sub	r3, fp, #20
   17538:	e3a00000 	mov	r0, #0
   1753c:	e1a01003 	mov	r1, r3
   17540:	ebfff115 	bl	1399c <thread_find>

  status = semaphore_acquire (lock -> id, 1, DNA_RELATIVE_TIMEOUT, 0);
   17544:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   17548:	e5932000 	ldr	r2, [r3]
   1754c:	e3a03000 	mov	r3, #0
   17550:	e3a04000 	mov	r4, #0
   17554:	e88d0018 	stm	sp, {r3, r4}
   17558:	e1a00002 	mov	r0, r2
   1755c:	e3a01001 	mov	r1, #1
   17560:	e3a02002 	mov	r2, #2
   17564:	ebffea7c 	bl	11f5c <semaphore_acquire>
   17568:	e1a03000 	mov	r3, r0
   1756c:	e14b30be 	strh	r3, [fp, #-14]
  semaphore_get_info (lock -> id, & sem_info);
   17570:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   17574:	e5932000 	ldr	r2, [r3]
   17578:	e24b303c 	sub	r3, fp, #60	; 0x3c
   1757c:	e1a00002 	mov	r0, r2
   17580:	e1a01003 	mov	r1, r3
   17584:	ebffe51d 	bl	10a00 <semaphore_get_info>
  
  if (status == DNA_WOULD_BLOCK)
   17588:	e15b20be 	ldrh	r2, [fp, #-14]
   1758c:	e59f3084 	ldr	r3, [pc, #132]	; 17618 <_dna_lock_acquire+0x198>
   17590:	e1520003 	cmp	r2, r3
   17594:	1a000010 	bne	175dc <_dna_lock_acquire+0x15c>
  {
//    cpu_dcache_inv_addr((void*)&lock->count);
//    cpu_dcache_inv_addr((void*)&sem_info.latest_holder);
    if (sem_info . latest_holder != thread_id || lock -> count == 0)
   17598:	e51b2018 	ldr	r2, [fp, #-24]
   1759c:	e51b3014 	ldr	r3, [fp, #-20]
   175a0:	e1520003 	cmp	r2, r3
   175a4:	1a000003 	bne	175b8 <_dna_lock_acquire+0x138>
   175a8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   175ac:	e5933004 	ldr	r3, [r3, #4]
   175b0:	e3530000 	cmp	r3, #0
   175b4:	1a000008 	bne	175dc <_dna_lock_acquire+0x15c>
    {
//      cpu_dcache_inv_addr((void*)&lock->id);
      semaphore_acquire (lock -> id, 1, 0, -1);
   175b8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   175bc:	e5932000 	ldr	r2, [r3]
   175c0:	e3e03000 	mvn	r3, #0
   175c4:	e3e04000 	mvn	r4, #0
   175c8:	e88d0018 	stm	sp, {r3, r4}
   175cc:	e1a00002 	mov	r0, r2
   175d0:	e3a01001 	mov	r1, #1
   175d4:	e3a02000 	mov	r2, #0
   175d8:	ebffea5f 	bl	11f5c <semaphore_acquire>

  /*
   * Increase the usage counter.
   */
//  cpu_dcache_inv_addr(&lock->count);
  cpu_dcache_invalidate((void*)&(lock->count),sizeof(int32_t));
   175dc:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   175e0:	e2833004 	add	r3, r3, #4
   175e4:	e1a00003 	mov	r0, r3
   175e8:	e3a01004 	mov	r1, #4
   175ec:	ebffe413 	bl	10640 <cpu_dcache_invalidate>

  lock -> count += 1;
   175f0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   175f4:	e5933004 	ldr	r3, [r3, #4]
   175f8:	e2832001 	add	r2, r3, #1
   175fc:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   17600:	e5832004 	str	r2, [r3, #4]
}
   17604:	e24bd008 	sub	sp, fp, #8
   17608:	e8bd4810 	pop	{r4, fp, lr}
   1760c:	e12fff1e 	bx	lr
   17610:	0003e464 	.word	0x0003e464
   17614:	00033044 	.word	0x00033044
   17618:	0000fdfd 	.word	0x0000fdfd

0001761c <_dna_lock_release>:

void
_DEFUN (_dna_lock_release, (lock),
        dna_lock_t * lock)
{
   1761c:	e92d4800 	push	{fp, lr}
   17620:	e28db004 	add	fp, sp, #4
   17624:	e24dd008 	sub	sp, sp, #8
   17628:	e50b0008 	str	r0, [fp, #-8]
  if (lock -> id != -1)
   1762c:	e51b3008 	ldr	r3, [fp, #-8]
   17630:	e5933000 	ldr	r3, [r3]
   17634:	e3730001 	cmn	r3, #1
   17638:	0a00000e 	beq	17678 <_dna_lock_release+0x5c>
  {
//    cpu_dcache_inv_addr((void*)&lock->count);
    lock -> count -= 1;
   1763c:	e51b3008 	ldr	r3, [fp, #-8]
   17640:	e5933004 	ldr	r3, [r3, #4]
   17644:	e2432001 	sub	r2, r3, #1
   17648:	e51b3008 	ldr	r3, [fp, #-8]
   1764c:	e5832004 	str	r2, [r3, #4]

    if (lock -> count == 0)
   17650:	e51b3008 	ldr	r3, [fp, #-8]
   17654:	e5933004 	ldr	r3, [r3, #4]
   17658:	e3530000 	cmp	r3, #0
   1765c:	1a000005 	bne	17678 <_dna_lock_release+0x5c>
    {
      semaphore_release (lock -> id, 1, DNA_NO_RESCHEDULE);
   17660:	e51b3008 	ldr	r3, [fp, #-8]
   17664:	e5933000 	ldr	r3, [r3]
   17668:	e1a00003 	mov	r0, r3
   1766c:	e3a01001 	mov	r1, #1
   17670:	e3a02001 	mov	r2, #1
   17674:	ebffeefc 	bl	1326c <semaphore_release>
    }
  }
}
   17678:	e24bd004 	sub	sp, fp, #4
   1767c:	e8bd4800 	pop	{fp, lr}
   17680:	e12fff1e 	bx	lr

00017684 <malloc>:
#ifndef _REENT_ONLY

_PTR
_DEFUN (malloc, (nbytes),
	size_t nbytes)		/* get a block */
{
   17684:	e92d4800 	push	{fp, lr}
   17688:	e28db004 	add	fp, sp, #4
   1768c:	e24dd008 	sub	sp, sp, #8
   17690:	e50b0008 	str	r0, [fp, #-8]
  return _malloc_r (_REENT, nbytes);
   17694:	e59f3020 	ldr	r3, [pc, #32]	; 176bc <malloc+0x38>
   17698:	e5933000 	ldr	r3, [r3]
   1769c:	e1a00003 	mov	r0, r3
   176a0:	e51b1008 	ldr	r1, [fp, #-8]
   176a4:	eb000102 	bl	17ab4 <_malloc_r>
   176a8:	e1a03000 	mov	r3, r0
}
   176ac:	e1a00003 	mov	r0, r3
   176b0:	e24bd004 	sub	sp, fp, #4
   176b4:	e8bd4800 	pop	{fp, lr}
   176b8:	e12fff1e 	bx	lr
   176bc:	0003e460 	.word	0x0003e460

000176c0 <free>:

void
_DEFUN (free, (aptr),
	_PTR aptr)
{
   176c0:	e92d4800 	push	{fp, lr}
   176c4:	e28db004 	add	fp, sp, #4
   176c8:	e24dd008 	sub	sp, sp, #8
   176cc:	e50b0008 	str	r0, [fp, #-8]
  _free_r (_REENT, aptr);
   176d0:	e59f3018 	ldr	r3, [pc, #24]	; 176f0 <free+0x30>
   176d4:	e5933000 	ldr	r3, [r3]
   176d8:	e1a00003 	mov	r0, r3
   176dc:	e51b1008 	ldr	r1, [fp, #-8]
   176e0:	ebfffc6a 	bl	16890 <_free_r>
}
   176e4:	e24bd004 	sub	sp, fp, #4
   176e8:	e8bd4800 	pop	{fp, lr}
   176ec:	e12fff1e 	bx	lr
   176f0:	0003e460 	.word	0x0003e460

000176f4 <malloc_extend_top>:
#if __STD_C
static void malloc_extend_top(RARG INTERNAL_SIZE_T nb)
#else
static void malloc_extend_top(RARG nb) RDECL INTERNAL_SIZE_T nb;
#endif
{
   176f4:	e92d4800 	push	{fp, lr}
   176f8:	e28db004 	add	fp, sp, #4
   176fc:	e24dd038 	sub	sp, sp, #56	; 0x38
   17700:	e50b0038 	str	r0, [fp, #-56]	; 0x38
   17704:	e50b103c 	str	r1, [fp, #-60]	; 0x3c
  char*     brk;                  /* return value from sbrk */
  INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of sbrked space */
  INTERNAL_SIZE_T correction;     /* bytes for 2nd sbrk call */
  int correction_failed = 0;      /* whether we should relax the assertion */
   17708:	e3a03000 	mov	r3, #0
   1770c:	e50b3018 	str	r3, [fp, #-24]
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
   17710:	e59f3384 	ldr	r3, [pc, #900]	; 17a9c <malloc_extend_top+0x3a8>
   17714:	e5933008 	ldr	r3, [r3, #8]
   17718:	e50b301c 	str	r3, [fp, #-28]
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
   1771c:	e51b301c 	ldr	r3, [fp, #-28]
   17720:	e5933004 	ldr	r3, [r3, #4]
   17724:	e3c33003 	bic	r3, r3, #3
   17728:	e50b3020 	str	r3, [fp, #-32]
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
   1772c:	e51b201c 	ldr	r2, [fp, #-28]
   17730:	e51b3020 	ldr	r3, [fp, #-32]
   17734:	e0823003 	add	r3, r2, r3
   17738:	e50b3024 	str	r3, [fp, #-36]	; 0x24

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
   1773c:	e59f335c 	ldr	r3, [pc, #860]	; 17aa0 <malloc_extend_top+0x3ac>
   17740:	e5932000 	ldr	r2, [r3]
   17744:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   17748:	e0823003 	add	r3, r2, r3
   1774c:	e2833010 	add	r3, r3, #16
   17750:	e50b3014 	str	r3, [fp, #-20]
  unsigned long pagesz    = malloc_getpagesize;
   17754:	e3a03a01 	mov	r3, #4096	; 0x1000
   17758:	e50b3028 	str	r3, [fp, #-40]	; 0x28

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
   1775c:	e59f3340 	ldr	r3, [pc, #832]	; 17aa4 <malloc_extend_top+0x3b0>
   17760:	e5933000 	ldr	r3, [r3]
   17764:	e3730001 	cmn	r3, #1
   17768:	0a000007 	beq	1778c <malloc_extend_top+0x98>
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
   1776c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   17770:	e51b3014 	ldr	r3, [fp, #-20]
   17774:	e0823003 	add	r3, r2, r3
   17778:	e2432001 	sub	r2, r3, #1
   1777c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   17780:	e2633000 	rsb	r3, r3, #0
   17784:	e0033002 	and	r3, r3, r2
   17788:	e50b3014 	str	r3, [fp, #-20]

  brk = (char*)(MORECORE (sbrk_size));
   1778c:	e51b3014 	ldr	r3, [fp, #-20]
   17790:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
   17794:	e1a01003 	mov	r1, r3
   17798:	eb000584 	bl	18db0 <_sbrk_r>
   1779c:	e50b0008 	str	r0, [fp, #-8]

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
   177a0:	e51b3008 	ldr	r3, [fp, #-8]
   177a4:	e3730001 	cmn	r3, #1
   177a8:	0a000007 	beq	177cc <malloc_extend_top+0xd8>
   177ac:	e51b2008 	ldr	r2, [fp, #-8]
   177b0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   177b4:	e1520003 	cmp	r2, r3
   177b8:	2a000004 	bcs	177d0 <malloc_extend_top+0xdc>
      (brk < old_end && old_top != initial_top))
   177bc:	e51b201c 	ldr	r2, [fp, #-28]
   177c0:	e59f32d4 	ldr	r3, [pc, #724]	; 17a9c <malloc_extend_top+0x3a8>
   177c4:	e1520003 	cmp	r2, r3
   177c8:	0a000000 	beq	177d0 <malloc_extend_top+0xdc>
    return;
   177cc:	ea0000af 	b	17a90 <malloc_extend_top+0x39c>

  sbrked_mem += sbrk_size;
   177d0:	e59f32d0 	ldr	r3, [pc, #720]	; 17aa8 <malloc_extend_top+0x3b4>
   177d4:	e5933000 	ldr	r3, [r3]
   177d8:	e1a02003 	mov	r2, r3
   177dc:	e51b3014 	ldr	r3, [fp, #-20]
   177e0:	e0823003 	add	r3, r2, r3
   177e4:	e1a02003 	mov	r2, r3
   177e8:	e59f32b8 	ldr	r3, [pc, #696]	; 17aa8 <malloc_extend_top+0x3b4>
   177ec:	e5832000 	str	r2, [r3]

  if (brk == old_end /* can just add bytes to current top, unless
   177f0:	e51b2008 	ldr	r2, [fp, #-8]
   177f4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   177f8:	e1520003 	cmp	r2, r3
   177fc:	1a00000f 	bne	17840 <malloc_extend_top+0x14c>
			previous correction failed */
      && ((POINTER_UINT)old_end & (pagesz - 1)) == 0)
   17800:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   17804:	e2432001 	sub	r2, r3, #1
   17808:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1780c:	e0033002 	and	r3, r3, r2
   17810:	e3530000 	cmp	r3, #0
   17814:	1a000009 	bne	17840 <malloc_extend_top+0x14c>
  {
    top_size = sbrk_size + old_top_size;
   17818:	e51b2014 	ldr	r2, [fp, #-20]
   1781c:	e51b3020 	ldr	r3, [fp, #-32]
   17820:	e0823003 	add	r3, r2, r3
   17824:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    set_head(top, top_size | PREV_INUSE);
   17828:	e59f326c 	ldr	r3, [pc, #620]	; 17a9c <malloc_extend_top+0x3a8>
   1782c:	e5933008 	ldr	r3, [r3, #8]
   17830:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
   17834:	e3822001 	orr	r2, r2, #1
   17838:	e5832004 	str	r2, [r3, #4]
   1783c:	ea00007b 	b	17a30 <malloc_extend_top+0x33c>
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
   17840:	e59f325c 	ldr	r3, [pc, #604]	; 17aa4 <malloc_extend_top+0x3b0>
   17844:	e5933000 	ldr	r3, [r3]
   17848:	e3730001 	cmn	r3, #1
   1784c:	1a000003 	bne	17860 <malloc_extend_top+0x16c>
      sbrk_base = brk;
   17850:	e59f324c 	ldr	r3, [pc, #588]	; 17aa4 <malloc_extend_top+0x3b0>
   17854:	e51b2008 	ldr	r2, [fp, #-8]
   17858:	e5832000 	str	r2, [r3]
   1785c:	ea000007 	b	17880 <malloc_extend_top+0x18c>
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
   17860:	e59f3240 	ldr	r3, [pc, #576]	; 17aa8 <malloc_extend_top+0x3b4>
   17864:	e5932000 	ldr	r2, [r3]
   17868:	e51b1008 	ldr	r1, [fp, #-8]
   1786c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17870:	e0633001 	rsb	r3, r3, r1
   17874:	e0822003 	add	r2, r2, r3
   17878:	e59f3228 	ldr	r3, [pc, #552]	; 17aa8 <malloc_extend_top+0x3b4>
   1787c:	e5832000 	str	r2, [r3]

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (POINTER_UINT)chunk2mem(brk) & MALLOC_ALIGN_MASK;
   17880:	e51b3008 	ldr	r3, [fp, #-8]
   17884:	e2833008 	add	r3, r3, #8
   17888:	e2033007 	and	r3, r3, #7
   1788c:	e50b3030 	str	r3, [fp, #-48]	; 0x30
    if (front_misalign > 0) 
   17890:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   17894:	e3530000 	cmp	r3, #0
   17898:	0a000007 	beq	178bc <malloc_extend_top+0x1c8>
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
   1789c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   178a0:	e2633008 	rsb	r3, r3, #8
   178a4:	e50b300c 	str	r3, [fp, #-12]
      brk += correction;
   178a8:	e51b2008 	ldr	r2, [fp, #-8]
   178ac:	e51b300c 	ldr	r3, [fp, #-12]
   178b0:	e0823003 	add	r3, r2, r3
   178b4:	e50b3008 	str	r3, [fp, #-8]
   178b8:	ea000001 	b	178c4 <malloc_extend_top+0x1d0>
    }
    else
      correction = 0;
   178bc:	e3a03000 	mov	r3, #0
   178c0:	e50b300c 	str	r3, [fp, #-12]

    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));
   178c4:	e51b2008 	ldr	r2, [fp, #-8]
   178c8:	e51b3014 	ldr	r3, [fp, #-20]
   178cc:	e0823003 	add	r3, r2, r3
   178d0:	e1a02003 	mov	r2, r3
   178d4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   178d8:	e2433001 	sub	r3, r3, #1
   178dc:	e0033002 	and	r3, r3, r2
   178e0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   178e4:	e0633002 	rsb	r3, r3, r2
   178e8:	e51b200c 	ldr	r2, [fp, #-12]
   178ec:	e0823003 	add	r3, r2, r3
   178f0:	e50b300c 	str	r3, [fp, #-12]

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
   178f4:	e51b300c 	ldr	r3, [fp, #-12]
   178f8:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
   178fc:	e1a01003 	mov	r1, r3
   17900:	eb00052a 	bl	18db0 <_sbrk_r>
   17904:	e50b0010 	str	r0, [fp, #-16]
    if (new_brk == (char*)(MORECORE_FAILURE))
   17908:	e51b3010 	ldr	r3, [fp, #-16]
   1790c:	e3730001 	cmn	r3, #1
   17910:	1a000005 	bne	1792c <malloc_extend_top+0x238>
      {
	correction = 0;
   17914:	e3a03000 	mov	r3, #0
   17918:	e50b300c 	str	r3, [fp, #-12]
	correction_failed = 1;
   1791c:	e3a03001 	mov	r3, #1
   17920:	e50b3018 	str	r3, [fp, #-24]
	new_brk = brk;
   17924:	e51b3008 	ldr	r3, [fp, #-8]
   17928:	e50b3010 	str	r3, [fp, #-16]
      }

    sbrked_mem += correction;
   1792c:	e59f3174 	ldr	r3, [pc, #372]	; 17aa8 <malloc_extend_top+0x3b4>
   17930:	e5933000 	ldr	r3, [r3]
   17934:	e1a02003 	mov	r2, r3
   17938:	e51b300c 	ldr	r3, [fp, #-12]
   1793c:	e0823003 	add	r3, r2, r3
   17940:	e1a02003 	mov	r2, r3
   17944:	e59f315c 	ldr	r3, [pc, #348]	; 17aa8 <malloc_extend_top+0x3b4>
   17948:	e5832000 	str	r2, [r3]

    top = (mchunkptr)brk;
   1794c:	e59f3148 	ldr	r3, [pc, #328]	; 17a9c <malloc_extend_top+0x3a8>
   17950:	e51b2008 	ldr	r2, [fp, #-8]
   17954:	e5832008 	str	r2, [r3, #8]
    top_size = new_brk - brk + correction;
   17958:	e51b2010 	ldr	r2, [fp, #-16]
   1795c:	e51b3008 	ldr	r3, [fp, #-8]
   17960:	e0633002 	rsb	r3, r3, r2
   17964:	e1a02003 	mov	r2, r3
   17968:	e51b300c 	ldr	r3, [fp, #-12]
   1796c:	e0823003 	add	r3, r2, r3
   17970:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    set_head(top, top_size | PREV_INUSE);
   17974:	e59f3120 	ldr	r3, [pc, #288]	; 17a9c <malloc_extend_top+0x3a8>
   17978:	e5933008 	ldr	r3, [r3, #8]
   1797c:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
   17980:	e3822001 	orr	r2, r2, #1
   17984:	e5832004 	str	r2, [r3, #4]

    if (old_top != initial_top)
   17988:	e51b201c 	ldr	r2, [fp, #-28]
   1798c:	e59f3108 	ldr	r3, [pc, #264]	; 17a9c <malloc_extend_top+0x3a8>
   17990:	e1520003 	cmp	r2, r3
   17994:	0a000025 	beq	17a30 <malloc_extend_top+0x33c>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
   17998:	e51b3020 	ldr	r3, [fp, #-32]
   1799c:	e353000f 	cmp	r3, #15
   179a0:	8a000004 	bhi	179b8 <malloc_extend_top+0x2c4>
      {
        set_head(top, PREV_INUSE); /* will force null return from malloc */
   179a4:	e59f30f0 	ldr	r3, [pc, #240]	; 17a9c <malloc_extend_top+0x3a8>
   179a8:	e5933008 	ldr	r3, [r3, #8]
   179ac:	e3a02001 	mov	r2, #1
   179b0:	e5832004 	str	r2, [r3, #4]
        return;
   179b4:	ea000035 	b	17a90 <malloc_extend_top+0x39c>
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
   179b8:	e51b3020 	ldr	r3, [fp, #-32]
   179bc:	e243300c 	sub	r3, r3, #12
   179c0:	e3c33007 	bic	r3, r3, #7
   179c4:	e50b3020 	str	r3, [fp, #-32]
      set_head_size(old_top, old_top_size);
   179c8:	e51b301c 	ldr	r3, [fp, #-28]
   179cc:	e5933004 	ldr	r3, [r3, #4]
   179d0:	e2032001 	and	r2, r3, #1
   179d4:	e51b3020 	ldr	r3, [fp, #-32]
   179d8:	e1822003 	orr	r2, r2, r3
   179dc:	e51b301c 	ldr	r3, [fp, #-28]
   179e0:	e5832004 	str	r2, [r3, #4]
      chunk_at_offset(old_top, old_top_size          )->size =
   179e4:	e51b201c 	ldr	r2, [fp, #-28]
   179e8:	e51b3020 	ldr	r3, [fp, #-32]
   179ec:	e0823003 	add	r3, r2, r3
   179f0:	e3a02005 	mov	r2, #5
   179f4:	e5832004 	str	r2, [r3, #4]
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
   179f8:	e51b3020 	ldr	r3, [fp, #-32]
   179fc:	e2833004 	add	r3, r3, #4
   17a00:	e51b201c 	ldr	r2, [fp, #-28]
   17a04:	e0823003 	add	r3, r2, r3
   17a08:	e3a02005 	mov	r2, #5
   17a0c:	e5832004 	str	r2, [r3, #4]
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
   17a10:	e51b3020 	ldr	r3, [fp, #-32]
   17a14:	e353000f 	cmp	r3, #15
   17a18:	9a000004 	bls	17a30 <malloc_extend_top+0x33c>
        fREe(RCALL chunk2mem(old_top));
   17a1c:	e51b301c 	ldr	r3, [fp, #-28]
   17a20:	e2833008 	add	r3, r3, #8
   17a24:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
   17a28:	e1a01003 	mov	r1, r3
   17a2c:	ebfffb97 	bl	16890 <_free_r>
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem) 
   17a30:	e59f3070 	ldr	r3, [pc, #112]	; 17aa8 <malloc_extend_top+0x3b4>
   17a34:	e5933000 	ldr	r3, [r3]
   17a38:	e1a02003 	mov	r2, r3
   17a3c:	e59f3068 	ldr	r3, [pc, #104]	; 17aac <malloc_extend_top+0x3b8>
   17a40:	e5933000 	ldr	r3, [r3]
   17a44:	e1520003 	cmp	r2, r3
   17a48:	9a000004 	bls	17a60 <malloc_extend_top+0x36c>
    max_sbrked_mem = sbrked_mem;
   17a4c:	e59f3054 	ldr	r3, [pc, #84]	; 17aa8 <malloc_extend_top+0x3b4>
   17a50:	e5933000 	ldr	r3, [r3]
   17a54:	e1a02003 	mov	r2, r3
   17a58:	e59f304c 	ldr	r3, [pc, #76]	; 17aac <malloc_extend_top+0x3b8>
   17a5c:	e5832000 	str	r2, [r3]
#if HAVE_MMAP
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem) 
    max_total_mem = mmapped_mem + sbrked_mem;
#else
  if ((unsigned long)(sbrked_mem) > (unsigned long)max_total_mem) 
   17a60:	e59f3040 	ldr	r3, [pc, #64]	; 17aa8 <malloc_extend_top+0x3b4>
   17a64:	e5933000 	ldr	r3, [r3]
   17a68:	e1a02003 	mov	r2, r3
   17a6c:	e59f303c 	ldr	r3, [pc, #60]	; 17ab0 <malloc_extend_top+0x3bc>
   17a70:	e5933000 	ldr	r3, [r3]
   17a74:	e1520003 	cmp	r2, r3
   17a78:	9a000004 	bls	17a90 <malloc_extend_top+0x39c>
    max_total_mem = sbrked_mem;
   17a7c:	e59f3024 	ldr	r3, [pc, #36]	; 17aa8 <malloc_extend_top+0x3b4>
   17a80:	e5933000 	ldr	r3, [r3]
   17a84:	e1a02003 	mov	r2, r3
   17a88:	e59f3020 	ldr	r3, [pc, #32]	; 17ab0 <malloc_extend_top+0x3bc>
   17a8c:	e5832000 	str	r2, [r3]
#endif

  /* We always land on a page boundary */
  assert(((unsigned long)((char*)top + top_size) & (pagesz - 1)) == 0
	 || correction_failed);
}
   17a90:	e24bd004 	sub	sp, fp, #4
   17a94:	e8bd4800 	pop	{fp, lr}
   17a98:	e12fff1e 	bx	lr
   17a9c:	0003e468 	.word	0x0003e468
   17aa0:	0013e9e0 	.word	0x0013e9e0
   17aa4:	0003e874 	.word	0x0003e874
   17aa8:	0013e9ec 	.word	0x0013e9ec
   17aac:	0013e9e4 	.word	0x0013e9e4
   17ab0:	0013e9e8 	.word	0x0013e9e8

00017ab4 <_malloc_r>:
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
   17ab4:	e92d4800 	push	{fp, lr}
   17ab8:	e28db004 	add	fp, sp, #4
   17abc:	e24dd040 	sub	sp, sp, #64	; 0x40
   17ac0:	e50b0040 	str	r0, [fp, #-64]	; 0x40
   17ac4:	e50b1044 	str	r1, [fp, #-68]	; 0x44
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
   17ac8:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   17acc:	e283300b 	add	r3, r3, #11
   17ad0:	e3530016 	cmp	r3, #22
   17ad4:	9a000003 	bls	17ae8 <_malloc_r+0x34>
   17ad8:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   17adc:	e283300b 	add	r3, r3, #11
   17ae0:	e3c33007 	bic	r3, r3, #7
   17ae4:	ea000000 	b	17aec <_malloc_r+0x38>
   17ae8:	e3a03010 	mov	r3, #16
   17aec:	e50b302c 	str	r3, [fp, #-44]	; 0x2c

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   17af0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17af4:	e3530000 	cmp	r3, #0
   17af8:	ba000003 	blt	17b0c <_malloc_r+0x58>
   17afc:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
   17b00:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   17b04:	e1520003 	cmp	r2, r3
   17b08:	2a000004 	bcs	17b20 <_malloc_r+0x6c>
  {
    RERRNO = ENOMEM;
   17b0c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   17b10:	e3a0200c 	mov	r2, #12
   17b14:	e5832000 	str	r2, [r3]
    return 0;
   17b18:	e3a03000 	mov	r3, #0
   17b1c:	ea0002a4 	b	185b4 <_malloc_r+0xb00>
  }

  MALLOC_LOCK;
   17b20:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   17b24:	eb000389 	bl	18950 <__malloc_lock>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
   17b28:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17b2c:	e3530f7e 	cmp	r3, #504	; 0x1f8
   17b30:	2a00003b 	bcs	17c24 <_malloc_r+0x170>
  {
    idx = smallbin_index(nb); 
   17b34:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17b38:	e1a031a3 	lsr	r3, r3, #3
   17b3c:	e50b300c 	str	r3, [fp, #-12]

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
   17b40:	e51b300c 	ldr	r3, [fp, #-12]
   17b44:	e1a03083 	lsl	r3, r3, #1
   17b48:	e1a02103 	lsl	r2, r3, #2
   17b4c:	e59f3a70 	ldr	r3, [pc, #2672]	; 185c4 <_malloc_r+0xb10>
   17b50:	e0823003 	add	r3, r2, r3
   17b54:	e50b3028 	str	r3, [fp, #-40]	; 0x28
    victim = last(q);
   17b58:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   17b5c:	e593300c 	ldr	r3, [r3, #12]
   17b60:	e50b3008 	str	r3, [fp, #-8]

#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
   17b64:	e51b2008 	ldr	r2, [fp, #-8]
   17b68:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   17b6c:	e1520003 	cmp	r2, r3
   17b70:	1a000005 	bne	17b8c <_malloc_r+0xd8>
    {
      q = next_bin(q);
   17b74:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   17b78:	e2833008 	add	r3, r3, #8
   17b7c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      victim = last(q);
   17b80:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   17b84:	e593300c 	ldr	r3, [r3, #12]
   17b88:	e50b3008 	str	r3, [fp, #-8]
    }
#endif
    if (victim != q)
   17b8c:	e51b2008 	ldr	r2, [fp, #-8]
   17b90:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   17b94:	e1520003 	cmp	r2, r3
   17b98:	0a00001d 	beq	17c14 <_malloc_r+0x160>
    {
      victim_size = chunksize(victim);
   17b9c:	e51b3008 	ldr	r3, [fp, #-8]
   17ba0:	e5933004 	ldr	r3, [r3, #4]
   17ba4:	e3c33003 	bic	r3, r3, #3
   17ba8:	e50b3030 	str	r3, [fp, #-48]	; 0x30
      unlink(victim, bck, fwd);
   17bac:	e51b3008 	ldr	r3, [fp, #-8]
   17bb0:	e593300c 	ldr	r3, [r3, #12]
   17bb4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   17bb8:	e51b3008 	ldr	r3, [fp, #-8]
   17bbc:	e5933008 	ldr	r3, [r3, #8]
   17bc0:	e50b3020 	str	r3, [fp, #-32]
   17bc4:	e51b3020 	ldr	r3, [fp, #-32]
   17bc8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   17bcc:	e583200c 	str	r2, [r3, #12]
   17bd0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17bd4:	e51b2020 	ldr	r2, [fp, #-32]
   17bd8:	e5832008 	str	r2, [r3, #8]
      set_inuse_bit_at_offset(victim, victim_size);
   17bdc:	e51b2008 	ldr	r2, [fp, #-8]
   17be0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   17be4:	e0823003 	add	r3, r2, r3
   17be8:	e51b1008 	ldr	r1, [fp, #-8]
   17bec:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   17bf0:	e0812002 	add	r2, r1, r2
   17bf4:	e5922004 	ldr	r2, [r2, #4]
   17bf8:	e3822001 	orr	r2, r2, #1
   17bfc:	e5832004 	str	r2, [r3, #4]
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   17c00:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   17c04:	eb00035b 	bl	18978 <__malloc_unlock>
      return chunk2mem(victim);
   17c08:	e51b3008 	ldr	r3, [fp, #-8]
   17c0c:	e2833008 	add	r3, r3, #8
   17c10:	ea000267 	b	185b4 <_malloc_r+0xb00>
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
   17c14:	e51b300c 	ldr	r3, [fp, #-12]
   17c18:	e2833002 	add	r3, r3, #2
   17c1c:	e50b300c 	str	r3, [fp, #-12]
   17c20:	ea000071 	b	17dec <_malloc_r+0x338>

  }
  else
  {
    idx = bin_index(nb);
   17c24:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17c28:	e1a034a3 	lsr	r3, r3, #9
   17c2c:	e3530000 	cmp	r3, #0
   17c30:	1a000002 	bne	17c40 <_malloc_r+0x18c>
   17c34:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17c38:	e1a031a3 	lsr	r3, r3, #3
   17c3c:	ea000029 	b	17ce8 <_malloc_r+0x234>
   17c40:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17c44:	e1a034a3 	lsr	r3, r3, #9
   17c48:	e3530004 	cmp	r3, #4
   17c4c:	8a000003 	bhi	17c60 <_malloc_r+0x1ac>
   17c50:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17c54:	e1a03323 	lsr	r3, r3, #6
   17c58:	e2833038 	add	r3, r3, #56	; 0x38
   17c5c:	ea000021 	b	17ce8 <_malloc_r+0x234>
   17c60:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17c64:	e1a034a3 	lsr	r3, r3, #9
   17c68:	e3530014 	cmp	r3, #20
   17c6c:	8a000003 	bhi	17c80 <_malloc_r+0x1cc>
   17c70:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17c74:	e1a034a3 	lsr	r3, r3, #9
   17c78:	e283305b 	add	r3, r3, #91	; 0x5b
   17c7c:	ea000019 	b	17ce8 <_malloc_r+0x234>
   17c80:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17c84:	e1a034a3 	lsr	r3, r3, #9
   17c88:	e3530054 	cmp	r3, #84	; 0x54
   17c8c:	8a000003 	bhi	17ca0 <_malloc_r+0x1ec>
   17c90:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17c94:	e1a03623 	lsr	r3, r3, #12
   17c98:	e283306e 	add	r3, r3, #110	; 0x6e
   17c9c:	ea000011 	b	17ce8 <_malloc_r+0x234>
   17ca0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17ca4:	e1a034a3 	lsr	r3, r3, #9
   17ca8:	e3530f55 	cmp	r3, #340	; 0x154
   17cac:	8a000003 	bhi	17cc0 <_malloc_r+0x20c>
   17cb0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17cb4:	e1a037a3 	lsr	r3, r3, #15
   17cb8:	e2833077 	add	r3, r3, #119	; 0x77
   17cbc:	ea000009 	b	17ce8 <_malloc_r+0x234>
   17cc0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17cc4:	e1a024a3 	lsr	r2, r3, #9
   17cc8:	e59f38f8 	ldr	r3, [pc, #2296]	; 185c8 <_malloc_r+0xb14>
   17ccc:	e1520003 	cmp	r2, r3
   17cd0:	8a000003 	bhi	17ce4 <_malloc_r+0x230>
   17cd4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17cd8:	e1a03923 	lsr	r3, r3, #18
   17cdc:	e283307c 	add	r3, r3, #124	; 0x7c
   17ce0:	ea000000 	b	17ce8 <_malloc_r+0x234>
   17ce4:	e3a0307e 	mov	r3, #126	; 0x7e
   17ce8:	e50b300c 	str	r3, [fp, #-12]
    bin = bin_at(idx);
   17cec:	e51b300c 	ldr	r3, [fp, #-12]
   17cf0:	e1a03083 	lsl	r3, r3, #1
   17cf4:	e1a02103 	lsl	r2, r3, #2
   17cf8:	e59f38c4 	ldr	r3, [pc, #2244]	; 185c4 <_malloc_r+0xb10>
   17cfc:	e0823003 	add	r3, r2, r3
   17d00:	e50b3010 	str	r3, [fp, #-16]

    for (victim = last(bin); victim != bin; victim = victim->bk)
   17d04:	e51b3010 	ldr	r3, [fp, #-16]
   17d08:	e593300c 	ldr	r3, [r3, #12]
   17d0c:	e50b3008 	str	r3, [fp, #-8]
   17d10:	ea00002e 	b	17dd0 <_malloc_r+0x31c>
    {
      victim_size = chunksize(victim);
   17d14:	e51b3008 	ldr	r3, [fp, #-8]
   17d18:	e5933004 	ldr	r3, [r3, #4]
   17d1c:	e3c33003 	bic	r3, r3, #3
   17d20:	e50b3030 	str	r3, [fp, #-48]	; 0x30
      remainder_size = long_sub_size_t(victim_size, nb);
   17d24:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   17d28:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17d2c:	e0633002 	rsb	r3, r3, r2
   17d30:	e50b3014 	str	r3, [fp, #-20]
      
      if (remainder_size >= (long)MINSIZE) /* too big */
   17d34:	e51b3014 	ldr	r3, [fp, #-20]
   17d38:	e353000f 	cmp	r3, #15
   17d3c:	da000003 	ble	17d50 <_malloc_r+0x29c>
      {
        --idx; /* adjust to rescan below after checking last remainder */
   17d40:	e51b300c 	ldr	r3, [fp, #-12]
   17d44:	e2433001 	sub	r3, r3, #1
   17d48:	e50b300c 	str	r3, [fp, #-12]
        break;   
   17d4c:	ea000023 	b	17de0 <_malloc_r+0x32c>
      }

      else if (remainder_size >= 0) /* exact fit */
   17d50:	e51b3014 	ldr	r3, [fp, #-20]
   17d54:	e3530000 	cmp	r3, #0
   17d58:	ba000019 	blt	17dc4 <_malloc_r+0x310>
      {
        unlink(victim, bck, fwd);
   17d5c:	e51b3008 	ldr	r3, [fp, #-8]
   17d60:	e593300c 	ldr	r3, [r3, #12]
   17d64:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   17d68:	e51b3008 	ldr	r3, [fp, #-8]
   17d6c:	e5933008 	ldr	r3, [r3, #8]
   17d70:	e50b3020 	str	r3, [fp, #-32]
   17d74:	e51b3020 	ldr	r3, [fp, #-32]
   17d78:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   17d7c:	e583200c 	str	r2, [r3, #12]
   17d80:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17d84:	e51b2020 	ldr	r2, [fp, #-32]
   17d88:	e5832008 	str	r2, [r3, #8]
        set_inuse_bit_at_offset(victim, victim_size);
   17d8c:	e51b2008 	ldr	r2, [fp, #-8]
   17d90:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   17d94:	e0823003 	add	r3, r2, r3
   17d98:	e51b1008 	ldr	r1, [fp, #-8]
   17d9c:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   17da0:	e0812002 	add	r2, r1, r2
   17da4:	e5922004 	ldr	r2, [r2, #4]
   17da8:	e3822001 	orr	r2, r2, #1
   17dac:	e5832004 	str	r2, [r3, #4]
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
   17db0:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   17db4:	eb0002ef 	bl	18978 <__malloc_unlock>
        return chunk2mem(victim);
   17db8:	e51b3008 	ldr	r3, [fp, #-8]
   17dbc:	e2833008 	add	r3, r3, #8
   17dc0:	ea0001fb 	b	185b4 <_malloc_r+0xb00>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
   17dc4:	e51b3008 	ldr	r3, [fp, #-8]
   17dc8:	e593300c 	ldr	r3, [r3, #12]
   17dcc:	e50b3008 	str	r3, [fp, #-8]
   17dd0:	e51b2008 	ldr	r2, [fp, #-8]
   17dd4:	e51b3010 	ldr	r3, [fp, #-16]
   17dd8:	e1520003 	cmp	r2, r3
   17ddc:	1affffcc 	bne	17d14 <_malloc_r+0x260>
	MALLOC_UNLOCK;
        return chunk2mem(victim);
      }
    }

    ++idx; 
   17de0:	e51b300c 	ldr	r3, [fp, #-12]
   17de4:	e2833001 	add	r3, r3, #1
   17de8:	e50b300c 	str	r3, [fp, #-12]

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
   17dec:	e59f37d8 	ldr	r3, [pc, #2008]	; 185cc <_malloc_r+0xb18>
   17df0:	e5933008 	ldr	r3, [r3, #8]
   17df4:	e50b3008 	str	r3, [fp, #-8]
   17df8:	e51b2008 	ldr	r2, [fp, #-8]
   17dfc:	e59f37c8 	ldr	r3, [pc, #1992]	; 185cc <_malloc_r+0xb18>
   17e00:	e1520003 	cmp	r2, r3
   17e04:	0a0000da 	beq	18174 <_malloc_r+0x6c0>
  {
    victim_size = chunksize(victim);
   17e08:	e51b3008 	ldr	r3, [fp, #-8]
   17e0c:	e5933004 	ldr	r3, [r3, #4]
   17e10:	e3c33003 	bic	r3, r3, #3
   17e14:	e50b3030 	str	r3, [fp, #-48]	; 0x30
    remainder_size = long_sub_size_t(victim_size, nb);
   17e18:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   17e1c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17e20:	e0633002 	rsb	r3, r3, r2
   17e24:	e50b3014 	str	r3, [fp, #-20]

    if (remainder_size >= (long)MINSIZE) /* re-split */
   17e28:	e51b3014 	ldr	r3, [fp, #-20]
   17e2c:	e353000f 	cmp	r3, #15
   17e30:	da000023 	ble	17ec4 <_malloc_r+0x410>
    {
      remainder = chunk_at_offset(victim, nb);
   17e34:	e51b2008 	ldr	r2, [fp, #-8]
   17e38:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17e3c:	e0823003 	add	r3, r2, r3
   17e40:	e50b3034 	str	r3, [fp, #-52]	; 0x34
      set_head(victim, nb | PREV_INUSE);
   17e44:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17e48:	e3832001 	orr	r2, r3, #1
   17e4c:	e51b3008 	ldr	r3, [fp, #-8]
   17e50:	e5832004 	str	r2, [r3, #4]
      link_last_remainder(remainder);
   17e54:	e59f2770 	ldr	r2, [pc, #1904]	; 185cc <_malloc_r+0xb18>
   17e58:	e59f376c 	ldr	r3, [pc, #1900]	; 185cc <_malloc_r+0xb18>
   17e5c:	e51b1034 	ldr	r1, [fp, #-52]	; 0x34
   17e60:	e583100c 	str	r1, [r3, #12]
   17e64:	e593300c 	ldr	r3, [r3, #12]
   17e68:	e5823008 	str	r3, [r2, #8]
   17e6c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   17e70:	e59f2754 	ldr	r2, [pc, #1876]	; 185cc <_malloc_r+0xb18>
   17e74:	e583200c 	str	r2, [r3, #12]
   17e78:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   17e7c:	e593200c 	ldr	r2, [r3, #12]
   17e80:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   17e84:	e5832008 	str	r2, [r3, #8]
      set_head(remainder, remainder_size | PREV_INUSE);
   17e88:	e51b3014 	ldr	r3, [fp, #-20]
   17e8c:	e3833001 	orr	r3, r3, #1
   17e90:	e1a02003 	mov	r2, r3
   17e94:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   17e98:	e5832004 	str	r2, [r3, #4]
      set_foot(remainder, remainder_size);
   17e9c:	e51b3014 	ldr	r3, [fp, #-20]
   17ea0:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   17ea4:	e0823003 	add	r3, r2, r3
   17ea8:	e51b2014 	ldr	r2, [fp, #-20]
   17eac:	e5832000 	str	r2, [r3]
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   17eb0:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   17eb4:	eb0002af 	bl	18978 <__malloc_unlock>
      return chunk2mem(victim);
   17eb8:	e51b3008 	ldr	r3, [fp, #-8]
   17ebc:	e2833008 	add	r3, r3, #8
   17ec0:	ea0001bb 	b	185b4 <_malloc_r+0xb00>
    }

    clear_last_remainder;
   17ec4:	e59f2700 	ldr	r2, [pc, #1792]	; 185cc <_malloc_r+0xb18>
   17ec8:	e59f36fc 	ldr	r3, [pc, #1788]	; 185cc <_malloc_r+0xb18>
   17ecc:	e59f16f8 	ldr	r1, [pc, #1784]	; 185cc <_malloc_r+0xb18>
   17ed0:	e583100c 	str	r1, [r3, #12]
   17ed4:	e593300c 	ldr	r3, [r3, #12]
   17ed8:	e5823008 	str	r3, [r2, #8]

    if (remainder_size >= 0)  /* exhaust */
   17edc:	e51b3014 	ldr	r3, [fp, #-20]
   17ee0:	e3530000 	cmp	r3, #0
   17ee4:	ba00000d 	blt	17f20 <_malloc_r+0x46c>
    {
      set_inuse_bit_at_offset(victim, victim_size);
   17ee8:	e51b2008 	ldr	r2, [fp, #-8]
   17eec:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   17ef0:	e0823003 	add	r3, r2, r3
   17ef4:	e51b1008 	ldr	r1, [fp, #-8]
   17ef8:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   17efc:	e0812002 	add	r2, r1, r2
   17f00:	e5922004 	ldr	r2, [r2, #4]
   17f04:	e3822001 	orr	r2, r2, #1
   17f08:	e5832004 	str	r2, [r3, #4]
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
   17f0c:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   17f10:	eb000298 	bl	18978 <__malloc_unlock>
      return chunk2mem(victim);
   17f14:	e51b3008 	ldr	r3, [fp, #-8]
   17f18:	e2833008 	add	r3, r3, #8
   17f1c:	ea0001a4 	b	185b4 <_malloc_r+0xb00>
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
   17f20:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   17f24:	e3530c02 	cmp	r3, #512	; 0x200
   17f28:	2a000026 	bcs	17fc8 <_malloc_r+0x514>
   17f2c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   17f30:	e1a031a3 	lsr	r3, r3, #3
   17f34:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   17f38:	e59f2684 	ldr	r2, [pc, #1668]	; 185c4 <_malloc_r+0xb10>
   17f3c:	e59f3680 	ldr	r3, [pc, #1664]	; 185c4 <_malloc_r+0xb10>
   17f40:	e5931004 	ldr	r1, [r3, #4]
   17f44:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   17f48:	e2830003 	add	r0, r3, #3
   17f4c:	e3530000 	cmp	r3, #0
   17f50:	b1a03000 	movlt	r3, r0
   17f54:	a1a03003 	movge	r3, r3
   17f58:	e1a03143 	asr	r3, r3, #2
   17f5c:	e3a00001 	mov	r0, #1
   17f60:	e1a03310 	lsl	r3, r0, r3
   17f64:	e1813003 	orr	r3, r1, r3
   17f68:	e5823004 	str	r3, [r2, #4]
   17f6c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   17f70:	e1a03083 	lsl	r3, r3, #1
   17f74:	e1a02103 	lsl	r2, r3, #2
   17f78:	e59f3644 	ldr	r3, [pc, #1604]	; 185c4 <_malloc_r+0xb10>
   17f7c:	e0823003 	add	r3, r2, r3
   17f80:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   17f84:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17f88:	e5933008 	ldr	r3, [r3, #8]
   17f8c:	e50b3020 	str	r3, [fp, #-32]
   17f90:	e51b3008 	ldr	r3, [fp, #-8]
   17f94:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   17f98:	e583200c 	str	r2, [r3, #12]
   17f9c:	e51b3008 	ldr	r3, [fp, #-8]
   17fa0:	e51b2020 	ldr	r2, [fp, #-32]
   17fa4:	e5832008 	str	r2, [r3, #8]
   17fa8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17fac:	e51b2008 	ldr	r2, [fp, #-8]
   17fb0:	e5832008 	str	r2, [r3, #8]
   17fb4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17fb8:	e5932008 	ldr	r2, [r3, #8]
   17fbc:	e51b3020 	ldr	r3, [fp, #-32]
   17fc0:	e583200c 	str	r2, [r3, #12]
   17fc4:	ea00006a 	b	18174 <_malloc_r+0x6c0>
   17fc8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   17fcc:	e1a034a3 	lsr	r3, r3, #9
   17fd0:	e3530000 	cmp	r3, #0
   17fd4:	1a000002 	bne	17fe4 <_malloc_r+0x530>
   17fd8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   17fdc:	e1a031a3 	lsr	r3, r3, #3
   17fe0:	ea000029 	b	1808c <_malloc_r+0x5d8>
   17fe4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   17fe8:	e1a034a3 	lsr	r3, r3, #9
   17fec:	e3530004 	cmp	r3, #4
   17ff0:	8a000003 	bhi	18004 <_malloc_r+0x550>
   17ff4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   17ff8:	e1a03323 	lsr	r3, r3, #6
   17ffc:	e2833038 	add	r3, r3, #56	; 0x38
   18000:	ea000021 	b	1808c <_malloc_r+0x5d8>
   18004:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   18008:	e1a034a3 	lsr	r3, r3, #9
   1800c:	e3530014 	cmp	r3, #20
   18010:	8a000003 	bhi	18024 <_malloc_r+0x570>
   18014:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   18018:	e1a034a3 	lsr	r3, r3, #9
   1801c:	e283305b 	add	r3, r3, #91	; 0x5b
   18020:	ea000019 	b	1808c <_malloc_r+0x5d8>
   18024:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   18028:	e1a034a3 	lsr	r3, r3, #9
   1802c:	e3530054 	cmp	r3, #84	; 0x54
   18030:	8a000003 	bhi	18044 <_malloc_r+0x590>
   18034:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   18038:	e1a03623 	lsr	r3, r3, #12
   1803c:	e283306e 	add	r3, r3, #110	; 0x6e
   18040:	ea000011 	b	1808c <_malloc_r+0x5d8>
   18044:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   18048:	e1a034a3 	lsr	r3, r3, #9
   1804c:	e3530f55 	cmp	r3, #340	; 0x154
   18050:	8a000003 	bhi	18064 <_malloc_r+0x5b0>
   18054:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   18058:	e1a037a3 	lsr	r3, r3, #15
   1805c:	e2833077 	add	r3, r3, #119	; 0x77
   18060:	ea000009 	b	1808c <_malloc_r+0x5d8>
   18064:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   18068:	e1a024a3 	lsr	r2, r3, #9
   1806c:	e59f3554 	ldr	r3, [pc, #1364]	; 185c8 <_malloc_r+0xb14>
   18070:	e1520003 	cmp	r2, r3
   18074:	8a000003 	bhi	18088 <_malloc_r+0x5d4>
   18078:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1807c:	e1a03923 	lsr	r3, r3, #18
   18080:	e283307c 	add	r3, r3, #124	; 0x7c
   18084:	ea000000 	b	1808c <_malloc_r+0x5d8>
   18088:	e3a0307e 	mov	r3, #126	; 0x7e
   1808c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   18090:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   18094:	e1a03083 	lsl	r3, r3, #1
   18098:	e1a02103 	lsl	r2, r3, #2
   1809c:	e59f3520 	ldr	r3, [pc, #1312]	; 185c4 <_malloc_r+0xb10>
   180a0:	e0823003 	add	r3, r2, r3
   180a4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   180a8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   180ac:	e5933008 	ldr	r3, [r3, #8]
   180b0:	e50b3020 	str	r3, [fp, #-32]
   180b4:	e51b2020 	ldr	r2, [fp, #-32]
   180b8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   180bc:	e1520003 	cmp	r2, r3
   180c0:	1a00000d 	bne	180fc <_malloc_r+0x648>
   180c4:	e59f24f8 	ldr	r2, [pc, #1272]	; 185c4 <_malloc_r+0xb10>
   180c8:	e59f34f4 	ldr	r3, [pc, #1268]	; 185c4 <_malloc_r+0xb10>
   180cc:	e5931004 	ldr	r1, [r3, #4]
   180d0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   180d4:	e2830003 	add	r0, r3, #3
   180d8:	e3530000 	cmp	r3, #0
   180dc:	b1a03000 	movlt	r3, r0
   180e0:	a1a03003 	movge	r3, r3
   180e4:	e1a03143 	asr	r3, r3, #2
   180e8:	e3a00001 	mov	r0, #1
   180ec:	e1a03310 	lsl	r3, r0, r3
   180f0:	e1813003 	orr	r3, r1, r3
   180f4:	e5823004 	str	r3, [r2, #4]
   180f8:	ea000010 	b	18140 <_malloc_r+0x68c>
   180fc:	ea000002 	b	1810c <_malloc_r+0x658>
   18100:	e51b3020 	ldr	r3, [fp, #-32]
   18104:	e5933008 	ldr	r3, [r3, #8]
   18108:	e50b3020 	str	r3, [fp, #-32]
   1810c:	e51b2020 	ldr	r2, [fp, #-32]
   18110:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   18114:	e1520003 	cmp	r2, r3
   18118:	0a000005 	beq	18134 <_malloc_r+0x680>
   1811c:	e51b3020 	ldr	r3, [fp, #-32]
   18120:	e5933004 	ldr	r3, [r3, #4]
   18124:	e3c32003 	bic	r2, r3, #3
   18128:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1812c:	e1520003 	cmp	r2, r3
   18130:	8afffff2 	bhi	18100 <_malloc_r+0x64c>
   18134:	e51b3020 	ldr	r3, [fp, #-32]
   18138:	e593300c 	ldr	r3, [r3, #12]
   1813c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   18140:	e51b3008 	ldr	r3, [fp, #-8]
   18144:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   18148:	e583200c 	str	r2, [r3, #12]
   1814c:	e51b3008 	ldr	r3, [fp, #-8]
   18150:	e51b2020 	ldr	r2, [fp, #-32]
   18154:	e5832008 	str	r2, [r3, #8]
   18158:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1815c:	e51b2008 	ldr	r2, [fp, #-8]
   18160:	e5832008 	str	r2, [r3, #8]
   18164:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   18168:	e5932008 	ldr	r2, [r3, #8]
   1816c:	e51b3020 	ldr	r3, [fp, #-32]
   18170:	e583200c 	str	r2, [r3, #12]
  /* 
     If there are any possibly nonempty big-enough blocks, 
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks)  
   18174:	e51b300c 	ldr	r3, [fp, #-12]
   18178:	e2832003 	add	r2, r3, #3
   1817c:	e3530000 	cmp	r3, #0
   18180:	b1a03002 	movlt	r3, r2
   18184:	a1a03003 	movge	r3, r3
   18188:	e1a03143 	asr	r3, r3, #2
   1818c:	e3a02001 	mov	r2, #1
   18190:	e1a03312 	lsl	r3, r2, r3
   18194:	e50b3018 	str	r3, [fp, #-24]
   18198:	e59f3424 	ldr	r3, [pc, #1060]	; 185c4 <_malloc_r+0xb10>
   1819c:	e5933004 	ldr	r3, [r3, #4]
   181a0:	e51b2018 	ldr	r2, [fp, #-24]
   181a4:	e1520003 	cmp	r2, r3
   181a8:	8a0000c0 	bhi	184b0 <_malloc_r+0x9fc>
  {

    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
   181ac:	e59f3410 	ldr	r3, [pc, #1040]	; 185c4 <_malloc_r+0xb10>
   181b0:	e5932004 	ldr	r2, [r3, #4]
   181b4:	e51b3018 	ldr	r3, [fp, #-24]
   181b8:	e0033002 	and	r3, r3, r2
   181bc:	e3530000 	cmp	r3, #0
   181c0:	1a000013 	bne	18214 <_malloc_r+0x760>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
   181c4:	e51b300c 	ldr	r3, [fp, #-12]
   181c8:	e3c33003 	bic	r3, r3, #3
   181cc:	e2833004 	add	r3, r3, #4
   181d0:	e50b300c 	str	r3, [fp, #-12]
      block <<= 1;
   181d4:	e51b3018 	ldr	r3, [fp, #-24]
   181d8:	e1a03083 	lsl	r3, r3, #1
   181dc:	e50b3018 	str	r3, [fp, #-24]
      while ((block & binblocks) == 0)
   181e0:	ea000005 	b	181fc <_malloc_r+0x748>
      {
        idx += BINBLOCKWIDTH;
   181e4:	e51b300c 	ldr	r3, [fp, #-12]
   181e8:	e2833004 	add	r3, r3, #4
   181ec:	e50b300c 	str	r3, [fp, #-12]
        block <<= 1;
   181f0:	e51b3018 	ldr	r3, [fp, #-24]
   181f4:	e1a03083 	lsl	r3, r3, #1
   181f8:	e50b3018 	str	r3, [fp, #-24]
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
   181fc:	e59f33c0 	ldr	r3, [pc, #960]	; 185c4 <_malloc_r+0xb10>
   18200:	e5932004 	ldr	r2, [r3, #4]
   18204:	e51b3018 	ldr	r3, [fp, #-24]
   18208:	e0033002 	and	r3, r3, r2
   1820c:	e3530000 	cmp	r3, #0
   18210:	0afffff3 	beq	181e4 <_malloc_r+0x730>
    }
      
    /* For each possibly nonempty block ... */
    for (;;)  
    {
      startidx = idx;          /* (track incomplete blocks) */
   18214:	e51b300c 	ldr	r3, [fp, #-12]
   18218:	e50b301c 	str	r3, [fp, #-28]
      q = bin = bin_at(idx);
   1821c:	e51b300c 	ldr	r3, [fp, #-12]
   18220:	e1a03083 	lsl	r3, r3, #1
   18224:	e1a02103 	lsl	r2, r3, #2
   18228:	e59f3394 	ldr	r3, [pc, #916]	; 185c4 <_malloc_r+0xb10>
   1822c:	e0823003 	add	r3, r2, r3
   18230:	e50b3010 	str	r3, [fp, #-16]
   18234:	e51b3010 	ldr	r3, [fp, #-16]
   18238:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
   1823c:	e51b3010 	ldr	r3, [fp, #-16]
   18240:	e593300c 	ldr	r3, [r3, #12]
   18244:	e50b3008 	str	r3, [fp, #-8]
   18248:	ea00005a 	b	183b8 <_malloc_r+0x904>
        {
          victim_size = chunksize(victim);
   1824c:	e51b3008 	ldr	r3, [fp, #-8]
   18250:	e5933004 	ldr	r3, [r3, #4]
   18254:	e3c33003 	bic	r3, r3, #3
   18258:	e50b3030 	str	r3, [fp, #-48]	; 0x30
          remainder_size = long_sub_size_t(victim_size, nb);
   1825c:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   18260:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   18264:	e0633002 	rsb	r3, r3, r2
   18268:	e50b3014 	str	r3, [fp, #-20]

          if (remainder_size >= (long)MINSIZE) /* split */
   1826c:	e51b3014 	ldr	r3, [fp, #-20]
   18270:	e353000f 	cmp	r3, #15
   18274:	da00002f 	ble	18338 <_malloc_r+0x884>
          {
            remainder = chunk_at_offset(victim, nb);
   18278:	e51b2008 	ldr	r2, [fp, #-8]
   1827c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   18280:	e0823003 	add	r3, r2, r3
   18284:	e50b3034 	str	r3, [fp, #-52]	; 0x34
            set_head(victim, nb | PREV_INUSE);
   18288:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1828c:	e3832001 	orr	r2, r3, #1
   18290:	e51b3008 	ldr	r3, [fp, #-8]
   18294:	e5832004 	str	r2, [r3, #4]
            unlink(victim, bck, fwd);
   18298:	e51b3008 	ldr	r3, [fp, #-8]
   1829c:	e593300c 	ldr	r3, [r3, #12]
   182a0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   182a4:	e51b3008 	ldr	r3, [fp, #-8]
   182a8:	e5933008 	ldr	r3, [r3, #8]
   182ac:	e50b3020 	str	r3, [fp, #-32]
   182b0:	e51b3020 	ldr	r3, [fp, #-32]
   182b4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   182b8:	e583200c 	str	r2, [r3, #12]
   182bc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   182c0:	e51b2020 	ldr	r2, [fp, #-32]
   182c4:	e5832008 	str	r2, [r3, #8]
            link_last_remainder(remainder);
   182c8:	e59f22fc 	ldr	r2, [pc, #764]	; 185cc <_malloc_r+0xb18>
   182cc:	e59f32f8 	ldr	r3, [pc, #760]	; 185cc <_malloc_r+0xb18>
   182d0:	e51b1034 	ldr	r1, [fp, #-52]	; 0x34
   182d4:	e583100c 	str	r1, [r3, #12]
   182d8:	e593300c 	ldr	r3, [r3, #12]
   182dc:	e5823008 	str	r3, [r2, #8]
   182e0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   182e4:	e59f22e0 	ldr	r2, [pc, #736]	; 185cc <_malloc_r+0xb18>
   182e8:	e583200c 	str	r2, [r3, #12]
   182ec:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   182f0:	e593200c 	ldr	r2, [r3, #12]
   182f4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   182f8:	e5832008 	str	r2, [r3, #8]
            set_head(remainder, remainder_size | PREV_INUSE);
   182fc:	e51b3014 	ldr	r3, [fp, #-20]
   18300:	e3833001 	orr	r3, r3, #1
   18304:	e1a02003 	mov	r2, r3
   18308:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1830c:	e5832004 	str	r2, [r3, #4]
            set_foot(remainder, remainder_size);
   18310:	e51b3014 	ldr	r3, [fp, #-20]
   18314:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   18318:	e0823003 	add	r3, r2, r3
   1831c:	e51b2014 	ldr	r2, [fp, #-20]
   18320:	e5832000 	str	r2, [r3]
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   18324:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   18328:	eb000192 	bl	18978 <__malloc_unlock>
            return chunk2mem(victim);
   1832c:	e51b3008 	ldr	r3, [fp, #-8]
   18330:	e2833008 	add	r3, r3, #8
   18334:	ea00009e 	b	185b4 <_malloc_r+0xb00>
          }

          else if (remainder_size >= 0)  /* take */
   18338:	e51b3014 	ldr	r3, [fp, #-20]
   1833c:	e3530000 	cmp	r3, #0
   18340:	ba000019 	blt	183ac <_malloc_r+0x8f8>
          {
            set_inuse_bit_at_offset(victim, victim_size);
   18344:	e51b2008 	ldr	r2, [fp, #-8]
   18348:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1834c:	e0823003 	add	r3, r2, r3
   18350:	e51b1008 	ldr	r1, [fp, #-8]
   18354:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   18358:	e0812002 	add	r2, r1, r2
   1835c:	e5922004 	ldr	r2, [r2, #4]
   18360:	e3822001 	orr	r2, r2, #1
   18364:	e5832004 	str	r2, [r3, #4]
            unlink(victim, bck, fwd);
   18368:	e51b3008 	ldr	r3, [fp, #-8]
   1836c:	e593300c 	ldr	r3, [r3, #12]
   18370:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   18374:	e51b3008 	ldr	r3, [fp, #-8]
   18378:	e5933008 	ldr	r3, [r3, #8]
   1837c:	e50b3020 	str	r3, [fp, #-32]
   18380:	e51b3020 	ldr	r3, [fp, #-32]
   18384:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   18388:	e583200c 	str	r2, [r3, #12]
   1838c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   18390:	e51b2020 	ldr	r2, [fp, #-32]
   18394:	e5832008 	str	r2, [r3, #8]
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
   18398:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   1839c:	eb000175 	bl	18978 <__malloc_unlock>
            return chunk2mem(victim);
   183a0:	e51b3008 	ldr	r3, [fp, #-8]
   183a4:	e2833008 	add	r3, r3, #8
   183a8:	ea000081 	b	185b4 <_malloc_r+0xb00>
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
   183ac:	e51b3008 	ldr	r3, [fp, #-8]
   183b0:	e593300c 	ldr	r3, [r3, #12]
   183b4:	e50b3008 	str	r3, [fp, #-8]
   183b8:	e51b2008 	ldr	r2, [fp, #-8]
   183bc:	e51b3010 	ldr	r3, [fp, #-16]
   183c0:	e1520003 	cmp	r2, r3
   183c4:	1affffa0 	bne	1824c <_malloc_r+0x798>
            return chunk2mem(victim);
          }

        }

       bin = next_bin(bin);
   183c8:	e51b3010 	ldr	r3, [fp, #-16]
   183cc:	e2833008 	add	r3, r3, #8
   183d0:	e50b3010 	str	r3, [fp, #-16]
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
   183d4:	e51b300c 	ldr	r3, [fp, #-12]
   183d8:	e2833001 	add	r3, r3, #1
   183dc:	e50b300c 	str	r3, [fp, #-12]
   183e0:	e51b300c 	ldr	r3, [fp, #-12]
   183e4:	e2033003 	and	r3, r3, #3
   183e8:	e3530000 	cmp	r3, #0
   183ec:	1affff92 	bne	1823c <_malloc_r+0x788>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
   183f0:	e51b301c 	ldr	r3, [fp, #-28]
   183f4:	e2033003 	and	r3, r3, #3
   183f8:	e3530000 	cmp	r3, #0
   183fc:	1a000007 	bne	18420 <_malloc_r+0x96c>
        {
          binblocks &= ~block;
   18400:	e59f31bc 	ldr	r3, [pc, #444]	; 185c4 <_malloc_r+0xb10>
   18404:	e59f21b8 	ldr	r2, [pc, #440]	; 185c4 <_malloc_r+0xb10>
   18408:	e5921004 	ldr	r1, [r2, #4]
   1840c:	e51b2018 	ldr	r2, [fp, #-24]
   18410:	e1e02002 	mvn	r2, r2
   18414:	e0022001 	and	r2, r2, r1
   18418:	e5832004 	str	r2, [r3, #4]
          break;
   1841c:	ea00000a 	b	1844c <_malloc_r+0x998>
        }
        --startidx;
   18420:	e51b301c 	ldr	r3, [fp, #-28]
   18424:	e2433001 	sub	r3, r3, #1
   18428:	e50b301c 	str	r3, [fp, #-28]
       q = prev_bin(q);
   1842c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   18430:	e2433008 	sub	r3, r3, #8
   18434:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      } while (first(q) == q);
   18438:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1843c:	e5932008 	ldr	r2, [r3, #8]
   18440:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   18444:	e1520003 	cmp	r2, r3
   18448:	0affffe8 	beq	183f0 <_malloc_r+0x93c>

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
   1844c:	e51b3018 	ldr	r3, [fp, #-24]
   18450:	e1a03083 	lsl	r3, r3, #1
   18454:	e50b3018 	str	r3, [fp, #-24]
   18458:	e59f3164 	ldr	r3, [pc, #356]	; 185c4 <_malloc_r+0xb10>
   1845c:	e5933004 	ldr	r3, [r3, #4]
   18460:	e51b2018 	ldr	r2, [fp, #-24]
   18464:	e1520003 	cmp	r2, r3
   18468:	8a000010 	bhi	184b0 <_malloc_r+0x9fc>
   1846c:	e51b3018 	ldr	r3, [fp, #-24]
   18470:	e3530000 	cmp	r3, #0
   18474:	0a00000d 	beq	184b0 <_malloc_r+0x9fc>
      {
        while ((block & binblocks) == 0)
   18478:	ea000005 	b	18494 <_malloc_r+0x9e0>
        {
          idx += BINBLOCKWIDTH;
   1847c:	e51b300c 	ldr	r3, [fp, #-12]
   18480:	e2833004 	add	r3, r3, #4
   18484:	e50b300c 	str	r3, [fp, #-12]
          block <<= 1;
   18488:	e51b3018 	ldr	r3, [fp, #-24]
   1848c:	e1a03083 	lsl	r3, r3, #1
   18490:	e50b3018 	str	r3, [fp, #-24]

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
   18494:	e59f3128 	ldr	r3, [pc, #296]	; 185c4 <_malloc_r+0xb10>
   18498:	e5932004 	ldr	r2, [r3, #4]
   1849c:	e51b3018 	ldr	r3, [fp, #-24]
   184a0:	e0033002 	and	r3, r3, r2
   184a4:	e3530000 	cmp	r3, #0
   184a8:	0afffff3 	beq	1847c <_malloc_r+0x9c8>
          block <<= 1;
        }
      }
      else
        break;
    }
   184ac:	eaffff58 	b	18214 <_malloc_r+0x760>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  cpu_dcache_invalidate((void*)&top,sizeof(uint32_t*)); 
   184b0:	e59f0114 	ldr	r0, [pc, #276]	; 185cc <_malloc_r+0xb18>
   184b4:	e3a01004 	mov	r1, #4
   184b8:	ebffe060 	bl	10640 <cpu_dcache_invalidate>
  remainder_size = long_sub_size_t(chunksize(top), nb);
   184bc:	e59f3100 	ldr	r3, [pc, #256]	; 185c4 <_malloc_r+0xb10>
   184c0:	e5933008 	ldr	r3, [r3, #8]
   184c4:	e5933004 	ldr	r3, [r3, #4]
   184c8:	e3c32003 	bic	r2, r3, #3
   184cc:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   184d0:	e0633002 	rsb	r3, r3, r2
   184d4:	e50b3014 	str	r3, [fp, #-20]
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   184d8:	e59f30e4 	ldr	r3, [pc, #228]	; 185c4 <_malloc_r+0xb10>
   184dc:	e5933008 	ldr	r3, [r3, #8]
   184e0:	e5933004 	ldr	r3, [r3, #4]
   184e4:	e3c32003 	bic	r2, r3, #3
   184e8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   184ec:	e1520003 	cmp	r2, r3
   184f0:	3a000002 	bcc	18500 <_malloc_r+0xa4c>
   184f4:	e51b3014 	ldr	r3, [fp, #-20]
   184f8:	e353000f 	cmp	r3, #15
   184fc:	ca000017 	bgt	18560 <_malloc_r+0xaac>
      return chunk2mem(victim);
    }
#endif

    /* Try to extend */
    malloc_extend_top(RCALL nb);
   18500:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   18504:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
   18508:	ebfffc79 	bl	176f4 <malloc_extend_top>
    remainder_size = long_sub_size_t(chunksize(top), nb);
   1850c:	e59f30b0 	ldr	r3, [pc, #176]	; 185c4 <_malloc_r+0xb10>
   18510:	e5933008 	ldr	r3, [r3, #8]
   18514:	e5933004 	ldr	r3, [r3, #4]
   18518:	e3c32003 	bic	r2, r3, #3
   1851c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   18520:	e0633002 	rsb	r3, r3, r2
   18524:	e50b3014 	str	r3, [fp, #-20]
    if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
   18528:	e59f3094 	ldr	r3, [pc, #148]	; 185c4 <_malloc_r+0xb10>
   1852c:	e5933008 	ldr	r3, [r3, #8]
   18530:	e5933004 	ldr	r3, [r3, #4]
   18534:	e3c32003 	bic	r2, r3, #3
   18538:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1853c:	e1520003 	cmp	r2, r3
   18540:	3a000002 	bcc	18550 <_malloc_r+0xa9c>
   18544:	e51b3014 	ldr	r3, [fp, #-20]
   18548:	e353000f 	cmp	r3, #15
   1854c:	ca000003 	bgt	18560 <_malloc_r+0xaac>
    {
      MALLOC_UNLOCK;
   18550:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   18554:	eb000107 	bl	18978 <__malloc_unlock>
      return 0; /* propagate failure */
   18558:	e3a03000 	mov	r3, #0
   1855c:	ea000014 	b	185b4 <_malloc_r+0xb00>
    }
  }

  victim = top;
   18560:	e59f305c 	ldr	r3, [pc, #92]	; 185c4 <_malloc_r+0xb10>
   18564:	e5933008 	ldr	r3, [r3, #8]
   18568:	e50b3008 	str	r3, [fp, #-8]
  set_head(victim, nb | PREV_INUSE);
   1856c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   18570:	e3832001 	orr	r2, r3, #1
   18574:	e51b3008 	ldr	r3, [fp, #-8]
   18578:	e5832004 	str	r2, [r3, #4]
  top = chunk_at_offset(victim, nb);
   1857c:	e59f3040 	ldr	r3, [pc, #64]	; 185c4 <_malloc_r+0xb10>
   18580:	e51b1008 	ldr	r1, [fp, #-8]
   18584:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
   18588:	e0812002 	add	r2, r1, r2
   1858c:	e5832008 	str	r2, [r3, #8]
  set_head(top, remainder_size | PREV_INUSE);
   18590:	e59f302c 	ldr	r3, [pc, #44]	; 185c4 <_malloc_r+0xb10>
   18594:	e5933008 	ldr	r3, [r3, #8]
   18598:	e51b2014 	ldr	r2, [fp, #-20]
   1859c:	e3822001 	orr	r2, r2, #1
   185a0:	e5832004 	str	r2, [r3, #4]
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
   185a4:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   185a8:	eb0000f2 	bl	18978 <__malloc_unlock>
  return chunk2mem(victim);
   185ac:	e51b3008 	ldr	r3, [fp, #-8]
   185b0:	e2833008 	add	r3, r3, #8

#endif /* MALLOC_PROVIDED */
}
   185b4:	e1a00003 	mov	r0, r3
   185b8:	e24bd004 	sub	sp, fp, #4
   185bc:	e8bd4800 	pop	{fp, lr}
   185c0:	e12fff1e 	bx	lr
   185c4:	0003e468 	.word	0x0003e468
   185c8:	00000554 	.word	0x00000554
   185cc:	0003e470 	.word	0x0003e470

000185d0 <memcpy>:
_PTR
_DEFUN (memcpy, (dst0, src0, len0),
	_PTR __restrict dst0 _AND
	_CONST _PTR __restrict src0 _AND
	size_t len0)
{
   185d0:	e92d4800 	push	{fp, lr}
   185d4:	e28db004 	add	fp, sp, #4
   185d8:	e24dd020 	sub	sp, sp, #32
   185dc:	e50b0018 	str	r0, [fp, #-24]
   185e0:	e50b101c 	str	r1, [fp, #-28]
   185e4:	e50b2020 	str	r2, [fp, #-32]
      *dst++ = *src++;
    }

  return save;
#else
  char *dst = dst0;
   185e8:	e51b3018 	ldr	r3, [fp, #-24]
   185ec:	e50b3008 	str	r3, [fp, #-8]
  _CONST char *src = src0;
   185f0:	e51b301c 	ldr	r3, [fp, #-28]
   185f4:	e50b300c 	str	r3, [fp, #-12]
  long *aligned_dst;
  _CONST long *aligned_src;

  /* If the size is small, or either SRC or DST is unaligned,
     then punt into the byte copy loop.  This should be rare.  */
  if (!TOO_SMALL(len0) && !UNALIGNED (src, dst))
   185f8:	e51b3020 	ldr	r3, [fp, #-32]
   185fc:	e353000f 	cmp	r3, #15
   18600:	9a000046 	bls	18720 <memcpy+0x150>
   18604:	e51b200c 	ldr	r2, [fp, #-12]
   18608:	e51b3008 	ldr	r3, [fp, #-8]
   1860c:	e1823003 	orr	r3, r2, r3
   18610:	e2033003 	and	r3, r3, #3
   18614:	e3530000 	cmp	r3, #0
   18618:	1a000040 	bne	18720 <memcpy+0x150>
    {
      aligned_dst = (long*)dst;
   1861c:	e51b3008 	ldr	r3, [fp, #-8]
   18620:	e50b3010 	str	r3, [fp, #-16]
      aligned_src = (long*)src;
   18624:	e51b300c 	ldr	r3, [fp, #-12]
   18628:	e50b3014 	str	r3, [fp, #-20]

      /* Copy 4X long words at a time if possible.  */
      cpu_dcache_invalidate((void*)aligned_src,len0);
   1862c:	e51b0014 	ldr	r0, [fp, #-20]
   18630:	e51b1020 	ldr	r1, [fp, #-32]
   18634:	ebffe001 	bl	10640 <cpu_dcache_invalidate>
      while (len0 >= BIGBLOCKSIZE)
   18638:	ea000022 	b	186c8 <memcpy+0xf8>
        {
          *aligned_dst++ = *aligned_src++;
   1863c:	e51b3010 	ldr	r3, [fp, #-16]
   18640:	e2832004 	add	r2, r3, #4
   18644:	e50b2010 	str	r2, [fp, #-16]
   18648:	e51b2014 	ldr	r2, [fp, #-20]
   1864c:	e2821004 	add	r1, r2, #4
   18650:	e50b1014 	str	r1, [fp, #-20]
   18654:	e5922000 	ldr	r2, [r2]
   18658:	e5832000 	str	r2, [r3]
          *aligned_dst++ = *aligned_src++;
   1865c:	e51b3010 	ldr	r3, [fp, #-16]
   18660:	e2832004 	add	r2, r3, #4
   18664:	e50b2010 	str	r2, [fp, #-16]
   18668:	e51b2014 	ldr	r2, [fp, #-20]
   1866c:	e2821004 	add	r1, r2, #4
   18670:	e50b1014 	str	r1, [fp, #-20]
   18674:	e5922000 	ldr	r2, [r2]
   18678:	e5832000 	str	r2, [r3]
          *aligned_dst++ = *aligned_src++;
   1867c:	e51b3010 	ldr	r3, [fp, #-16]
   18680:	e2832004 	add	r2, r3, #4
   18684:	e50b2010 	str	r2, [fp, #-16]
   18688:	e51b2014 	ldr	r2, [fp, #-20]
   1868c:	e2821004 	add	r1, r2, #4
   18690:	e50b1014 	str	r1, [fp, #-20]
   18694:	e5922000 	ldr	r2, [r2]
   18698:	e5832000 	str	r2, [r3]
          *aligned_dst++ = *aligned_src++;
   1869c:	e51b3010 	ldr	r3, [fp, #-16]
   186a0:	e2832004 	add	r2, r3, #4
   186a4:	e50b2010 	str	r2, [fp, #-16]
   186a8:	e51b2014 	ldr	r2, [fp, #-20]
   186ac:	e2821004 	add	r1, r2, #4
   186b0:	e50b1014 	str	r1, [fp, #-20]
   186b4:	e5922000 	ldr	r2, [r2]
   186b8:	e5832000 	str	r2, [r3]
          len0 -= BIGBLOCKSIZE;
   186bc:	e51b3020 	ldr	r3, [fp, #-32]
   186c0:	e2433010 	sub	r3, r3, #16
   186c4:	e50b3020 	str	r3, [fp, #-32]
      aligned_dst = (long*)dst;
      aligned_src = (long*)src;

      /* Copy 4X long words at a time if possible.  */
      cpu_dcache_invalidate((void*)aligned_src,len0);
      while (len0 >= BIGBLOCKSIZE)
   186c8:	e51b3020 	ldr	r3, [fp, #-32]
   186cc:	e353000f 	cmp	r3, #15
   186d0:	8affffd9 	bhi	1863c <memcpy+0x6c>
          *aligned_dst++ = *aligned_src++;
          len0 -= BIGBLOCKSIZE;
        }

      /* Copy one long word at a time if possible.  */
      while (len0 >= LITTLEBLOCKSIZE)
   186d4:	ea00000a 	b	18704 <memcpy+0x134>
        {
          *aligned_dst++ = *aligned_src++;
   186d8:	e51b3010 	ldr	r3, [fp, #-16]
   186dc:	e2832004 	add	r2, r3, #4
   186e0:	e50b2010 	str	r2, [fp, #-16]
   186e4:	e51b2014 	ldr	r2, [fp, #-20]
   186e8:	e2821004 	add	r1, r2, #4
   186ec:	e50b1014 	str	r1, [fp, #-20]
   186f0:	e5922000 	ldr	r2, [r2]
   186f4:	e5832000 	str	r2, [r3]
          len0 -= LITTLEBLOCKSIZE;
   186f8:	e51b3020 	ldr	r3, [fp, #-32]
   186fc:	e2433004 	sub	r3, r3, #4
   18700:	e50b3020 	str	r3, [fp, #-32]
          *aligned_dst++ = *aligned_src++;
          len0 -= BIGBLOCKSIZE;
        }

      /* Copy one long word at a time if possible.  */
      while (len0 >= LITTLEBLOCKSIZE)
   18704:	e51b3020 	ldr	r3, [fp, #-32]
   18708:	e3530003 	cmp	r3, #3
   1870c:	8afffff1 	bhi	186d8 <memcpy+0x108>
          *aligned_dst++ = *aligned_src++;
          len0 -= LITTLEBLOCKSIZE;
        }

       /* Pick up any residual with a byte copier.  */
      dst = (char*)aligned_dst;
   18710:	e51b3010 	ldr	r3, [fp, #-16]
   18714:	e50b3008 	str	r3, [fp, #-8]
      src = (char*)aligned_src;
   18718:	e51b3014 	ldr	r3, [fp, #-20]
   1871c:	e50b300c 	str	r3, [fp, #-12]
    }
  cpu_dcache_invalidate((void*)src, sizeof(char)*len0);
   18720:	e51b000c 	ldr	r0, [fp, #-12]
   18724:	e51b1020 	ldr	r1, [fp, #-32]
   18728:	ebffdfc4 	bl	10640 <cpu_dcache_invalidate>
  while (len0--)
   1872c:	ea000007 	b	18750 <memcpy+0x180>
    *dst++ = *src++;
   18730:	e51b3008 	ldr	r3, [fp, #-8]
   18734:	e2832001 	add	r2, r3, #1
   18738:	e50b2008 	str	r2, [fp, #-8]
   1873c:	e51b200c 	ldr	r2, [fp, #-12]
   18740:	e2821001 	add	r1, r2, #1
   18744:	e50b100c 	str	r1, [fp, #-12]
   18748:	e5d22000 	ldrb	r2, [r2]
   1874c:	e5c32000 	strb	r2, [r3]
       /* Pick up any residual with a byte copier.  */
      dst = (char*)aligned_dst;
      src = (char*)aligned_src;
    }
  cpu_dcache_invalidate((void*)src, sizeof(char)*len0);
  while (len0--)
   18750:	e51b3020 	ldr	r3, [fp, #-32]
   18754:	e2432001 	sub	r2, r3, #1
   18758:	e50b2020 	str	r2, [fp, #-32]
   1875c:	e3530000 	cmp	r3, #0
   18760:	1afffff2 	bne	18730 <memcpy+0x160>
    *dst++ = *src++;

  return dst0;
   18764:	e51b3018 	ldr	r3, [fp, #-24]
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   18768:	e1a00003 	mov	r0, r3
   1876c:	e24bd004 	sub	sp, fp, #4
   18770:	e8bd4800 	pop	{fp, lr}
   18774:	e12fff1e 	bx	lr

00018778 <memset>:
_PTR
_DEFUN (memset, (m, c, n),
	_PTR m _AND
	int c _AND
	size_t n)
{
   18778:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   1877c:	e28db000 	add	fp, sp, #0
   18780:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   18784:	e50b0020 	str	r0, [fp, #-32]
   18788:	e50b1024 	str	r1, [fp, #-36]	; 0x24
   1878c:	e50b2028 	str	r2, [fp, #-40]	; 0x28
  char *s = (char *) m;
   18790:	e51b3020 	ldr	r3, [fp, #-32]
   18794:	e50b3008 	str	r3, [fp, #-8]

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  int i;
  unsigned long buffer;
  unsigned long *aligned_addr;
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
   18798:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1879c:	e20330ff 	and	r3, r3, #255	; 0xff
   187a0:	e50b3018 	str	r3, [fp, #-24]
				   unsigned variable.  */

  while (UNALIGNED (s))
   187a4:	ea00000d 	b	187e0 <memset+0x68>
    {
      if (n--)
   187a8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   187ac:	e2432001 	sub	r2, r3, #1
   187b0:	e50b2028 	str	r2, [fp, #-40]	; 0x28
   187b4:	e3530000 	cmp	r3, #0
   187b8:	0a000006 	beq	187d8 <memset+0x60>
        *s++ = (char) c;
   187bc:	e51b3008 	ldr	r3, [fp, #-8]
   187c0:	e2832001 	add	r2, r3, #1
   187c4:	e50b2008 	str	r2, [fp, #-8]
   187c8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   187cc:	e20220ff 	and	r2, r2, #255	; 0xff
   187d0:	e5c32000 	strb	r2, [r3]
   187d4:	ea000001 	b	187e0 <memset+0x68>
      else
        return m;
   187d8:	e51b3020 	ldr	r3, [fp, #-32]
   187dc:	ea000057 	b	18940 <memset+0x1c8>
  unsigned long buffer;
  unsigned long *aligned_addr;
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
				   unsigned variable.  */

  while (UNALIGNED (s))
   187e0:	e51b3008 	ldr	r3, [fp, #-8]
   187e4:	e2033003 	and	r3, r3, #3
   187e8:	e3530000 	cmp	r3, #0
   187ec:	1affffed 	bne	187a8 <memset+0x30>
        *s++ = (char) c;
      else
        return m;
    }

  if (!TOO_SMALL (n))
   187f0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   187f4:	e3530003 	cmp	r3, #3
   187f8:	9a000043 	bls	1890c <memset+0x194>
    {
      /* If we get this far, we know that n is large and s is word-aligned. */
      aligned_addr = (unsigned long *) s;
   187fc:	e51b3008 	ldr	r3, [fp, #-8]
   18800:	e50b3014 	str	r3, [fp, #-20]

      /* Store D into each char sized location in BUFFER so that
         we can set large blocks quickly.  */
      buffer = (d << 8) | d;
   18804:	e51b3018 	ldr	r3, [fp, #-24]
   18808:	e1a02403 	lsl	r2, r3, #8
   1880c:	e51b3018 	ldr	r3, [fp, #-24]
   18810:	e1823003 	orr	r3, r2, r3
   18814:	e50b3010 	str	r3, [fp, #-16]
      buffer |= (buffer << 16);
   18818:	e51b3010 	ldr	r3, [fp, #-16]
   1881c:	e1a03803 	lsl	r3, r3, #16
   18820:	e51b2010 	ldr	r2, [fp, #-16]
   18824:	e1823003 	orr	r3, r2, r3
   18828:	e50b3010 	str	r3, [fp, #-16]
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
   1882c:	e3a03020 	mov	r3, #32
   18830:	e50b300c 	str	r3, [fp, #-12]
   18834:	ea000008 	b	1885c <memset+0xe4>
        buffer = (buffer << i) | buffer;
   18838:	e51b2010 	ldr	r2, [fp, #-16]
   1883c:	e51b300c 	ldr	r3, [fp, #-12]
   18840:	e1a03312 	lsl	r3, r2, r3
   18844:	e51b2010 	ldr	r2, [fp, #-16]
   18848:	e1823003 	orr	r3, r2, r3
   1884c:	e50b3010 	str	r3, [fp, #-16]

      /* Store D into each char sized location in BUFFER so that
         we can set large blocks quickly.  */
      buffer = (d << 8) | d;
      buffer |= (buffer << 16);
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
   18850:	e51b300c 	ldr	r3, [fp, #-12]
   18854:	e1a03083 	lsl	r3, r3, #1
   18858:	e50b300c 	str	r3, [fp, #-12]
   1885c:	e51b300c 	ldr	r3, [fp, #-12]
   18860:	e353001f 	cmp	r3, #31
   18864:	9afffff3 	bls	18838 <memset+0xc0>
        buffer = (buffer << i) | buffer;

      /* Unroll the loop.  */
      while (n >= LBLOCKSIZE*4)
   18868:	ea000016 	b	188c8 <memset+0x150>
        {
          *aligned_addr++ = buffer;
   1886c:	e51b3014 	ldr	r3, [fp, #-20]
   18870:	e2832004 	add	r2, r3, #4
   18874:	e50b2014 	str	r2, [fp, #-20]
   18878:	e51b2010 	ldr	r2, [fp, #-16]
   1887c:	e5832000 	str	r2, [r3]
          *aligned_addr++ = buffer;
   18880:	e51b3014 	ldr	r3, [fp, #-20]
   18884:	e2832004 	add	r2, r3, #4
   18888:	e50b2014 	str	r2, [fp, #-20]
   1888c:	e51b2010 	ldr	r2, [fp, #-16]
   18890:	e5832000 	str	r2, [r3]
          *aligned_addr++ = buffer;
   18894:	e51b3014 	ldr	r3, [fp, #-20]
   18898:	e2832004 	add	r2, r3, #4
   1889c:	e50b2014 	str	r2, [fp, #-20]
   188a0:	e51b2010 	ldr	r2, [fp, #-16]
   188a4:	e5832000 	str	r2, [r3]
          *aligned_addr++ = buffer;
   188a8:	e51b3014 	ldr	r3, [fp, #-20]
   188ac:	e2832004 	add	r2, r3, #4
   188b0:	e50b2014 	str	r2, [fp, #-20]
   188b4:	e51b2010 	ldr	r2, [fp, #-16]
   188b8:	e5832000 	str	r2, [r3]
          n -= 4*LBLOCKSIZE;
   188bc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   188c0:	e2433010 	sub	r3, r3, #16
   188c4:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      buffer |= (buffer << 16);
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        buffer = (buffer << i) | buffer;

      /* Unroll the loop.  */
      while (n >= LBLOCKSIZE*4)
   188c8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   188cc:	e353000f 	cmp	r3, #15
   188d0:	8affffe5 	bhi	1886c <memset+0xf4>
          *aligned_addr++ = buffer;
          *aligned_addr++ = buffer;
          n -= 4*LBLOCKSIZE;
        }

      while (n >= LBLOCKSIZE)
   188d4:	ea000007 	b	188f8 <memset+0x180>
        {
          *aligned_addr++ = buffer;
   188d8:	e51b3014 	ldr	r3, [fp, #-20]
   188dc:	e2832004 	add	r2, r3, #4
   188e0:	e50b2014 	str	r2, [fp, #-20]
   188e4:	e51b2010 	ldr	r2, [fp, #-16]
   188e8:	e5832000 	str	r2, [r3]
          n -= LBLOCKSIZE;
   188ec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   188f0:	e2433004 	sub	r3, r3, #4
   188f4:	e50b3028 	str	r3, [fp, #-40]	; 0x28
          *aligned_addr++ = buffer;
          *aligned_addr++ = buffer;
          n -= 4*LBLOCKSIZE;
        }

      while (n >= LBLOCKSIZE)
   188f8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   188fc:	e3530003 	cmp	r3, #3
   18900:	8afffff4 	bhi	188d8 <memset+0x160>
        {
          *aligned_addr++ = buffer;
          n -= LBLOCKSIZE;
        }
      /* Pick up the remainder with a bytewise loop.  */
      s = (char*)aligned_addr;
   18904:	e51b3014 	ldr	r3, [fp, #-20]
   18908:	e50b3008 	str	r3, [fp, #-8]
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
   1890c:	ea000005 	b	18928 <memset+0x1b0>
    *s++ = (char) c;
   18910:	e51b3008 	ldr	r3, [fp, #-8]
   18914:	e2832001 	add	r2, r3, #1
   18918:	e50b2008 	str	r2, [fp, #-8]
   1891c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   18920:	e20220ff 	and	r2, r2, #255	; 0xff
   18924:	e5c32000 	strb	r2, [r3]
      s = (char*)aligned_addr;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
   18928:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1892c:	e2432001 	sub	r2, r3, #1
   18930:	e50b2028 	str	r2, [fp, #-40]	; 0x28
   18934:	e3530000 	cmp	r3, #0
   18938:	1afffff4 	bne	18910 <memset+0x198>
    *s++ = (char) c;

  return m;
   1893c:	e51b3020 	ldr	r3, [fp, #-32]
}
   18940:	e1a00003 	mov	r0, r3
   18944:	e24bd000 	sub	sp, fp, #0
   18948:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1894c:	e12fff1e 	bx	lr

00018950 <__malloc_lock>:
#endif

void
__malloc_lock (ptr)
     struct _reent *ptr;
{
   18950:	e92d4800 	push	{fp, lr}
   18954:	e28db004 	add	fp, sp, #4
   18958:	e24dd008 	sub	sp, sp, #8
   1895c:	e50b0008 	str	r0, [fp, #-8]
#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive (__malloc_lock_object);
   18960:	e59f000c 	ldr	r0, [pc, #12]	; 18974 <__malloc_lock+0x24>
   18964:	ebfffac5 	bl	17480 <_dna_lock_acquire>
#endif
}
   18968:	e24bd004 	sub	sp, fp, #4
   1896c:	e8bd4800 	pop	{fp, lr}
   18970:	e12fff1e 	bx	lr
   18974:	0003e878 	.word	0x0003e878

00018978 <__malloc_unlock>:

void
__malloc_unlock (ptr)
     struct _reent *ptr;
{
   18978:	e92d4800 	push	{fp, lr}
   1897c:	e28db004 	add	fp, sp, #4
   18980:	e24dd008 	sub	sp, sp, #8
   18984:	e50b0008 	str	r0, [fp, #-8]
#ifndef __SINGLE_THREAD__
  __lock_release_recursive (__malloc_lock_object);
   18988:	e59f000c 	ldr	r0, [pc, #12]	; 1899c <__malloc_unlock+0x24>
   1898c:	ebfffb22 	bl	1761c <_dna_lock_release>
#endif
}
   18990:	e24bd004 	sub	sp, fp, #4
   18994:	e8bd4800 	pop	{fp, lr}
   18998:	e12fff1e 	bx	lr
   1899c:	0003e878 	.word	0x0003e878

000189a0 <open>:
int
_DEFUN (_open, (file, flags, mode),
        char *file  _AND
        int   flags _AND
        int   mode)
{
   189a0:	e92d4800 	push	{fp, lr}
   189a4:	e28db004 	add	fp, sp, #4
   189a8:	e24dd018 	sub	sp, sp, #24
   189ac:	e50b0010 	str	r0, [fp, #-16]
   189b0:	e50b1014 	str	r1, [fp, #-20]
   189b4:	e50b2018 	str	r2, [fp, #-24]
	int16_t fd = -1;
   189b8:	e3e03000 	mvn	r3, #0
   189bc:	e14b30b8 	strh	r3, [fp, #-8]
	status_t status = DNA_OK;
   189c0:	e3a03000 	mov	r3, #0
   189c4:	e14b30b6 	strh	r3, [fp, #-6]

	status = vfs_open (file, flags, mode, & fd);
   189c8:	e24b3008 	sub	r3, fp, #8
   189cc:	e51b0010 	ldr	r0, [fp, #-16]
   189d0:	e51b1014 	ldr	r1, [fp, #-20]
   189d4:	e51b2018 	ldr	r2, [fp, #-24]
   189d8:	ebffd59b 	bl	e04c <vfs_open>
   189dc:	e1a03000 	mov	r3, r0
   189e0:	e14b30b6 	strh	r3, [fp, #-6]
	return fd;
   189e4:	e15b30b8 	ldrh	r3, [fp, #-8]
   189e8:	e1a03803 	lsl	r3, r3, #16
   189ec:	e1a03843 	asr	r3, r3, #16
}
   189f0:	e1a00003 	mov	r0, r3
   189f4:	e24bd004 	sub	sp, fp, #4
   189f8:	e8bd4800 	pop	{fp, lr}
   189fc:	e12fff1e 	bx	lr

00018a00 <_printf_r>:

int
_DEFUN(_printf_r, (ptr, fmt),
       struct _reent *ptr _AND
       const char *fmt _DOTS)
{
   18a00:	e92d000e 	push	{r1, r2, r3}
   18a04:	e92d4800 	push	{fp, lr}
   18a08:	e28db004 	add	fp, sp, #4
   18a0c:	e24dd014 	sub	sp, sp, #20
   18a10:	e50b0014 	str	r0, [fp, #-20]
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   18a14:	e28b3008 	add	r3, fp, #8
   18a18:	e50b3010 	str	r3, [fp, #-16]
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   18a1c:	e51b3014 	ldr	r3, [fp, #-20]
   18a20:	e5933008 	ldr	r3, [r3, #8]
   18a24:	e51b0014 	ldr	r0, [fp, #-20]
   18a28:	e1a01003 	mov	r1, r3
   18a2c:	e59b2004 	ldr	r2, [fp, #4]
   18a30:	e51b3010 	ldr	r3, [fp, #-16]
   18a34:	eb000e28 	bl	1c2dc <_vfprintf_r>
   18a38:	e50b000c 	str	r0, [fp, #-12]
  va_end (ap);
  return ret;
   18a3c:	e51b300c 	ldr	r3, [fp, #-12]
}
   18a40:	e1a00003 	mov	r0, r3
   18a44:	e24bd004 	sub	sp, fp, #4
   18a48:	e8bd4800 	pop	{fp, lr}
   18a4c:	e28dd00c 	add	sp, sp, #12
   18a50:	e12fff1e 	bx	lr

00018a54 <printf>:
#ifndef _REENT_ONLY

int
_DEFUN(printf, (fmt),
       const char *fmt _DOTS)
{
   18a54:	e92d000f 	push	{r0, r1, r2, r3}
   18a58:	e92d4800 	push	{fp, lr}
   18a5c:	e28db004 	add	fp, sp, #4
   18a60:	e24dd010 	sub	sp, sp, #16
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;
   18a64:	e59f3044 	ldr	r3, [pc, #68]	; 18ab0 <printf+0x5c>
   18a68:	e5933000 	ldr	r3, [r3]
   18a6c:	e50b3008 	str	r3, [fp, #-8]

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
   18a70:	e28b3008 	add	r3, fp, #8
   18a74:	e50b3010 	str	r3, [fp, #-16]
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
   18a78:	e51b3008 	ldr	r3, [fp, #-8]
   18a7c:	e5933008 	ldr	r3, [r3, #8]
   18a80:	e51b0008 	ldr	r0, [fp, #-8]
   18a84:	e1a01003 	mov	r1, r3
   18a88:	e59b2004 	ldr	r2, [fp, #4]
   18a8c:	e51b3010 	ldr	r3, [fp, #-16]
   18a90:	eb000e11 	bl	1c2dc <_vfprintf_r>
   18a94:	e50b000c 	str	r0, [fp, #-12]
  va_end (ap);
  return ret;
   18a98:	e51b300c 	ldr	r3, [fp, #-12]
}
   18a9c:	e1a00003 	mov	r0, r3
   18aa0:	e24bd004 	sub	sp, fp, #4
   18aa4:	e8bd4800 	pop	{fp, lr}
   18aa8:	e28dd010 	add	sp, sp, #16
   18aac:	e12fff1e 	bx	lr
   18ab0:	0003e460 	.word	0x0003e460

00018ab4 <_puts_r>:

int
_DEFUN(_puts_r, (ptr, s),
       struct _reent *ptr _AND
       _CONST char * s)
{
   18ab4:	e92d4800 	push	{fp, lr}
   18ab8:	e28db004 	add	fp, sp, #4
   18abc:	e24dd038 	sub	sp, sp, #56	; 0x38
   18ac0:	e50b0038 	str	r0, [fp, #-56]	; 0x38
   18ac4:	e50b103c 	str	r1, [fp, #-60]	; 0x3c
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
   18ac8:	e51b003c 	ldr	r0, [fp, #-60]	; 0x3c
   18acc:	eb0001f7 	bl	192b0 <strlen>
   18ad0:	e50b0008 	str	r0, [fp, #-8]
  struct __suio uio;
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
   18ad4:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   18ad8:	e50b3030 	str	r3, [fp, #-48]	; 0x30
  iov[0].iov_len = c;
   18adc:	e51b3008 	ldr	r3, [fp, #-8]
   18ae0:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
  iov[1].iov_base = "\n";
   18ae4:	e59f3144 	ldr	r3, [pc, #324]	; 18c30 <_puts_r+0x17c>
   18ae8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
  iov[1].iov_len = 1;
   18aec:	e3a03001 	mov	r3, #1
   18af0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
  uio.uio_resid = c + 1;
   18af4:	e51b3008 	ldr	r3, [fp, #-8]
   18af8:	e2833001 	add	r3, r3, #1
   18afc:	e50b3018 	str	r3, [fp, #-24]
  uio.uio_iov = &iov[0];
   18b00:	e24b3030 	sub	r3, fp, #48	; 0x30
   18b04:	e50b3020 	str	r3, [fp, #-32]
  uio.uio_iovcnt = 2;
   18b08:	e3a03002 	mov	r3, #2
   18b0c:	e50b301c 	str	r3, [fp, #-28]

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
   18b10:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   18b14:	e5933008 	ldr	r3, [r3, #8]
   18b18:	e50b300c 	str	r3, [fp, #-12]
  CHECK_INIT (ptr, fp);
   18b1c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   18b20:	e50b3010 	str	r3, [fp, #-16]
   18b24:	e51b3010 	ldr	r3, [fp, #-16]
   18b28:	e3530000 	cmp	r3, #0
   18b2c:	0a000005 	beq	18b48 <_puts_r+0x94>
   18b30:	e51b3010 	ldr	r3, [fp, #-16]
   18b34:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   18b38:	e3530000 	cmp	r3, #0
   18b3c:	1a000001 	bne	18b48 <_puts_r+0x94>
   18b40:	e51b0010 	ldr	r0, [fp, #-16]
   18b44:	ebfff690 	bl	1658c <__sinit>
  _newlib_flockfile_start (fp);
   18b48:	e51b300c 	ldr	r3, [fp, #-12]
   18b4c:	e1d330bc 	ldrh	r3, [r3, #12]
   18b50:	e1a03803 	lsl	r3, r3, #16
   18b54:	e1a03823 	lsr	r3, r3, #16
   18b58:	e2033c02 	and	r3, r3, #512	; 0x200
   18b5c:	e3530000 	cmp	r3, #0
   18b60:	1a000003 	bne	18b74 <_puts_r+0xc0>
   18b64:	e51b300c 	ldr	r3, [fp, #-12]
   18b68:	e283305c 	add	r3, r3, #92	; 0x5c
   18b6c:	e1a00003 	mov	r0, r3
   18b70:	ebfffa42 	bl	17480 <_dna_lock_acquire>
  ORIENT (fp, -1);
   18b74:	e51b300c 	ldr	r3, [fp, #-12]
   18b78:	e1d330bc 	ldrh	r3, [r3, #12]
   18b7c:	e1a03803 	lsl	r3, r3, #16
   18b80:	e1a03823 	lsr	r3, r3, #16
   18b84:	e2033a02 	and	r3, r3, #8192	; 0x2000
   18b88:	e3530000 	cmp	r3, #0
   18b8c:	1a00000b 	bne	18bc0 <_puts_r+0x10c>
   18b90:	e51b300c 	ldr	r3, [fp, #-12]
   18b94:	e1d330bc 	ldrh	r3, [r3, #12]
   18b98:	e3833a02 	orr	r3, r3, #8192	; 0x2000
   18b9c:	e1a03803 	lsl	r3, r3, #16
   18ba0:	e1a02823 	lsr	r2, r3, #16
   18ba4:	e51b300c 	ldr	r3, [fp, #-12]
   18ba8:	e1c320bc 	strh	r2, [r3, #12]
   18bac:	e51b300c 	ldr	r3, [fp, #-12]
   18bb0:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
   18bb4:	e3c32a02 	bic	r2, r3, #8192	; 0x2000
   18bb8:	e51b300c 	ldr	r3, [fp, #-12]
   18bbc:	e583206c 	str	r2, [r3, #108]	; 0x6c
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
   18bc0:	e24b3020 	sub	r3, fp, #32
   18bc4:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
   18bc8:	e51b100c 	ldr	r1, [fp, #-12]
   18bcc:	e1a02003 	mov	r2, r3
   18bd0:	eb0023cd 	bl	21b0c <__sfvwrite_r>
   18bd4:	e1a03000 	mov	r3, r0
   18bd8:	e3530000 	cmp	r3, #0
   18bdc:	0a000001 	beq	18be8 <_puts_r+0x134>
   18be0:	e3e03000 	mvn	r3, #0
   18be4:	ea000000 	b	18bec <_puts_r+0x138>
   18be8:	e3a0300a 	mov	r3, #10
   18bec:	e50b3014 	str	r3, [fp, #-20]
  _newlib_flockfile_end (fp);
   18bf0:	e51b300c 	ldr	r3, [fp, #-12]
   18bf4:	e1d330bc 	ldrh	r3, [r3, #12]
   18bf8:	e1a03803 	lsl	r3, r3, #16
   18bfc:	e1a03823 	lsr	r3, r3, #16
   18c00:	e2033c02 	and	r3, r3, #512	; 0x200
   18c04:	e3530000 	cmp	r3, #0
   18c08:	1a000003 	bne	18c1c <_puts_r+0x168>
   18c0c:	e51b300c 	ldr	r3, [fp, #-12]
   18c10:	e283305c 	add	r3, r3, #92	; 0x5c
   18c14:	e1a00003 	mov	r0, r3
   18c18:	ebfffa7f 	bl	1761c <_dna_lock_release>
  return result;
   18c1c:	e51b3014 	ldr	r3, [fp, #-20]

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
   18c20:	e1a00003 	mov	r0, r3
   18c24:	e24bd004 	sub	sp, fp, #4
   18c28:	e8bd4800 	pop	{fp, lr}
   18c2c:	e12fff1e 	bx	lr
   18c30:	00033058 	.word	0x00033058

00018c34 <puts>:
#ifndef _REENT_ONLY

int
_DEFUN(puts, (s),
       char _CONST * s)
{
   18c34:	e92d4800 	push	{fp, lr}
   18c38:	e28db004 	add	fp, sp, #4
   18c3c:	e24dd008 	sub	sp, sp, #8
   18c40:	e50b0008 	str	r0, [fp, #-8]
  return _puts_r (_REENT, s);
   18c44:	e59f3020 	ldr	r3, [pc, #32]	; 18c6c <puts+0x38>
   18c48:	e5933000 	ldr	r3, [r3]
   18c4c:	e1a00003 	mov	r0, r3
   18c50:	e51b1008 	ldr	r1, [fp, #-8]
   18c54:	ebffff96 	bl	18ab4 <_puts_r>
   18c58:	e1a03000 	mov	r3, r0
}
   18c5c:	e1a00003 	mov	r0, r3
   18c60:	e24bd004 	sub	sp, fp, #4
   18c64:	e8bd4800 	pop	{fp, lr}
   18c68:	e12fff1e 	bx	lr
   18c6c:	0003e460 	.word	0x0003e460

00018c70 <srand>:
#include <stdlib.h>
#include <reent.h>

void
_DEFUN (srand, (seed), unsigned int seed)
{
   18c70:	e92d0810 	push	{r4, fp}
   18c74:	e28db004 	add	fp, sp, #4
   18c78:	e24dd010 	sub	sp, sp, #16
   18c7c:	e50b0010 	str	r0, [fp, #-16]
  struct _reent *reent = _REENT;
   18c80:	e59f3024 	ldr	r3, [pc, #36]	; 18cac <srand+0x3c>
   18c84:	e5933000 	ldr	r3, [r3]
   18c88:	e50b3008 	str	r3, [fp, #-8]

  _REENT_CHECK_RAND48(reent);
  _REENT_RAND_NEXT(reent) = seed;
   18c8c:	e51b3010 	ldr	r3, [fp, #-16]
   18c90:	e3a04000 	mov	r4, #0
   18c94:	e51b2008 	ldr	r2, [fp, #-8]
   18c98:	e58230a8 	str	r3, [r2, #168]	; 0xa8
   18c9c:	e58240ac 	str	r4, [r2, #172]	; 0xac
}
   18ca0:	e24bd004 	sub	sp, fp, #4
   18ca4:	e8bd0810 	pop	{r4, fp}
   18ca8:	e12fff1e 	bx	lr
   18cac:	0003e460 	.word	0x0003e460

00018cb0 <rand>:

int
_DEFUN_VOID (rand)
{
   18cb0:	e92d0870 	push	{r4, r5, r6, fp}
   18cb4:	e28db00c 	add	fp, sp, #12
   18cb8:	e24dd008 	sub	sp, sp, #8
  struct _reent *reent = _REENT;
   18cbc:	e59f3074 	ldr	r3, [pc, #116]	; 18d38 <rand+0x88>
   18cc0:	e5933000 	ldr	r3, [r3]
   18cc4:	e50b3010 	str	r3, [fp, #-16]
  /* This multiplier was obtained from Knuth, D.E., "The Art of
     Computer Programming," Vol 2, Seminumerical Algorithms, Third
     Edition, Addison-Wesley, 1998, p. 106 (line 26) & p. 108 */
  _REENT_CHECK_RAND48(reent);
  _REENT_RAND_NEXT(reent) =
     _REENT_RAND_NEXT(reent) * __extension__ 6364136223846793005LL + 1;
   18cc8:	e51b3010 	ldr	r3, [fp, #-16]
   18ccc:	e28320a8 	add	r2, r3, #168	; 0xa8
   18cd0:	e8920006 	ldm	r2, {r1, r2}
   18cd4:	e59f3060 	ldr	r3, [pc, #96]	; 18d3c <rand+0x8c>
   18cd8:	e0000293 	mul	r0, r3, r2
   18cdc:	e59f305c 	ldr	r3, [pc, #92]	; 18d40 <rand+0x90>
   18ce0:	e0030391 	mul	r3, r1, r3
   18ce4:	e0800003 	add	r0, r0, r3
   18ce8:	e59fc04c 	ldr	ip, [pc, #76]	; 18d3c <rand+0x8c>
   18cec:	e0843c91 	umull	r3, r4, r1, ip
   18cf0:	e0802004 	add	r2, r0, r4
   18cf4:	e1a04002 	mov	r4, r2
   18cf8:	e2933001 	adds	r3, r3, #1
   18cfc:	e2a44000 	adc	r4, r4, #0

  /* This multiplier was obtained from Knuth, D.E., "The Art of
     Computer Programming," Vol 2, Seminumerical Algorithms, Third
     Edition, Addison-Wesley, 1998, p. 106 (line 26) & p. 108 */
  _REENT_CHECK_RAND48(reent);
  _REENT_RAND_NEXT(reent) =
   18d00:	e51b2010 	ldr	r2, [fp, #-16]
   18d04:	e58230a8 	str	r3, [r2, #168]	; 0xa8
   18d08:	e58240ac 	str	r4, [r2, #172]	; 0xac
     _REENT_RAND_NEXT(reent) * __extension__ 6364136223846793005LL + 1;
  return (int)((_REENT_RAND_NEXT(reent) >> 32) & RAND_MAX);
   18d0c:	e51b3010 	ldr	r3, [fp, #-16]
   18d10:	e28340a8 	add	r4, r3, #168	; 0xa8
   18d14:	e8940018 	ldm	r4, {r3, r4}
   18d18:	e1a05004 	mov	r5, r4
   18d1c:	e3a06000 	mov	r6, #0
   18d20:	e1a03005 	mov	r3, r5
   18d24:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
}
   18d28:	e1a00003 	mov	r0, r3
   18d2c:	e24bd00c 	sub	sp, fp, #12
   18d30:	e8bd0870 	pop	{r4, r5, r6, fp}
   18d34:	e12fff1e 	bx	lr
   18d38:	0003e460 	.word	0x0003e460
   18d3c:	4c957f2d 	.word	0x4c957f2d
   18d40:	5851f42d 	.word	0x5851f42d

00018d44 <read>:
int
_DEFUN (_read, (file, ptr, len),
        int   file  _AND
        char *ptr   _AND
        int   len)
{
   18d44:	e92d4800 	push	{fp, lr}
   18d48:	e28db004 	add	fp, sp, #4
   18d4c:	e24dd018 	sub	sp, sp, #24
   18d50:	e50b0010 	str	r0, [fp, #-16]
   18d54:	e50b1014 	str	r1, [fp, #-20]
   18d58:	e50b2018 	str	r2, [fp, #-24]
	status_t status = DNA_OK;
   18d5c:	e3a03000 	mov	r3, #0
   18d60:	e14b30b6 	strh	r3, [fp, #-6]
	int32_t res = -1;
   18d64:	e3e03000 	mvn	r3, #0
   18d68:	e50b300c 	str	r3, [fp, #-12]

	status = vfs_read (file, ptr, len, & res);
   18d6c:	e51b3010 	ldr	r3, [fp, #-16]
   18d70:	e1a03803 	lsl	r3, r3, #16
   18d74:	e1a03823 	lsr	r3, r3, #16
   18d78:	e1a03803 	lsl	r3, r3, #16
   18d7c:	e1a02843 	asr	r2, r3, #16
   18d80:	e24b300c 	sub	r3, fp, #12
   18d84:	e1a00002 	mov	r0, r2
   18d88:	e51b1014 	ldr	r1, [fp, #-20]
   18d8c:	e51b2018 	ldr	r2, [fp, #-24]
   18d90:	ebffd73f 	bl	ea94 <vfs_read>
   18d94:	e1a03000 	mov	r3, r0
   18d98:	e14b30b6 	strh	r3, [fp, #-6]
	return res;
   18d9c:	e51b300c 	ldr	r3, [fp, #-12]
}
   18da0:	e1a00003 	mov	r0, r3
   18da4:	e24bd004 	sub	sp, fp, #4
   18da8:	e8bd4800 	pop	{fp, lr}
   18dac:	e12fff1e 	bx	lr

00018db0 <_sbrk_r>:

void *
_DEFUN (_sbrk_r, (ptr, incr),
     struct _reent *ptr _AND
     ptrdiff_t incr)
{
   18db0:	e92d4800 	push	{fp, lr}
   18db4:	e28db004 	add	fp, sp, #4
   18db8:	e24dd010 	sub	sp, sp, #16
   18dbc:	e50b0010 	str	r0, [fp, #-16]
   18dc0:	e50b1014 	str	r1, [fp, #-20]
  char *ret;
  void *_sbrk(ptrdiff_t);

  errno = 0;
   18dc4:	e59f3050 	ldr	r3, [pc, #80]	; 18e1c <_sbrk_r+0x6c>
   18dc8:	e3a02000 	mov	r2, #0
   18dcc:	e5832000 	str	r2, [r3]
  if ((ret = (char *)(_sbrk (incr))) == (void *) -1 && errno != 0)
   18dd0:	e51b0014 	ldr	r0, [fp, #-20]
   18dd4:	eb003155 	bl	25330 <sbrk>
   18dd8:	e50b0008 	str	r0, [fp, #-8]
   18ddc:	e51b3008 	ldr	r3, [fp, #-8]
   18de0:	e3730001 	cmn	r3, #1
   18de4:	1a000007 	bne	18e08 <_sbrk_r+0x58>
   18de8:	e59f302c 	ldr	r3, [pc, #44]	; 18e1c <_sbrk_r+0x6c>
   18dec:	e5933000 	ldr	r3, [r3]
   18df0:	e3530000 	cmp	r3, #0
   18df4:	0a000003 	beq	18e08 <_sbrk_r+0x58>
    ptr->_errno = errno;
   18df8:	e59f301c 	ldr	r3, [pc, #28]	; 18e1c <_sbrk_r+0x6c>
   18dfc:	e5932000 	ldr	r2, [r3]
   18e00:	e51b3010 	ldr	r3, [fp, #-16]
   18e04:	e5832000 	str	r2, [r3]
  return ret;
   18e08:	e51b3008 	ldr	r3, [fp, #-8]
}
   18e0c:	e1a00003 	mov	r0, r3
   18e10:	e24bd004 	sub	sp, fp, #4
   18e14:	e8bd4800 	pop	{fp, lr}
   18e18:	e12fff1e 	bx	lr
   18e1c:	0018b940 	.word	0x0018b940

00018e20 <_sprintf_r>:
           struct _reent *ptr;
           char *str;
           _CONST char *fmt;
           va_dcl
#endif
{
   18e20:	e92d000c 	push	{r2, r3}
   18e24:	e92d4800 	push	{fp, lr}
   18e28:	e28db004 	add	fp, sp, #4
   18e2c:	e24dd080 	sub	sp, sp, #128	; 0x80
   18e30:	e50b0080 	str	r0, [fp, #-128]	; 0x80
   18e34:	e50b1084 	str	r1, [fp, #-132]	; 0x84
  int ret;
  va_list ap;
  FILE f;

  f._flags = __SWR | __SSTR;
   18e38:	e3a03f82 	mov	r3, #520	; 0x208
   18e3c:	e14b37b0 	strh	r3, [fp, #-112]	; 0xffffff90
  f._bf._base = f._p = (unsigned char *) str;
   18e40:	e51b3084 	ldr	r3, [fp, #-132]	; 0x84
   18e44:	e50b307c 	str	r3, [fp, #-124]	; 0x7c
   18e48:	e51b307c 	ldr	r3, [fp, #-124]	; 0x7c
   18e4c:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
  f._bf._size = f._w = INT_MAX;
   18e50:	e3e03102 	mvn	r3, #-2147483648	; 0x80000000
   18e54:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   18e58:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   18e5c:	e50b3068 	str	r3, [fp, #-104]	; 0x68
  f._file = -1;  /* No file. */
   18e60:	e3e03000 	mvn	r3, #0
   18e64:	e14b36be 	strh	r3, [fp, #-110]	; 0xffffff92
#ifdef _HAVE_STDC
  va_start (ap, fmt);
   18e68:	e28b3008 	add	r3, fp, #8
   18e6c:	e50b300c 	str	r3, [fp, #-12]
#else
  va_start (ap);
#endif
  ret = _svfprintf_r (ptr, &f, fmt, ap);
   18e70:	e24b307c 	sub	r3, fp, #124	; 0x7c
   18e74:	e51b0080 	ldr	r0, [fp, #-128]	; 0x80
   18e78:	e1a01003 	mov	r1, r3
   18e7c:	e59b2004 	ldr	r2, [fp, #4]
   18e80:	e51b300c 	ldr	r3, [fp, #-12]
   18e84:	eb000122 	bl	19314 <_svfprintf_r>
   18e88:	e50b0008 	str	r0, [fp, #-8]
  va_end (ap);
  *f._p = '\0';	/* terminate the string */
   18e8c:	e51b307c 	ldr	r3, [fp, #-124]	; 0x7c
   18e90:	e3a02000 	mov	r2, #0
   18e94:	e5c32000 	strb	r2, [r3]
  return (ret);
   18e98:	e51b3008 	ldr	r3, [fp, #-8]
}
   18e9c:	e1a00003 	mov	r0, r3
   18ea0:	e24bd004 	sub	sp, fp, #4
   18ea4:	e8bd4800 	pop	{fp, lr}
   18ea8:	e28dd008 	add	sp, sp, #8
   18eac:	e12fff1e 	bx	lr

00018eb0 <sprintf>:
sprintf(str, fmt, va_alist)
        char *str;
        _CONST char *fmt;
        va_dcl
#endif
{
   18eb0:	e92d000e 	push	{r1, r2, r3}
   18eb4:	e92d4800 	push	{fp, lr}
   18eb8:	e28db004 	add	fp, sp, #4
   18ebc:	e24dd084 	sub	sp, sp, #132	; 0x84
   18ec0:	e50b0084 	str	r0, [fp, #-132]	; 0x84
  int ret;
  va_list ap;
  FILE f;

  f._flags = __SWR | __SSTR;
   18ec4:	e3a03f82 	mov	r3, #520	; 0x208
   18ec8:	e14b37b4 	strh	r3, [fp, #-116]	; 0xffffff8c
  f._bf._base = f._p = (unsigned char *) str;
   18ecc:	e51b3084 	ldr	r3, [fp, #-132]	; 0x84
   18ed0:	e50b3080 	str	r3, [fp, #-128]	; 0x80
   18ed4:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
   18ed8:	e50b3070 	str	r3, [fp, #-112]	; 0x70
  f._bf._size = f._w = INT_MAX;
   18edc:	e3e03102 	mvn	r3, #-2147483648	; 0x80000000
   18ee0:	e50b3078 	str	r3, [fp, #-120]	; 0x78
   18ee4:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   18ee8:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
  f._file = -1;  /* No file. */
   18eec:	e3e03000 	mvn	r3, #0
   18ef0:	e14b37b2 	strh	r3, [fp, #-114]	; 0xffffff8e
#ifdef _HAVE_STDC
  va_start (ap, fmt);
   18ef4:	e28b3008 	add	r3, fp, #8
   18ef8:	e50b3010 	str	r3, [fp, #-16]
#else
  va_start (ap);
#endif
  ret = _svfprintf_r (_REENT, &f, fmt, ap);
   18efc:	e59f3040 	ldr	r3, [pc, #64]	; 18f44 <sprintf+0x94>
   18f00:	e5932000 	ldr	r2, [r3]
   18f04:	e24b3080 	sub	r3, fp, #128	; 0x80
   18f08:	e1a00002 	mov	r0, r2
   18f0c:	e1a01003 	mov	r1, r3
   18f10:	e59b2004 	ldr	r2, [fp, #4]
   18f14:	e51b3010 	ldr	r3, [fp, #-16]
   18f18:	eb0000fd 	bl	19314 <_svfprintf_r>
   18f1c:	e50b000c 	str	r0, [fp, #-12]
  va_end (ap);
  *f._p = '\0';	/* terminate the string */
   18f20:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
   18f24:	e3a02000 	mov	r2, #0
   18f28:	e5c32000 	strb	r2, [r3]
  return (ret);
   18f2c:	e51b300c 	ldr	r3, [fp, #-12]
}
   18f30:	e1a00003 	mov	r0, r3
   18f34:	e24bd004 	sub	sp, fp, #4
   18f38:	e8bd4800 	pop	{fp, lr}
   18f3c:	e28dd00c 	add	sp, sp, #12
   18f40:	e12fff1e 	bx	lr
   18f44:	0003e460 	.word	0x0003e460

00018f48 <__sread>:
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       int n)
{
   18f48:	e92d4830 	push	{r4, r5, fp, lr}
   18f4c:	e28db00c 	add	fp, sp, #12
   18f50:	e24dd010 	sub	sp, sp, #16
   18f54:	e50b0010 	str	r0, [fp, #-16]
   18f58:	e50b1014 	str	r1, [fp, #-20]
   18f5c:	e50b2018 	str	r2, [fp, #-24]
   18f60:	e50b301c 	str	r3, [fp, #-28]
  register FILE *fp = (FILE *) cookie;
   18f64:	e51b4014 	ldr	r4, [fp, #-20]
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   18f68:	e1d430be 	ldrh	r3, [r4, #14]
   18f6c:	e1a03803 	lsl	r3, r3, #16
   18f70:	e1a02843 	asr	r2, r3, #16
   18f74:	e51b301c 	ldr	r3, [fp, #-28]
   18f78:	e51b0010 	ldr	r0, [fp, #-16]
   18f7c:	e1a01002 	mov	r1, r2
   18f80:	e51b2018 	ldr	r2, [fp, #-24]
   18f84:	eb002d43 	bl	24498 <_read_r>
   18f88:	e1a05000 	mov	r5, r0
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
   18f8c:	e3550000 	cmp	r5, #0
   18f90:	ba000008 	blt	18fb8 <__sread+0x70>
    fp->_offset += ret;
   18f94:	e2841050 	add	r1, r4, #80	; 0x50
   18f98:	e8910003 	ldm	r1, {r0, r1}
   18f9c:	e1a02005 	mov	r2, r5
   18fa0:	e1a03fc2 	asr	r3, r2, #31
   18fa4:	e0922000 	adds	r2, r2, r0
   18fa8:	e0a33001 	adc	r3, r3, r1
   18fac:	e5842050 	str	r2, [r4, #80]	; 0x50
   18fb0:	e5843054 	str	r3, [r4, #84]	; 0x54
   18fb4:	ea000004 	b	18fcc <__sread+0x84>
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
   18fb8:	e1d430bc 	ldrh	r3, [r4, #12]
   18fbc:	e3c33a01 	bic	r3, r3, #4096	; 0x1000
   18fc0:	e1a03803 	lsl	r3, r3, #16
   18fc4:	e1a03823 	lsr	r3, r3, #16
   18fc8:	e1c430bc 	strh	r3, [r4, #12]
  return ret;
   18fcc:	e1a03005 	mov	r3, r5
}
   18fd0:	e1a00003 	mov	r0, r3
   18fd4:	e24bd00c 	sub	sp, fp, #12
   18fd8:	e8bd4830 	pop	{r4, r5, fp, lr}
   18fdc:	e12fff1e 	bx	lr

00018fe0 <__seofread>:
_DEFUN(__seofread, (ptr, cookie, buf, len),
       struct _reent *_ptr _AND
       _PTR cookie _AND
       char *buf   _AND
       int len)
{
   18fe0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   18fe4:	e28db000 	add	fp, sp, #0
   18fe8:	e24dd014 	sub	sp, sp, #20
   18fec:	e50b0008 	str	r0, [fp, #-8]
   18ff0:	e50b100c 	str	r1, [fp, #-12]
   18ff4:	e50b2010 	str	r2, [fp, #-16]
   18ff8:	e50b3014 	str	r3, [fp, #-20]
  return 0;
   18ffc:	e3a03000 	mov	r3, #0
}
   19000:	e1a00003 	mov	r0, r3
   19004:	e24bd000 	sub	sp, fp, #0
   19008:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1900c:	e12fff1e 	bx	lr

00019010 <__swrite>:
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       int n)
{
   19010:	e92d4810 	push	{r4, fp, lr}
   19014:	e28db008 	add	fp, sp, #8
   19018:	e24dd024 	sub	sp, sp, #36	; 0x24
   1901c:	e50b0018 	str	r0, [fp, #-24]
   19020:	e50b101c 	str	r1, [fp, #-28]
   19024:	e50b2020 	str	r2, [fp, #-32]
   19028:	e50b3024 	str	r3, [fp, #-36]	; 0x24
  register FILE *fp = (FILE *) cookie;
   1902c:	e51b401c 	ldr	r4, [fp, #-28]
  int w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   19030:	e1d430bc 	ldrh	r3, [r4, #12]
   19034:	e1a03803 	lsl	r3, r3, #16
   19038:	e1a03823 	lsr	r3, r3, #16
   1903c:	e2033c01 	and	r3, r3, #256	; 0x100
   19040:	e3530000 	cmp	r3, #0
   19044:	0a000009 	beq	19070 <__swrite+0x60>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
   19048:	e1d430be 	ldrh	r3, [r4, #14]
   1904c:	e1a03803 	lsl	r3, r3, #16
   19050:	e1a03843 	asr	r3, r3, #16
   19054:	e3a02002 	mov	r2, #2
   19058:	e58d2000 	str	r2, [sp]
   1905c:	e51b0018 	ldr	r0, [fp, #-24]
   19060:	e1a01003 	mov	r1, r3
   19064:	e3a02000 	mov	r2, #0
   19068:	e3a03000 	mov	r3, #0
   1906c:	eb0024b4 	bl	22344 <_lseek_r>
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   19070:	e1d430bc 	ldrh	r3, [r4, #12]
   19074:	e3c33a01 	bic	r3, r3, #4096	; 0x1000
   19078:	e1a03803 	lsl	r3, r3, #16
   1907c:	e1a03823 	lsr	r3, r3, #16
   19080:	e1c430bc 	strh	r3, [r4, #12]
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   19084:	e1d430be 	ldrh	r3, [r4, #14]
   19088:	e1a03803 	lsl	r3, r3, #16
   1908c:	e1a02843 	asr	r2, r3, #16
   19090:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   19094:	e51b0018 	ldr	r0, [fp, #-24]
   19098:	e1a01002 	mov	r1, r2
   1909c:	e51b2020 	ldr	r2, [fp, #-32]
   190a0:	eb0018cd 	bl	1f3dc <_write_r>
   190a4:	e50b0010 	str	r0, [fp, #-16]
#ifdef __SCLE
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
   190a8:	e51b3010 	ldr	r3, [fp, #-16]
}
   190ac:	e1a00003 	mov	r0, r3
   190b0:	e24bd008 	sub	sp, fp, #8
   190b4:	e8bd4810 	pop	{r4, fp, lr}
   190b8:	e12fff1e 	bx	lr

000190bc <__sseek>:
_DEFUN(__sseek, (ptr, cookie, offset, whence),
       struct _reent *ptr _AND
       void *cookie _AND
       _fpos_t offset _AND
       int whence)
{
   190bc:	e92d4870 	push	{r4, r5, r6, fp, lr}
   190c0:	e28db010 	add	fp, sp, #16
   190c4:	e24dd01c 	sub	sp, sp, #28
   190c8:	e50b0018 	str	r0, [fp, #-24]
   190cc:	e50b101c 	str	r1, [fp, #-28]
   190d0:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   190d4:	e50b3020 	str	r3, [fp, #-32]
  register FILE *fp = (FILE *) cookie;
   190d8:	e51b601c 	ldr	r6, [fp, #-28]
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
   190dc:	e1d630be 	ldrh	r3, [r6, #14]
   190e0:	e1a03803 	lsl	r3, r3, #16
   190e4:	e1a03843 	asr	r3, r3, #16
   190e8:	e59b2004 	ldr	r2, [fp, #4]
   190ec:	e58d2000 	str	r2, [sp]
   190f0:	e51b0018 	ldr	r0, [fp, #-24]
   190f4:	e1a01003 	mov	r1, r3
   190f8:	e24b3024 	sub	r3, fp, #36	; 0x24
   190fc:	e893000c 	ldm	r3, {r2, r3}
   19100:	eb00248f 	bl	22344 <_lseek_r>
   19104:	e1a04000 	mov	r4, r0
   19108:	e1a05001 	mov	r5, r1
  if (ret == -1L)
   1910c:	e3e02000 	mvn	r2, #0
   19110:	e3e03000 	mvn	r3, #0
   19114:	e1550003 	cmp	r5, r3
   19118:	01540002 	cmpeq	r4, r2
   1911c:	1a000005 	bne	19138 <__sseek+0x7c>
    fp->_flags &= ~__SOFF;
   19120:	e1d630bc 	ldrh	r3, [r6, #12]
   19124:	e3c33a01 	bic	r3, r3, #4096	; 0x1000
   19128:	e1a03803 	lsl	r3, r3, #16
   1912c:	e1a03823 	lsr	r3, r3, #16
   19130:	e1c630bc 	strh	r3, [r6, #12]
   19134:	ea000006 	b	19154 <__sseek+0x98>
  else
    {
      fp->_flags |= __SOFF;
   19138:	e1d630bc 	ldrh	r3, [r6, #12]
   1913c:	e3833a01 	orr	r3, r3, #4096	; 0x1000
   19140:	e1a03803 	lsl	r3, r3, #16
   19144:	e1a03823 	lsr	r3, r3, #16
   19148:	e1c630bc 	strh	r3, [r6, #12]
      fp->_offset = ret;
   1914c:	e5864050 	str	r4, [r6, #80]	; 0x50
   19150:	e5865054 	str	r5, [r6, #84]	; 0x54
    }
  return ret;
   19154:	e1a03004 	mov	r3, r4
   19158:	e1a04005 	mov	r4, r5
}
   1915c:	e1a00003 	mov	r0, r3
   19160:	e1a01004 	mov	r1, r4
   19164:	e24bd010 	sub	sp, fp, #16
   19168:	e8bd4870 	pop	{r4, r5, r6, fp, lr}
   1916c:	e12fff1e 	bx	lr

00019170 <__sclose>:

int
_DEFUN(__sclose, (ptr, cookie),
       struct _reent *ptr _AND
       void *cookie)
{
   19170:	e92d4800 	push	{fp, lr}
   19174:	e28db004 	add	fp, sp, #4
   19178:	e24dd010 	sub	sp, sp, #16
   1917c:	e50b0010 	str	r0, [fp, #-16]
   19180:	e50b1014 	str	r1, [fp, #-20]
  FILE *fp = (FILE *) cookie;
   19184:	e51b3014 	ldr	r3, [fp, #-20]
   19188:	e50b3008 	str	r3, [fp, #-8]

  return _close_r (ptr, fp->_file);
   1918c:	e51b3008 	ldr	r3, [fp, #-8]
   19190:	e1d330be 	ldrh	r3, [r3, #14]
   19194:	e1a03803 	lsl	r3, r3, #16
   19198:	e1a03843 	asr	r3, r3, #16
   1919c:	e51b0010 	ldr	r0, [fp, #-16]
   191a0:	e1a01003 	mov	r1, r3
   191a4:	eb0019ac 	bl	1f85c <_close_r>
   191a8:	e1a03000 	mov	r3, r0
}
   191ac:	e1a00003 	mov	r0, r3
   191b0:	e24bd004 	sub	sp, fp, #4
   191b4:	e8bd4800 	pop	{fp, lr}
   191b8:	e12fff1e 	bx	lr

000191bc <strcpy>:
#endif

char* __attribute__((naked))
strcpy (char* dst, const char* src)
{
  asm (
   191bc:	e0202001 	eor	r2, r0, r1
   191c0:	e1a0c000 	mov	ip, r0
   191c4:	e3120003 	tst	r2, #3
   191c8:	1a000032 	bne	19298 <strcpy+0xdc>
   191cc:	e3110003 	tst	r1, #3
   191d0:	1a000021 	bne	1925c <strcpy+0xa0>
   191d4:	e52d5004 	push	{r5}		; (str r5, [sp, #-4]!)
   191d8:	e3a05001 	mov	r5, #1
   191dc:	e1855405 	orr	r5, r5, r5, lsl #8
   191e0:	e1855805 	orr	r5, r5, r5, lsl #16
   191e4:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
   191e8:	e3110004 	tst	r1, #4
   191ec:	e4913004 	ldr	r3, [r1], #4
   191f0:	0a000005 	beq	1920c <strcpy+0x50>
   191f4:	e0432005 	sub	r2, r3, r5
   191f8:	e1d22003 	bics	r2, r2, r3
   191fc:	e1120385 	tst	r2, r5, lsl #7
   19200:	048c3004 	streq	r3, [ip], #4
   19204:	04913004 	ldreq	r3, [r1], #4
   19208:	1a00000c 	bne	19240 <strcpy+0x84>
   1920c:	e4914004 	ldr	r4, [r1], #4
   19210:	e0432005 	sub	r2, r3, r5
   19214:	e1d22003 	bics	r2, r2, r3
   19218:	e1120385 	tst	r2, r5, lsl #7
   1921c:	e0442005 	sub	r2, r4, r5
   19220:	1a000006 	bne	19240 <strcpy+0x84>
   19224:	e48c3004 	str	r3, [ip], #4
   19228:	e1d22004 	bics	r2, r2, r4
   1922c:	e1120385 	tst	r2, r5, lsl #7
   19230:	04913004 	ldreq	r3, [r1], #4
   19234:	048c4004 	streq	r4, [ip], #4
   19238:	0afffff3 	beq	1920c <strcpy+0x50>
   1923c:	e1a03004 	mov	r3, r4
   19240:	e4cc3001 	strb	r3, [ip], #1
   19244:	e31300ff 	tst	r3, #255	; 0xff
   19248:	e1a03463 	ror	r3, r3, #8
   1924c:	1afffffb 	bne	19240 <strcpy+0x84>
   19250:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
   19254:	e49d5004 	pop	{r5}		; (ldr r5, [sp], #4)
   19258:	e12fff1e 	bx	lr
   1925c:	e3110001 	tst	r1, #1
   19260:	0a000003 	beq	19274 <strcpy+0xb8>
   19264:	e4d12001 	ldrb	r2, [r1], #1
   19268:	e4cc2001 	strb	r2, [ip], #1
   1926c:	e3520000 	cmp	r2, #0
   19270:	012fff1e 	bxeq	lr
   19274:	e3110002 	tst	r1, #2
   19278:	0affffd5 	beq	191d4 <strcpy+0x18>
   1927c:	e0d120b2 	ldrh	r2, [r1], #2
   19280:	e31200ff 	tst	r2, #255	; 0xff
   19284:	10cc20b2 	strhne	r2, [ip], #2
   19288:	05cc2000 	strbeq	r2, [ip]
   1928c:	13120cff 	tstne	r2, #65280	; 0xff00
   19290:	1affffcf 	bne	191d4 <strcpy+0x18>
   19294:	e12fff1e 	bx	lr
   19298:	e4d12001 	ldrb	r2, [r1], #1
   1929c:	e4cc2001 	strb	r2, [ip], #1
   192a0:	e3520000 	cmp	r2, #0
   192a4:	1afffffb 	bne	19298 <strcpy+0xdc>
   192a8:	e12fff1e 	bx	lr
       "cmp	r2, #0\n\t"
       "bne	1b\n\t"
       "RETURN"
#endif
       );
}
   192ac:	e1a00003 	mov	r0, r3

000192b0 <strlen>:
#if !(defined(_ISA_ARM_7) || defined(__ARM_ARCH_6T2__))

size_t __attribute__((naked))
strlen (const char* str)
{
  asm ("len .req r0\n\t"
   192b0:	e3c01003 	bic	r1, r0, #3
   192b4:	e2100003 	ands	r0, r0, #3
   192b8:	e2600000 	rsb	r0, r0, #0
   192bc:	e4913004 	ldr	r3, [r1], #4
   192c0:	e280c004 	add	ip, r0, #4
   192c4:	e1a0c18c 	lsl	ip, ip, #3
   192c8:	e3e02000 	mvn	r2, #0
   192cc:	11833c32 	orrne	r3, r3, r2, lsr ip
   192d0:	e3a0c001 	mov	ip, #1
   192d4:	e18cc40c 	orr	ip, ip, ip, lsl #8
   192d8:	e18cc80c 	orr	ip, ip, ip, lsl #16
   192dc:	e043200c 	sub	r2, r3, ip
   192e0:	e1c22003 	bic	r2, r2, r3
   192e4:	e012238c 	ands	r2, r2, ip, lsl #7
   192e8:	04913004 	ldreq	r3, [r1], #4
   192ec:	02800004 	addeq	r0, r0, #4
   192f0:	0afffff9 	beq	192dc <strlen+0x2c>
   192f4:	e31300ff 	tst	r3, #255	; 0xff
   192f8:	12800001 	addne	r0, r0, #1
   192fc:	13130cff 	tstne	r3, #65280	; 0xff00
   19300:	12800001 	addne	r0, r0, #1
   19304:	131308ff 	tstne	r3, #16711680	; 0xff0000
   19308:	12800001 	addne	r0, r0, #1
   1930c:	e12fff1e 	bx	lr
       "it	ne\n\t"
       "addne	len, len, #1\n\t"
# endif
#endif
       "RETURN");
}
   19310:	e1a00003 	mov	r0, r3

00019314 <_svfprintf_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
   19314:	e92d4bf0 	push	{r4, r5, r6, r7, r8, r9, fp, lr}
   19318:	e28db01c 	add	fp, sp, #28
   1931c:	e24ddd06 	sub	sp, sp, #384	; 0x180
   19320:	e50b0160 	str	r0, [fp, #-352]	; 0x160
   19324:	e50b1164 	str	r1, [fp, #-356]	; 0x164
   19328:	e50b2168 	str	r2, [fp, #-360]	; 0x168
   1932c:	e50b316c 	str	r3, [fp, #-364]	; 0x16c
	int width;		/* width from format (%8d), or 0 */
	int prec;		/* precision from format (%.3d), or -1 */
	char sign;		/* sign prefix (' ', '+', '-', or \0) */
#ifdef _WANT_IO_C99_FORMATS
				/* locale specific numeric grouping */
	char *thousands_sep = NULL;
   19330:	e3a03000 	mov	r3, #0
   19334:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	size_t thsnd_len = 0;
   19338:	e3a03000 	mov	r3, #0
   1933c:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	const char *grouping = NULL;
   19340:	e3a03000 	mov	r3, #0
   19344:	e50b3034 	str	r3, [fp, #-52]	; 0x34
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
   19348:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1934c:	eb0023d5 	bl	222a8 <_localeconv_r>
   19350:	e1a03000 	mov	r3, r0
   19354:	e5933000 	ldr	r3, [r3]
   19358:	e50b3074 	str	r3, [fp, #-116]	; 0x74
	size_t decp_len = strlen (decimal_point);
   1935c:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
   19360:	ebffffd2 	bl	192b0 <strlen>
   19364:	e50b0078 	str	r0, [fp, #-120]	; 0x78
	char softsign;		/* temporary negative sign for floats */
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
   19368:	e3a03000 	mov	r3, #0
   1936c:	e3a04000 	mov	r4, #0
   19370:	e50b3094 	str	r3, [fp, #-148]	; 0x94
   19374:	e50b4090 	str	r4, [fp, #-144]	; 0x90
# define _fpvalue (_double_.fp)
	int expt;		/* integer value of exponent */
	int expsize = 0;	/* character count for expstr */
   19378:	e3a03000 	mov	r3, #0
   1937c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	char expstr[MAXEXPLEN];	/* buffer for exponent string */
	int lead;		/* sig figs before decimal or group sep */
#endif /* FLOATING_POINT */
#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
	int ndig = 0;		/* actual number of digits returned by cvt */
   19380:	e3a03000 	mov	r3, #0
   19384:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
   19388:	e3a03000 	mov	r3, #0
   1938c:	e50b3060 	str	r3, [fp, #-96]	; 0x60
	char ox[2];		/* space for 0x hex-prefix */
#ifdef _MB_CAPABLE
	wchar_t wc;
	mbstate_t state;        /* mbtowc calls from library must not change state */
#endif
	char *malloc_buf = NULL;/* handy pointer for malloced buffers */
   19390:	e3a03000 	mov	r3, #0
   19394:	e50b3064 	str	r3, [fp, #-100]	; 0x64
		return (__sbprintf (data, fp, fmt0, ap));
	}
#endif
#else /* STRING_ONLY */
        /* Create initial buffer if we are called by asprintf family.  */
        if (fp->_flags & __SMBF && !fp->_bf._base)
   19398:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1939c:	e1d330bc 	ldrh	r3, [r3, #12]
   193a0:	e1a03803 	lsl	r3, r3, #16
   193a4:	e1a03823 	lsr	r3, r3, #16
   193a8:	e2033080 	and	r3, r3, #128	; 0x80
   193ac:	e3530000 	cmp	r3, #0
   193b0:	0a000019 	beq	1941c <_svfprintf_r+0x108>
   193b4:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   193b8:	e5933010 	ldr	r3, [r3, #16]
   193bc:	e3530000 	cmp	r3, #0
   193c0:	1a000015 	bne	1941c <_svfprintf_r+0x108>
        {
		fp->_bf._base = fp->_p = _malloc_r (data, 64);
   193c4:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   193c8:	e3a01040 	mov	r1, #64	; 0x40
   193cc:	ebfff9b8 	bl	17ab4 <_malloc_r>
   193d0:	e1a02000 	mov	r2, r0
   193d4:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   193d8:	e5832000 	str	r2, [r3]
   193dc:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   193e0:	e5932000 	ldr	r2, [r3]
   193e4:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   193e8:	e5832010 	str	r2, [r3, #16]
		if (!fp->_p)
   193ec:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   193f0:	e5933000 	ldr	r3, [r3]
   193f4:	e3530000 	cmp	r3, #0
   193f8:	1a000004 	bne	19410 <_svfprintf_r+0xfc>
		{
			data->_errno = ENOMEM;
   193fc:	e51b3160 	ldr	r3, [fp, #-352]	; 0x160
   19400:	e3a0200c 	mov	r2, #12
   19404:	e5832000 	str	r2, [r3]
			return EOF;
   19408:	e3e03000 	mvn	r3, #0
   1940c:	ea0009b4 	b	1bae4 <_svfprintf_r+0x27d0>
		}
		fp->_bf._size = 64;
   19410:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   19414:	e3a02040 	mov	r2, #64	; 0x40
   19418:	e5832014 	str	r2, [r3, #20]
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
   1941c:	e51b9168 	ldr	r9, [fp, #-360]	; 0x168
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   19420:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   19424:	e50b40b0 	str	r4, [fp, #-176]	; 0xb0
	uio.uio_resid = 0;
   19428:	e3a03000 	mov	r3, #0
   1942c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
	uio.uio_iovcnt = 0;
   19430:	e3a03000 	mov	r3, #0
   19434:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
#endif
	ret = 0;
   19438:	e3a03000 	mov	r3, #0
   1943c:	e50b3020 	str	r3, [fp, #-32]

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
	        cp = fmt;
   19440:	e1a07009 	mov	r7, r9
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   19444:	ea000000 	b	1944c <_svfprintf_r+0x138>
                    fmt += 1;
   19448:	e2899001 	add	r9, r9, #1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   1944c:	e5d93000 	ldrb	r3, [r9]
   19450:	e3530000 	cmp	r3, #0
   19454:	0a000002 	beq	19464 <_svfprintf_r+0x150>
   19458:	e5d93000 	ldrb	r3, [r9]
   1945c:	e3530025 	cmp	r3, #37	; 0x25
   19460:	1afffff8 	bne	19448 <_svfprintf_r+0x134>
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
   19464:	e1a02009 	mov	r2, r9
   19468:	e1a03007 	mov	r3, r7
   1946c:	e0635002 	rsb	r5, r3, r2
   19470:	e3550000 	cmp	r5, #0
   19474:	0a000019 	beq	194e0 <_svfprintf_r+0x1cc>
			PRINT (cp, m);
   19478:	e5847000 	str	r7, [r4]
   1947c:	e1a03005 	mov	r3, r5
   19480:	e5843004 	str	r3, [r4, #4]
   19484:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   19488:	e0833005 	add	r3, r3, r5
   1948c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   19490:	e2844008 	add	r4, r4, #8
   19494:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   19498:	e2833001 	add	r3, r3, #1
   1949c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   194a0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   194a4:	e3530007 	cmp	r3, #7
   194a8:	da000009 	ble	194d4 <_svfprintf_r+0x1c0>
   194ac:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   194b0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   194b4:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   194b8:	e1a02003 	mov	r2, r3
   194bc:	eb003147 	bl	259e0 <__ssprint_r>
   194c0:	e1a03000 	mov	r3, r0
   194c4:	e3530000 	cmp	r3, #0
   194c8:	0a000000 	beq	194d0 <_svfprintf_r+0x1bc>
   194cc:	ea000973 	b	1baa0 <_svfprintf_r+0x278c>
   194d0:	e24b40f0 	sub	r4, fp, #240	; 0xf0
			ret += m;
   194d4:	e51b3020 	ldr	r3, [fp, #-32]
   194d8:	e0833005 	add	r3, r3, r5
   194dc:	e50b3020 	str	r3, [fp, #-32]
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   194e0:	e5d93000 	ldrb	r3, [r9]
   194e4:	e3530000 	cmp	r3, #0
   194e8:	1a000000 	bne	194f0 <_svfprintf_r+0x1dc>
                    goto done;
   194ec:	ea00095c 	b	1ba64 <_svfprintf_r+0x2750>
#endif
		fmt_anchor = fmt;
   194f0:	e50b907c 	str	r9, [fp, #-124]	; 0x7c
		fmt++;		/* skip over '%' */
   194f4:	e2899001 	add	r9, r9, #1

		flags = 0;
   194f8:	e3a06000 	mov	r6, #0
		dprec = 0;
   194fc:	e3a03000 	mov	r3, #0
   19500:	e50b3054 	str	r3, [fp, #-84]	; 0x54
		width = 0;
   19504:	e3a03000 	mov	r3, #0
   19508:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		prec = -1;
   1950c:	e3e03000 	mvn	r3, #0
   19510:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		sign = '\0';
   19514:	e3a03000 	mov	r3, #0
   19518:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
#ifdef FLOATING_POINT
		lead = 0;
   1951c:	e3a03000 	mov	r3, #0
   19520:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
#ifdef _WANT_IO_C99_FORMATS
		nseps = nrepeats = 0;
   19524:	e3a03000 	mov	r3, #0
   19528:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   1952c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   19530:	e50b3040 	str	r3, [fp, #-64]	; 0x40
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   19534:	e1a03009 	mov	r3, r9
   19538:	e2839001 	add	r9, r3, #1
   1953c:	e5d33000 	ldrb	r3, [r3]
   19540:	e1a08003 	mov	r8, r3
reswitch:	switch (ch) {
   19544:	e2483020 	sub	r3, r8, #32
   19548:	e353005a 	cmp	r3, #90	; 0x5a
   1954c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   19550:	ea000443 	b	1a664 <_svfprintf_r+0x1350>
   19554:	00019724 	.word	0x00019724
   19558:	0001a664 	.word	0x0001a664
   1955c:	0001a664 	.word	0x0001a664
   19560:	0001973c 	.word	0x0001973c
   19564:	0001a664 	.word	0x0001a664
   19568:	0001a664 	.word	0x0001a664
   1956c:	0001a664 	.word	0x0001a664
   19570:	000196c0 	.word	0x000196c0
   19574:	0001a664 	.word	0x0001a664
   19578:	0001a664 	.word	0x0001a664
   1957c:	00019744 	.word	0x00019744
   19580:	0001977c 	.word	0x0001977c
   19584:	0001a664 	.word	0x0001a664
   19588:	00019774 	.word	0x00019774
   1958c:	00019788 	.word	0x00019788
   19590:	0001a664 	.word	0x0001a664
   19594:	00019824 	.word	0x00019824
   19598:	0001982c 	.word	0x0001982c
   1959c:	0001982c 	.word	0x0001982c
   195a0:	0001982c 	.word	0x0001982c
   195a4:	0001982c 	.word	0x0001982c
   195a8:	0001982c 	.word	0x0001982c
   195ac:	0001982c 	.word	0x0001982c
   195b0:	0001982c 	.word	0x0001982c
   195b4:	0001982c 	.word	0x0001982c
   195b8:	0001982c 	.word	0x0001982c
   195bc:	0001a664 	.word	0x0001a664
   195c0:	0001a664 	.word	0x0001a664
   195c4:	0001a664 	.word	0x0001a664
   195c8:	0001a664 	.word	0x0001a664
   195cc:	0001a664 	.word	0x0001a664
   195d0:	0001a664 	.word	0x0001a664
   195d4:	0001a664 	.word	0x0001a664
   195d8:	00019a18 	.word	0x00019a18
   195dc:	0001a664 	.word	0x0001a664
   195e0:	000198c8 	.word	0x000198c8
   195e4:	000198f8 	.word	0x000198f8
   195e8:	00019a18 	.word	0x00019a18
   195ec:	00019a18 	.word	0x00019a18
   195f0:	00019a18 	.word	0x00019a18
   195f4:	0001a664 	.word	0x0001a664
   195f8:	0001a664 	.word	0x0001a664
   195fc:	0001a664 	.word	0x0001a664
   19600:	0001a664 	.word	0x0001a664
   19604:	00019870 	.word	0x00019870
   19608:	0001a664 	.word	0x0001a664
   1960c:	0001a664 	.word	0x0001a664
   19610:	00019f8c 	.word	0x00019f8c
   19614:	0001a664 	.word	0x0001a664
   19618:	0001a664 	.word	0x0001a664
   1961c:	0001a664 	.word	0x0001a664
   19620:	0001a0bc 	.word	0x0001a0bc
   19624:	0001a664 	.word	0x0001a664
   19628:	0001a17c 	.word	0x0001a17c
   1962c:	0001a664 	.word	0x0001a664
   19630:	0001a664 	.word	0x0001a664
   19634:	0001a25c 	.word	0x0001a25c
   19638:	0001a664 	.word	0x0001a664
   1963c:	0001a664 	.word	0x0001a664
   19640:	0001a664 	.word	0x0001a664
   19644:	0001a664 	.word	0x0001a664
   19648:	0001a664 	.word	0x0001a664
   1964c:	0001a664 	.word	0x0001a664
   19650:	0001a664 	.word	0x0001a664
   19654:	0001a664 	.word	0x0001a664
   19658:	00019a18 	.word	0x00019a18
   1965c:	0001a664 	.word	0x0001a664
   19660:	000198c8 	.word	0x000198c8
   19664:	000198fc 	.word	0x000198fc
   19668:	00019a18 	.word	0x00019a18
   1966c:	00019a18 	.word	0x00019a18
   19670:	00019a18 	.word	0x00019a18
   19674:	00019878 	.word	0x00019878
   19678:	000198fc 	.word	0x000198fc
   1967c:	000198c0 	.word	0x000198c0
   19680:	0001a664 	.word	0x0001a664
   19684:	00019898 	.word	0x00019898
   19688:	0001a664 	.word	0x0001a664
   1968c:	00019eb8 	.word	0x00019eb8
   19690:	00019f90 	.word	0x00019f90
   19694:	0001a070 	.word	0x0001a070
   19698:	000198b8 	.word	0x000198b8
   1969c:	0001a664 	.word	0x0001a664
   196a0:	0001a0bc 	.word	0x0001a0bc
   196a4:	00019534 	.word	0x00019534
   196a8:	0001a180 	.word	0x0001a180
   196ac:	0001a664 	.word	0x0001a664
   196b0:	0001a664 	.word	0x0001a664
   196b4:	0001a268 	.word	0x0001a268
   196b8:	0001a664 	.word	0x0001a664
   196bc:	00019534 	.word	0x00019534
#ifdef _WANT_IO_C99_FORMATS
		case '\'':
			thousands_sep = _localeconv_r (data)->thousands_sep;
   196c0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   196c4:	eb0022f7 	bl	222a8 <_localeconv_r>
   196c8:	e1a03000 	mov	r3, r0
   196cc:	e5933004 	ldr	r3, [r3, #4]
   196d0:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
			thsnd_len = strlen (thousands_sep);
   196d4:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
   196d8:	ebfffef4 	bl	192b0 <strlen>
   196dc:	e50b0030 	str	r0, [fp, #-48]	; 0x30
			grouping = _localeconv_r (data)->grouping;
   196e0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   196e4:	eb0022ef 	bl	222a8 <_localeconv_r>
   196e8:	e1a03000 	mov	r3, r0
   196ec:	e5933008 	ldr	r3, [r3, #8]
   196f0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
			if (thsnd_len > 0 && grouping && *grouping)
   196f4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   196f8:	e3530000 	cmp	r3, #0
   196fc:	0a000007 	beq	19720 <_svfprintf_r+0x40c>
   19700:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   19704:	e3530000 	cmp	r3, #0
   19708:	0a000004 	beq	19720 <_svfprintf_r+0x40c>
   1970c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   19710:	e5d33000 	ldrb	r3, [r3]
   19714:	e3530000 	cmp	r3, #0
   19718:	0a000000 	beq	19720 <_svfprintf_r+0x40c>
			  flags |= GROUPING;
   1971c:	e3866b01 	orr	r6, r6, #1024	; 0x400
			goto rflag;
   19720:	eaffff83 	b	19534 <_svfprintf_r+0x220>
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
   19724:	e55b3085 	ldrb	r3, [fp, #-133]	; 0x85
   19728:	e3530000 	cmp	r3, #0
   1972c:	1a000001 	bne	19738 <_svfprintf_r+0x424>
				sign = ' ';
   19730:	e3a03020 	mov	r3, #32
   19734:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
			goto rflag;
   19738:	eaffff7d 	b	19534 <_svfprintf_r+0x220>
		case '#':
			flags |= ALT;
   1973c:	e3866001 	orr	r6, r6, #1
			goto rflag;
   19740:	eaffff7b 	b	19534 <_svfprintf_r+0x220>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   19744:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   19748:	e2832004 	add	r2, r3, #4
   1974c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   19750:	e5933000 	ldr	r3, [r3]
   19754:	e50b3024 	str	r3, [fp, #-36]	; 0x24
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
   19758:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1975c:	e3530000 	cmp	r3, #0
   19760:	ba000000 	blt	19768 <_svfprintf_r+0x454>
				goto rflag;
   19764:	eaffff72 	b	19534 <_svfprintf_r+0x220>
			width = -width;
   19768:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1976c:	e2633000 	rsb	r3, r3, #0
   19770:	e50b3024 	str	r3, [fp, #-36]	; 0x24
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
   19774:	e3866004 	orr	r6, r6, #4
			goto rflag;
   19778:	eaffff6d 	b	19534 <_svfprintf_r+0x220>
		case '+':
			sign = '+';
   1977c:	e3a0302b 	mov	r3, #43	; 0x2b
   19780:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
			goto rflag;
   19784:	eaffff6a 	b	19534 <_svfprintf_r+0x220>
		case '.':
			if ((ch = *fmt++) == '*') {
   19788:	e1a03009 	mov	r3, r9
   1978c:	e2839001 	add	r9, r3, #1
   19790:	e5d33000 	ldrb	r3, [r3]
   19794:	e1a08003 	mov	r8, r3
   19798:	e358002a 	cmp	r8, #42	; 0x2a
   1979c:	1a00000a 	bne	197cc <_svfprintf_r+0x4b8>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   197a0:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   197a4:	e2832004 	add	r2, r3, #4
   197a8:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   197ac:	e5933000 	ldr	r3, [r3]
   197b0:	e50b3028 	str	r3, [fp, #-40]	; 0x28
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   197b4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   197b8:	e3530000 	cmp	r3, #0
   197bc:	aa000001 	bge	197c8 <_svfprintf_r+0x4b4>
					prec = -1;
   197c0:	e3e03000 	mvn	r3, #0
   197c4:	e50b3028 	str	r3, [fp, #-40]	; 0x28
				goto rflag;
   197c8:	eaffff59 	b	19534 <_svfprintf_r+0x220>
			}
			n = 0;
   197cc:	e3a05000 	mov	r5, #0
			while (is_digit (ch)) {
   197d0:	ea00000a 	b	19800 <_svfprintf_r+0x4ec>
				n = 10 * n + to_digit (ch);
   197d4:	e1a03005 	mov	r3, r5
   197d8:	e1a03103 	lsl	r3, r3, #2
   197dc:	e0833005 	add	r3, r3, r5
   197e0:	e1a03083 	lsl	r3, r3, #1
   197e4:	e1a02003 	mov	r2, r3
   197e8:	e2483030 	sub	r3, r8, #48	; 0x30
   197ec:	e0825003 	add	r5, r2, r3
				ch = *fmt++;
   197f0:	e1a03009 	mov	r3, r9
   197f4:	e2839001 	add	r9, r3, #1
   197f8:	e5d33000 	ldrb	r3, [r3]
   197fc:	e1a08003 	mov	r8, r3
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   19800:	e2483030 	sub	r3, r8, #48	; 0x30
   19804:	e3530009 	cmp	r3, #9
   19808:	9afffff1 	bls	197d4 <_svfprintf_r+0x4c0>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
   1980c:	e3e03000 	mvn	r3, #0
   19810:	e1550003 	cmp	r5, r3
   19814:	a1a03005 	movge	r3, r5
   19818:	b1a03003 	movlt	r3, r3
   1981c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
			goto reswitch;
   19820:	eaffff47 	b	19544 <_svfprintf_r+0x230>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
   19824:	e3866080 	orr	r6, r6, #128	; 0x80
			goto rflag;
   19828:	eaffff41 	b	19534 <_svfprintf_r+0x220>
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
   1982c:	e3a05000 	mov	r5, #0
			do {
				n = 10 * n + to_digit (ch);
   19830:	e1a03005 	mov	r3, r5
   19834:	e1a03103 	lsl	r3, r3, #2
   19838:	e0833005 	add	r3, r3, r5
   1983c:	e1a03083 	lsl	r3, r3, #1
   19840:	e1a02003 	mov	r2, r3
   19844:	e2483030 	sub	r3, r8, #48	; 0x30
   19848:	e0825003 	add	r5, r2, r3
				ch = *fmt++;
   1984c:	e1a03009 	mov	r3, r9
   19850:	e2839001 	add	r9, r3, #1
   19854:	e5d33000 	ldrb	r3, [r3]
   19858:	e1a08003 	mov	r8, r3
			} while (is_digit (ch));
   1985c:	e2483030 	sub	r3, r8, #48	; 0x30
   19860:	e3530009 	cmp	r3, #9
   19864:	9afffff1 	bls	19830 <_svfprintf_r+0x51c>
				}
				else
					goto error;
			}
#endif /* !_NO_POS_ARGS */
			width = n;
   19868:	e50b5024 	str	r5, [fp, #-36]	; 0x24
			goto reswitch;
   1986c:	eaffff34 	b	19544 <_svfprintf_r+0x230>
#ifdef FLOATING_POINT
		case 'L':
			flags |= LONGDBL;
   19870:	e3866008 	orr	r6, r6, #8
			goto rflag;
   19874:	eaffff2e 	b	19534 <_svfprintf_r+0x220>
#endif
		case 'h':
#ifdef _WANT_IO_C99_FORMATS
			if (*fmt == 'h') {
   19878:	e5d93000 	ldrb	r3, [r9]
   1987c:	e3530068 	cmp	r3, #104	; 0x68
   19880:	1a000002 	bne	19890 <_svfprintf_r+0x57c>
				fmt++;
   19884:	e2899001 	add	r9, r9, #1
				flags |= CHARINT;
   19888:	e3866c02 	orr	r6, r6, #512	; 0x200
   1988c:	ea000000 	b	19894 <_svfprintf_r+0x580>
			} else
#endif
				flags |= SHORTINT;
   19890:	e3866040 	orr	r6, r6, #64	; 0x40
			goto rflag;
   19894:	eaffff26 	b	19534 <_svfprintf_r+0x220>
		case 'l':
#if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
			if (*fmt == 'l') {
   19898:	e5d93000 	ldrb	r3, [r9]
   1989c:	e353006c 	cmp	r3, #108	; 0x6c
   198a0:	1a000002 	bne	198b0 <_svfprintf_r+0x59c>
				fmt++;
   198a4:	e2899001 	add	r9, r9, #1
				flags |= QUADINT;
   198a8:	e3866020 	orr	r6, r6, #32
   198ac:	ea000000 	b	198b4 <_svfprintf_r+0x5a0>
			} else
#endif
				flags |= LONGINT;
   198b0:	e3866010 	orr	r6, r6, #16
			goto rflag;
   198b4:	eaffff1e 	b	19534 <_svfprintf_r+0x220>
		case 'q': /* extension */
			flags |= QUADINT;
   198b8:	e3866020 	orr	r6, r6, #32
			goto rflag;
   198bc:	eaffff1c 	b	19534 <_svfprintf_r+0x220>
#ifdef _WANT_IO_C99_FORMATS
		case 'j':
		  if (sizeof (intmax_t) == sizeof (long))
		    flags |= LONGINT;
		  else
		    flags |= QUADINT;
   198c0:	e3866020 	orr	r6, r6, #32
		  goto rflag;
   198c4:	eaffff1a 	b	19534 <_svfprintf_r+0x220>
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
   198c8:	e24b7f55 	sub	r7, fp, #340	; 0x154
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   198cc:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   198d0:	e2832004 	add	r2, r3, #4
   198d4:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   198d8:	e5933000 	ldr	r3, [r3]
   198dc:	e20330ff 	and	r3, r3, #255	; 0xff
   198e0:	e5c73000 	strb	r3, [r7]
				size = 1;
   198e4:	e3a03001 	mov	r3, #1
   198e8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
			}
			sign = '\0';
   198ec:	e3a03000 	mov	r3, #0
   198f0:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
			break;
   198f4:	ea000365 	b	1a690 <_svfprintf_r+0x137c>
		case 'D':  /* extension */
			flags |= LONGINT;
   198f8:	e3866010 	orr	r6, r6, #16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   198fc:	e2063020 	and	r3, r6, #32
   19900:	e3530000 	cmp	r3, #0
   19904:	0a000006 	beq	19924 <_svfprintf_r+0x610>
   19908:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1990c:	e2833007 	add	r3, r3, #7
   19910:	e3c33007 	bic	r3, r3, #7
   19914:	e2832008 	add	r2, r3, #8
   19918:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1991c:	e893000c 	ldm	r3, {r2, r3}
   19920:	ea00002a 	b	199d0 <_svfprintf_r+0x6bc>
   19924:	e2063010 	and	r3, r6, #16
   19928:	e3530000 	cmp	r3, #0
   1992c:	0a000006 	beq	1994c <_svfprintf_r+0x638>
   19930:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   19934:	e2832004 	add	r2, r3, #4
   19938:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1993c:	e5933000 	ldr	r3, [r3]
   19940:	e1a02003 	mov	r2, r3
   19944:	e1a03fc2 	asr	r3, r2, #31
   19948:	ea000020 	b	199d0 <_svfprintf_r+0x6bc>
   1994c:	e2063040 	and	r3, r6, #64	; 0x40
   19950:	e3530000 	cmp	r3, #0
   19954:	0a00000a 	beq	19984 <_svfprintf_r+0x670>
   19958:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1995c:	e2832004 	add	r2, r3, #4
   19960:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   19964:	e5933000 	ldr	r3, [r3]
   19968:	e1a03803 	lsl	r3, r3, #16
   1996c:	e1a01823 	lsr	r1, r3, #16
   19970:	e1a03801 	lsl	r3, r1, #16
   19974:	e1a03843 	asr	r3, r3, #16
   19978:	e1a02003 	mov	r2, r3
   1997c:	e1a03fc2 	asr	r3, r2, #31
   19980:	ea000012 	b	199d0 <_svfprintf_r+0x6bc>
   19984:	e2063c02 	and	r3, r6, #512	; 0x200
   19988:	e3530000 	cmp	r3, #0
   1998c:	0a000009 	beq	199b8 <_svfprintf_r+0x6a4>
   19990:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   19994:	e2832004 	add	r2, r3, #4
   19998:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1999c:	e5933000 	ldr	r3, [r3]
   199a0:	e20310ff 	and	r1, r3, #255	; 0xff
   199a4:	e1a03c01 	lsl	r3, r1, #24
   199a8:	e1a03c43 	asr	r3, r3, #24
   199ac:	e1a02003 	mov	r2, r3
   199b0:	e1a03fc2 	asr	r3, r2, #31
   199b4:	ea000005 	b	199d0 <_svfprintf_r+0x6bc>
   199b8:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   199bc:	e2832004 	add	r2, r3, #4
   199c0:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   199c4:	e5933000 	ldr	r3, [r3]
   199c8:	e1a02003 	mov	r2, r3
   199cc:	e1a03fc2 	asr	r3, r2, #31
   199d0:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   199d4:	e50b3048 	str	r3, [fp, #-72]	; 0x48
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
   199d8:	e24b304c 	sub	r3, fp, #76	; 0x4c
   199dc:	e893000c 	ldm	r3, {r2, r3}
   199e0:	e3520000 	cmp	r2, #0
   199e4:	e2d31000 	sbcs	r1, r3, #0
   199e8:	aa000007 	bge	19a0c <_svfprintf_r+0x6f8>
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
   199ec:	e24b304c 	sub	r3, fp, #76	; 0x4c
   199f0:	e893000c 	ldm	r3, {r2, r3}
   199f4:	e2722000 	rsbs	r2, r2, #0
   199f8:	e2e33000 	rsc	r3, r3, #0
   199fc:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   19a00:	e50b3048 	str	r3, [fp, #-72]	; 0x48
				sign = '-';
   19a04:	e3a0302d 	mov	r3, #45	; 0x2d
   19a08:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
			}
			base = DEC;
   19a0c:	e3a03001 	mov	r3, #1
   19a10:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
			goto number;
   19a14:	ea00025a 	b	1a384 <_svfprintf_r+0x1070>
		case 'E':
		case 'f':
		case 'g':
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
   19a18:	e2063008 	and	r3, r6, #8
   19a1c:	e3530000 	cmp	r3, #0
   19a20:	0a000008 	beq	19a48 <_svfprintf_r+0x734>
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
   19a24:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   19a28:	e2833007 	add	r3, r3, #7
   19a2c:	e3c33007 	bic	r3, r3, #7
   19a30:	e2832008 	add	r2, r3, #8
   19a34:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   19a38:	e893000c 	ldm	r3, {r2, r3}
   19a3c:	e50b2094 	str	r2, [fp, #-148]	; 0x94
   19a40:	e50b3090 	str	r3, [fp, #-144]	; 0x90
   19a44:	ea000007 	b	19a68 <_svfprintf_r+0x754>
			} else {
				_fpvalue = GET_ARG (N, ap, double);
   19a48:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   19a4c:	e2833007 	add	r3, r3, #7
   19a50:	e3c33007 	bic	r3, r3, #7
   19a54:	e2832008 	add	r2, r3, #8
   19a58:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   19a5c:	e893000c 	ldm	r3, {r2, r3}
   19a60:	e50b2094 	str	r2, [fp, #-148]	; 0x94
   19a64:	e50b3090 	str	r3, [fp, #-144]	; 0x90

			   If the output is infinite or NaN, leading
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
   19a68:	e24b3094 	sub	r3, fp, #148	; 0x94
   19a6c:	e893000c 	ldm	r3, {r2, r3}
   19a70:	e1a00002 	mov	r0, r2
   19a74:	e1a01003 	mov	r1, r3
   19a78:	eb002e46 	bl	25398 <__fpclassifyd>
   19a7c:	e1a03000 	mov	r3, r0
   19a80:	e3530001 	cmp	r3, #1
   19a84:	1a000014 	bne	19adc <_svfprintf_r+0x7c8>
				if (_fpvalue < 0)
   19a88:	e24b3094 	sub	r3, fp, #148	; 0x94
   19a8c:	e893000c 	ldm	r3, {r2, r3}
   19a90:	e1a00002 	mov	r0, r2
   19a94:	e1a01003 	mov	r1, r3
   19a98:	e3a02000 	mov	r2, #0
   19a9c:	e3a03000 	mov	r3, #0
   19aa0:	ebffed76 	bl	15080 <__aeabi_dcmplt>
   19aa4:	e1a03000 	mov	r3, r0
   19aa8:	e3530000 	cmp	r3, #0
   19aac:	0a000001 	beq	19ab8 <_svfprintf_r+0x7a4>
					sign = '-';
   19ab0:	e3a0302d 	mov	r3, #45	; 0x2d
   19ab4:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
   19ab8:	e3580047 	cmp	r8, #71	; 0x47
   19abc:	ca000001 	bgt	19ac8 <_svfprintf_r+0x7b4>
					cp = "INF";
   19ac0:	e59f7fa8 	ldr	r7, [pc, #4008]	; 1aa70 <_svfprintf_r+0x175c>
   19ac4:	ea000000 	b	19acc <_svfprintf_r+0x7b8>
				else
					cp = "inf";
   19ac8:	e59f7fa4 	ldr	r7, [pc, #4004]	; 1aa74 <_svfprintf_r+0x1760>
				size = 3;
   19acc:	e3a03003 	mov	r3, #3
   19ad0:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
				flags &= ~ZEROPAD;
   19ad4:	e3c66080 	bic	r6, r6, #128	; 0x80
				break;
   19ad8:	ea0002ec 	b	1a690 <_svfprintf_r+0x137c>
			}
			if (isnan (_fpvalue)) {
   19adc:	e24b3094 	sub	r3, fp, #148	; 0x94
   19ae0:	e893000c 	ldm	r3, {r2, r3}
   19ae4:	e1a00002 	mov	r0, r2
   19ae8:	e1a01003 	mov	r1, r3
   19aec:	eb002e29 	bl	25398 <__fpclassifyd>
   19af0:	e1a03000 	mov	r3, r0
   19af4:	e3530000 	cmp	r3, #0
   19af8:	1a000008 	bne	19b20 <_svfprintf_r+0x80c>
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
   19afc:	e3580047 	cmp	r8, #71	; 0x47
   19b00:	ca000001 	bgt	19b0c <_svfprintf_r+0x7f8>
					cp = "NAN";
   19b04:	e59f7f6c 	ldr	r7, [pc, #3948]	; 1aa78 <_svfprintf_r+0x1764>
   19b08:	ea000000 	b	19b10 <_svfprintf_r+0x7fc>
				else
					cp = "nan";
   19b0c:	e59f7f68 	ldr	r7, [pc, #3944]	; 1aa7c <_svfprintf_r+0x1768>
				size = 3;
   19b10:	e3a03003 	mov	r3, #3
   19b14:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
				flags &= ~ZEROPAD;
   19b18:	e3c66080 	bic	r6, r6, #128	; 0x80
				break;
   19b1c:	ea0002db 	b	1a690 <_svfprintf_r+0x137c>
				break;
			}
# endif /* !_NO_LONGDBL */

# ifdef _WANT_IO_C99_FORMATS
			if (ch == 'a' || ch == 'A') {
   19b20:	e3580061 	cmp	r8, #97	; 0x61
   19b24:	0a000001 	beq	19b30 <_svfprintf_r+0x81c>
   19b28:	e3580041 	cmp	r8, #65	; 0x41
   19b2c:	1a000020 	bne	19bb4 <_svfprintf_r+0x8a0>
				ox[0] = '0';
   19b30:	e3a03030 	mov	r3, #48	; 0x30
   19b34:	e54b3158 	strb	r3, [fp, #-344]	; 0x158
				ox[1] = ch == 'a' ? 'x' : 'X';
   19b38:	e3580061 	cmp	r8, #97	; 0x61
   19b3c:	1a000001 	bne	19b48 <_svfprintf_r+0x834>
   19b40:	e3a03078 	mov	r3, #120	; 0x78
   19b44:	ea000000 	b	19b4c <_svfprintf_r+0x838>
   19b48:	e3a03058 	mov	r3, #88	; 0x58
   19b4c:	e54b3157 	strb	r3, [fp, #-343]	; 0x157
				flags |= HEXPREFIX;
   19b50:	e3866002 	orr	r6, r6, #2
				if (prec >= BUF)
   19b54:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   19b58:	e3530063 	cmp	r3, #99	; 0x63
   19b5c:	da000012 	ble	19bac <_svfprintf_r+0x898>
				  {
				    if ((malloc_buf =
					 (char *)_malloc_r (data, prec + 1))
   19b60:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   19b64:	e2833001 	add	r3, r3, #1
				ox[0] = '0';
				ox[1] = ch == 'a' ? 'x' : 'X';
				flags |= HEXPREFIX;
				if (prec >= BUF)
				  {
				    if ((malloc_buf =
   19b68:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   19b6c:	e1a01003 	mov	r1, r3
   19b70:	ebfff7cf 	bl	17ab4 <_malloc_r>
   19b74:	e50b0064 	str	r0, [fp, #-100]	; 0x64
   19b78:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   19b7c:	e3530000 	cmp	r3, #0
   19b80:	1a000007 	bne	19ba4 <_svfprintf_r+0x890>
					 (char *)_malloc_r (data, prec + 1))
					== NULL)
				      {
					fp->_flags |= __SERR;
   19b84:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   19b88:	e1d330bc 	ldrh	r3, [r3, #12]
   19b8c:	e3833040 	orr	r3, r3, #64	; 0x40
   19b90:	e1a03803 	lsl	r3, r3, #16
   19b94:	e1a02823 	lsr	r2, r3, #16
   19b98:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   19b9c:	e1c320bc 	strh	r2, [r3, #12]
					goto error;
   19ba0:	ea0007be 	b	1baa0 <_svfprintf_r+0x278c>
				      }
				    cp = malloc_buf;
   19ba4:	e51b7064 	ldr	r7, [fp, #-100]	; 0x64
# ifdef _WANT_IO_C99_FORMATS
			if (ch == 'a' || ch == 'A') {
				ox[0] = '0';
				ox[1] = ch == 'a' ? 'x' : 'X';
				flags |= HEXPREFIX;
				if (prec >= BUF)
   19ba8:	ea000010 	b	19bf0 <_svfprintf_r+0x8dc>
					goto error;
				      }
				    cp = malloc_buf;
				  }
				else
				  cp = buf;
   19bac:	e24b7f55 	sub	r7, fp, #340	; 0x154
# ifdef _WANT_IO_C99_FORMATS
			if (ch == 'a' || ch == 'A') {
				ox[0] = '0';
				ox[1] = ch == 'a' ? 'x' : 'X';
				flags |= HEXPREFIX;
				if (prec >= BUF)
   19bb0:	ea00000e 	b	19bf0 <_svfprintf_r+0x8dc>
				  }
				else
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
   19bb4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   19bb8:	e3730001 	cmn	r3, #1
   19bbc:	1a000002 	bne	19bcc <_svfprintf_r+0x8b8>
				prec = DEFPREC;
   19bc0:	e3a03006 	mov	r3, #6
   19bc4:	e50b3028 	str	r3, [fp, #-40]	; 0x28
   19bc8:	ea000008 	b	19bf0 <_svfprintf_r+0x8dc>
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
   19bcc:	e3580067 	cmp	r8, #103	; 0x67
   19bd0:	0a000001 	beq	19bdc <_svfprintf_r+0x8c8>
   19bd4:	e3580047 	cmp	r8, #71	; 0x47
   19bd8:	1a000004 	bne	19bf0 <_svfprintf_r+0x8dc>
   19bdc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   19be0:	e3530000 	cmp	r3, #0
   19be4:	1a000001 	bne	19bf0 <_svfprintf_r+0x8dc>
				prec = 1;
   19be8:	e3a03001 	mov	r3, #1
   19bec:	e50b3028 	str	r3, [fp, #-40]	; 0x28
			}

			flags |= FPT;
   19bf0:	e3866c01 	orr	r6, r6, #256	; 0x100

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
   19bf4:	e24b3094 	sub	r3, fp, #148	; 0x94
   19bf8:	e893000c 	ldm	r3, {r2, r3}
   19bfc:	e51b1028 	ldr	r1, [fp, #-40]	; 0x28
   19c00:	e58d1000 	str	r1, [sp]
   19c04:	e58d6004 	str	r6, [sp, #4]
   19c08:	e24b1086 	sub	r1, fp, #134	; 0x86
   19c0c:	e58d1008 	str	r1, [sp, #8]
   19c10:	e24b1098 	sub	r1, fp, #152	; 0x98
   19c14:	e58d100c 	str	r1, [sp, #12]
   19c18:	e58d8010 	str	r8, [sp, #16]
   19c1c:	e24b10a4 	sub	r1, fp, #164	; 0xa4
   19c20:	e58d1014 	str	r1, [sp, #20]
   19c24:	e58d7018 	str	r7, [sp, #24]
   19c28:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   19c2c:	eb0007b0 	bl	1baf4 <cvt>
   19c30:	e1a07000 	mov	r7, r0
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
   19c34:	e3580067 	cmp	r8, #103	; 0x67
   19c38:	0a000001 	beq	19c44 <_svfprintf_r+0x930>
   19c3c:	e3580047 	cmp	r8, #71	; 0x47
   19c40:	1a00000a 	bne	19c70 <_svfprintf_r+0x95c>
				if (expt <= -4 || expt > prec)
   19c44:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   19c48:	e3730003 	cmn	r3, #3
   19c4c:	ba000003 	blt	19c60 <_svfprintf_r+0x94c>
   19c50:	e51b2098 	ldr	r2, [fp, #-152]	; 0x98
   19c54:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   19c58:	e1520003 	cmp	r2, r3
   19c5c:	da000001 	ble	19c68 <_svfprintf_r+0x954>
					ch -= 2; /* 'e' or 'E' */
   19c60:	e2488002 	sub	r8, r8, #2

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
				if (expt <= -4 || expt > prec)
   19c64:	ea000004 	b	19c7c <_svfprintf_r+0x968>
					ch -= 2; /* 'e' or 'E' */
				else
					ch = 'g';
   19c68:	e3a08067 	mov	r8, #103	; 0x67

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
				if (expt <= -4 || expt > prec)
   19c6c:	ea000002 	b	19c7c <_svfprintf_r+0x968>
					ch -= 2; /* 'e' or 'E' */
				else
					ch = 'g';
			}
# ifdef _WANT_IO_C99_FORMATS
			else if (ch == 'F')
   19c70:	e3580046 	cmp	r8, #70	; 0x46
   19c74:	1a000000 	bne	19c7c <_svfprintf_r+0x968>
				ch = 'f';
   19c78:	e3a08066 	mov	r8, #102	; 0x66
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
   19c7c:	e3580065 	cmp	r8, #101	; 0x65
   19c80:	ca000018 	bgt	19ce8 <_svfprintf_r+0x9d4>
				--expt;
   19c84:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   19c88:	e2433001 	sub	r3, r3, #1
   19c8c:	e50b3098 	str	r3, [fp, #-152]	; 0x98
				expsize = exponent (expstr, expt, ch);
   19c90:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   19c94:	e24b20a0 	sub	r2, fp, #160	; 0xa0
   19c98:	e1a00002 	mov	r0, r2
   19c9c:	e1a01003 	mov	r1, r3
   19ca0:	e1a02008 	mov	r2, r8
   19ca4:	eb0008b8 	bl	1bf8c <exponent>
   19ca8:	e50b0038 	str	r0, [fp, #-56]	; 0x38
				size = expsize + ndig;
   19cac:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   19cb0:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   19cb4:	e0823003 	add	r3, r2, r3
   19cb8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
				if (ndig > 1 || flags & ALT)
   19cbc:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   19cc0:	e3530001 	cmp	r3, #1
   19cc4:	ca000002 	bgt	19cd4 <_svfprintf_r+0x9c0>
   19cc8:	e2063001 	and	r3, r6, #1
   19ccc:	e3530000 	cmp	r3, #0
   19cd0:	0a000002 	beq	19ce0 <_svfprintf_r+0x9cc>
					++size;
   19cd4:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   19cd8:	e2833001 	add	r3, r3, #1
   19cdc:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
# ifdef _WANT_IO_C99_FORMATS
				flags &= ~GROUPING;
   19ce0:	e3c66b01 	bic	r6, r6, #1024	; 0x400
   19ce4:	ea00006c 	b	19e9c <_svfprintf_r+0xb88>
# endif
			} else {
				if (ch == 'f') {		/* f fmt */
   19ce8:	e3580066 	cmp	r8, #102	; 0x66
   19cec:	1a00001c 	bne	19d64 <_svfprintf_r+0xa50>
					if (expt > 0) {
   19cf0:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   19cf4:	e3530000 	cmp	r3, #0
   19cf8:	da00000d 	ble	19d34 <_svfprintf_r+0xa20>
						size = expt;
   19cfc:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   19d00:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
						if (prec || flags & ALT)
   19d04:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   19d08:	e3530000 	cmp	r3, #0
   19d0c:	1a000002 	bne	19d1c <_svfprintf_r+0xa08>
   19d10:	e2063001 	and	r3, r6, #1
   19d14:	e3530000 	cmp	r3, #0
   19d18:	0a000028 	beq	19dc0 <_svfprintf_r+0xaac>
							size += prec + 1;
   19d1c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   19d20:	e2833001 	add	r3, r3, #1
   19d24:	e51b205c 	ldr	r2, [fp, #-92]	; 0x5c
   19d28:	e0823003 	add	r3, r2, r3
   19d2c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   19d30:	ea000022 	b	19dc0 <_svfprintf_r+0xaac>
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
   19d34:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   19d38:	e3530000 	cmp	r3, #0
   19d3c:	1a000002 	bne	19d4c <_svfprintf_r+0xa38>
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
   19d40:	e2063001 	and	r3, r6, #1
   19d44:	e3530000 	cmp	r3, #0
   19d48:	0a000002 	beq	19d58 <_svfprintf_r+0xa44>
							  ? prec + 2
							  : 1;
   19d4c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   19d50:	e2833002 	add	r3, r3, #2
   19d54:	ea000000 	b	19d5c <_svfprintf_r+0xa48>
   19d58:	e3a03001 	mov	r3, #1
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
   19d5c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   19d60:	ea000016 	b	19dc0 <_svfprintf_r+0xaac>
							  ? prec + 2
							  : 1;
				} else if (expt >= ndig) { /* fixed g fmt */
   19d64:	e51b2098 	ldr	r2, [fp, #-152]	; 0x98
   19d68:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   19d6c:	e1520003 	cmp	r2, r3
   19d70:	ba000008 	blt	19d98 <_svfprintf_r+0xa84>
					size = expt;
   19d74:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   19d78:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
					if (flags & ALT)
   19d7c:	e2063001 	and	r3, r6, #1
   19d80:	e3530000 	cmp	r3, #0
   19d84:	0a00000d 	beq	19dc0 <_svfprintf_r+0xaac>
						++size;
   19d88:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   19d8c:	e2833001 	add	r3, r3, #1
   19d90:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   19d94:	ea000009 	b	19dc0 <_svfprintf_r+0xaac>
				} else
					size = ndig + (expt > 0 ?
   19d98:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
						1 : 2 - expt);
   19d9c:	e3530000 	cmp	r3, #0
   19da0:	ca000002 	bgt	19db0 <_svfprintf_r+0xa9c>
   19da4:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   19da8:	e2633002 	rsb	r3, r3, #2
   19dac:	ea000000 	b	19db4 <_svfprintf_r+0xaa0>
   19db0:	e3a03001 	mov	r3, #1
				} else if (expt >= ndig) { /* fixed g fmt */
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
   19db4:	e51b20a4 	ldr	r2, [fp, #-164]	; 0xa4
   19db8:	e0833002 	add	r3, r3, r2
   19dbc:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
						1 : 2 - expt);
# ifdef _WANT_IO_C99_FORMATS
				if ((flags & GROUPING) && expt > 0) {
   19dc0:	e2063b01 	and	r3, r6, #1024	; 0x400
   19dc4:	e3530000 	cmp	r3, #0
   19dc8:	0a000031 	beq	19e94 <_svfprintf_r+0xb80>
   19dcc:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   19dd0:	e3530000 	cmp	r3, #0
   19dd4:	da00002e 	ble	19e94 <_svfprintf_r+0xb80>
					/* space for thousands' grouping */
					nseps = nrepeats = 0;
   19dd8:	e3a03000 	mov	r3, #0
   19ddc:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   19de0:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   19de4:	e50b3040 	str	r3, [fp, #-64]	; 0x40
					lead = expt;
   19de8:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   19dec:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
					while (*grouping != CHAR_MAX) {
   19df0:	ea00001a 	b	19e60 <_svfprintf_r+0xb4c>
						if (lead <= *grouping)
   19df4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   19df8:	e5d33000 	ldrb	r3, [r3]
   19dfc:	e1a02003 	mov	r2, r3
   19e00:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   19e04:	e1520003 	cmp	r2, r3
   19e08:	ba000000 	blt	19e10 <_svfprintf_r+0xafc>
							break;
   19e0c:	ea000017 	b	19e70 <_svfprintf_r+0xb5c>
						lead -= *grouping;
   19e10:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   19e14:	e5d33000 	ldrb	r3, [r3]
   19e18:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   19e1c:	e0633002 	rsb	r3, r3, r2
   19e20:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
						if (grouping[1]) {
   19e24:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   19e28:	e2833001 	add	r3, r3, #1
   19e2c:	e5d33000 	ldrb	r3, [r3]
   19e30:	e3530000 	cmp	r3, #0
   19e34:	0a000006 	beq	19e54 <_svfprintf_r+0xb40>
							nseps++;
   19e38:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   19e3c:	e2833001 	add	r3, r3, #1
   19e40:	e50b3040 	str	r3, [fp, #-64]	; 0x40
							grouping++;
   19e44:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   19e48:	e2833001 	add	r3, r3, #1
   19e4c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   19e50:	ea000002 	b	19e60 <_svfprintf_r+0xb4c>
						} else
							nrepeats++;
   19e54:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   19e58:	e2833001 	add	r3, r3, #1
   19e5c:	e50b3044 	str	r3, [fp, #-68]	; 0x44
# ifdef _WANT_IO_C99_FORMATS
				if ((flags & GROUPING) && expt > 0) {
					/* space for thousands' grouping */
					nseps = nrepeats = 0;
					lead = expt;
					while (*grouping != CHAR_MAX) {
   19e60:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   19e64:	e5d33000 	ldrb	r3, [r3]
   19e68:	e35300ff 	cmp	r3, #255	; 0xff
   19e6c:	1affffe0 	bne	19df4 <_svfprintf_r+0xae0>
							nseps++;
							grouping++;
						} else
							nrepeats++;
					}
					size += (nseps + nrepeats) * thsnd_len;
   19e70:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   19e74:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   19e78:	e0823003 	add	r3, r2, r3
   19e7c:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   19e80:	e0020293 	mul	r2, r3, r2
   19e84:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   19e88:	e0823003 	add	r3, r2, r3
   19e8c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   19e90:	ea000001 	b	19e9c <_svfprintf_r+0xb88>
				} else
# endif
					lead = expt;
   19e94:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   19e98:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
			}

			if (softsign)
   19e9c:	e55b3086 	ldrb	r3, [fp, #-134]	; 0x86
   19ea0:	e3530000 	cmp	r3, #0
   19ea4:	0a000002 	beq	19eb4 <_svfprintf_r+0xba0>
				sign = '-';
   19ea8:	e3a0302d 	mov	r3, #45	; 0x2d
   19eac:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
			break;
   19eb0:	ea0001f6 	b	1a690 <_svfprintf_r+0x137c>
   19eb4:	ea0001f5 	b	1a690 <_svfprintf_r+0x137c>
			flags &= ~LONGINT;
			goto string;
#endif
		case 'n':
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
   19eb8:	e2063020 	and	r3, r6, #32
   19ebc:	e3530000 	cmp	r3, #0
   19ec0:	0a000008 	beq	19ee8 <_svfprintf_r+0xbd4>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
   19ec4:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   19ec8:	e2832004 	add	r2, r3, #4
   19ecc:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   19ed0:	e5931000 	ldr	r1, [r3]
   19ed4:	e51b3020 	ldr	r3, [fp, #-32]
   19ed8:	e1a02003 	mov	r2, r3
   19edc:	e1a03fc2 	asr	r3, r2, #31
   19ee0:	e881000c 	stm	r1, {r2, r3}
   19ee4:	ea000027 	b	19f88 <_svfprintf_r+0xc74>
			else
#endif
			if (flags & LONGINT)
   19ee8:	e2063010 	and	r3, r6, #16
   19eec:	e3530000 	cmp	r3, #0
   19ef0:	0a000006 	beq	19f10 <_svfprintf_r+0xbfc>
				*GET_ARG (N, ap, long_ptr_t) = ret;
   19ef4:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   19ef8:	e2832004 	add	r2, r3, #4
   19efc:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   19f00:	e5933000 	ldr	r3, [r3]
   19f04:	e51b2020 	ldr	r2, [fp, #-32]
   19f08:	e5832000 	str	r2, [r3]
   19f0c:	ea00001d 	b	19f88 <_svfprintf_r+0xc74>
			else if (flags & SHORTINT)
   19f10:	e2063040 	and	r3, r6, #64	; 0x40
   19f14:	e3530000 	cmp	r3, #0
   19f18:	0a000008 	beq	19f40 <_svfprintf_r+0xc2c>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   19f1c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   19f20:	e2832004 	add	r2, r3, #4
   19f24:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   19f28:	e5933000 	ldr	r3, [r3]
   19f2c:	e51b2020 	ldr	r2, [fp, #-32]
   19f30:	e1a02802 	lsl	r2, r2, #16
   19f34:	e1a02822 	lsr	r2, r2, #16
   19f38:	e1c320b0 	strh	r2, [r3]
   19f3c:	ea000011 	b	19f88 <_svfprintf_r+0xc74>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
   19f40:	e2063c02 	and	r3, r6, #512	; 0x200
   19f44:	e3530000 	cmp	r3, #0
   19f48:	0a000007 	beq	19f6c <_svfprintf_r+0xc58>
				*GET_ARG (N, ap, char_ptr_t) = ret;
   19f4c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   19f50:	e2832004 	add	r2, r3, #4
   19f54:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   19f58:	e5933000 	ldr	r3, [r3]
   19f5c:	e51b2020 	ldr	r2, [fp, #-32]
   19f60:	e20220ff 	and	r2, r2, #255	; 0xff
   19f64:	e5c32000 	strb	r2, [r3]
   19f68:	ea000006 	b	19f88 <_svfprintf_r+0xc74>
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
   19f6c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   19f70:	e2832004 	add	r2, r3, #4
   19f74:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   19f78:	e5933000 	ldr	r3, [r3]
   19f7c:	e51b2020 	ldr	r2, [fp, #-32]
   19f80:	e5832000 	str	r2, [r3]
			continue;	/* no output */
   19f84:	ea0006b5 	b	1ba60 <_svfprintf_r+0x274c>
   19f88:	ea0006b4 	b	1ba60 <_svfprintf_r+0x274c>
		case 'O': /* extension */
			flags |= LONGINT;
   19f8c:	e3866010 	orr	r6, r6, #16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   19f90:	e2063020 	and	r3, r6, #32
   19f94:	e3530000 	cmp	r3, #0
   19f98:	0a000006 	beq	19fb8 <_svfprintf_r+0xca4>
   19f9c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   19fa0:	e2833007 	add	r3, r3, #7
   19fa4:	e3c33007 	bic	r3, r3, #7
   19fa8:	e2832008 	add	r2, r3, #8
   19fac:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   19fb0:	e893000c 	ldm	r3, {r2, r3}
   19fb4:	ea000027 	b	1a058 <_svfprintf_r+0xd44>
   19fb8:	e2063010 	and	r3, r6, #16
   19fbc:	e3530000 	cmp	r3, #0
   19fc0:	0a000006 	beq	19fe0 <_svfprintf_r+0xccc>
   19fc4:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   19fc8:	e2832004 	add	r2, r3, #4
   19fcc:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   19fd0:	e5933000 	ldr	r3, [r3]
   19fd4:	e1a02003 	mov	r2, r3
   19fd8:	e3a03000 	mov	r3, #0
   19fdc:	ea00001d 	b	1a058 <_svfprintf_r+0xd44>
   19fe0:	e2063040 	and	r3, r6, #64	; 0x40
   19fe4:	e3530000 	cmp	r3, #0
   19fe8:	0a000009 	beq	1a014 <_svfprintf_r+0xd00>
   19fec:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   19ff0:	e2832004 	add	r2, r3, #4
   19ff4:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   19ff8:	e5933000 	ldr	r3, [r3]
   19ffc:	e1a03803 	lsl	r3, r3, #16
   1a000:	e1a01823 	lsr	r1, r3, #16
   1a004:	e1a03001 	mov	r3, r1
   1a008:	e1a02003 	mov	r2, r3
   1a00c:	e3a03000 	mov	r3, #0
   1a010:	ea000010 	b	1a058 <_svfprintf_r+0xd44>
   1a014:	e2063c02 	and	r3, r6, #512	; 0x200
   1a018:	e3530000 	cmp	r3, #0
   1a01c:	0a000007 	beq	1a040 <_svfprintf_r+0xd2c>
   1a020:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1a024:	e2832004 	add	r2, r3, #4
   1a028:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1a02c:	e5933000 	ldr	r3, [r3]
   1a030:	e20330ff 	and	r3, r3, #255	; 0xff
   1a034:	e20320ff 	and	r2, r3, #255	; 0xff
   1a038:	e3a03000 	mov	r3, #0
   1a03c:	ea000005 	b	1a058 <_svfprintf_r+0xd44>
   1a040:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1a044:	e2832004 	add	r2, r3, #4
   1a048:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1a04c:	e5933000 	ldr	r3, [r3]
   1a050:	e1a02003 	mov	r2, r3
   1a054:	e3a03000 	mov	r3, #0
   1a058:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1a05c:	e50b3048 	str	r3, [fp, #-72]	; 0x48
			base = OCT;
   1a060:	e3a03000 	mov	r3, #0
   1a064:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
   1a068:	e3c66b01 	bic	r6, r6, #1024	; 0x400
#endif
			goto nosign;
   1a06c:	ea0000c2 	b	1a37c <_svfprintf_r+0x1068>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   1a070:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1a074:	e2832004 	add	r2, r3, #4
   1a078:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1a07c:	e5933000 	ldr	r3, [r3]
   1a080:	e1a02003 	mov	r2, r3
   1a084:	e3a03000 	mov	r3, #0
   1a088:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1a08c:	e50b3048 	str	r3, [fp, #-72]	; 0x48
			base = HEX;
   1a090:	e3a03002 	mov	r3, #2
   1a094:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
			xdigs = "0123456789abcdef";
   1a098:	e59f39e0 	ldr	r3, [pc, #2528]	; 1aa80 <_svfprintf_r+0x176c>
   1a09c:	e50b3060 	str	r3, [fp, #-96]	; 0x60
			flags |= HEXPREFIX;
   1a0a0:	e3866002 	orr	r6, r6, #2
			ox[0] = '0';
   1a0a4:	e3a03030 	mov	r3, #48	; 0x30
   1a0a8:	e54b3158 	strb	r3, [fp, #-344]	; 0x158
			ox[1] = ch = 'x';
   1a0ac:	e3a08078 	mov	r8, #120	; 0x78
   1a0b0:	e3a03078 	mov	r3, #120	; 0x78
   1a0b4:	e54b3157 	strb	r3, [fp, #-343]	; 0x157
			goto nosign;
   1a0b8:	ea0000af 	b	1a37c <_svfprintf_r+0x1068>
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   1a0bc:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1a0c0:	e2832004 	add	r2, r3, #4
   1a0c4:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1a0c8:	e5937000 	ldr	r7, [r3]
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
   1a0cc:	e3a03000 	mov	r3, #0
   1a0d0:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
   1a0d4:	e3570000 	cmp	r7, #0
   1a0d8:	1a000006 	bne	1a0f8 <_svfprintf_r+0xde4>
				cp = "(null)";
   1a0dc:	e59f79a0 	ldr	r7, [pc, #2464]	; 1aa84 <_svfprintf_r+0x1770>
				size = ((unsigned) prec > 6U) ? 6 : prec;
   1a0e0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1a0e4:	e3530006 	cmp	r3, #6
   1a0e8:	31a03003 	movcc	r3, r3
   1a0ec:	23a03006 	movcs	r3, #6
   1a0f0:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   1a0f4:	ea00001f 	b	1a178 <_svfprintf_r+0xe64>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
   1a0f8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1a0fc:	e3530000 	cmp	r3, #0
   1a100:	ba000017 	blt	1a164 <_svfprintf_r+0xe50>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
   1a104:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1a108:	e1a00007 	mov	r0, r7
   1a10c:	e3a01000 	mov	r1, #0
   1a110:	e1a02003 	mov	r2, r3
   1a114:	eb00213c 	bl	2260c <memchr>
   1a118:	e50b0080 	str	r0, [fp, #-128]	; 0x80

				if (p != NULL) {
   1a11c:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
   1a120:	e3530000 	cmp	r3, #0
   1a124:	0a00000a 	beq	1a154 <_svfprintf_r+0xe40>
					size = p - cp;
   1a128:	e51b2080 	ldr	r2, [fp, #-128]	; 0x80
   1a12c:	e1a03007 	mov	r3, r7
   1a130:	e0633002 	rsb	r3, r3, r2
   1a134:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
					if (size > prec)
   1a138:	e51b205c 	ldr	r2, [fp, #-92]	; 0x5c
   1a13c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1a140:	e1520003 	cmp	r2, r3
   1a144:	da000005 	ble	1a160 <_svfprintf_r+0xe4c>
						size = prec;
   1a148:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1a14c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   1a150:	ea000008 	b	1a178 <_svfprintf_r+0xe64>
				} else
					size = prec;
   1a154:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1a158:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   1a15c:	ea000005 	b	1a178 <_svfprintf_r+0xe64>
   1a160:	ea000004 	b	1a178 <_svfprintf_r+0xe64>
			} else
				size = strlen (cp);
   1a164:	e1a00007 	mov	r0, r7
   1a168:	ebfffc50 	bl	192b0 <strlen>
   1a16c:	e1a03000 	mov	r3, r0
   1a170:	e50b305c 	str	r3, [fp, #-92]	; 0x5c

			break;
   1a174:	ea000145 	b	1a690 <_svfprintf_r+0x137c>
   1a178:	ea000144 	b	1a690 <_svfprintf_r+0x137c>
		case 'U': /* extension */
			flags |= LONGINT;
   1a17c:	e3866010 	orr	r6, r6, #16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   1a180:	e2063020 	and	r3, r6, #32
   1a184:	e3530000 	cmp	r3, #0
   1a188:	0a000006 	beq	1a1a8 <_svfprintf_r+0xe94>
   1a18c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1a190:	e2833007 	add	r3, r3, #7
   1a194:	e3c33007 	bic	r3, r3, #7
   1a198:	e2832008 	add	r2, r3, #8
   1a19c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1a1a0:	e893000c 	ldm	r3, {r2, r3}
   1a1a4:	ea000027 	b	1a248 <_svfprintf_r+0xf34>
   1a1a8:	e2063010 	and	r3, r6, #16
   1a1ac:	e3530000 	cmp	r3, #0
   1a1b0:	0a000006 	beq	1a1d0 <_svfprintf_r+0xebc>
   1a1b4:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1a1b8:	e2832004 	add	r2, r3, #4
   1a1bc:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1a1c0:	e5933000 	ldr	r3, [r3]
   1a1c4:	e1a02003 	mov	r2, r3
   1a1c8:	e3a03000 	mov	r3, #0
   1a1cc:	ea00001d 	b	1a248 <_svfprintf_r+0xf34>
   1a1d0:	e2063040 	and	r3, r6, #64	; 0x40
   1a1d4:	e3530000 	cmp	r3, #0
   1a1d8:	0a000009 	beq	1a204 <_svfprintf_r+0xef0>
   1a1dc:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1a1e0:	e2832004 	add	r2, r3, #4
   1a1e4:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1a1e8:	e5933000 	ldr	r3, [r3]
   1a1ec:	e1a03803 	lsl	r3, r3, #16
   1a1f0:	e1a01823 	lsr	r1, r3, #16
   1a1f4:	e1a03001 	mov	r3, r1
   1a1f8:	e1a02003 	mov	r2, r3
   1a1fc:	e3a03000 	mov	r3, #0
   1a200:	ea000010 	b	1a248 <_svfprintf_r+0xf34>
   1a204:	e2063c02 	and	r3, r6, #512	; 0x200
   1a208:	e3530000 	cmp	r3, #0
   1a20c:	0a000007 	beq	1a230 <_svfprintf_r+0xf1c>
   1a210:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1a214:	e2832004 	add	r2, r3, #4
   1a218:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1a21c:	e5933000 	ldr	r3, [r3]
   1a220:	e20330ff 	and	r3, r3, #255	; 0xff
   1a224:	e20320ff 	and	r2, r3, #255	; 0xff
   1a228:	e3a03000 	mov	r3, #0
   1a22c:	ea000005 	b	1a248 <_svfprintf_r+0xf34>
   1a230:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1a234:	e2832004 	add	r2, r3, #4
   1a238:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1a23c:	e5933000 	ldr	r3, [r3]
   1a240:	e1a02003 	mov	r2, r3
   1a244:	e3a03000 	mov	r3, #0
   1a248:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1a24c:	e50b3048 	str	r3, [fp, #-72]	; 0x48
			base = DEC;
   1a250:	e3a03001 	mov	r3, #1
   1a254:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
			goto nosign;
   1a258:	ea000047 	b	1a37c <_svfprintf_r+0x1068>
		case 'X':
			xdigs = "0123456789ABCDEF";
   1a25c:	e59f3824 	ldr	r3, [pc, #2084]	; 1aa88 <_svfprintf_r+0x1774>
   1a260:	e50b3060 	str	r3, [fp, #-96]	; 0x60
			goto hex;
   1a264:	ea000001 	b	1a270 <_svfprintf_r+0xf5c>
		case 'x':
			xdigs = "0123456789abcdef";
   1a268:	e59f3810 	ldr	r3, [pc, #2064]	; 1aa80 <_svfprintf_r+0x176c>
   1a26c:	e50b3060 	str	r3, [fp, #-96]	; 0x60
hex:			_uquad = UARG ();
   1a270:	e2063020 	and	r3, r6, #32
   1a274:	e3530000 	cmp	r3, #0
   1a278:	0a000006 	beq	1a298 <_svfprintf_r+0xf84>
   1a27c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1a280:	e2833007 	add	r3, r3, #7
   1a284:	e3c33007 	bic	r3, r3, #7
   1a288:	e2832008 	add	r2, r3, #8
   1a28c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1a290:	e893000c 	ldm	r3, {r2, r3}
   1a294:	ea000027 	b	1a338 <_svfprintf_r+0x1024>
   1a298:	e2063010 	and	r3, r6, #16
   1a29c:	e3530000 	cmp	r3, #0
   1a2a0:	0a000006 	beq	1a2c0 <_svfprintf_r+0xfac>
   1a2a4:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1a2a8:	e2832004 	add	r2, r3, #4
   1a2ac:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1a2b0:	e5933000 	ldr	r3, [r3]
   1a2b4:	e1a02003 	mov	r2, r3
   1a2b8:	e3a03000 	mov	r3, #0
   1a2bc:	ea00001d 	b	1a338 <_svfprintf_r+0x1024>
   1a2c0:	e2063040 	and	r3, r6, #64	; 0x40
   1a2c4:	e3530000 	cmp	r3, #0
   1a2c8:	0a000009 	beq	1a2f4 <_svfprintf_r+0xfe0>
   1a2cc:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1a2d0:	e2832004 	add	r2, r3, #4
   1a2d4:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1a2d8:	e5933000 	ldr	r3, [r3]
   1a2dc:	e1a03803 	lsl	r3, r3, #16
   1a2e0:	e1a01823 	lsr	r1, r3, #16
   1a2e4:	e1a03001 	mov	r3, r1
   1a2e8:	e1a02003 	mov	r2, r3
   1a2ec:	e3a03000 	mov	r3, #0
   1a2f0:	ea000010 	b	1a338 <_svfprintf_r+0x1024>
   1a2f4:	e2063c02 	and	r3, r6, #512	; 0x200
   1a2f8:	e3530000 	cmp	r3, #0
   1a2fc:	0a000007 	beq	1a320 <_svfprintf_r+0x100c>
   1a300:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1a304:	e2832004 	add	r2, r3, #4
   1a308:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1a30c:	e5933000 	ldr	r3, [r3]
   1a310:	e20330ff 	and	r3, r3, #255	; 0xff
   1a314:	e20320ff 	and	r2, r3, #255	; 0xff
   1a318:	e3a03000 	mov	r3, #0
   1a31c:	ea000005 	b	1a338 <_svfprintf_r+0x1024>
   1a320:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1a324:	e2832004 	add	r2, r3, #4
   1a328:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1a32c:	e5933000 	ldr	r3, [r3]
   1a330:	e1a02003 	mov	r2, r3
   1a334:	e3a03000 	mov	r3, #0
   1a338:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1a33c:	e50b3048 	str	r3, [fp, #-72]	; 0x48
			base = HEX;
   1a340:	e3a03002 	mov	r3, #2
   1a344:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
   1a348:	e2063001 	and	r3, r6, #1
   1a34c:	e3530000 	cmp	r3, #0
   1a350:	0a000008 	beq	1a378 <_svfprintf_r+0x1064>
   1a354:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1a358:	e893000c 	ldm	r3, {r2, r3}
   1a35c:	e1921003 	orrs	r1, r2, r3
   1a360:	0a000004 	beq	1a378 <_svfprintf_r+0x1064>
				ox[0] = '0';
   1a364:	e3a03030 	mov	r3, #48	; 0x30
   1a368:	e54b3158 	strb	r3, [fp, #-344]	; 0x158
				ox[1] = ch;
   1a36c:	e20830ff 	and	r3, r8, #255	; 0xff
   1a370:	e54b3157 	strb	r3, [fp, #-343]	; 0x157
				flags |= HEXPREFIX;
   1a374:	e3866002 	orr	r6, r6, #2
			}

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
   1a378:	e3c66b01 	bic	r6, r6, #1024	; 0x400
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   1a37c:	e3a03000 	mov	r3, #0
   1a380:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1a384:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1a388:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   1a38c:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   1a390:	e3530000 	cmp	r3, #0
   1a394:	ba000000 	blt	1a39c <_svfprintf_r+0x1088>
				flags &= ~ZEROPAD;
   1a398:	e3c66080 	bic	r6, r6, #128	; 0x80
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   1a39c:	e24b7f55 	sub	r7, fp, #340	; 0x154
   1a3a0:	e2877064 	add	r7, r7, #100	; 0x64
			if (_uquad != 0 || prec != 0) {
   1a3a4:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1a3a8:	e893000c 	ldm	r3, {r2, r3}
   1a3ac:	e1921003 	orrs	r1, r2, r3
   1a3b0:	1a000002 	bne	1a3c0 <_svfprintf_r+0x10ac>
   1a3b4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1a3b8:	e3530000 	cmp	r3, #0
   1a3bc:	0a000099 	beq	1a628 <_svfprintf_r+0x1314>
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   1a3c0:	e55b304d 	ldrb	r3, [fp, #-77]	; 0x4d
   1a3c4:	e3530001 	cmp	r3, #1
   1a3c8:	0a000026 	beq	1a468 <_svfprintf_r+0x1154>
   1a3cc:	e3530002 	cmp	r3, #2
   1a3d0:	0a000073 	beq	1a5a4 <_svfprintf_r+0x1290>
   1a3d4:	e3530000 	cmp	r3, #0
   1a3d8:	1a00008a 	bne	1a608 <_svfprintf_r+0x12f4>
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   1a3dc:	e2477001 	sub	r7, r7, #1
   1a3e0:	e55b304c 	ldrb	r3, [fp, #-76]	; 0x4c
   1a3e4:	e2033007 	and	r3, r3, #7
   1a3e8:	e20330ff 	and	r3, r3, #255	; 0xff
   1a3ec:	e2833030 	add	r3, r3, #48	; 0x30
   1a3f0:	e20330ff 	and	r3, r3, #255	; 0xff
   1a3f4:	e5c73000 	strb	r3, [r7]
						_uquad >>= 3;
   1a3f8:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1a3fc:	e893000c 	ldm	r3, {r2, r3}
   1a400:	e1a011a2 	lsr	r1, r2, #3
   1a404:	e50b1174 	str	r1, [fp, #-372]	; 0x174
   1a408:	e51b1174 	ldr	r1, [fp, #-372]	; 0x174
   1a40c:	e1811e83 	orr	r1, r1, r3, lsl #29
   1a410:	e50b1174 	str	r1, [fp, #-372]	; 0x174
   1a414:	e1a011a3 	lsr	r1, r3, #3
   1a418:	e50b1170 	str	r1, [fp, #-368]	; 0x170
   1a41c:	e24b3f5d 	sub	r3, fp, #372	; 0x174
   1a420:	e893000c 	ldm	r3, {r2, r3}
   1a424:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1a428:	e50b3048 	str	r3, [fp, #-72]	; 0x48
					} while (_uquad);
   1a42c:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1a430:	e893000c 	ldm	r3, {r2, r3}
   1a434:	e1921003 	orrs	r1, r2, r3
   1a438:	1affffe7 	bne	1a3dc <_svfprintf_r+0x10c8>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
   1a43c:	e2063001 	and	r3, r6, #1
   1a440:	e3530000 	cmp	r3, #0
   1a444:	0a000006 	beq	1a464 <_svfprintf_r+0x1150>
   1a448:	e5d73000 	ldrb	r3, [r7]
   1a44c:	e3530030 	cmp	r3, #48	; 0x30
   1a450:	0a000003 	beq	1a464 <_svfprintf_r+0x1150>
						*--cp = '0';
   1a454:	e2477001 	sub	r7, r7, #1
   1a458:	e3a03030 	mov	r3, #48	; 0x30
   1a45c:	e5c73000 	strb	r3, [r7]
					break;
   1a460:	ea00006f 	b	1a624 <_svfprintf_r+0x1310>
   1a464:	ea00006e 	b	1a624 <_svfprintf_r+0x1310>

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   1a468:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1a46c:	e893000c 	ldm	r3, {r2, r3}
   1a470:	e3530000 	cmp	r3, #0
   1a474:	03520009 	cmpeq	r2, #9
   1a478:	8a000005 	bhi	1a494 <_svfprintf_r+0x1180>
						*--cp = to_char(_uquad);
   1a47c:	e2477001 	sub	r7, r7, #1
   1a480:	e55b304c 	ldrb	r3, [fp, #-76]	; 0x4c
   1a484:	e2833030 	add	r3, r3, #48	; 0x30
   1a488:	e20330ff 	and	r3, r3, #255	; 0xff
   1a48c:	e5c73000 	strb	r3, [r7]
						break;
   1a490:	ea000063 	b	1a624 <_svfprintf_r+0x1310>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
   1a494:	e3a03000 	mov	r3, #0
   1a498:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   1a49c:	e2477001 	sub	r7, r7, #1
   1a4a0:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1a4a4:	e893000c 	ldm	r3, {r2, r3}
   1a4a8:	e1a00002 	mov	r0, r2
   1a4ac:	e1a01003 	mov	r1, r3
   1a4b0:	e3a0200a 	mov	r2, #10
   1a4b4:	e3a03000 	mov	r3, #0
   1a4b8:	ebffeb30 	bl	15180 <__aeabi_uldivmod>
   1a4bc:	e20230ff 	and	r3, r2, #255	; 0xff
   1a4c0:	e2833030 	add	r3, r3, #48	; 0x30
   1a4c4:	e20330ff 	and	r3, r3, #255	; 0xff
   1a4c8:	e5c73000 	strb	r3, [r7]
#ifdef _WANT_IO_C99_FORMATS
					  ndig++;
   1a4cc:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1a4d0:	e2833001 	add	r3, r3, #1
   1a4d4:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
					  /* If (*grouping == CHAR_MAX) then no
					     more grouping */
					  if ((flags & GROUPING)
   1a4d8:	e2063b01 	and	r3, r6, #1024	; 0x400
   1a4dc:	e3530000 	cmp	r3, #0
   1a4e0:	0a00001f 	beq	1a564 <_svfprintf_r+0x1250>
					      && ndig == *grouping
   1a4e4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1a4e8:	e5d33000 	ldrb	r3, [r3]
   1a4ec:	e1a02003 	mov	r2, r3
   1a4f0:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1a4f4:	e1520003 	cmp	r2, r3
   1a4f8:	1a000019 	bne	1a564 <_svfprintf_r+0x1250>
					      && *grouping != CHAR_MAX
   1a4fc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1a500:	e5d33000 	ldrb	r3, [r3]
   1a504:	e35300ff 	cmp	r3, #255	; 0xff
   1a508:	0a000015 	beq	1a564 <_svfprintf_r+0x1250>
					      && _uquad > 9) {
   1a50c:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1a510:	e893000c 	ldm	r3, {r2, r3}
   1a514:	e3530000 	cmp	r3, #0
   1a518:	03520009 	cmpeq	r2, #9
   1a51c:	9a000010 	bls	1a564 <_svfprintf_r+0x1250>
					    cp -= thsnd_len;
   1a520:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1a524:	e2633000 	rsb	r3, r3, #0
   1a528:	e0877003 	add	r7, r7, r3
					    strncpy (cp, thousands_sep,
   1a52c:	e1a00007 	mov	r0, r7
   1a530:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
   1a534:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   1a538:	eb002ccc 	bl	25870 <strncpy>
						     thsnd_len);
					    ndig = 0;
   1a53c:	e3a03000 	mov	r3, #0
   1a540:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
					    /* If (grouping[1] == '\0') then we
					       have to use *grouping character
					       (last grouping rule) for all
					       next cases. */
					    if (grouping[1] != '\0')
   1a544:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1a548:	e2833001 	add	r3, r3, #1
   1a54c:	e5d33000 	ldrb	r3, [r3]
   1a550:	e3530000 	cmp	r3, #0
   1a554:	0a000002 	beq	1a564 <_svfprintf_r+0x1250>
					      grouping++;
   1a558:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1a55c:	e2833001 	add	r3, r3, #1
   1a560:	e50b3034 	str	r3, [fp, #-52]	; 0x34
					  }
#endif
					  _uquad /= 10;
   1a564:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1a568:	e893000c 	ldm	r3, {r2, r3}
   1a56c:	e1a00002 	mov	r0, r2
   1a570:	e1a01003 	mov	r1, r3
   1a574:	e3a0200a 	mov	r2, #10
   1a578:	e3a03000 	mov	r3, #0
   1a57c:	ebffeaff 	bl	15180 <__aeabi_uldivmod>
   1a580:	e1a02000 	mov	r2, r0
   1a584:	e1a03001 	mov	r3, r1
   1a588:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1a58c:	e50b3048 	str	r3, [fp, #-72]	; 0x48
					} while (_uquad != 0);
   1a590:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1a594:	e893000c 	ldm	r3, {r2, r3}
   1a598:	e1921003 	orrs	r1, r2, r3
   1a59c:	1affffbe 	bne	1a49c <_svfprintf_r+0x1188>
					break;
   1a5a0:	ea00001f 	b	1a624 <_svfprintf_r+0x1310>

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   1a5a4:	e2477001 	sub	r7, r7, #1
   1a5a8:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1a5ac:	e203300f 	and	r3, r3, #15
   1a5b0:	e51b2060 	ldr	r2, [fp, #-96]	; 0x60
   1a5b4:	e0823003 	add	r3, r2, r3
   1a5b8:	e5d33000 	ldrb	r3, [r3]
   1a5bc:	e5c73000 	strb	r3, [r7]
						_uquad >>= 4;
   1a5c0:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1a5c4:	e893000c 	ldm	r3, {r2, r3}
   1a5c8:	e1a01222 	lsr	r1, r2, #4
   1a5cc:	e50b117c 	str	r1, [fp, #-380]	; 0x17c
   1a5d0:	e51b117c 	ldr	r1, [fp, #-380]	; 0x17c
   1a5d4:	e1811e03 	orr	r1, r1, r3, lsl #28
   1a5d8:	e50b117c 	str	r1, [fp, #-380]	; 0x17c
   1a5dc:	e1a01223 	lsr	r1, r3, #4
   1a5e0:	e50b1178 	str	r1, [fp, #-376]	; 0x178
   1a5e4:	e24b3f5f 	sub	r3, fp, #380	; 0x17c
   1a5e8:	e893000c 	ldm	r3, {r2, r3}
   1a5ec:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1a5f0:	e50b3048 	str	r3, [fp, #-72]	; 0x48
					} while (_uquad);
   1a5f4:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1a5f8:	e893000c 	ldm	r3, {r2, r3}
   1a5fc:	e1921003 	orrs	r1, r2, r3
   1a600:	1affffe7 	bne	1a5a4 <_svfprintf_r+0x1290>
					break;
   1a604:	ea000006 	b	1a624 <_svfprintf_r+0x1310>

				default:
					cp = "bug in vfprintf: bad base";
   1a608:	e59f747c 	ldr	r7, [pc, #1148]	; 1aa8c <_svfprintf_r+0x1778>
					size = strlen (cp);
   1a60c:	e1a00007 	mov	r0, r7
   1a610:	ebfffb26 	bl	192b0 <strlen>
   1a614:	e1a03000 	mov	r3, r0
   1a618:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
					goto skipsize;
   1a61c:	e1a00000 	nop			; (mov r0, r0)
                       else if (base == OCT && (flags & ALT))
                         *--cp = '0';

			size = buf + BUF - cp;
		skipsize:
			break;
   1a620:	ea00001a 	b	1a690 <_svfprintf_r+0x137c>
				default:
					cp = "bug in vfprintf: bad base";
					size = strlen (cp);
					goto skipsize;
				}
			}
   1a624:	ea000008 	b	1a64c <_svfprintf_r+0x1338>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   1a628:	e55b304d 	ldrb	r3, [fp, #-77]	; 0x4d
   1a62c:	e3530000 	cmp	r3, #0
   1a630:	1a000005 	bne	1a64c <_svfprintf_r+0x1338>
   1a634:	e2063001 	and	r3, r6, #1
   1a638:	e3530000 	cmp	r3, #0
   1a63c:	0a000002 	beq	1a64c <_svfprintf_r+0x1338>
                         *--cp = '0';
   1a640:	e2477001 	sub	r7, r7, #1
   1a644:	e3a03030 	mov	r3, #48	; 0x30
   1a648:	e5c73000 	strb	r3, [r7]

			size = buf + BUF - cp;
   1a64c:	e24b3f55 	sub	r3, fp, #340	; 0x154
   1a650:	e2833064 	add	r3, r3, #100	; 0x64
   1a654:	e1a02007 	mov	r2, r7
   1a658:	e0623003 	rsb	r3, r2, r3
   1a65c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
		skipsize:
			break;
   1a660:	ea00000a 	b	1a690 <_svfprintf_r+0x137c>
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
   1a664:	e3580000 	cmp	r8, #0
   1a668:	1a000000 	bne	1a670 <_svfprintf_r+0x135c>
				goto done;
   1a66c:	ea0004fc 	b	1ba64 <_svfprintf_r+0x2750>
			/* pretend it was %c with argument ch */
			cp = buf;
   1a670:	e24b7f55 	sub	r7, fp, #340	; 0x154
			*cp = ch;
   1a674:	e20830ff 	and	r3, r8, #255	; 0xff
   1a678:	e5c73000 	strb	r3, [r7]
			size = 1;
   1a67c:	e3a03001 	mov	r3, #1
   1a680:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
			sign = '\0';
   1a684:	e3a03000 	mov	r3, #0
   1a688:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
			break;
   1a68c:	e1a00000 	nop			; (mov r0, r0)
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
   1a690:	e51b205c 	ldr	r2, [fp, #-92]	; 0x5c
   1a694:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   1a698:	e1520003 	cmp	r2, r3
   1a69c:	a1a03002 	movge	r3, r2
   1a6a0:	b1a03003 	movlt	r3, r3
   1a6a4:	e50b3058 	str	r3, [fp, #-88]	; 0x58
		if (sign)
   1a6a8:	e55b3085 	ldrb	r3, [fp, #-133]	; 0x85
   1a6ac:	e3530000 	cmp	r3, #0
   1a6b0:	0a000002 	beq	1a6c0 <_svfprintf_r+0x13ac>
			realsz++;
   1a6b4:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   1a6b8:	e2833001 	add	r3, r3, #1
   1a6bc:	e50b3058 	str	r3, [fp, #-88]	; 0x58
		if (flags & HEXPREFIX)
   1a6c0:	e2063002 	and	r3, r6, #2
   1a6c4:	e3530000 	cmp	r3, #0
   1a6c8:	0a000002 	beq	1a6d8 <_svfprintf_r+0x13c4>
			realsz+= 2;
   1a6cc:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   1a6d0:	e2833002 	add	r3, r3, #2
   1a6d4:	e50b3058 	str	r3, [fp, #-88]	; 0x58

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   1a6d8:	e2063084 	and	r3, r6, #132	; 0x84
   1a6dc:	e3530000 	cmp	r3, #0
   1a6e0:	1a000038 	bne	1a7c8 <_svfprintf_r+0x14b4>
			PAD (width - realsz, blanks);
   1a6e4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1a6e8:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   1a6ec:	e0635002 	rsb	r5, r3, r2
   1a6f0:	e3550000 	cmp	r5, #0
   1a6f4:	da000033 	ble	1a7c8 <_svfprintf_r+0x14b4>
   1a6f8:	ea000018 	b	1a760 <_svfprintf_r+0x144c>
   1a6fc:	e59f3394 	ldr	r3, [pc, #916]	; 1aa98 <_svfprintf_r+0x1784>
   1a700:	e5843000 	str	r3, [r4]
   1a704:	e3a03010 	mov	r3, #16
   1a708:	e5843004 	str	r3, [r4, #4]
   1a70c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1a710:	e2833010 	add	r3, r3, #16
   1a714:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1a718:	e2844008 	add	r4, r4, #8
   1a71c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1a720:	e2833001 	add	r3, r3, #1
   1a724:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1a728:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1a72c:	e3530007 	cmp	r3, #7
   1a730:	da000009 	ble	1a75c <_svfprintf_r+0x1448>
   1a734:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1a738:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1a73c:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1a740:	e1a02003 	mov	r2, r3
   1a744:	eb002ca5 	bl	259e0 <__ssprint_r>
   1a748:	e1a03000 	mov	r3, r0
   1a74c:	e3530000 	cmp	r3, #0
   1a750:	0a000000 	beq	1a758 <_svfprintf_r+0x1444>
   1a754:	ea0004d1 	b	1baa0 <_svfprintf_r+0x278c>
   1a758:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1a75c:	e2455010 	sub	r5, r5, #16
   1a760:	e3550010 	cmp	r5, #16
   1a764:	caffffe4 	bgt	1a6fc <_svfprintf_r+0x13e8>
   1a768:	e59f3328 	ldr	r3, [pc, #808]	; 1aa98 <_svfprintf_r+0x1784>
   1a76c:	e5843000 	str	r3, [r4]
   1a770:	e1a03005 	mov	r3, r5
   1a774:	e5843004 	str	r3, [r4, #4]
   1a778:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1a77c:	e0833005 	add	r3, r3, r5
   1a780:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1a784:	e2844008 	add	r4, r4, #8
   1a788:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1a78c:	e2833001 	add	r3, r3, #1
   1a790:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1a794:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1a798:	e3530007 	cmp	r3, #7
   1a79c:	da000009 	ble	1a7c8 <_svfprintf_r+0x14b4>
   1a7a0:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1a7a4:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1a7a8:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1a7ac:	e1a02003 	mov	r2, r3
   1a7b0:	eb002c8a 	bl	259e0 <__ssprint_r>
   1a7b4:	e1a03000 	mov	r3, r0
   1a7b8:	e3530000 	cmp	r3, #0
   1a7bc:	0a000000 	beq	1a7c4 <_svfprintf_r+0x14b0>
   1a7c0:	ea0004b6 	b	1baa0 <_svfprintf_r+0x278c>
   1a7c4:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* prefix */
		if (sign)
   1a7c8:	e55b3085 	ldrb	r3, [fp, #-133]	; 0x85
   1a7cc:	e3530000 	cmp	r3, #0
   1a7d0:	0a000017 	beq	1a834 <_svfprintf_r+0x1520>
			PRINT (&sign, 1);
   1a7d4:	e24b3085 	sub	r3, fp, #133	; 0x85
   1a7d8:	e5843000 	str	r3, [r4]
   1a7dc:	e3a03001 	mov	r3, #1
   1a7e0:	e5843004 	str	r3, [r4, #4]
   1a7e4:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1a7e8:	e2833001 	add	r3, r3, #1
   1a7ec:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1a7f0:	e2844008 	add	r4, r4, #8
   1a7f4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1a7f8:	e2833001 	add	r3, r3, #1
   1a7fc:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1a800:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1a804:	e3530007 	cmp	r3, #7
   1a808:	da000009 	ble	1a834 <_svfprintf_r+0x1520>
   1a80c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1a810:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1a814:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1a818:	e1a02003 	mov	r2, r3
   1a81c:	eb002c6f 	bl	259e0 <__ssprint_r>
   1a820:	e1a03000 	mov	r3, r0
   1a824:	e3530000 	cmp	r3, #0
   1a828:	0a000000 	beq	1a830 <_svfprintf_r+0x151c>
   1a82c:	ea00049b 	b	1baa0 <_svfprintf_r+0x278c>
   1a830:	e24b40f0 	sub	r4, fp, #240	; 0xf0
		if (flags & HEXPREFIX)
   1a834:	e2063002 	and	r3, r6, #2
   1a838:	e3530000 	cmp	r3, #0
   1a83c:	0a000017 	beq	1a8a0 <_svfprintf_r+0x158c>
			PRINT (ox, 2);
   1a840:	e24b3f56 	sub	r3, fp, #344	; 0x158
   1a844:	e5843000 	str	r3, [r4]
   1a848:	e3a03002 	mov	r3, #2
   1a84c:	e5843004 	str	r3, [r4, #4]
   1a850:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1a854:	e2833002 	add	r3, r3, #2
   1a858:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1a85c:	e2844008 	add	r4, r4, #8
   1a860:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1a864:	e2833001 	add	r3, r3, #1
   1a868:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1a86c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1a870:	e3530007 	cmp	r3, #7
   1a874:	da000009 	ble	1a8a0 <_svfprintf_r+0x158c>
   1a878:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1a87c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1a880:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1a884:	e1a02003 	mov	r2, r3
   1a888:	eb002c54 	bl	259e0 <__ssprint_r>
   1a88c:	e1a03000 	mov	r3, r0
   1a890:	e3530000 	cmp	r3, #0
   1a894:	0a000000 	beq	1a89c <_svfprintf_r+0x1588>
   1a898:	ea000480 	b	1baa0 <_svfprintf_r+0x278c>
   1a89c:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   1a8a0:	e2063084 	and	r3, r6, #132	; 0x84
   1a8a4:	e3530080 	cmp	r3, #128	; 0x80
   1a8a8:	1a000038 	bne	1a990 <_svfprintf_r+0x167c>
			PAD (width - realsz, zeroes);
   1a8ac:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1a8b0:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   1a8b4:	e0635002 	rsb	r5, r3, r2
   1a8b8:	e3550000 	cmp	r5, #0
   1a8bc:	da000033 	ble	1a990 <_svfprintf_r+0x167c>
   1a8c0:	ea000018 	b	1a928 <_svfprintf_r+0x1614>
   1a8c4:	e59f31c8 	ldr	r3, [pc, #456]	; 1aa94 <_svfprintf_r+0x1780>
   1a8c8:	e5843000 	str	r3, [r4]
   1a8cc:	e3a03010 	mov	r3, #16
   1a8d0:	e5843004 	str	r3, [r4, #4]
   1a8d4:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1a8d8:	e2833010 	add	r3, r3, #16
   1a8dc:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1a8e0:	e2844008 	add	r4, r4, #8
   1a8e4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1a8e8:	e2833001 	add	r3, r3, #1
   1a8ec:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1a8f0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1a8f4:	e3530007 	cmp	r3, #7
   1a8f8:	da000009 	ble	1a924 <_svfprintf_r+0x1610>
   1a8fc:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1a900:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1a904:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1a908:	e1a02003 	mov	r2, r3
   1a90c:	eb002c33 	bl	259e0 <__ssprint_r>
   1a910:	e1a03000 	mov	r3, r0
   1a914:	e3530000 	cmp	r3, #0
   1a918:	0a000000 	beq	1a920 <_svfprintf_r+0x160c>
   1a91c:	ea00045f 	b	1baa0 <_svfprintf_r+0x278c>
   1a920:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1a924:	e2455010 	sub	r5, r5, #16
   1a928:	e3550010 	cmp	r5, #16
   1a92c:	caffffe4 	bgt	1a8c4 <_svfprintf_r+0x15b0>
   1a930:	e59f315c 	ldr	r3, [pc, #348]	; 1aa94 <_svfprintf_r+0x1780>
   1a934:	e5843000 	str	r3, [r4]
   1a938:	e1a03005 	mov	r3, r5
   1a93c:	e5843004 	str	r3, [r4, #4]
   1a940:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1a944:	e0833005 	add	r3, r3, r5
   1a948:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1a94c:	e2844008 	add	r4, r4, #8
   1a950:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1a954:	e2833001 	add	r3, r3, #1
   1a958:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1a95c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1a960:	e3530007 	cmp	r3, #7
   1a964:	da000009 	ble	1a990 <_svfprintf_r+0x167c>
   1a968:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1a96c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1a970:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1a974:	e1a02003 	mov	r2, r3
   1a978:	eb002c18 	bl	259e0 <__ssprint_r>
   1a97c:	e1a03000 	mov	r3, r0
   1a980:	e3530000 	cmp	r3, #0
   1a984:	0a000000 	beq	1a98c <_svfprintf_r+0x1678>
   1a988:	ea000444 	b	1baa0 <_svfprintf_r+0x278c>
   1a98c:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   1a990:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   1a994:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1a998:	e0635002 	rsb	r5, r3, r2
   1a99c:	e3550000 	cmp	r5, #0
   1a9a0:	da00003e 	ble	1aaa0 <_svfprintf_r+0x178c>
   1a9a4:	ea000018 	b	1aa0c <_svfprintf_r+0x16f8>
   1a9a8:	e59f30e4 	ldr	r3, [pc, #228]	; 1aa94 <_svfprintf_r+0x1780>
   1a9ac:	e5843000 	str	r3, [r4]
   1a9b0:	e3a03010 	mov	r3, #16
   1a9b4:	e5843004 	str	r3, [r4, #4]
   1a9b8:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1a9bc:	e2833010 	add	r3, r3, #16
   1a9c0:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1a9c4:	e2844008 	add	r4, r4, #8
   1a9c8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1a9cc:	e2833001 	add	r3, r3, #1
   1a9d0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1a9d4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1a9d8:	e3530007 	cmp	r3, #7
   1a9dc:	da000009 	ble	1aa08 <_svfprintf_r+0x16f4>
   1a9e0:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1a9e4:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1a9e8:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1a9ec:	e1a02003 	mov	r2, r3
   1a9f0:	eb002bfa 	bl	259e0 <__ssprint_r>
   1a9f4:	e1a03000 	mov	r3, r0
   1a9f8:	e3530000 	cmp	r3, #0
   1a9fc:	0a000000 	beq	1aa04 <_svfprintf_r+0x16f0>
   1aa00:	ea000426 	b	1baa0 <_svfprintf_r+0x278c>
   1aa04:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1aa08:	e2455010 	sub	r5, r5, #16
   1aa0c:	e3550010 	cmp	r5, #16
   1aa10:	caffffe4 	bgt	1a9a8 <_svfprintf_r+0x1694>
   1aa14:	e59f3078 	ldr	r3, [pc, #120]	; 1aa94 <_svfprintf_r+0x1780>
   1aa18:	e5843000 	str	r3, [r4]
   1aa1c:	e1a03005 	mov	r3, r5
   1aa20:	e5843004 	str	r3, [r4, #4]
   1aa24:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1aa28:	e0833005 	add	r3, r3, r5
   1aa2c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1aa30:	e2844008 	add	r4, r4, #8
   1aa34:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1aa38:	e2833001 	add	r3, r3, #1
   1aa3c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1aa40:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1aa44:	e3530007 	cmp	r3, #7
   1aa48:	da000014 	ble	1aaa0 <_svfprintf_r+0x178c>
   1aa4c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1aa50:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1aa54:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1aa58:	e1a02003 	mov	r2, r3
   1aa5c:	eb002bdf 	bl	259e0 <__ssprint_r>
   1aa60:	e1a03000 	mov	r3, r0
   1aa64:	e3530000 	cmp	r3, #0
   1aa68:	0a00000b 	beq	1aa9c <_svfprintf_r+0x1788>
   1aa6c:	ea00040b 	b	1baa0 <_svfprintf_r+0x278c>
   1aa70:	0003305c 	.word	0x0003305c
   1aa74:	00033060 	.word	0x00033060
   1aa78:	00033064 	.word	0x00033064
   1aa7c:	00033068 	.word	0x00033068
   1aa80:	0003306c 	.word	0x0003306c
   1aa84:	00033080 	.word	0x00033080
   1aa88:	00033088 	.word	0x00033088
   1aa8c:	0003309c 	.word	0x0003309c
   1aa90:	000330b8 	.word	0x000330b8
   1aa94:	000330cc 	.word	0x000330cc
   1aa98:	000330bc 	.word	0x000330bc
   1aa9c:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
   1aaa0:	e2063c01 	and	r3, r6, #256	; 0x100
   1aaa4:	e3530000 	cmp	r3, #0
   1aaa8:	1a000018 	bne	1ab10 <_svfprintf_r+0x17fc>
			PRINT (cp, size);
   1aaac:	e5847000 	str	r7, [r4]
   1aab0:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1aab4:	e5843004 	str	r3, [r4, #4]
   1aab8:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1aabc:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1aac0:	e0823003 	add	r3, r2, r3
   1aac4:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1aac8:	e2844008 	add	r4, r4, #8
   1aacc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1aad0:	e2833001 	add	r3, r3, #1
   1aad4:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1aad8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1aadc:	e3530007 	cmp	r3, #7
   1aae0:	da000383 	ble	1b8f4 <_svfprintf_r+0x25e0>
   1aae4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1aae8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1aaec:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1aaf0:	e1a02003 	mov	r2, r3
   1aaf4:	eb002bb9 	bl	259e0 <__ssprint_r>
   1aaf8:	e1a03000 	mov	r3, r0
   1aafc:	e3530000 	cmp	r3, #0
   1ab00:	0a000000 	beq	1ab08 <_svfprintf_r+0x17f4>
   1ab04:	ea0003e5 	b	1baa0 <_svfprintf_r+0x278c>
   1ab08:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1ab0c:	ea000378 	b	1b8f4 <_svfprintf_r+0x25e0>
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
   1ab10:	e3580065 	cmp	r8, #101	; 0x65
   1ab14:	da0002af 	ble	1b5d8 <_svfprintf_r+0x22c4>
				if (_fpvalue == 0) {
   1ab18:	e24b3094 	sub	r3, fp, #148	; 0x94
   1ab1c:	e893000c 	ldm	r3, {r2, r3}
   1ab20:	e1a00002 	mov	r0, r2
   1ab24:	e1a01003 	mov	r1, r3
   1ab28:	e3a02000 	mov	r2, #0
   1ab2c:	e3a03000 	mov	r3, #0
   1ab30:	ebffe94c 	bl	15068 <__aeabi_dcmpeq>
   1ab34:	e1a03000 	mov	r3, r0
   1ab38:	e3530000 	cmp	r3, #0
   1ab3c:	0a000071 	beq	1ad08 <_svfprintf_r+0x19f4>
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
   1ab40:	e51f30b8 	ldr	r3, [pc, #-184]	; 1aa90 <_svfprintf_r+0x177c>
   1ab44:	e5843000 	str	r3, [r4]
   1ab48:	e3a03001 	mov	r3, #1
   1ab4c:	e5843004 	str	r3, [r4, #4]
   1ab50:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1ab54:	e2833001 	add	r3, r3, #1
   1ab58:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1ab5c:	e2844008 	add	r4, r4, #8
   1ab60:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1ab64:	e2833001 	add	r3, r3, #1
   1ab68:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1ab6c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1ab70:	e3530007 	cmp	r3, #7
   1ab74:	da000009 	ble	1aba0 <_svfprintf_r+0x188c>
   1ab78:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1ab7c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ab80:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1ab84:	e1a02003 	mov	r2, r3
   1ab88:	eb002b94 	bl	259e0 <__ssprint_r>
   1ab8c:	e1a03000 	mov	r3, r0
   1ab90:	e3530000 	cmp	r3, #0
   1ab94:	0a000000 	beq	1ab9c <_svfprintf_r+0x1888>
   1ab98:	ea0003c0 	b	1baa0 <_svfprintf_r+0x278c>
   1ab9c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					if (expt < ndig || flags & ALT) {
   1aba0:	e51b2098 	ldr	r2, [fp, #-152]	; 0x98
   1aba4:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1aba8:	e1520003 	cmp	r2, r3
   1abac:	ba000002 	blt	1abbc <_svfprintf_r+0x18a8>
   1abb0:	e2063001 	and	r3, r6, #1
   1abb4:	e3530000 	cmp	r3, #0
   1abb8:	0a00034d 	beq	1b8f4 <_svfprintf_r+0x25e0>
						PRINT (decimal_point, decp_len);
   1abbc:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1abc0:	e5843000 	str	r3, [r4]
   1abc4:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1abc8:	e5843004 	str	r3, [r4, #4]
   1abcc:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1abd0:	e1a02003 	mov	r2, r3
   1abd4:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1abd8:	e0823003 	add	r3, r2, r3
   1abdc:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1abe0:	e2844008 	add	r4, r4, #8
   1abe4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1abe8:	e2833001 	add	r3, r3, #1
   1abec:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1abf0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1abf4:	e3530007 	cmp	r3, #7
   1abf8:	da000009 	ble	1ac24 <_svfprintf_r+0x1910>
   1abfc:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1ac00:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ac04:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1ac08:	e1a02003 	mov	r2, r3
   1ac0c:	eb002b73 	bl	259e0 <__ssprint_r>
   1ac10:	e1a03000 	mov	r3, r0
   1ac14:	e3530000 	cmp	r3, #0
   1ac18:	0a000000 	beq	1ac20 <_svfprintf_r+0x190c>
   1ac1c:	ea00039f 	b	1baa0 <_svfprintf_r+0x278c>
   1ac20:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						PAD (ndig - 1, zeroes);
   1ac24:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1ac28:	e2435001 	sub	r5, r3, #1
   1ac2c:	e3550000 	cmp	r5, #0
   1ac30:	da00032f 	ble	1b8f4 <_svfprintf_r+0x25e0>
   1ac34:	ea000018 	b	1ac9c <_svfprintf_r+0x1988>
   1ac38:	e51f31ac 	ldr	r3, [pc, #-428]	; 1aa94 <_svfprintf_r+0x1780>
   1ac3c:	e5843000 	str	r3, [r4]
   1ac40:	e3a03010 	mov	r3, #16
   1ac44:	e5843004 	str	r3, [r4, #4]
   1ac48:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1ac4c:	e2833010 	add	r3, r3, #16
   1ac50:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1ac54:	e2844008 	add	r4, r4, #8
   1ac58:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1ac5c:	e2833001 	add	r3, r3, #1
   1ac60:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1ac64:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1ac68:	e3530007 	cmp	r3, #7
   1ac6c:	da000009 	ble	1ac98 <_svfprintf_r+0x1984>
   1ac70:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1ac74:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ac78:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1ac7c:	e1a02003 	mov	r2, r3
   1ac80:	eb002b56 	bl	259e0 <__ssprint_r>
   1ac84:	e1a03000 	mov	r3, r0
   1ac88:	e3530000 	cmp	r3, #0
   1ac8c:	0a000000 	beq	1ac94 <_svfprintf_r+0x1980>
   1ac90:	ea000382 	b	1baa0 <_svfprintf_r+0x278c>
   1ac94:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1ac98:	e2455010 	sub	r5, r5, #16
   1ac9c:	e3550010 	cmp	r5, #16
   1aca0:	caffffe4 	bgt	1ac38 <_svfprintf_r+0x1924>
   1aca4:	e51f3218 	ldr	r3, [pc, #-536]	; 1aa94 <_svfprintf_r+0x1780>
   1aca8:	e5843000 	str	r3, [r4]
   1acac:	e1a03005 	mov	r3, r5
   1acb0:	e5843004 	str	r3, [r4, #4]
   1acb4:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1acb8:	e0833005 	add	r3, r3, r5
   1acbc:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1acc0:	e2844008 	add	r4, r4, #8
   1acc4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1acc8:	e2833001 	add	r3, r3, #1
   1accc:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1acd0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1acd4:	e3530007 	cmp	r3, #7
   1acd8:	da000305 	ble	1b8f4 <_svfprintf_r+0x25e0>
   1acdc:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1ace0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ace4:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1ace8:	e1a02003 	mov	r2, r3
   1acec:	eb002b3b 	bl	259e0 <__ssprint_r>
   1acf0:	e1a03000 	mov	r3, r0
   1acf4:	e3530000 	cmp	r3, #0
   1acf8:	0a000000 	beq	1ad00 <_svfprintf_r+0x19ec>
   1acfc:	ea000367 	b	1baa0 <_svfprintf_r+0x278c>
   1ad00:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1ad04:	ea0002fa 	b	1b8f4 <_svfprintf_r+0x25e0>
					}
				} else if (expt <= 0) {
   1ad08:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1ad0c:	e3530000 	cmp	r3, #0
   1ad10:	ca00008b 	bgt	1af44 <_svfprintf_r+0x1c30>
					PRINT ("0", 1);
   1ad14:	e51f328c 	ldr	r3, [pc, #-652]	; 1aa90 <_svfprintf_r+0x177c>
   1ad18:	e5843000 	str	r3, [r4]
   1ad1c:	e3a03001 	mov	r3, #1
   1ad20:	e5843004 	str	r3, [r4, #4]
   1ad24:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1ad28:	e2833001 	add	r3, r3, #1
   1ad2c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1ad30:	e2844008 	add	r4, r4, #8
   1ad34:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1ad38:	e2833001 	add	r3, r3, #1
   1ad3c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1ad40:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1ad44:	e3530007 	cmp	r3, #7
   1ad48:	da000009 	ble	1ad74 <_svfprintf_r+0x1a60>
   1ad4c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1ad50:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ad54:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1ad58:	e1a02003 	mov	r2, r3
   1ad5c:	eb002b1f 	bl	259e0 <__ssprint_r>
   1ad60:	e1a03000 	mov	r3, r0
   1ad64:	e3530000 	cmp	r3, #0
   1ad68:	0a000000 	beq	1ad70 <_svfprintf_r+0x1a5c>
   1ad6c:	ea00034b 	b	1baa0 <_svfprintf_r+0x278c>
   1ad70:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					if (expt || ndig || flags & ALT) {
   1ad74:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1ad78:	e3530000 	cmp	r3, #0
   1ad7c:	1a000005 	bne	1ad98 <_svfprintf_r+0x1a84>
   1ad80:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1ad84:	e3530000 	cmp	r3, #0
   1ad88:	1a000002 	bne	1ad98 <_svfprintf_r+0x1a84>
   1ad8c:	e2063001 	and	r3, r6, #1
   1ad90:	e3530000 	cmp	r3, #0
   1ad94:	0a0002d6 	beq	1b8f4 <_svfprintf_r+0x25e0>
						PRINT (decimal_point, decp_len);
   1ad98:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1ad9c:	e5843000 	str	r3, [r4]
   1ada0:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1ada4:	e5843004 	str	r3, [r4, #4]
   1ada8:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1adac:	e1a02003 	mov	r2, r3
   1adb0:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1adb4:	e0823003 	add	r3, r2, r3
   1adb8:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1adbc:	e2844008 	add	r4, r4, #8
   1adc0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1adc4:	e2833001 	add	r3, r3, #1
   1adc8:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1adcc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1add0:	e3530007 	cmp	r3, #7
   1add4:	da000009 	ble	1ae00 <_svfprintf_r+0x1aec>
   1add8:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1addc:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ade0:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1ade4:	e1a02003 	mov	r2, r3
   1ade8:	eb002afc 	bl	259e0 <__ssprint_r>
   1adec:	e1a03000 	mov	r3, r0
   1adf0:	e3530000 	cmp	r3, #0
   1adf4:	0a000000 	beq	1adfc <_svfprintf_r+0x1ae8>
   1adf8:	ea000328 	b	1baa0 <_svfprintf_r+0x278c>
   1adfc:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						PAD (-expt, zeroes);
   1ae00:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1ae04:	e2635000 	rsb	r5, r3, #0
   1ae08:	e3550000 	cmp	r5, #0
   1ae0c:	da000033 	ble	1aee0 <_svfprintf_r+0x1bcc>
   1ae10:	ea000018 	b	1ae78 <_svfprintf_r+0x1b64>
   1ae14:	e51f3388 	ldr	r3, [pc, #-904]	; 1aa94 <_svfprintf_r+0x1780>
   1ae18:	e5843000 	str	r3, [r4]
   1ae1c:	e3a03010 	mov	r3, #16
   1ae20:	e5843004 	str	r3, [r4, #4]
   1ae24:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1ae28:	e2833010 	add	r3, r3, #16
   1ae2c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1ae30:	e2844008 	add	r4, r4, #8
   1ae34:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1ae38:	e2833001 	add	r3, r3, #1
   1ae3c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1ae40:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1ae44:	e3530007 	cmp	r3, #7
   1ae48:	da000009 	ble	1ae74 <_svfprintf_r+0x1b60>
   1ae4c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1ae50:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ae54:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1ae58:	e1a02003 	mov	r2, r3
   1ae5c:	eb002adf 	bl	259e0 <__ssprint_r>
   1ae60:	e1a03000 	mov	r3, r0
   1ae64:	e3530000 	cmp	r3, #0
   1ae68:	0a000000 	beq	1ae70 <_svfprintf_r+0x1b5c>
   1ae6c:	ea00030b 	b	1baa0 <_svfprintf_r+0x278c>
   1ae70:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1ae74:	e2455010 	sub	r5, r5, #16
   1ae78:	e3550010 	cmp	r5, #16
   1ae7c:	caffffe4 	bgt	1ae14 <_svfprintf_r+0x1b00>
   1ae80:	e51f33f4 	ldr	r3, [pc, #-1012]	; 1aa94 <_svfprintf_r+0x1780>
   1ae84:	e5843000 	str	r3, [r4]
   1ae88:	e1a03005 	mov	r3, r5
   1ae8c:	e5843004 	str	r3, [r4, #4]
   1ae90:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1ae94:	e0833005 	add	r3, r3, r5
   1ae98:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1ae9c:	e2844008 	add	r4, r4, #8
   1aea0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1aea4:	e2833001 	add	r3, r3, #1
   1aea8:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1aeac:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1aeb0:	e3530007 	cmp	r3, #7
   1aeb4:	da000009 	ble	1aee0 <_svfprintf_r+0x1bcc>
   1aeb8:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1aebc:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1aec0:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1aec4:	e1a02003 	mov	r2, r3
   1aec8:	eb002ac4 	bl	259e0 <__ssprint_r>
   1aecc:	e1a03000 	mov	r3, r0
   1aed0:	e3530000 	cmp	r3, #0
   1aed4:	0a000000 	beq	1aedc <_svfprintf_r+0x1bc8>
   1aed8:	ea0002f0 	b	1baa0 <_svfprintf_r+0x278c>
   1aedc:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						PRINT (cp, ndig);
   1aee0:	e5847000 	str	r7, [r4]
   1aee4:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1aee8:	e5843004 	str	r3, [r4, #4]
   1aeec:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1aef0:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1aef4:	e0823003 	add	r3, r2, r3
   1aef8:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1aefc:	e2844008 	add	r4, r4, #8
   1af00:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1af04:	e2833001 	add	r3, r3, #1
   1af08:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1af0c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1af10:	e3530007 	cmp	r3, #7
   1af14:	da000276 	ble	1b8f4 <_svfprintf_r+0x25e0>
   1af18:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1af1c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1af20:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1af24:	e1a02003 	mov	r2, r3
   1af28:	eb002aac 	bl	259e0 <__ssprint_r>
   1af2c:	e1a03000 	mov	r3, r0
   1af30:	e3530000 	cmp	r3, #0
   1af34:	0a000000 	beq	1af3c <_svfprintf_r+0x1c28>
   1af38:	ea0002d8 	b	1baa0 <_svfprintf_r+0x278c>
   1af3c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1af40:	ea00026b 	b	1b8f4 <_svfprintf_r+0x25e0>
					}
				} else {
					char *convbuf = cp;
   1af44:	e50b7084 	str	r7, [fp, #-132]	; 0x84
					PRINTANDPAD(cp, convbuf + ndig,
   1af48:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1af4c:	e51b2084 	ldr	r2, [fp, #-132]	; 0x84
   1af50:	e0823003 	add	r3, r2, r3
   1af54:	e1a02003 	mov	r2, r3
   1af58:	e1a03007 	mov	r3, r7
   1af5c:	e0633002 	rsb	r3, r3, r2
   1af60:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   1af64:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   1af68:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1af6c:	e1520003 	cmp	r2, r3
   1af70:	da000001 	ble	1af7c <_svfprintf_r+0x1c68>
   1af74:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1af78:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   1af7c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1af80:	e3530000 	cmp	r3, #0
   1af84:	da000017 	ble	1afe8 <_svfprintf_r+0x1cd4>
   1af88:	e5847000 	str	r7, [r4]
   1af8c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1af90:	e5843004 	str	r3, [r4, #4]
   1af94:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1af98:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1af9c:	e0823003 	add	r3, r2, r3
   1afa0:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1afa4:	e2844008 	add	r4, r4, #8
   1afa8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1afac:	e2833001 	add	r3, r3, #1
   1afb0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1afb4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1afb8:	e3530007 	cmp	r3, #7
   1afbc:	da000009 	ble	1afe8 <_svfprintf_r+0x1cd4>
   1afc0:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1afc4:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1afc8:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1afcc:	e1a02003 	mov	r2, r3
   1afd0:	eb002a82 	bl	259e0 <__ssprint_r>
   1afd4:	e1a03000 	mov	r3, r0
   1afd8:	e3530000 	cmp	r3, #0
   1afdc:	0a000000 	beq	1afe4 <_svfprintf_r+0x1cd0>
   1afe0:	ea0002ae 	b	1baa0 <_svfprintf_r+0x278c>
   1afe4:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1afe8:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1afec:	e1c33fc3 	bic	r3, r3, r3, asr #31
   1aff0:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   1aff4:	e0633002 	rsb	r3, r3, r2
   1aff8:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   1affc:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1b000:	e3530000 	cmp	r3, #0
   1b004:	da000037 	ble	1b0e8 <_svfprintf_r+0x1dd4>
   1b008:	ea00001a 	b	1b078 <_svfprintf_r+0x1d64>
   1b00c:	e51f3580 	ldr	r3, [pc, #-1408]	; 1aa94 <_svfprintf_r+0x1780>
   1b010:	e5843000 	str	r3, [r4]
   1b014:	e3a03010 	mov	r3, #16
   1b018:	e5843004 	str	r3, [r4, #4]
   1b01c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1b020:	e2833010 	add	r3, r3, #16
   1b024:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b028:	e2844008 	add	r4, r4, #8
   1b02c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b030:	e2833001 	add	r3, r3, #1
   1b034:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b038:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b03c:	e3530007 	cmp	r3, #7
   1b040:	da000009 	ble	1b06c <_svfprintf_r+0x1d58>
   1b044:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b048:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b04c:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b050:	e1a02003 	mov	r2, r3
   1b054:	eb002a61 	bl	259e0 <__ssprint_r>
   1b058:	e1a03000 	mov	r3, r0
   1b05c:	e3530000 	cmp	r3, #0
   1b060:	0a000000 	beq	1b068 <_svfprintf_r+0x1d54>
   1b064:	ea00028d 	b	1baa0 <_svfprintf_r+0x278c>
   1b068:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1b06c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1b070:	e2433010 	sub	r3, r3, #16
   1b074:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   1b078:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1b07c:	e3530010 	cmp	r3, #16
   1b080:	caffffe1 	bgt	1b00c <_svfprintf_r+0x1cf8>
   1b084:	e51f35f8 	ldr	r3, [pc, #-1528]	; 1aa94 <_svfprintf_r+0x1780>
   1b088:	e5843000 	str	r3, [r4]
   1b08c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1b090:	e5843004 	str	r3, [r4, #4]
   1b094:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1b098:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1b09c:	e0823003 	add	r3, r2, r3
   1b0a0:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b0a4:	e2844008 	add	r4, r4, #8
   1b0a8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b0ac:	e2833001 	add	r3, r3, #1
   1b0b0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b0b4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b0b8:	e3530007 	cmp	r3, #7
   1b0bc:	da000009 	ble	1b0e8 <_svfprintf_r+0x1dd4>
   1b0c0:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b0c4:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b0c8:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b0cc:	e1a02003 	mov	r2, r3
   1b0d0:	eb002a42 	bl	259e0 <__ssprint_r>
   1b0d4:	e1a03000 	mov	r3, r0
   1b0d8:	e3530000 	cmp	r3, #0
   1b0dc:	0a000000 	beq	1b0e4 <_svfprintf_r+0x1dd0>
   1b0e0:	ea00026e 	b	1baa0 <_svfprintf_r+0x278c>
   1b0e4:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						    lead, zeroes);
					cp += lead;
   1b0e8:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1b0ec:	e0877003 	add	r7, r7, r3
#ifdef _WANT_IO_C99_FORMATS
					if (flags & GROUPING) {
   1b0f0:	e2063b01 	and	r3, r6, #1024	; 0x400
   1b0f4:	e3530000 	cmp	r3, #0
   1b0f8:	0a0000a5 	beq	1b394 <_svfprintf_r+0x2080>
					    while (nseps > 0 || nrepeats > 0) {
   1b0fc:	ea000096 	b	1b35c <_svfprintf_r+0x2048>
						if (nrepeats > 0)
   1b100:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1b104:	e3530000 	cmp	r3, #0
   1b108:	da000003 	ble	1b11c <_svfprintf_r+0x1e08>
						    nrepeats--;
   1b10c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1b110:	e2433001 	sub	r3, r3, #1
   1b114:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   1b118:	ea000005 	b	1b134 <_svfprintf_r+0x1e20>
						else {
						    grouping--;
   1b11c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1b120:	e2433001 	sub	r3, r3, #1
   1b124:	e50b3034 	str	r3, [fp, #-52]	; 0x34
						    nseps--;
   1b128:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1b12c:	e2433001 	sub	r3, r3, #1
   1b130:	e50b3040 	str	r3, [fp, #-64]	; 0x40
						}
						PRINT(thousands_sep, thsnd_len);
   1b134:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1b138:	e5843000 	str	r3, [r4]
   1b13c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1b140:	e5843004 	str	r3, [r4, #4]
   1b144:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1b148:	e1a02003 	mov	r2, r3
   1b14c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1b150:	e0823003 	add	r3, r2, r3
   1b154:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b158:	e2844008 	add	r4, r4, #8
   1b15c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b160:	e2833001 	add	r3, r3, #1
   1b164:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b168:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b16c:	e3530007 	cmp	r3, #7
   1b170:	da000009 	ble	1b19c <_svfprintf_r+0x1e88>
   1b174:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b178:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b17c:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b180:	e1a02003 	mov	r2, r3
   1b184:	eb002a15 	bl	259e0 <__ssprint_r>
   1b188:	e1a03000 	mov	r3, r0
   1b18c:	e3530000 	cmp	r3, #0
   1b190:	0a000000 	beq	1b198 <_svfprintf_r+0x1e84>
   1b194:	ea000241 	b	1baa0 <_svfprintf_r+0x278c>
   1b198:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						PRINTANDPAD (cp, convbuf + ndig,
   1b19c:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1b1a0:	e51b2084 	ldr	r2, [fp, #-132]	; 0x84
   1b1a4:	e0823003 	add	r3, r2, r3
   1b1a8:	e1a02003 	mov	r2, r3
   1b1ac:	e1a03007 	mov	r3, r7
   1b1b0:	e0633002 	rsb	r3, r3, r2
   1b1b4:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1b1b8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1b1bc:	e5d33000 	ldrb	r3, [r3]
   1b1c0:	e1a02003 	mov	r2, r3
   1b1c4:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1b1c8:	e1520003 	cmp	r2, r3
   1b1cc:	aa000002 	bge	1b1dc <_svfprintf_r+0x1ec8>
   1b1d0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1b1d4:	e5d33000 	ldrb	r3, [r3]
   1b1d8:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1b1dc:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1b1e0:	e3530000 	cmp	r3, #0
   1b1e4:	da000017 	ble	1b248 <_svfprintf_r+0x1f34>
   1b1e8:	e5847000 	str	r7, [r4]
   1b1ec:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1b1f0:	e5843004 	str	r3, [r4, #4]
   1b1f4:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1b1f8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1b1fc:	e0823003 	add	r3, r2, r3
   1b200:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b204:	e2844008 	add	r4, r4, #8
   1b208:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b20c:	e2833001 	add	r3, r3, #1
   1b210:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b214:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b218:	e3530007 	cmp	r3, #7
   1b21c:	da000009 	ble	1b248 <_svfprintf_r+0x1f34>
   1b220:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b224:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b228:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b22c:	e1a02003 	mov	r2, r3
   1b230:	eb0029ea 	bl	259e0 <__ssprint_r>
   1b234:	e1a03000 	mov	r3, r0
   1b238:	e3530000 	cmp	r3, #0
   1b23c:	0a000000 	beq	1b244 <_svfprintf_r+0x1f30>
   1b240:	ea000216 	b	1baa0 <_svfprintf_r+0x278c>
   1b244:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1b248:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1b24c:	e5d33000 	ldrb	r3, [r3]
   1b250:	e1a02003 	mov	r2, r3
   1b254:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1b258:	e1c33fc3 	bic	r3, r3, r3, asr #31
   1b25c:	e0633002 	rsb	r3, r3, r2
   1b260:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1b264:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1b268:	e3530000 	cmp	r3, #0
   1b26c:	da000037 	ble	1b350 <_svfprintf_r+0x203c>
   1b270:	ea00001a 	b	1b2e0 <_svfprintf_r+0x1fcc>
   1b274:	e51f37e8 	ldr	r3, [pc, #-2024]	; 1aa94 <_svfprintf_r+0x1780>
   1b278:	e5843000 	str	r3, [r4]
   1b27c:	e3a03010 	mov	r3, #16
   1b280:	e5843004 	str	r3, [r4, #4]
   1b284:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1b288:	e2833010 	add	r3, r3, #16
   1b28c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b290:	e2844008 	add	r4, r4, #8
   1b294:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b298:	e2833001 	add	r3, r3, #1
   1b29c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b2a0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b2a4:	e3530007 	cmp	r3, #7
   1b2a8:	da000009 	ble	1b2d4 <_svfprintf_r+0x1fc0>
   1b2ac:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b2b0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b2b4:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b2b8:	e1a02003 	mov	r2, r3
   1b2bc:	eb0029c7 	bl	259e0 <__ssprint_r>
   1b2c0:	e1a03000 	mov	r3, r0
   1b2c4:	e3530000 	cmp	r3, #0
   1b2c8:	0a000000 	beq	1b2d0 <_svfprintf_r+0x1fbc>
   1b2cc:	ea0001f3 	b	1baa0 <_svfprintf_r+0x278c>
   1b2d0:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1b2d4:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1b2d8:	e2433010 	sub	r3, r3, #16
   1b2dc:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1b2e0:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1b2e4:	e3530010 	cmp	r3, #16
   1b2e8:	caffffe1 	bgt	1b274 <_svfprintf_r+0x1f60>
   1b2ec:	e51f3860 	ldr	r3, [pc, #-2144]	; 1aa94 <_svfprintf_r+0x1780>
   1b2f0:	e5843000 	str	r3, [r4]
   1b2f4:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1b2f8:	e5843004 	str	r3, [r4, #4]
   1b2fc:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1b300:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1b304:	e0823003 	add	r3, r2, r3
   1b308:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b30c:	e2844008 	add	r4, r4, #8
   1b310:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b314:	e2833001 	add	r3, r3, #1
   1b318:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b31c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b320:	e3530007 	cmp	r3, #7
   1b324:	da000009 	ble	1b350 <_svfprintf_r+0x203c>
   1b328:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b32c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b330:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b334:	e1a02003 	mov	r2, r3
   1b338:	eb0029a8 	bl	259e0 <__ssprint_r>
   1b33c:	e1a03000 	mov	r3, r0
   1b340:	e3530000 	cmp	r3, #0
   1b344:	0a000000 	beq	1b34c <_svfprintf_r+0x2038>
   1b348:	ea0001d4 	b	1baa0 <_svfprintf_r+0x278c>
   1b34c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
							     *grouping, zeroes);
						cp += *grouping;
   1b350:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1b354:	e5d33000 	ldrb	r3, [r3]
   1b358:	e0877003 	add	r7, r7, r3
					PRINTANDPAD(cp, convbuf + ndig,
						    lead, zeroes);
					cp += lead;
#ifdef _WANT_IO_C99_FORMATS
					if (flags & GROUPING) {
					    while (nseps > 0 || nrepeats > 0) {
   1b35c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1b360:	e3530000 	cmp	r3, #0
   1b364:	caffff65 	bgt	1b100 <_svfprintf_r+0x1dec>
   1b368:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1b36c:	e3530000 	cmp	r3, #0
   1b370:	caffff62 	bgt	1b100 <_svfprintf_r+0x1dec>
						PRINT(thousands_sep, thsnd_len);
						PRINTANDPAD (cp, convbuf + ndig,
							     *grouping, zeroes);
						cp += *grouping;
					    }
					    if (cp > convbuf + ndig)
   1b374:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1b378:	e51b2084 	ldr	r2, [fp, #-132]	; 0x84
   1b37c:	e0823003 	add	r3, r2, r3
   1b380:	e1530007 	cmp	r3, r7
   1b384:	2a000002 	bcs	1b394 <_svfprintf_r+0x2080>
						cp = convbuf + ndig;
   1b388:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1b38c:	e51b2084 	ldr	r2, [fp, #-132]	; 0x84
   1b390:	e0827003 	add	r7, r2, r3
					}
#endif
					if (expt < ndig || flags & ALT)
   1b394:	e51b2098 	ldr	r2, [fp, #-152]	; 0x98
   1b398:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1b39c:	e1520003 	cmp	r2, r3
   1b3a0:	ba000002 	blt	1b3b0 <_svfprintf_r+0x209c>
   1b3a4:	e2063001 	and	r3, r6, #1
   1b3a8:	e3530000 	cmp	r3, #0
   1b3ac:	0a000019 	beq	1b418 <_svfprintf_r+0x2104>
					    PRINT (decimal_point, decp_len);
   1b3b0:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1b3b4:	e5843000 	str	r3, [r4]
   1b3b8:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1b3bc:	e5843004 	str	r3, [r4, #4]
   1b3c0:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1b3c4:	e1a02003 	mov	r2, r3
   1b3c8:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1b3cc:	e0823003 	add	r3, r2, r3
   1b3d0:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b3d4:	e2844008 	add	r4, r4, #8
   1b3d8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b3dc:	e2833001 	add	r3, r3, #1
   1b3e0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b3e4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b3e8:	e3530007 	cmp	r3, #7
   1b3ec:	da000009 	ble	1b418 <_svfprintf_r+0x2104>
   1b3f0:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b3f4:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b3f8:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b3fc:	e1a02003 	mov	r2, r3
   1b400:	eb002976 	bl	259e0 <__ssprint_r>
   1b404:	e1a03000 	mov	r3, r0
   1b408:	e3530000 	cmp	r3, #0
   1b40c:	0a000000 	beq	1b414 <_svfprintf_r+0x2100>
   1b410:	ea0001a2 	b	1baa0 <_svfprintf_r+0x278c>
   1b414:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					PRINTANDPAD (cp, convbuf + ndig,
   1b418:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1b41c:	e51b2084 	ldr	r2, [fp, #-132]	; 0x84
   1b420:	e0823003 	add	r3, r2, r3
   1b424:	e1a02003 	mov	r2, r3
   1b428:	e1a03007 	mov	r3, r7
   1b42c:	e0633002 	rsb	r3, r3, r2
   1b430:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1b434:	e51b20a4 	ldr	r2, [fp, #-164]	; 0xa4
   1b438:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1b43c:	e0632002 	rsb	r2, r3, r2
   1b440:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1b444:	e1520003 	cmp	r2, r3
   1b448:	aa000003 	bge	1b45c <_svfprintf_r+0x2148>
   1b44c:	e51b20a4 	ldr	r2, [fp, #-164]	; 0xa4
   1b450:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1b454:	e0633002 	rsb	r3, r3, r2
   1b458:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1b45c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1b460:	e3530000 	cmp	r3, #0
   1b464:	da000017 	ble	1b4c8 <_svfprintf_r+0x21b4>
   1b468:	e5847000 	str	r7, [r4]
   1b46c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1b470:	e5843004 	str	r3, [r4, #4]
   1b474:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1b478:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1b47c:	e0823003 	add	r3, r2, r3
   1b480:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b484:	e2844008 	add	r4, r4, #8
   1b488:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b48c:	e2833001 	add	r3, r3, #1
   1b490:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b494:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b498:	e3530007 	cmp	r3, #7
   1b49c:	da000009 	ble	1b4c8 <_svfprintf_r+0x21b4>
   1b4a0:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b4a4:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b4a8:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b4ac:	e1a02003 	mov	r2, r3
   1b4b0:	eb00294a 	bl	259e0 <__ssprint_r>
   1b4b4:	e1a03000 	mov	r3, r0
   1b4b8:	e3530000 	cmp	r3, #0
   1b4bc:	0a000000 	beq	1b4c4 <_svfprintf_r+0x21b0>
   1b4c0:	ea000176 	b	1baa0 <_svfprintf_r+0x278c>
   1b4c4:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1b4c8:	e51b20a4 	ldr	r2, [fp, #-164]	; 0xa4
   1b4cc:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1b4d0:	e0632002 	rsb	r2, r3, r2
   1b4d4:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1b4d8:	e1c33fc3 	bic	r3, r3, r3, asr #31
   1b4dc:	e0633002 	rsb	r3, r3, r2
   1b4e0:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1b4e4:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1b4e8:	e3530000 	cmp	r3, #0
   1b4ec:	da000038 	ble	1b5d4 <_svfprintf_r+0x22c0>
   1b4f0:	ea00001a 	b	1b560 <_svfprintf_r+0x224c>
   1b4f4:	e51f3a68 	ldr	r3, [pc, #-2664]	; 1aa94 <_svfprintf_r+0x1780>
   1b4f8:	e5843000 	str	r3, [r4]
   1b4fc:	e3a03010 	mov	r3, #16
   1b500:	e5843004 	str	r3, [r4, #4]
   1b504:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1b508:	e2833010 	add	r3, r3, #16
   1b50c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b510:	e2844008 	add	r4, r4, #8
   1b514:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b518:	e2833001 	add	r3, r3, #1
   1b51c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b520:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b524:	e3530007 	cmp	r3, #7
   1b528:	da000009 	ble	1b554 <_svfprintf_r+0x2240>
   1b52c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b530:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b534:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b538:	e1a02003 	mov	r2, r3
   1b53c:	eb002927 	bl	259e0 <__ssprint_r>
   1b540:	e1a03000 	mov	r3, r0
   1b544:	e3530000 	cmp	r3, #0
   1b548:	0a000000 	beq	1b550 <_svfprintf_r+0x223c>
   1b54c:	ea000153 	b	1baa0 <_svfprintf_r+0x278c>
   1b550:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1b554:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1b558:	e2433010 	sub	r3, r3, #16
   1b55c:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1b560:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1b564:	e3530010 	cmp	r3, #16
   1b568:	caffffe1 	bgt	1b4f4 <_svfprintf_r+0x21e0>
   1b56c:	e51f3ae0 	ldr	r3, [pc, #-2784]	; 1aa94 <_svfprintf_r+0x1780>
   1b570:	e5843000 	str	r3, [r4]
   1b574:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1b578:	e5843004 	str	r3, [r4, #4]
   1b57c:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1b580:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1b584:	e0823003 	add	r3, r2, r3
   1b588:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b58c:	e2844008 	add	r4, r4, #8
   1b590:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b594:	e2833001 	add	r3, r3, #1
   1b598:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b59c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b5a0:	e3530007 	cmp	r3, #7
   1b5a4:	da00000a 	ble	1b5d4 <_svfprintf_r+0x22c0>
   1b5a8:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b5ac:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b5b0:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b5b4:	e1a02003 	mov	r2, r3
   1b5b8:	eb002908 	bl	259e0 <__ssprint_r>
   1b5bc:	e1a03000 	mov	r3, r0
   1b5c0:	e3530000 	cmp	r3, #0
   1b5c4:	0a000000 	beq	1b5cc <_svfprintf_r+0x22b8>
   1b5c8:	ea000134 	b	1baa0 <_svfprintf_r+0x278c>
   1b5cc:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1b5d0:	ea0000c7 	b	1b8f4 <_svfprintf_r+0x25e0>
   1b5d4:	ea0000c6 	b	1b8f4 <_svfprintf_r+0x25e0>
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
   1b5d8:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1b5dc:	e3530001 	cmp	r3, #1
   1b5e0:	ca000002 	bgt	1b5f0 <_svfprintf_r+0x22dc>
   1b5e4:	e2063001 	and	r3, r6, #1
   1b5e8:	e3530000 	cmp	r3, #0
   1b5ec:	0a000090 	beq	1b834 <_svfprintf_r+0x2520>
					PRINT (cp, 1);
   1b5f0:	e5847000 	str	r7, [r4]
   1b5f4:	e3a03001 	mov	r3, #1
   1b5f8:	e5843004 	str	r3, [r4, #4]
   1b5fc:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1b600:	e2833001 	add	r3, r3, #1
   1b604:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b608:	e2844008 	add	r4, r4, #8
   1b60c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b610:	e2833001 	add	r3, r3, #1
   1b614:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b618:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b61c:	e3530007 	cmp	r3, #7
   1b620:	da000009 	ble	1b64c <_svfprintf_r+0x2338>
   1b624:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b628:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b62c:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b630:	e1a02003 	mov	r2, r3
   1b634:	eb0028e9 	bl	259e0 <__ssprint_r>
   1b638:	e1a03000 	mov	r3, r0
   1b63c:	e3530000 	cmp	r3, #0
   1b640:	0a000000 	beq	1b648 <_svfprintf_r+0x2334>
   1b644:	ea000115 	b	1baa0 <_svfprintf_r+0x278c>
   1b648:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					cp++;
   1b64c:	e2877001 	add	r7, r7, #1
					PRINT (decimal_point, decp_len);
   1b650:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1b654:	e5843000 	str	r3, [r4]
   1b658:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1b65c:	e5843004 	str	r3, [r4, #4]
   1b660:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1b664:	e1a02003 	mov	r2, r3
   1b668:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1b66c:	e0823003 	add	r3, r2, r3
   1b670:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b674:	e2844008 	add	r4, r4, #8
   1b678:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b67c:	e2833001 	add	r3, r3, #1
   1b680:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b684:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b688:	e3530007 	cmp	r3, #7
   1b68c:	da000009 	ble	1b6b8 <_svfprintf_r+0x23a4>
   1b690:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b694:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b698:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b69c:	e1a02003 	mov	r2, r3
   1b6a0:	eb0028ce 	bl	259e0 <__ssprint_r>
   1b6a4:	e1a03000 	mov	r3, r0
   1b6a8:	e3530000 	cmp	r3, #0
   1b6ac:	0a000000 	beq	1b6b4 <_svfprintf_r+0x23a0>
   1b6b0:	ea0000fa 	b	1baa0 <_svfprintf_r+0x278c>
   1b6b4:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					if (_fpvalue) {
   1b6b8:	e24b3094 	sub	r3, fp, #148	; 0x94
   1b6bc:	e893000c 	ldm	r3, {r2, r3}
   1b6c0:	e1a00002 	mov	r0, r2
   1b6c4:	e1a01003 	mov	r1, r3
   1b6c8:	e3a02000 	mov	r2, #0
   1b6cc:	e3a03000 	mov	r3, #0
   1b6d0:	ebffe664 	bl	15068 <__aeabi_dcmpeq>
   1b6d4:	e1a03000 	mov	r3, r0
   1b6d8:	e3530000 	cmp	r3, #0
   1b6dc:	1a00001a 	bne	1b74c <_svfprintf_r+0x2438>
						PRINT (cp, ndig - 1);
   1b6e0:	e5847000 	str	r7, [r4]
   1b6e4:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1b6e8:	e2433001 	sub	r3, r3, #1
   1b6ec:	e5843004 	str	r3, [r4, #4]
   1b6f0:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1b6f4:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1b6f8:	e2433001 	sub	r3, r3, #1
   1b6fc:	e0823003 	add	r3, r2, r3
   1b700:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b704:	e2844008 	add	r4, r4, #8
   1b708:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b70c:	e2833001 	add	r3, r3, #1
   1b710:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b714:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b718:	e3530007 	cmp	r3, #7
   1b71c:	da000043 	ble	1b830 <_svfprintf_r+0x251c>
   1b720:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b724:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b728:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b72c:	e1a02003 	mov	r2, r3
   1b730:	eb0028aa 	bl	259e0 <__ssprint_r>
   1b734:	e1a03000 	mov	r3, r0
   1b738:	e3530000 	cmp	r3, #0
   1b73c:	0a000000 	beq	1b744 <_svfprintf_r+0x2430>
   1b740:	ea0000d6 	b	1baa0 <_svfprintf_r+0x278c>
   1b744:	e24b40f0 	sub	r4, fp, #240	; 0xf0
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
					cp++;
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
   1b748:	ea000050 	b	1b890 <_svfprintf_r+0x257c>
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
   1b74c:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1b750:	e2435001 	sub	r5, r3, #1
   1b754:	e3550000 	cmp	r5, #0
   1b758:	da000034 	ble	1b830 <_svfprintf_r+0x251c>
   1b75c:	ea000018 	b	1b7c4 <_svfprintf_r+0x24b0>
   1b760:	e51f3cd4 	ldr	r3, [pc, #-3284]	; 1aa94 <_svfprintf_r+0x1780>
   1b764:	e5843000 	str	r3, [r4]
   1b768:	e3a03010 	mov	r3, #16
   1b76c:	e5843004 	str	r3, [r4, #4]
   1b770:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1b774:	e2833010 	add	r3, r3, #16
   1b778:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b77c:	e2844008 	add	r4, r4, #8
   1b780:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b784:	e2833001 	add	r3, r3, #1
   1b788:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b78c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b790:	e3530007 	cmp	r3, #7
   1b794:	da000009 	ble	1b7c0 <_svfprintf_r+0x24ac>
   1b798:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b79c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b7a0:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b7a4:	e1a02003 	mov	r2, r3
   1b7a8:	eb00288c 	bl	259e0 <__ssprint_r>
   1b7ac:	e1a03000 	mov	r3, r0
   1b7b0:	e3530000 	cmp	r3, #0
   1b7b4:	0a000000 	beq	1b7bc <_svfprintf_r+0x24a8>
   1b7b8:	ea0000b8 	b	1baa0 <_svfprintf_r+0x278c>
   1b7bc:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1b7c0:	e2455010 	sub	r5, r5, #16
   1b7c4:	e3550010 	cmp	r5, #16
   1b7c8:	caffffe4 	bgt	1b760 <_svfprintf_r+0x244c>
   1b7cc:	e51f3d40 	ldr	r3, [pc, #-3392]	; 1aa94 <_svfprintf_r+0x1780>
   1b7d0:	e5843000 	str	r3, [r4]
   1b7d4:	e1a03005 	mov	r3, r5
   1b7d8:	e5843004 	str	r3, [r4, #4]
   1b7dc:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1b7e0:	e0833005 	add	r3, r3, r5
   1b7e4:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b7e8:	e2844008 	add	r4, r4, #8
   1b7ec:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b7f0:	e2833001 	add	r3, r3, #1
   1b7f4:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b7f8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b7fc:	e3530007 	cmp	r3, #7
   1b800:	da00000a 	ble	1b830 <_svfprintf_r+0x251c>
   1b804:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b808:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b80c:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b810:	e1a02003 	mov	r2, r3
   1b814:	eb002871 	bl	259e0 <__ssprint_r>
   1b818:	e1a03000 	mov	r3, r0
   1b81c:	e3530000 	cmp	r3, #0
   1b820:	0a000000 	beq	1b828 <_svfprintf_r+0x2514>
   1b824:	ea00009d 	b	1baa0 <_svfprintf_r+0x278c>
   1b828:	e24b40f0 	sub	r4, fp, #240	; 0xf0
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
					cp++;
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
   1b82c:	ea000017 	b	1b890 <_svfprintf_r+0x257c>
   1b830:	ea000016 	b	1b890 <_svfprintf_r+0x257c>
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
				} else	/* XeYYY */
					PRINT (cp, 1);
   1b834:	e5847000 	str	r7, [r4]
   1b838:	e3a03001 	mov	r3, #1
   1b83c:	e5843004 	str	r3, [r4, #4]
   1b840:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1b844:	e2833001 	add	r3, r3, #1
   1b848:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b84c:	e2844008 	add	r4, r4, #8
   1b850:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b854:	e2833001 	add	r3, r3, #1
   1b858:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b85c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b860:	e3530007 	cmp	r3, #7
   1b864:	da000009 	ble	1b890 <_svfprintf_r+0x257c>
   1b868:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b86c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b870:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b874:	e1a02003 	mov	r2, r3
   1b878:	eb002858 	bl	259e0 <__ssprint_r>
   1b87c:	e1a03000 	mov	r3, r0
   1b880:	e3530000 	cmp	r3, #0
   1b884:	0a000000 	beq	1b88c <_svfprintf_r+0x2578>
   1b888:	ea000084 	b	1baa0 <_svfprintf_r+0x278c>
   1b88c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
				PRINT (expstr, expsize);
   1b890:	e24b30a0 	sub	r3, fp, #160	; 0xa0
   1b894:	e5843000 	str	r3, [r4]
   1b898:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1b89c:	e5843004 	str	r3, [r4, #4]
   1b8a0:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1b8a4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1b8a8:	e0823003 	add	r3, r2, r3
   1b8ac:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b8b0:	e2844008 	add	r4, r4, #8
   1b8b4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b8b8:	e2833001 	add	r3, r3, #1
   1b8bc:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b8c0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b8c4:	e3530007 	cmp	r3, #7
   1b8c8:	da000009 	ble	1b8f4 <_svfprintf_r+0x25e0>
   1b8cc:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b8d0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b8d4:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b8d8:	e1a02003 	mov	r2, r3
   1b8dc:	eb00283f 	bl	259e0 <__ssprint_r>
   1b8e0:	e1a03000 	mov	r3, r0
   1b8e4:	e3530000 	cmp	r3, #0
   1b8e8:	0a000000 	beq	1b8f0 <_svfprintf_r+0x25dc>
   1b8ec:	ea00006b 	b	1baa0 <_svfprintf_r+0x278c>
   1b8f0:	e24b40f0 	sub	r4, fp, #240	; 0xf0
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   1b8f4:	e2063004 	and	r3, r6, #4
   1b8f8:	e3530000 	cmp	r3, #0
   1b8fc:	0a000038 	beq	1b9e4 <_svfprintf_r+0x26d0>
			PAD (width - realsz, blanks);
   1b900:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1b904:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   1b908:	e0635002 	rsb	r5, r3, r2
   1b90c:	e3550000 	cmp	r5, #0
   1b910:	da000033 	ble	1b9e4 <_svfprintf_r+0x26d0>
   1b914:	ea000018 	b	1b97c <_svfprintf_r+0x2668>
   1b918:	e51f3e88 	ldr	r3, [pc, #-3720]	; 1aa98 <_svfprintf_r+0x1784>
   1b91c:	e5843000 	str	r3, [r4]
   1b920:	e3a03010 	mov	r3, #16
   1b924:	e5843004 	str	r3, [r4, #4]
   1b928:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1b92c:	e2833010 	add	r3, r3, #16
   1b930:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b934:	e2844008 	add	r4, r4, #8
   1b938:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b93c:	e2833001 	add	r3, r3, #1
   1b940:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b944:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b948:	e3530007 	cmp	r3, #7
   1b94c:	da000009 	ble	1b978 <_svfprintf_r+0x2664>
   1b950:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b954:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b958:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b95c:	e1a02003 	mov	r2, r3
   1b960:	eb00281e 	bl	259e0 <__ssprint_r>
   1b964:	e1a03000 	mov	r3, r0
   1b968:	e3530000 	cmp	r3, #0
   1b96c:	0a000000 	beq	1b974 <_svfprintf_r+0x2660>
   1b970:	ea00004a 	b	1baa0 <_svfprintf_r+0x278c>
   1b974:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1b978:	e2455010 	sub	r5, r5, #16
   1b97c:	e3550010 	cmp	r5, #16
   1b980:	caffffe4 	bgt	1b918 <_svfprintf_r+0x2604>
   1b984:	e51f3ef4 	ldr	r3, [pc, #-3828]	; 1aa98 <_svfprintf_r+0x1784>
   1b988:	e5843000 	str	r3, [r4]
   1b98c:	e1a03005 	mov	r3, r5
   1b990:	e5843004 	str	r3, [r4, #4]
   1b994:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1b998:	e0833005 	add	r3, r3, r5
   1b99c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1b9a0:	e2844008 	add	r4, r4, #8
   1b9a4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b9a8:	e2833001 	add	r3, r3, #1
   1b9ac:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1b9b0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1b9b4:	e3530007 	cmp	r3, #7
   1b9b8:	da000009 	ble	1b9e4 <_svfprintf_r+0x26d0>
   1b9bc:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1b9c0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1b9c4:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1b9c8:	e1a02003 	mov	r2, r3
   1b9cc:	eb002803 	bl	259e0 <__ssprint_r>
   1b9d0:	e1a03000 	mov	r3, r0
   1b9d4:	e3530000 	cmp	r3, #0
   1b9d8:	0a000000 	beq	1b9e0 <_svfprintf_r+0x26cc>
   1b9dc:	ea00002f 	b	1baa0 <_svfprintf_r+0x278c>
   1b9e0:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   1b9e4:	e51b2058 	ldr	r2, [fp, #-88]	; 0x58
   1b9e8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1b9ec:	e1520003 	cmp	r2, r3
   1b9f0:	a1a03002 	movge	r3, r2
   1b9f4:	b1a03003 	movlt	r3, r3
   1b9f8:	e51b2020 	ldr	r2, [fp, #-32]
   1b9fc:	e0823003 	add	r3, r2, r3
   1ba00:	e50b3020 	str	r3, [fp, #-32]

		FLUSH ();	/* copy out the I/O vectors */
   1ba04:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1ba08:	e3530000 	cmp	r3, #0
   1ba0c:	0a000008 	beq	1ba34 <_svfprintf_r+0x2720>
   1ba10:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1ba14:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ba18:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1ba1c:	e1a02003 	mov	r2, r3
   1ba20:	eb0027ee 	bl	259e0 <__ssprint_r>
   1ba24:	e1a03000 	mov	r3, r0
   1ba28:	e3530000 	cmp	r3, #0
   1ba2c:	0a000000 	beq	1ba34 <_svfprintf_r+0x2720>
   1ba30:	ea00001a 	b	1baa0 <_svfprintf_r+0x278c>
   1ba34:	e3a03000 	mov	r3, #0
   1ba38:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1ba3c:	e24b40f0 	sub	r4, fp, #240	; 0xf0

                if (malloc_buf != NULL) {
   1ba40:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   1ba44:	e3530000 	cmp	r3, #0
   1ba48:	0a000004 	beq	1ba60 <_svfprintf_r+0x274c>
			_free_r (data, malloc_buf);
   1ba4c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ba50:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
   1ba54:	ebffeb8d 	bl	16890 <_free_r>
			malloc_buf = NULL;
   1ba58:	e3a03000 	mov	r3, #0
   1ba5c:	e50b3064 	str	r3, [fp, #-100]	; 0x64
		}
	}
   1ba60:	eafff676 	b	19440 <_svfprintf_r+0x12c>
done:
	FLUSH ();
   1ba64:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1ba68:	e3530000 	cmp	r3, #0
   1ba6c:	0a000008 	beq	1ba94 <_svfprintf_r+0x2780>
   1ba70:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1ba74:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ba78:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1ba7c:	e1a02003 	mov	r2, r3
   1ba80:	eb0027d6 	bl	259e0 <__ssprint_r>
   1ba84:	e1a03000 	mov	r3, r0
   1ba88:	e3530000 	cmp	r3, #0
   1ba8c:	0a000000 	beq	1ba94 <_svfprintf_r+0x2780>
   1ba90:	ea000002 	b	1baa0 <_svfprintf_r+0x278c>
   1ba94:	e3a03000 	mov	r3, #0
   1ba98:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1ba9c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
error:
	if (malloc_buf != NULL)
   1baa0:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   1baa4:	e3530000 	cmp	r3, #0
   1baa8:	0a000002 	beq	1bab8 <_svfprintf_r+0x27a4>
		_free_r (data, malloc_buf);
   1baac:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1bab0:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
   1bab4:	ebffeb75 	bl	16890 <_free_r>
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
   1bab8:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1babc:	e1d330bc 	ldrh	r3, [r3, #12]
   1bac0:	e1a03803 	lsl	r3, r3, #16
   1bac4:	e1a03823 	lsr	r3, r3, #16
   1bac8:	e2033040 	and	r3, r3, #64	; 0x40
   1bacc:	e3530000 	cmp	r3, #0
   1bad0:	1a000001 	bne	1badc <_svfprintf_r+0x27c8>
   1bad4:	e51b3020 	ldr	r3, [fp, #-32]
   1bad8:	ea000000 	b	1bae0 <_svfprintf_r+0x27cc>
   1badc:	e3e03000 	mvn	r3, #0
   1bae0:	e1a00000 	nop			; (mov r0, r0)
	/* NOTREACHED */
}
   1bae4:	e1a00003 	mov	r0, r3
   1bae8:	e24bd01c 	sub	sp, fp, #28
   1baec:	e8bd4bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, lr}
   1baf0:	e12fff1e 	bx	lr

0001baf4 <cvt>:
   [aAeEfFgG]; if it is [aA], then the return string lives in BUF,
   otherwise the return value shares the mprec reentrant storage.  */
static char *
cvt(struct _reent *data, _PRINTF_FLOAT_TYPE value, int ndigits, int flags,
    char *sign, int *decpt, int ch, int *length, char *buf)
{
   1baf4:	e92d4810 	push	{r4, fp, lr}
   1baf8:	e28db008 	add	fp, sp, #8
   1bafc:	e24dd04c 	sub	sp, sp, #76	; 0x4c
   1bb00:	e50b0030 	str	r0, [fp, #-48]	; 0x30
   1bb04:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
   1bb08:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	int mode, dsgn;
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
   1bb0c:	e24b403c 	sub	r4, fp, #60	; 0x3c
   1bb10:	e8940018 	ldm	r4, {r3, r4}
   1bb14:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   1bb18:	e50b4028 	str	r4, [fp, #-40]	; 0x28
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   1bb1c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1bb20:	e3530000 	cmp	r3, #0
   1bb24:	aa000008 	bge	1bb4c <cvt+0x58>
		value = -value;
   1bb28:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1bb2c:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   1bb30:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1bb34:	e2233102 	eor	r3, r3, #-2147483648	; 0x80000000
   1bb38:	e50b3038 	str	r3, [fp, #-56]	; 0x38
		*sign = '-';
   1bb3c:	e59b300c 	ldr	r3, [fp, #12]
   1bb40:	e3a0202d 	mov	r2, #45	; 0x2d
   1bb44:	e5c32000 	strb	r2, [r3]
   1bb48:	ea000002 	b	1bb58 <cvt+0x64>
	} else
		*sign = '\000';
   1bb4c:	e59b300c 	ldr	r3, [fp, #12]
   1bb50:	e3a02000 	mov	r2, #0
   1bb54:	e5c32000 	strb	r2, [r3]
	} else
		*sign = '\000';
# endif /* !_NO_LONGDBL */

# ifdef _WANT_IO_C99_FORMATS
	if (ch == 'a' || ch == 'A') {
   1bb58:	e59b3014 	ldr	r3, [fp, #20]
   1bb5c:	e3530061 	cmp	r3, #97	; 0x61
   1bb60:	0a000002 	beq	1bb70 <cvt+0x7c>
   1bb64:	e59b3014 	ldr	r3, [fp, #20]
   1bb68:	e3530041 	cmp	r3, #65	; 0x41
   1bb6c:	1a000096 	bne	1bdcc <cvt+0x2d8>
		/* This code assumes FLT_RADIX is a power of 2.  The initial
		   division ensures the digit before the decimal will be less
		   than FLT_RADIX (unless it is rounded later).	 There is no
		   loss of precision in these calculations.  */
		value = FREXP (value, decpt) / 8;
   1bb70:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1bb74:	e8910003 	ldm	r1, {r0, r1}
   1bb78:	e59b2010 	ldr	r2, [fp, #16]
   1bb7c:	eb002653 	bl	254d0 <frexp>
   1bb80:	e1a03000 	mov	r3, r0
   1bb84:	e1a04001 	mov	r4, r1
   1bb88:	e1a00003 	mov	r0, r3
   1bb8c:	e1a01004 	mov	r1, r4
   1bb90:	e3a02000 	mov	r2, #0
   1bb94:	e59f33dc 	ldr	r3, [pc, #988]	; 1bf78 <cvt+0x484>
   1bb98:	ebffe47c 	bl	14d90 <__aeabi_ddiv>
   1bb9c:	e1a03000 	mov	r3, r0
   1bba0:	e1a04001 	mov	r4, r1
   1bba4:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   1bba8:	e50b4038 	str	r4, [fp, #-56]	; 0x38
		if (!value)
   1bbac:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1bbb0:	e8910003 	ldm	r1, {r0, r1}
   1bbb4:	e3a02000 	mov	r2, #0
   1bbb8:	e3a03000 	mov	r3, #0
   1bbbc:	ebffe529 	bl	15068 <__aeabi_dcmpeq>
   1bbc0:	e1a03000 	mov	r3, r0
   1bbc4:	e3530000 	cmp	r3, #0
   1bbc8:	0a000002 	beq	1bbd8 <cvt+0xe4>
			*decpt = 1;
   1bbcc:	e59b3010 	ldr	r3, [fp, #16]
   1bbd0:	e3a02001 	mov	r2, #1
   1bbd4:	e5832000 	str	r2, [r3]
		digits = ch == 'a' ? "0123456789abcdef" : "0123456789ABCDEF";
   1bbd8:	e59b3014 	ldr	r3, [fp, #20]
   1bbdc:	e3530061 	cmp	r3, #97	; 0x61
   1bbe0:	1a000001 	bne	1bbec <cvt+0xf8>
   1bbe4:	e59f3390 	ldr	r3, [pc, #912]	; 1bf7c <cvt+0x488>
   1bbe8:	ea000000 	b	1bbf0 <cvt+0xfc>
   1bbec:	e59f338c 	ldr	r3, [pc, #908]	; 1bf80 <cvt+0x48c>
   1bbf0:	e50b3018 	str	r3, [fp, #-24]
		bp = buf;
   1bbf4:	e59b301c 	ldr	r3, [fp, #28]
   1bbf8:	e50b3014 	str	r3, [fp, #-20]
		do {
			value *= 16;
   1bbfc:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1bc00:	e8910003 	ldm	r1, {r0, r1}
   1bc04:	e3a02000 	mov	r2, #0
   1bc08:	e59f3374 	ldr	r3, [pc, #884]	; 1bf84 <cvt+0x490>
   1bc0c:	ebffe3bb 	bl	14b00 <__aeabi_dmul>
   1bc10:	e1a03000 	mov	r3, r0
   1bc14:	e1a04001 	mov	r4, r1
   1bc18:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   1bc1c:	e50b4038 	str	r4, [fp, #-56]	; 0x38
			mode = (int) value;
   1bc20:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1bc24:	e8910003 	ldm	r1, {r0, r1}
   1bc28:	ebffe52c 	bl	150e0 <__aeabi_d2iz>
   1bc2c:	e1a03000 	mov	r3, r0
   1bc30:	e50b3010 	str	r3, [fp, #-16]
			value -= mode;
   1bc34:	e51b0010 	ldr	r0, [fp, #-16]
   1bc38:	ebffe379 	bl	14a24 <__aeabi_i2d>
   1bc3c:	e1a03000 	mov	r3, r0
   1bc40:	e1a04001 	mov	r4, r1
   1bc44:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1bc48:	e8910003 	ldm	r1, {r0, r1}
   1bc4c:	e1a02003 	mov	r2, r3
   1bc50:	e1a03004 	mov	r3, r4
   1bc54:	ebffe2a4 	bl	146ec <__aeabi_dsub>
   1bc58:	e1a03000 	mov	r3, r0
   1bc5c:	e1a04001 	mov	r4, r1
   1bc60:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   1bc64:	e50b4038 	str	r4, [fp, #-56]	; 0x38
			*bp++ = digits[mode];
   1bc68:	e51b3014 	ldr	r3, [fp, #-20]
   1bc6c:	e2832001 	add	r2, r3, #1
   1bc70:	e50b2014 	str	r2, [fp, #-20]
   1bc74:	e51b2010 	ldr	r2, [fp, #-16]
   1bc78:	e51b1018 	ldr	r1, [fp, #-24]
   1bc7c:	e0812002 	add	r2, r1, r2
   1bc80:	e5d22000 	ldrb	r2, [r2]
   1bc84:	e5c32000 	strb	r2, [r3]
		} while (ndigits-- && value);
   1bc88:	e59b3004 	ldr	r3, [fp, #4]
   1bc8c:	e2432001 	sub	r2, r3, #1
   1bc90:	e58b2004 	str	r2, [fp, #4]
   1bc94:	e3530000 	cmp	r3, #0
   1bc98:	0a000007 	beq	1bcbc <cvt+0x1c8>
   1bc9c:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1bca0:	e8910003 	ldm	r1, {r0, r1}
   1bca4:	e3a02000 	mov	r2, #0
   1bca8:	e3a03000 	mov	r3, #0
   1bcac:	ebffe4ed 	bl	15068 <__aeabi_dcmpeq>
   1bcb0:	e1a03000 	mov	r3, r0
   1bcb4:	e3530000 	cmp	r3, #0
   1bcb8:	0affffcf 	beq	1bbfc <cvt+0x108>
		if (value > 0.5 || (value == 0.5 && mode & 1)) {
   1bcbc:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1bcc0:	e8910003 	ldm	r1, {r0, r1}
   1bcc4:	e3a02000 	mov	r2, #0
   1bcc8:	e59f32b8 	ldr	r3, [pc, #696]	; 1bf88 <cvt+0x494>
   1bccc:	ebffe4fd 	bl	150c8 <__aeabi_dcmpgt>
   1bcd0:	e1a03000 	mov	r3, r0
   1bcd4:	e3530000 	cmp	r3, #0
   1bcd8:	1a00000b 	bne	1bd0c <cvt+0x218>
   1bcdc:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1bce0:	e8910003 	ldm	r1, {r0, r1}
   1bce4:	e3a02000 	mov	r2, #0
   1bce8:	e59f3298 	ldr	r3, [pc, #664]	; 1bf88 <cvt+0x494>
   1bcec:	ebffe4dd 	bl	15068 <__aeabi_dcmpeq>
   1bcf0:	e1a03000 	mov	r3, r0
   1bcf4:	e3530000 	cmp	r3, #0
   1bcf8:	0a000021 	beq	1bd84 <cvt+0x290>
   1bcfc:	e51b3010 	ldr	r3, [fp, #-16]
   1bd00:	e2033001 	and	r3, r3, #1
   1bd04:	e3530000 	cmp	r3, #0
   1bd08:	0a00001d 	beq	1bd84 <cvt+0x290>
			/* round to even */
			rve = bp;
   1bd0c:	e51b3014 	ldr	r3, [fp, #-20]
   1bd10:	e50b3020 	str	r3, [fp, #-32]
			while (*--rve == digits[0xf]) {
   1bd14:	ea000002 	b	1bd24 <cvt+0x230>
				*rve = '0';
   1bd18:	e51b3020 	ldr	r3, [fp, #-32]
   1bd1c:	e3a02030 	mov	r2, #48	; 0x30
   1bd20:	e5c32000 	strb	r2, [r3]
			*bp++ = digits[mode];
		} while (ndigits-- && value);
		if (value > 0.5 || (value == 0.5 && mode & 1)) {
			/* round to even */
			rve = bp;
			while (*--rve == digits[0xf]) {
   1bd24:	e51b3020 	ldr	r3, [fp, #-32]
   1bd28:	e2433001 	sub	r3, r3, #1
   1bd2c:	e50b3020 	str	r3, [fp, #-32]
   1bd30:	e51b3020 	ldr	r3, [fp, #-32]
   1bd34:	e5d32000 	ldrb	r2, [r3]
   1bd38:	e51b3018 	ldr	r3, [fp, #-24]
   1bd3c:	e283300f 	add	r3, r3, #15
   1bd40:	e5d33000 	ldrb	r3, [r3]
   1bd44:	e1520003 	cmp	r2, r3
   1bd48:	0afffff2 	beq	1bd18 <cvt+0x224>
				*rve = '0';
			}
			*rve = *rve == '9' ? digits[0xa] : *rve + 1;
   1bd4c:	e51b2020 	ldr	r2, [fp, #-32]
   1bd50:	e51b3020 	ldr	r3, [fp, #-32]
   1bd54:	e5d33000 	ldrb	r3, [r3]
   1bd58:	e3530039 	cmp	r3, #57	; 0x39
   1bd5c:	1a000002 	bne	1bd6c <cvt+0x278>
   1bd60:	e51b3018 	ldr	r3, [fp, #-24]
   1bd64:	e5d3300a 	ldrb	r3, [r3, #10]
   1bd68:	ea000003 	b	1bd7c <cvt+0x288>
   1bd6c:	e51b3020 	ldr	r3, [fp, #-32]
   1bd70:	e5d33000 	ldrb	r3, [r3]
   1bd74:	e2833001 	add	r3, r3, #1
   1bd78:	e20330ff 	and	r3, r3, #255	; 0xff
   1bd7c:	e5c23000 	strb	r3, [r2]
   1bd80:	ea00000a 	b	1bdb0 <cvt+0x2bc>
		} else {
			while (ndigits-- >= 0) {
   1bd84:	ea000004 	b	1bd9c <cvt+0x2a8>
				*bp++ = '0';
   1bd88:	e51b3014 	ldr	r3, [fp, #-20]
   1bd8c:	e2832001 	add	r2, r3, #1
   1bd90:	e50b2014 	str	r2, [fp, #-20]
   1bd94:	e3a02030 	mov	r2, #48	; 0x30
   1bd98:	e5c32000 	strb	r2, [r3]
			while (*--rve == digits[0xf]) {
				*rve = '0';
			}
			*rve = *rve == '9' ? digits[0xa] : *rve + 1;
		} else {
			while (ndigits-- >= 0) {
   1bd9c:	e59b3004 	ldr	r3, [fp, #4]
   1bda0:	e2432001 	sub	r2, r3, #1
   1bda4:	e58b2004 	str	r2, [fp, #4]
   1bda8:	e3530000 	cmp	r3, #0
   1bdac:	aafffff5 	bge	1bd88 <cvt+0x294>
				*bp++ = '0';
			}
		}
		*length = bp - buf;
   1bdb0:	e51b2014 	ldr	r2, [fp, #-20]
   1bdb4:	e59b301c 	ldr	r3, [fp, #28]
   1bdb8:	e0632002 	rsb	r2, r3, r2
   1bdbc:	e59b3018 	ldr	r3, [fp, #24]
   1bdc0:	e5832000 	str	r2, [r3]
		return buf;
   1bdc4:	e59b301c 	ldr	r3, [fp, #28]
   1bdc8:	ea000066 	b	1bf68 <cvt+0x474>
	}
# endif /* _WANT_IO_C99_FORMATS */
	if (ch == 'f' || ch == 'F') {
   1bdcc:	e59b3014 	ldr	r3, [fp, #20]
   1bdd0:	e3530066 	cmp	r3, #102	; 0x66
   1bdd4:	0a000002 	beq	1bde4 <cvt+0x2f0>
   1bdd8:	e59b3014 	ldr	r3, [fp, #20]
   1bddc:	e3530046 	cmp	r3, #70	; 0x46
   1bde0:	1a000002 	bne	1bdf0 <cvt+0x2fc>
		mode = 3;		/* ndigits after the decimal point */
   1bde4:	e3a03003 	mov	r3, #3
   1bde8:	e50b3010 	str	r3, [fp, #-16]
   1bdec:	ea00000a 	b	1be1c <cvt+0x328>
	} else {
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
   1bdf0:	e59b3014 	ldr	r3, [fp, #20]
   1bdf4:	e3530065 	cmp	r3, #101	; 0x65
   1bdf8:	0a000002 	beq	1be08 <cvt+0x314>
   1bdfc:	e59b3014 	ldr	r3, [fp, #20]
   1be00:	e3530045 	cmp	r3, #69	; 0x45
   1be04:	1a000002 	bne	1be14 <cvt+0x320>
			ndigits++;
   1be08:	e59b3004 	ldr	r3, [fp, #4]
   1be0c:	e2833001 	add	r3, r3, #1
   1be10:	e58b3004 	str	r3, [fp, #4]
		}
		mode = 2;		/* ndigits significant digits */
   1be14:	e3a03002 	mov	r3, #2
   1be18:	e50b3010 	str	r3, [fp, #-16]
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   1be1c:	e51b3010 	ldr	r3, [fp, #-16]
   1be20:	e58d3000 	str	r3, [sp]
   1be24:	e59b3004 	ldr	r3, [fp, #4]
   1be28:	e58d3004 	str	r3, [sp, #4]
   1be2c:	e59b3010 	ldr	r3, [fp, #16]
   1be30:	e58d3008 	str	r3, [sp, #8]
   1be34:	e24b301c 	sub	r3, fp, #28
   1be38:	e58d300c 	str	r3, [sp, #12]
   1be3c:	e24b3020 	sub	r3, fp, #32
   1be40:	e58d3010 	str	r3, [sp, #16]
   1be44:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   1be48:	e24b303c 	sub	r3, fp, #60	; 0x3c
   1be4c:	e893000c 	ldm	r3, {r2, r3}
   1be50:	eb000f9e 	bl	1fcd0 <_dtoa_r>
   1be54:	e50b0018 	str	r0, [fp, #-24]

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   1be58:	e59b3014 	ldr	r3, [fp, #20]
   1be5c:	e3530067 	cmp	r3, #103	; 0x67
   1be60:	0a000002 	beq	1be70 <cvt+0x37c>
   1be64:	e59b3014 	ldr	r3, [fp, #20]
   1be68:	e3530047 	cmp	r3, #71	; 0x47
   1be6c:	1a000003 	bne	1be80 <cvt+0x38c>
   1be70:	e59b3008 	ldr	r3, [fp, #8]
   1be74:	e2033001 	and	r3, r3, #1
   1be78:	e3530000 	cmp	r3, #0
   1be7c:	0a000032 	beq	1bf4c <cvt+0x458>
		bp = digits + ndigits;
   1be80:	e59b3004 	ldr	r3, [fp, #4]
   1be84:	e51b2018 	ldr	r2, [fp, #-24]
   1be88:	e0823003 	add	r3, r2, r3
   1be8c:	e50b3014 	str	r3, [fp, #-20]
		if (ch == 'f' || ch == 'F') {
   1be90:	e59b3014 	ldr	r3, [fp, #20]
   1be94:	e3530066 	cmp	r3, #102	; 0x66
   1be98:	0a000002 	beq	1bea8 <cvt+0x3b4>
   1be9c:	e59b3014 	ldr	r3, [fp, #20]
   1bea0:	e3530046 	cmp	r3, #70	; 0x46
   1bea4:	1a000014 	bne	1befc <cvt+0x408>
			if (*digits == '0' && value)
   1bea8:	e51b3018 	ldr	r3, [fp, #-24]
   1beac:	e5d33000 	ldrb	r3, [r3]
   1beb0:	e3530030 	cmp	r3, #48	; 0x30
   1beb4:	1a00000b 	bne	1bee8 <cvt+0x3f4>
   1beb8:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1bebc:	e8910003 	ldm	r1, {r0, r1}
   1bec0:	e3a02000 	mov	r2, #0
   1bec4:	e3a03000 	mov	r3, #0
   1bec8:	ebffe466 	bl	15068 <__aeabi_dcmpeq>
   1becc:	e1a03000 	mov	r3, r0
   1bed0:	e3530000 	cmp	r3, #0
   1bed4:	1a000003 	bne	1bee8 <cvt+0x3f4>
				*decpt = -ndigits + 1;
   1bed8:	e59b3004 	ldr	r3, [fp, #4]
   1bedc:	e2632001 	rsb	r2, r3, #1
   1bee0:	e59b3010 	ldr	r3, [fp, #16]
   1bee4:	e5832000 	str	r2, [r3]
			bp += *decpt;
   1bee8:	e59b3010 	ldr	r3, [fp, #16]
   1beec:	e5933000 	ldr	r3, [r3]
   1bef0:	e51b2014 	ldr	r2, [fp, #-20]
   1bef4:	e0823003 	add	r3, r2, r3
   1bef8:	e50b3014 	str	r3, [fp, #-20]
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
   1befc:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1bf00:	e8910003 	ldm	r1, {r0, r1}
   1bf04:	e3a02000 	mov	r2, #0
   1bf08:	e3a03000 	mov	r3, #0
   1bf0c:	ebffe455 	bl	15068 <__aeabi_dcmpeq>
   1bf10:	e1a03000 	mov	r3, r0
   1bf14:	e3530000 	cmp	r3, #0
   1bf18:	0a000001 	beq	1bf24 <cvt+0x430>
			rve = bp;
   1bf1c:	e51b3014 	ldr	r3, [fp, #-20]
   1bf20:	e50b3020 	str	r3, [fp, #-32]
		while (rve < bp)
   1bf24:	ea000004 	b	1bf3c <cvt+0x448>
			*rve++ = '0';
   1bf28:	e51b3020 	ldr	r3, [fp, #-32]
   1bf2c:	e2832001 	add	r2, r3, #1
   1bf30:	e50b2020 	str	r2, [fp, #-32]
   1bf34:	e3a02030 	mov	r2, #48	; 0x30
   1bf38:	e5c32000 	strb	r2, [r3]
				*decpt = -ndigits + 1;
			bp += *decpt;
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
   1bf3c:	e51b2020 	ldr	r2, [fp, #-32]
   1bf40:	e51b3014 	ldr	r3, [fp, #-20]
   1bf44:	e1520003 	cmp	r2, r3
   1bf48:	3afffff6 	bcc	1bf28 <cvt+0x434>
			*rve++ = '0';
	}
	*length = rve - digits;
   1bf4c:	e51b3020 	ldr	r3, [fp, #-32]
   1bf50:	e1a02003 	mov	r2, r3
   1bf54:	e51b3018 	ldr	r3, [fp, #-24]
   1bf58:	e0632002 	rsb	r2, r3, r2
   1bf5c:	e59b3018 	ldr	r3, [fp, #24]
   1bf60:	e5832000 	str	r2, [r3]
	return (digits);
   1bf64:	e51b3018 	ldr	r3, [fp, #-24]
}
   1bf68:	e1a00003 	mov	r0, r3
   1bf6c:	e24bd008 	sub	sp, fp, #8
   1bf70:	e8bd4810 	pop	{r4, fp, lr}
   1bf74:	e12fff1e 	bx	lr
   1bf78:	40200000 	.word	0x40200000
   1bf7c:	0003306c 	.word	0x0003306c
   1bf80:	00033088 	.word	0x00033088
   1bf84:	40300000 	.word	0x40300000
   1bf88:	3fe00000 	.word	0x3fe00000

0001bf8c <exponent>:

static int
exponent(char *p0, int exp, int fmtch)
{
   1bf8c:	e92d0830 	push	{r4, r5, fp}
   1bf90:	e28db008 	add	fp, sp, #8
   1bf94:	e24dd024 	sub	sp, sp, #36	; 0x24
   1bf98:	e50b0020 	str	r0, [fp, #-32]
   1bf9c:	e50b1024 	str	r1, [fp, #-36]	; 0x24
   1bfa0:	e50b2028 	str	r2, [fp, #-40]	; 0x28
	register char *p, *t;
	char expbuf[MAXEXPLEN];
# ifdef _WANT_IO_C99_FORMATS
	int isa = fmtch == 'a' || fmtch == 'A';
   1bfa4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1bfa8:	e3530061 	cmp	r3, #97	; 0x61
   1bfac:	0a000002 	beq	1bfbc <exponent+0x30>
   1bfb0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1bfb4:	e3530041 	cmp	r3, #65	; 0x41
   1bfb8:	1a000001 	bne	1bfc4 <exponent+0x38>
   1bfbc:	e3a03001 	mov	r3, #1
   1bfc0:	ea000000 	b	1bfc8 <exponent+0x3c>
   1bfc4:	e3a03000 	mov	r3, #0
   1bfc8:	e50b3010 	str	r3, [fp, #-16]
# else
#  define isa 0
# endif

	p = p0;
   1bfcc:	e51b4020 	ldr	r4, [fp, #-32]
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   1bfd0:	e1a03004 	mov	r3, r4
   1bfd4:	e2834001 	add	r4, r3, #1
   1bfd8:	e51b2010 	ldr	r2, [fp, #-16]
   1bfdc:	e3520000 	cmp	r2, #0
   1bfe0:	0a000004 	beq	1bff8 <exponent+0x6c>
   1bfe4:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   1bfe8:	e20220ff 	and	r2, r2, #255	; 0xff
   1bfec:	e282200f 	add	r2, r2, #15
   1bff0:	e20220ff 	and	r2, r2, #255	; 0xff
   1bff4:	ea000001 	b	1c000 <exponent+0x74>
   1bff8:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   1bffc:	e20220ff 	and	r2, r2, #255	; 0xff
   1c000:	e5c32000 	strb	r2, [r3]
	if (exp < 0) {
   1c004:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1c008:	e3530000 	cmp	r3, #0
   1c00c:	aa000007 	bge	1c030 <exponent+0xa4>
		exp = -exp;
   1c010:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1c014:	e2633000 	rsb	r3, r3, #0
   1c018:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		*p++ = '-';
   1c01c:	e1a03004 	mov	r3, r4
   1c020:	e2834001 	add	r4, r3, #1
   1c024:	e3a0202d 	mov	r2, #45	; 0x2d
   1c028:	e5c32000 	strb	r2, [r3]
   1c02c:	ea000003 	b	1c040 <exponent+0xb4>
	}
	else
		*p++ = '+';
   1c030:	e1a03004 	mov	r3, r4
   1c034:	e2834001 	add	r4, r3, #1
   1c038:	e3a0202b 	mov	r2, #43	; 0x2b
   1c03c:	e5c32000 	strb	r2, [r3]
	t = expbuf + MAXEXPLEN;
   1c040:	e24b5018 	sub	r5, fp, #24
   1c044:	e2855007 	add	r5, r5, #7
	if (exp > 9) {
   1c048:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1c04c:	e3530009 	cmp	r3, #9
   1c050:	da00002b 	ble	1c104 <exponent+0x178>
		do {
			*--t = to_char (exp % 10);
   1c054:	e2455001 	sub	r5, r5, #1
   1c058:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
   1c05c:	e59f30f4 	ldr	r3, [pc, #244]	; 1c158 <exponent+0x1cc>
   1c060:	e0c32391 	smull	r2, r3, r1, r3
   1c064:	e1a02143 	asr	r2, r3, #2
   1c068:	e1a03fc1 	asr	r3, r1, #31
   1c06c:	e0632002 	rsb	r2, r3, r2
   1c070:	e1a03002 	mov	r3, r2
   1c074:	e1a03103 	lsl	r3, r3, #2
   1c078:	e0833002 	add	r3, r3, r2
   1c07c:	e1a03083 	lsl	r3, r3, #1
   1c080:	e0632001 	rsb	r2, r3, r1
   1c084:	e20230ff 	and	r3, r2, #255	; 0xff
   1c088:	e2833030 	add	r3, r3, #48	; 0x30
   1c08c:	e20330ff 	and	r3, r3, #255	; 0xff
   1c090:	e5c53000 	strb	r3, [r5]
		} while ((exp /= 10) > 9);
   1c094:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1c098:	e59f20b8 	ldr	r2, [pc, #184]	; 1c158 <exponent+0x1cc>
   1c09c:	e0c21293 	smull	r1, r2, r3, r2
   1c0a0:	e1a02142 	asr	r2, r2, #2
   1c0a4:	e1a03fc3 	asr	r3, r3, #31
   1c0a8:	e0633002 	rsb	r3, r3, r2
   1c0ac:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   1c0b0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1c0b4:	e3530009 	cmp	r3, #9
   1c0b8:	caffffe5 	bgt	1c054 <exponent+0xc8>
		*--t = to_char (exp);
   1c0bc:	e2455001 	sub	r5, r5, #1
   1c0c0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1c0c4:	e20330ff 	and	r3, r3, #255	; 0xff
   1c0c8:	e2833030 	add	r3, r3, #48	; 0x30
   1c0cc:	e20330ff 	and	r3, r3, #255	; 0xff
   1c0d0:	e5c53000 	strb	r3, [r5]
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
   1c0d4:	ea000005 	b	1c0f0 <exponent+0x164>
   1c0d8:	e1a03004 	mov	r3, r4
   1c0dc:	e2834001 	add	r4, r3, #1
   1c0e0:	e1a02005 	mov	r2, r5
   1c0e4:	e2825001 	add	r5, r2, #1
   1c0e8:	e5d22000 	ldrb	r2, [r2]
   1c0ec:	e5c32000 	strb	r2, [r3]
   1c0f0:	e24b3018 	sub	r3, fp, #24
   1c0f4:	e2833007 	add	r3, r3, #7
   1c0f8:	e1550003 	cmp	r5, r3
   1c0fc:	3afffff5 	bcc	1c0d8 <exponent+0x14c>
   1c100:	ea00000d 	b	1c13c <exponent+0x1b0>
	}
	else {
		if (!isa)
   1c104:	e51b3010 	ldr	r3, [fp, #-16]
   1c108:	e3530000 	cmp	r3, #0
   1c10c:	1a000003 	bne	1c120 <exponent+0x194>
			*p++ = '0';
   1c110:	e1a03004 	mov	r3, r4
   1c114:	e2834001 	add	r4, r3, #1
   1c118:	e3a02030 	mov	r2, #48	; 0x30
   1c11c:	e5c32000 	strb	r2, [r3]
		*p++ = to_char (exp);
   1c120:	e1a03004 	mov	r3, r4
   1c124:	e2834001 	add	r4, r3, #1
   1c128:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1c12c:	e20220ff 	and	r2, r2, #255	; 0xff
   1c130:	e2822030 	add	r2, r2, #48	; 0x30
   1c134:	e20220ff 	and	r2, r2, #255	; 0xff
   1c138:	e5c32000 	strb	r2, [r3]
	}
	return (p - p0);
   1c13c:	e1a02004 	mov	r2, r4
   1c140:	e51b3020 	ldr	r3, [fp, #-32]
   1c144:	e0633002 	rsb	r3, r3, r2
}
   1c148:	e1a00003 	mov	r0, r3
   1c14c:	e24bd008 	sub	sp, fp, #8
   1c150:	e8bd0830 	pop	{r4, r5, fp}
   1c154:	e12fff1e 	bx	lr
   1c158:	66666667 	.word	0x66666667

0001c15c <__sbprintf>:
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   1c15c:	e92d4810 	push	{r4, fp, lr}
   1c160:	e28db008 	add	fp, sp, #8
   1c164:	e24ddd12 	sub	sp, sp, #1152	; 0x480
   1c168:	e24dd00c 	sub	sp, sp, #12
   1c16c:	e50b0488 	str	r0, [fp, #-1160]	; 0x488
   1c170:	e1a04001 	mov	r4, r1
   1c174:	e50b248c 	str	r2, [fp, #-1164]	; 0x48c
   1c178:	e50b3490 	str	r3, [fp, #-1168]	; 0x490
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   1c17c:	e1d430bc 	ldrh	r3, [r4, #12]
   1c180:	e3c33002 	bic	r3, r3, #2
   1c184:	e1a03803 	lsl	r3, r3, #16
   1c188:	e1a03823 	lsr	r3, r3, #16
   1c18c:	e14b37b8 	strh	r3, [fp, #-120]	; 0xffffff88
	fake._flags2 = fp->_flags2;
   1c190:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
   1c194:	e50b3018 	str	r3, [fp, #-24]
	fake._file = fp->_file;
   1c198:	e1d430be 	ldrh	r3, [r4, #14]
   1c19c:	e14b37b6 	strh	r3, [fp, #-118]	; 0xffffff8a
	fake._cookie = fp->_cookie;
   1c1a0:	e594301c 	ldr	r3, [r4, #28]
   1c1a4:	e50b3068 	str	r3, [fp, #-104]	; 0x68
	fake._write = fp->_write;
   1c1a8:	e5943024 	ldr	r3, [r4, #36]	; 0x24
   1c1ac:	e50b3060 	str	r3, [fp, #-96]	; 0x60

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   1c1b0:	e24b3e47 	sub	r3, fp, #1136	; 0x470
   1c1b4:	e243300c 	sub	r3, r3, #12
   1c1b8:	e2433008 	sub	r3, r3, #8
   1c1bc:	e50b3084 	str	r3, [fp, #-132]	; 0x84
   1c1c0:	e51b3084 	ldr	r3, [fp, #-132]	; 0x84
   1c1c4:	e50b3074 	str	r3, [fp, #-116]	; 0x74
	fake._bf._size = fake._w = sizeof (buf);
   1c1c8:	e3a03b01 	mov	r3, #1024	; 0x400
   1c1cc:	e50b307c 	str	r3, [fp, #-124]	; 0x7c
   1c1d0:	e51b307c 	ldr	r3, [fp, #-124]	; 0x7c
   1c1d4:	e50b3070 	str	r3, [fp, #-112]	; 0x70
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
   1c1d8:	e3a03000 	mov	r3, #0
   1c1dc:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
   1c1e0:	e24b3084 	sub	r3, fp, #132	; 0x84
   1c1e4:	e283305c 	add	r3, r3, #92	; 0x5c
   1c1e8:	e1a00003 	mov	r0, r3
   1c1ec:	ebffec52 	bl	1733c <_dna_lock_init>
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   1c1f0:	e24b3084 	sub	r3, fp, #132	; 0x84
   1c1f4:	e51b0488 	ldr	r0, [fp, #-1160]	; 0x488
   1c1f8:	e1a01003 	mov	r1, r3
   1c1fc:	e51b248c 	ldr	r2, [fp, #-1164]	; 0x48c
   1c200:	e51b3490 	ldr	r3, [fp, #-1168]	; 0x490
   1c204:	eb000034 	bl	1c2dc <_vfprintf_r>
   1c208:	e50b0010 	str	r0, [fp, #-16]
	if (ret >= 0 && _fflush_r (rptr, &fake))
   1c20c:	e51b3010 	ldr	r3, [fp, #-16]
   1c210:	e3530000 	cmp	r3, #0
   1c214:	ba000008 	blt	1c23c <__sbprintf+0xe0>
   1c218:	e24b3084 	sub	r3, fp, #132	; 0x84
   1c21c:	e51b0488 	ldr	r0, [fp, #-1160]	; 0x488
   1c220:	e1a01003 	mov	r1, r3
   1c224:	ebffe78d 	bl	16060 <_fflush_r>
   1c228:	e1a03000 	mov	r3, r0
   1c22c:	e3530000 	cmp	r3, #0
   1c230:	0a000001 	beq	1c23c <__sbprintf+0xe0>
		ret = EOF;
   1c234:	e3e03000 	mvn	r3, #0
   1c238:	e50b3010 	str	r3, [fp, #-16]
	if (fake._flags & __SERR)
   1c23c:	e15b37b8 	ldrh	r3, [fp, #-120]	; 0xffffff88
   1c240:	e1a03803 	lsl	r3, r3, #16
   1c244:	e1a03823 	lsr	r3, r3, #16
   1c248:	e2033040 	and	r3, r3, #64	; 0x40
   1c24c:	e3530000 	cmp	r3, #0
   1c250:	0a000004 	beq	1c268 <__sbprintf+0x10c>
		fp->_flags |= __SERR;
   1c254:	e1d430bc 	ldrh	r3, [r4, #12]
   1c258:	e3833040 	orr	r3, r3, #64	; 0x40
   1c25c:	e1a03803 	lsl	r3, r3, #16
   1c260:	e1a03823 	lsr	r3, r3, #16
   1c264:	e1c430bc 	strh	r3, [r4, #12]

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
   1c268:	e24b3084 	sub	r3, fp, #132	; 0x84
   1c26c:	e283305c 	add	r3, r3, #92	; 0x5c
   1c270:	e1a00003 	mov	r0, r3
   1c274:	ebffec5c 	bl	173ec <_dna_lock_close>
#endif
	return (ret);
   1c278:	e51b3010 	ldr	r3, [fp, #-16]
}
   1c27c:	e1a00003 	mov	r0, r3
   1c280:	e24bd008 	sub	sp, fp, #8
   1c284:	e8bd4810 	pop	{r4, fp, lr}
   1c288:	e12fff1e 	bx	lr

0001c28c <vfprintf>:
int
_DEFUN(VFPRINTF, (fp, fmt0, ap),
       FILE * fp         _AND
       _CONST char *fmt0 _AND
       va_list ap)
{
   1c28c:	e92d4800 	push	{fp, lr}
   1c290:	e28db004 	add	fp, sp, #4
   1c294:	e24dd018 	sub	sp, sp, #24
   1c298:	e50b0010 	str	r0, [fp, #-16]
   1c29c:	e50b1014 	str	r1, [fp, #-20]
   1c2a0:	e50b2018 	str	r2, [fp, #-24]
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   1c2a4:	e59f302c 	ldr	r3, [pc, #44]	; 1c2d8 <vfprintf+0x4c>
   1c2a8:	e5933000 	ldr	r3, [r3]
   1c2ac:	e1a00003 	mov	r0, r3
   1c2b0:	e51b1010 	ldr	r1, [fp, #-16]
   1c2b4:	e51b2014 	ldr	r2, [fp, #-20]
   1c2b8:	e51b3018 	ldr	r3, [fp, #-24]
   1c2bc:	eb000006 	bl	1c2dc <_vfprintf_r>
   1c2c0:	e50b0008 	str	r0, [fp, #-8]
  return result;
   1c2c4:	e51b3008 	ldr	r3, [fp, #-8]
}
   1c2c8:	e1a00003 	mov	r0, r3
   1c2cc:	e24bd004 	sub	sp, fp, #4
   1c2d0:	e8bd4800 	pop	{fp, lr}
   1c2d4:	e12fff1e 	bx	lr
   1c2d8:	0003e460 	.word	0x0003e460

0001c2dc <_vfprintf_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
   1c2dc:	e92d4bf0 	push	{r4, r5, r6, r7, r8, r9, fp, lr}
   1c2e0:	e28db01c 	add	fp, sp, #28
   1c2e4:	e24ddd06 	sub	sp, sp, #384	; 0x180
   1c2e8:	e50b0160 	str	r0, [fp, #-352]	; 0x160
   1c2ec:	e50b1164 	str	r1, [fp, #-356]	; 0x164
   1c2f0:	e50b2168 	str	r2, [fp, #-360]	; 0x168
   1c2f4:	e50b316c 	str	r3, [fp, #-364]	; 0x16c
	int width;		/* width from format (%8d), or 0 */
	int prec;		/* precision from format (%.3d), or -1 */
	char sign;		/* sign prefix (' ', '+', '-', or \0) */
#ifdef _WANT_IO_C99_FORMATS
				/* locale specific numeric grouping */
	char *thousands_sep = NULL;
   1c2f8:	e3a03000 	mov	r3, #0
   1c2fc:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	size_t thsnd_len = 0;
   1c300:	e3a03000 	mov	r3, #0
   1c304:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	const char *grouping = NULL;
   1c308:	e3a03000 	mov	r3, #0
   1c30c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
   1c310:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1c314:	eb0017e3 	bl	222a8 <_localeconv_r>
   1c318:	e1a03000 	mov	r3, r0
   1c31c:	e5933000 	ldr	r3, [r3]
   1c320:	e50b3074 	str	r3, [fp, #-116]	; 0x74
	size_t decp_len = strlen (decimal_point);
   1c324:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
   1c328:	ebfff3e0 	bl	192b0 <strlen>
   1c32c:	e50b0078 	str	r0, [fp, #-120]	; 0x78
	char softsign;		/* temporary negative sign for floats */
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
   1c330:	e3a03000 	mov	r3, #0
   1c334:	e3a04000 	mov	r4, #0
   1c338:	e50b3094 	str	r3, [fp, #-148]	; 0x94
   1c33c:	e50b4090 	str	r4, [fp, #-144]	; 0x90
# define _fpvalue (_double_.fp)
	int expt;		/* integer value of exponent */
	int expsize = 0;	/* character count for expstr */
   1c340:	e3a03000 	mov	r3, #0
   1c344:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	char expstr[MAXEXPLEN];	/* buffer for exponent string */
	int lead;		/* sig figs before decimal or group sep */
#endif /* FLOATING_POINT */
#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
	int ndig = 0;		/* actual number of digits returned by cvt */
   1c348:	e3a03000 	mov	r3, #0
   1c34c:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
   1c350:	e3a03000 	mov	r3, #0
   1c354:	e50b3060 	str	r3, [fp, #-96]	; 0x60
	char ox[2];		/* space for 0x hex-prefix */
#ifdef _MB_CAPABLE
	wchar_t wc;
	mbstate_t state;        /* mbtowc calls from library must not change state */
#endif
	char *malloc_buf = NULL;/* handy pointer for malloced buffers */
   1c358:	e3a03000 	mov	r3, #0
   1c35c:	e50b3064 	str	r3, [fp, #-100]	; 0x64
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
    CHECK_INIT (data, fp);
   1c360:	e51b3160 	ldr	r3, [fp, #-352]	; 0x160
   1c364:	e50b307c 	str	r3, [fp, #-124]	; 0x7c
   1c368:	e51b307c 	ldr	r3, [fp, #-124]	; 0x7c
   1c36c:	e3530000 	cmp	r3, #0
   1c370:	0a000005 	beq	1c38c <_vfprintf_r+0xb0>
   1c374:	e51b307c 	ldr	r3, [fp, #-124]	; 0x7c
   1c378:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   1c37c:	e3530000 	cmp	r3, #0
   1c380:	1a000001 	bne	1c38c <_vfprintf_r+0xb0>
   1c384:	e51b007c 	ldr	r0, [fp, #-124]	; 0x7c
   1c388:	ebffe87f 	bl	1658c <__sinit>
    cpu_dcache_invalidate((void*)&(fp->_flags), sizeof(short));
   1c38c:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c390:	e283300c 	add	r3, r3, #12
   1c394:	e1a00003 	mov	r0, r3
   1c398:	e3a01002 	mov	r1, #2
   1c39c:	ebffd0a7 	bl	10640 <cpu_dcache_invalidate>
    cpu_dcache_invalidate((void*)&(fp->_lock) , sizeof(_flock_t));
   1c3a0:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c3a4:	e283305c 	add	r3, r3, #92	; 0x5c
   1c3a8:	e1a00003 	mov	r0, r3
   1c3ac:	e3a01008 	mov	r1, #8
   1c3b0:	ebffd0a2 	bl	10640 <cpu_dcache_invalidate>
	_newlib_flockfile_start (fp);
   1c3b4:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c3b8:	e1d330bc 	ldrh	r3, [r3, #12]
   1c3bc:	e1a03803 	lsl	r3, r3, #16
   1c3c0:	e1a03823 	lsr	r3, r3, #16
   1c3c4:	e2033c02 	and	r3, r3, #512	; 0x200
   1c3c8:	e3530000 	cmp	r3, #0
   1c3cc:	1a000003 	bne	1c3e0 <_vfprintf_r+0x104>
   1c3d0:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c3d4:	e283305c 	add	r3, r3, #92	; 0x5c
   1c3d8:	e1a00003 	mov	r0, r3
   1c3dc:	ebffec27 	bl	17480 <_dna_lock_acquire>

    cpu_dcache_invalidate((void*)&(fp), sizeof(struct __sFILE));
   1c3e0:	e24b3f59 	sub	r3, fp, #356	; 0x164
   1c3e4:	e1a00003 	mov	r0, r3
   1c3e8:	e3a01070 	mov	r1, #112	; 0x70
   1c3ec:	ebffd093 	bl	10640 <cpu_dcache_invalidate>
    cpu_dcache_invalidate((void*)&(fp->_flags) ,sizeof(short));
   1c3f0:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c3f4:	e283300c 	add	r3, r3, #12
   1c3f8:	e1a00003 	mov	r0, r3
   1c3fc:	e3a01002 	mov	r1, #2
   1c400:	ebffd08e 	bl	10640 <cpu_dcache_invalidate>
    cpu_dcache_invalidate((void*)&(fp->_flags2), sizeof(int));
   1c404:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c408:	e283306c 	add	r3, r3, #108	; 0x6c
   1c40c:	e1a00003 	mov	r0, r3
   1c410:	e3a01004 	mov	r1, #4
   1c414:	ebffd089 	bl	10640 <cpu_dcache_invalidate>
    ORIENT(fp, -1);
   1c418:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c41c:	e1d330bc 	ldrh	r3, [r3, #12]
   1c420:	e1a03803 	lsl	r3, r3, #16
   1c424:	e1a03823 	lsr	r3, r3, #16
   1c428:	e2033a02 	and	r3, r3, #8192	; 0x2000
   1c42c:	e3530000 	cmp	r3, #0
   1c430:	1a00000b 	bne	1c464 <_vfprintf_r+0x188>
   1c434:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c438:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1c43c:	e1d220bc 	ldrh	r2, [r2, #12]
   1c440:	e3822a02 	orr	r2, r2, #8192	; 0x2000
   1c444:	e1a02802 	lsl	r2, r2, #16
   1c448:	e1a02822 	lsr	r2, r2, #16
   1c44c:	e1c320bc 	strh	r2, [r3, #12]
   1c450:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c454:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1c458:	e592206c 	ldr	r2, [r2, #108]	; 0x6c
   1c45c:	e3c22a02 	bic	r2, r2, #8192	; 0x2000
   1c460:	e583206c 	str	r2, [r3, #108]	; 0x6c

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   1c464:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c468:	e1d330bc 	ldrh	r3, [r3, #12]
   1c46c:	e1a03803 	lsl	r3, r3, #16
   1c470:	e1a03823 	lsr	r3, r3, #16
   1c474:	e2033008 	and	r3, r3, #8
   1c478:	e3530000 	cmp	r3, #0
   1c47c:	0a000003 	beq	1c490 <_vfprintf_r+0x1b4>
   1c480:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c484:	e5933010 	ldr	r3, [r3, #16]
   1c488:	e3530000 	cmp	r3, #0
   1c48c:	1a000013 	bne	1c4e0 <_vfprintf_r+0x204>
   1c490:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c494:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1c498:	e1a01003 	mov	r1, r3
   1c49c:	eb000bee 	bl	1f45c <__swsetup_r>
   1c4a0:	e1a03000 	mov	r3, r0
   1c4a4:	e3530000 	cmp	r3, #0
   1c4a8:	0a00000c 	beq	1c4e0 <_vfprintf_r+0x204>
		_newlib_flockfile_exit (fp);
   1c4ac:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c4b0:	e1d330bc 	ldrh	r3, [r3, #12]
   1c4b4:	e1a03803 	lsl	r3, r3, #16
   1c4b8:	e1a03823 	lsr	r3, r3, #16
   1c4bc:	e2033c02 	and	r3, r3, #512	; 0x200
   1c4c0:	e3530000 	cmp	r3, #0
   1c4c4:	1a000003 	bne	1c4d8 <_vfprintf_r+0x1fc>
   1c4c8:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c4cc:	e283305c 	add	r3, r3, #92	; 0x5c
   1c4d0:	e1a00003 	mov	r0, r3
   1c4d4:	ebffec50 	bl	1761c <_dna_lock_release>
		return (EOF);
   1c4d8:	e3e03000 	mvn	r3, #0
   1c4dc:	ea000a05 	b	1ecf8 <_vfprintf_r+0x2a1c>
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   1c4e0:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c4e4:	e1d330bc 	ldrh	r3, [r3, #12]
   1c4e8:	e1a03803 	lsl	r3, r3, #16
   1c4ec:	e1a03823 	lsr	r3, r3, #16
   1c4f0:	e203301a 	and	r3, r3, #26
   1c4f4:	e353000a 	cmp	r3, #10
   1c4f8:	1a000018 	bne	1c560 <_vfprintf_r+0x284>
	    fp->_file >= 0) {
   1c4fc:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c500:	e1d330be 	ldrh	r3, [r3, #14]
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   1c504:	e1a03803 	lsl	r3, r3, #16
   1c508:	e1a03843 	asr	r3, r3, #16
   1c50c:	e3530000 	cmp	r3, #0
   1c510:	ba000012 	blt	1c560 <_vfprintf_r+0x284>
	    fp->_file >= 0) {
		_newlib_flockfile_exit (fp);
   1c514:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c518:	e1d330bc 	ldrh	r3, [r3, #12]
   1c51c:	e1a03803 	lsl	r3, r3, #16
   1c520:	e1a03823 	lsr	r3, r3, #16
   1c524:	e2033c02 	and	r3, r3, #512	; 0x200
   1c528:	e3530000 	cmp	r3, #0
   1c52c:	1a000003 	bne	1c540 <_vfprintf_r+0x264>
   1c530:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c534:	e283305c 	add	r3, r3, #92	; 0x5c
   1c538:	e1a00003 	mov	r0, r3
   1c53c:	ebffec36 	bl	1761c <_dna_lock_release>
		return (__sbprintf (data, fp, fmt0, ap));
   1c540:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1c544:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1c548:	e1a01003 	mov	r1, r3
   1c54c:	e51b2168 	ldr	r2, [fp, #-360]	; 0x168
   1c550:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1c554:	ebffff00 	bl	1c15c <__sbprintf>
   1c558:	e1a03000 	mov	r3, r0
   1c55c:	ea0009e5 	b	1ecf8 <_vfprintf_r+0x2a1c>
		}
		fp->_bf._size = 64;
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
   1c560:	e51b9168 	ldr	r9, [fp, #-360]	; 0x168
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   1c564:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1c568:	e50b40b0 	str	r4, [fp, #-176]	; 0xb0
	uio.uio_resid = 0;
   1c56c:	e3a03000 	mov	r3, #0
   1c570:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
	uio.uio_iovcnt = 0;
   1c574:	e3a03000 	mov	r3, #0
   1c578:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
#endif
	ret = 0;
   1c57c:	e3a03000 	mov	r3, #0
   1c580:	e50b3020 	str	r3, [fp, #-32]

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
	        cp = fmt;
   1c584:	e1a07009 	mov	r7, r9
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   1c588:	ea000000 	b	1c590 <_vfprintf_r+0x2b4>
                    fmt += 1;
   1c58c:	e2899001 	add	r9, r9, #1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   1c590:	e5d93000 	ldrb	r3, [r9]
   1c594:	e3530000 	cmp	r3, #0
   1c598:	0a000002 	beq	1c5a8 <_vfprintf_r+0x2cc>
   1c59c:	e5d93000 	ldrb	r3, [r9]
   1c5a0:	e3530025 	cmp	r3, #37	; 0x25
   1c5a4:	1afffff8 	bne	1c58c <_vfprintf_r+0x2b0>
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
   1c5a8:	e1a02009 	mov	r2, r9
   1c5ac:	e1a03007 	mov	r3, r7
   1c5b0:	e0635002 	rsb	r5, r3, r2
   1c5b4:	e3550000 	cmp	r5, #0
   1c5b8:	0a00001a 	beq	1c628 <_vfprintf_r+0x34c>
			PRINT (cp, m);
   1c5bc:	e5847000 	str	r7, [r4]
   1c5c0:	e1a03005 	mov	r3, r5
   1c5c4:	e5843004 	str	r3, [r4, #4]
   1c5c8:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1c5cc:	e0833005 	add	r3, r3, r5
   1c5d0:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1c5d4:	e2844008 	add	r4, r4, #8
   1c5d8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1c5dc:	e2833001 	add	r3, r3, #1
   1c5e0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1c5e4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1c5e8:	e3530007 	cmp	r3, #7
   1c5ec:	da00000a 	ble	1c61c <_vfprintf_r+0x340>
   1c5f0:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1c5f4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1c5f8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1c5fc:	e1a01002 	mov	r1, r2
   1c600:	e1a02003 	mov	r2, r3
   1c604:	eb002ae9 	bl	271b0 <__sprint_r>
   1c608:	e1a03000 	mov	r3, r0
   1c60c:	e3530000 	cmp	r3, #0
   1c610:	0a000000 	beq	1c618 <_vfprintf_r+0x33c>
   1c614:	ea00099b 	b	1ec88 <_vfprintf_r+0x29ac>
   1c618:	e24b40f0 	sub	r4, fp, #240	; 0xf0
			ret += m;
   1c61c:	e51b3020 	ldr	r3, [fp, #-32]
   1c620:	e0833005 	add	r3, r3, r5
   1c624:	e50b3020 	str	r3, [fp, #-32]
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   1c628:	e5d93000 	ldrb	r3, [r9]
   1c62c:	e3530000 	cmp	r3, #0
   1c630:	1a000000 	bne	1c638 <_vfprintf_r+0x35c>
                    goto done;
   1c634:	ea000983 	b	1ec48 <_vfprintf_r+0x296c>
#endif
		fmt_anchor = fmt;
   1c638:	e50b9080 	str	r9, [fp, #-128]	; 0x80
		fmt++;		/* skip over '%' */
   1c63c:	e2899001 	add	r9, r9, #1

		flags = 0;
   1c640:	e3a06000 	mov	r6, #0
		dprec = 0;
   1c644:	e3a03000 	mov	r3, #0
   1c648:	e50b3054 	str	r3, [fp, #-84]	; 0x54
		width = 0;
   1c64c:	e3a03000 	mov	r3, #0
   1c650:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		prec = -1;
   1c654:	e3e03000 	mvn	r3, #0
   1c658:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		sign = '\0';
   1c65c:	e3a03000 	mov	r3, #0
   1c660:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
#ifdef FLOATING_POINT
		lead = 0;
   1c664:	e3a03000 	mov	r3, #0
   1c668:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
#ifdef _WANT_IO_C99_FORMATS
		nseps = nrepeats = 0;
   1c66c:	e3a03000 	mov	r3, #0
   1c670:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   1c674:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1c678:	e50b3040 	str	r3, [fp, #-64]	; 0x40
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   1c67c:	e1a03009 	mov	r3, r9
   1c680:	e2839001 	add	r9, r3, #1
   1c684:	e5d33000 	ldrb	r3, [r3]
   1c688:	e1a08003 	mov	r8, r3
reswitch:	switch (ch) {
   1c68c:	e2483020 	sub	r3, r8, #32
   1c690:	e353005a 	cmp	r3, #90	; 0x5a
   1c694:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   1c698:	ea000443 	b	1d7ac <_vfprintf_r+0x14d0>
   1c69c:	0001c86c 	.word	0x0001c86c
   1c6a0:	0001d7ac 	.word	0x0001d7ac
   1c6a4:	0001d7ac 	.word	0x0001d7ac
   1c6a8:	0001c884 	.word	0x0001c884
   1c6ac:	0001d7ac 	.word	0x0001d7ac
   1c6b0:	0001d7ac 	.word	0x0001d7ac
   1c6b4:	0001d7ac 	.word	0x0001d7ac
   1c6b8:	0001c808 	.word	0x0001c808
   1c6bc:	0001d7ac 	.word	0x0001d7ac
   1c6c0:	0001d7ac 	.word	0x0001d7ac
   1c6c4:	0001c88c 	.word	0x0001c88c
   1c6c8:	0001c8c4 	.word	0x0001c8c4
   1c6cc:	0001d7ac 	.word	0x0001d7ac
   1c6d0:	0001c8bc 	.word	0x0001c8bc
   1c6d4:	0001c8d0 	.word	0x0001c8d0
   1c6d8:	0001d7ac 	.word	0x0001d7ac
   1c6dc:	0001c96c 	.word	0x0001c96c
   1c6e0:	0001c974 	.word	0x0001c974
   1c6e4:	0001c974 	.word	0x0001c974
   1c6e8:	0001c974 	.word	0x0001c974
   1c6ec:	0001c974 	.word	0x0001c974
   1c6f0:	0001c974 	.word	0x0001c974
   1c6f4:	0001c974 	.word	0x0001c974
   1c6f8:	0001c974 	.word	0x0001c974
   1c6fc:	0001c974 	.word	0x0001c974
   1c700:	0001c974 	.word	0x0001c974
   1c704:	0001d7ac 	.word	0x0001d7ac
   1c708:	0001d7ac 	.word	0x0001d7ac
   1c70c:	0001d7ac 	.word	0x0001d7ac
   1c710:	0001d7ac 	.word	0x0001d7ac
   1c714:	0001d7ac 	.word	0x0001d7ac
   1c718:	0001d7ac 	.word	0x0001d7ac
   1c71c:	0001d7ac 	.word	0x0001d7ac
   1c720:	0001cb60 	.word	0x0001cb60
   1c724:	0001d7ac 	.word	0x0001d7ac
   1c728:	0001ca10 	.word	0x0001ca10
   1c72c:	0001ca40 	.word	0x0001ca40
   1c730:	0001cb60 	.word	0x0001cb60
   1c734:	0001cb60 	.word	0x0001cb60
   1c738:	0001cb60 	.word	0x0001cb60
   1c73c:	0001d7ac 	.word	0x0001d7ac
   1c740:	0001d7ac 	.word	0x0001d7ac
   1c744:	0001d7ac 	.word	0x0001d7ac
   1c748:	0001d7ac 	.word	0x0001d7ac
   1c74c:	0001c9b8 	.word	0x0001c9b8
   1c750:	0001d7ac 	.word	0x0001d7ac
   1c754:	0001d7ac 	.word	0x0001d7ac
   1c758:	0001d0d4 	.word	0x0001d0d4
   1c75c:	0001d7ac 	.word	0x0001d7ac
   1c760:	0001d7ac 	.word	0x0001d7ac
   1c764:	0001d7ac 	.word	0x0001d7ac
   1c768:	0001d204 	.word	0x0001d204
   1c76c:	0001d7ac 	.word	0x0001d7ac
   1c770:	0001d2c4 	.word	0x0001d2c4
   1c774:	0001d7ac 	.word	0x0001d7ac
   1c778:	0001d7ac 	.word	0x0001d7ac
   1c77c:	0001d3a4 	.word	0x0001d3a4
   1c780:	0001d7ac 	.word	0x0001d7ac
   1c784:	0001d7ac 	.word	0x0001d7ac
   1c788:	0001d7ac 	.word	0x0001d7ac
   1c78c:	0001d7ac 	.word	0x0001d7ac
   1c790:	0001d7ac 	.word	0x0001d7ac
   1c794:	0001d7ac 	.word	0x0001d7ac
   1c798:	0001d7ac 	.word	0x0001d7ac
   1c79c:	0001d7ac 	.word	0x0001d7ac
   1c7a0:	0001cb60 	.word	0x0001cb60
   1c7a4:	0001d7ac 	.word	0x0001d7ac
   1c7a8:	0001ca10 	.word	0x0001ca10
   1c7ac:	0001ca44 	.word	0x0001ca44
   1c7b0:	0001cb60 	.word	0x0001cb60
   1c7b4:	0001cb60 	.word	0x0001cb60
   1c7b8:	0001cb60 	.word	0x0001cb60
   1c7bc:	0001c9c0 	.word	0x0001c9c0
   1c7c0:	0001ca44 	.word	0x0001ca44
   1c7c4:	0001ca08 	.word	0x0001ca08
   1c7c8:	0001d7ac 	.word	0x0001d7ac
   1c7cc:	0001c9e0 	.word	0x0001c9e0
   1c7d0:	0001d7ac 	.word	0x0001d7ac
   1c7d4:	0001d000 	.word	0x0001d000
   1c7d8:	0001d0d8 	.word	0x0001d0d8
   1c7dc:	0001d1b8 	.word	0x0001d1b8
   1c7e0:	0001ca00 	.word	0x0001ca00
   1c7e4:	0001d7ac 	.word	0x0001d7ac
   1c7e8:	0001d204 	.word	0x0001d204
   1c7ec:	0001c67c 	.word	0x0001c67c
   1c7f0:	0001d2c8 	.word	0x0001d2c8
   1c7f4:	0001d7ac 	.word	0x0001d7ac
   1c7f8:	0001d7ac 	.word	0x0001d7ac
   1c7fc:	0001d3b0 	.word	0x0001d3b0
   1c800:	0001d7ac 	.word	0x0001d7ac
   1c804:	0001c67c 	.word	0x0001c67c
#ifdef _WANT_IO_C99_FORMATS
		case '\'':
			thousands_sep = _localeconv_r (data)->thousands_sep;
   1c808:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1c80c:	eb0016a5 	bl	222a8 <_localeconv_r>
   1c810:	e1a03000 	mov	r3, r0
   1c814:	e5933004 	ldr	r3, [r3, #4]
   1c818:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
			thsnd_len = strlen (thousands_sep);
   1c81c:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
   1c820:	ebfff2a2 	bl	192b0 <strlen>
   1c824:	e50b0030 	str	r0, [fp, #-48]	; 0x30
			grouping = _localeconv_r (data)->grouping;
   1c828:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1c82c:	eb00169d 	bl	222a8 <_localeconv_r>
   1c830:	e1a03000 	mov	r3, r0
   1c834:	e5933008 	ldr	r3, [r3, #8]
   1c838:	e50b3034 	str	r3, [fp, #-52]	; 0x34
			if (thsnd_len > 0 && grouping && *grouping)
   1c83c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1c840:	e3530000 	cmp	r3, #0
   1c844:	0a000007 	beq	1c868 <_vfprintf_r+0x58c>
   1c848:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1c84c:	e3530000 	cmp	r3, #0
   1c850:	0a000004 	beq	1c868 <_vfprintf_r+0x58c>
   1c854:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1c858:	e5d33000 	ldrb	r3, [r3]
   1c85c:	e3530000 	cmp	r3, #0
   1c860:	0a000000 	beq	1c868 <_vfprintf_r+0x58c>
			  flags |= GROUPING;
   1c864:	e3866b01 	orr	r6, r6, #1024	; 0x400
			goto rflag;
   1c868:	eaffff83 	b	1c67c <_vfprintf_r+0x3a0>
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
   1c86c:	e55b3089 	ldrb	r3, [fp, #-137]	; 0x89
   1c870:	e3530000 	cmp	r3, #0
   1c874:	1a000001 	bne	1c880 <_vfprintf_r+0x5a4>
				sign = ' ';
   1c878:	e3a03020 	mov	r3, #32
   1c87c:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
			goto rflag;
   1c880:	eaffff7d 	b	1c67c <_vfprintf_r+0x3a0>
		case '#':
			flags |= ALT;
   1c884:	e3866001 	orr	r6, r6, #1
			goto rflag;
   1c888:	eaffff7b 	b	1c67c <_vfprintf_r+0x3a0>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   1c88c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1c890:	e2832004 	add	r2, r3, #4
   1c894:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1c898:	e5933000 	ldr	r3, [r3]
   1c89c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
   1c8a0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1c8a4:	e3530000 	cmp	r3, #0
   1c8a8:	ba000000 	blt	1c8b0 <_vfprintf_r+0x5d4>
				goto rflag;
   1c8ac:	eaffff72 	b	1c67c <_vfprintf_r+0x3a0>
			width = -width;
   1c8b0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1c8b4:	e2633000 	rsb	r3, r3, #0
   1c8b8:	e50b3024 	str	r3, [fp, #-36]	; 0x24
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
   1c8bc:	e3866004 	orr	r6, r6, #4
			goto rflag;
   1c8c0:	eaffff6d 	b	1c67c <_vfprintf_r+0x3a0>
		case '+':
			sign = '+';
   1c8c4:	e3a0302b 	mov	r3, #43	; 0x2b
   1c8c8:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
			goto rflag;
   1c8cc:	eaffff6a 	b	1c67c <_vfprintf_r+0x3a0>
		case '.':
			if ((ch = *fmt++) == '*') {
   1c8d0:	e1a03009 	mov	r3, r9
   1c8d4:	e2839001 	add	r9, r3, #1
   1c8d8:	e5d33000 	ldrb	r3, [r3]
   1c8dc:	e1a08003 	mov	r8, r3
   1c8e0:	e358002a 	cmp	r8, #42	; 0x2a
   1c8e4:	1a00000a 	bne	1c914 <_vfprintf_r+0x638>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   1c8e8:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1c8ec:	e2832004 	add	r2, r3, #4
   1c8f0:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1c8f4:	e5933000 	ldr	r3, [r3]
   1c8f8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   1c8fc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1c900:	e3530000 	cmp	r3, #0
   1c904:	aa000001 	bge	1c910 <_vfprintf_r+0x634>
					prec = -1;
   1c908:	e3e03000 	mvn	r3, #0
   1c90c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
				goto rflag;
   1c910:	eaffff59 	b	1c67c <_vfprintf_r+0x3a0>
			}
			n = 0;
   1c914:	e3a05000 	mov	r5, #0
			while (is_digit (ch)) {
   1c918:	ea00000a 	b	1c948 <_vfprintf_r+0x66c>
				n = 10 * n + to_digit (ch);
   1c91c:	e1a03005 	mov	r3, r5
   1c920:	e1a03103 	lsl	r3, r3, #2
   1c924:	e0833005 	add	r3, r3, r5
   1c928:	e1a03083 	lsl	r3, r3, #1
   1c92c:	e1a02003 	mov	r2, r3
   1c930:	e2483030 	sub	r3, r8, #48	; 0x30
   1c934:	e0825003 	add	r5, r2, r3
				ch = *fmt++;
   1c938:	e1a03009 	mov	r3, r9
   1c93c:	e2839001 	add	r9, r3, #1
   1c940:	e5d33000 	ldrb	r3, [r3]
   1c944:	e1a08003 	mov	r8, r3
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   1c948:	e2483030 	sub	r3, r8, #48	; 0x30
   1c94c:	e3530009 	cmp	r3, #9
   1c950:	9afffff1 	bls	1c91c <_vfprintf_r+0x640>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
   1c954:	e3e03000 	mvn	r3, #0
   1c958:	e1550003 	cmp	r5, r3
   1c95c:	a1a03005 	movge	r3, r5
   1c960:	b1a03003 	movlt	r3, r3
   1c964:	e50b3028 	str	r3, [fp, #-40]	; 0x28
			goto reswitch;
   1c968:	eaffff47 	b	1c68c <_vfprintf_r+0x3b0>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
   1c96c:	e3866080 	orr	r6, r6, #128	; 0x80
			goto rflag;
   1c970:	eaffff41 	b	1c67c <_vfprintf_r+0x3a0>
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
   1c974:	e3a05000 	mov	r5, #0
			do {
				n = 10 * n + to_digit (ch);
   1c978:	e1a03005 	mov	r3, r5
   1c97c:	e1a03103 	lsl	r3, r3, #2
   1c980:	e0833005 	add	r3, r3, r5
   1c984:	e1a03083 	lsl	r3, r3, #1
   1c988:	e1a02003 	mov	r2, r3
   1c98c:	e2483030 	sub	r3, r8, #48	; 0x30
   1c990:	e0825003 	add	r5, r2, r3
				ch = *fmt++;
   1c994:	e1a03009 	mov	r3, r9
   1c998:	e2839001 	add	r9, r3, #1
   1c99c:	e5d33000 	ldrb	r3, [r3]
   1c9a0:	e1a08003 	mov	r8, r3
			} while (is_digit (ch));
   1c9a4:	e2483030 	sub	r3, r8, #48	; 0x30
   1c9a8:	e3530009 	cmp	r3, #9
   1c9ac:	9afffff1 	bls	1c978 <_vfprintf_r+0x69c>
				}
				else
					goto error;
			}
#endif /* !_NO_POS_ARGS */
			width = n;
   1c9b0:	e50b5024 	str	r5, [fp, #-36]	; 0x24
			goto reswitch;
   1c9b4:	eaffff34 	b	1c68c <_vfprintf_r+0x3b0>
#ifdef FLOATING_POINT
		case 'L':
			flags |= LONGDBL;
   1c9b8:	e3866008 	orr	r6, r6, #8
			goto rflag;
   1c9bc:	eaffff2e 	b	1c67c <_vfprintf_r+0x3a0>
#endif
		case 'h':
#ifdef _WANT_IO_C99_FORMATS
			if (*fmt == 'h') {
   1c9c0:	e5d93000 	ldrb	r3, [r9]
   1c9c4:	e3530068 	cmp	r3, #104	; 0x68
   1c9c8:	1a000002 	bne	1c9d8 <_vfprintf_r+0x6fc>
				fmt++;
   1c9cc:	e2899001 	add	r9, r9, #1
				flags |= CHARINT;
   1c9d0:	e3866c02 	orr	r6, r6, #512	; 0x200
   1c9d4:	ea000000 	b	1c9dc <_vfprintf_r+0x700>
			} else
#endif
				flags |= SHORTINT;
   1c9d8:	e3866040 	orr	r6, r6, #64	; 0x40
			goto rflag;
   1c9dc:	eaffff26 	b	1c67c <_vfprintf_r+0x3a0>
		case 'l':
#if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
			if (*fmt == 'l') {
   1c9e0:	e5d93000 	ldrb	r3, [r9]
   1c9e4:	e353006c 	cmp	r3, #108	; 0x6c
   1c9e8:	1a000002 	bne	1c9f8 <_vfprintf_r+0x71c>
				fmt++;
   1c9ec:	e2899001 	add	r9, r9, #1
				flags |= QUADINT;
   1c9f0:	e3866020 	orr	r6, r6, #32
   1c9f4:	ea000000 	b	1c9fc <_vfprintf_r+0x720>
			} else
#endif
				flags |= LONGINT;
   1c9f8:	e3866010 	orr	r6, r6, #16
			goto rflag;
   1c9fc:	eaffff1e 	b	1c67c <_vfprintf_r+0x3a0>
		case 'q': /* extension */
			flags |= QUADINT;
   1ca00:	e3866020 	orr	r6, r6, #32
			goto rflag;
   1ca04:	eaffff1c 	b	1c67c <_vfprintf_r+0x3a0>
#ifdef _WANT_IO_C99_FORMATS
		case 'j':
		  if (sizeof (intmax_t) == sizeof (long))
		    flags |= LONGINT;
		  else
		    flags |= QUADINT;
   1ca08:	e3866020 	orr	r6, r6, #32
		  goto rflag;
   1ca0c:	eaffff1a 	b	1c67c <_vfprintf_r+0x3a0>
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
   1ca10:	e24b7f55 	sub	r7, fp, #340	; 0x154
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   1ca14:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1ca18:	e2832004 	add	r2, r3, #4
   1ca1c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1ca20:	e5933000 	ldr	r3, [r3]
   1ca24:	e20330ff 	and	r3, r3, #255	; 0xff
   1ca28:	e5c73000 	strb	r3, [r7]
				size = 1;
   1ca2c:	e3a03001 	mov	r3, #1
   1ca30:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
			}
			sign = '\0';
   1ca34:	e3a03000 	mov	r3, #0
   1ca38:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
			break;
   1ca3c:	ea000365 	b	1d7d8 <_vfprintf_r+0x14fc>
		case 'D':  /* extension */
			flags |= LONGINT;
   1ca40:	e3866010 	orr	r6, r6, #16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   1ca44:	e2063020 	and	r3, r6, #32
   1ca48:	e3530000 	cmp	r3, #0
   1ca4c:	0a000006 	beq	1ca6c <_vfprintf_r+0x790>
   1ca50:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1ca54:	e2833007 	add	r3, r3, #7
   1ca58:	e3c33007 	bic	r3, r3, #7
   1ca5c:	e2832008 	add	r2, r3, #8
   1ca60:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1ca64:	e893000c 	ldm	r3, {r2, r3}
   1ca68:	ea00002a 	b	1cb18 <_vfprintf_r+0x83c>
   1ca6c:	e2063010 	and	r3, r6, #16
   1ca70:	e3530000 	cmp	r3, #0
   1ca74:	0a000006 	beq	1ca94 <_vfprintf_r+0x7b8>
   1ca78:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1ca7c:	e2832004 	add	r2, r3, #4
   1ca80:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1ca84:	e5933000 	ldr	r3, [r3]
   1ca88:	e1a02003 	mov	r2, r3
   1ca8c:	e1a03fc2 	asr	r3, r2, #31
   1ca90:	ea000020 	b	1cb18 <_vfprintf_r+0x83c>
   1ca94:	e2063040 	and	r3, r6, #64	; 0x40
   1ca98:	e3530000 	cmp	r3, #0
   1ca9c:	0a00000a 	beq	1cacc <_vfprintf_r+0x7f0>
   1caa0:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1caa4:	e2832004 	add	r2, r3, #4
   1caa8:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1caac:	e5933000 	ldr	r3, [r3]
   1cab0:	e1a03803 	lsl	r3, r3, #16
   1cab4:	e1a01823 	lsr	r1, r3, #16
   1cab8:	e1a03801 	lsl	r3, r1, #16
   1cabc:	e1a03843 	asr	r3, r3, #16
   1cac0:	e1a02003 	mov	r2, r3
   1cac4:	e1a03fc2 	asr	r3, r2, #31
   1cac8:	ea000012 	b	1cb18 <_vfprintf_r+0x83c>
   1cacc:	e2063c02 	and	r3, r6, #512	; 0x200
   1cad0:	e3530000 	cmp	r3, #0
   1cad4:	0a000009 	beq	1cb00 <_vfprintf_r+0x824>
   1cad8:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1cadc:	e2832004 	add	r2, r3, #4
   1cae0:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1cae4:	e5933000 	ldr	r3, [r3]
   1cae8:	e20310ff 	and	r1, r3, #255	; 0xff
   1caec:	e1a03c01 	lsl	r3, r1, #24
   1caf0:	e1a03c43 	asr	r3, r3, #24
   1caf4:	e1a02003 	mov	r2, r3
   1caf8:	e1a03fc2 	asr	r3, r2, #31
   1cafc:	ea000005 	b	1cb18 <_vfprintf_r+0x83c>
   1cb00:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1cb04:	e2832004 	add	r2, r3, #4
   1cb08:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1cb0c:	e5933000 	ldr	r3, [r3]
   1cb10:	e1a02003 	mov	r2, r3
   1cb14:	e1a03fc2 	asr	r3, r2, #31
   1cb18:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1cb1c:	e50b3048 	str	r3, [fp, #-72]	; 0x48
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
   1cb20:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1cb24:	e893000c 	ldm	r3, {r2, r3}
   1cb28:	e3520000 	cmp	r2, #0
   1cb2c:	e2d31000 	sbcs	r1, r3, #0
   1cb30:	aa000007 	bge	1cb54 <_vfprintf_r+0x878>
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
   1cb34:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1cb38:	e893000c 	ldm	r3, {r2, r3}
   1cb3c:	e2722000 	rsbs	r2, r2, #0
   1cb40:	e2e33000 	rsc	r3, r3, #0
   1cb44:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1cb48:	e50b3048 	str	r3, [fp, #-72]	; 0x48
				sign = '-';
   1cb4c:	e3a0302d 	mov	r3, #45	; 0x2d
   1cb50:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
			}
			base = DEC;
   1cb54:	e3a03001 	mov	r3, #1
   1cb58:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
			goto number;
   1cb5c:	ea00025a 	b	1d4cc <_vfprintf_r+0x11f0>
		case 'E':
		case 'f':
		case 'g':
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
   1cb60:	e2063008 	and	r3, r6, #8
   1cb64:	e3530000 	cmp	r3, #0
   1cb68:	0a000008 	beq	1cb90 <_vfprintf_r+0x8b4>
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
   1cb6c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1cb70:	e2833007 	add	r3, r3, #7
   1cb74:	e3c33007 	bic	r3, r3, #7
   1cb78:	e2832008 	add	r2, r3, #8
   1cb7c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1cb80:	e893000c 	ldm	r3, {r2, r3}
   1cb84:	e50b2094 	str	r2, [fp, #-148]	; 0x94
   1cb88:	e50b3090 	str	r3, [fp, #-144]	; 0x90
   1cb8c:	ea000007 	b	1cbb0 <_vfprintf_r+0x8d4>
			} else {
				_fpvalue = GET_ARG (N, ap, double);
   1cb90:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1cb94:	e2833007 	add	r3, r3, #7
   1cb98:	e3c33007 	bic	r3, r3, #7
   1cb9c:	e2832008 	add	r2, r3, #8
   1cba0:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1cba4:	e893000c 	ldm	r3, {r2, r3}
   1cba8:	e50b2094 	str	r2, [fp, #-148]	; 0x94
   1cbac:	e50b3090 	str	r3, [fp, #-144]	; 0x90

			   If the output is infinite or NaN, leading
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
   1cbb0:	e24b3094 	sub	r3, fp, #148	; 0x94
   1cbb4:	e893000c 	ldm	r3, {r2, r3}
   1cbb8:	e1a00002 	mov	r0, r2
   1cbbc:	e1a01003 	mov	r1, r3
   1cbc0:	eb0021f4 	bl	25398 <__fpclassifyd>
   1cbc4:	e1a03000 	mov	r3, r0
   1cbc8:	e3530001 	cmp	r3, #1
   1cbcc:	1a000014 	bne	1cc24 <_vfprintf_r+0x948>
				if (_fpvalue < 0)
   1cbd0:	e24b3094 	sub	r3, fp, #148	; 0x94
   1cbd4:	e893000c 	ldm	r3, {r2, r3}
   1cbd8:	e1a00002 	mov	r0, r2
   1cbdc:	e1a01003 	mov	r1, r3
   1cbe0:	e3a02000 	mov	r2, #0
   1cbe4:	e3a03000 	mov	r3, #0
   1cbe8:	ebffe124 	bl	15080 <__aeabi_dcmplt>
   1cbec:	e1a03000 	mov	r3, r0
   1cbf0:	e3530000 	cmp	r3, #0
   1cbf4:	0a000001 	beq	1cc00 <_vfprintf_r+0x924>
					sign = '-';
   1cbf8:	e3a0302d 	mov	r3, #45	; 0x2d
   1cbfc:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
   1cc00:	e3580047 	cmp	r8, #71	; 0x47
   1cc04:	ca000001 	bgt	1cc10 <_vfprintf_r+0x934>
					cp = "INF";
   1cc08:	e59f7fc8 	ldr	r7, [pc, #4040]	; 1dbd8 <_vfprintf_r+0x18fc>
   1cc0c:	ea000000 	b	1cc14 <_vfprintf_r+0x938>
				else
					cp = "inf";
   1cc10:	e59f7fc4 	ldr	r7, [pc, #4036]	; 1dbdc <_vfprintf_r+0x1900>
				size = 3;
   1cc14:	e3a03003 	mov	r3, #3
   1cc18:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
				flags &= ~ZEROPAD;
   1cc1c:	e3c66080 	bic	r6, r6, #128	; 0x80
				break;
   1cc20:	ea0002ec 	b	1d7d8 <_vfprintf_r+0x14fc>
			}
			if (isnan (_fpvalue)) {
   1cc24:	e24b3094 	sub	r3, fp, #148	; 0x94
   1cc28:	e893000c 	ldm	r3, {r2, r3}
   1cc2c:	e1a00002 	mov	r0, r2
   1cc30:	e1a01003 	mov	r1, r3
   1cc34:	eb0021d7 	bl	25398 <__fpclassifyd>
   1cc38:	e1a03000 	mov	r3, r0
   1cc3c:	e3530000 	cmp	r3, #0
   1cc40:	1a000008 	bne	1cc68 <_vfprintf_r+0x98c>
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
   1cc44:	e3580047 	cmp	r8, #71	; 0x47
   1cc48:	ca000001 	bgt	1cc54 <_vfprintf_r+0x978>
					cp = "NAN";
   1cc4c:	e59f7f8c 	ldr	r7, [pc, #3980]	; 1dbe0 <_vfprintf_r+0x1904>
   1cc50:	ea000000 	b	1cc58 <_vfprintf_r+0x97c>
				else
					cp = "nan";
   1cc54:	e59f7f88 	ldr	r7, [pc, #3976]	; 1dbe4 <_vfprintf_r+0x1908>
				size = 3;
   1cc58:	e3a03003 	mov	r3, #3
   1cc5c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
				flags &= ~ZEROPAD;
   1cc60:	e3c66080 	bic	r6, r6, #128	; 0x80
				break;
   1cc64:	ea0002db 	b	1d7d8 <_vfprintf_r+0x14fc>
				break;
			}
# endif /* !_NO_LONGDBL */

# ifdef _WANT_IO_C99_FORMATS
			if (ch == 'a' || ch == 'A') {
   1cc68:	e3580061 	cmp	r8, #97	; 0x61
   1cc6c:	0a000001 	beq	1cc78 <_vfprintf_r+0x99c>
   1cc70:	e3580041 	cmp	r8, #65	; 0x41
   1cc74:	1a000020 	bne	1ccfc <_vfprintf_r+0xa20>
				ox[0] = '0';
   1cc78:	e3a03030 	mov	r3, #48	; 0x30
   1cc7c:	e54b3158 	strb	r3, [fp, #-344]	; 0x158
				ox[1] = ch == 'a' ? 'x' : 'X';
   1cc80:	e3580061 	cmp	r8, #97	; 0x61
   1cc84:	1a000001 	bne	1cc90 <_vfprintf_r+0x9b4>
   1cc88:	e3a03078 	mov	r3, #120	; 0x78
   1cc8c:	ea000000 	b	1cc94 <_vfprintf_r+0x9b8>
   1cc90:	e3a03058 	mov	r3, #88	; 0x58
   1cc94:	e54b3157 	strb	r3, [fp, #-343]	; 0x157
				flags |= HEXPREFIX;
   1cc98:	e3866002 	orr	r6, r6, #2
				if (prec >= BUF)
   1cc9c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1cca0:	e3530063 	cmp	r3, #99	; 0x63
   1cca4:	da000012 	ble	1ccf4 <_vfprintf_r+0xa18>
				  {
				    if ((malloc_buf =
					 (char *)_malloc_r (data, prec + 1))
   1cca8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1ccac:	e2833001 	add	r3, r3, #1
				ox[0] = '0';
				ox[1] = ch == 'a' ? 'x' : 'X';
				flags |= HEXPREFIX;
				if (prec >= BUF)
				  {
				    if ((malloc_buf =
   1ccb0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ccb4:	e1a01003 	mov	r1, r3
   1ccb8:	ebffeb7d 	bl	17ab4 <_malloc_r>
   1ccbc:	e50b0064 	str	r0, [fp, #-100]	; 0x64
   1ccc0:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   1ccc4:	e3530000 	cmp	r3, #0
   1ccc8:	1a000007 	bne	1ccec <_vfprintf_r+0xa10>
					 (char *)_malloc_r (data, prec + 1))
					== NULL)
				      {
					fp->_flags |= __SERR;
   1cccc:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1ccd0:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1ccd4:	e1d220bc 	ldrh	r2, [r2, #12]
   1ccd8:	e3822040 	orr	r2, r2, #64	; 0x40
   1ccdc:	e1a02802 	lsl	r2, r2, #16
   1cce0:	e1a02822 	lsr	r2, r2, #16
   1cce4:	e1c320bc 	strh	r2, [r3, #12]
					goto error;
   1cce8:	ea0007e6 	b	1ec88 <_vfprintf_r+0x29ac>
				      }
				    cp = malloc_buf;
   1ccec:	e51b7064 	ldr	r7, [fp, #-100]	; 0x64
# ifdef _WANT_IO_C99_FORMATS
			if (ch == 'a' || ch == 'A') {
				ox[0] = '0';
				ox[1] = ch == 'a' ? 'x' : 'X';
				flags |= HEXPREFIX;
				if (prec >= BUF)
   1ccf0:	ea000010 	b	1cd38 <_vfprintf_r+0xa5c>
					goto error;
				      }
				    cp = malloc_buf;
				  }
				else
				  cp = buf;
   1ccf4:	e24b7f55 	sub	r7, fp, #340	; 0x154
# ifdef _WANT_IO_C99_FORMATS
			if (ch == 'a' || ch == 'A') {
				ox[0] = '0';
				ox[1] = ch == 'a' ? 'x' : 'X';
				flags |= HEXPREFIX;
				if (prec >= BUF)
   1ccf8:	ea00000e 	b	1cd38 <_vfprintf_r+0xa5c>
				  }
				else
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
   1ccfc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1cd00:	e3730001 	cmn	r3, #1
   1cd04:	1a000002 	bne	1cd14 <_vfprintf_r+0xa38>
				prec = DEFPREC;
   1cd08:	e3a03006 	mov	r3, #6
   1cd0c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
   1cd10:	ea000008 	b	1cd38 <_vfprintf_r+0xa5c>
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
   1cd14:	e3580067 	cmp	r8, #103	; 0x67
   1cd18:	0a000001 	beq	1cd24 <_vfprintf_r+0xa48>
   1cd1c:	e3580047 	cmp	r8, #71	; 0x47
   1cd20:	1a000004 	bne	1cd38 <_vfprintf_r+0xa5c>
   1cd24:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1cd28:	e3530000 	cmp	r3, #0
   1cd2c:	1a000001 	bne	1cd38 <_vfprintf_r+0xa5c>
				prec = 1;
   1cd30:	e3a03001 	mov	r3, #1
   1cd34:	e50b3028 	str	r3, [fp, #-40]	; 0x28
			}

			flags |= FPT;
   1cd38:	e3866c01 	orr	r6, r6, #256	; 0x100

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
   1cd3c:	e24b3094 	sub	r3, fp, #148	; 0x94
   1cd40:	e893000c 	ldm	r3, {r2, r3}
   1cd44:	e51b1028 	ldr	r1, [fp, #-40]	; 0x28
   1cd48:	e58d1000 	str	r1, [sp]
   1cd4c:	e58d6004 	str	r6, [sp, #4]
   1cd50:	e24b108a 	sub	r1, fp, #138	; 0x8a
   1cd54:	e58d1008 	str	r1, [sp, #8]
   1cd58:	e24b1098 	sub	r1, fp, #152	; 0x98
   1cd5c:	e58d100c 	str	r1, [sp, #12]
   1cd60:	e58d8010 	str	r8, [sp, #16]
   1cd64:	e24b10a4 	sub	r1, fp, #164	; 0xa4
   1cd68:	e58d1014 	str	r1, [sp, #20]
   1cd6c:	e58d7018 	str	r7, [sp, #24]
   1cd70:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1cd74:	eb0007e3 	bl	1ed08 <cvt>
   1cd78:	e1a07000 	mov	r7, r0
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
   1cd7c:	e3580067 	cmp	r8, #103	; 0x67
   1cd80:	0a000001 	beq	1cd8c <_vfprintf_r+0xab0>
   1cd84:	e3580047 	cmp	r8, #71	; 0x47
   1cd88:	1a00000a 	bne	1cdb8 <_vfprintf_r+0xadc>
				if (expt <= -4 || expt > prec)
   1cd8c:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1cd90:	e3730003 	cmn	r3, #3
   1cd94:	ba000003 	blt	1cda8 <_vfprintf_r+0xacc>
   1cd98:	e51b2098 	ldr	r2, [fp, #-152]	; 0x98
   1cd9c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1cda0:	e1520003 	cmp	r2, r3
   1cda4:	da000001 	ble	1cdb0 <_vfprintf_r+0xad4>
					ch -= 2; /* 'e' or 'E' */
   1cda8:	e2488002 	sub	r8, r8, #2

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
				if (expt <= -4 || expt > prec)
   1cdac:	ea000004 	b	1cdc4 <_vfprintf_r+0xae8>
					ch -= 2; /* 'e' or 'E' */
				else
					ch = 'g';
   1cdb0:	e3a08067 	mov	r8, #103	; 0x67

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
				if (expt <= -4 || expt > prec)
   1cdb4:	ea000002 	b	1cdc4 <_vfprintf_r+0xae8>
					ch -= 2; /* 'e' or 'E' */
				else
					ch = 'g';
			}
# ifdef _WANT_IO_C99_FORMATS
			else if (ch == 'F')
   1cdb8:	e3580046 	cmp	r8, #70	; 0x46
   1cdbc:	1a000000 	bne	1cdc4 <_vfprintf_r+0xae8>
				ch = 'f';
   1cdc0:	e3a08066 	mov	r8, #102	; 0x66
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
   1cdc4:	e3580065 	cmp	r8, #101	; 0x65
   1cdc8:	ca000018 	bgt	1ce30 <_vfprintf_r+0xb54>
				--expt;
   1cdcc:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1cdd0:	e2433001 	sub	r3, r3, #1
   1cdd4:	e50b3098 	str	r3, [fp, #-152]	; 0x98
				expsize = exponent (expstr, expt, ch);
   1cdd8:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1cddc:	e24b20a0 	sub	r2, fp, #160	; 0xa0
   1cde0:	e1a00002 	mov	r0, r2
   1cde4:	e1a01003 	mov	r1, r3
   1cde8:	e1a02008 	mov	r2, r8
   1cdec:	eb0008eb 	bl	1f1a0 <exponent>
   1cdf0:	e50b0038 	str	r0, [fp, #-56]	; 0x38
				size = expsize + ndig;
   1cdf4:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1cdf8:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   1cdfc:	e0823003 	add	r3, r2, r3
   1ce00:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
				if (ndig > 1 || flags & ALT)
   1ce04:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1ce08:	e3530001 	cmp	r3, #1
   1ce0c:	ca000002 	bgt	1ce1c <_vfprintf_r+0xb40>
   1ce10:	e2063001 	and	r3, r6, #1
   1ce14:	e3530000 	cmp	r3, #0
   1ce18:	0a000002 	beq	1ce28 <_vfprintf_r+0xb4c>
					++size;
   1ce1c:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1ce20:	e2833001 	add	r3, r3, #1
   1ce24:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
# ifdef _WANT_IO_C99_FORMATS
				flags &= ~GROUPING;
   1ce28:	e3c66b01 	bic	r6, r6, #1024	; 0x400
   1ce2c:	ea00006c 	b	1cfe4 <_vfprintf_r+0xd08>
# endif
			} else {
				if (ch == 'f') {		/* f fmt */
   1ce30:	e3580066 	cmp	r8, #102	; 0x66
   1ce34:	1a00001c 	bne	1ceac <_vfprintf_r+0xbd0>
					if (expt > 0) {
   1ce38:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1ce3c:	e3530000 	cmp	r3, #0
   1ce40:	da00000d 	ble	1ce7c <_vfprintf_r+0xba0>
						size = expt;
   1ce44:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1ce48:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
						if (prec || flags & ALT)
   1ce4c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1ce50:	e3530000 	cmp	r3, #0
   1ce54:	1a000002 	bne	1ce64 <_vfprintf_r+0xb88>
   1ce58:	e2063001 	and	r3, r6, #1
   1ce5c:	e3530000 	cmp	r3, #0
   1ce60:	0a000028 	beq	1cf08 <_vfprintf_r+0xc2c>
							size += prec + 1;
   1ce64:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1ce68:	e2833001 	add	r3, r3, #1
   1ce6c:	e51b205c 	ldr	r2, [fp, #-92]	; 0x5c
   1ce70:	e0823003 	add	r3, r2, r3
   1ce74:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   1ce78:	ea000022 	b	1cf08 <_vfprintf_r+0xc2c>
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
   1ce7c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1ce80:	e3530000 	cmp	r3, #0
   1ce84:	1a000002 	bne	1ce94 <_vfprintf_r+0xbb8>
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
   1ce88:	e2063001 	and	r3, r6, #1
   1ce8c:	e3530000 	cmp	r3, #0
   1ce90:	0a000002 	beq	1cea0 <_vfprintf_r+0xbc4>
							  ? prec + 2
							  : 1;
   1ce94:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1ce98:	e2833002 	add	r3, r3, #2
   1ce9c:	ea000000 	b	1cea4 <_vfprintf_r+0xbc8>
   1cea0:	e3a03001 	mov	r3, #1
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
   1cea4:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   1cea8:	ea000016 	b	1cf08 <_vfprintf_r+0xc2c>
							  ? prec + 2
							  : 1;
				} else if (expt >= ndig) { /* fixed g fmt */
   1ceac:	e51b2098 	ldr	r2, [fp, #-152]	; 0x98
   1ceb0:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1ceb4:	e1520003 	cmp	r2, r3
   1ceb8:	ba000008 	blt	1cee0 <_vfprintf_r+0xc04>
					size = expt;
   1cebc:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1cec0:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
					if (flags & ALT)
   1cec4:	e2063001 	and	r3, r6, #1
   1cec8:	e3530000 	cmp	r3, #0
   1cecc:	0a00000d 	beq	1cf08 <_vfprintf_r+0xc2c>
						++size;
   1ced0:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1ced4:	e2833001 	add	r3, r3, #1
   1ced8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   1cedc:	ea000009 	b	1cf08 <_vfprintf_r+0xc2c>
				} else
					size = ndig + (expt > 0 ?
   1cee0:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
						1 : 2 - expt);
   1cee4:	e3530000 	cmp	r3, #0
   1cee8:	ca000002 	bgt	1cef8 <_vfprintf_r+0xc1c>
   1ceec:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1cef0:	e2633002 	rsb	r3, r3, #2
   1cef4:	ea000000 	b	1cefc <_vfprintf_r+0xc20>
   1cef8:	e3a03001 	mov	r3, #1
				} else if (expt >= ndig) { /* fixed g fmt */
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
   1cefc:	e51b20a4 	ldr	r2, [fp, #-164]	; 0xa4
   1cf00:	e0833002 	add	r3, r3, r2
   1cf04:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
						1 : 2 - expt);
# ifdef _WANT_IO_C99_FORMATS
				if ((flags & GROUPING) && expt > 0) {
   1cf08:	e2063b01 	and	r3, r6, #1024	; 0x400
   1cf0c:	e3530000 	cmp	r3, #0
   1cf10:	0a000031 	beq	1cfdc <_vfprintf_r+0xd00>
   1cf14:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1cf18:	e3530000 	cmp	r3, #0
   1cf1c:	da00002e 	ble	1cfdc <_vfprintf_r+0xd00>
					/* space for thousands' grouping */
					nseps = nrepeats = 0;
   1cf20:	e3a03000 	mov	r3, #0
   1cf24:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   1cf28:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1cf2c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
					lead = expt;
   1cf30:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1cf34:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
					while (*grouping != CHAR_MAX) {
   1cf38:	ea00001a 	b	1cfa8 <_vfprintf_r+0xccc>
						if (lead <= *grouping)
   1cf3c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1cf40:	e5d33000 	ldrb	r3, [r3]
   1cf44:	e1a02003 	mov	r2, r3
   1cf48:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1cf4c:	e1520003 	cmp	r2, r3
   1cf50:	ba000000 	blt	1cf58 <_vfprintf_r+0xc7c>
							break;
   1cf54:	ea000017 	b	1cfb8 <_vfprintf_r+0xcdc>
						lead -= *grouping;
   1cf58:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1cf5c:	e5d33000 	ldrb	r3, [r3]
   1cf60:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   1cf64:	e0633002 	rsb	r3, r3, r2
   1cf68:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
						if (grouping[1]) {
   1cf6c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1cf70:	e2833001 	add	r3, r3, #1
   1cf74:	e5d33000 	ldrb	r3, [r3]
   1cf78:	e3530000 	cmp	r3, #0
   1cf7c:	0a000006 	beq	1cf9c <_vfprintf_r+0xcc0>
							nseps++;
   1cf80:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1cf84:	e2833001 	add	r3, r3, #1
   1cf88:	e50b3040 	str	r3, [fp, #-64]	; 0x40
							grouping++;
   1cf8c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1cf90:	e2833001 	add	r3, r3, #1
   1cf94:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   1cf98:	ea000002 	b	1cfa8 <_vfprintf_r+0xccc>
						} else
							nrepeats++;
   1cf9c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1cfa0:	e2833001 	add	r3, r3, #1
   1cfa4:	e50b3044 	str	r3, [fp, #-68]	; 0x44
# ifdef _WANT_IO_C99_FORMATS
				if ((flags & GROUPING) && expt > 0) {
					/* space for thousands' grouping */
					nseps = nrepeats = 0;
					lead = expt;
					while (*grouping != CHAR_MAX) {
   1cfa8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1cfac:	e5d33000 	ldrb	r3, [r3]
   1cfb0:	e35300ff 	cmp	r3, #255	; 0xff
   1cfb4:	1affffe0 	bne	1cf3c <_vfprintf_r+0xc60>
							nseps++;
							grouping++;
						} else
							nrepeats++;
					}
					size += (nseps + nrepeats) * thsnd_len;
   1cfb8:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   1cfbc:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1cfc0:	e0823003 	add	r3, r2, r3
   1cfc4:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   1cfc8:	e0020293 	mul	r2, r3, r2
   1cfcc:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1cfd0:	e0823003 	add	r3, r2, r3
   1cfd4:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   1cfd8:	ea000001 	b	1cfe4 <_vfprintf_r+0xd08>
				} else
# endif
					lead = expt;
   1cfdc:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1cfe0:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
			}

			if (softsign)
   1cfe4:	e55b308a 	ldrb	r3, [fp, #-138]	; 0x8a
   1cfe8:	e3530000 	cmp	r3, #0
   1cfec:	0a000002 	beq	1cffc <_vfprintf_r+0xd20>
				sign = '-';
   1cff0:	e3a0302d 	mov	r3, #45	; 0x2d
   1cff4:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
			break;
   1cff8:	ea0001f6 	b	1d7d8 <_vfprintf_r+0x14fc>
   1cffc:	ea0001f5 	b	1d7d8 <_vfprintf_r+0x14fc>
			flags &= ~LONGINT;
			goto string;
#endif
		case 'n':
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
   1d000:	e2063020 	and	r3, r6, #32
   1d004:	e3530000 	cmp	r3, #0
   1d008:	0a000008 	beq	1d030 <_vfprintf_r+0xd54>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
   1d00c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d010:	e2832004 	add	r2, r3, #4
   1d014:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d018:	e5931000 	ldr	r1, [r3]
   1d01c:	e51b3020 	ldr	r3, [fp, #-32]
   1d020:	e1a02003 	mov	r2, r3
   1d024:	e1a03fc2 	asr	r3, r2, #31
   1d028:	e881000c 	stm	r1, {r2, r3}
   1d02c:	ea000027 	b	1d0d0 <_vfprintf_r+0xdf4>
			else
#endif
			if (flags & LONGINT)
   1d030:	e2063010 	and	r3, r6, #16
   1d034:	e3530000 	cmp	r3, #0
   1d038:	0a000006 	beq	1d058 <_vfprintf_r+0xd7c>
				*GET_ARG (N, ap, long_ptr_t) = ret;
   1d03c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d040:	e2832004 	add	r2, r3, #4
   1d044:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d048:	e5933000 	ldr	r3, [r3]
   1d04c:	e51b2020 	ldr	r2, [fp, #-32]
   1d050:	e5832000 	str	r2, [r3]
   1d054:	ea00001d 	b	1d0d0 <_vfprintf_r+0xdf4>
			else if (flags & SHORTINT)
   1d058:	e2063040 	and	r3, r6, #64	; 0x40
   1d05c:	e3530000 	cmp	r3, #0
   1d060:	0a000008 	beq	1d088 <_vfprintf_r+0xdac>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   1d064:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d068:	e2832004 	add	r2, r3, #4
   1d06c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d070:	e5933000 	ldr	r3, [r3]
   1d074:	e51b2020 	ldr	r2, [fp, #-32]
   1d078:	e1a02802 	lsl	r2, r2, #16
   1d07c:	e1a02822 	lsr	r2, r2, #16
   1d080:	e1c320b0 	strh	r2, [r3]
   1d084:	ea000011 	b	1d0d0 <_vfprintf_r+0xdf4>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
   1d088:	e2063c02 	and	r3, r6, #512	; 0x200
   1d08c:	e3530000 	cmp	r3, #0
   1d090:	0a000007 	beq	1d0b4 <_vfprintf_r+0xdd8>
				*GET_ARG (N, ap, char_ptr_t) = ret;
   1d094:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d098:	e2832004 	add	r2, r3, #4
   1d09c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d0a0:	e5933000 	ldr	r3, [r3]
   1d0a4:	e51b2020 	ldr	r2, [fp, #-32]
   1d0a8:	e20220ff 	and	r2, r2, #255	; 0xff
   1d0ac:	e5c32000 	strb	r2, [r3]
   1d0b0:	ea000006 	b	1d0d0 <_vfprintf_r+0xdf4>
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
   1d0b4:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d0b8:	e2832004 	add	r2, r3, #4
   1d0bc:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d0c0:	e5933000 	ldr	r3, [r3]
   1d0c4:	e51b2020 	ldr	r2, [fp, #-32]
   1d0c8:	e5832000 	str	r2, [r3]
			continue;	/* no output */
   1d0cc:	ea0006dc 	b	1ec44 <_vfprintf_r+0x2968>
   1d0d0:	ea0006db 	b	1ec44 <_vfprintf_r+0x2968>
		case 'O': /* extension */
			flags |= LONGINT;
   1d0d4:	e3866010 	orr	r6, r6, #16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   1d0d8:	e2063020 	and	r3, r6, #32
   1d0dc:	e3530000 	cmp	r3, #0
   1d0e0:	0a000006 	beq	1d100 <_vfprintf_r+0xe24>
   1d0e4:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d0e8:	e2833007 	add	r3, r3, #7
   1d0ec:	e3c33007 	bic	r3, r3, #7
   1d0f0:	e2832008 	add	r2, r3, #8
   1d0f4:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d0f8:	e893000c 	ldm	r3, {r2, r3}
   1d0fc:	ea000027 	b	1d1a0 <_vfprintf_r+0xec4>
   1d100:	e2063010 	and	r3, r6, #16
   1d104:	e3530000 	cmp	r3, #0
   1d108:	0a000006 	beq	1d128 <_vfprintf_r+0xe4c>
   1d10c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d110:	e2832004 	add	r2, r3, #4
   1d114:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d118:	e5933000 	ldr	r3, [r3]
   1d11c:	e1a02003 	mov	r2, r3
   1d120:	e3a03000 	mov	r3, #0
   1d124:	ea00001d 	b	1d1a0 <_vfprintf_r+0xec4>
   1d128:	e2063040 	and	r3, r6, #64	; 0x40
   1d12c:	e3530000 	cmp	r3, #0
   1d130:	0a000009 	beq	1d15c <_vfprintf_r+0xe80>
   1d134:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d138:	e2832004 	add	r2, r3, #4
   1d13c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d140:	e5933000 	ldr	r3, [r3]
   1d144:	e1a03803 	lsl	r3, r3, #16
   1d148:	e1a01823 	lsr	r1, r3, #16
   1d14c:	e1a03001 	mov	r3, r1
   1d150:	e1a02003 	mov	r2, r3
   1d154:	e3a03000 	mov	r3, #0
   1d158:	ea000010 	b	1d1a0 <_vfprintf_r+0xec4>
   1d15c:	e2063c02 	and	r3, r6, #512	; 0x200
   1d160:	e3530000 	cmp	r3, #0
   1d164:	0a000007 	beq	1d188 <_vfprintf_r+0xeac>
   1d168:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d16c:	e2832004 	add	r2, r3, #4
   1d170:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d174:	e5933000 	ldr	r3, [r3]
   1d178:	e20330ff 	and	r3, r3, #255	; 0xff
   1d17c:	e20320ff 	and	r2, r3, #255	; 0xff
   1d180:	e3a03000 	mov	r3, #0
   1d184:	ea000005 	b	1d1a0 <_vfprintf_r+0xec4>
   1d188:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d18c:	e2832004 	add	r2, r3, #4
   1d190:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d194:	e5933000 	ldr	r3, [r3]
   1d198:	e1a02003 	mov	r2, r3
   1d19c:	e3a03000 	mov	r3, #0
   1d1a0:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1d1a4:	e50b3048 	str	r3, [fp, #-72]	; 0x48
			base = OCT;
   1d1a8:	e3a03000 	mov	r3, #0
   1d1ac:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
   1d1b0:	e3c66b01 	bic	r6, r6, #1024	; 0x400
#endif
			goto nosign;
   1d1b4:	ea0000c2 	b	1d4c4 <_vfprintf_r+0x11e8>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   1d1b8:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d1bc:	e2832004 	add	r2, r3, #4
   1d1c0:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d1c4:	e5933000 	ldr	r3, [r3]
   1d1c8:	e1a02003 	mov	r2, r3
   1d1cc:	e3a03000 	mov	r3, #0
   1d1d0:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1d1d4:	e50b3048 	str	r3, [fp, #-72]	; 0x48
			base = HEX;
   1d1d8:	e3a03002 	mov	r3, #2
   1d1dc:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
			xdigs = "0123456789abcdef";
   1d1e0:	e59f3a00 	ldr	r3, [pc, #2560]	; 1dbe8 <_vfprintf_r+0x190c>
   1d1e4:	e50b3060 	str	r3, [fp, #-96]	; 0x60
			flags |= HEXPREFIX;
   1d1e8:	e3866002 	orr	r6, r6, #2
			ox[0] = '0';
   1d1ec:	e3a03030 	mov	r3, #48	; 0x30
   1d1f0:	e54b3158 	strb	r3, [fp, #-344]	; 0x158
			ox[1] = ch = 'x';
   1d1f4:	e3a08078 	mov	r8, #120	; 0x78
   1d1f8:	e3a03078 	mov	r3, #120	; 0x78
   1d1fc:	e54b3157 	strb	r3, [fp, #-343]	; 0x157
			goto nosign;
   1d200:	ea0000af 	b	1d4c4 <_vfprintf_r+0x11e8>
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   1d204:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d208:	e2832004 	add	r2, r3, #4
   1d20c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d210:	e5937000 	ldr	r7, [r3]
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
   1d214:	e3a03000 	mov	r3, #0
   1d218:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
   1d21c:	e3570000 	cmp	r7, #0
   1d220:	1a000006 	bne	1d240 <_vfprintf_r+0xf64>
				cp = "(null)";
   1d224:	e59f79c0 	ldr	r7, [pc, #2496]	; 1dbec <_vfprintf_r+0x1910>
				size = ((unsigned) prec > 6U) ? 6 : prec;
   1d228:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1d22c:	e3530006 	cmp	r3, #6
   1d230:	31a03003 	movcc	r3, r3
   1d234:	23a03006 	movcs	r3, #6
   1d238:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   1d23c:	ea00001f 	b	1d2c0 <_vfprintf_r+0xfe4>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
   1d240:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1d244:	e3530000 	cmp	r3, #0
   1d248:	ba000017 	blt	1d2ac <_vfprintf_r+0xfd0>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
   1d24c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1d250:	e1a00007 	mov	r0, r7
   1d254:	e3a01000 	mov	r1, #0
   1d258:	e1a02003 	mov	r2, r3
   1d25c:	eb0014ea 	bl	2260c <memchr>
   1d260:	e50b0084 	str	r0, [fp, #-132]	; 0x84

				if (p != NULL) {
   1d264:	e51b3084 	ldr	r3, [fp, #-132]	; 0x84
   1d268:	e3530000 	cmp	r3, #0
   1d26c:	0a00000a 	beq	1d29c <_vfprintf_r+0xfc0>
					size = p - cp;
   1d270:	e51b2084 	ldr	r2, [fp, #-132]	; 0x84
   1d274:	e1a03007 	mov	r3, r7
   1d278:	e0633002 	rsb	r3, r3, r2
   1d27c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
					if (size > prec)
   1d280:	e51b205c 	ldr	r2, [fp, #-92]	; 0x5c
   1d284:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1d288:	e1520003 	cmp	r2, r3
   1d28c:	da000005 	ble	1d2a8 <_vfprintf_r+0xfcc>
						size = prec;
   1d290:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1d294:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   1d298:	ea000008 	b	1d2c0 <_vfprintf_r+0xfe4>
				} else
					size = prec;
   1d29c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1d2a0:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   1d2a4:	ea000005 	b	1d2c0 <_vfprintf_r+0xfe4>
   1d2a8:	ea000004 	b	1d2c0 <_vfprintf_r+0xfe4>
			} else
				size = strlen (cp);
   1d2ac:	e1a00007 	mov	r0, r7
   1d2b0:	ebffeffe 	bl	192b0 <strlen>
   1d2b4:	e1a03000 	mov	r3, r0
   1d2b8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c

			break;
   1d2bc:	ea000145 	b	1d7d8 <_vfprintf_r+0x14fc>
   1d2c0:	ea000144 	b	1d7d8 <_vfprintf_r+0x14fc>
		case 'U': /* extension */
			flags |= LONGINT;
   1d2c4:	e3866010 	orr	r6, r6, #16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   1d2c8:	e2063020 	and	r3, r6, #32
   1d2cc:	e3530000 	cmp	r3, #0
   1d2d0:	0a000006 	beq	1d2f0 <_vfprintf_r+0x1014>
   1d2d4:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d2d8:	e2833007 	add	r3, r3, #7
   1d2dc:	e3c33007 	bic	r3, r3, #7
   1d2e0:	e2832008 	add	r2, r3, #8
   1d2e4:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d2e8:	e893000c 	ldm	r3, {r2, r3}
   1d2ec:	ea000027 	b	1d390 <_vfprintf_r+0x10b4>
   1d2f0:	e2063010 	and	r3, r6, #16
   1d2f4:	e3530000 	cmp	r3, #0
   1d2f8:	0a000006 	beq	1d318 <_vfprintf_r+0x103c>
   1d2fc:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d300:	e2832004 	add	r2, r3, #4
   1d304:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d308:	e5933000 	ldr	r3, [r3]
   1d30c:	e1a02003 	mov	r2, r3
   1d310:	e3a03000 	mov	r3, #0
   1d314:	ea00001d 	b	1d390 <_vfprintf_r+0x10b4>
   1d318:	e2063040 	and	r3, r6, #64	; 0x40
   1d31c:	e3530000 	cmp	r3, #0
   1d320:	0a000009 	beq	1d34c <_vfprintf_r+0x1070>
   1d324:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d328:	e2832004 	add	r2, r3, #4
   1d32c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d330:	e5933000 	ldr	r3, [r3]
   1d334:	e1a03803 	lsl	r3, r3, #16
   1d338:	e1a01823 	lsr	r1, r3, #16
   1d33c:	e1a03001 	mov	r3, r1
   1d340:	e1a02003 	mov	r2, r3
   1d344:	e3a03000 	mov	r3, #0
   1d348:	ea000010 	b	1d390 <_vfprintf_r+0x10b4>
   1d34c:	e2063c02 	and	r3, r6, #512	; 0x200
   1d350:	e3530000 	cmp	r3, #0
   1d354:	0a000007 	beq	1d378 <_vfprintf_r+0x109c>
   1d358:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d35c:	e2832004 	add	r2, r3, #4
   1d360:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d364:	e5933000 	ldr	r3, [r3]
   1d368:	e20330ff 	and	r3, r3, #255	; 0xff
   1d36c:	e20320ff 	and	r2, r3, #255	; 0xff
   1d370:	e3a03000 	mov	r3, #0
   1d374:	ea000005 	b	1d390 <_vfprintf_r+0x10b4>
   1d378:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d37c:	e2832004 	add	r2, r3, #4
   1d380:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d384:	e5933000 	ldr	r3, [r3]
   1d388:	e1a02003 	mov	r2, r3
   1d38c:	e3a03000 	mov	r3, #0
   1d390:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1d394:	e50b3048 	str	r3, [fp, #-72]	; 0x48
			base = DEC;
   1d398:	e3a03001 	mov	r3, #1
   1d39c:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
			goto nosign;
   1d3a0:	ea000047 	b	1d4c4 <_vfprintf_r+0x11e8>
		case 'X':
			xdigs = "0123456789ABCDEF";
   1d3a4:	e59f3844 	ldr	r3, [pc, #2116]	; 1dbf0 <_vfprintf_r+0x1914>
   1d3a8:	e50b3060 	str	r3, [fp, #-96]	; 0x60
			goto hex;
   1d3ac:	ea000001 	b	1d3b8 <_vfprintf_r+0x10dc>
		case 'x':
			xdigs = "0123456789abcdef";
   1d3b0:	e59f3830 	ldr	r3, [pc, #2096]	; 1dbe8 <_vfprintf_r+0x190c>
   1d3b4:	e50b3060 	str	r3, [fp, #-96]	; 0x60
hex:			_uquad = UARG ();
   1d3b8:	e2063020 	and	r3, r6, #32
   1d3bc:	e3530000 	cmp	r3, #0
   1d3c0:	0a000006 	beq	1d3e0 <_vfprintf_r+0x1104>
   1d3c4:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d3c8:	e2833007 	add	r3, r3, #7
   1d3cc:	e3c33007 	bic	r3, r3, #7
   1d3d0:	e2832008 	add	r2, r3, #8
   1d3d4:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d3d8:	e893000c 	ldm	r3, {r2, r3}
   1d3dc:	ea000027 	b	1d480 <_vfprintf_r+0x11a4>
   1d3e0:	e2063010 	and	r3, r6, #16
   1d3e4:	e3530000 	cmp	r3, #0
   1d3e8:	0a000006 	beq	1d408 <_vfprintf_r+0x112c>
   1d3ec:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d3f0:	e2832004 	add	r2, r3, #4
   1d3f4:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d3f8:	e5933000 	ldr	r3, [r3]
   1d3fc:	e1a02003 	mov	r2, r3
   1d400:	e3a03000 	mov	r3, #0
   1d404:	ea00001d 	b	1d480 <_vfprintf_r+0x11a4>
   1d408:	e2063040 	and	r3, r6, #64	; 0x40
   1d40c:	e3530000 	cmp	r3, #0
   1d410:	0a000009 	beq	1d43c <_vfprintf_r+0x1160>
   1d414:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d418:	e2832004 	add	r2, r3, #4
   1d41c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d420:	e5933000 	ldr	r3, [r3]
   1d424:	e1a03803 	lsl	r3, r3, #16
   1d428:	e1a01823 	lsr	r1, r3, #16
   1d42c:	e1a03001 	mov	r3, r1
   1d430:	e1a02003 	mov	r2, r3
   1d434:	e3a03000 	mov	r3, #0
   1d438:	ea000010 	b	1d480 <_vfprintf_r+0x11a4>
   1d43c:	e2063c02 	and	r3, r6, #512	; 0x200
   1d440:	e3530000 	cmp	r3, #0
   1d444:	0a000007 	beq	1d468 <_vfprintf_r+0x118c>
   1d448:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d44c:	e2832004 	add	r2, r3, #4
   1d450:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d454:	e5933000 	ldr	r3, [r3]
   1d458:	e20330ff 	and	r3, r3, #255	; 0xff
   1d45c:	e20320ff 	and	r2, r3, #255	; 0xff
   1d460:	e3a03000 	mov	r3, #0
   1d464:	ea000005 	b	1d480 <_vfprintf_r+0x11a4>
   1d468:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1d46c:	e2832004 	add	r2, r3, #4
   1d470:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1d474:	e5933000 	ldr	r3, [r3]
   1d478:	e1a02003 	mov	r2, r3
   1d47c:	e3a03000 	mov	r3, #0
   1d480:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1d484:	e50b3048 	str	r3, [fp, #-72]	; 0x48
			base = HEX;
   1d488:	e3a03002 	mov	r3, #2
   1d48c:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
   1d490:	e2063001 	and	r3, r6, #1
   1d494:	e3530000 	cmp	r3, #0
   1d498:	0a000008 	beq	1d4c0 <_vfprintf_r+0x11e4>
   1d49c:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1d4a0:	e893000c 	ldm	r3, {r2, r3}
   1d4a4:	e1921003 	orrs	r1, r2, r3
   1d4a8:	0a000004 	beq	1d4c0 <_vfprintf_r+0x11e4>
				ox[0] = '0';
   1d4ac:	e3a03030 	mov	r3, #48	; 0x30
   1d4b0:	e54b3158 	strb	r3, [fp, #-344]	; 0x158
				ox[1] = ch;
   1d4b4:	e20830ff 	and	r3, r8, #255	; 0xff
   1d4b8:	e54b3157 	strb	r3, [fp, #-343]	; 0x157
				flags |= HEXPREFIX;
   1d4bc:	e3866002 	orr	r6, r6, #2
			}

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
   1d4c0:	e3c66b01 	bic	r6, r6, #1024	; 0x400
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   1d4c4:	e3a03000 	mov	r3, #0
   1d4c8:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1d4cc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1d4d0:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   1d4d4:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   1d4d8:	e3530000 	cmp	r3, #0
   1d4dc:	ba000000 	blt	1d4e4 <_vfprintf_r+0x1208>
				flags &= ~ZEROPAD;
   1d4e0:	e3c66080 	bic	r6, r6, #128	; 0x80
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   1d4e4:	e24b7f55 	sub	r7, fp, #340	; 0x154
   1d4e8:	e2877064 	add	r7, r7, #100	; 0x64
			if (_uquad != 0 || prec != 0) {
   1d4ec:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1d4f0:	e893000c 	ldm	r3, {r2, r3}
   1d4f4:	e1921003 	orrs	r1, r2, r3
   1d4f8:	1a000002 	bne	1d508 <_vfprintf_r+0x122c>
   1d4fc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1d500:	e3530000 	cmp	r3, #0
   1d504:	0a000099 	beq	1d770 <_vfprintf_r+0x1494>
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   1d508:	e55b304d 	ldrb	r3, [fp, #-77]	; 0x4d
   1d50c:	e3530001 	cmp	r3, #1
   1d510:	0a000026 	beq	1d5b0 <_vfprintf_r+0x12d4>
   1d514:	e3530002 	cmp	r3, #2
   1d518:	0a000073 	beq	1d6ec <_vfprintf_r+0x1410>
   1d51c:	e3530000 	cmp	r3, #0
   1d520:	1a00008a 	bne	1d750 <_vfprintf_r+0x1474>
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   1d524:	e2477001 	sub	r7, r7, #1
   1d528:	e55b304c 	ldrb	r3, [fp, #-76]	; 0x4c
   1d52c:	e2033007 	and	r3, r3, #7
   1d530:	e20330ff 	and	r3, r3, #255	; 0xff
   1d534:	e2833030 	add	r3, r3, #48	; 0x30
   1d538:	e20330ff 	and	r3, r3, #255	; 0xff
   1d53c:	e5c73000 	strb	r3, [r7]
						_uquad >>= 3;
   1d540:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1d544:	e893000c 	ldm	r3, {r2, r3}
   1d548:	e1a011a2 	lsr	r1, r2, #3
   1d54c:	e50b1174 	str	r1, [fp, #-372]	; 0x174
   1d550:	e51b1174 	ldr	r1, [fp, #-372]	; 0x174
   1d554:	e1811e83 	orr	r1, r1, r3, lsl #29
   1d558:	e50b1174 	str	r1, [fp, #-372]	; 0x174
   1d55c:	e1a011a3 	lsr	r1, r3, #3
   1d560:	e50b1170 	str	r1, [fp, #-368]	; 0x170
   1d564:	e24b3f5d 	sub	r3, fp, #372	; 0x174
   1d568:	e893000c 	ldm	r3, {r2, r3}
   1d56c:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1d570:	e50b3048 	str	r3, [fp, #-72]	; 0x48
					} while (_uquad);
   1d574:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1d578:	e893000c 	ldm	r3, {r2, r3}
   1d57c:	e1921003 	orrs	r1, r2, r3
   1d580:	1affffe7 	bne	1d524 <_vfprintf_r+0x1248>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
   1d584:	e2063001 	and	r3, r6, #1
   1d588:	e3530000 	cmp	r3, #0
   1d58c:	0a000006 	beq	1d5ac <_vfprintf_r+0x12d0>
   1d590:	e5d73000 	ldrb	r3, [r7]
   1d594:	e3530030 	cmp	r3, #48	; 0x30
   1d598:	0a000003 	beq	1d5ac <_vfprintf_r+0x12d0>
						*--cp = '0';
   1d59c:	e2477001 	sub	r7, r7, #1
   1d5a0:	e3a03030 	mov	r3, #48	; 0x30
   1d5a4:	e5c73000 	strb	r3, [r7]
					break;
   1d5a8:	ea00006f 	b	1d76c <_vfprintf_r+0x1490>
   1d5ac:	ea00006e 	b	1d76c <_vfprintf_r+0x1490>

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   1d5b0:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1d5b4:	e893000c 	ldm	r3, {r2, r3}
   1d5b8:	e3530000 	cmp	r3, #0
   1d5bc:	03520009 	cmpeq	r2, #9
   1d5c0:	8a000005 	bhi	1d5dc <_vfprintf_r+0x1300>
						*--cp = to_char(_uquad);
   1d5c4:	e2477001 	sub	r7, r7, #1
   1d5c8:	e55b304c 	ldrb	r3, [fp, #-76]	; 0x4c
   1d5cc:	e2833030 	add	r3, r3, #48	; 0x30
   1d5d0:	e20330ff 	and	r3, r3, #255	; 0xff
   1d5d4:	e5c73000 	strb	r3, [r7]
						break;
   1d5d8:	ea000063 	b	1d76c <_vfprintf_r+0x1490>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
   1d5dc:	e3a03000 	mov	r3, #0
   1d5e0:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   1d5e4:	e2477001 	sub	r7, r7, #1
   1d5e8:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1d5ec:	e893000c 	ldm	r3, {r2, r3}
   1d5f0:	e1a00002 	mov	r0, r2
   1d5f4:	e1a01003 	mov	r1, r3
   1d5f8:	e3a0200a 	mov	r2, #10
   1d5fc:	e3a03000 	mov	r3, #0
   1d600:	ebffdede 	bl	15180 <__aeabi_uldivmod>
   1d604:	e20230ff 	and	r3, r2, #255	; 0xff
   1d608:	e2833030 	add	r3, r3, #48	; 0x30
   1d60c:	e20330ff 	and	r3, r3, #255	; 0xff
   1d610:	e5c73000 	strb	r3, [r7]
#ifdef _WANT_IO_C99_FORMATS
					  ndig++;
   1d614:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1d618:	e2833001 	add	r3, r3, #1
   1d61c:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
					  /* If (*grouping == CHAR_MAX) then no
					     more grouping */
					  if ((flags & GROUPING)
   1d620:	e2063b01 	and	r3, r6, #1024	; 0x400
   1d624:	e3530000 	cmp	r3, #0
   1d628:	0a00001f 	beq	1d6ac <_vfprintf_r+0x13d0>
					      && ndig == *grouping
   1d62c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1d630:	e5d33000 	ldrb	r3, [r3]
   1d634:	e1a02003 	mov	r2, r3
   1d638:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1d63c:	e1520003 	cmp	r2, r3
   1d640:	1a000019 	bne	1d6ac <_vfprintf_r+0x13d0>
					      && *grouping != CHAR_MAX
   1d644:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1d648:	e5d33000 	ldrb	r3, [r3]
   1d64c:	e35300ff 	cmp	r3, #255	; 0xff
   1d650:	0a000015 	beq	1d6ac <_vfprintf_r+0x13d0>
					      && _uquad > 9) {
   1d654:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1d658:	e893000c 	ldm	r3, {r2, r3}
   1d65c:	e3530000 	cmp	r3, #0
   1d660:	03520009 	cmpeq	r2, #9
   1d664:	9a000010 	bls	1d6ac <_vfprintf_r+0x13d0>
					    cp -= thsnd_len;
   1d668:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1d66c:	e2633000 	rsb	r3, r3, #0
   1d670:	e0877003 	add	r7, r7, r3
					    strncpy (cp, thousands_sep,
   1d674:	e1a00007 	mov	r0, r7
   1d678:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
   1d67c:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   1d680:	eb00207a 	bl	25870 <strncpy>
						     thsnd_len);
					    ndig = 0;
   1d684:	e3a03000 	mov	r3, #0
   1d688:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
					    /* If (grouping[1] == '\0') then we
					       have to use *grouping character
					       (last grouping rule) for all
					       next cases. */
					    if (grouping[1] != '\0')
   1d68c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1d690:	e2833001 	add	r3, r3, #1
   1d694:	e5d33000 	ldrb	r3, [r3]
   1d698:	e3530000 	cmp	r3, #0
   1d69c:	0a000002 	beq	1d6ac <_vfprintf_r+0x13d0>
					      grouping++;
   1d6a0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1d6a4:	e2833001 	add	r3, r3, #1
   1d6a8:	e50b3034 	str	r3, [fp, #-52]	; 0x34
					  }
#endif
					  _uquad /= 10;
   1d6ac:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1d6b0:	e893000c 	ldm	r3, {r2, r3}
   1d6b4:	e1a00002 	mov	r0, r2
   1d6b8:	e1a01003 	mov	r1, r3
   1d6bc:	e3a0200a 	mov	r2, #10
   1d6c0:	e3a03000 	mov	r3, #0
   1d6c4:	ebffdead 	bl	15180 <__aeabi_uldivmod>
   1d6c8:	e1a02000 	mov	r2, r0
   1d6cc:	e1a03001 	mov	r3, r1
   1d6d0:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1d6d4:	e50b3048 	str	r3, [fp, #-72]	; 0x48
					} while (_uquad != 0);
   1d6d8:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1d6dc:	e893000c 	ldm	r3, {r2, r3}
   1d6e0:	e1921003 	orrs	r1, r2, r3
   1d6e4:	1affffbe 	bne	1d5e4 <_vfprintf_r+0x1308>
					break;
   1d6e8:	ea00001f 	b	1d76c <_vfprintf_r+0x1490>

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   1d6ec:	e2477001 	sub	r7, r7, #1
   1d6f0:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1d6f4:	e203300f 	and	r3, r3, #15
   1d6f8:	e51b2060 	ldr	r2, [fp, #-96]	; 0x60
   1d6fc:	e0823003 	add	r3, r2, r3
   1d700:	e5d33000 	ldrb	r3, [r3]
   1d704:	e5c73000 	strb	r3, [r7]
						_uquad >>= 4;
   1d708:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1d70c:	e893000c 	ldm	r3, {r2, r3}
   1d710:	e1a01222 	lsr	r1, r2, #4
   1d714:	e50b117c 	str	r1, [fp, #-380]	; 0x17c
   1d718:	e51b117c 	ldr	r1, [fp, #-380]	; 0x17c
   1d71c:	e1811e03 	orr	r1, r1, r3, lsl #28
   1d720:	e50b117c 	str	r1, [fp, #-380]	; 0x17c
   1d724:	e1a01223 	lsr	r1, r3, #4
   1d728:	e50b1178 	str	r1, [fp, #-376]	; 0x178
   1d72c:	e24b3f5f 	sub	r3, fp, #380	; 0x17c
   1d730:	e893000c 	ldm	r3, {r2, r3}
   1d734:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1d738:	e50b3048 	str	r3, [fp, #-72]	; 0x48
					} while (_uquad);
   1d73c:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1d740:	e893000c 	ldm	r3, {r2, r3}
   1d744:	e1921003 	orrs	r1, r2, r3
   1d748:	1affffe7 	bne	1d6ec <_vfprintf_r+0x1410>
					break;
   1d74c:	ea000006 	b	1d76c <_vfprintf_r+0x1490>

				default:
					cp = "bug in vfprintf: bad base";
   1d750:	e59f749c 	ldr	r7, [pc, #1180]	; 1dbf4 <_vfprintf_r+0x1918>
					size = strlen (cp);
   1d754:	e1a00007 	mov	r0, r7
   1d758:	ebffeed4 	bl	192b0 <strlen>
   1d75c:	e1a03000 	mov	r3, r0
   1d760:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
					goto skipsize;
   1d764:	e1a00000 	nop			; (mov r0, r0)
                       else if (base == OCT && (flags & ALT))
                         *--cp = '0';

			size = buf + BUF - cp;
		skipsize:
			break;
   1d768:	ea00001a 	b	1d7d8 <_vfprintf_r+0x14fc>
				default:
					cp = "bug in vfprintf: bad base";
					size = strlen (cp);
					goto skipsize;
				}
			}
   1d76c:	ea000008 	b	1d794 <_vfprintf_r+0x14b8>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   1d770:	e55b304d 	ldrb	r3, [fp, #-77]	; 0x4d
   1d774:	e3530000 	cmp	r3, #0
   1d778:	1a000005 	bne	1d794 <_vfprintf_r+0x14b8>
   1d77c:	e2063001 	and	r3, r6, #1
   1d780:	e3530000 	cmp	r3, #0
   1d784:	0a000002 	beq	1d794 <_vfprintf_r+0x14b8>
                         *--cp = '0';
   1d788:	e2477001 	sub	r7, r7, #1
   1d78c:	e3a03030 	mov	r3, #48	; 0x30
   1d790:	e5c73000 	strb	r3, [r7]

			size = buf + BUF - cp;
   1d794:	e24b3f55 	sub	r3, fp, #340	; 0x154
   1d798:	e2833064 	add	r3, r3, #100	; 0x64
   1d79c:	e1a02007 	mov	r2, r7
   1d7a0:	e0623003 	rsb	r3, r2, r3
   1d7a4:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
		skipsize:
			break;
   1d7a8:	ea00000a 	b	1d7d8 <_vfprintf_r+0x14fc>
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
   1d7ac:	e3580000 	cmp	r8, #0
   1d7b0:	1a000000 	bne	1d7b8 <_vfprintf_r+0x14dc>
				goto done;
   1d7b4:	ea000523 	b	1ec48 <_vfprintf_r+0x296c>
			/* pretend it was %c with argument ch */
			cp = buf;
   1d7b8:	e24b7f55 	sub	r7, fp, #340	; 0x154
			*cp = ch;
   1d7bc:	e20830ff 	and	r3, r8, #255	; 0xff
   1d7c0:	e5c73000 	strb	r3, [r7]
			size = 1;
   1d7c4:	e3a03001 	mov	r3, #1
   1d7c8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
			sign = '\0';
   1d7cc:	e3a03000 	mov	r3, #0
   1d7d0:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
			break;
   1d7d4:	e1a00000 	nop			; (mov r0, r0)
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
   1d7d8:	e51b205c 	ldr	r2, [fp, #-92]	; 0x5c
   1d7dc:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   1d7e0:	e1520003 	cmp	r2, r3
   1d7e4:	a1a03002 	movge	r3, r2
   1d7e8:	b1a03003 	movlt	r3, r3
   1d7ec:	e50b3058 	str	r3, [fp, #-88]	; 0x58
		if (sign)
   1d7f0:	e55b3089 	ldrb	r3, [fp, #-137]	; 0x89
   1d7f4:	e3530000 	cmp	r3, #0
   1d7f8:	0a000002 	beq	1d808 <_vfprintf_r+0x152c>
			realsz++;
   1d7fc:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   1d800:	e2833001 	add	r3, r3, #1
   1d804:	e50b3058 	str	r3, [fp, #-88]	; 0x58
		if (flags & HEXPREFIX)
   1d808:	e2063002 	and	r3, r6, #2
   1d80c:	e3530000 	cmp	r3, #0
   1d810:	0a000002 	beq	1d820 <_vfprintf_r+0x1544>
			realsz+= 2;
   1d814:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   1d818:	e2833002 	add	r3, r3, #2
   1d81c:	e50b3058 	str	r3, [fp, #-88]	; 0x58

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   1d820:	e2063084 	and	r3, r6, #132	; 0x84
   1d824:	e3530000 	cmp	r3, #0
   1d828:	1a00003a 	bne	1d918 <_vfprintf_r+0x163c>
			PAD (width - realsz, blanks);
   1d82c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1d830:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   1d834:	e0635002 	rsb	r5, r3, r2
   1d838:	e3550000 	cmp	r5, #0
   1d83c:	da000035 	ble	1d918 <_vfprintf_r+0x163c>
   1d840:	ea000019 	b	1d8ac <_vfprintf_r+0x15d0>
   1d844:	e59f33b4 	ldr	r3, [pc, #948]	; 1dc00 <_vfprintf_r+0x1924>
   1d848:	e5843000 	str	r3, [r4]
   1d84c:	e3a03010 	mov	r3, #16
   1d850:	e5843004 	str	r3, [r4, #4]
   1d854:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1d858:	e2833010 	add	r3, r3, #16
   1d85c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1d860:	e2844008 	add	r4, r4, #8
   1d864:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1d868:	e2833001 	add	r3, r3, #1
   1d86c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1d870:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1d874:	e3530007 	cmp	r3, #7
   1d878:	da00000a 	ble	1d8a8 <_vfprintf_r+0x15cc>
   1d87c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1d880:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1d884:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1d888:	e1a01002 	mov	r1, r2
   1d88c:	e1a02003 	mov	r2, r3
   1d890:	eb002646 	bl	271b0 <__sprint_r>
   1d894:	e1a03000 	mov	r3, r0
   1d898:	e3530000 	cmp	r3, #0
   1d89c:	0a000000 	beq	1d8a4 <_vfprintf_r+0x15c8>
   1d8a0:	ea0004f8 	b	1ec88 <_vfprintf_r+0x29ac>
   1d8a4:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1d8a8:	e2455010 	sub	r5, r5, #16
   1d8ac:	e3550010 	cmp	r5, #16
   1d8b0:	caffffe3 	bgt	1d844 <_vfprintf_r+0x1568>
   1d8b4:	e59f3344 	ldr	r3, [pc, #836]	; 1dc00 <_vfprintf_r+0x1924>
   1d8b8:	e5843000 	str	r3, [r4]
   1d8bc:	e1a03005 	mov	r3, r5
   1d8c0:	e5843004 	str	r3, [r4, #4]
   1d8c4:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1d8c8:	e0833005 	add	r3, r3, r5
   1d8cc:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1d8d0:	e2844008 	add	r4, r4, #8
   1d8d4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1d8d8:	e2833001 	add	r3, r3, #1
   1d8dc:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1d8e0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1d8e4:	e3530007 	cmp	r3, #7
   1d8e8:	da00000a 	ble	1d918 <_vfprintf_r+0x163c>
   1d8ec:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1d8f0:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1d8f4:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1d8f8:	e1a01002 	mov	r1, r2
   1d8fc:	e1a02003 	mov	r2, r3
   1d900:	eb00262a 	bl	271b0 <__sprint_r>
   1d904:	e1a03000 	mov	r3, r0
   1d908:	e3530000 	cmp	r3, #0
   1d90c:	0a000000 	beq	1d914 <_vfprintf_r+0x1638>
   1d910:	ea0004dc 	b	1ec88 <_vfprintf_r+0x29ac>
   1d914:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* prefix */
		if (sign)
   1d918:	e55b3089 	ldrb	r3, [fp, #-137]	; 0x89
   1d91c:	e3530000 	cmp	r3, #0
   1d920:	0a000018 	beq	1d988 <_vfprintf_r+0x16ac>
			PRINT (&sign, 1);
   1d924:	e24b3089 	sub	r3, fp, #137	; 0x89
   1d928:	e5843000 	str	r3, [r4]
   1d92c:	e3a03001 	mov	r3, #1
   1d930:	e5843004 	str	r3, [r4, #4]
   1d934:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1d938:	e2833001 	add	r3, r3, #1
   1d93c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1d940:	e2844008 	add	r4, r4, #8
   1d944:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1d948:	e2833001 	add	r3, r3, #1
   1d94c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1d950:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1d954:	e3530007 	cmp	r3, #7
   1d958:	da00000a 	ble	1d988 <_vfprintf_r+0x16ac>
   1d95c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1d960:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1d964:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1d968:	e1a01002 	mov	r1, r2
   1d96c:	e1a02003 	mov	r2, r3
   1d970:	eb00260e 	bl	271b0 <__sprint_r>
   1d974:	e1a03000 	mov	r3, r0
   1d978:	e3530000 	cmp	r3, #0
   1d97c:	0a000000 	beq	1d984 <_vfprintf_r+0x16a8>
   1d980:	ea0004c0 	b	1ec88 <_vfprintf_r+0x29ac>
   1d984:	e24b40f0 	sub	r4, fp, #240	; 0xf0
		if (flags & HEXPREFIX)
   1d988:	e2063002 	and	r3, r6, #2
   1d98c:	e3530000 	cmp	r3, #0
   1d990:	0a000018 	beq	1d9f8 <_vfprintf_r+0x171c>
			PRINT (ox, 2);
   1d994:	e24b3f56 	sub	r3, fp, #344	; 0x158
   1d998:	e5843000 	str	r3, [r4]
   1d99c:	e3a03002 	mov	r3, #2
   1d9a0:	e5843004 	str	r3, [r4, #4]
   1d9a4:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1d9a8:	e2833002 	add	r3, r3, #2
   1d9ac:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1d9b0:	e2844008 	add	r4, r4, #8
   1d9b4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1d9b8:	e2833001 	add	r3, r3, #1
   1d9bc:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1d9c0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1d9c4:	e3530007 	cmp	r3, #7
   1d9c8:	da00000a 	ble	1d9f8 <_vfprintf_r+0x171c>
   1d9cc:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1d9d0:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1d9d4:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1d9d8:	e1a01002 	mov	r1, r2
   1d9dc:	e1a02003 	mov	r2, r3
   1d9e0:	eb0025f2 	bl	271b0 <__sprint_r>
   1d9e4:	e1a03000 	mov	r3, r0
   1d9e8:	e3530000 	cmp	r3, #0
   1d9ec:	0a000000 	beq	1d9f4 <_vfprintf_r+0x1718>
   1d9f0:	ea0004a4 	b	1ec88 <_vfprintf_r+0x29ac>
   1d9f4:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   1d9f8:	e2063084 	and	r3, r6, #132	; 0x84
   1d9fc:	e3530080 	cmp	r3, #128	; 0x80
   1da00:	1a00003a 	bne	1daf0 <_vfprintf_r+0x1814>
			PAD (width - realsz, zeroes);
   1da04:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1da08:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   1da0c:	e0635002 	rsb	r5, r3, r2
   1da10:	e3550000 	cmp	r5, #0
   1da14:	da000035 	ble	1daf0 <_vfprintf_r+0x1814>
   1da18:	ea000019 	b	1da84 <_vfprintf_r+0x17a8>
   1da1c:	e59f31d8 	ldr	r3, [pc, #472]	; 1dbfc <_vfprintf_r+0x1920>
   1da20:	e5843000 	str	r3, [r4]
   1da24:	e3a03010 	mov	r3, #16
   1da28:	e5843004 	str	r3, [r4, #4]
   1da2c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1da30:	e2833010 	add	r3, r3, #16
   1da34:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1da38:	e2844008 	add	r4, r4, #8
   1da3c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1da40:	e2833001 	add	r3, r3, #1
   1da44:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1da48:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1da4c:	e3530007 	cmp	r3, #7
   1da50:	da00000a 	ble	1da80 <_vfprintf_r+0x17a4>
   1da54:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1da58:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1da5c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1da60:	e1a01002 	mov	r1, r2
   1da64:	e1a02003 	mov	r2, r3
   1da68:	eb0025d0 	bl	271b0 <__sprint_r>
   1da6c:	e1a03000 	mov	r3, r0
   1da70:	e3530000 	cmp	r3, #0
   1da74:	0a000000 	beq	1da7c <_vfprintf_r+0x17a0>
   1da78:	ea000482 	b	1ec88 <_vfprintf_r+0x29ac>
   1da7c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1da80:	e2455010 	sub	r5, r5, #16
   1da84:	e3550010 	cmp	r5, #16
   1da88:	caffffe3 	bgt	1da1c <_vfprintf_r+0x1740>
   1da8c:	e59f3168 	ldr	r3, [pc, #360]	; 1dbfc <_vfprintf_r+0x1920>
   1da90:	e5843000 	str	r3, [r4]
   1da94:	e1a03005 	mov	r3, r5
   1da98:	e5843004 	str	r3, [r4, #4]
   1da9c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1daa0:	e0833005 	add	r3, r3, r5
   1daa4:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1daa8:	e2844008 	add	r4, r4, #8
   1daac:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1dab0:	e2833001 	add	r3, r3, #1
   1dab4:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1dab8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1dabc:	e3530007 	cmp	r3, #7
   1dac0:	da00000a 	ble	1daf0 <_vfprintf_r+0x1814>
   1dac4:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1dac8:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1dacc:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1dad0:	e1a01002 	mov	r1, r2
   1dad4:	e1a02003 	mov	r2, r3
   1dad8:	eb0025b4 	bl	271b0 <__sprint_r>
   1dadc:	e1a03000 	mov	r3, r0
   1dae0:	e3530000 	cmp	r3, #0
   1dae4:	0a000000 	beq	1daec <_vfprintf_r+0x1810>
   1dae8:	ea000466 	b	1ec88 <_vfprintf_r+0x29ac>
   1daec:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   1daf0:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   1daf4:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1daf8:	e0635002 	rsb	r5, r3, r2
   1dafc:	e3550000 	cmp	r5, #0
   1db00:	da000040 	ble	1dc08 <_vfprintf_r+0x192c>
   1db04:	ea000019 	b	1db70 <_vfprintf_r+0x1894>
   1db08:	e59f30ec 	ldr	r3, [pc, #236]	; 1dbfc <_vfprintf_r+0x1920>
   1db0c:	e5843000 	str	r3, [r4]
   1db10:	e3a03010 	mov	r3, #16
   1db14:	e5843004 	str	r3, [r4, #4]
   1db18:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1db1c:	e2833010 	add	r3, r3, #16
   1db20:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1db24:	e2844008 	add	r4, r4, #8
   1db28:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1db2c:	e2833001 	add	r3, r3, #1
   1db30:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1db34:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1db38:	e3530007 	cmp	r3, #7
   1db3c:	da00000a 	ble	1db6c <_vfprintf_r+0x1890>
   1db40:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1db44:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1db48:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1db4c:	e1a01002 	mov	r1, r2
   1db50:	e1a02003 	mov	r2, r3
   1db54:	eb002595 	bl	271b0 <__sprint_r>
   1db58:	e1a03000 	mov	r3, r0
   1db5c:	e3530000 	cmp	r3, #0
   1db60:	0a000000 	beq	1db68 <_vfprintf_r+0x188c>
   1db64:	ea000447 	b	1ec88 <_vfprintf_r+0x29ac>
   1db68:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1db6c:	e2455010 	sub	r5, r5, #16
   1db70:	e3550010 	cmp	r5, #16
   1db74:	caffffe3 	bgt	1db08 <_vfprintf_r+0x182c>
   1db78:	e59f307c 	ldr	r3, [pc, #124]	; 1dbfc <_vfprintf_r+0x1920>
   1db7c:	e5843000 	str	r3, [r4]
   1db80:	e1a03005 	mov	r3, r5
   1db84:	e5843004 	str	r3, [r4, #4]
   1db88:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1db8c:	e0833005 	add	r3, r3, r5
   1db90:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1db94:	e2844008 	add	r4, r4, #8
   1db98:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1db9c:	e2833001 	add	r3, r3, #1
   1dba0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1dba4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1dba8:	e3530007 	cmp	r3, #7
   1dbac:	da000015 	ble	1dc08 <_vfprintf_r+0x192c>
   1dbb0:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1dbb4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1dbb8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1dbbc:	e1a01002 	mov	r1, r2
   1dbc0:	e1a02003 	mov	r2, r3
   1dbc4:	eb002579 	bl	271b0 <__sprint_r>
   1dbc8:	e1a03000 	mov	r3, r0
   1dbcc:	e3530000 	cmp	r3, #0
   1dbd0:	0a00000b 	beq	1dc04 <_vfprintf_r+0x1928>
   1dbd4:	ea00042b 	b	1ec88 <_vfprintf_r+0x29ac>
   1dbd8:	000330dc 	.word	0x000330dc
   1dbdc:	000330e0 	.word	0x000330e0
   1dbe0:	000330e4 	.word	0x000330e4
   1dbe4:	000330e8 	.word	0x000330e8
   1dbe8:	000330ec 	.word	0x000330ec
   1dbec:	00033100 	.word	0x00033100
   1dbf0:	00033108 	.word	0x00033108
   1dbf4:	0003311c 	.word	0x0003311c
   1dbf8:	00033138 	.word	0x00033138
   1dbfc:	0003314c 	.word	0x0003314c
   1dc00:	0003313c 	.word	0x0003313c
   1dc04:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
   1dc08:	e2063c01 	and	r3, r6, #256	; 0x100
   1dc0c:	e3530000 	cmp	r3, #0
   1dc10:	1a000019 	bne	1dc7c <_vfprintf_r+0x19a0>
			PRINT (cp, size);
   1dc14:	e5847000 	str	r7, [r4]
   1dc18:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1dc1c:	e5843004 	str	r3, [r4, #4]
   1dc20:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1dc24:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1dc28:	e0823003 	add	r3, r2, r3
   1dc2c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1dc30:	e2844008 	add	r4, r4, #8
   1dc34:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1dc38:	e2833001 	add	r3, r3, #1
   1dc3c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1dc40:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1dc44:	e3530007 	cmp	r3, #7
   1dc48:	da00039f 	ble	1eacc <_vfprintf_r+0x27f0>
   1dc4c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1dc50:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1dc54:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1dc58:	e1a01002 	mov	r1, r2
   1dc5c:	e1a02003 	mov	r2, r3
   1dc60:	eb002552 	bl	271b0 <__sprint_r>
   1dc64:	e1a03000 	mov	r3, r0
   1dc68:	e3530000 	cmp	r3, #0
   1dc6c:	0a000000 	beq	1dc74 <_vfprintf_r+0x1998>
   1dc70:	ea000404 	b	1ec88 <_vfprintf_r+0x29ac>
   1dc74:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1dc78:	ea000393 	b	1eacc <_vfprintf_r+0x27f0>
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
   1dc7c:	e3580065 	cmp	r8, #101	; 0x65
   1dc80:	da0002c3 	ble	1e794 <_vfprintf_r+0x24b8>
				if (_fpvalue == 0) {
   1dc84:	e24b3094 	sub	r3, fp, #148	; 0x94
   1dc88:	e893000c 	ldm	r3, {r2, r3}
   1dc8c:	e1a00002 	mov	r0, r2
   1dc90:	e1a01003 	mov	r1, r3
   1dc94:	e3a02000 	mov	r2, #0
   1dc98:	e3a03000 	mov	r3, #0
   1dc9c:	ebffdcf1 	bl	15068 <__aeabi_dcmpeq>
   1dca0:	e1a03000 	mov	r3, r0
   1dca4:	e3530000 	cmp	r3, #0
   1dca8:	0a000075 	beq	1de84 <_vfprintf_r+0x1ba8>
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
   1dcac:	e51f30bc 	ldr	r3, [pc, #-188]	; 1dbf8 <_vfprintf_r+0x191c>
   1dcb0:	e5843000 	str	r3, [r4]
   1dcb4:	e3a03001 	mov	r3, #1
   1dcb8:	e5843004 	str	r3, [r4, #4]
   1dcbc:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1dcc0:	e2833001 	add	r3, r3, #1
   1dcc4:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1dcc8:	e2844008 	add	r4, r4, #8
   1dccc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1dcd0:	e2833001 	add	r3, r3, #1
   1dcd4:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1dcd8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1dcdc:	e3530007 	cmp	r3, #7
   1dce0:	da00000a 	ble	1dd10 <_vfprintf_r+0x1a34>
   1dce4:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1dce8:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1dcec:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1dcf0:	e1a01002 	mov	r1, r2
   1dcf4:	e1a02003 	mov	r2, r3
   1dcf8:	eb00252c 	bl	271b0 <__sprint_r>
   1dcfc:	e1a03000 	mov	r3, r0
   1dd00:	e3530000 	cmp	r3, #0
   1dd04:	0a000000 	beq	1dd0c <_vfprintf_r+0x1a30>
   1dd08:	ea0003de 	b	1ec88 <_vfprintf_r+0x29ac>
   1dd0c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					if (expt < ndig || flags & ALT) {
   1dd10:	e51b2098 	ldr	r2, [fp, #-152]	; 0x98
   1dd14:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1dd18:	e1520003 	cmp	r2, r3
   1dd1c:	ba000002 	blt	1dd2c <_vfprintf_r+0x1a50>
   1dd20:	e2063001 	and	r3, r6, #1
   1dd24:	e3530000 	cmp	r3, #0
   1dd28:	0a000367 	beq	1eacc <_vfprintf_r+0x27f0>
						PRINT (decimal_point, decp_len);
   1dd2c:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1dd30:	e5843000 	str	r3, [r4]
   1dd34:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1dd38:	e5843004 	str	r3, [r4, #4]
   1dd3c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1dd40:	e1a02003 	mov	r2, r3
   1dd44:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1dd48:	e0823003 	add	r3, r2, r3
   1dd4c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1dd50:	e2844008 	add	r4, r4, #8
   1dd54:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1dd58:	e2833001 	add	r3, r3, #1
   1dd5c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1dd60:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1dd64:	e3530007 	cmp	r3, #7
   1dd68:	da00000a 	ble	1dd98 <_vfprintf_r+0x1abc>
   1dd6c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1dd70:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1dd74:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1dd78:	e1a01002 	mov	r1, r2
   1dd7c:	e1a02003 	mov	r2, r3
   1dd80:	eb00250a 	bl	271b0 <__sprint_r>
   1dd84:	e1a03000 	mov	r3, r0
   1dd88:	e3530000 	cmp	r3, #0
   1dd8c:	0a000000 	beq	1dd94 <_vfprintf_r+0x1ab8>
   1dd90:	ea0003bc 	b	1ec88 <_vfprintf_r+0x29ac>
   1dd94:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						PAD (ndig - 1, zeroes);
   1dd98:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1dd9c:	e2435001 	sub	r5, r3, #1
   1dda0:	e3550000 	cmp	r5, #0
   1dda4:	da000348 	ble	1eacc <_vfprintf_r+0x27f0>
   1dda8:	ea000019 	b	1de14 <_vfprintf_r+0x1b38>
   1ddac:	e51f31b8 	ldr	r3, [pc, #-440]	; 1dbfc <_vfprintf_r+0x1920>
   1ddb0:	e5843000 	str	r3, [r4]
   1ddb4:	e3a03010 	mov	r3, #16
   1ddb8:	e5843004 	str	r3, [r4, #4]
   1ddbc:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1ddc0:	e2833010 	add	r3, r3, #16
   1ddc4:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1ddc8:	e2844008 	add	r4, r4, #8
   1ddcc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1ddd0:	e2833001 	add	r3, r3, #1
   1ddd4:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1ddd8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1dddc:	e3530007 	cmp	r3, #7
   1dde0:	da00000a 	ble	1de10 <_vfprintf_r+0x1b34>
   1dde4:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1dde8:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1ddec:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ddf0:	e1a01002 	mov	r1, r2
   1ddf4:	e1a02003 	mov	r2, r3
   1ddf8:	eb0024ec 	bl	271b0 <__sprint_r>
   1ddfc:	e1a03000 	mov	r3, r0
   1de00:	e3530000 	cmp	r3, #0
   1de04:	0a000000 	beq	1de0c <_vfprintf_r+0x1b30>
   1de08:	ea00039e 	b	1ec88 <_vfprintf_r+0x29ac>
   1de0c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1de10:	e2455010 	sub	r5, r5, #16
   1de14:	e3550010 	cmp	r5, #16
   1de18:	caffffe3 	bgt	1ddac <_vfprintf_r+0x1ad0>
   1de1c:	e51f3228 	ldr	r3, [pc, #-552]	; 1dbfc <_vfprintf_r+0x1920>
   1de20:	e5843000 	str	r3, [r4]
   1de24:	e1a03005 	mov	r3, r5
   1de28:	e5843004 	str	r3, [r4, #4]
   1de2c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1de30:	e0833005 	add	r3, r3, r5
   1de34:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1de38:	e2844008 	add	r4, r4, #8
   1de3c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1de40:	e2833001 	add	r3, r3, #1
   1de44:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1de48:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1de4c:	e3530007 	cmp	r3, #7
   1de50:	da00031d 	ble	1eacc <_vfprintf_r+0x27f0>
   1de54:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1de58:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1de5c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1de60:	e1a01002 	mov	r1, r2
   1de64:	e1a02003 	mov	r2, r3
   1de68:	eb0024d0 	bl	271b0 <__sprint_r>
   1de6c:	e1a03000 	mov	r3, r0
   1de70:	e3530000 	cmp	r3, #0
   1de74:	0a000000 	beq	1de7c <_vfprintf_r+0x1ba0>
   1de78:	ea000382 	b	1ec88 <_vfprintf_r+0x29ac>
   1de7c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1de80:	ea000311 	b	1eacc <_vfprintf_r+0x27f0>
					}
				} else if (expt <= 0) {
   1de84:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1de88:	e3530000 	cmp	r3, #0
   1de8c:	ca000090 	bgt	1e0d4 <_vfprintf_r+0x1df8>
					PRINT ("0", 1);
   1de90:	e51f32a0 	ldr	r3, [pc, #-672]	; 1dbf8 <_vfprintf_r+0x191c>
   1de94:	e5843000 	str	r3, [r4]
   1de98:	e3a03001 	mov	r3, #1
   1de9c:	e5843004 	str	r3, [r4, #4]
   1dea0:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1dea4:	e2833001 	add	r3, r3, #1
   1dea8:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1deac:	e2844008 	add	r4, r4, #8
   1deb0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1deb4:	e2833001 	add	r3, r3, #1
   1deb8:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1debc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1dec0:	e3530007 	cmp	r3, #7
   1dec4:	da00000a 	ble	1def4 <_vfprintf_r+0x1c18>
   1dec8:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1decc:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1ded0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ded4:	e1a01002 	mov	r1, r2
   1ded8:	e1a02003 	mov	r2, r3
   1dedc:	eb0024b3 	bl	271b0 <__sprint_r>
   1dee0:	e1a03000 	mov	r3, r0
   1dee4:	e3530000 	cmp	r3, #0
   1dee8:	0a000000 	beq	1def0 <_vfprintf_r+0x1c14>
   1deec:	ea000365 	b	1ec88 <_vfprintf_r+0x29ac>
   1def0:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					if (expt || ndig || flags & ALT) {
   1def4:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1def8:	e3530000 	cmp	r3, #0
   1defc:	1a000005 	bne	1df18 <_vfprintf_r+0x1c3c>
   1df00:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1df04:	e3530000 	cmp	r3, #0
   1df08:	1a000002 	bne	1df18 <_vfprintf_r+0x1c3c>
   1df0c:	e2063001 	and	r3, r6, #1
   1df10:	e3530000 	cmp	r3, #0
   1df14:	0a0002ec 	beq	1eacc <_vfprintf_r+0x27f0>
						PRINT (decimal_point, decp_len);
   1df18:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1df1c:	e5843000 	str	r3, [r4]
   1df20:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1df24:	e5843004 	str	r3, [r4, #4]
   1df28:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1df2c:	e1a02003 	mov	r2, r3
   1df30:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1df34:	e0823003 	add	r3, r2, r3
   1df38:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1df3c:	e2844008 	add	r4, r4, #8
   1df40:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1df44:	e2833001 	add	r3, r3, #1
   1df48:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1df4c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1df50:	e3530007 	cmp	r3, #7
   1df54:	da00000a 	ble	1df84 <_vfprintf_r+0x1ca8>
   1df58:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1df5c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1df60:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1df64:	e1a01002 	mov	r1, r2
   1df68:	e1a02003 	mov	r2, r3
   1df6c:	eb00248f 	bl	271b0 <__sprint_r>
   1df70:	e1a03000 	mov	r3, r0
   1df74:	e3530000 	cmp	r3, #0
   1df78:	0a000000 	beq	1df80 <_vfprintf_r+0x1ca4>
   1df7c:	ea000341 	b	1ec88 <_vfprintf_r+0x29ac>
   1df80:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						PAD (-expt, zeroes);
   1df84:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1df88:	e2635000 	rsb	r5, r3, #0
   1df8c:	e3550000 	cmp	r5, #0
   1df90:	da000035 	ble	1e06c <_vfprintf_r+0x1d90>
   1df94:	ea000019 	b	1e000 <_vfprintf_r+0x1d24>
   1df98:	e51f33a4 	ldr	r3, [pc, #-932]	; 1dbfc <_vfprintf_r+0x1920>
   1df9c:	e5843000 	str	r3, [r4]
   1dfa0:	e3a03010 	mov	r3, #16
   1dfa4:	e5843004 	str	r3, [r4, #4]
   1dfa8:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1dfac:	e2833010 	add	r3, r3, #16
   1dfb0:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1dfb4:	e2844008 	add	r4, r4, #8
   1dfb8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1dfbc:	e2833001 	add	r3, r3, #1
   1dfc0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1dfc4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1dfc8:	e3530007 	cmp	r3, #7
   1dfcc:	da00000a 	ble	1dffc <_vfprintf_r+0x1d20>
   1dfd0:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1dfd4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1dfd8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1dfdc:	e1a01002 	mov	r1, r2
   1dfe0:	e1a02003 	mov	r2, r3
   1dfe4:	eb002471 	bl	271b0 <__sprint_r>
   1dfe8:	e1a03000 	mov	r3, r0
   1dfec:	e3530000 	cmp	r3, #0
   1dff0:	0a000000 	beq	1dff8 <_vfprintf_r+0x1d1c>
   1dff4:	ea000323 	b	1ec88 <_vfprintf_r+0x29ac>
   1dff8:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1dffc:	e2455010 	sub	r5, r5, #16
   1e000:	e3550010 	cmp	r5, #16
   1e004:	caffffe3 	bgt	1df98 <_vfprintf_r+0x1cbc>
   1e008:	e51f3414 	ldr	r3, [pc, #-1044]	; 1dbfc <_vfprintf_r+0x1920>
   1e00c:	e5843000 	str	r3, [r4]
   1e010:	e1a03005 	mov	r3, r5
   1e014:	e5843004 	str	r3, [r4, #4]
   1e018:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1e01c:	e0833005 	add	r3, r3, r5
   1e020:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e024:	e2844008 	add	r4, r4, #8
   1e028:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e02c:	e2833001 	add	r3, r3, #1
   1e030:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e034:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e038:	e3530007 	cmp	r3, #7
   1e03c:	da00000a 	ble	1e06c <_vfprintf_r+0x1d90>
   1e040:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e044:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e048:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e04c:	e1a01002 	mov	r1, r2
   1e050:	e1a02003 	mov	r2, r3
   1e054:	eb002455 	bl	271b0 <__sprint_r>
   1e058:	e1a03000 	mov	r3, r0
   1e05c:	e3530000 	cmp	r3, #0
   1e060:	0a000000 	beq	1e068 <_vfprintf_r+0x1d8c>
   1e064:	ea000307 	b	1ec88 <_vfprintf_r+0x29ac>
   1e068:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						PRINT (cp, ndig);
   1e06c:	e5847000 	str	r7, [r4]
   1e070:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1e074:	e5843004 	str	r3, [r4, #4]
   1e078:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1e07c:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1e080:	e0823003 	add	r3, r2, r3
   1e084:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e088:	e2844008 	add	r4, r4, #8
   1e08c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e090:	e2833001 	add	r3, r3, #1
   1e094:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e098:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e09c:	e3530007 	cmp	r3, #7
   1e0a0:	da000289 	ble	1eacc <_vfprintf_r+0x27f0>
   1e0a4:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e0a8:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e0ac:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e0b0:	e1a01002 	mov	r1, r2
   1e0b4:	e1a02003 	mov	r2, r3
   1e0b8:	eb00243c 	bl	271b0 <__sprint_r>
   1e0bc:	e1a03000 	mov	r3, r0
   1e0c0:	e3530000 	cmp	r3, #0
   1e0c4:	0a000000 	beq	1e0cc <_vfprintf_r+0x1df0>
   1e0c8:	ea0002ee 	b	1ec88 <_vfprintf_r+0x29ac>
   1e0cc:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1e0d0:	ea00027d 	b	1eacc <_vfprintf_r+0x27f0>
					}
				} else {
					char *convbuf = cp;
   1e0d4:	e50b7088 	str	r7, [fp, #-136]	; 0x88
					PRINTANDPAD(cp, convbuf + ndig,
   1e0d8:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1e0dc:	e51b2088 	ldr	r2, [fp, #-136]	; 0x88
   1e0e0:	e0823003 	add	r3, r2, r3
   1e0e4:	e1a02003 	mov	r2, r3
   1e0e8:	e1a03007 	mov	r3, r7
   1e0ec:	e0633002 	rsb	r3, r3, r2
   1e0f0:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   1e0f4:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   1e0f8:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1e0fc:	e1520003 	cmp	r2, r3
   1e100:	da000001 	ble	1e10c <_vfprintf_r+0x1e30>
   1e104:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1e108:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   1e10c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1e110:	e3530000 	cmp	r3, #0
   1e114:	da000018 	ble	1e17c <_vfprintf_r+0x1ea0>
   1e118:	e5847000 	str	r7, [r4]
   1e11c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1e120:	e5843004 	str	r3, [r4, #4]
   1e124:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1e128:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1e12c:	e0823003 	add	r3, r2, r3
   1e130:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e134:	e2844008 	add	r4, r4, #8
   1e138:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e13c:	e2833001 	add	r3, r3, #1
   1e140:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e144:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e148:	e3530007 	cmp	r3, #7
   1e14c:	da00000a 	ble	1e17c <_vfprintf_r+0x1ea0>
   1e150:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e154:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e158:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e15c:	e1a01002 	mov	r1, r2
   1e160:	e1a02003 	mov	r2, r3
   1e164:	eb002411 	bl	271b0 <__sprint_r>
   1e168:	e1a03000 	mov	r3, r0
   1e16c:	e3530000 	cmp	r3, #0
   1e170:	0a000000 	beq	1e178 <_vfprintf_r+0x1e9c>
   1e174:	ea0002c3 	b	1ec88 <_vfprintf_r+0x29ac>
   1e178:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1e17c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1e180:	e1c33fc3 	bic	r3, r3, r3, asr #31
   1e184:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   1e188:	e0633002 	rsb	r3, r3, r2
   1e18c:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   1e190:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1e194:	e3530000 	cmp	r3, #0
   1e198:	da000039 	ble	1e284 <_vfprintf_r+0x1fa8>
   1e19c:	ea00001b 	b	1e210 <_vfprintf_r+0x1f34>
   1e1a0:	e51f35ac 	ldr	r3, [pc, #-1452]	; 1dbfc <_vfprintf_r+0x1920>
   1e1a4:	e5843000 	str	r3, [r4]
   1e1a8:	e3a03010 	mov	r3, #16
   1e1ac:	e5843004 	str	r3, [r4, #4]
   1e1b0:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1e1b4:	e2833010 	add	r3, r3, #16
   1e1b8:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e1bc:	e2844008 	add	r4, r4, #8
   1e1c0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e1c4:	e2833001 	add	r3, r3, #1
   1e1c8:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e1cc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e1d0:	e3530007 	cmp	r3, #7
   1e1d4:	da00000a 	ble	1e204 <_vfprintf_r+0x1f28>
   1e1d8:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e1dc:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e1e0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e1e4:	e1a01002 	mov	r1, r2
   1e1e8:	e1a02003 	mov	r2, r3
   1e1ec:	eb0023ef 	bl	271b0 <__sprint_r>
   1e1f0:	e1a03000 	mov	r3, r0
   1e1f4:	e3530000 	cmp	r3, #0
   1e1f8:	0a000000 	beq	1e200 <_vfprintf_r+0x1f24>
   1e1fc:	ea0002a1 	b	1ec88 <_vfprintf_r+0x29ac>
   1e200:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1e204:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1e208:	e2433010 	sub	r3, r3, #16
   1e20c:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   1e210:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1e214:	e3530010 	cmp	r3, #16
   1e218:	caffffe0 	bgt	1e1a0 <_vfprintf_r+0x1ec4>
   1e21c:	e51f3628 	ldr	r3, [pc, #-1576]	; 1dbfc <_vfprintf_r+0x1920>
   1e220:	e5843000 	str	r3, [r4]
   1e224:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1e228:	e5843004 	str	r3, [r4, #4]
   1e22c:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1e230:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1e234:	e0823003 	add	r3, r2, r3
   1e238:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e23c:	e2844008 	add	r4, r4, #8
   1e240:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e244:	e2833001 	add	r3, r3, #1
   1e248:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e24c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e250:	e3530007 	cmp	r3, #7
   1e254:	da00000a 	ble	1e284 <_vfprintf_r+0x1fa8>
   1e258:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e25c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e260:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e264:	e1a01002 	mov	r1, r2
   1e268:	e1a02003 	mov	r2, r3
   1e26c:	eb0023cf 	bl	271b0 <__sprint_r>
   1e270:	e1a03000 	mov	r3, r0
   1e274:	e3530000 	cmp	r3, #0
   1e278:	0a000000 	beq	1e280 <_vfprintf_r+0x1fa4>
   1e27c:	ea000281 	b	1ec88 <_vfprintf_r+0x29ac>
   1e280:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						    lead, zeroes);
					cp += lead;
   1e284:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1e288:	e0877003 	add	r7, r7, r3
#ifdef _WANT_IO_C99_FORMATS
					if (flags & GROUPING) {
   1e28c:	e2063b01 	and	r3, r6, #1024	; 0x400
   1e290:	e3530000 	cmp	r3, #0
   1e294:	0a0000a9 	beq	1e540 <_vfprintf_r+0x2264>
					    while (nseps > 0 || nrepeats > 0) {
   1e298:	ea00009a 	b	1e508 <_vfprintf_r+0x222c>
						if (nrepeats > 0)
   1e29c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1e2a0:	e3530000 	cmp	r3, #0
   1e2a4:	da000003 	ble	1e2b8 <_vfprintf_r+0x1fdc>
						    nrepeats--;
   1e2a8:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1e2ac:	e2433001 	sub	r3, r3, #1
   1e2b0:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   1e2b4:	ea000005 	b	1e2d0 <_vfprintf_r+0x1ff4>
						else {
						    grouping--;
   1e2b8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e2bc:	e2433001 	sub	r3, r3, #1
   1e2c0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
						    nseps--;
   1e2c4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1e2c8:	e2433001 	sub	r3, r3, #1
   1e2cc:	e50b3040 	str	r3, [fp, #-64]	; 0x40
						}
						PRINT(thousands_sep, thsnd_len);
   1e2d0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1e2d4:	e5843000 	str	r3, [r4]
   1e2d8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1e2dc:	e5843004 	str	r3, [r4, #4]
   1e2e0:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1e2e4:	e1a02003 	mov	r2, r3
   1e2e8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1e2ec:	e0823003 	add	r3, r2, r3
   1e2f0:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e2f4:	e2844008 	add	r4, r4, #8
   1e2f8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e2fc:	e2833001 	add	r3, r3, #1
   1e300:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e304:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e308:	e3530007 	cmp	r3, #7
   1e30c:	da00000a 	ble	1e33c <_vfprintf_r+0x2060>
   1e310:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e314:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e318:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e31c:	e1a01002 	mov	r1, r2
   1e320:	e1a02003 	mov	r2, r3
   1e324:	eb0023a1 	bl	271b0 <__sprint_r>
   1e328:	e1a03000 	mov	r3, r0
   1e32c:	e3530000 	cmp	r3, #0
   1e330:	0a000000 	beq	1e338 <_vfprintf_r+0x205c>
   1e334:	ea000253 	b	1ec88 <_vfprintf_r+0x29ac>
   1e338:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						PRINTANDPAD (cp, convbuf + ndig,
   1e33c:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1e340:	e51b2088 	ldr	r2, [fp, #-136]	; 0x88
   1e344:	e0823003 	add	r3, r2, r3
   1e348:	e1a02003 	mov	r2, r3
   1e34c:	e1a03007 	mov	r3, r7
   1e350:	e0633002 	rsb	r3, r3, r2
   1e354:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1e358:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e35c:	e5d33000 	ldrb	r3, [r3]
   1e360:	e1a02003 	mov	r2, r3
   1e364:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1e368:	e1520003 	cmp	r2, r3
   1e36c:	aa000002 	bge	1e37c <_vfprintf_r+0x20a0>
   1e370:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e374:	e5d33000 	ldrb	r3, [r3]
   1e378:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1e37c:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1e380:	e3530000 	cmp	r3, #0
   1e384:	da000018 	ble	1e3ec <_vfprintf_r+0x2110>
   1e388:	e5847000 	str	r7, [r4]
   1e38c:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1e390:	e5843004 	str	r3, [r4, #4]
   1e394:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1e398:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1e39c:	e0823003 	add	r3, r2, r3
   1e3a0:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e3a4:	e2844008 	add	r4, r4, #8
   1e3a8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e3ac:	e2833001 	add	r3, r3, #1
   1e3b0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e3b4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e3b8:	e3530007 	cmp	r3, #7
   1e3bc:	da00000a 	ble	1e3ec <_vfprintf_r+0x2110>
   1e3c0:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e3c4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e3c8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e3cc:	e1a01002 	mov	r1, r2
   1e3d0:	e1a02003 	mov	r2, r3
   1e3d4:	eb002375 	bl	271b0 <__sprint_r>
   1e3d8:	e1a03000 	mov	r3, r0
   1e3dc:	e3530000 	cmp	r3, #0
   1e3e0:	0a000000 	beq	1e3e8 <_vfprintf_r+0x210c>
   1e3e4:	ea000227 	b	1ec88 <_vfprintf_r+0x29ac>
   1e3e8:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1e3ec:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e3f0:	e5d33000 	ldrb	r3, [r3]
   1e3f4:	e1a02003 	mov	r2, r3
   1e3f8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1e3fc:	e1c33fc3 	bic	r3, r3, r3, asr #31
   1e400:	e0633002 	rsb	r3, r3, r2
   1e404:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1e408:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1e40c:	e3530000 	cmp	r3, #0
   1e410:	da000039 	ble	1e4fc <_vfprintf_r+0x2220>
   1e414:	ea00001b 	b	1e488 <_vfprintf_r+0x21ac>
   1e418:	e51f3824 	ldr	r3, [pc, #-2084]	; 1dbfc <_vfprintf_r+0x1920>
   1e41c:	e5843000 	str	r3, [r4]
   1e420:	e3a03010 	mov	r3, #16
   1e424:	e5843004 	str	r3, [r4, #4]
   1e428:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1e42c:	e2833010 	add	r3, r3, #16
   1e430:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e434:	e2844008 	add	r4, r4, #8
   1e438:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e43c:	e2833001 	add	r3, r3, #1
   1e440:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e444:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e448:	e3530007 	cmp	r3, #7
   1e44c:	da00000a 	ble	1e47c <_vfprintf_r+0x21a0>
   1e450:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e454:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e458:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e45c:	e1a01002 	mov	r1, r2
   1e460:	e1a02003 	mov	r2, r3
   1e464:	eb002351 	bl	271b0 <__sprint_r>
   1e468:	e1a03000 	mov	r3, r0
   1e46c:	e3530000 	cmp	r3, #0
   1e470:	0a000000 	beq	1e478 <_vfprintf_r+0x219c>
   1e474:	ea000203 	b	1ec88 <_vfprintf_r+0x29ac>
   1e478:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1e47c:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1e480:	e2433010 	sub	r3, r3, #16
   1e484:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1e488:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1e48c:	e3530010 	cmp	r3, #16
   1e490:	caffffe0 	bgt	1e418 <_vfprintf_r+0x213c>
   1e494:	e51f38a0 	ldr	r3, [pc, #-2208]	; 1dbfc <_vfprintf_r+0x1920>
   1e498:	e5843000 	str	r3, [r4]
   1e49c:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1e4a0:	e5843004 	str	r3, [r4, #4]
   1e4a4:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1e4a8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1e4ac:	e0823003 	add	r3, r2, r3
   1e4b0:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e4b4:	e2844008 	add	r4, r4, #8
   1e4b8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e4bc:	e2833001 	add	r3, r3, #1
   1e4c0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e4c4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e4c8:	e3530007 	cmp	r3, #7
   1e4cc:	da00000a 	ble	1e4fc <_vfprintf_r+0x2220>
   1e4d0:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e4d4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e4d8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e4dc:	e1a01002 	mov	r1, r2
   1e4e0:	e1a02003 	mov	r2, r3
   1e4e4:	eb002331 	bl	271b0 <__sprint_r>
   1e4e8:	e1a03000 	mov	r3, r0
   1e4ec:	e3530000 	cmp	r3, #0
   1e4f0:	0a000000 	beq	1e4f8 <_vfprintf_r+0x221c>
   1e4f4:	ea0001e3 	b	1ec88 <_vfprintf_r+0x29ac>
   1e4f8:	e24b40f0 	sub	r4, fp, #240	; 0xf0
							     *grouping, zeroes);
						cp += *grouping;
   1e4fc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e500:	e5d33000 	ldrb	r3, [r3]
   1e504:	e0877003 	add	r7, r7, r3
					PRINTANDPAD(cp, convbuf + ndig,
						    lead, zeroes);
					cp += lead;
#ifdef _WANT_IO_C99_FORMATS
					if (flags & GROUPING) {
					    while (nseps > 0 || nrepeats > 0) {
   1e508:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1e50c:	e3530000 	cmp	r3, #0
   1e510:	caffff61 	bgt	1e29c <_vfprintf_r+0x1fc0>
   1e514:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1e518:	e3530000 	cmp	r3, #0
   1e51c:	caffff5e 	bgt	1e29c <_vfprintf_r+0x1fc0>
						PRINT(thousands_sep, thsnd_len);
						PRINTANDPAD (cp, convbuf + ndig,
							     *grouping, zeroes);
						cp += *grouping;
					    }
					    if (cp > convbuf + ndig)
   1e520:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1e524:	e51b2088 	ldr	r2, [fp, #-136]	; 0x88
   1e528:	e0823003 	add	r3, r2, r3
   1e52c:	e1530007 	cmp	r3, r7
   1e530:	2a000002 	bcs	1e540 <_vfprintf_r+0x2264>
						cp = convbuf + ndig;
   1e534:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1e538:	e51b2088 	ldr	r2, [fp, #-136]	; 0x88
   1e53c:	e0827003 	add	r7, r2, r3
					}
#endif
					if (expt < ndig || flags & ALT)
   1e540:	e51b2098 	ldr	r2, [fp, #-152]	; 0x98
   1e544:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1e548:	e1520003 	cmp	r2, r3
   1e54c:	ba000002 	blt	1e55c <_vfprintf_r+0x2280>
   1e550:	e2063001 	and	r3, r6, #1
   1e554:	e3530000 	cmp	r3, #0
   1e558:	0a00001a 	beq	1e5c8 <_vfprintf_r+0x22ec>
					    PRINT (decimal_point, decp_len);
   1e55c:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1e560:	e5843000 	str	r3, [r4]
   1e564:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1e568:	e5843004 	str	r3, [r4, #4]
   1e56c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1e570:	e1a02003 	mov	r2, r3
   1e574:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1e578:	e0823003 	add	r3, r2, r3
   1e57c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e580:	e2844008 	add	r4, r4, #8
   1e584:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e588:	e2833001 	add	r3, r3, #1
   1e58c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e590:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e594:	e3530007 	cmp	r3, #7
   1e598:	da00000a 	ble	1e5c8 <_vfprintf_r+0x22ec>
   1e59c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e5a0:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e5a4:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e5a8:	e1a01002 	mov	r1, r2
   1e5ac:	e1a02003 	mov	r2, r3
   1e5b0:	eb0022fe 	bl	271b0 <__sprint_r>
   1e5b4:	e1a03000 	mov	r3, r0
   1e5b8:	e3530000 	cmp	r3, #0
   1e5bc:	0a000000 	beq	1e5c4 <_vfprintf_r+0x22e8>
   1e5c0:	ea0001b0 	b	1ec88 <_vfprintf_r+0x29ac>
   1e5c4:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					PRINTANDPAD (cp, convbuf + ndig,
   1e5c8:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1e5cc:	e51b2088 	ldr	r2, [fp, #-136]	; 0x88
   1e5d0:	e0823003 	add	r3, r2, r3
   1e5d4:	e1a02003 	mov	r2, r3
   1e5d8:	e1a03007 	mov	r3, r7
   1e5dc:	e0633002 	rsb	r3, r3, r2
   1e5e0:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1e5e4:	e51b20a4 	ldr	r2, [fp, #-164]	; 0xa4
   1e5e8:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1e5ec:	e0632002 	rsb	r2, r3, r2
   1e5f0:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1e5f4:	e1520003 	cmp	r2, r3
   1e5f8:	aa000003 	bge	1e60c <_vfprintf_r+0x2330>
   1e5fc:	e51b20a4 	ldr	r2, [fp, #-164]	; 0xa4
   1e600:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1e604:	e0633002 	rsb	r3, r3, r2
   1e608:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1e60c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1e610:	e3530000 	cmp	r3, #0
   1e614:	da000018 	ble	1e67c <_vfprintf_r+0x23a0>
   1e618:	e5847000 	str	r7, [r4]
   1e61c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1e620:	e5843004 	str	r3, [r4, #4]
   1e624:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1e628:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1e62c:	e0823003 	add	r3, r2, r3
   1e630:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e634:	e2844008 	add	r4, r4, #8
   1e638:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e63c:	e2833001 	add	r3, r3, #1
   1e640:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e644:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e648:	e3530007 	cmp	r3, #7
   1e64c:	da00000a 	ble	1e67c <_vfprintf_r+0x23a0>
   1e650:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e654:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e658:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e65c:	e1a01002 	mov	r1, r2
   1e660:	e1a02003 	mov	r2, r3
   1e664:	eb0022d1 	bl	271b0 <__sprint_r>
   1e668:	e1a03000 	mov	r3, r0
   1e66c:	e3530000 	cmp	r3, #0
   1e670:	0a000000 	beq	1e678 <_vfprintf_r+0x239c>
   1e674:	ea000183 	b	1ec88 <_vfprintf_r+0x29ac>
   1e678:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1e67c:	e51b20a4 	ldr	r2, [fp, #-164]	; 0xa4
   1e680:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1e684:	e0632002 	rsb	r2, r3, r2
   1e688:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1e68c:	e1c33fc3 	bic	r3, r3, r3, asr #31
   1e690:	e0633002 	rsb	r3, r3, r2
   1e694:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1e698:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1e69c:	e3530000 	cmp	r3, #0
   1e6a0:	da00003a 	ble	1e790 <_vfprintf_r+0x24b4>
   1e6a4:	ea00001b 	b	1e718 <_vfprintf_r+0x243c>
   1e6a8:	e51f3ab4 	ldr	r3, [pc, #-2740]	; 1dbfc <_vfprintf_r+0x1920>
   1e6ac:	e5843000 	str	r3, [r4]
   1e6b0:	e3a03010 	mov	r3, #16
   1e6b4:	e5843004 	str	r3, [r4, #4]
   1e6b8:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1e6bc:	e2833010 	add	r3, r3, #16
   1e6c0:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e6c4:	e2844008 	add	r4, r4, #8
   1e6c8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e6cc:	e2833001 	add	r3, r3, #1
   1e6d0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e6d4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e6d8:	e3530007 	cmp	r3, #7
   1e6dc:	da00000a 	ble	1e70c <_vfprintf_r+0x2430>
   1e6e0:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e6e4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e6e8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e6ec:	e1a01002 	mov	r1, r2
   1e6f0:	e1a02003 	mov	r2, r3
   1e6f4:	eb0022ad 	bl	271b0 <__sprint_r>
   1e6f8:	e1a03000 	mov	r3, r0
   1e6fc:	e3530000 	cmp	r3, #0
   1e700:	0a000000 	beq	1e708 <_vfprintf_r+0x242c>
   1e704:	ea00015f 	b	1ec88 <_vfprintf_r+0x29ac>
   1e708:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1e70c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1e710:	e2433010 	sub	r3, r3, #16
   1e714:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1e718:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1e71c:	e3530010 	cmp	r3, #16
   1e720:	caffffe0 	bgt	1e6a8 <_vfprintf_r+0x23cc>
   1e724:	e51f3b30 	ldr	r3, [pc, #-2864]	; 1dbfc <_vfprintf_r+0x1920>
   1e728:	e5843000 	str	r3, [r4]
   1e72c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1e730:	e5843004 	str	r3, [r4, #4]
   1e734:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1e738:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1e73c:	e0823003 	add	r3, r2, r3
   1e740:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e744:	e2844008 	add	r4, r4, #8
   1e748:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e74c:	e2833001 	add	r3, r3, #1
   1e750:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e754:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e758:	e3530007 	cmp	r3, #7
   1e75c:	da00000b 	ble	1e790 <_vfprintf_r+0x24b4>
   1e760:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e764:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e768:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e76c:	e1a01002 	mov	r1, r2
   1e770:	e1a02003 	mov	r2, r3
   1e774:	eb00228d 	bl	271b0 <__sprint_r>
   1e778:	e1a03000 	mov	r3, r0
   1e77c:	e3530000 	cmp	r3, #0
   1e780:	0a000000 	beq	1e788 <_vfprintf_r+0x24ac>
   1e784:	ea00013f 	b	1ec88 <_vfprintf_r+0x29ac>
   1e788:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1e78c:	ea0000ce 	b	1eacc <_vfprintf_r+0x27f0>
   1e790:	ea0000cd 	b	1eacc <_vfprintf_r+0x27f0>
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
   1e794:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1e798:	e3530001 	cmp	r3, #1
   1e79c:	ca000002 	bgt	1e7ac <_vfprintf_r+0x24d0>
   1e7a0:	e2063001 	and	r3, r6, #1
   1e7a4:	e3530000 	cmp	r3, #0
   1e7a8:	0a000095 	beq	1ea04 <_vfprintf_r+0x2728>
					PRINT (cp, 1);
   1e7ac:	e5847000 	str	r7, [r4]
   1e7b0:	e3a03001 	mov	r3, #1
   1e7b4:	e5843004 	str	r3, [r4, #4]
   1e7b8:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1e7bc:	e2833001 	add	r3, r3, #1
   1e7c0:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e7c4:	e2844008 	add	r4, r4, #8
   1e7c8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e7cc:	e2833001 	add	r3, r3, #1
   1e7d0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e7d4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e7d8:	e3530007 	cmp	r3, #7
   1e7dc:	da00000a 	ble	1e80c <_vfprintf_r+0x2530>
   1e7e0:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e7e4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e7e8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e7ec:	e1a01002 	mov	r1, r2
   1e7f0:	e1a02003 	mov	r2, r3
   1e7f4:	eb00226d 	bl	271b0 <__sprint_r>
   1e7f8:	e1a03000 	mov	r3, r0
   1e7fc:	e3530000 	cmp	r3, #0
   1e800:	0a000000 	beq	1e808 <_vfprintf_r+0x252c>
   1e804:	ea00011f 	b	1ec88 <_vfprintf_r+0x29ac>
   1e808:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					cp++;
   1e80c:	e2877001 	add	r7, r7, #1
					PRINT (decimal_point, decp_len);
   1e810:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1e814:	e5843000 	str	r3, [r4]
   1e818:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1e81c:	e5843004 	str	r3, [r4, #4]
   1e820:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1e824:	e1a02003 	mov	r2, r3
   1e828:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1e82c:	e0823003 	add	r3, r2, r3
   1e830:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e834:	e2844008 	add	r4, r4, #8
   1e838:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e83c:	e2833001 	add	r3, r3, #1
   1e840:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e844:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e848:	e3530007 	cmp	r3, #7
   1e84c:	da00000a 	ble	1e87c <_vfprintf_r+0x25a0>
   1e850:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e854:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e858:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e85c:	e1a01002 	mov	r1, r2
   1e860:	e1a02003 	mov	r2, r3
   1e864:	eb002251 	bl	271b0 <__sprint_r>
   1e868:	e1a03000 	mov	r3, r0
   1e86c:	e3530000 	cmp	r3, #0
   1e870:	0a000000 	beq	1e878 <_vfprintf_r+0x259c>
   1e874:	ea000103 	b	1ec88 <_vfprintf_r+0x29ac>
   1e878:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					if (_fpvalue) {
   1e87c:	e24b3094 	sub	r3, fp, #148	; 0x94
   1e880:	e893000c 	ldm	r3, {r2, r3}
   1e884:	e1a00002 	mov	r0, r2
   1e888:	e1a01003 	mov	r1, r3
   1e88c:	e3a02000 	mov	r2, #0
   1e890:	e3a03000 	mov	r3, #0
   1e894:	ebffd9f3 	bl	15068 <__aeabi_dcmpeq>
   1e898:	e1a03000 	mov	r3, r0
   1e89c:	e3530000 	cmp	r3, #0
   1e8a0:	1a00001b 	bne	1e914 <_vfprintf_r+0x2638>
						PRINT (cp, ndig - 1);
   1e8a4:	e5847000 	str	r7, [r4]
   1e8a8:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1e8ac:	e2433001 	sub	r3, r3, #1
   1e8b0:	e5843004 	str	r3, [r4, #4]
   1e8b4:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1e8b8:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1e8bc:	e2433001 	sub	r3, r3, #1
   1e8c0:	e0823003 	add	r3, r2, r3
   1e8c4:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e8c8:	e2844008 	add	r4, r4, #8
   1e8cc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e8d0:	e2833001 	add	r3, r3, #1
   1e8d4:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e8d8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e8dc:	e3530007 	cmp	r3, #7
   1e8e0:	da000046 	ble	1ea00 <_vfprintf_r+0x2724>
   1e8e4:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e8e8:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e8ec:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e8f0:	e1a01002 	mov	r1, r2
   1e8f4:	e1a02003 	mov	r2, r3
   1e8f8:	eb00222c 	bl	271b0 <__sprint_r>
   1e8fc:	e1a03000 	mov	r3, r0
   1e900:	e3530000 	cmp	r3, #0
   1e904:	0a000000 	beq	1e90c <_vfprintf_r+0x2630>
   1e908:	ea0000de 	b	1ec88 <_vfprintf_r+0x29ac>
   1e90c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
					cp++;
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
   1e910:	ea000053 	b	1ea64 <_vfprintf_r+0x2788>
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
   1e914:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   1e918:	e2435001 	sub	r5, r3, #1
   1e91c:	e3550000 	cmp	r5, #0
   1e920:	da000036 	ble	1ea00 <_vfprintf_r+0x2724>
   1e924:	ea000019 	b	1e990 <_vfprintf_r+0x26b4>
   1e928:	e51f3d34 	ldr	r3, [pc, #-3380]	; 1dbfc <_vfprintf_r+0x1920>
   1e92c:	e5843000 	str	r3, [r4]
   1e930:	e3a03010 	mov	r3, #16
   1e934:	e5843004 	str	r3, [r4, #4]
   1e938:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1e93c:	e2833010 	add	r3, r3, #16
   1e940:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e944:	e2844008 	add	r4, r4, #8
   1e948:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e94c:	e2833001 	add	r3, r3, #1
   1e950:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e954:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e958:	e3530007 	cmp	r3, #7
   1e95c:	da00000a 	ble	1e98c <_vfprintf_r+0x26b0>
   1e960:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e964:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e968:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e96c:	e1a01002 	mov	r1, r2
   1e970:	e1a02003 	mov	r2, r3
   1e974:	eb00220d 	bl	271b0 <__sprint_r>
   1e978:	e1a03000 	mov	r3, r0
   1e97c:	e3530000 	cmp	r3, #0
   1e980:	0a000000 	beq	1e988 <_vfprintf_r+0x26ac>
   1e984:	ea0000bf 	b	1ec88 <_vfprintf_r+0x29ac>
   1e988:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1e98c:	e2455010 	sub	r5, r5, #16
   1e990:	e3550010 	cmp	r5, #16
   1e994:	caffffe3 	bgt	1e928 <_vfprintf_r+0x264c>
   1e998:	e51f3da4 	ldr	r3, [pc, #-3492]	; 1dbfc <_vfprintf_r+0x1920>
   1e99c:	e5843000 	str	r3, [r4]
   1e9a0:	e1a03005 	mov	r3, r5
   1e9a4:	e5843004 	str	r3, [r4, #4]
   1e9a8:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1e9ac:	e0833005 	add	r3, r3, r5
   1e9b0:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1e9b4:	e2844008 	add	r4, r4, #8
   1e9b8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e9bc:	e2833001 	add	r3, r3, #1
   1e9c0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1e9c4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1e9c8:	e3530007 	cmp	r3, #7
   1e9cc:	da00000b 	ble	1ea00 <_vfprintf_r+0x2724>
   1e9d0:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1e9d4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1e9d8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1e9dc:	e1a01002 	mov	r1, r2
   1e9e0:	e1a02003 	mov	r2, r3
   1e9e4:	eb0021f1 	bl	271b0 <__sprint_r>
   1e9e8:	e1a03000 	mov	r3, r0
   1e9ec:	e3530000 	cmp	r3, #0
   1e9f0:	0a000000 	beq	1e9f8 <_vfprintf_r+0x271c>
   1e9f4:	ea0000a3 	b	1ec88 <_vfprintf_r+0x29ac>
   1e9f8:	e24b40f0 	sub	r4, fp, #240	; 0xf0
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
					cp++;
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
   1e9fc:	ea000018 	b	1ea64 <_vfprintf_r+0x2788>
   1ea00:	ea000017 	b	1ea64 <_vfprintf_r+0x2788>
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
				} else	/* XeYYY */
					PRINT (cp, 1);
   1ea04:	e5847000 	str	r7, [r4]
   1ea08:	e3a03001 	mov	r3, #1
   1ea0c:	e5843004 	str	r3, [r4, #4]
   1ea10:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1ea14:	e2833001 	add	r3, r3, #1
   1ea18:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1ea1c:	e2844008 	add	r4, r4, #8
   1ea20:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1ea24:	e2833001 	add	r3, r3, #1
   1ea28:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1ea2c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1ea30:	e3530007 	cmp	r3, #7
   1ea34:	da00000a 	ble	1ea64 <_vfprintf_r+0x2788>
   1ea38:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1ea3c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1ea40:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ea44:	e1a01002 	mov	r1, r2
   1ea48:	e1a02003 	mov	r2, r3
   1ea4c:	eb0021d7 	bl	271b0 <__sprint_r>
   1ea50:	e1a03000 	mov	r3, r0
   1ea54:	e3530000 	cmp	r3, #0
   1ea58:	0a000000 	beq	1ea60 <_vfprintf_r+0x2784>
   1ea5c:	ea000089 	b	1ec88 <_vfprintf_r+0x29ac>
   1ea60:	e24b40f0 	sub	r4, fp, #240	; 0xf0
				PRINT (expstr, expsize);
   1ea64:	e24b30a0 	sub	r3, fp, #160	; 0xa0
   1ea68:	e5843000 	str	r3, [r4]
   1ea6c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1ea70:	e5843004 	str	r3, [r4, #4]
   1ea74:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1ea78:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1ea7c:	e0823003 	add	r3, r2, r3
   1ea80:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1ea84:	e2844008 	add	r4, r4, #8
   1ea88:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1ea8c:	e2833001 	add	r3, r3, #1
   1ea90:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1ea94:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1ea98:	e3530007 	cmp	r3, #7
   1ea9c:	da00000a 	ble	1eacc <_vfprintf_r+0x27f0>
   1eaa0:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1eaa4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1eaa8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1eaac:	e1a01002 	mov	r1, r2
   1eab0:	e1a02003 	mov	r2, r3
   1eab4:	eb0021bd 	bl	271b0 <__sprint_r>
   1eab8:	e1a03000 	mov	r3, r0
   1eabc:	e3530000 	cmp	r3, #0
   1eac0:	0a000000 	beq	1eac8 <_vfprintf_r+0x27ec>
   1eac4:	ea00006f 	b	1ec88 <_vfprintf_r+0x29ac>
   1eac8:	e24b40f0 	sub	r4, fp, #240	; 0xf0
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   1eacc:	e2063004 	and	r3, r6, #4
   1ead0:	e3530000 	cmp	r3, #0
   1ead4:	0a00003a 	beq	1ebc4 <_vfprintf_r+0x28e8>
			PAD (width - realsz, blanks);
   1ead8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1eadc:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   1eae0:	e0635002 	rsb	r5, r3, r2
   1eae4:	e3550000 	cmp	r5, #0
   1eae8:	da000035 	ble	1ebc4 <_vfprintf_r+0x28e8>
   1eaec:	ea000019 	b	1eb58 <_vfprintf_r+0x287c>
   1eaf0:	e51f3ef8 	ldr	r3, [pc, #-3832]	; 1dc00 <_vfprintf_r+0x1924>
   1eaf4:	e5843000 	str	r3, [r4]
   1eaf8:	e3a03010 	mov	r3, #16
   1eafc:	e5843004 	str	r3, [r4, #4]
   1eb00:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1eb04:	e2833010 	add	r3, r3, #16
   1eb08:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1eb0c:	e2844008 	add	r4, r4, #8
   1eb10:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1eb14:	e2833001 	add	r3, r3, #1
   1eb18:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1eb1c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1eb20:	e3530007 	cmp	r3, #7
   1eb24:	da00000a 	ble	1eb54 <_vfprintf_r+0x2878>
   1eb28:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1eb2c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1eb30:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1eb34:	e1a01002 	mov	r1, r2
   1eb38:	e1a02003 	mov	r2, r3
   1eb3c:	eb00219b 	bl	271b0 <__sprint_r>
   1eb40:	e1a03000 	mov	r3, r0
   1eb44:	e3530000 	cmp	r3, #0
   1eb48:	0a000000 	beq	1eb50 <_vfprintf_r+0x2874>
   1eb4c:	ea00004d 	b	1ec88 <_vfprintf_r+0x29ac>
   1eb50:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1eb54:	e2455010 	sub	r5, r5, #16
   1eb58:	e3550010 	cmp	r5, #16
   1eb5c:	caffffe3 	bgt	1eaf0 <_vfprintf_r+0x2814>
   1eb60:	e51f3f68 	ldr	r3, [pc, #-3944]	; 1dc00 <_vfprintf_r+0x1924>
   1eb64:	e5843000 	str	r3, [r4]
   1eb68:	e1a03005 	mov	r3, r5
   1eb6c:	e5843004 	str	r3, [r4, #4]
   1eb70:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1eb74:	e0833005 	add	r3, r3, r5
   1eb78:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1eb7c:	e2844008 	add	r4, r4, #8
   1eb80:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1eb84:	e2833001 	add	r3, r3, #1
   1eb88:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1eb8c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1eb90:	e3530007 	cmp	r3, #7
   1eb94:	da00000a 	ble	1ebc4 <_vfprintf_r+0x28e8>
   1eb98:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1eb9c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1eba0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1eba4:	e1a01002 	mov	r1, r2
   1eba8:	e1a02003 	mov	r2, r3
   1ebac:	eb00217f 	bl	271b0 <__sprint_r>
   1ebb0:	e1a03000 	mov	r3, r0
   1ebb4:	e3530000 	cmp	r3, #0
   1ebb8:	0a000000 	beq	1ebc0 <_vfprintf_r+0x28e4>
   1ebbc:	ea000031 	b	1ec88 <_vfprintf_r+0x29ac>
   1ebc0:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   1ebc4:	e51b2058 	ldr	r2, [fp, #-88]	; 0x58
   1ebc8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1ebcc:	e1520003 	cmp	r2, r3
   1ebd0:	a1a03002 	movge	r3, r2
   1ebd4:	b1a03003 	movlt	r3, r3
   1ebd8:	e51b2020 	ldr	r2, [fp, #-32]
   1ebdc:	e0823003 	add	r3, r2, r3
   1ebe0:	e50b3020 	str	r3, [fp, #-32]

		FLUSH ();	/* copy out the I/O vectors */
   1ebe4:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1ebe8:	e3530000 	cmp	r3, #0
   1ebec:	0a000009 	beq	1ec18 <_vfprintf_r+0x293c>
   1ebf0:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1ebf4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1ebf8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ebfc:	e1a01002 	mov	r1, r2
   1ec00:	e1a02003 	mov	r2, r3
   1ec04:	eb002169 	bl	271b0 <__sprint_r>
   1ec08:	e1a03000 	mov	r3, r0
   1ec0c:	e3530000 	cmp	r3, #0
   1ec10:	0a000000 	beq	1ec18 <_vfprintf_r+0x293c>
   1ec14:	ea00001b 	b	1ec88 <_vfprintf_r+0x29ac>
   1ec18:	e3a03000 	mov	r3, #0
   1ec1c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1ec20:	e24b40f0 	sub	r4, fp, #240	; 0xf0

                if (malloc_buf != NULL) {
   1ec24:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   1ec28:	e3530000 	cmp	r3, #0
   1ec2c:	0a000004 	beq	1ec44 <_vfprintf_r+0x2968>
			_free_r (data, malloc_buf);
   1ec30:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ec34:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
   1ec38:	ebffdf14 	bl	16890 <_free_r>
			malloc_buf = NULL;
   1ec3c:	e3a03000 	mov	r3, #0
   1ec40:	e50b3064 	str	r3, [fp, #-100]	; 0x64
		}
	}
   1ec44:	eafff64e 	b	1c584 <_vfprintf_r+0x2a8>
done:
	FLUSH ();
   1ec48:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1ec4c:	e3530000 	cmp	r3, #0
   1ec50:	0a000009 	beq	1ec7c <_vfprintf_r+0x29a0>
   1ec54:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1ec58:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1ec5c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ec60:	e1a01002 	mov	r1, r2
   1ec64:	e1a02003 	mov	r2, r3
   1ec68:	eb002150 	bl	271b0 <__sprint_r>
   1ec6c:	e1a03000 	mov	r3, r0
   1ec70:	e3530000 	cmp	r3, #0
   1ec74:	0a000000 	beq	1ec7c <_vfprintf_r+0x29a0>
   1ec78:	ea000002 	b	1ec88 <_vfprintf_r+0x29ac>
   1ec7c:	e3a03000 	mov	r3, #0
   1ec80:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1ec84:	e24b40f0 	sub	r4, fp, #240	; 0xf0
error:
	if (malloc_buf != NULL)
   1ec88:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   1ec8c:	e3530000 	cmp	r3, #0
   1ec90:	0a000002 	beq	1eca0 <_vfprintf_r+0x29c4>
		_free_r (data, malloc_buf);
   1ec94:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1ec98:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
   1ec9c:	ebffdefb 	bl	16890 <_free_r>
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
   1eca0:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1eca4:	e1d330bc 	ldrh	r3, [r3, #12]
   1eca8:	e1a03803 	lsl	r3, r3, #16
   1ecac:	e1a03823 	lsr	r3, r3, #16
   1ecb0:	e2033c02 	and	r3, r3, #512	; 0x200
   1ecb4:	e3530000 	cmp	r3, #0
   1ecb8:	1a000003 	bne	1eccc <_vfprintf_r+0x29f0>
   1ecbc:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1ecc0:	e283305c 	add	r3, r3, #92	; 0x5c
   1ecc4:	e1a00003 	mov	r0, r3
   1ecc8:	ebffe253 	bl	1761c <_dna_lock_release>
#endif
	return (__sferror (fp) ? EOF : ret);
   1eccc:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1ecd0:	e1d330bc 	ldrh	r3, [r3, #12]
   1ecd4:	e1a03803 	lsl	r3, r3, #16
   1ecd8:	e1a03823 	lsr	r3, r3, #16
   1ecdc:	e2033040 	and	r3, r3, #64	; 0x40
   1ece0:	e3530000 	cmp	r3, #0
   1ece4:	1a000001 	bne	1ecf0 <_vfprintf_r+0x2a14>
   1ece8:	e51b3020 	ldr	r3, [fp, #-32]
   1ecec:	ea000000 	b	1ecf4 <_vfprintf_r+0x2a18>
   1ecf0:	e3e03000 	mvn	r3, #0
   1ecf4:	e1a00000 	nop			; (mov r0, r0)
	/* NOTREACHED */
}
   1ecf8:	e1a00003 	mov	r0, r3
   1ecfc:	e24bd01c 	sub	sp, fp, #28
   1ed00:	e8bd4bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, lr}
   1ed04:	e12fff1e 	bx	lr

0001ed08 <cvt>:
   [aAeEfFgG]; if it is [aA], then the return string lives in BUF,
   otherwise the return value shares the mprec reentrant storage.  */
static char *
cvt(struct _reent *data, _PRINTF_FLOAT_TYPE value, int ndigits, int flags,
    char *sign, int *decpt, int ch, int *length, char *buf)
{
   1ed08:	e92d4810 	push	{r4, fp, lr}
   1ed0c:	e28db008 	add	fp, sp, #8
   1ed10:	e24dd04c 	sub	sp, sp, #76	; 0x4c
   1ed14:	e50b0030 	str	r0, [fp, #-48]	; 0x30
   1ed18:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
   1ed1c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	int mode, dsgn;
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
   1ed20:	e24b403c 	sub	r4, fp, #60	; 0x3c
   1ed24:	e8940018 	ldm	r4, {r3, r4}
   1ed28:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   1ed2c:	e50b4028 	str	r4, [fp, #-40]	; 0x28
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   1ed30:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1ed34:	e3530000 	cmp	r3, #0
   1ed38:	aa000008 	bge	1ed60 <cvt+0x58>
		value = -value;
   1ed3c:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1ed40:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   1ed44:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1ed48:	e2233102 	eor	r3, r3, #-2147483648	; 0x80000000
   1ed4c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
		*sign = '-';
   1ed50:	e59b300c 	ldr	r3, [fp, #12]
   1ed54:	e3a0202d 	mov	r2, #45	; 0x2d
   1ed58:	e5c32000 	strb	r2, [r3]
   1ed5c:	ea000002 	b	1ed6c <cvt+0x64>
	} else
		*sign = '\000';
   1ed60:	e59b300c 	ldr	r3, [fp, #12]
   1ed64:	e3a02000 	mov	r2, #0
   1ed68:	e5c32000 	strb	r2, [r3]
	} else
		*sign = '\000';
# endif /* !_NO_LONGDBL */

# ifdef _WANT_IO_C99_FORMATS
	if (ch == 'a' || ch == 'A') {
   1ed6c:	e59b3014 	ldr	r3, [fp, #20]
   1ed70:	e3530061 	cmp	r3, #97	; 0x61
   1ed74:	0a000002 	beq	1ed84 <cvt+0x7c>
   1ed78:	e59b3014 	ldr	r3, [fp, #20]
   1ed7c:	e3530041 	cmp	r3, #65	; 0x41
   1ed80:	1a000096 	bne	1efe0 <cvt+0x2d8>
		/* This code assumes FLT_RADIX is a power of 2.  The initial
		   division ensures the digit before the decimal will be less
		   than FLT_RADIX (unless it is rounded later).	 There is no
		   loss of precision in these calculations.  */
		value = FREXP (value, decpt) / 8;
   1ed84:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1ed88:	e8910003 	ldm	r1, {r0, r1}
   1ed8c:	e59b2010 	ldr	r2, [fp, #16]
   1ed90:	eb0019ce 	bl	254d0 <frexp>
   1ed94:	e1a03000 	mov	r3, r0
   1ed98:	e1a04001 	mov	r4, r1
   1ed9c:	e1a00003 	mov	r0, r3
   1eda0:	e1a01004 	mov	r1, r4
   1eda4:	e3a02000 	mov	r2, #0
   1eda8:	e59f33dc 	ldr	r3, [pc, #988]	; 1f18c <cvt+0x484>
   1edac:	ebffd7f7 	bl	14d90 <__aeabi_ddiv>
   1edb0:	e1a03000 	mov	r3, r0
   1edb4:	e1a04001 	mov	r4, r1
   1edb8:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   1edbc:	e50b4038 	str	r4, [fp, #-56]	; 0x38
		if (!value)
   1edc0:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1edc4:	e8910003 	ldm	r1, {r0, r1}
   1edc8:	e3a02000 	mov	r2, #0
   1edcc:	e3a03000 	mov	r3, #0
   1edd0:	ebffd8a4 	bl	15068 <__aeabi_dcmpeq>
   1edd4:	e1a03000 	mov	r3, r0
   1edd8:	e3530000 	cmp	r3, #0
   1eddc:	0a000002 	beq	1edec <cvt+0xe4>
			*decpt = 1;
   1ede0:	e59b3010 	ldr	r3, [fp, #16]
   1ede4:	e3a02001 	mov	r2, #1
   1ede8:	e5832000 	str	r2, [r3]
		digits = ch == 'a' ? "0123456789abcdef" : "0123456789ABCDEF";
   1edec:	e59b3014 	ldr	r3, [fp, #20]
   1edf0:	e3530061 	cmp	r3, #97	; 0x61
   1edf4:	1a000001 	bne	1ee00 <cvt+0xf8>
   1edf8:	e59f3390 	ldr	r3, [pc, #912]	; 1f190 <cvt+0x488>
   1edfc:	ea000000 	b	1ee04 <cvt+0xfc>
   1ee00:	e59f338c 	ldr	r3, [pc, #908]	; 1f194 <cvt+0x48c>
   1ee04:	e50b3018 	str	r3, [fp, #-24]
		bp = buf;
   1ee08:	e59b301c 	ldr	r3, [fp, #28]
   1ee0c:	e50b3014 	str	r3, [fp, #-20]
		do {
			value *= 16;
   1ee10:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1ee14:	e8910003 	ldm	r1, {r0, r1}
   1ee18:	e3a02000 	mov	r2, #0
   1ee1c:	e59f3374 	ldr	r3, [pc, #884]	; 1f198 <cvt+0x490>
   1ee20:	ebffd736 	bl	14b00 <__aeabi_dmul>
   1ee24:	e1a03000 	mov	r3, r0
   1ee28:	e1a04001 	mov	r4, r1
   1ee2c:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   1ee30:	e50b4038 	str	r4, [fp, #-56]	; 0x38
			mode = (int) value;
   1ee34:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1ee38:	e8910003 	ldm	r1, {r0, r1}
   1ee3c:	ebffd8a7 	bl	150e0 <__aeabi_d2iz>
   1ee40:	e1a03000 	mov	r3, r0
   1ee44:	e50b3010 	str	r3, [fp, #-16]
			value -= mode;
   1ee48:	e51b0010 	ldr	r0, [fp, #-16]
   1ee4c:	ebffd6f4 	bl	14a24 <__aeabi_i2d>
   1ee50:	e1a03000 	mov	r3, r0
   1ee54:	e1a04001 	mov	r4, r1
   1ee58:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1ee5c:	e8910003 	ldm	r1, {r0, r1}
   1ee60:	e1a02003 	mov	r2, r3
   1ee64:	e1a03004 	mov	r3, r4
   1ee68:	ebffd61f 	bl	146ec <__aeabi_dsub>
   1ee6c:	e1a03000 	mov	r3, r0
   1ee70:	e1a04001 	mov	r4, r1
   1ee74:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   1ee78:	e50b4038 	str	r4, [fp, #-56]	; 0x38
			*bp++ = digits[mode];
   1ee7c:	e51b3014 	ldr	r3, [fp, #-20]
   1ee80:	e2832001 	add	r2, r3, #1
   1ee84:	e50b2014 	str	r2, [fp, #-20]
   1ee88:	e51b2010 	ldr	r2, [fp, #-16]
   1ee8c:	e51b1018 	ldr	r1, [fp, #-24]
   1ee90:	e0812002 	add	r2, r1, r2
   1ee94:	e5d22000 	ldrb	r2, [r2]
   1ee98:	e5c32000 	strb	r2, [r3]
		} while (ndigits-- && value);
   1ee9c:	e59b3004 	ldr	r3, [fp, #4]
   1eea0:	e2432001 	sub	r2, r3, #1
   1eea4:	e58b2004 	str	r2, [fp, #4]
   1eea8:	e3530000 	cmp	r3, #0
   1eeac:	0a000007 	beq	1eed0 <cvt+0x1c8>
   1eeb0:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1eeb4:	e8910003 	ldm	r1, {r0, r1}
   1eeb8:	e3a02000 	mov	r2, #0
   1eebc:	e3a03000 	mov	r3, #0
   1eec0:	ebffd868 	bl	15068 <__aeabi_dcmpeq>
   1eec4:	e1a03000 	mov	r3, r0
   1eec8:	e3530000 	cmp	r3, #0
   1eecc:	0affffcf 	beq	1ee10 <cvt+0x108>
		if (value > 0.5 || (value == 0.5 && mode & 1)) {
   1eed0:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1eed4:	e8910003 	ldm	r1, {r0, r1}
   1eed8:	e3a02000 	mov	r2, #0
   1eedc:	e59f32b8 	ldr	r3, [pc, #696]	; 1f19c <cvt+0x494>
   1eee0:	ebffd878 	bl	150c8 <__aeabi_dcmpgt>
   1eee4:	e1a03000 	mov	r3, r0
   1eee8:	e3530000 	cmp	r3, #0
   1eeec:	1a00000b 	bne	1ef20 <cvt+0x218>
   1eef0:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1eef4:	e8910003 	ldm	r1, {r0, r1}
   1eef8:	e3a02000 	mov	r2, #0
   1eefc:	e59f3298 	ldr	r3, [pc, #664]	; 1f19c <cvt+0x494>
   1ef00:	ebffd858 	bl	15068 <__aeabi_dcmpeq>
   1ef04:	e1a03000 	mov	r3, r0
   1ef08:	e3530000 	cmp	r3, #0
   1ef0c:	0a000021 	beq	1ef98 <cvt+0x290>
   1ef10:	e51b3010 	ldr	r3, [fp, #-16]
   1ef14:	e2033001 	and	r3, r3, #1
   1ef18:	e3530000 	cmp	r3, #0
   1ef1c:	0a00001d 	beq	1ef98 <cvt+0x290>
			/* round to even */
			rve = bp;
   1ef20:	e51b3014 	ldr	r3, [fp, #-20]
   1ef24:	e50b3020 	str	r3, [fp, #-32]
			while (*--rve == digits[0xf]) {
   1ef28:	ea000002 	b	1ef38 <cvt+0x230>
				*rve = '0';
   1ef2c:	e51b3020 	ldr	r3, [fp, #-32]
   1ef30:	e3a02030 	mov	r2, #48	; 0x30
   1ef34:	e5c32000 	strb	r2, [r3]
			*bp++ = digits[mode];
		} while (ndigits-- && value);
		if (value > 0.5 || (value == 0.5 && mode & 1)) {
			/* round to even */
			rve = bp;
			while (*--rve == digits[0xf]) {
   1ef38:	e51b3020 	ldr	r3, [fp, #-32]
   1ef3c:	e2433001 	sub	r3, r3, #1
   1ef40:	e50b3020 	str	r3, [fp, #-32]
   1ef44:	e51b3020 	ldr	r3, [fp, #-32]
   1ef48:	e5d32000 	ldrb	r2, [r3]
   1ef4c:	e51b3018 	ldr	r3, [fp, #-24]
   1ef50:	e283300f 	add	r3, r3, #15
   1ef54:	e5d33000 	ldrb	r3, [r3]
   1ef58:	e1520003 	cmp	r2, r3
   1ef5c:	0afffff2 	beq	1ef2c <cvt+0x224>
				*rve = '0';
			}
			*rve = *rve == '9' ? digits[0xa] : *rve + 1;
   1ef60:	e51b2020 	ldr	r2, [fp, #-32]
   1ef64:	e51b3020 	ldr	r3, [fp, #-32]
   1ef68:	e5d33000 	ldrb	r3, [r3]
   1ef6c:	e3530039 	cmp	r3, #57	; 0x39
   1ef70:	1a000002 	bne	1ef80 <cvt+0x278>
   1ef74:	e51b3018 	ldr	r3, [fp, #-24]
   1ef78:	e5d3300a 	ldrb	r3, [r3, #10]
   1ef7c:	ea000003 	b	1ef90 <cvt+0x288>
   1ef80:	e51b3020 	ldr	r3, [fp, #-32]
   1ef84:	e5d33000 	ldrb	r3, [r3]
   1ef88:	e2833001 	add	r3, r3, #1
   1ef8c:	e20330ff 	and	r3, r3, #255	; 0xff
   1ef90:	e5c23000 	strb	r3, [r2]
   1ef94:	ea00000a 	b	1efc4 <cvt+0x2bc>
		} else {
			while (ndigits-- >= 0) {
   1ef98:	ea000004 	b	1efb0 <cvt+0x2a8>
				*bp++ = '0';
   1ef9c:	e51b3014 	ldr	r3, [fp, #-20]
   1efa0:	e2832001 	add	r2, r3, #1
   1efa4:	e50b2014 	str	r2, [fp, #-20]
   1efa8:	e3a02030 	mov	r2, #48	; 0x30
   1efac:	e5c32000 	strb	r2, [r3]
			while (*--rve == digits[0xf]) {
				*rve = '0';
			}
			*rve = *rve == '9' ? digits[0xa] : *rve + 1;
		} else {
			while (ndigits-- >= 0) {
   1efb0:	e59b3004 	ldr	r3, [fp, #4]
   1efb4:	e2432001 	sub	r2, r3, #1
   1efb8:	e58b2004 	str	r2, [fp, #4]
   1efbc:	e3530000 	cmp	r3, #0
   1efc0:	aafffff5 	bge	1ef9c <cvt+0x294>
				*bp++ = '0';
			}
		}
		*length = bp - buf;
   1efc4:	e51b2014 	ldr	r2, [fp, #-20]
   1efc8:	e59b301c 	ldr	r3, [fp, #28]
   1efcc:	e0632002 	rsb	r2, r3, r2
   1efd0:	e59b3018 	ldr	r3, [fp, #24]
   1efd4:	e5832000 	str	r2, [r3]
		return buf;
   1efd8:	e59b301c 	ldr	r3, [fp, #28]
   1efdc:	ea000066 	b	1f17c <cvt+0x474>
	}
# endif /* _WANT_IO_C99_FORMATS */
	if (ch == 'f' || ch == 'F') {
   1efe0:	e59b3014 	ldr	r3, [fp, #20]
   1efe4:	e3530066 	cmp	r3, #102	; 0x66
   1efe8:	0a000002 	beq	1eff8 <cvt+0x2f0>
   1efec:	e59b3014 	ldr	r3, [fp, #20]
   1eff0:	e3530046 	cmp	r3, #70	; 0x46
   1eff4:	1a000002 	bne	1f004 <cvt+0x2fc>
		mode = 3;		/* ndigits after the decimal point */
   1eff8:	e3a03003 	mov	r3, #3
   1effc:	e50b3010 	str	r3, [fp, #-16]
   1f000:	ea00000a 	b	1f030 <cvt+0x328>
	} else {
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
   1f004:	e59b3014 	ldr	r3, [fp, #20]
   1f008:	e3530065 	cmp	r3, #101	; 0x65
   1f00c:	0a000002 	beq	1f01c <cvt+0x314>
   1f010:	e59b3014 	ldr	r3, [fp, #20]
   1f014:	e3530045 	cmp	r3, #69	; 0x45
   1f018:	1a000002 	bne	1f028 <cvt+0x320>
			ndigits++;
   1f01c:	e59b3004 	ldr	r3, [fp, #4]
   1f020:	e2833001 	add	r3, r3, #1
   1f024:	e58b3004 	str	r3, [fp, #4]
		}
		mode = 2;		/* ndigits significant digits */
   1f028:	e3a03002 	mov	r3, #2
   1f02c:	e50b3010 	str	r3, [fp, #-16]
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   1f030:	e51b3010 	ldr	r3, [fp, #-16]
   1f034:	e58d3000 	str	r3, [sp]
   1f038:	e59b3004 	ldr	r3, [fp, #4]
   1f03c:	e58d3004 	str	r3, [sp, #4]
   1f040:	e59b3010 	ldr	r3, [fp, #16]
   1f044:	e58d3008 	str	r3, [sp, #8]
   1f048:	e24b301c 	sub	r3, fp, #28
   1f04c:	e58d300c 	str	r3, [sp, #12]
   1f050:	e24b3020 	sub	r3, fp, #32
   1f054:	e58d3010 	str	r3, [sp, #16]
   1f058:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   1f05c:	e24b303c 	sub	r3, fp, #60	; 0x3c
   1f060:	e893000c 	ldm	r3, {r2, r3}
   1f064:	eb000319 	bl	1fcd0 <_dtoa_r>
   1f068:	e50b0018 	str	r0, [fp, #-24]

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   1f06c:	e59b3014 	ldr	r3, [fp, #20]
   1f070:	e3530067 	cmp	r3, #103	; 0x67
   1f074:	0a000002 	beq	1f084 <cvt+0x37c>
   1f078:	e59b3014 	ldr	r3, [fp, #20]
   1f07c:	e3530047 	cmp	r3, #71	; 0x47
   1f080:	1a000003 	bne	1f094 <cvt+0x38c>
   1f084:	e59b3008 	ldr	r3, [fp, #8]
   1f088:	e2033001 	and	r3, r3, #1
   1f08c:	e3530000 	cmp	r3, #0
   1f090:	0a000032 	beq	1f160 <cvt+0x458>
		bp = digits + ndigits;
   1f094:	e59b3004 	ldr	r3, [fp, #4]
   1f098:	e51b2018 	ldr	r2, [fp, #-24]
   1f09c:	e0823003 	add	r3, r2, r3
   1f0a0:	e50b3014 	str	r3, [fp, #-20]
		if (ch == 'f' || ch == 'F') {
   1f0a4:	e59b3014 	ldr	r3, [fp, #20]
   1f0a8:	e3530066 	cmp	r3, #102	; 0x66
   1f0ac:	0a000002 	beq	1f0bc <cvt+0x3b4>
   1f0b0:	e59b3014 	ldr	r3, [fp, #20]
   1f0b4:	e3530046 	cmp	r3, #70	; 0x46
   1f0b8:	1a000014 	bne	1f110 <cvt+0x408>
			if (*digits == '0' && value)
   1f0bc:	e51b3018 	ldr	r3, [fp, #-24]
   1f0c0:	e5d33000 	ldrb	r3, [r3]
   1f0c4:	e3530030 	cmp	r3, #48	; 0x30
   1f0c8:	1a00000b 	bne	1f0fc <cvt+0x3f4>
   1f0cc:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1f0d0:	e8910003 	ldm	r1, {r0, r1}
   1f0d4:	e3a02000 	mov	r2, #0
   1f0d8:	e3a03000 	mov	r3, #0
   1f0dc:	ebffd7e1 	bl	15068 <__aeabi_dcmpeq>
   1f0e0:	e1a03000 	mov	r3, r0
   1f0e4:	e3530000 	cmp	r3, #0
   1f0e8:	1a000003 	bne	1f0fc <cvt+0x3f4>
				*decpt = -ndigits + 1;
   1f0ec:	e59b3004 	ldr	r3, [fp, #4]
   1f0f0:	e2632001 	rsb	r2, r3, #1
   1f0f4:	e59b3010 	ldr	r3, [fp, #16]
   1f0f8:	e5832000 	str	r2, [r3]
			bp += *decpt;
   1f0fc:	e59b3010 	ldr	r3, [fp, #16]
   1f100:	e5933000 	ldr	r3, [r3]
   1f104:	e51b2014 	ldr	r2, [fp, #-20]
   1f108:	e0823003 	add	r3, r2, r3
   1f10c:	e50b3014 	str	r3, [fp, #-20]
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
   1f110:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1f114:	e8910003 	ldm	r1, {r0, r1}
   1f118:	e3a02000 	mov	r2, #0
   1f11c:	e3a03000 	mov	r3, #0
   1f120:	ebffd7d0 	bl	15068 <__aeabi_dcmpeq>
   1f124:	e1a03000 	mov	r3, r0
   1f128:	e3530000 	cmp	r3, #0
   1f12c:	0a000001 	beq	1f138 <cvt+0x430>
			rve = bp;
   1f130:	e51b3014 	ldr	r3, [fp, #-20]
   1f134:	e50b3020 	str	r3, [fp, #-32]
		while (rve < bp)
   1f138:	ea000004 	b	1f150 <cvt+0x448>
			*rve++ = '0';
   1f13c:	e51b3020 	ldr	r3, [fp, #-32]
   1f140:	e2832001 	add	r2, r3, #1
   1f144:	e50b2020 	str	r2, [fp, #-32]
   1f148:	e3a02030 	mov	r2, #48	; 0x30
   1f14c:	e5c32000 	strb	r2, [r3]
				*decpt = -ndigits + 1;
			bp += *decpt;
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
   1f150:	e51b2020 	ldr	r2, [fp, #-32]
   1f154:	e51b3014 	ldr	r3, [fp, #-20]
   1f158:	e1520003 	cmp	r2, r3
   1f15c:	3afffff6 	bcc	1f13c <cvt+0x434>
			*rve++ = '0';
	}
	*length = rve - digits;
   1f160:	e51b3020 	ldr	r3, [fp, #-32]
   1f164:	e1a02003 	mov	r2, r3
   1f168:	e51b3018 	ldr	r3, [fp, #-24]
   1f16c:	e0632002 	rsb	r2, r3, r2
   1f170:	e59b3018 	ldr	r3, [fp, #24]
   1f174:	e5832000 	str	r2, [r3]
	return (digits);
   1f178:	e51b3018 	ldr	r3, [fp, #-24]
}
   1f17c:	e1a00003 	mov	r0, r3
   1f180:	e24bd008 	sub	sp, fp, #8
   1f184:	e8bd4810 	pop	{r4, fp, lr}
   1f188:	e12fff1e 	bx	lr
   1f18c:	40200000 	.word	0x40200000
   1f190:	000330ec 	.word	0x000330ec
   1f194:	00033108 	.word	0x00033108
   1f198:	40300000 	.word	0x40300000
   1f19c:	3fe00000 	.word	0x3fe00000

0001f1a0 <exponent>:

static int
exponent(char *p0, int exp, int fmtch)
{
   1f1a0:	e92d0830 	push	{r4, r5, fp}
   1f1a4:	e28db008 	add	fp, sp, #8
   1f1a8:	e24dd024 	sub	sp, sp, #36	; 0x24
   1f1ac:	e50b0020 	str	r0, [fp, #-32]
   1f1b0:	e50b1024 	str	r1, [fp, #-36]	; 0x24
   1f1b4:	e50b2028 	str	r2, [fp, #-40]	; 0x28
	register char *p, *t;
	char expbuf[MAXEXPLEN];
# ifdef _WANT_IO_C99_FORMATS
	int isa = fmtch == 'a' || fmtch == 'A';
   1f1b8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1f1bc:	e3530061 	cmp	r3, #97	; 0x61
   1f1c0:	0a000002 	beq	1f1d0 <exponent+0x30>
   1f1c4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1f1c8:	e3530041 	cmp	r3, #65	; 0x41
   1f1cc:	1a000001 	bne	1f1d8 <exponent+0x38>
   1f1d0:	e3a03001 	mov	r3, #1
   1f1d4:	ea000000 	b	1f1dc <exponent+0x3c>
   1f1d8:	e3a03000 	mov	r3, #0
   1f1dc:	e50b3010 	str	r3, [fp, #-16]
# else
#  define isa 0
# endif

	p = p0;
   1f1e0:	e51b4020 	ldr	r4, [fp, #-32]
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   1f1e4:	e1a03004 	mov	r3, r4
   1f1e8:	e2834001 	add	r4, r3, #1
   1f1ec:	e51b2010 	ldr	r2, [fp, #-16]
   1f1f0:	e3520000 	cmp	r2, #0
   1f1f4:	0a000004 	beq	1f20c <exponent+0x6c>
   1f1f8:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   1f1fc:	e20220ff 	and	r2, r2, #255	; 0xff
   1f200:	e282200f 	add	r2, r2, #15
   1f204:	e20220ff 	and	r2, r2, #255	; 0xff
   1f208:	ea000001 	b	1f214 <exponent+0x74>
   1f20c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   1f210:	e20220ff 	and	r2, r2, #255	; 0xff
   1f214:	e5c32000 	strb	r2, [r3]
	if (exp < 0) {
   1f218:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1f21c:	e3530000 	cmp	r3, #0
   1f220:	aa000007 	bge	1f244 <exponent+0xa4>
		exp = -exp;
   1f224:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1f228:	e2633000 	rsb	r3, r3, #0
   1f22c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		*p++ = '-';
   1f230:	e1a03004 	mov	r3, r4
   1f234:	e2834001 	add	r4, r3, #1
   1f238:	e3a0202d 	mov	r2, #45	; 0x2d
   1f23c:	e5c32000 	strb	r2, [r3]
   1f240:	ea000003 	b	1f254 <exponent+0xb4>
	}
	else
		*p++ = '+';
   1f244:	e1a03004 	mov	r3, r4
   1f248:	e2834001 	add	r4, r3, #1
   1f24c:	e3a0202b 	mov	r2, #43	; 0x2b
   1f250:	e5c32000 	strb	r2, [r3]
	t = expbuf + MAXEXPLEN;
   1f254:	e24b5018 	sub	r5, fp, #24
   1f258:	e2855007 	add	r5, r5, #7
	if (exp > 9) {
   1f25c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1f260:	e3530009 	cmp	r3, #9
   1f264:	da00002b 	ble	1f318 <exponent+0x178>
		do {
			*--t = to_char (exp % 10);
   1f268:	e2455001 	sub	r5, r5, #1
   1f26c:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
   1f270:	e59f30f4 	ldr	r3, [pc, #244]	; 1f36c <exponent+0x1cc>
   1f274:	e0c32391 	smull	r2, r3, r1, r3
   1f278:	e1a02143 	asr	r2, r3, #2
   1f27c:	e1a03fc1 	asr	r3, r1, #31
   1f280:	e0632002 	rsb	r2, r3, r2
   1f284:	e1a03002 	mov	r3, r2
   1f288:	e1a03103 	lsl	r3, r3, #2
   1f28c:	e0833002 	add	r3, r3, r2
   1f290:	e1a03083 	lsl	r3, r3, #1
   1f294:	e0632001 	rsb	r2, r3, r1
   1f298:	e20230ff 	and	r3, r2, #255	; 0xff
   1f29c:	e2833030 	add	r3, r3, #48	; 0x30
   1f2a0:	e20330ff 	and	r3, r3, #255	; 0xff
   1f2a4:	e5c53000 	strb	r3, [r5]
		} while ((exp /= 10) > 9);
   1f2a8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1f2ac:	e59f20b8 	ldr	r2, [pc, #184]	; 1f36c <exponent+0x1cc>
   1f2b0:	e0c21293 	smull	r1, r2, r3, r2
   1f2b4:	e1a02142 	asr	r2, r2, #2
   1f2b8:	e1a03fc3 	asr	r3, r3, #31
   1f2bc:	e0633002 	rsb	r3, r3, r2
   1f2c0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   1f2c4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1f2c8:	e3530009 	cmp	r3, #9
   1f2cc:	caffffe5 	bgt	1f268 <exponent+0xc8>
		*--t = to_char (exp);
   1f2d0:	e2455001 	sub	r5, r5, #1
   1f2d4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1f2d8:	e20330ff 	and	r3, r3, #255	; 0xff
   1f2dc:	e2833030 	add	r3, r3, #48	; 0x30
   1f2e0:	e20330ff 	and	r3, r3, #255	; 0xff
   1f2e4:	e5c53000 	strb	r3, [r5]
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
   1f2e8:	ea000005 	b	1f304 <exponent+0x164>
   1f2ec:	e1a03004 	mov	r3, r4
   1f2f0:	e2834001 	add	r4, r3, #1
   1f2f4:	e1a02005 	mov	r2, r5
   1f2f8:	e2825001 	add	r5, r2, #1
   1f2fc:	e5d22000 	ldrb	r2, [r2]
   1f300:	e5c32000 	strb	r2, [r3]
   1f304:	e24b3018 	sub	r3, fp, #24
   1f308:	e2833007 	add	r3, r3, #7
   1f30c:	e1550003 	cmp	r5, r3
   1f310:	3afffff5 	bcc	1f2ec <exponent+0x14c>
   1f314:	ea00000d 	b	1f350 <exponent+0x1b0>
	}
	else {
		if (!isa)
   1f318:	e51b3010 	ldr	r3, [fp, #-16]
   1f31c:	e3530000 	cmp	r3, #0
   1f320:	1a000003 	bne	1f334 <exponent+0x194>
			*p++ = '0';
   1f324:	e1a03004 	mov	r3, r4
   1f328:	e2834001 	add	r4, r3, #1
   1f32c:	e3a02030 	mov	r2, #48	; 0x30
   1f330:	e5c32000 	strb	r2, [r3]
		*p++ = to_char (exp);
   1f334:	e1a03004 	mov	r3, r4
   1f338:	e2834001 	add	r4, r3, #1
   1f33c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1f340:	e20220ff 	and	r2, r2, #255	; 0xff
   1f344:	e2822030 	add	r2, r2, #48	; 0x30
   1f348:	e20220ff 	and	r2, r2, #255	; 0xff
   1f34c:	e5c32000 	strb	r2, [r3]
	}
	return (p - p0);
   1f350:	e1a02004 	mov	r2, r4
   1f354:	e51b3020 	ldr	r3, [fp, #-32]
   1f358:	e0633002 	rsb	r3, r3, r2
}
   1f35c:	e1a00003 	mov	r0, r3
   1f360:	e24bd008 	sub	sp, fp, #8
   1f364:	e8bd0830 	pop	{r4, r5, fp}
   1f368:	e12fff1e 	bx	lr
   1f36c:	66666667 	.word	0x66666667

0001f370 <write>:
int
_DEFUN (_write, (file, ptr, len),
        int   file  _AND
        char *ptr   _AND
        int   len)
{
   1f370:	e92d4800 	push	{fp, lr}
   1f374:	e28db004 	add	fp, sp, #4
   1f378:	e24dd018 	sub	sp, sp, #24
   1f37c:	e50b0010 	str	r0, [fp, #-16]
   1f380:	e50b1014 	str	r1, [fp, #-20]
   1f384:	e50b2018 	str	r2, [fp, #-24]
	status_t status = DNA_OK;
   1f388:	e3a03000 	mov	r3, #0
   1f38c:	e14b30b6 	strh	r3, [fp, #-6]
	int32_t res = -1;
   1f390:	e3e03000 	mvn	r3, #0
   1f394:	e50b300c 	str	r3, [fp, #-12]

	status = vfs_write (file, ptr, len, & res);
   1f398:	e51b3010 	ldr	r3, [fp, #-16]
   1f39c:	e1a03803 	lsl	r3, r3, #16
   1f3a0:	e1a03823 	lsr	r3, r3, #16
   1f3a4:	e1a03803 	lsl	r3, r3, #16
   1f3a8:	e1a02843 	asr	r2, r3, #16
   1f3ac:	e24b300c 	sub	r3, fp, #12
   1f3b0:	e1a00002 	mov	r0, r2
   1f3b4:	e51b1014 	ldr	r1, [fp, #-20]
   1f3b8:	e51b2018 	ldr	r2, [fp, #-24]
   1f3bc:	ebffbca3 	bl	e650 <vfs_write>
   1f3c0:	e1a03000 	mov	r3, r0
   1f3c4:	e14b30b6 	strh	r3, [fp, #-6]
	return res;
   1f3c8:	e51b300c 	ldr	r3, [fp, #-12]
}
   1f3cc:	e1a00003 	mov	r0, r3
   1f3d0:	e24bd004 	sub	sp, fp, #4
   1f3d4:	e8bd4800 	pop	{fp, lr}
   1f3d8:	e12fff1e 	bx	lr

0001f3dc <_write_r>:
_DEFUN (_write_r, (ptr, fd, buf, cnt),
     struct _reent *ptr _AND
     int fd _AND
     _CONST _PTR buf _AND
     size_t cnt)
{
   1f3dc:	e92d4800 	push	{fp, lr}
   1f3e0:	e28db004 	add	fp, sp, #4
   1f3e4:	e24dd018 	sub	sp, sp, #24
   1f3e8:	e50b0010 	str	r0, [fp, #-16]
   1f3ec:	e50b1014 	str	r1, [fp, #-20]
   1f3f0:	e50b2018 	str	r2, [fp, #-24]
   1f3f4:	e50b301c 	str	r3, [fp, #-28]
  _ssize_t ret;

  errno = 0;
   1f3f8:	e59f3058 	ldr	r3, [pc, #88]	; 1f458 <_write_r+0x7c>
   1f3fc:	e3a02000 	mov	r2, #0
   1f400:	e5832000 	str	r2, [r3]
  if ((ret = (_ssize_t)_write (fd, buf, cnt)) == -1 && errno != 0)
   1f404:	e51b0014 	ldr	r0, [fp, #-20]
   1f408:	e51b1018 	ldr	r1, [fp, #-24]
   1f40c:	e51b201c 	ldr	r2, [fp, #-28]
   1f410:	ebffffd6 	bl	1f370 <write>
   1f414:	e50b0008 	str	r0, [fp, #-8]
   1f418:	e51b3008 	ldr	r3, [fp, #-8]
   1f41c:	e3730001 	cmn	r3, #1
   1f420:	1a000007 	bne	1f444 <_write_r+0x68>
   1f424:	e59f302c 	ldr	r3, [pc, #44]	; 1f458 <_write_r+0x7c>
   1f428:	e5933000 	ldr	r3, [r3]
   1f42c:	e3530000 	cmp	r3, #0
   1f430:	0a000003 	beq	1f444 <_write_r+0x68>
    ptr->_errno = errno;
   1f434:	e59f301c 	ldr	r3, [pc, #28]	; 1f458 <_write_r+0x7c>
   1f438:	e5932000 	ldr	r2, [r3]
   1f43c:	e51b3010 	ldr	r3, [fp, #-16]
   1f440:	e5832000 	str	r2, [r3]
  return ret;
   1f444:	e51b3008 	ldr	r3, [fp, #-8]
}
   1f448:	e1a00003 	mov	r0, r3
   1f44c:	e24bd004 	sub	sp, fp, #4
   1f450:	e8bd4800 	pop	{fp, lr}
   1f454:	e12fff1e 	bx	lr
   1f458:	0018b940 	.word	0x0018b940

0001f45c <__swsetup_r>:

int
_DEFUN(__swsetup_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   1f45c:	e92d4810 	push	{r4, fp, lr}
   1f460:	e28db008 	add	fp, sp, #8
   1f464:	e24dd014 	sub	sp, sp, #20
   1f468:	e50b0018 	str	r0, [fp, #-24]
   1f46c:	e1a04001 	mov	r4, r1
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   1f470:	e59f31f8 	ldr	r3, [pc, #504]	; 1f670 <__swsetup_r+0x214>
   1f474:	e5933000 	ldr	r3, [r3]
   1f478:	e50b3010 	str	r3, [fp, #-16]
   1f47c:	e51b3010 	ldr	r3, [fp, #-16]
   1f480:	e3530000 	cmp	r3, #0
   1f484:	0a000005 	beq	1f4a0 <__swsetup_r+0x44>
   1f488:	e51b3010 	ldr	r3, [fp, #-16]
   1f48c:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   1f490:	e3530000 	cmp	r3, #0
   1f494:	1a000001 	bne	1f4a0 <__swsetup_r+0x44>
   1f498:	e51b0010 	ldr	r0, [fp, #-16]
   1f49c:	ebffdc3a 	bl	1658c <__sinit>

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
   1f4a0:	e1d430bc 	ldrh	r3, [r4, #12]
   1f4a4:	e1a03803 	lsl	r3, r3, #16
   1f4a8:	e1a03823 	lsr	r3, r3, #16
   1f4ac:	e2033008 	and	r3, r3, #8
   1f4b0:	e3530000 	cmp	r3, #0
   1f4b4:	1a000030 	bne	1f57c <__swsetup_r+0x120>
    {
      if ((fp->_flags & __SRW) == 0)
   1f4b8:	e1d430bc 	ldrh	r3, [r4, #12]
   1f4bc:	e1a03803 	lsl	r3, r3, #16
   1f4c0:	e1a03823 	lsr	r3, r3, #16
   1f4c4:	e2033010 	and	r3, r3, #16
   1f4c8:	e3530000 	cmp	r3, #0
   1f4cc:	1a000009 	bne	1f4f8 <__swsetup_r+0x9c>
        {
	  ptr->_errno = EBADF;
   1f4d0:	e51b3018 	ldr	r3, [fp, #-24]
   1f4d4:	e3a02009 	mov	r2, #9
   1f4d8:	e5832000 	str	r2, [r3]
	  fp->_flags |= __SERR;
   1f4dc:	e1d430bc 	ldrh	r3, [r4, #12]
   1f4e0:	e3833040 	orr	r3, r3, #64	; 0x40
   1f4e4:	e1a03803 	lsl	r3, r3, #16
   1f4e8:	e1a03823 	lsr	r3, r3, #16
   1f4ec:	e1c430bc 	strh	r3, [r4, #12]
	  return EOF;
   1f4f0:	e3e03000 	mvn	r3, #0
   1f4f4:	ea000059 	b	1f660 <__swsetup_r+0x204>
        }
      if (fp->_flags & __SRD)
   1f4f8:	e1d430bc 	ldrh	r3, [r4, #12]
   1f4fc:	e1a03803 	lsl	r3, r3, #16
   1f500:	e1a03823 	lsr	r3, r3, #16
   1f504:	e2033004 	and	r3, r3, #4
   1f508:	e3530000 	cmp	r3, #0
   1f50c:	0a000015 	beq	1f568 <__swsetup_r+0x10c>
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
   1f510:	e5943030 	ldr	r3, [r4, #48]	; 0x30
   1f514:	e3530000 	cmp	r3, #0
   1f518:	0a000009 	beq	1f544 <__swsetup_r+0xe8>
	    FREEUB (ptr, fp);
   1f51c:	e5942030 	ldr	r2, [r4, #48]	; 0x30
   1f520:	e2843040 	add	r3, r4, #64	; 0x40
   1f524:	e1520003 	cmp	r2, r3
   1f528:	0a000003 	beq	1f53c <__swsetup_r+0xe0>
   1f52c:	e5943030 	ldr	r3, [r4, #48]	; 0x30
   1f530:	e51b0018 	ldr	r0, [fp, #-24]
   1f534:	e1a01003 	mov	r1, r3
   1f538:	ebffdcd4 	bl	16890 <_free_r>
   1f53c:	e3a03000 	mov	r3, #0
   1f540:	e5843030 	str	r3, [r4, #48]	; 0x30
	  fp->_flags &= ~(__SRD | __SEOF);
   1f544:	e1d430bc 	ldrh	r3, [r4, #12]
   1f548:	e3c33024 	bic	r3, r3, #36	; 0x24
   1f54c:	e1a03803 	lsl	r3, r3, #16
   1f550:	e1a03823 	lsr	r3, r3, #16
   1f554:	e1c430bc 	strh	r3, [r4, #12]
	  fp->_r = 0;
   1f558:	e3a03000 	mov	r3, #0
   1f55c:	e5843004 	str	r3, [r4, #4]
	  fp->_p = fp->_bf._base;
   1f560:	e5943010 	ldr	r3, [r4, #16]
   1f564:	e5843000 	str	r3, [r4]
	}
      fp->_flags |= __SWR;
   1f568:	e1d430bc 	ldrh	r3, [r4, #12]
   1f56c:	e3833008 	orr	r3, r3, #8
   1f570:	e1a03803 	lsl	r3, r3, #16
   1f574:	e1a03823 	lsr	r3, r3, #16
   1f578:	e1c430bc 	strh	r3, [r4, #12]
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
   1f57c:	e5943010 	ldr	r3, [r4, #16]
   1f580:	e3530000 	cmp	r3, #0
   1f584:	1a00000e 	bne	1f5c4 <__swsetup_r+0x168>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
   1f588:	e1d430bc 	ldrh	r3, [r4, #12]
   1f58c:	e1a03803 	lsl	r3, r3, #16
   1f590:	e1a03823 	lsr	r3, r3, #16
   1f594:	e2033c02 	and	r3, r3, #512	; 0x200
   1f598:	e3530000 	cmp	r3, #0
   1f59c:	0a000005 	beq	1f5b8 <__swsetup_r+0x15c>
   1f5a0:	e1d430bc 	ldrh	r3, [r4, #12]
   1f5a4:	e1a03803 	lsl	r3, r3, #16
   1f5a8:	e1a03823 	lsr	r3, r3, #16
   1f5ac:	e2033080 	and	r3, r3, #128	; 0x80
   1f5b0:	e3530000 	cmp	r3, #0
   1f5b4:	0a000002 	beq	1f5c4 <__swsetup_r+0x168>
    __smakebuf_r (ptr, fp);
   1f5b8:	e51b0018 	ldr	r0, [fp, #-24]
   1f5bc:	e1a01004 	mov	r1, r4
   1f5c0:	eb000b88 	bl	223e8 <__smakebuf_r>

  if (fp->_flags & __SLBF)
   1f5c4:	e1d430bc 	ldrh	r3, [r4, #12]
   1f5c8:	e1a03803 	lsl	r3, r3, #16
   1f5cc:	e1a03823 	lsr	r3, r3, #16
   1f5d0:	e2033001 	and	r3, r3, #1
   1f5d4:	e3530000 	cmp	r3, #0
   1f5d8:	0a000005 	beq	1f5f4 <__swsetup_r+0x198>
      /*
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
   1f5dc:	e3a03000 	mov	r3, #0
   1f5e0:	e5843008 	str	r3, [r4, #8]
      fp->_lbfsize = -fp->_bf._size;
   1f5e4:	e5943014 	ldr	r3, [r4, #20]
   1f5e8:	e2633000 	rsb	r3, r3, #0
   1f5ec:	e5843018 	str	r3, [r4, #24]
   1f5f0:	ea000009 	b	1f61c <__swsetup_r+0x1c0>
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
   1f5f4:	e1d430bc 	ldrh	r3, [r4, #12]
   1f5f8:	e1a03803 	lsl	r3, r3, #16
   1f5fc:	e1a03823 	lsr	r3, r3, #16
   1f600:	e2033002 	and	r3, r3, #2
   1f604:	e3530000 	cmp	r3, #0
   1f608:	1a000001 	bne	1f614 <__swsetup_r+0x1b8>
   1f60c:	e5943014 	ldr	r3, [r4, #20]
   1f610:	ea000000 	b	1f618 <__swsetup_r+0x1bc>
   1f614:	e3a03000 	mov	r3, #0
   1f618:	e5843008 	str	r3, [r4, #8]

  if (!fp->_bf._base && (fp->_flags & __SMBF))
   1f61c:	e5943010 	ldr	r3, [r4, #16]
   1f620:	e3530000 	cmp	r3, #0
   1f624:	1a00000c 	bne	1f65c <__swsetup_r+0x200>
   1f628:	e1d430bc 	ldrh	r3, [r4, #12]
   1f62c:	e1a03803 	lsl	r3, r3, #16
   1f630:	e1a03823 	lsr	r3, r3, #16
   1f634:	e2033080 	and	r3, r3, #128	; 0x80
   1f638:	e3530000 	cmp	r3, #0
   1f63c:	0a000006 	beq	1f65c <__swsetup_r+0x200>
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
   1f640:	e1d430bc 	ldrh	r3, [r4, #12]
   1f644:	e3833040 	orr	r3, r3, #64	; 0x40
   1f648:	e1a03803 	lsl	r3, r3, #16
   1f64c:	e1a03823 	lsr	r3, r3, #16
   1f650:	e1c430bc 	strh	r3, [r4, #12]
      return EOF;
   1f654:	e3e03000 	mvn	r3, #0
   1f658:	ea000000 	b	1f660 <__swsetup_r+0x204>
    }
  return 0;
   1f65c:	e3a03000 	mov	r3, #0
}
   1f660:	e1a00003 	mov	r0, r3
   1f664:	e24bd008 	sub	sp, fp, #8
   1f668:	e8bd4810 	pop	{r4, fp, lr}
   1f66c:	e12fff1e 	bx	lr
   1f670:	0003e460 	.word	0x0003e460

0001f674 <__call_exitprocs>:
 */

void 
_DEFUN (__call_exitprocs, (code, d),
	int code _AND _PTR d)
{
   1f674:	e92d4870 	push	{r4, r5, r6, fp, lr}
   1f678:	e28db010 	add	fp, sp, #16
   1f67c:	e24dd01c 	sub	sp, sp, #28
   1f680:	e50b0028 	str	r0, [fp, #-40]	; 0x28
   1f684:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
  int i;
  void (*fn) (void);


#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive(__atexit_lock);
   1f688:	e59f01c0 	ldr	r0, [pc, #448]	; 1f850 <__call_exitprocs+0x1dc>
   1f68c:	ebffdf7b 	bl	17480 <_dna_lock_acquire>
#endif

 restart:

  p = _GLOBAL_ATEXIT;
   1f690:	e59f31bc 	ldr	r3, [pc, #444]	; 1f854 <__call_exitprocs+0x1e0>
   1f694:	e5933000 	ldr	r3, [r3]
   1f698:	e5934148 	ldr	r4, [r3, #328]	; 0x148
  lastp = &_GLOBAL_ATEXIT;
   1f69c:	e59f31b0 	ldr	r3, [pc, #432]	; 1f854 <__call_exitprocs+0x1e0>
   1f6a0:	e5933000 	ldr	r3, [r3]
   1f6a4:	e2833f52 	add	r3, r3, #328	; 0x148
   1f6a8:	e50b3018 	str	r3, [fp, #-24]
  while (p)
   1f6ac:	ea000060 	b	1f834 <__call_exitprocs+0x1c0>
    {
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
   1f6b0:	e2846088 	add	r6, r4, #136	; 0x88
#endif
      for (n = p->_ind - 1; n >= 0; n--)
   1f6b4:	e5943004 	ldr	r3, [r4, #4]
   1f6b8:	e2435001 	sub	r5, r3, #1
   1f6bc:	ea000046 	b	1f7dc <__call_exitprocs+0x168>
	{
	  int ind;

	  i = 1 << n;
   1f6c0:	e3a03001 	mov	r3, #1
   1f6c4:	e1a03513 	lsl	r3, r3, r5
   1f6c8:	e50b301c 	str	r3, [fp, #-28]

	  /* Skip functions not from this dso.  */
	  if (d && (!args || args->_dso_handle[n] != d))
   1f6cc:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1f6d0:	e3530000 	cmp	r3, #0
   1f6d4:	0a000007 	beq	1f6f8 <__call_exitprocs+0x84>
   1f6d8:	e3560000 	cmp	r6, #0
   1f6dc:	0a000004 	beq	1f6f4 <__call_exitprocs+0x80>
   1f6e0:	e2853020 	add	r3, r5, #32
   1f6e4:	e7962103 	ldr	r2, [r6, r3, lsl #2]
   1f6e8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1f6ec:	e1520003 	cmp	r2, r3
   1f6f0:	0a000000 	beq	1f6f8 <__call_exitprocs+0x84>
	    continue;
   1f6f4:	ea000037 	b	1f7d8 <__call_exitprocs+0x164>

	  /* Remove the function now to protect against the
	     function calling exit recursively.  */
	  fn = p->_fns[n];
   1f6f8:	e2853002 	add	r3, r5, #2
   1f6fc:	e7943103 	ldr	r3, [r4, r3, lsl #2]
   1f700:	e50b3020 	str	r3, [fp, #-32]
	  if (n == p->_ind - 1)
   1f704:	e5943004 	ldr	r3, [r4, #4]
   1f708:	e2433001 	sub	r3, r3, #1
   1f70c:	e1530005 	cmp	r3, r5
   1f710:	1a000003 	bne	1f724 <__call_exitprocs+0xb0>
	    p->_ind--;
   1f714:	e5943004 	ldr	r3, [r4, #4]
   1f718:	e2433001 	sub	r3, r3, #1
   1f71c:	e5843004 	str	r3, [r4, #4]
   1f720:	ea000002 	b	1f730 <__call_exitprocs+0xbc>
	  else
	    p->_fns[n] = NULL;
   1f724:	e2853002 	add	r3, r5, #2
   1f728:	e3a02000 	mov	r2, #0
   1f72c:	e7842103 	str	r2, [r4, r3, lsl #2]

	  /* Skip functions that have already been called.  */
	  if (!fn)
   1f730:	e51b3020 	ldr	r3, [fp, #-32]
   1f734:	e3530000 	cmp	r3, #0
   1f738:	1a000000 	bne	1f740 <__call_exitprocs+0xcc>
	    continue;
   1f73c:	ea000025 	b	1f7d8 <__call_exitprocs+0x164>

	  ind = p->_ind;
   1f740:	e5943004 	ldr	r3, [r4, #4]
   1f744:	e50b3024 	str	r3, [fp, #-36]	; 0x24

	  /* Call the function.  */
	  if (!args || (args->_fntypes & i) == 0)
   1f748:	e3560000 	cmp	r6, #0
   1f74c:	0a000004 	beq	1f764 <__call_exitprocs+0xf0>
   1f750:	e5962100 	ldr	r2, [r6, #256]	; 0x100
   1f754:	e51b301c 	ldr	r3, [fp, #-28]
   1f758:	e0033002 	and	r3, r3, r2
   1f75c:	e3530000 	cmp	r3, #0
   1f760:	1a000003 	bne	1f774 <__call_exitprocs+0x100>
	    fn ();
   1f764:	e51b3020 	ldr	r3, [fp, #-32]
   1f768:	e1a0e00f 	mov	lr, pc
   1f76c:	e12fff13 	bx	r3
   1f770:	ea000010 	b	1f7b8 <__call_exitprocs+0x144>
	  else if ((args->_is_cxa & i) == 0)
   1f774:	e5962104 	ldr	r2, [r6, #260]	; 0x104
   1f778:	e51b301c 	ldr	r3, [fp, #-28]
   1f77c:	e0033002 	and	r3, r3, r2
   1f780:	e3530000 	cmp	r3, #0
   1f784:	1a000006 	bne	1f7a4 <__call_exitprocs+0x130>
	    (*((void (*)(int, _PTR)) fn))(code, args->_fnargs[n]);
   1f788:	e7962105 	ldr	r2, [r6, r5, lsl #2]
   1f78c:	e51b3020 	ldr	r3, [fp, #-32]
   1f790:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
   1f794:	e1a01002 	mov	r1, r2
   1f798:	e1a0e00f 	mov	lr, pc
   1f79c:	e12fff13 	bx	r3
   1f7a0:	ea000004 	b	1f7b8 <__call_exitprocs+0x144>
	  else
	    (*((void (*)(_PTR)) fn))(args->_fnargs[n]);
   1f7a4:	e7962105 	ldr	r2, [r6, r5, lsl #2]
   1f7a8:	e51b3020 	ldr	r3, [fp, #-32]
   1f7ac:	e1a00002 	mov	r0, r2
   1f7b0:	e1a0e00f 	mov	lr, pc
   1f7b4:	e12fff13 	bx	r3

	  /* The function we called call atexit and registered another
	     function (or functions).  Call these new functions before
	     continuing with the already registered functions.  */
	  if (ind != p->_ind || *lastp != p)
   1f7b8:	e5942004 	ldr	r2, [r4, #4]
   1f7bc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1f7c0:	e1520003 	cmp	r2, r3
   1f7c4:	1affffb1 	bne	1f690 <__call_exitprocs+0x1c>
   1f7c8:	e51b3018 	ldr	r3, [fp, #-24]
   1f7cc:	e5933000 	ldr	r3, [r3]
   1f7d0:	e1530004 	cmp	r3, r4
   1f7d4:	1affffad 	bne	1f690 <__call_exitprocs+0x1c>
#ifdef _REENT_SMALL
      args = p->_on_exit_args_ptr;
#else
      args = &p->_on_exit_args;
#endif
      for (n = p->_ind - 1; n >= 0; n--)
   1f7d8:	e2455001 	sub	r5, r5, #1
   1f7dc:	e3550000 	cmp	r5, #0
   1f7e0:	aaffffb6 	bge	1f6c0 <__call_exitprocs+0x4c>
#ifndef _ATEXIT_DYNAMIC_ALLOC
      break;
#else
      /* Don't dynamically free the atexit array if free is not
	 available.  */
      if (!free)
   1f7e4:	e59f306c 	ldr	r3, [pc, #108]	; 1f858 <__call_exitprocs+0x1e4>
   1f7e8:	e3530000 	cmp	r3, #0
   1f7ec:	1a000000 	bne	1f7f4 <__call_exitprocs+0x180>
	break;
   1f7f0:	ea000011 	b	1f83c <__call_exitprocs+0x1c8>

      /* Move to the next block.  Free empty blocks except the last one,
	 which is part of _GLOBAL_REENT.  */
      if (p->_ind == 0 && p->_next)
   1f7f4:	e5943004 	ldr	r3, [r4, #4]
   1f7f8:	e3530000 	cmp	r3, #0
   1f7fc:	1a00000a 	bne	1f82c <__call_exitprocs+0x1b8>
   1f800:	e5943000 	ldr	r3, [r4]
   1f804:	e3530000 	cmp	r3, #0
   1f808:	0a000007 	beq	1f82c <__call_exitprocs+0x1b8>
	{
	  /* Remove empty block from the list.  */
	  *lastp = p->_next;
   1f80c:	e5942000 	ldr	r2, [r4]
   1f810:	e51b3018 	ldr	r3, [fp, #-24]
   1f814:	e5832000 	str	r2, [r3]
#ifdef _REENT_SMALL
	  if (args)
	    free (args);
#endif
	  free (p);
   1f818:	e1a00004 	mov	r0, r4
   1f81c:	ebffdfa7 	bl	176c0 <free>
	  p = *lastp;
   1f820:	e51b3018 	ldr	r3, [fp, #-24]
   1f824:	e5934000 	ldr	r4, [r3]
   1f828:	ea000001 	b	1f834 <__call_exitprocs+0x1c0>
	}
      else
	{
	  lastp = &p->_next;
   1f82c:	e50b4018 	str	r4, [fp, #-24]
	  p = p->_next;
   1f830:	e5944000 	ldr	r4, [r4]

 restart:

  p = _GLOBAL_ATEXIT;
  lastp = &_GLOBAL_ATEXIT;
  while (p)
   1f834:	e3540000 	cmp	r4, #0
   1f838:	1affff9c 	bne	1f6b0 <__call_exitprocs+0x3c>
	  p = p->_next;
	}
#endif
    }
#ifndef __SINGLE_THREAD__
  __lock_release_recursive(__atexit_lock);
   1f83c:	e59f000c 	ldr	r0, [pc, #12]	; 1f850 <__call_exitprocs+0x1dc>
   1f840:	ebffdf75 	bl	1761c <_dna_lock_release>
#endif

}
   1f844:	e24bd010 	sub	sp, fp, #16
   1f848:	e8bd4870 	pop	{r4, r5, r6, fp, lr}
   1f84c:	e12fff1e 	bx	lr
   1f850:	0003e880 	.word	0x0003e880
   1f854:	00033004 	.word	0x00033004
   1f858:	000176c0 	.word	0x000176c0

0001f85c <_close_r>:

int
_close_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
   1f85c:	e92d4800 	push	{fp, lr}
   1f860:	e28db004 	add	fp, sp, #4
   1f864:	e24dd010 	sub	sp, sp, #16
   1f868:	e50b0010 	str	r0, [fp, #-16]
   1f86c:	e50b1014 	str	r1, [fp, #-20]
  int ret;

  errno = 0;
   1f870:	e59f3050 	ldr	r3, [pc, #80]	; 1f8c8 <_close_r+0x6c>
   1f874:	e3a02000 	mov	r2, #0
   1f878:	e5832000 	str	r2, [r3]
  if ((ret = _close (fd)) == -1 && errno != 0)
   1f87c:	e51b0014 	ldr	r0, [fp, #-20]
   1f880:	ebffd8cd 	bl	15bbc <close>
   1f884:	e50b0008 	str	r0, [fp, #-8]
   1f888:	e51b3008 	ldr	r3, [fp, #-8]
   1f88c:	e3730001 	cmn	r3, #1
   1f890:	1a000007 	bne	1f8b4 <_close_r+0x58>
   1f894:	e59f302c 	ldr	r3, [pc, #44]	; 1f8c8 <_close_r+0x6c>
   1f898:	e5933000 	ldr	r3, [r3]
   1f89c:	e3530000 	cmp	r3, #0
   1f8a0:	0a000003 	beq	1f8b4 <_close_r+0x58>
    ptr->_errno = errno;
   1f8a4:	e59f301c 	ldr	r3, [pc, #28]	; 1f8c8 <_close_r+0x6c>
   1f8a8:	e5932000 	ldr	r2, [r3]
   1f8ac:	e51b3010 	ldr	r3, [fp, #-16]
   1f8b0:	e5832000 	str	r2, [r3]
  return ret;
   1f8b4:	e51b3008 	ldr	r3, [fp, #-8]
}
   1f8b8:	e1a00003 	mov	r0, r3
   1f8bc:	e24bd004 	sub	sp, fp, #4
   1f8c0:	e8bd4800 	pop	{fp, lr}
   1f8c4:	e12fff1e 	bx	lr
   1f8c8:	0018b940 	.word	0x0018b940

0001f8cc <quorem>:

static int
_DEFUN (quorem,
	(b, S),
	_Bigint * b _AND _Bigint * S)
{
   1f8cc:	e92d4800 	push	{fp, lr}
   1f8d0:	e28db004 	add	fp, sp, #4
   1f8d4:	e24dd040 	sub	sp, sp, #64	; 0x40
   1f8d8:	e50b0040 	str	r0, [fp, #-64]	; 0x40
   1f8dc:	e50b1044 	str	r1, [fp, #-68]	; 0x44
#ifdef Pack_32
  __Long z;
  __ULong si, zs;
#endif

  n = S->_wds;
   1f8e0:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1f8e4:	e5933010 	ldr	r3, [r3, #16]
   1f8e8:	e50b3008 	str	r3, [fp, #-8]
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
   1f8ec:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1f8f0:	e5932010 	ldr	r2, [r3, #16]
   1f8f4:	e51b3008 	ldr	r3, [fp, #-8]
   1f8f8:	e1520003 	cmp	r2, r3
   1f8fc:	aa000001 	bge	1f908 <quorem+0x3c>
    return 0;
   1f900:	e3a03000 	mov	r3, #0
   1f904:	ea0000ec 	b	1fcbc <quorem+0x3f0>
  sx = S->_x;
   1f908:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1f90c:	e2833014 	add	r3, r3, #20
   1f910:	e50b3020 	str	r3, [fp, #-32]
  sxe = sx + --n;
   1f914:	e51b3008 	ldr	r3, [fp, #-8]
   1f918:	e2433001 	sub	r3, r3, #1
   1f91c:	e50b3008 	str	r3, [fp, #-8]
   1f920:	e51b3008 	ldr	r3, [fp, #-8]
   1f924:	e1a03103 	lsl	r3, r3, #2
   1f928:	e51b2020 	ldr	r2, [fp, #-32]
   1f92c:	e0823003 	add	r3, r2, r3
   1f930:	e50b3024 	str	r3, [fp, #-36]	; 0x24
  bx = b->_x;
   1f934:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1f938:	e2833014 	add	r3, r3, #20
   1f93c:	e50b3018 	str	r3, [fp, #-24]
  bxe = bx + n;
   1f940:	e51b3008 	ldr	r3, [fp, #-8]
   1f944:	e1a03103 	lsl	r3, r3, #2
   1f948:	e51b2018 	ldr	r2, [fp, #-24]
   1f94c:	e0823003 	add	r3, r2, r3
   1f950:	e50b301c 	str	r3, [fp, #-28]
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
   1f954:	e51b301c 	ldr	r3, [fp, #-28]
   1f958:	e5932000 	ldr	r2, [r3]
   1f95c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1f960:	e5933000 	ldr	r3, [r3]
   1f964:	e2833001 	add	r3, r3, #1
   1f968:	e1a00002 	mov	r0, r2
   1f96c:	e1a01003 	mov	r1, r3
   1f970:	ebffd2c3 	bl	14484 <__aeabi_uidiv>
   1f974:	e1a03000 	mov	r3, r0
   1f978:	e50b3014 	str	r3, [fp, #-20]
#ifdef DEBUG
  /*debug*/ if (q > 9)
    /*debug*/ Bug ("oversized quotient in quorem");
#endif
  if (q)
   1f97c:	e51b3014 	ldr	r3, [fp, #-20]
   1f980:	e3530000 	cmp	r3, #0
   1f984:	0a00005d 	beq	1fb00 <quorem+0x234>
    {
      borrow = 0;
   1f988:	e3a03000 	mov	r3, #0
   1f98c:	e50b300c 	str	r3, [fp, #-12]
      carry = 0;
   1f990:	e3a03000 	mov	r3, #0
   1f994:	e50b3010 	str	r3, [fp, #-16]
      do
	{
#ifdef Pack_32
	  si = *sx++;
   1f998:	e51b3020 	ldr	r3, [fp, #-32]
   1f99c:	e2832004 	add	r2, r3, #4
   1f9a0:	e50b2020 	str	r2, [fp, #-32]
   1f9a4:	e5933000 	ldr	r3, [r3]
   1f9a8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	  ys = (si & 0xffff) * q + carry;
   1f9ac:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1f9b0:	e1a03803 	lsl	r3, r3, #16
   1f9b4:	e1a03823 	lsr	r3, r3, #16
   1f9b8:	e51b2014 	ldr	r2, [fp, #-20]
   1f9bc:	e0020293 	mul	r2, r3, r2
   1f9c0:	e51b3010 	ldr	r3, [fp, #-16]
   1f9c4:	e0823003 	add	r3, r2, r3
   1f9c8:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	  zs = (si >> 16) * q + (ys >> 16);
   1f9cc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1f9d0:	e1a03823 	lsr	r3, r3, #16
   1f9d4:	e51b2014 	ldr	r2, [fp, #-20]
   1f9d8:	e0020293 	mul	r2, r3, r2
   1f9dc:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1f9e0:	e1a03823 	lsr	r3, r3, #16
   1f9e4:	e0823003 	add	r3, r2, r3
   1f9e8:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	  carry = zs >> 16;
   1f9ec:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1f9f0:	e1a03823 	lsr	r3, r3, #16
   1f9f4:	e50b3010 	str	r3, [fp, #-16]
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   1f9f8:	e51b3018 	ldr	r3, [fp, #-24]
   1f9fc:	e5933000 	ldr	r3, [r3]
   1fa00:	e1a02803 	lsl	r2, r3, #16
   1fa04:	e1a02822 	lsr	r2, r2, #16
   1fa08:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1fa0c:	e1a03803 	lsl	r3, r3, #16
   1fa10:	e1a03823 	lsr	r3, r3, #16
   1fa14:	e0632002 	rsb	r2, r3, r2
   1fa18:	e51b300c 	ldr	r3, [fp, #-12]
   1fa1c:	e0823003 	add	r3, r2, r3
   1fa20:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	  borrow = y >> 16;
   1fa24:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1fa28:	e1a03843 	asr	r3, r3, #16
   1fa2c:	e50b300c 	str	r3, [fp, #-12]
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   1fa30:	e51b3018 	ldr	r3, [fp, #-24]
   1fa34:	e5933000 	ldr	r3, [r3]
   1fa38:	e1a02823 	lsr	r2, r3, #16
   1fa3c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1fa40:	e1a03803 	lsl	r3, r3, #16
   1fa44:	e1a03823 	lsr	r3, r3, #16
   1fa48:	e0632002 	rsb	r2, r3, r2
   1fa4c:	e51b300c 	ldr	r3, [fp, #-12]
   1fa50:	e0823003 	add	r3, r2, r3
   1fa54:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	  borrow = z >> 16;
   1fa58:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1fa5c:	e1a03843 	asr	r3, r3, #16
   1fa60:	e50b300c 	str	r3, [fp, #-12]
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   1fa64:	e51b2018 	ldr	r2, [fp, #-24]
   1fa68:	e2823004 	add	r3, r2, #4
   1fa6c:	e50b3018 	str	r3, [fp, #-24]
   1fa70:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1fa74:	e1a01803 	lsl	r1, r3, #16
   1fa78:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1fa7c:	e1a03803 	lsl	r3, r3, #16
   1fa80:	e1a03823 	lsr	r3, r3, #16
   1fa84:	e1813003 	orr	r3, r1, r3
   1fa88:	e5823000 	str	r3, [r2]
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
   1fa8c:	e51b2020 	ldr	r2, [fp, #-32]
   1fa90:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1fa94:	e1520003 	cmp	r2, r3
   1fa98:	9affffbe 	bls	1f998 <quorem+0xcc>
      if (!*bxe)
   1fa9c:	e51b301c 	ldr	r3, [fp, #-28]
   1faa0:	e5933000 	ldr	r3, [r3]
   1faa4:	e3530000 	cmp	r3, #0
   1faa8:	1a000014 	bne	1fb00 <quorem+0x234>
	{
	  bx = b->_x;
   1faac:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1fab0:	e2833014 	add	r3, r3, #20
   1fab4:	e50b3018 	str	r3, [fp, #-24]
	  while (--bxe > bx && !*bxe)
   1fab8:	ea000002 	b	1fac8 <quorem+0x1fc>
	    --n;
   1fabc:	e51b3008 	ldr	r3, [fp, #-8]
   1fac0:	e2433001 	sub	r3, r3, #1
   1fac4:	e50b3008 	str	r3, [fp, #-8]
	}
      while (sx <= sxe);
      if (!*bxe)
	{
	  bx = b->_x;
	  while (--bxe > bx && !*bxe)
   1fac8:	e51b301c 	ldr	r3, [fp, #-28]
   1facc:	e2433004 	sub	r3, r3, #4
   1fad0:	e50b301c 	str	r3, [fp, #-28]
   1fad4:	e51b201c 	ldr	r2, [fp, #-28]
   1fad8:	e51b3018 	ldr	r3, [fp, #-24]
   1fadc:	e1520003 	cmp	r2, r3
   1fae0:	9a000003 	bls	1faf4 <quorem+0x228>
   1fae4:	e51b301c 	ldr	r3, [fp, #-28]
   1fae8:	e5933000 	ldr	r3, [r3]
   1faec:	e3530000 	cmp	r3, #0
   1faf0:	0afffff1 	beq	1fabc <quorem+0x1f0>
	    --n;
	  b->_wds = n;
   1faf4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1faf8:	e51b2008 	ldr	r2, [fp, #-8]
   1fafc:	e5832010 	str	r2, [r3, #16]
	}
    }
  if (cmp (b, S) >= 0)
   1fb00:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   1fb04:	e51b1044 	ldr	r1, [fp, #-68]	; 0x44
   1fb08:	eb000f48 	bl	23830 <__mcmp>
   1fb0c:	e1a03000 	mov	r3, r0
   1fb10:	e3530000 	cmp	r3, #0
   1fb14:	ba000067 	blt	1fcb8 <quorem+0x3ec>
    {
      q++;
   1fb18:	e51b3014 	ldr	r3, [fp, #-20]
   1fb1c:	e2833001 	add	r3, r3, #1
   1fb20:	e50b3014 	str	r3, [fp, #-20]
      borrow = 0;
   1fb24:	e3a03000 	mov	r3, #0
   1fb28:	e50b300c 	str	r3, [fp, #-12]
      carry = 0;
   1fb2c:	e3a03000 	mov	r3, #0
   1fb30:	e50b3010 	str	r3, [fp, #-16]
      bx = b->_x;
   1fb34:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1fb38:	e2833014 	add	r3, r3, #20
   1fb3c:	e50b3018 	str	r3, [fp, #-24]
      sx = S->_x;
   1fb40:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1fb44:	e2833014 	add	r3, r3, #20
   1fb48:	e50b3020 	str	r3, [fp, #-32]
      do
	{
#ifdef Pack_32
	  si = *sx++;
   1fb4c:	e51b3020 	ldr	r3, [fp, #-32]
   1fb50:	e2832004 	add	r2, r3, #4
   1fb54:	e50b2020 	str	r2, [fp, #-32]
   1fb58:	e5933000 	ldr	r3, [r3]
   1fb5c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	  ys = (si & 0xffff) + carry;
   1fb60:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1fb64:	e1a03803 	lsl	r3, r3, #16
   1fb68:	e1a03823 	lsr	r3, r3, #16
   1fb6c:	e51b2010 	ldr	r2, [fp, #-16]
   1fb70:	e0833002 	add	r3, r3, r2
   1fb74:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	  zs = (si >> 16) + (ys >> 16);
   1fb78:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1fb7c:	e1a02823 	lsr	r2, r3, #16
   1fb80:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1fb84:	e1a03823 	lsr	r3, r3, #16
   1fb88:	e0823003 	add	r3, r2, r3
   1fb8c:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	  carry = zs >> 16;
   1fb90:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1fb94:	e1a03823 	lsr	r3, r3, #16
   1fb98:	e50b3010 	str	r3, [fp, #-16]
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   1fb9c:	e51b3018 	ldr	r3, [fp, #-24]
   1fba0:	e5933000 	ldr	r3, [r3]
   1fba4:	e1a02803 	lsl	r2, r3, #16
   1fba8:	e1a02822 	lsr	r2, r2, #16
   1fbac:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1fbb0:	e1a03803 	lsl	r3, r3, #16
   1fbb4:	e1a03823 	lsr	r3, r3, #16
   1fbb8:	e0632002 	rsb	r2, r3, r2
   1fbbc:	e51b300c 	ldr	r3, [fp, #-12]
   1fbc0:	e0823003 	add	r3, r2, r3
   1fbc4:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	  borrow = y >> 16;
   1fbc8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1fbcc:	e1a03843 	asr	r3, r3, #16
   1fbd0:	e50b300c 	str	r3, [fp, #-12]
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   1fbd4:	e51b3018 	ldr	r3, [fp, #-24]
   1fbd8:	e5933000 	ldr	r3, [r3]
   1fbdc:	e1a02823 	lsr	r2, r3, #16
   1fbe0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1fbe4:	e1a03803 	lsl	r3, r3, #16
   1fbe8:	e1a03823 	lsr	r3, r3, #16
   1fbec:	e0632002 	rsb	r2, r3, r2
   1fbf0:	e51b300c 	ldr	r3, [fp, #-12]
   1fbf4:	e0823003 	add	r3, r2, r3
   1fbf8:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	  borrow = z >> 16;
   1fbfc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1fc00:	e1a03843 	asr	r3, r3, #16
   1fc04:	e50b300c 	str	r3, [fp, #-12]
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   1fc08:	e51b2018 	ldr	r2, [fp, #-24]
   1fc0c:	e2823004 	add	r3, r2, #4
   1fc10:	e50b3018 	str	r3, [fp, #-24]
   1fc14:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1fc18:	e1a01803 	lsl	r1, r3, #16
   1fc1c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1fc20:	e1a03803 	lsl	r3, r3, #16
   1fc24:	e1a03823 	lsr	r3, r3, #16
   1fc28:	e1813003 	orr	r3, r1, r3
   1fc2c:	e5823000 	str	r3, [r2]
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
   1fc30:	e51b2020 	ldr	r2, [fp, #-32]
   1fc34:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1fc38:	e1520003 	cmp	r2, r3
   1fc3c:	9affffc2 	bls	1fb4c <quorem+0x280>
      bx = b->_x;
   1fc40:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1fc44:	e2833014 	add	r3, r3, #20
   1fc48:	e50b3018 	str	r3, [fp, #-24]
      bxe = bx + n;
   1fc4c:	e51b3008 	ldr	r3, [fp, #-8]
   1fc50:	e1a03103 	lsl	r3, r3, #2
   1fc54:	e51b2018 	ldr	r2, [fp, #-24]
   1fc58:	e0823003 	add	r3, r2, r3
   1fc5c:	e50b301c 	str	r3, [fp, #-28]
      if (!*bxe)
   1fc60:	e51b301c 	ldr	r3, [fp, #-28]
   1fc64:	e5933000 	ldr	r3, [r3]
   1fc68:	e3530000 	cmp	r3, #0
   1fc6c:	1a000011 	bne	1fcb8 <quorem+0x3ec>
	{
	  while (--bxe > bx && !*bxe)
   1fc70:	ea000002 	b	1fc80 <quorem+0x3b4>
	    --n;
   1fc74:	e51b3008 	ldr	r3, [fp, #-8]
   1fc78:	e2433001 	sub	r3, r3, #1
   1fc7c:	e50b3008 	str	r3, [fp, #-8]
      while (sx <= sxe);
      bx = b->_x;
      bxe = bx + n;
      if (!*bxe)
	{
	  while (--bxe > bx && !*bxe)
   1fc80:	e51b301c 	ldr	r3, [fp, #-28]
   1fc84:	e2433004 	sub	r3, r3, #4
   1fc88:	e50b301c 	str	r3, [fp, #-28]
   1fc8c:	e51b201c 	ldr	r2, [fp, #-28]
   1fc90:	e51b3018 	ldr	r3, [fp, #-24]
   1fc94:	e1520003 	cmp	r2, r3
   1fc98:	9a000003 	bls	1fcac <quorem+0x3e0>
   1fc9c:	e51b301c 	ldr	r3, [fp, #-28]
   1fca0:	e5933000 	ldr	r3, [r3]
   1fca4:	e3530000 	cmp	r3, #0
   1fca8:	0afffff1 	beq	1fc74 <quorem+0x3a8>
	    --n;
	  b->_wds = n;
   1fcac:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1fcb0:	e51b2008 	ldr	r2, [fp, #-8]
   1fcb4:	e5832010 	str	r2, [r3, #16]
	}
    }
  return q;
   1fcb8:	e51b3014 	ldr	r3, [fp, #-20]
}
   1fcbc:	e1a00003 	mov	r0, r3
   1fcc0:	e24bd004 	sub	sp, fp, #4
   1fcc4:	e8bd4800 	pop	{fp, lr}
   1fcc8:	e12fff1e 	bx	lr
   1fccc:	00000000 	andeq	r0, r0, r0

0001fcd0 <_dtoa_r>:
	int mode _AND
	int ndigits _AND
	int *decpt _AND
	int *sign _AND
	char **rve)
{
   1fcd0:	e92d48f0 	push	{r4, r5, r6, r7, fp, lr}
   1fcd4:	e28db014 	add	fp, sp, #20
   1fcd8:	e24dd0c0 	sub	sp, sp, #192	; 0xc0
   1fcdc:	e50b00c0 	str	r0, [fp, #-192]	; 0xc0
   1fce0:	e50b20cc 	str	r2, [fp, #-204]	; 0xcc
   1fce4:	e50b30c8 	str	r3, [fp, #-200]	; 0xc8
  __Long L;
#ifndef Sudden_Underflow
  int denorm;
  __ULong x;
#endif
  _Bigint *b, *b1, *delta, *mlo = NULL, *mhi, *S;
   1fce8:	e3a03000 	mov	r3, #0
   1fcec:	e50b3064 	str	r3, [fp, #-100]	; 0x64
  double ds;
  char *s, *s0;

  d.d = _d;
   1fcf0:	e24b30cc 	sub	r3, fp, #204	; 0xcc
   1fcf4:	e893000c 	ldm	r3, {r2, r3}
   1fcf8:	e50b20ac 	str	r2, [fp, #-172]	; 0xac
   1fcfc:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
   1fd00:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   1fd04:	e5933040 	ldr	r3, [r3, #64]	; 0x40
   1fd08:	e3530000 	cmp	r3, #0
   1fd0c:	0a000013 	beq	1fd60 <_dtoa_r+0x90>
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
   1fd10:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   1fd14:	e5933040 	ldr	r3, [r3, #64]	; 0x40
   1fd18:	e51b20c0 	ldr	r2, [fp, #-192]	; 0xc0
   1fd1c:	e5922044 	ldr	r2, [r2, #68]	; 0x44
   1fd20:	e5832004 	str	r2, [r3, #4]
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
   1fd24:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   1fd28:	e5933040 	ldr	r3, [r3, #64]	; 0x40
   1fd2c:	e51b20c0 	ldr	r2, [fp, #-192]	; 0xc0
   1fd30:	e5922044 	ldr	r2, [r2, #68]	; 0x44
   1fd34:	e3a01001 	mov	r1, #1
   1fd38:	e1a02211 	lsl	r2, r1, r2
   1fd3c:	e5832008 	str	r2, [r3, #8]
      Bfree (ptr, _REENT_MP_RESULT(ptr));
   1fd40:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   1fd44:	e5933040 	ldr	r3, [r3, #64]	; 0x40
   1fd48:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   1fd4c:	e1a01003 	mov	r1, r3
   1fd50:	eb000b72 	bl	22b20 <_Bfree>
      _REENT_MP_RESULT(ptr) = 0;
   1fd54:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   1fd58:	e3a02000 	mov	r2, #0
   1fd5c:	e5832040 	str	r2, [r3, #64]	; 0x40
    }

  if (word0 (d) & Sign_bit)
   1fd60:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1fd64:	e3530000 	cmp	r3, #0
   1fd68:	aa000006 	bge	1fd88 <_dtoa_r+0xb8>
    {
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
   1fd6c:	e59b3010 	ldr	r3, [fp, #16]
   1fd70:	e3a02001 	mov	r2, #1
   1fd74:	e5832000 	str	r2, [r3]
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
   1fd78:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1fd7c:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   1fd80:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1fd84:	ea000002 	b	1fd94 <_dtoa_r+0xc4>
    }
  else
    *sign = 0;
   1fd88:	e59b3010 	ldr	r3, [fp, #16]
   1fd8c:	e3a02000 	mov	r2, #0
   1fd90:	e5832000 	str	r2, [r3]

#if defined(IEEE_Arith) + defined(VAX)
#ifdef IEEE_Arith
  if ((word0 (d) & Exp_mask) == Exp_mask)
   1fd94:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1fd98:	e59f35a8 	ldr	r3, [pc, #1448]	; 20348 <_dtoa_r+0x678>
   1fd9c:	e0033002 	and	r3, r3, r2
   1fda0:	e59f25a0 	ldr	r2, [pc, #1440]	; 20348 <_dtoa_r+0x678>
   1fda4:	e1530002 	cmp	r3, r2
   1fda8:	1a00001f 	bne	1fe2c <_dtoa_r+0x15c>
#else
  if (word0 (d) == 0x8000)
#endif
    {
      /* Infinity or NaN */
      *decpt = 9999;
   1fdac:	e59b300c 	ldr	r3, [fp, #12]
   1fdb0:	e59f2560 	ldr	r2, [pc, #1376]	; 20318 <_dtoa_r+0x648>
   1fdb4:	e5832000 	str	r2, [r3]
      s =
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
   1fdb8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1fdbc:	e3530000 	cmp	r3, #0
   1fdc0:	1a000006 	bne	1fde0 <_dtoa_r+0x110>
   1fdc4:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1fdc8:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
   1fdcc:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   1fdd0:	e3530000 	cmp	r3, #0
   1fdd4:	1a000001 	bne	1fde0 <_dtoa_r+0x110>
   1fdd8:	e59f353c 	ldr	r3, [pc, #1340]	; 2031c <_dtoa_r+0x64c>
   1fddc:	ea000000 	b	1fde4 <_dtoa_r+0x114>
   1fde0:	e59f3538 	ldr	r3, [pc, #1336]	; 20320 <_dtoa_r+0x650>
  if (word0 (d) == 0x8000)
#endif
    {
      /* Infinity or NaN */
      *decpt = 9999;
      s =
   1fde4:	e50b3078 	str	r3, [fp, #-120]	; 0x78
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
#endif
	"NaN";
      if (rve)
   1fde8:	e59b3014 	ldr	r3, [fp, #20]
   1fdec:	e3530000 	cmp	r3, #0
   1fdf0:	0a00000b 	beq	1fe24 <_dtoa_r+0x154>
	*rve =
#ifdef IEEE_Arith
	  s[3] ? s + 8 :
   1fdf4:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1fdf8:	e2833003 	add	r3, r3, #3
   1fdfc:	e5d33000 	ldrb	r3, [r3]
   1fe00:	e3530000 	cmp	r3, #0
   1fe04:	0a000002 	beq	1fe14 <_dtoa_r+0x144>
   1fe08:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1fe0c:	e2833008 	add	r3, r3, #8
   1fe10:	ea000001 	b	1fe1c <_dtoa_r+0x14c>
   1fe14:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1fe18:	e2833003 	add	r3, r3, #3
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
#endif
	"NaN";
      if (rve)
	*rve =
   1fe1c:	e59b2014 	ldr	r2, [fp, #20]
   1fe20:	e5823000 	str	r3, [r2]
#ifdef IEEE_Arith
	  s[3] ? s + 8 :
#endif
	  s + 3;
      return s;
   1fe24:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1fe28:	ea0006a4 	b	218c0 <_dtoa_r+0x1bf0>
    }
#endif
#ifdef IBM
  d.d += 0;			/* normalize */
#endif
  if (!d.d)
   1fe2c:	e24b30ac 	sub	r3, fp, #172	; 0xac
   1fe30:	e893000c 	ldm	r3, {r2, r3}
   1fe34:	e1a00002 	mov	r0, r2
   1fe38:	e1a01003 	mov	r1, r3
   1fe3c:	e3a02000 	mov	r2, #0
   1fe40:	e3a03000 	mov	r3, #0
   1fe44:	ebffd487 	bl	15068 <__aeabi_dcmpeq>
   1fe48:	e1a03000 	mov	r3, r0
   1fe4c:	e3530000 	cmp	r3, #0
   1fe50:	0a00000d 	beq	1fe8c <_dtoa_r+0x1bc>
    {
      *decpt = 1;
   1fe54:	e59b300c 	ldr	r3, [fp, #12]
   1fe58:	e3a02001 	mov	r2, #1
   1fe5c:	e5832000 	str	r2, [r3]
      s = "0";
   1fe60:	e59f34bc 	ldr	r3, [pc, #1212]	; 20324 <_dtoa_r+0x654>
   1fe64:	e50b3078 	str	r3, [fp, #-120]	; 0x78
      if (rve)
   1fe68:	e59b3014 	ldr	r3, [fp, #20]
   1fe6c:	e3530000 	cmp	r3, #0
   1fe70:	0a000003 	beq	1fe84 <_dtoa_r+0x1b4>
	*rve = s + 1;
   1fe74:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1fe78:	e2832001 	add	r2, r3, #1
   1fe7c:	e59b3014 	ldr	r3, [fp, #20]
   1fe80:	e5832000 	str	r2, [r3]
      return s;
   1fe84:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1fe88:	ea00068c 	b	218c0 <_dtoa_r+0x1bf0>
    }

  b = d2b (ptr, d.d, &be, &bbits);
   1fe8c:	e24b30ac 	sub	r3, fp, #172	; 0xac
   1fe90:	e893000c 	ldm	r3, {r2, r3}
   1fe94:	e24b10a0 	sub	r1, fp, #160	; 0xa0
   1fe98:	e58d1000 	str	r1, [sp]
   1fe9c:	e24b109c 	sub	r1, fp, #156	; 0x9c
   1fea0:	e58d1004 	str	r1, [sp, #4]
   1fea4:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   1fea8:	eb001004 	bl	23ec0 <__d2b>
   1feac:	e50b0060 	str	r0, [fp, #-96]	; 0x60
#ifdef Sudden_Underflow
  i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1));
#else
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
   1feb0:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1feb4:	e1a03a23 	lsr	r3, r3, #20
   1feb8:	e1a03a83 	lsl	r3, r3, #21
   1febc:	e1a03aa3 	lsr	r3, r3, #21
   1fec0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   1fec4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1fec8:	e3530000 	cmp	r3, #0
   1fecc:	0a000012 	beq	1ff1c <_dtoa_r+0x24c>
    {
#endif
      d2.d = d.d;
   1fed0:	e24b30ac 	sub	r3, fp, #172	; 0xac
   1fed4:	e893000c 	ldm	r3, {r2, r3}
   1fed8:	e50b20b4 	str	r2, [fp, #-180]	; 0xb4
   1fedc:	e50b30b0 	str	r3, [fp, #-176]	; 0xb0
      word0 (d2) &= Frac_mask1;
   1fee0:	e51b30b0 	ldr	r3, [fp, #-176]	; 0xb0
   1fee4:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
   1fee8:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   1feec:	e50b30b0 	str	r3, [fp, #-176]	; 0xb0
      word0 (d2) |= Exp_11;
   1fef0:	e51b30b0 	ldr	r3, [fp, #-176]	; 0xb0
   1fef4:	e38335ff 	orr	r3, r3, #1069547520	; 0x3fc00000
   1fef8:	e3833603 	orr	r3, r3, #3145728	; 0x300000
   1fefc:	e50b30b0 	str	r3, [fp, #-176]	; 0xb0
		 * Hence we adjust the constant term to 0.1760912590558.
		 * (We could get a more accurate k by invoking log10,
		 *  but this is probably not worthwhile.)
		 */

      i -= Bias;
   1ff00:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1ff04:	e2433fff 	sub	r3, r3, #1020	; 0x3fc
   1ff08:	e2433003 	sub	r3, r3, #3
   1ff0c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
#ifdef IBM
      i <<= 2;
      i += j;
#endif
#ifndef Sudden_Underflow
      denorm = 0;
   1ff10:	e3a03000 	mov	r3, #0
   1ff14:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   1ff18:	ea000026 	b	1ffb8 <_dtoa_r+0x2e8>
    }
  else
    {
      /* d is denormalized */

      i = bbits + be + (Bias + (P - 1) - 1);
   1ff1c:	e51b209c 	ldr	r2, [fp, #-156]	; 0x9c
   1ff20:	e51b30a0 	ldr	r3, [fp, #-160]	; 0xa0
   1ff24:	e0823003 	add	r3, r2, r3
   1ff28:	e2833e43 	add	r3, r3, #1072	; 0x430
   1ff2c:	e2833002 	add	r3, r3, #2
   1ff30:	e50b3024 	str	r3, [fp, #-36]	; 0x24
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
   1ff34:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1ff38:	e3530020 	cmp	r3, #32
   1ff3c:	da000009 	ble	1ff68 <_dtoa_r+0x298>
   1ff40:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1ff44:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1ff48:	e2633040 	rsb	r3, r3, #64	; 0x40
   1ff4c:	e1a02312 	lsl	r2, r2, r3
   1ff50:	e51b10ac 	ldr	r1, [fp, #-172]	; 0xac
   1ff54:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1ff58:	e2433020 	sub	r3, r3, #32
   1ff5c:	e1a03331 	lsr	r3, r1, r3
   1ff60:	e1823003 	orr	r3, r2, r3
   1ff64:	ea000003 	b	1ff78 <_dtoa_r+0x2a8>
       : (word1 (d) << (32 - i));
   1ff68:	e51b20ac 	ldr	r2, [fp, #-172]	; 0xac
   1ff6c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1ff70:	e2633020 	rsb	r3, r3, #32

      i = bbits + be + (Bias + (P - 1) - 1);
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
   1ff74:	e1a03312 	lsl	r3, r2, r3
   1ff78:	e50b307c 	str	r3, [fp, #-124]	; 0x7c
       : (word1 (d) << (32 - i));
#endif
      d2.d = x;
   1ff7c:	e51b007c 	ldr	r0, [fp, #-124]	; 0x7c
   1ff80:	ebffd29e 	bl	14a00 <__aeabi_ui2d>
   1ff84:	e1a02000 	mov	r2, r0
   1ff88:	e1a03001 	mov	r3, r1
   1ff8c:	e50b20b4 	str	r2, [fp, #-180]	; 0xb4
   1ff90:	e50b30b0 	str	r3, [fp, #-176]	; 0xb0
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
   1ff94:	e51b30b0 	ldr	r3, [fp, #-176]	; 0xb0
   1ff98:	e243361f 	sub	r3, r3, #32505856	; 0x1f00000
   1ff9c:	e50b30b0 	str	r3, [fp, #-176]	; 0xb0
      i -= (Bias + (P - 1) - 1) + 1;
   1ffa0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1ffa4:	e2433e43 	sub	r3, r3, #1072	; 0x430
   1ffa8:	e2433003 	sub	r3, r3, #3
   1ffac:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      denorm = 1;
   1ffb0:	e3a03001 	mov	r3, #1
   1ffb4:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
    }
#endif
#if defined (_DOUBLE_IS_32BITS)
  ds = (d2.d - 1.5) * 0.289529651 + 0.176091269 + i * 0.30103001;
#else
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
   1ffb8:	e24b30b4 	sub	r3, fp, #180	; 0xb4
   1ffbc:	e893000c 	ldm	r3, {r2, r3}
   1ffc0:	e1a00002 	mov	r0, r2
   1ffc4:	e1a01003 	mov	r1, r3
   1ffc8:	e3a02000 	mov	r2, #0
   1ffcc:	e59f3354 	ldr	r3, [pc, #852]	; 20328 <_dtoa_r+0x658>
   1ffd0:	ebffd1c5 	bl	146ec <__aeabi_dsub>
   1ffd4:	e1a02000 	mov	r2, r0
   1ffd8:	e1a03001 	mov	r3, r1
   1ffdc:	e1a00002 	mov	r0, r2
   1ffe0:	e1a01003 	mov	r1, r3
   1ffe4:	e28f3fc5 	add	r3, pc, #788	; 0x314
   1ffe8:	e893000c 	ldm	r3, {r2, r3}
   1ffec:	ebffd2c3 	bl	14b00 <__aeabi_dmul>
   1fff0:	e1a02000 	mov	r2, r0
   1fff4:	e1a03001 	mov	r3, r1
   1fff8:	e1a00002 	mov	r0, r2
   1fffc:	e1a01003 	mov	r1, r3
   20000:	e28f3c03 	add	r3, pc, #768	; 0x300
   20004:	e893000c 	ldm	r3, {r2, r3}
   20008:	ebffd1b8 	bl	146f0 <__adddf3>
   2000c:	e1a02000 	mov	r2, r0
   20010:	e1a03001 	mov	r3, r1
   20014:	e1a06002 	mov	r6, r2
   20018:	e1a07003 	mov	r7, r3
   2001c:	e51b0024 	ldr	r0, [fp, #-36]	; 0x24
   20020:	ebffd27f 	bl	14a24 <__aeabi_i2d>
   20024:	e1a02000 	mov	r2, r0
   20028:	e1a03001 	mov	r3, r1
   2002c:	e1a00002 	mov	r0, r2
   20030:	e1a01003 	mov	r1, r3
   20034:	e28f3fb5 	add	r3, pc, #724	; 0x2d4
   20038:	e893000c 	ldm	r3, {r2, r3}
   2003c:	ebffd2af 	bl	14b00 <__aeabi_dmul>
   20040:	e1a02000 	mov	r2, r0
   20044:	e1a03001 	mov	r3, r1
   20048:	e1a00006 	mov	r0, r6
   2004c:	e1a01007 	mov	r1, r7
   20050:	ebffd1a6 	bl	146f0 <__adddf3>
   20054:	e1a02000 	mov	r2, r0
   20058:	e1a03001 	mov	r3, r1
   2005c:	e50b2074 	str	r2, [fp, #-116]	; 0x74
   20060:	e50b3070 	str	r3, [fp, #-112]	; 0x70
#endif
  k = (int) ds;
   20064:	e24b1074 	sub	r1, fp, #116	; 0x74
   20068:	e8910003 	ldm	r1, {r0, r1}
   2006c:	ebffd41b 	bl	150e0 <__aeabi_d2iz>
   20070:	e1a03000 	mov	r3, r0
   20074:	e50b3038 	str	r3, [fp, #-56]	; 0x38
  if (ds < 0. && ds != k)
   20078:	e24b1074 	sub	r1, fp, #116	; 0x74
   2007c:	e8910003 	ldm	r1, {r0, r1}
   20080:	e3a02000 	mov	r2, #0
   20084:	e3a03000 	mov	r3, #0
   20088:	ebffd3fc 	bl	15080 <__aeabi_dcmplt>
   2008c:	e1a03000 	mov	r3, r0
   20090:	e3530000 	cmp	r3, #0
   20094:	0a00000e 	beq	200d4 <_dtoa_r+0x404>
   20098:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
   2009c:	ebffd260 	bl	14a24 <__aeabi_i2d>
   200a0:	e1a02000 	mov	r2, r0
   200a4:	e1a03001 	mov	r3, r1
   200a8:	e1a00002 	mov	r0, r2
   200ac:	e1a01003 	mov	r1, r3
   200b0:	e24b3074 	sub	r3, fp, #116	; 0x74
   200b4:	e893000c 	ldm	r3, {r2, r3}
   200b8:	ebffd3ea 	bl	15068 <__aeabi_dcmpeq>
   200bc:	e1a03000 	mov	r3, r0
   200c0:	e3530000 	cmp	r3, #0
   200c4:	1a000002 	bne	200d4 <_dtoa_r+0x404>
    k--;			/* want k = floor(ds) */
   200c8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   200cc:	e2433001 	sub	r3, r3, #1
   200d0:	e50b3038 	str	r3, [fp, #-56]	; 0x38
  k_check = 1;
   200d4:	e3a03001 	mov	r3, #1
   200d8:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
  if (k >= 0 && k <= Ten_pmax)
   200dc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   200e0:	e3530000 	cmp	r3, #0
   200e4:	ba000012 	blt	20134 <_dtoa_r+0x464>
   200e8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   200ec:	e3530016 	cmp	r3, #22
   200f0:	ca00000f 	bgt	20134 <_dtoa_r+0x464>
    {
      if (d.d < tens[k])
   200f4:	e24b10ac 	sub	r1, fp, #172	; 0xac
   200f8:	e8910003 	ldm	r1, {r0, r1}
   200fc:	e59f2238 	ldr	r2, [pc, #568]	; 2033c <_dtoa_r+0x66c>
   20100:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   20104:	e1a03183 	lsl	r3, r3, #3
   20108:	e0823003 	add	r3, r2, r3
   2010c:	e893000c 	ldm	r3, {r2, r3}
   20110:	ebffd3da 	bl	15080 <__aeabi_dcmplt>
   20114:	e1a03000 	mov	r3, r0
   20118:	e3530000 	cmp	r3, #0
   2011c:	0a000002 	beq	2012c <_dtoa_r+0x45c>
	k--;
   20120:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   20124:	e2433001 	sub	r3, r3, #1
   20128:	e50b3038 	str	r3, [fp, #-56]	; 0x38
      k_check = 0;
   2012c:	e3a03000 	mov	r3, #0
   20130:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
    }
  j = bbits - i - 1;
   20134:	e51b209c 	ldr	r2, [fp, #-156]	; 0x9c
   20138:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   2013c:	e0633002 	rsb	r3, r3, r2
   20140:	e2433001 	sub	r3, r3, #1
   20144:	e50b3034 	str	r3, [fp, #-52]	; 0x34
  if (j >= 0)
   20148:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2014c:	e3530000 	cmp	r3, #0
   20150:	ba000004 	blt	20168 <_dtoa_r+0x498>
    {
      b2 = 0;
   20154:	e3a03000 	mov	r3, #0
   20158:	e50b3018 	str	r3, [fp, #-24]
      s2 = j;
   2015c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   20160:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   20164:	ea000004 	b	2017c <_dtoa_r+0x4ac>
    }
  else
    {
      b2 = -j;
   20168:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2016c:	e2633000 	rsb	r3, r3, #0
   20170:	e50b3018 	str	r3, [fp, #-24]
      s2 = 0;
   20174:	e3a03000 	mov	r3, #0
   20178:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
    }
  if (k >= 0)
   2017c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   20180:	e3530000 	cmp	r3, #0
   20184:	ba000008 	blt	201ac <_dtoa_r+0x4dc>
    {
      b5 = 0;
   20188:	e3a03000 	mov	r3, #0
   2018c:	e50b301c 	str	r3, [fp, #-28]
      s5 = k;
   20190:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   20194:	e50b3050 	str	r3, [fp, #-80]	; 0x50
      s2 += k;
   20198:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   2019c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   201a0:	e0823003 	add	r3, r2, r3
   201a4:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   201a8:	ea000008 	b	201d0 <_dtoa_r+0x500>
    }
  else
    {
      b2 -= k;
   201ac:	e51b2018 	ldr	r2, [fp, #-24]
   201b0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   201b4:	e0633002 	rsb	r3, r3, r2
   201b8:	e50b3018 	str	r3, [fp, #-24]
      b5 = -k;
   201bc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   201c0:	e2633000 	rsb	r3, r3, #0
   201c4:	e50b301c 	str	r3, [fp, #-28]
      s5 = 0;
   201c8:	e3a03000 	mov	r3, #0
   201cc:	e50b3050 	str	r3, [fp, #-80]	; 0x50
    }
  if (mode < 0 || mode > 9)
   201d0:	e59b3004 	ldr	r3, [fp, #4]
   201d4:	e3530000 	cmp	r3, #0
   201d8:	ba000002 	blt	201e8 <_dtoa_r+0x518>
   201dc:	e59b3004 	ldr	r3, [fp, #4]
   201e0:	e3530009 	cmp	r3, #9
   201e4:	da000001 	ble	201f0 <_dtoa_r+0x520>
    mode = 0;
   201e8:	e3a03000 	mov	r3, #0
   201ec:	e58b3004 	str	r3, [fp, #4]
  try_quick = 1;
   201f0:	e3a03001 	mov	r3, #1
   201f4:	e50b3058 	str	r3, [fp, #-88]	; 0x58
  if (mode > 5)
   201f8:	e59b3004 	ldr	r3, [fp, #4]
   201fc:	e3530005 	cmp	r3, #5
   20200:	da000004 	ble	20218 <_dtoa_r+0x548>
    {
      mode -= 4;
   20204:	e59b3004 	ldr	r3, [fp, #4]
   20208:	e2433004 	sub	r3, r3, #4
   2020c:	e58b3004 	str	r3, [fp, #4]
      try_quick = 0;
   20210:	e3a03000 	mov	r3, #0
   20214:	e50b3058 	str	r3, [fp, #-88]	; 0x58
    }
  leftright = 1;
   20218:	e3a03001 	mov	r3, #1
   2021c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
  ilim = ilim1 = -1;
   20220:	e3e03000 	mvn	r3, #0
   20224:	e50b3030 	str	r3, [fp, #-48]	; 0x30
   20228:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2022c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
  switch (mode)
   20230:	e59b3004 	ldr	r3, [fp, #4]
   20234:	e3530005 	cmp	r3, #5
   20238:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   2023c:	ea000029 	b	202e8 <_dtoa_r+0x618>
   20240:	00020258 	.word	0x00020258
   20244:	00020258 	.word	0x00020258
   20248:	0002026c 	.word	0x0002026c
   2024c:	000202a4 	.word	0x000202a4
   20250:	00020274 	.word	0x00020274
   20254:	000202ac 	.word	0x000202ac
    {
    case 0:
    case 1:
      i = 18;
   20258:	e3a03012 	mov	r3, #18
   2025c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      ndigits = 0;
   20260:	e3a03000 	mov	r3, #0
   20264:	e58b3008 	str	r3, [fp, #8]
      break;
   20268:	ea00001e 	b	202e8 <_dtoa_r+0x618>
    case 2:
      leftright = 0;
   2026c:	e3a03000 	mov	r3, #0
   20270:	e50b3040 	str	r3, [fp, #-64]	; 0x40
      /* no break */
    case 4:
      if (ndigits <= 0)
   20274:	e59b3008 	ldr	r3, [fp, #8]
   20278:	e3530000 	cmp	r3, #0
   2027c:	ca000001 	bgt	20288 <_dtoa_r+0x5b8>
	ndigits = 1;
   20280:	e3a03001 	mov	r3, #1
   20284:	e58b3008 	str	r3, [fp, #8]
      ilim = ilim1 = i = ndigits;
   20288:	e59b3008 	ldr	r3, [fp, #8]
   2028c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   20290:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   20294:	e50b3030 	str	r3, [fp, #-48]	; 0x30
   20298:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2029c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
      break;
   202a0:	ea000010 	b	202e8 <_dtoa_r+0x618>
    case 3:
      leftright = 0;
   202a4:	e3a03000 	mov	r3, #0
   202a8:	e50b3040 	str	r3, [fp, #-64]	; 0x40
      /* no break */
    case 5:
      i = ndigits + k + 1;
   202ac:	e59b2008 	ldr	r2, [fp, #8]
   202b0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   202b4:	e0823003 	add	r3, r2, r3
   202b8:	e2833001 	add	r3, r3, #1
   202bc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      ilim = i;
   202c0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   202c4:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
      ilim1 = i - 1;
   202c8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   202cc:	e2433001 	sub	r3, r3, #1
   202d0:	e50b3030 	str	r3, [fp, #-48]	; 0x30
      if (i <= 0)
   202d4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   202d8:	e3530000 	cmp	r3, #0
   202dc:	ca000001 	bgt	202e8 <_dtoa_r+0x618>
	i = 1;
   202e0:	e3a03001 	mov	r3, #1
   202e4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    }
  j = sizeof (__ULong);
   202e8:	e3a03004 	mov	r3, #4
   202ec:	e50b3034 	str	r3, [fp, #-52]	; 0x34
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   202f0:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   202f4:	e3a02000 	mov	r2, #0
   202f8:	e5832044 	str	r2, [r3, #68]	; 0x44
   202fc:	ea00001a 	b	2036c <_dtoa_r+0x69c>
   20300:	636f4361 	.word	0x636f4361
   20304:	3fd287a7 	.word	0x3fd287a7
   20308:	8b60c8b3 	.word	0x8b60c8b3
   2030c:	3fc68a28 	.word	0x3fc68a28
   20310:	509f79fb 	.word	0x509f79fb
   20314:	3fd34413 	.word	0x3fd34413
   20318:	0000270f 	.word	0x0000270f
   2031c:	0003315c 	.word	0x0003315c
   20320:	00033168 	.word	0x00033168
   20324:	0003316c 	.word	0x0003316c
   20328:	3ff80000 	.word	0x3ff80000
   2032c:	00033250 	.word	0x00033250
   20330:	401c0000 	.word	0x401c0000
   20334:	3ff00000 	.word	0x3ff00000
   20338:	3fe00000 	.word	0x3fe00000
   2033c:	00033188 	.word	0x00033188
   20340:	40140000 	.word	0x40140000
   20344:	40240000 	.word	0x40240000
   20348:	7ff00000 	.word	0x7ff00000
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
   2034c:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   20350:	e5933044 	ldr	r3, [r3, #68]	; 0x44
   20354:	e2832001 	add	r2, r3, #1
   20358:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2035c:	e5832044 	str	r2, [r3, #68]	; 0x44
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
   20360:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   20364:	e1a03083 	lsl	r3, r3, #1
   20368:	e50b3034 	str	r3, [fp, #-52]	; 0x34
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   2036c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   20370:	e2832014 	add	r2, r3, #20
   20374:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   20378:	e1520003 	cmp	r2, r3
   2037c:	9afffff2 	bls	2034c <_dtoa_r+0x67c>
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   20380:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   20384:	e5933044 	ldr	r3, [r3, #68]	; 0x44
   20388:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   2038c:	e1a01003 	mov	r1, r3
   20390:	eb000996 	bl	229f0 <_Balloc>
   20394:	e1a02000 	mov	r2, r0
   20398:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2039c:	e5832040 	str	r2, [r3, #64]	; 0x40
  s = s0 = (char *) _REENT_MP_RESULT(ptr);
   203a0:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   203a4:	e5933040 	ldr	r3, [r3, #64]	; 0x40
   203a8:	e50b3080 	str	r3, [fp, #-128]	; 0x80
   203ac:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
   203b0:	e50b3078 	str	r3, [fp, #-120]	; 0x78

  if (ilim >= 0 && ilim <= Quick_max && try_quick)
   203b4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   203b8:	e3530000 	cmp	r3, #0
   203bc:	ba0001f3 	blt	20b90 <_dtoa_r+0xec0>
   203c0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   203c4:	e353000e 	cmp	r3, #14
   203c8:	ca0001f0 	bgt	20b90 <_dtoa_r+0xec0>
   203cc:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   203d0:	e3530000 	cmp	r3, #0
   203d4:	0a0001ed 	beq	20b90 <_dtoa_r+0xec0>
    {
      /* Try to get by with floating-point arithmetic. */

      i = 0;
   203d8:	e3a03000 	mov	r3, #0
   203dc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      d2.d = d.d;
   203e0:	e24b30ac 	sub	r3, fp, #172	; 0xac
   203e4:	e893000c 	ldm	r3, {r2, r3}
   203e8:	e50b20b4 	str	r2, [fp, #-180]	; 0xb4
   203ec:	e50b30b0 	str	r3, [fp, #-176]	; 0xb0
      k0 = k;
   203f0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   203f4:	e50b3084 	str	r3, [fp, #-132]	; 0x84
      ilim0 = ilim;
   203f8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   203fc:	e50b3088 	str	r3, [fp, #-136]	; 0x88
      ieps = 2;			/* conservative */
   20400:	e3a03002 	mov	r3, #2
   20404:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      if (k > 0)
   20408:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2040c:	e3530000 	cmp	r3, #0
   20410:	da000047 	ble	20534 <_dtoa_r+0x864>
	{
	  ds = tens[k & 0xf];
   20414:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   20418:	e203300f 	and	r3, r3, #15
   2041c:	e51f20e8 	ldr	r2, [pc, #-232]	; 2033c <_dtoa_r+0x66c>
   20420:	e1a03183 	lsl	r3, r3, #3
   20424:	e0823003 	add	r3, r2, r3
   20428:	e893000c 	ldm	r3, {r2, r3}
   2042c:	e50b2074 	str	r2, [fp, #-116]	; 0x74
   20430:	e50b3070 	str	r3, [fp, #-112]	; 0x70
	  j = k >> 4;
   20434:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   20438:	e1a03243 	asr	r3, r3, #4
   2043c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	  if (j & Bletch)
   20440:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   20444:	e2033010 	and	r3, r3, #16
   20448:	e3530000 	cmp	r3, #0
   2044c:	0a00000f 	beq	20490 <_dtoa_r+0x7c0>
	    {
	      /* prevent overflows */
	      j &= Bletch - 1;
   20450:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   20454:	e203300f 	and	r3, r3, #15
   20458:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	      d.d /= bigtens[n_bigtens - 1];
   2045c:	e24b10ac 	sub	r1, fp, #172	; 0xac
   20460:	e8910003 	ldm	r1, {r0, r1}
   20464:	e51f3140 	ldr	r3, [pc, #-320]	; 2032c <_dtoa_r+0x65c>
   20468:	e2833020 	add	r3, r3, #32
   2046c:	e893000c 	ldm	r3, {r2, r3}
   20470:	ebffd246 	bl	14d90 <__aeabi_ddiv>
   20474:	e1a02000 	mov	r2, r0
   20478:	e1a03001 	mov	r3, r1
   2047c:	e50b20ac 	str	r2, [fp, #-172]	; 0xac
   20480:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
	      ieps++;
   20484:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   20488:	e2833001 	add	r3, r3, #1
   2048c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	    }
	  for (; j; j >>= 1, i++)
   20490:	ea000018 	b	204f8 <_dtoa_r+0x828>
	    if (j & 1)
   20494:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   20498:	e2033001 	and	r3, r3, #1
   2049c:	e3530000 	cmp	r3, #0
   204a0:	0a00000e 	beq	204e0 <_dtoa_r+0x810>
	      {
		ieps++;
   204a4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   204a8:	e2833001 	add	r3, r3, #1
   204ac:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		ds *= bigtens[i];
   204b0:	e51f218c 	ldr	r2, [pc, #-396]	; 2032c <_dtoa_r+0x65c>
   204b4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   204b8:	e1a03183 	lsl	r3, r3, #3
   204bc:	e0823003 	add	r3, r2, r3
   204c0:	e893000c 	ldm	r3, {r2, r3}
   204c4:	e24b1074 	sub	r1, fp, #116	; 0x74
   204c8:	e8910003 	ldm	r1, {r0, r1}
   204cc:	ebffd18b 	bl	14b00 <__aeabi_dmul>
   204d0:	e1a02000 	mov	r2, r0
   204d4:	e1a03001 	mov	r3, r1
   204d8:	e50b2074 	str	r2, [fp, #-116]	; 0x74
   204dc:	e50b3070 	str	r3, [fp, #-112]	; 0x70
	      /* prevent overflows */
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
   204e0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   204e4:	e1a030c3 	asr	r3, r3, #1
   204e8:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   204ec:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   204f0:	e2833001 	add	r3, r3, #1
   204f4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   204f8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   204fc:	e3530000 	cmp	r3, #0
   20500:	1affffe3 	bne	20494 <_dtoa_r+0x7c4>
	    if (j & 1)
	      {
		ieps++;
		ds *= bigtens[i];
	      }
	  d.d /= ds;
   20504:	e24b30ac 	sub	r3, fp, #172	; 0xac
   20508:	e893000c 	ldm	r3, {r2, r3}
   2050c:	e1a00002 	mov	r0, r2
   20510:	e1a01003 	mov	r1, r3
   20514:	e24b3074 	sub	r3, fp, #116	; 0x74
   20518:	e893000c 	ldm	r3, {r2, r3}
   2051c:	ebffd21b 	bl	14d90 <__aeabi_ddiv>
   20520:	e1a02000 	mov	r2, r0
   20524:	e1a03001 	mov	r3, r1
   20528:	e50b20ac 	str	r2, [fp, #-172]	; 0xac
   2052c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   20530:	ea000032 	b	20600 <_dtoa_r+0x930>
	}
      else if ((j1 = -k) != 0)
   20534:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   20538:	e2633000 	rsb	r3, r3, #0
   2053c:	e50b308c 	str	r3, [fp, #-140]	; 0x8c
   20540:	e51b308c 	ldr	r3, [fp, #-140]	; 0x8c
   20544:	e3530000 	cmp	r3, #0
   20548:	0a00002c 	beq	20600 <_dtoa_r+0x930>
	{
	  d.d *= tens[j1 & 0xf];
   2054c:	e24b10ac 	sub	r1, fp, #172	; 0xac
   20550:	e8910003 	ldm	r1, {r0, r1}
   20554:	e51b308c 	ldr	r3, [fp, #-140]	; 0x8c
   20558:	e203300f 	and	r3, r3, #15
   2055c:	e51f2228 	ldr	r2, [pc, #-552]	; 2033c <_dtoa_r+0x66c>
   20560:	e1a03183 	lsl	r3, r3, #3
   20564:	e0823003 	add	r3, r2, r3
   20568:	e893000c 	ldm	r3, {r2, r3}
   2056c:	ebffd163 	bl	14b00 <__aeabi_dmul>
   20570:	e1a02000 	mov	r2, r0
   20574:	e1a03001 	mov	r3, r1
   20578:	e50b20ac 	str	r2, [fp, #-172]	; 0xac
   2057c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
	  for (j = j1 >> 4; j; j >>= 1, i++)
   20580:	e51b308c 	ldr	r3, [fp, #-140]	; 0x8c
   20584:	e1a03243 	asr	r3, r3, #4
   20588:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2058c:	ea000018 	b	205f4 <_dtoa_r+0x924>
	    if (j & 1)
   20590:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   20594:	e2033001 	and	r3, r3, #1
   20598:	e3530000 	cmp	r3, #0
   2059c:	0a00000e 	beq	205dc <_dtoa_r+0x90c>
	      {
		ieps++;
   205a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   205a4:	e2833001 	add	r3, r3, #1
   205a8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		d.d *= bigtens[i];
   205ac:	e24b10ac 	sub	r1, fp, #172	; 0xac
   205b0:	e8910003 	ldm	r1, {r0, r1}
   205b4:	e51f2290 	ldr	r2, [pc, #-656]	; 2032c <_dtoa_r+0x65c>
   205b8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   205bc:	e1a03183 	lsl	r3, r3, #3
   205c0:	e0823003 	add	r3, r2, r3
   205c4:	e893000c 	ldm	r3, {r2, r3}
   205c8:	ebffd14c 	bl	14b00 <__aeabi_dmul>
   205cc:	e1a02000 	mov	r2, r0
   205d0:	e1a03001 	mov	r3, r1
   205d4:	e50b20ac 	str	r2, [fp, #-172]	; 0xac
   205d8:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
   205dc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   205e0:	e1a030c3 	asr	r3, r3, #1
   205e4:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   205e8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   205ec:	e2833001 	add	r3, r3, #1
   205f0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   205f4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   205f8:	e3530000 	cmp	r3, #0
   205fc:	1affffe3 	bne	20590 <_dtoa_r+0x8c0>
	      {
		ieps++;
		d.d *= bigtens[i];
	      }
	}
      if (k_check && d.d < 1. && ilim > 0)
   20600:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   20604:	e3530000 	cmp	r3, #0
   20608:	0a000023 	beq	2069c <_dtoa_r+0x9cc>
   2060c:	e24b30ac 	sub	r3, fp, #172	; 0xac
   20610:	e893000c 	ldm	r3, {r2, r3}
   20614:	e1a00002 	mov	r0, r2
   20618:	e1a01003 	mov	r1, r3
   2061c:	e3a02000 	mov	r2, #0
   20620:	e51f32f4 	ldr	r3, [pc, #-756]	; 20334 <_dtoa_r+0x664>
   20624:	ebffd295 	bl	15080 <__aeabi_dcmplt>
   20628:	e1a03000 	mov	r3, r0
   2062c:	e3530000 	cmp	r3, #0
   20630:	0a000019 	beq	2069c <_dtoa_r+0x9cc>
   20634:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   20638:	e3530000 	cmp	r3, #0
   2063c:	da000016 	ble	2069c <_dtoa_r+0x9cc>
	{
	  if (ilim1 <= 0)
   20640:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   20644:	e3530000 	cmp	r3, #0
   20648:	ca000000 	bgt	20650 <_dtoa_r+0x980>
	    goto fast_failed;
   2064c:	ea000145 	b	20b68 <_dtoa_r+0xe98>
	  ilim = ilim1;
   20650:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   20654:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	  k--;
   20658:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2065c:	e2433001 	sub	r3, r3, #1
   20660:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	  d.d *= 10.;
   20664:	e24b30ac 	sub	r3, fp, #172	; 0xac
   20668:	e893000c 	ldm	r3, {r2, r3}
   2066c:	e1a00002 	mov	r0, r2
   20670:	e1a01003 	mov	r1, r3
   20674:	e3a02000 	mov	r2, #0
   20678:	e51f333c 	ldr	r3, [pc, #-828]	; 20344 <_dtoa_r+0x674>
   2067c:	ebffd11f 	bl	14b00 <__aeabi_dmul>
   20680:	e1a02000 	mov	r2, r0
   20684:	e1a03001 	mov	r3, r1
   20688:	e50b20ac 	str	r2, [fp, #-172]	; 0xac
   2068c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
	  ieps++;
   20690:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   20694:	e2833001 	add	r3, r3, #1
   20698:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	}
      eps.d = ieps * d.d + 7.;
   2069c:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
   206a0:	ebffd0df 	bl	14a24 <__aeabi_i2d>
   206a4:	e24b30ac 	sub	r3, fp, #172	; 0xac
   206a8:	e893000c 	ldm	r3, {r2, r3}
   206ac:	ebffd113 	bl	14b00 <__aeabi_dmul>
   206b0:	e1a02000 	mov	r2, r0
   206b4:	e1a03001 	mov	r3, r1
   206b8:	e1a00002 	mov	r0, r2
   206bc:	e1a01003 	mov	r1, r3
   206c0:	e3a02000 	mov	r2, #0
   206c4:	e51f339c 	ldr	r3, [pc, #-924]	; 20330 <_dtoa_r+0x660>
   206c8:	ebffd008 	bl	146f0 <__adddf3>
   206cc:	e1a02000 	mov	r2, r0
   206d0:	e1a03001 	mov	r3, r1
   206d4:	e50b20bc 	str	r2, [fp, #-188]	; 0xbc
   206d8:	e50b30b8 	str	r3, [fp, #-184]	; 0xb8
      word0 (eps) -= (P - 1) * Exp_msk1;
   206dc:	e51b30b8 	ldr	r3, [fp, #-184]	; 0xb8
   206e0:	e243350d 	sub	r3, r3, #54525952	; 0x3400000
   206e4:	e50b30b8 	str	r3, [fp, #-184]	; 0xb8
      if (ilim == 0)
   206e8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   206ec:	e3530000 	cmp	r3, #0
   206f0:	1a000025 	bne	2078c <_dtoa_r+0xabc>
	{
	  S = mhi = 0;
   206f4:	e3a03000 	mov	r3, #0
   206f8:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   206fc:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   20700:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
	  d.d -= 5.;
   20704:	e24b30ac 	sub	r3, fp, #172	; 0xac
   20708:	e893000c 	ldm	r3, {r2, r3}
   2070c:	e1a00002 	mov	r0, r2
   20710:	e1a01003 	mov	r1, r3
   20714:	e3a02000 	mov	r2, #0
   20718:	e51f33e0 	ldr	r3, [pc, #-992]	; 20340 <_dtoa_r+0x670>
   2071c:	ebffcff2 	bl	146ec <__aeabi_dsub>
   20720:	e1a02000 	mov	r2, r0
   20724:	e1a03001 	mov	r3, r1
   20728:	e50b20ac 	str	r2, [fp, #-172]	; 0xac
   2072c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
	  if (d.d > eps.d)
   20730:	e24b10ac 	sub	r1, fp, #172	; 0xac
   20734:	e8910003 	ldm	r1, {r0, r1}
   20738:	e24b30bc 	sub	r3, fp, #188	; 0xbc
   2073c:	e893000c 	ldm	r3, {r2, r3}
   20740:	ebffd260 	bl	150c8 <__aeabi_dcmpgt>
   20744:	e1a03000 	mov	r3, r0
   20748:	e3530000 	cmp	r3, #0
   2074c:	0a000000 	beq	20754 <_dtoa_r+0xa84>
	    goto one_digit;
   20750:	ea000301 	b	2135c <_dtoa_r+0x168c>
	  if (d.d < -eps.d)
   20754:	e24b10ac 	sub	r1, fp, #172	; 0xac
   20758:	e8910003 	ldm	r1, {r0, r1}
   2075c:	e24b30bc 	sub	r3, fp, #188	; 0xbc
   20760:	e893000c 	ldm	r3, {r2, r3}
   20764:	e1a04002 	mov	r4, r2
   20768:	e2235102 	eor	r5, r3, #-2147483648	; 0x80000000
   2076c:	e1a02004 	mov	r2, r4
   20770:	e1a03005 	mov	r3, r5
   20774:	ebffd241 	bl	15080 <__aeabi_dcmplt>
   20778:	e1a03000 	mov	r3, r0
   2077c:	e3530000 	cmp	r3, #0
   20780:	1a000000 	bne	20788 <_dtoa_r+0xab8>
	    goto no_digits;
	  goto fast_failed;
   20784:	ea0000f7 	b	20b68 <_dtoa_r+0xe98>
	  S = mhi = 0;
	  d.d -= 5.;
	  if (d.d > eps.d)
	    goto one_digit;
	  if (d.d < -eps.d)
	    goto no_digits;
   20788:	ea0002ef 	b	2134c <_dtoa_r+0x167c>
	  goto fast_failed;
	}
#ifndef No_leftright
      if (leftright)
   2078c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   20790:	e3530000 	cmp	r3, #0
   20794:	0a00007c 	beq	2098c <_dtoa_r+0xcbc>
	{
	  /* Use Steele & White method of only
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
   20798:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   2079c:	e2433001 	sub	r3, r3, #1
   207a0:	e51f246c 	ldr	r2, [pc, #-1132]	; 2033c <_dtoa_r+0x66c>
   207a4:	e1a03183 	lsl	r3, r3, #3
   207a8:	e0823003 	add	r3, r2, r3
   207ac:	e8930018 	ldm	r3, {r3, r4}
   207b0:	e3a00000 	mov	r0, #0
   207b4:	e51f1484 	ldr	r1, [pc, #-1156]	; 20338 <_dtoa_r+0x668>
   207b8:	e1a02003 	mov	r2, r3
   207bc:	e1a03004 	mov	r3, r4
   207c0:	ebffd172 	bl	14d90 <__aeabi_ddiv>
   207c4:	e1a03000 	mov	r3, r0
   207c8:	e1a04001 	mov	r4, r1
   207cc:	e1a01003 	mov	r1, r3
   207d0:	e1a02004 	mov	r2, r4
   207d4:	e24b40bc 	sub	r4, fp, #188	; 0xbc
   207d8:	e8940018 	ldm	r4, {r3, r4}
   207dc:	e1a00001 	mov	r0, r1
   207e0:	e1a01002 	mov	r1, r2
   207e4:	e1a02003 	mov	r2, r3
   207e8:	e1a03004 	mov	r3, r4
   207ec:	ebffcfbe 	bl	146ec <__aeabi_dsub>
   207f0:	e1a03000 	mov	r3, r0
   207f4:	e1a04001 	mov	r4, r1
   207f8:	e50b30bc 	str	r3, [fp, #-188]	; 0xbc
   207fc:	e50b40b8 	str	r4, [fp, #-184]	; 0xb8
	  for (i = 0;;)
   20800:	e3a03000 	mov	r3, #0
   20804:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	    {
	      L = d.d;
   20808:	e24b40ac 	sub	r4, fp, #172	; 0xac
   2080c:	e8940018 	ldm	r4, {r3, r4}
   20810:	e1a00003 	mov	r0, r3
   20814:	e1a01004 	mov	r1, r4
   20818:	ebffd230 	bl	150e0 <__aeabi_d2iz>
   2081c:	e1a03000 	mov	r3, r0
   20820:	e50b3090 	str	r3, [fp, #-144]	; 0x90
	      d.d -= L;
   20824:	e24b60ac 	sub	r6, fp, #172	; 0xac
   20828:	e8960060 	ldm	r6, {r5, r6}
   2082c:	e51b0090 	ldr	r0, [fp, #-144]	; 0x90
   20830:	ebffd07b 	bl	14a24 <__aeabi_i2d>
   20834:	e1a03000 	mov	r3, r0
   20838:	e1a04001 	mov	r4, r1
   2083c:	e1a00005 	mov	r0, r5
   20840:	e1a01006 	mov	r1, r6
   20844:	e1a02003 	mov	r2, r3
   20848:	e1a03004 	mov	r3, r4
   2084c:	ebffcfa6 	bl	146ec <__aeabi_dsub>
   20850:	e1a03000 	mov	r3, r0
   20854:	e1a04001 	mov	r4, r1
   20858:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   2085c:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
	      *s++ = '0' + (int) L;
   20860:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   20864:	e2832001 	add	r2, r3, #1
   20868:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   2086c:	e51b2090 	ldr	r2, [fp, #-144]	; 0x90
   20870:	e20220ff 	and	r2, r2, #255	; 0xff
   20874:	e2822030 	add	r2, r2, #48	; 0x30
   20878:	e20220ff 	and	r2, r2, #255	; 0xff
   2087c:	e5c32000 	strb	r2, [r3]
	      if (d.d < eps.d)
   20880:	e24b20ac 	sub	r2, fp, #172	; 0xac
   20884:	e8920006 	ldm	r2, {r1, r2}
   20888:	e24b40bc 	sub	r4, fp, #188	; 0xbc
   2088c:	e8940018 	ldm	r4, {r3, r4}
   20890:	e1a00001 	mov	r0, r1
   20894:	e1a01002 	mov	r1, r2
   20898:	e1a02003 	mov	r2, r3
   2089c:	e1a03004 	mov	r3, r4
   208a0:	ebffd1f6 	bl	15080 <__aeabi_dcmplt>
   208a4:	e1a03000 	mov	r3, r0
   208a8:	e3530000 	cmp	r3, #0
   208ac:	0a000000 	beq	208b4 <_dtoa_r+0xbe4>
		goto ret1;
   208b0:	ea0003f1 	b	2187c <_dtoa_r+0x1bac>
	      if (1. - d.d < eps.d)
   208b4:	e24b40ac 	sub	r4, fp, #172	; 0xac
   208b8:	e8940018 	ldm	r4, {r3, r4}
   208bc:	e3a00000 	mov	r0, #0
   208c0:	e51f1594 	ldr	r1, [pc, #-1428]	; 20334 <_dtoa_r+0x664>
   208c4:	e1a02003 	mov	r2, r3
   208c8:	e1a03004 	mov	r3, r4
   208cc:	ebffcf86 	bl	146ec <__aeabi_dsub>
   208d0:	e1a03000 	mov	r3, r0
   208d4:	e1a04001 	mov	r4, r1
   208d8:	e1a01003 	mov	r1, r3
   208dc:	e1a02004 	mov	r2, r4
   208e0:	e24b40bc 	sub	r4, fp, #188	; 0xbc
   208e4:	e8940018 	ldm	r4, {r3, r4}
   208e8:	e1a00001 	mov	r0, r1
   208ec:	e1a01002 	mov	r1, r2
   208f0:	e1a02003 	mov	r2, r3
   208f4:	e1a03004 	mov	r3, r4
   208f8:	ebffd1e0 	bl	15080 <__aeabi_dcmplt>
   208fc:	e1a03000 	mov	r3, r0
   20900:	e3530000 	cmp	r3, #0
   20904:	0a000000 	beq	2090c <_dtoa_r+0xc3c>
		goto bump_up;
   20908:	ea000122 	b	20d98 <_dtoa_r+0x10c8>
	      if (++i >= ilim)
   2090c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   20910:	e2833001 	add	r3, r3, #1
   20914:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   20918:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   2091c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   20920:	e1520003 	cmp	r2, r3
   20924:	ba000001 	blt	20930 <_dtoa_r+0xc60>
		break;
   20928:	e1a00000 	nop			; (mov r0, r0)
   2092c:	ea00008d 	b	20b68 <_dtoa_r+0xe98>
	      eps.d *= 10.;
   20930:	e24b40bc 	sub	r4, fp, #188	; 0xbc
   20934:	e8940018 	ldm	r4, {r3, r4}
   20938:	e1a00003 	mov	r0, r3
   2093c:	e1a01004 	mov	r1, r4
   20940:	e3a02000 	mov	r2, #0
   20944:	e51f3608 	ldr	r3, [pc, #-1544]	; 20344 <_dtoa_r+0x674>
   20948:	ebffd06c 	bl	14b00 <__aeabi_dmul>
   2094c:	e1a03000 	mov	r3, r0
   20950:	e1a04001 	mov	r4, r1
   20954:	e50b30bc 	str	r3, [fp, #-188]	; 0xbc
   20958:	e50b40b8 	str	r4, [fp, #-184]	; 0xb8
	      d.d *= 10.;
   2095c:	e24b40ac 	sub	r4, fp, #172	; 0xac
   20960:	e8940018 	ldm	r4, {r3, r4}
   20964:	e1a00003 	mov	r0, r3
   20968:	e1a01004 	mov	r1, r4
   2096c:	e3a02000 	mov	r2, #0
   20970:	e51f3634 	ldr	r3, [pc, #-1588]	; 20344 <_dtoa_r+0x674>
   20974:	ebffd061 	bl	14b00 <__aeabi_dmul>
   20978:	e1a03000 	mov	r3, r0
   2097c:	e1a04001 	mov	r4, r1
   20980:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   20984:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
	    }
   20988:	eaffff9e 	b	20808 <_dtoa_r+0xb38>
	}
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
   2098c:	e24b20bc 	sub	r2, fp, #188	; 0xbc
   20990:	e8920006 	ldm	r2, {r1, r2}
   20994:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   20998:	e2433001 	sub	r3, r3, #1
   2099c:	e51f0668 	ldr	r0, [pc, #-1640]	; 2033c <_dtoa_r+0x66c>
   209a0:	e1a03183 	lsl	r3, r3, #3
   209a4:	e0803003 	add	r3, r0, r3
   209a8:	e8930018 	ldm	r3, {r3, r4}
   209ac:	e1a00001 	mov	r0, r1
   209b0:	e1a01002 	mov	r1, r2
   209b4:	e1a02003 	mov	r2, r3
   209b8:	e1a03004 	mov	r3, r4
   209bc:	ebffd04f 	bl	14b00 <__aeabi_dmul>
   209c0:	e1a03000 	mov	r3, r0
   209c4:	e1a04001 	mov	r4, r1
   209c8:	e50b30bc 	str	r3, [fp, #-188]	; 0xbc
   209cc:	e50b40b8 	str	r4, [fp, #-184]	; 0xb8
	  for (i = 1;; i++, d.d *= 10.)
   209d0:	e3a03001 	mov	r3, #1
   209d4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	    {
	      L = d.d;
   209d8:	e24b40ac 	sub	r4, fp, #172	; 0xac
   209dc:	e8940018 	ldm	r4, {r3, r4}
   209e0:	e1a00003 	mov	r0, r3
   209e4:	e1a01004 	mov	r1, r4
   209e8:	ebffd1bc 	bl	150e0 <__aeabi_d2iz>
   209ec:	e1a03000 	mov	r3, r0
   209f0:	e50b3090 	str	r3, [fp, #-144]	; 0x90
	      d.d -= L;
   209f4:	e24b60ac 	sub	r6, fp, #172	; 0xac
   209f8:	e8960060 	ldm	r6, {r5, r6}
   209fc:	e51b0090 	ldr	r0, [fp, #-144]	; 0x90
   20a00:	ebffd007 	bl	14a24 <__aeabi_i2d>
   20a04:	e1a03000 	mov	r3, r0
   20a08:	e1a04001 	mov	r4, r1
   20a0c:	e1a00005 	mov	r0, r5
   20a10:	e1a01006 	mov	r1, r6
   20a14:	e1a02003 	mov	r2, r3
   20a18:	e1a03004 	mov	r3, r4
   20a1c:	ebffcf32 	bl	146ec <__aeabi_dsub>
   20a20:	e1a03000 	mov	r3, r0
   20a24:	e1a04001 	mov	r4, r1
   20a28:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   20a2c:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
	      *s++ = '0' + (int) L;
   20a30:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   20a34:	e2832001 	add	r2, r3, #1
   20a38:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   20a3c:	e51b2090 	ldr	r2, [fp, #-144]	; 0x90
   20a40:	e20220ff 	and	r2, r2, #255	; 0xff
   20a44:	e2822030 	add	r2, r2, #48	; 0x30
   20a48:	e20220ff 	and	r2, r2, #255	; 0xff
   20a4c:	e5c32000 	strb	r2, [r3]
	      if (i == ilim)
   20a50:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   20a54:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   20a58:	e1520003 	cmp	r2, r3
   20a5c:	1a000032 	bne	20b2c <_dtoa_r+0xe5c>
		{
		  if (d.d > 0.5 + eps.d)
   20a60:	e24b60ac 	sub	r6, fp, #172	; 0xac
   20a64:	e8960060 	ldm	r6, {r5, r6}
   20a68:	e24b40bc 	sub	r4, fp, #188	; 0xbc
   20a6c:	e8940018 	ldm	r4, {r3, r4}
   20a70:	e1a00003 	mov	r0, r3
   20a74:	e1a01004 	mov	r1, r4
   20a78:	e3a02000 	mov	r2, #0
   20a7c:	e51f374c 	ldr	r3, [pc, #-1868]	; 20338 <_dtoa_r+0x668>
   20a80:	ebffcf1a 	bl	146f0 <__adddf3>
   20a84:	e1a03000 	mov	r3, r0
   20a88:	e1a04001 	mov	r4, r1
   20a8c:	e1a00005 	mov	r0, r5
   20a90:	e1a01006 	mov	r1, r6
   20a94:	e1a02003 	mov	r2, r3
   20a98:	e1a03004 	mov	r3, r4
   20a9c:	ebffd189 	bl	150c8 <__aeabi_dcmpgt>
   20aa0:	e1a03000 	mov	r3, r0
   20aa4:	e3530000 	cmp	r3, #0
   20aa8:	0a000000 	beq	20ab0 <_dtoa_r+0xde0>
		    goto bump_up;
   20aac:	ea0000b9 	b	20d98 <_dtoa_r+0x10c8>
		  else if (d.d < 0.5 - eps.d)
   20ab0:	e24b60ac 	sub	r6, fp, #172	; 0xac
   20ab4:	e8960060 	ldm	r6, {r5, r6}
   20ab8:	e24b40bc 	sub	r4, fp, #188	; 0xbc
   20abc:	e8940018 	ldm	r4, {r3, r4}
   20ac0:	e3a00000 	mov	r0, #0
   20ac4:	e51f1794 	ldr	r1, [pc, #-1940]	; 20338 <_dtoa_r+0x668>
   20ac8:	e1a02003 	mov	r2, r3
   20acc:	e1a03004 	mov	r3, r4
   20ad0:	ebffcf05 	bl	146ec <__aeabi_dsub>
   20ad4:	e1a03000 	mov	r3, r0
   20ad8:	e1a04001 	mov	r4, r1
   20adc:	e1a00005 	mov	r0, r5
   20ae0:	e1a01006 	mov	r1, r6
   20ae4:	e1a02003 	mov	r2, r3
   20ae8:	e1a03004 	mov	r3, r4
   20aec:	ebffd163 	bl	15080 <__aeabi_dcmplt>
   20af0:	e1a03000 	mov	r3, r0
   20af4:	e3530000 	cmp	r3, #0
   20af8:	1a000000 	bne	20b00 <_dtoa_r+0xe30>
		    {
		      while (*--s == '0');
		      s++;
		      goto ret1;
		    }
		  break;
   20afc:	ea000019 	b	20b68 <_dtoa_r+0xe98>
		{
		  if (d.d > 0.5 + eps.d)
		    goto bump_up;
		  else if (d.d < 0.5 - eps.d)
		    {
		      while (*--s == '0');
   20b00:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   20b04:	e2433001 	sub	r3, r3, #1
   20b08:	e50b3078 	str	r3, [fp, #-120]	; 0x78
   20b0c:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   20b10:	e5d33000 	ldrb	r3, [r3]
   20b14:	e3530030 	cmp	r3, #48	; 0x30
   20b18:	0afffff8 	beq	20b00 <_dtoa_r+0xe30>
		      s++;
   20b1c:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   20b20:	e2833001 	add	r3, r3, #1
   20b24:	e50b3078 	str	r3, [fp, #-120]	; 0x78
		      goto ret1;
   20b28:	ea000353 	b	2187c <_dtoa_r+0x1bac>
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
   20b2c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   20b30:	e2833001 	add	r3, r3, #1
   20b34:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   20b38:	e24b40ac 	sub	r4, fp, #172	; 0xac
   20b3c:	e8940018 	ldm	r4, {r3, r4}
   20b40:	e1a00003 	mov	r0, r3
   20b44:	e1a01004 	mov	r1, r4
   20b48:	e3a02000 	mov	r2, #0
   20b4c:	e51f3810 	ldr	r3, [pc, #-2064]	; 20344 <_dtoa_r+0x674>
   20b50:	ebffcfea 	bl	14b00 <__aeabi_dmul>
   20b54:	e1a03000 	mov	r3, r0
   20b58:	e1a04001 	mov	r4, r1
   20b5c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   20b60:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
		      s++;
		      goto ret1;
		    }
		  break;
		}
	    }
   20b64:	eaffff9b 	b	209d8 <_dtoa_r+0xd08>
#ifndef No_leftright
	}
#endif
    fast_failed:
      s = s0;
   20b68:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
   20b6c:	e50b3078 	str	r3, [fp, #-120]	; 0x78
      d.d = d2.d;
   20b70:	e24b40b4 	sub	r4, fp, #180	; 0xb4
   20b74:	e8940018 	ldm	r4, {r3, r4}
   20b78:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   20b7c:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
      k = k0;
   20b80:	e51b3084 	ldr	r3, [fp, #-132]	; 0x84
   20b84:	e50b3038 	str	r3, [fp, #-56]	; 0x38
      ilim = ilim0;
   20b88:	e51b3088 	ldr	r3, [fp, #-136]	; 0x88
   20b8c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    }

  /* Do we have a "small" integer? */

  if (be >= 0 && k <= Int_max)
   20b90:	e51b30a0 	ldr	r3, [fp, #-160]	; 0xa0
   20b94:	e3530000 	cmp	r3, #0
   20b98:	ba0000b5 	blt	20e74 <_dtoa_r+0x11a4>
   20b9c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   20ba0:	e353000e 	cmp	r3, #14
   20ba4:	ca0000b2 	bgt	20e74 <_dtoa_r+0x11a4>
    {
      /* Yes. */
      ds = tens[k];
   20ba8:	e51f2874 	ldr	r2, [pc, #-2164]	; 2033c <_dtoa_r+0x66c>
   20bac:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   20bb0:	e1a03183 	lsl	r3, r3, #3
   20bb4:	e0823003 	add	r3, r2, r3
   20bb8:	e8930018 	ldm	r3, {r3, r4}
   20bbc:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   20bc0:	e50b4070 	str	r4, [fp, #-112]	; 0x70
      if (ndigits < 0 && ilim <= 0)
   20bc4:	e59b3008 	ldr	r3, [fp, #8]
   20bc8:	e3530000 	cmp	r3, #0
   20bcc:	aa00001b 	bge	20c40 <_dtoa_r+0xf70>
   20bd0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   20bd4:	e3530000 	cmp	r3, #0
   20bd8:	ca000018 	bgt	20c40 <_dtoa_r+0xf70>
	{
	  S = mhi = 0;
   20bdc:	e3a03000 	mov	r3, #0
   20be0:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   20be4:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   20be8:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
	  if (ilim < 0 || d.d <= 5 * ds)
   20bec:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   20bf0:	e3530000 	cmp	r3, #0
   20bf4:	ba0001d4 	blt	2134c <_dtoa_r+0x167c>
   20bf8:	e24b60ac 	sub	r6, fp, #172	; 0xac
   20bfc:	e8960060 	ldm	r6, {r5, r6}
   20c00:	e24b1074 	sub	r1, fp, #116	; 0x74
   20c04:	e8910003 	ldm	r1, {r0, r1}
   20c08:	e3a02000 	mov	r2, #0
   20c0c:	e51f38d4 	ldr	r3, [pc, #-2260]	; 20340 <_dtoa_r+0x670>
   20c10:	ebffcfba 	bl	14b00 <__aeabi_dmul>
   20c14:	e1a03000 	mov	r3, r0
   20c18:	e1a04001 	mov	r4, r1
   20c1c:	e1a00005 	mov	r0, r5
   20c20:	e1a01006 	mov	r1, r6
   20c24:	e1a02003 	mov	r2, r3
   20c28:	e1a03004 	mov	r3, r4
   20c2c:	ebffd119 	bl	15098 <__aeabi_dcmple>
   20c30:	e1a03000 	mov	r3, r0
   20c34:	e3530000 	cmp	r3, #0
   20c38:	1a0001c3 	bne	2134c <_dtoa_r+0x167c>
	    goto no_digits;
	  goto one_digit;
   20c3c:	ea0001c6 	b	2135c <_dtoa_r+0x168c>
	}
      for (i = 1;; i++)
   20c40:	e3a03001 	mov	r3, #1
   20c44:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	{
	  L = d.d / ds;
   20c48:	e24b40ac 	sub	r4, fp, #172	; 0xac
   20c4c:	e8940018 	ldm	r4, {r3, r4}
   20c50:	e1a00003 	mov	r0, r3
   20c54:	e1a01004 	mov	r1, r4
   20c58:	e24b3074 	sub	r3, fp, #116	; 0x74
   20c5c:	e893000c 	ldm	r3, {r2, r3}
   20c60:	ebffd04a 	bl	14d90 <__aeabi_ddiv>
   20c64:	e1a03000 	mov	r3, r0
   20c68:	e1a04001 	mov	r4, r1
   20c6c:	e1a00003 	mov	r0, r3
   20c70:	e1a01004 	mov	r1, r4
   20c74:	ebffd119 	bl	150e0 <__aeabi_d2iz>
   20c78:	e1a03000 	mov	r3, r0
   20c7c:	e50b3090 	str	r3, [fp, #-144]	; 0x90
	  d.d -= L * ds;
   20c80:	e24b60ac 	sub	r6, fp, #172	; 0xac
   20c84:	e8960060 	ldm	r6, {r5, r6}
   20c88:	e51b0090 	ldr	r0, [fp, #-144]	; 0x90
   20c8c:	ebffcf64 	bl	14a24 <__aeabi_i2d>
   20c90:	e1a03000 	mov	r3, r0
   20c94:	e1a04001 	mov	r4, r1
   20c98:	e1a00003 	mov	r0, r3
   20c9c:	e1a01004 	mov	r1, r4
   20ca0:	e24b3074 	sub	r3, fp, #116	; 0x74
   20ca4:	e893000c 	ldm	r3, {r2, r3}
   20ca8:	ebffcf94 	bl	14b00 <__aeabi_dmul>
   20cac:	e1a03000 	mov	r3, r0
   20cb0:	e1a04001 	mov	r4, r1
   20cb4:	e1a00005 	mov	r0, r5
   20cb8:	e1a01006 	mov	r1, r6
   20cbc:	e1a02003 	mov	r2, r3
   20cc0:	e1a03004 	mov	r3, r4
   20cc4:	ebffce88 	bl	146ec <__aeabi_dsub>
   20cc8:	e1a03000 	mov	r3, r0
   20ccc:	e1a04001 	mov	r4, r1
   20cd0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   20cd4:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   20cd8:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   20cdc:	e2832001 	add	r2, r3, #1
   20ce0:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   20ce4:	e51b2090 	ldr	r2, [fp, #-144]	; 0x90
   20ce8:	e20220ff 	and	r2, r2, #255	; 0xff
   20cec:	e2822030 	add	r2, r2, #48	; 0x30
   20cf0:	e20220ff 	and	r2, r2, #255	; 0xff
   20cf4:	e5c32000 	strb	r2, [r3]
	  if (i == ilim)
   20cf8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   20cfc:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   20d00:	e1520003 	cmp	r2, r3
   20d04:	1a00003f 	bne	20e08 <_dtoa_r+0x1138>
	    {
	      d.d += d.d;
   20d08:	e24b40ac 	sub	r4, fp, #172	; 0xac
   20d0c:	e8940018 	ldm	r4, {r3, r4}
   20d10:	e1a00003 	mov	r0, r3
   20d14:	e1a01004 	mov	r1, r4
   20d18:	e1a02003 	mov	r2, r3
   20d1c:	e1a03004 	mov	r3, r4
   20d20:	ebffce72 	bl	146f0 <__adddf3>
   20d24:	e1a03000 	mov	r3, r0
   20d28:	e1a04001 	mov	r4, r1
   20d2c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   20d30:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
   20d34:	e24b40ac 	sub	r4, fp, #172	; 0xac
   20d38:	e8940018 	ldm	r4, {r3, r4}
   20d3c:	e1a00003 	mov	r0, r3
   20d40:	e1a01004 	mov	r1, r4
   20d44:	e24b3074 	sub	r3, fp, #116	; 0x74
   20d48:	e893000c 	ldm	r3, {r2, r3}
   20d4c:	ebffd0dd 	bl	150c8 <__aeabi_dcmpgt>
   20d50:	e1a03000 	mov	r3, r0
   20d54:	e3530000 	cmp	r3, #0
   20d58:	1a00000e 	bne	20d98 <_dtoa_r+0x10c8>
   20d5c:	e24b40ac 	sub	r4, fp, #172	; 0xac
   20d60:	e8940018 	ldm	r4, {r3, r4}
   20d64:	e1a00003 	mov	r0, r3
   20d68:	e1a01004 	mov	r1, r4
   20d6c:	e24b3074 	sub	r3, fp, #116	; 0x74
   20d70:	e893000c 	ldm	r3, {r2, r3}
   20d74:	ebffd0bb 	bl	15068 <__aeabi_dcmpeq>
   20d78:	e1a03000 	mov	r3, r0
   20d7c:	e3530000 	cmp	r3, #0
   20d80:	1a000000 	bne	20d88 <_dtoa_r+0x10b8>
			*s = '0';
			break;
		      }
		  ++*s++;
		}
	      break;
   20d84:	ea000039 	b	20e70 <_dtoa_r+0x11a0>
#endif
	  *s++ = '0' + (int) L;
	  if (i == ilim)
	    {
	      d.d += d.d;
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
   20d88:	e51b3090 	ldr	r3, [fp, #-144]	; 0x90
   20d8c:	e2033001 	and	r3, r3, #1
   20d90:	e3530000 	cmp	r3, #0
   20d94:	0a00001a 	beq	20e04 <_dtoa_r+0x1134>
		{
		bump_up:
		  while (*--s == '9')
   20d98:	ea00000a 	b	20dc8 <_dtoa_r+0x10f8>
		    if (s == s0)
   20d9c:	e51b2078 	ldr	r2, [fp, #-120]	; 0x78
   20da0:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
   20da4:	e1520003 	cmp	r2, r3
   20da8:	1a000006 	bne	20dc8 <_dtoa_r+0x10f8>
		      {
			k++;
   20dac:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   20db0:	e2833001 	add	r3, r3, #1
   20db4:	e50b3038 	str	r3, [fp, #-56]	; 0x38
			*s = '0';
   20db8:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   20dbc:	e3a02030 	mov	r2, #48	; 0x30
   20dc0:	e5c32000 	strb	r2, [r3]
			break;
   20dc4:	ea000006 	b	20de4 <_dtoa_r+0x1114>
	    {
	      d.d += d.d;
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
		{
		bump_up:
		  while (*--s == '9')
   20dc8:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   20dcc:	e2433001 	sub	r3, r3, #1
   20dd0:	e50b3078 	str	r3, [fp, #-120]	; 0x78
   20dd4:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   20dd8:	e5d33000 	ldrb	r3, [r3]
   20ddc:	e3530039 	cmp	r3, #57	; 0x39
   20de0:	0affffed 	beq	20d9c <_dtoa_r+0x10cc>
		      {
			k++;
			*s = '0';
			break;
		      }
		  ++*s++;
   20de4:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   20de8:	e2832001 	add	r2, r3, #1
   20dec:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   20df0:	e5d32000 	ldrb	r2, [r3]
   20df4:	e2822001 	add	r2, r2, #1
   20df8:	e20220ff 	and	r2, r2, #255	; 0xff
   20dfc:	e5c32000 	strb	r2, [r3]
		}
	      break;
   20e00:	ea00001a 	b	20e70 <_dtoa_r+0x11a0>
   20e04:	ea000019 	b	20e70 <_dtoa_r+0x11a0>
	    }
	  if (!(d.d *= 10.))
   20e08:	e24b40ac 	sub	r4, fp, #172	; 0xac
   20e0c:	e8940018 	ldm	r4, {r3, r4}
   20e10:	e1a00003 	mov	r0, r3
   20e14:	e1a01004 	mov	r1, r4
   20e18:	e3a02000 	mov	r2, #0
   20e1c:	e51f3ae0 	ldr	r3, [pc, #-2784]	; 20344 <_dtoa_r+0x674>
   20e20:	ebffcf36 	bl	14b00 <__aeabi_dmul>
   20e24:	e1a03000 	mov	r3, r0
   20e28:	e1a04001 	mov	r4, r1
   20e2c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   20e30:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
   20e34:	e24b40ac 	sub	r4, fp, #172	; 0xac
   20e38:	e8940018 	ldm	r4, {r3, r4}
   20e3c:	e1a00003 	mov	r0, r3
   20e40:	e1a01004 	mov	r1, r4
   20e44:	e3a02000 	mov	r2, #0
   20e48:	e3a03000 	mov	r3, #0
   20e4c:	ebffd085 	bl	15068 <__aeabi_dcmpeq>
   20e50:	e1a03000 	mov	r3, r0
   20e54:	e3530000 	cmp	r3, #0
   20e58:	0a000000 	beq	20e60 <_dtoa_r+0x1190>
	    break;
   20e5c:	ea000003 	b	20e70 <_dtoa_r+0x11a0>
	  S = mhi = 0;
	  if (ilim < 0 || d.d <= 5 * ds)
	    goto no_digits;
	  goto one_digit;
	}
      for (i = 1;; i++)
   20e60:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   20e64:	e2833001 	add	r3, r3, #1
   20e68:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		}
	      break;
	    }
	  if (!(d.d *= 10.))
	    break;
	}
   20e6c:	eaffff75 	b	20c48 <_dtoa_r+0xf78>
      goto ret1;
   20e70:	ea000281 	b	2187c <_dtoa_r+0x1bac>
    }

  m2 = b2;
   20e74:	e51b3018 	ldr	r3, [fp, #-24]
   20e78:	e50b3044 	str	r3, [fp, #-68]	; 0x44
  m5 = b5;
   20e7c:	e51b301c 	ldr	r3, [fp, #-28]
   20e80:	e50b3048 	str	r3, [fp, #-72]	; 0x48
  mhi = mlo = 0;
   20e84:	e3a03000 	mov	r3, #0
   20e88:	e50b3064 	str	r3, [fp, #-100]	; 0x64
   20e8c:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   20e90:	e50b3068 	str	r3, [fp, #-104]	; 0x68
  if (leftright)
   20e94:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   20e98:	e3530000 	cmp	r3, #0
   20e9c:	0a00003e 	beq	20f9c <_dtoa_r+0x12cc>
    {
      if (mode < 2)
   20ea0:	e59b3004 	ldr	r3, [fp, #4]
   20ea4:	e3530001 	cmp	r3, #1
   20ea8:	ca00000a 	bgt	20ed8 <_dtoa_r+0x1208>
	{
	  i =
#ifndef Sudden_Underflow
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
   20eac:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   20eb0:	e3530000 	cmp	r3, #0
   20eb4:	0a000003 	beq	20ec8 <_dtoa_r+0x11f8>
   20eb8:	e51b30a0 	ldr	r3, [fp, #-160]	; 0xa0
   20ebc:	e2833e43 	add	r3, r3, #1072	; 0x430
   20ec0:	e2833003 	add	r3, r3, #3
   20ec4:	ea000001 	b	20ed0 <_dtoa_r+0x1200>
#endif
#ifdef IBM
	    1 + 4 * P - 3 - bbits + ((bbits + be - 1) & 3);
#else
	    1 + P - bbits;
   20ec8:	e51b309c 	ldr	r3, [fp, #-156]	; 0x9c
    {
      if (mode < 2)
	{
	  i =
#ifndef Sudden_Underflow
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
   20ecc:	e2633036 	rsb	r3, r3, #54	; 0x36
  mhi = mlo = 0;
  if (leftright)
    {
      if (mode < 2)
	{
	  i =
   20ed0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   20ed4:	ea000024 	b	20f6c <_dtoa_r+0x129c>
	    1 + P - bbits;
#endif
	}
      else
	{
	  j = ilim - 1;
   20ed8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   20edc:	e2433001 	sub	r3, r3, #1
   20ee0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	  if (m5 >= j)
   20ee4:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   20ee8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   20eec:	e1520003 	cmp	r2, r3
   20ef0:	ba000004 	blt	20f08 <_dtoa_r+0x1238>
	    m5 -= j;
   20ef4:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   20ef8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   20efc:	e0633002 	rsb	r3, r3, r2
   20f00:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   20f04:	ea00000d 	b	20f40 <_dtoa_r+0x1270>
	  else
	    {
	      s5 += j -= m5;
   20f08:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   20f0c:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   20f10:	e0633002 	rsb	r3, r3, r2
   20f14:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   20f18:	e51b2050 	ldr	r2, [fp, #-80]	; 0x50
   20f1c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   20f20:	e0823003 	add	r3, r2, r3
   20f24:	e50b3050 	str	r3, [fp, #-80]	; 0x50
	      b5 += j;
   20f28:	e51b201c 	ldr	r2, [fp, #-28]
   20f2c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   20f30:	e0823003 	add	r3, r2, r3
   20f34:	e50b301c 	str	r3, [fp, #-28]
	      m5 = 0;
   20f38:	e3a03000 	mov	r3, #0
   20f3c:	e50b3048 	str	r3, [fp, #-72]	; 0x48
	    }
	  if ((i = ilim) < 0)
   20f40:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   20f44:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   20f48:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   20f4c:	e3530000 	cmp	r3, #0
   20f50:	aa000005 	bge	20f6c <_dtoa_r+0x129c>
	    {
	      m2 -= i;
   20f54:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   20f58:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   20f5c:	e0633002 	rsb	r3, r3, r2
   20f60:	e50b3044 	str	r3, [fp, #-68]	; 0x44
	      i = 0;
   20f64:	e3a03000 	mov	r3, #0
   20f68:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	    }
	}
      b2 += i;
   20f6c:	e51b2018 	ldr	r2, [fp, #-24]
   20f70:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   20f74:	e0823003 	add	r3, r2, r3
   20f78:	e50b3018 	str	r3, [fp, #-24]
      s2 += i;
   20f7c:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   20f80:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   20f84:	e0823003 	add	r3, r2, r3
   20f88:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
      mhi = i2b (ptr, 1);
   20f8c:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   20f90:	e3a01001 	mov	r1, #1
   20f94:	eb00082e 	bl	23054 <__i2b>
   20f98:	e50b0068 	str	r0, [fp, #-104]	; 0x68
    }
  if (m2 > 0 && s2 > 0)
   20f9c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   20fa0:	e3530000 	cmp	r3, #0
   20fa4:	da000014 	ble	20ffc <_dtoa_r+0x132c>
   20fa8:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   20fac:	e3530000 	cmp	r3, #0
   20fb0:	da000011 	ble	20ffc <_dtoa_r+0x132c>
    {
      i = m2 < s2 ? m2 : s2;
   20fb4:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   20fb8:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   20fbc:	e1520003 	cmp	r2, r3
   20fc0:	b1a03002 	movlt	r3, r2
   20fc4:	a1a03003 	movge	r3, r3
   20fc8:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      b2 -= i;
   20fcc:	e51b2018 	ldr	r2, [fp, #-24]
   20fd0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   20fd4:	e0633002 	rsb	r3, r3, r2
   20fd8:	e50b3018 	str	r3, [fp, #-24]
      m2 -= i;
   20fdc:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   20fe0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   20fe4:	e0633002 	rsb	r3, r3, r2
   20fe8:	e50b3044 	str	r3, [fp, #-68]	; 0x44
      s2 -= i;
   20fec:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   20ff0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   20ff4:	e0633002 	rsb	r3, r3, r2
   20ff8:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
    }
  if (b5 > 0)
   20ffc:	e51b301c 	ldr	r3, [fp, #-28]
   21000:	e3530000 	cmp	r3, #0
   21004:	da000026 	ble	210a4 <_dtoa_r+0x13d4>
    {
      if (leftright)
   21008:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   2100c:	e3530000 	cmp	r3, #0
   21010:	0a00001e 	beq	21090 <_dtoa_r+0x13c0>
	{
	  if (m5 > 0)
   21014:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   21018:	e3530000 	cmp	r3, #0
   2101c:	da00000e 	ble	2105c <_dtoa_r+0x138c>
	    {
	      mhi = pow5mult (ptr, mhi, m5);
   21020:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   21024:	e51b1068 	ldr	r1, [fp, #-104]	; 0x68
   21028:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   2102c:	eb00091a 	bl	2349c <__pow5mult>
   21030:	e50b0068 	str	r0, [fp, #-104]	; 0x68
	      b1 = mult (ptr, mhi, b);
   21034:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   21038:	e51b1068 	ldr	r1, [fp, #-104]	; 0x68
   2103c:	e51b2060 	ldr	r2, [fp, #-96]	; 0x60
   21040:	eb000817 	bl	230a4 <__multiply>
   21044:	e50b0094 	str	r0, [fp, #-148]	; 0x94
	      Bfree (ptr, b);
   21048:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   2104c:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   21050:	eb0006b2 	bl	22b20 <_Bfree>
	      b = b1;
   21054:	e51b3094 	ldr	r3, [fp, #-148]	; 0x94
   21058:	e50b3060 	str	r3, [fp, #-96]	; 0x60
	    }
         if ((j = b5 - m5) != 0)
   2105c:	e51b201c 	ldr	r2, [fp, #-28]
   21060:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   21064:	e0633002 	rsb	r3, r3, r2
   21068:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2106c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   21070:	e3530000 	cmp	r3, #0
   21074:	0a00000a 	beq	210a4 <_dtoa_r+0x13d4>
	    b = pow5mult (ptr, b, j);
   21078:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   2107c:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   21080:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   21084:	eb000904 	bl	2349c <__pow5mult>
   21088:	e50b0060 	str	r0, [fp, #-96]	; 0x60
   2108c:	ea000004 	b	210a4 <_dtoa_r+0x13d4>
	}
      else
	b = pow5mult (ptr, b, b5);
   21090:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   21094:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   21098:	e51b201c 	ldr	r2, [fp, #-28]
   2109c:	eb0008fe 	bl	2349c <__pow5mult>
   210a0:	e50b0060 	str	r0, [fp, #-96]	; 0x60
    }
  S = i2b (ptr, 1);
   210a4:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   210a8:	e3a01001 	mov	r1, #1
   210ac:	eb0007e8 	bl	23054 <__i2b>
   210b0:	e50b006c 	str	r0, [fp, #-108]	; 0x6c
  if (s5 > 0)
   210b4:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   210b8:	e3530000 	cmp	r3, #0
   210bc:	da000004 	ble	210d4 <_dtoa_r+0x1404>
    S = pow5mult (ptr, S, s5);
   210c0:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   210c4:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   210c8:	e51b2050 	ldr	r2, [fp, #-80]	; 0x50
   210cc:	eb0008f2 	bl	2349c <__pow5mult>
   210d0:	e50b006c 	str	r0, [fp, #-108]	; 0x6c

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
   210d4:	e3a03000 	mov	r3, #0
   210d8:	e50b3054 	str	r3, [fp, #-84]	; 0x54
  if (mode < 2)
   210dc:	e59b3004 	ldr	r3, [fp, #4]
   210e0:	e3530001 	cmp	r3, #1
   210e4:	ca000014 	bgt	2113c <_dtoa_r+0x146c>
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
   210e8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   210ec:	e3530000 	cmp	r3, #0
   210f0:	1a000011 	bne	2113c <_dtoa_r+0x146c>
   210f4:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   210f8:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
   210fc:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   21100:	e3530000 	cmp	r3, #0
   21104:	1a00000c 	bne	2113c <_dtoa_r+0x146c>
#ifndef Sudden_Underflow
	  && word0 (d) & Exp_mask
   21108:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   2110c:	e51f3dcc 	ldr	r3, [pc, #-3532]	; 20348 <_dtoa_r+0x678>
   21110:	e0033002 	and	r3, r3, r2
   21114:	e3530000 	cmp	r3, #0
   21118:	0a000007 	beq	2113c <_dtoa_r+0x146c>
#endif
	)
	{
	  /* The special case */
	  b2 += Log2P;
   2111c:	e51b3018 	ldr	r3, [fp, #-24]
   21120:	e2833001 	add	r3, r3, #1
   21124:	e50b3018 	str	r3, [fp, #-24]
	  s2 += Log2P;
   21128:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   2112c:	e2833001 	add	r3, r3, #1
   21130:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
	  spec_case = 1;
   21134:	e3a03001 	mov	r3, #1
   21138:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   * and for all and pass them and a shift to quorem, so it
   * can do shifts and ors to compute the numerator for q.
   */

#ifdef Pack_32
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
   2113c:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   21140:	e3530000 	cmp	r3, #0
   21144:	0a00000e 	beq	21184 <_dtoa_r+0x14b4>
   21148:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   2114c:	e5933010 	ldr	r3, [r3, #16]
   21150:	e2433001 	sub	r3, r3, #1
   21154:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   21158:	e2832004 	add	r2, r3, #4
   2115c:	e3a03004 	mov	r3, #4
   21160:	e1a02102 	lsl	r2, r2, #2
   21164:	e0812002 	add	r2, r1, r2
   21168:	e0823003 	add	r3, r2, r3
   2116c:	e5933000 	ldr	r3, [r3]
   21170:	e1a00003 	mov	r0, r3
   21174:	eb00074e 	bl	22eb4 <__hi0bits>
   21178:	e1a03000 	mov	r3, r0
   2117c:	e2633020 	rsb	r3, r3, #32
   21180:	ea000000 	b	21188 <_dtoa_r+0x14b8>
   21184:	e3a03001 	mov	r3, #1
   21188:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   2118c:	e0833002 	add	r3, r3, r2
   21190:	e203301f 	and	r3, r3, #31
   21194:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   21198:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   2119c:	e3530000 	cmp	r3, #0
   211a0:	0a000002 	beq	211b0 <_dtoa_r+0x14e0>
    i = 32 - i;
   211a4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   211a8:	e2633020 	rsb	r3, r3, #32
   211ac:	e50b3024 	str	r3, [fp, #-36]	; 0x24
#else
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0xf) != 0)
    i = 16 - i;
#endif
  if (i > 4)
   211b0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   211b4:	e3530004 	cmp	r3, #4
   211b8:	da00000f 	ble	211fc <_dtoa_r+0x152c>
    {
      i -= 4;
   211bc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   211c0:	e2433004 	sub	r3, r3, #4
   211c4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      b2 += i;
   211c8:	e51b2018 	ldr	r2, [fp, #-24]
   211cc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   211d0:	e0823003 	add	r3, r2, r3
   211d4:	e50b3018 	str	r3, [fp, #-24]
      m2 += i;
   211d8:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   211dc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   211e0:	e0823003 	add	r3, r2, r3
   211e4:	e50b3044 	str	r3, [fp, #-68]	; 0x44
      s2 += i;
   211e8:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   211ec:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   211f0:	e0823003 	add	r3, r2, r3
   211f4:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   211f8:	ea000011 	b	21244 <_dtoa_r+0x1574>
    }
  else if (i < 4)
   211fc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   21200:	e3530003 	cmp	r3, #3
   21204:	ca00000e 	bgt	21244 <_dtoa_r+0x1574>
    {
      i += 28;
   21208:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   2120c:	e283301c 	add	r3, r3, #28
   21210:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      b2 += i;
   21214:	e51b2018 	ldr	r2, [fp, #-24]
   21218:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   2121c:	e0823003 	add	r3, r2, r3
   21220:	e50b3018 	str	r3, [fp, #-24]
      m2 += i;
   21224:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   21228:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   2122c:	e0823003 	add	r3, r2, r3
   21230:	e50b3044 	str	r3, [fp, #-68]	; 0x44
      s2 += i;
   21234:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   21238:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   2123c:	e0823003 	add	r3, r2, r3
   21240:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
    }
  if (b2 > 0)
   21244:	e51b3018 	ldr	r3, [fp, #-24]
   21248:	e3530000 	cmp	r3, #0
   2124c:	da000004 	ble	21264 <_dtoa_r+0x1594>
    b = lshift (ptr, b, b2);
   21250:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   21254:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   21258:	e51b2018 	ldr	r2, [fp, #-24]
   2125c:	eb0008f1 	bl	23628 <__lshift>
   21260:	e50b0060 	str	r0, [fp, #-96]	; 0x60
  if (s2 > 0)
   21264:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   21268:	e3530000 	cmp	r3, #0
   2126c:	da000004 	ble	21284 <_dtoa_r+0x15b4>
    S = lshift (ptr, S, s2);
   21270:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   21274:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   21278:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   2127c:	eb0008e9 	bl	23628 <__lshift>
   21280:	e50b006c 	str	r0, [fp, #-108]	; 0x6c
  if (k_check)
   21284:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   21288:	e3530000 	cmp	r3, #0
   2128c:	0a000019 	beq	212f8 <_dtoa_r+0x1628>
    {
      if (cmp (b, S) < 0)
   21290:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   21294:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   21298:	eb000964 	bl	23830 <__mcmp>
   2129c:	e1a03000 	mov	r3, r0
   212a0:	e3530000 	cmp	r3, #0
   212a4:	aa000013 	bge	212f8 <_dtoa_r+0x1628>
	{
	  k--;
   212a8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   212ac:	e2433001 	sub	r3, r3, #1
   212b0:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
   212b4:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   212b8:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   212bc:	e3a0200a 	mov	r2, #10
   212c0:	e3a03000 	mov	r3, #0
   212c4:	eb000631 	bl	22b90 <__multadd>
   212c8:	e50b0060 	str	r0, [fp, #-96]	; 0x60
	  if (leftright)
   212cc:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   212d0:	e3530000 	cmp	r3, #0
   212d4:	0a000005 	beq	212f0 <_dtoa_r+0x1620>
	    mhi = multadd (ptr, mhi, 10, 0);
   212d8:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   212dc:	e51b1068 	ldr	r1, [fp, #-104]	; 0x68
   212e0:	e3a0200a 	mov	r2, #10
   212e4:	e3a03000 	mov	r3, #0
   212e8:	eb000628 	bl	22b90 <__multadd>
   212ec:	e50b0068 	str	r0, [fp, #-104]	; 0x68
	  ilim = ilim1;
   212f0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   212f4:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	}
    }
  if (ilim <= 0 && mode > 2)
   212f8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   212fc:	e3530000 	cmp	r3, #0
   21300:	ca00001e 	bgt	21380 <_dtoa_r+0x16b0>
   21304:	e59b3004 	ldr	r3, [fp, #4]
   21308:	e3530002 	cmp	r3, #2
   2130c:	da00001b 	ble	21380 <_dtoa_r+0x16b0>
    {
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
   21310:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   21314:	e3530000 	cmp	r3, #0
   21318:	ba00000b 	blt	2134c <_dtoa_r+0x167c>
   2131c:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   21320:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   21324:	e3a02005 	mov	r2, #5
   21328:	e3a03000 	mov	r3, #0
   2132c:	eb000617 	bl	22b90 <__multadd>
   21330:	e50b006c 	str	r0, [fp, #-108]	; 0x6c
   21334:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   21338:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   2133c:	eb00093b 	bl	23830 <__mcmp>
   21340:	e1a03000 	mov	r3, r0
   21344:	e3530000 	cmp	r3, #0
   21348:	ca000003 	bgt	2135c <_dtoa_r+0x168c>
	{
	  /* no digits, fcvt style */
	no_digits:
	  k = -1 - ndigits;
   2134c:	e59b3008 	ldr	r3, [fp, #8]
   21350:	e1e03003 	mvn	r3, r3
   21354:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	  goto ret;
   21358:	ea000134 	b	21830 <_dtoa_r+0x1b60>
	}
    one_digit:
      *s++ = '1';
   2135c:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   21360:	e2832001 	add	r2, r3, #1
   21364:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   21368:	e3a02031 	mov	r2, #49	; 0x31
   2136c:	e5c32000 	strb	r2, [r3]
      k++;
   21370:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   21374:	e2833001 	add	r3, r3, #1
   21378:	e50b3038 	str	r3, [fp, #-56]	; 0x38
      goto ret;
   2137c:	ea00012b 	b	21830 <_dtoa_r+0x1b60>
    }
  if (leftright)
   21380:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   21384:	e3530000 	cmp	r3, #0
   21388:	0a0000d1 	beq	216d4 <_dtoa_r+0x1a04>
    {
      if (m2 > 0)
   2138c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   21390:	e3530000 	cmp	r3, #0
   21394:	da000004 	ble	213ac <_dtoa_r+0x16dc>
	mhi = lshift (ptr, mhi, m2);
   21398:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   2139c:	e51b1068 	ldr	r1, [fp, #-104]	; 0x68
   213a0:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   213a4:	eb00089f 	bl	23628 <__lshift>
   213a8:	e50b0068 	str	r0, [fp, #-104]	; 0x68

      /* Compute mlo -- check for special case
       * that d is a normalized power of 2.
       */

      mlo = mhi;
   213ac:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   213b0:	e50b3064 	str	r3, [fp, #-100]	; 0x64
      if (spec_case)
   213b4:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   213b8:	e3530000 	cmp	r3, #0
   213bc:	0a000016 	beq	2141c <_dtoa_r+0x174c>
	{
	  mhi = Balloc (ptr, mhi->_k);
   213c0:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   213c4:	e5933004 	ldr	r3, [r3, #4]
   213c8:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   213cc:	e1a01003 	mov	r1, r3
   213d0:	eb000586 	bl	229f0 <_Balloc>
   213d4:	e50b0068 	str	r0, [fp, #-104]	; 0x68
	  Bcopy (mhi, mlo);
   213d8:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   213dc:	e283100c 	add	r1, r3, #12
   213e0:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   213e4:	e283200c 	add	r2, r3, #12
   213e8:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   213ec:	e5933010 	ldr	r3, [r3, #16]
   213f0:	e2833002 	add	r3, r3, #2
   213f4:	e1a03103 	lsl	r3, r3, #2
   213f8:	e1a00001 	mov	r0, r1
   213fc:	e1a01002 	mov	r1, r2
   21400:	e1a02003 	mov	r2, r3
   21404:	ebffdc71 	bl	185d0 <memcpy>
	  mhi = lshift (ptr, mhi, Log2P);
   21408:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   2140c:	e51b1068 	ldr	r1, [fp, #-104]	; 0x68
   21410:	e3a02001 	mov	r2, #1
   21414:	eb000883 	bl	23628 <__lshift>
   21418:	e50b0068 	str	r0, [fp, #-104]	; 0x68
	}

      for (i = 1;; i++)
   2141c:	e3a03001 	mov	r3, #1
   21420:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	{
	  dig = quorem (b, S) + '0';
   21424:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   21428:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   2142c:	ebfff926 	bl	1f8cc <quorem>
   21430:	e1a03000 	mov	r3, r0
   21434:	e2833030 	add	r3, r3, #48	; 0x30
   21438:	e50b3020 	str	r3, [fp, #-32]
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
   2143c:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   21440:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
   21444:	eb0008f9 	bl	23830 <__mcmp>
   21448:	e50b0034 	str	r0, [fp, #-52]	; 0x34
	  delta = diff (ptr, S, mhi);
   2144c:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   21450:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   21454:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   21458:	eb00093a 	bl	23948 <__mdiff>
   2145c:	e50b0098 	str	r0, [fp, #-152]	; 0x98
	  j1 = delta->_sign ? 1 : cmp (b, delta);
   21460:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   21464:	e593300c 	ldr	r3, [r3, #12]
   21468:	e3530000 	cmp	r3, #0
   2146c:	1a000004 	bne	21484 <_dtoa_r+0x17b4>
   21470:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   21474:	e51b1098 	ldr	r1, [fp, #-152]	; 0x98
   21478:	eb0008ec 	bl	23830 <__mcmp>
   2147c:	e1a03000 	mov	r3, r0
   21480:	ea000000 	b	21488 <_dtoa_r+0x17b8>
   21484:	e3a03001 	mov	r3, #1
   21488:	e50b308c 	str	r3, [fp, #-140]	; 0x8c
	  Bfree (ptr, delta);
   2148c:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   21490:	e51b1098 	ldr	r1, [fp, #-152]	; 0x98
   21494:	eb0005a1 	bl	22b20 <_Bfree>
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
   21498:	e51b308c 	ldr	r3, [fp, #-140]	; 0x8c
   2149c:	e3530000 	cmp	r3, #0
   214a0:	1a000017 	bne	21504 <_dtoa_r+0x1834>
   214a4:	e59b3004 	ldr	r3, [fp, #4]
   214a8:	e3530000 	cmp	r3, #0
   214ac:	1a000014 	bne	21504 <_dtoa_r+0x1834>
   214b0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   214b4:	e2033001 	and	r3, r3, #1
   214b8:	e3530000 	cmp	r3, #0
   214bc:	1a000010 	bne	21504 <_dtoa_r+0x1834>
	    {
	      if (dig == '9')
   214c0:	e51b3020 	ldr	r3, [fp, #-32]
   214c4:	e3530039 	cmp	r3, #57	; 0x39
   214c8:	1a000000 	bne	214d0 <_dtoa_r+0x1800>
		goto round_9_up;
   214cc:	ea000042 	b	215dc <_dtoa_r+0x190c>
	      if (j > 0)
   214d0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   214d4:	e3530000 	cmp	r3, #0
   214d8:	da000002 	ble	214e8 <_dtoa_r+0x1818>
		dig++;
   214dc:	e51b3020 	ldr	r3, [fp, #-32]
   214e0:	e2833001 	add	r3, r3, #1
   214e4:	e50b3020 	str	r3, [fp, #-32]
	      *s++ = dig;
   214e8:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   214ec:	e2832001 	add	r2, r3, #1
   214f0:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   214f4:	e51b2020 	ldr	r2, [fp, #-32]
   214f8:	e20220ff 	and	r2, r2, #255	; 0xff
   214fc:	e5c32000 	strb	r2, [r3]
	      goto ret;
   21500:	ea0000ca 	b	21830 <_dtoa_r+0x1b60>
	    }
#endif
         if ((j < 0) || ((j == 0) && !mode
   21504:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   21508:	e3530000 	cmp	r3, #0
   2150c:	ba000009 	blt	21538 <_dtoa_r+0x1868>
   21510:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   21514:	e3530000 	cmp	r3, #0
   21518:	1a000029 	bne	215c4 <_dtoa_r+0x18f4>
   2151c:	e59b3004 	ldr	r3, [fp, #4]
   21520:	e3530000 	cmp	r3, #0
   21524:	1a000026 	bne	215c4 <_dtoa_r+0x18f4>
#ifndef ROUND_BIASED
	      && !(word1 (d) & 1)
   21528:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   2152c:	e2033001 	and	r3, r3, #1
   21530:	e3530000 	cmp	r3, #0
   21534:	1a000022 	bne	215c4 <_dtoa_r+0x18f4>
#endif
           ))
	    {
	      if (j1 > 0)
   21538:	e51b308c 	ldr	r3, [fp, #-140]	; 0x8c
   2153c:	e3530000 	cmp	r3, #0
   21540:	da000018 	ble	215a8 <_dtoa_r+0x18d8>
		{
		  b = lshift (ptr, b, 1);
   21544:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   21548:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   2154c:	e3a02001 	mov	r2, #1
   21550:	eb000834 	bl	23628 <__lshift>
   21554:	e50b0060 	str	r0, [fp, #-96]	; 0x60
		  j1 = cmp (b, S);
   21558:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   2155c:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   21560:	eb0008b2 	bl	23830 <__mcmp>
   21564:	e50b008c 	str	r0, [fp, #-140]	; 0x8c
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
   21568:	e51b308c 	ldr	r3, [fp, #-140]	; 0x8c
   2156c:	e3530000 	cmp	r3, #0
   21570:	ca000006 	bgt	21590 <_dtoa_r+0x18c0>
   21574:	e51b308c 	ldr	r3, [fp, #-140]	; 0x8c
   21578:	e3530000 	cmp	r3, #0
   2157c:	1a000009 	bne	215a8 <_dtoa_r+0x18d8>
   21580:	e51b3020 	ldr	r3, [fp, #-32]
   21584:	e2033001 	and	r3, r3, #1
   21588:	e3530000 	cmp	r3, #0
   2158c:	0a000005 	beq	215a8 <_dtoa_r+0x18d8>
		      && dig++ == '9')
   21590:	e51b3020 	ldr	r3, [fp, #-32]
   21594:	e2832001 	add	r2, r3, #1
   21598:	e50b2020 	str	r2, [fp, #-32]
   2159c:	e3530039 	cmp	r3, #57	; 0x39
   215a0:	1a000000 	bne	215a8 <_dtoa_r+0x18d8>
		    goto round_9_up;
   215a4:	ea00000c 	b	215dc <_dtoa_r+0x190c>
		}
	      *s++ = dig;
   215a8:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   215ac:	e2832001 	add	r2, r3, #1
   215b0:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   215b4:	e51b2020 	ldr	r2, [fp, #-32]
   215b8:	e20220ff 	and	r2, r2, #255	; 0xff
   215bc:	e5c32000 	strb	r2, [r3]
	      goto ret;
   215c0:	ea00009a 	b	21830 <_dtoa_r+0x1b60>
	    }
	  if (j1 > 0)
   215c4:	e51b308c 	ldr	r3, [fp, #-140]	; 0x8c
   215c8:	e3530000 	cmp	r3, #0
   215cc:	da000011 	ble	21618 <_dtoa_r+0x1948>
	    {
	      if (dig == '9')
   215d0:	e51b3020 	ldr	r3, [fp, #-32]
   215d4:	e3530039 	cmp	r3, #57	; 0x39
   215d8:	1a000005 	bne	215f4 <_dtoa_r+0x1924>
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
   215dc:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   215e0:	e2832001 	add	r2, r3, #1
   215e4:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   215e8:	e3a02039 	mov	r2, #57	; 0x39
   215ec:	e5c32000 	strb	r2, [r3]
		  goto roundoff;
   215f0:	ea000067 	b	21794 <_dtoa_r+0x1ac4>
		}
	      *s++ = dig + 1;
   215f4:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   215f8:	e2832001 	add	r2, r3, #1
   215fc:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   21600:	e51b2020 	ldr	r2, [fp, #-32]
   21604:	e20220ff 	and	r2, r2, #255	; 0xff
   21608:	e2822001 	add	r2, r2, #1
   2160c:	e20220ff 	and	r2, r2, #255	; 0xff
   21610:	e5c32000 	strb	r2, [r3]
	      goto ret;
   21614:	ea000085 	b	21830 <_dtoa_r+0x1b60>
	    }
	  *s++ = dig;
   21618:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   2161c:	e2832001 	add	r2, r3, #1
   21620:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   21624:	e51b2020 	ldr	r2, [fp, #-32]
   21628:	e20220ff 	and	r2, r2, #255	; 0xff
   2162c:	e5c32000 	strb	r2, [r3]
	  if (i == ilim)
   21630:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   21634:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   21638:	e1520003 	cmp	r2, r3
   2163c:	1a000001 	bne	21648 <_dtoa_r+0x1978>
	    break;
   21640:	e1a00000 	nop			; (mov r0, r0)
   21644:	ea00003f 	b	21748 <_dtoa_r+0x1a78>
	  b = multadd (ptr, b, 10, 0);
   21648:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   2164c:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   21650:	e3a0200a 	mov	r2, #10
   21654:	e3a03000 	mov	r3, #0
   21658:	eb00054c 	bl	22b90 <__multadd>
   2165c:	e50b0060 	str	r0, [fp, #-96]	; 0x60
	  if (mlo == mhi)
   21660:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
   21664:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   21668:	e1520003 	cmp	r2, r3
   2166c:	1a000008 	bne	21694 <_dtoa_r+0x19c4>
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   21670:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   21674:	e51b1068 	ldr	r1, [fp, #-104]	; 0x68
   21678:	e3a0200a 	mov	r2, #10
   2167c:	e3a03000 	mov	r3, #0
   21680:	eb000542 	bl	22b90 <__multadd>
   21684:	e50b0068 	str	r0, [fp, #-104]	; 0x68
   21688:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   2168c:	e50b3064 	str	r3, [fp, #-100]	; 0x64
   21690:	ea00000b 	b	216c4 <_dtoa_r+0x19f4>
	  else
	    {
	      mlo = multadd (ptr, mlo, 10, 0);
   21694:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   21698:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
   2169c:	e3a0200a 	mov	r2, #10
   216a0:	e3a03000 	mov	r3, #0
   216a4:	eb000539 	bl	22b90 <__multadd>
   216a8:	e50b0064 	str	r0, [fp, #-100]	; 0x64
	      mhi = multadd (ptr, mhi, 10, 0);
   216ac:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   216b0:	e51b1068 	ldr	r1, [fp, #-104]	; 0x68
   216b4:	e3a0200a 	mov	r2, #10
   216b8:	e3a03000 	mov	r3, #0
   216bc:	eb000533 	bl	22b90 <__multadd>
   216c0:	e50b0068 	str	r0, [fp, #-104]	; 0x68
	  mhi = Balloc (ptr, mhi->_k);
	  Bcopy (mhi, mlo);
	  mhi = lshift (ptr, mhi, Log2P);
	}

      for (i = 1;; i++)
   216c4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   216c8:	e2833001 	add	r3, r3, #1
   216cc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	  else
	    {
	      mlo = multadd (ptr, mlo, 10, 0);
	      mhi = multadd (ptr, mhi, 10, 0);
	    }
	}
   216d0:	eaffff53 	b	21424 <_dtoa_r+0x1754>
    }
  else
    for (i = 1;; i++)
   216d4:	e3a03001 	mov	r3, #1
   216d8:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      {
	*s++ = dig = quorem (b, S) + '0';
   216dc:	e51b4078 	ldr	r4, [fp, #-120]	; 0x78
   216e0:	e2843001 	add	r3, r4, #1
   216e4:	e50b3078 	str	r3, [fp, #-120]	; 0x78
   216e8:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   216ec:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   216f0:	ebfff875 	bl	1f8cc <quorem>
   216f4:	e1a03000 	mov	r3, r0
   216f8:	e2833030 	add	r3, r3, #48	; 0x30
   216fc:	e50b3020 	str	r3, [fp, #-32]
   21700:	e51b3020 	ldr	r3, [fp, #-32]
   21704:	e20330ff 	and	r3, r3, #255	; 0xff
   21708:	e5c43000 	strb	r3, [r4]
	if (i >= ilim)
   2170c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   21710:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   21714:	e1520003 	cmp	r2, r3
   21718:	ba000000 	blt	21720 <_dtoa_r+0x1a50>
	  break;
   2171c:	ea000009 	b	21748 <_dtoa_r+0x1a78>
	b = multadd (ptr, b, 10, 0);
   21720:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   21724:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   21728:	e3a0200a 	mov	r2, #10
   2172c:	e3a03000 	mov	r3, #0
   21730:	eb000516 	bl	22b90 <__multadd>
   21734:	e50b0060 	str	r0, [fp, #-96]	; 0x60
	      mhi = multadd (ptr, mhi, 10, 0);
	    }
	}
    }
  else
    for (i = 1;; i++)
   21738:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   2173c:	e2833001 	add	r3, r3, #1
   21740:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      {
	*s++ = dig = quorem (b, S) + '0';
	if (i >= ilim)
	  break;
	b = multadd (ptr, b, 10, 0);
      }
   21744:	eaffffe4 	b	216dc <_dtoa_r+0x1a0c>

  /* Round off last digit */

  b = lshift (ptr, b, 1);
   21748:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   2174c:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   21750:	e3a02001 	mov	r2, #1
   21754:	eb0007b3 	bl	23628 <__lshift>
   21758:	e50b0060 	str	r0, [fp, #-96]	; 0x60
  j = cmp (b, S);
   2175c:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   21760:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   21764:	eb000831 	bl	23830 <__mcmp>
   21768:	e50b0034 	str	r0, [fp, #-52]	; 0x34
  if ((j > 0) || ((j == 0) && (dig & 1)))
   2176c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   21770:	e3530000 	cmp	r3, #0
   21774:	ca000006 	bgt	21794 <_dtoa_r+0x1ac4>
   21778:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2177c:	e3530000 	cmp	r3, #0
   21780:	1a000020 	bne	21808 <_dtoa_r+0x1b38>
   21784:	e51b3020 	ldr	r3, [fp, #-32]
   21788:	e2033001 	and	r3, r3, #1
   2178c:	e3530000 	cmp	r3, #0
   21790:	0a00001c 	beq	21808 <_dtoa_r+0x1b38>
    {
    roundoff:
      while (*--s == '9')
   21794:	ea00000c 	b	217cc <_dtoa_r+0x1afc>
	if (s == s0)
   21798:	e51b2078 	ldr	r2, [fp, #-120]	; 0x78
   2179c:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
   217a0:	e1520003 	cmp	r2, r3
   217a4:	1a000008 	bne	217cc <_dtoa_r+0x1afc>
	  {
	    k++;
   217a8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   217ac:	e2833001 	add	r3, r3, #1
   217b0:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	    *s++ = '1';
   217b4:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   217b8:	e2832001 	add	r2, r3, #1
   217bc:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   217c0:	e3a02031 	mov	r2, #49	; 0x31
   217c4:	e5c32000 	strb	r2, [r3]
	    goto ret;
   217c8:	ea000018 	b	21830 <_dtoa_r+0x1b60>
  b = lshift (ptr, b, 1);
  j = cmp (b, S);
  if ((j > 0) || ((j == 0) && (dig & 1)))
    {
    roundoff:
      while (*--s == '9')
   217cc:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   217d0:	e2433001 	sub	r3, r3, #1
   217d4:	e50b3078 	str	r3, [fp, #-120]	; 0x78
   217d8:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   217dc:	e5d33000 	ldrb	r3, [r3]
   217e0:	e3530039 	cmp	r3, #57	; 0x39
   217e4:	0affffeb 	beq	21798 <_dtoa_r+0x1ac8>
	  {
	    k++;
	    *s++ = '1';
	    goto ret;
	  }
      ++*s++;
   217e8:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   217ec:	e2832001 	add	r2, r3, #1
   217f0:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   217f4:	e5d32000 	ldrb	r2, [r3]
   217f8:	e2822001 	add	r2, r2, #1
   217fc:	e20220ff 	and	r2, r2, #255	; 0xff
   21800:	e5c32000 	strb	r2, [r3]
   21804:	ea000009 	b	21830 <_dtoa_r+0x1b60>
    }
  else
    {
      while (*--s == '0');
   21808:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   2180c:	e2433001 	sub	r3, r3, #1
   21810:	e50b3078 	str	r3, [fp, #-120]	; 0x78
   21814:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   21818:	e5d33000 	ldrb	r3, [r3]
   2181c:	e3530030 	cmp	r3, #48	; 0x30
   21820:	0afffff8 	beq	21808 <_dtoa_r+0x1b38>
      s++;
   21824:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   21828:	e2833001 	add	r3, r3, #1
   2182c:	e50b3078 	str	r3, [fp, #-120]	; 0x78
    }
ret:
  Bfree (ptr, S);
   21830:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   21834:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   21838:	eb0004b8 	bl	22b20 <_Bfree>
  if (mhi)
   2183c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   21840:	e3530000 	cmp	r3, #0
   21844:	0a00000c 	beq	2187c <_dtoa_r+0x1bac>
    {
      if (mlo && mlo != mhi)
   21848:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   2184c:	e3530000 	cmp	r3, #0
   21850:	0a000006 	beq	21870 <_dtoa_r+0x1ba0>
   21854:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
   21858:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   2185c:	e1520003 	cmp	r2, r3
   21860:	0a000002 	beq	21870 <_dtoa_r+0x1ba0>
	Bfree (ptr, mlo);
   21864:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   21868:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
   2186c:	eb0004ab 	bl	22b20 <_Bfree>
      Bfree (ptr, mhi);
   21870:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   21874:	e51b1068 	ldr	r1, [fp, #-104]	; 0x68
   21878:	eb0004a8 	bl	22b20 <_Bfree>
    }
ret1:
  Bfree (ptr, b);
   2187c:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   21880:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   21884:	eb0004a5 	bl	22b20 <_Bfree>
  *s = 0;
   21888:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   2188c:	e3a02000 	mov	r2, #0
   21890:	e5c32000 	strb	r2, [r3]
  *decpt = k + 1;
   21894:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   21898:	e2832001 	add	r2, r3, #1
   2189c:	e59b300c 	ldr	r3, [fp, #12]
   218a0:	e5832000 	str	r2, [r3]
  if (rve)
   218a4:	e59b3014 	ldr	r3, [fp, #20]
   218a8:	e3530000 	cmp	r3, #0
   218ac:	0a000002 	beq	218bc <_dtoa_r+0x1bec>
    *rve = s;
   218b0:	e59b3014 	ldr	r3, [fp, #20]
   218b4:	e51b2078 	ldr	r2, [fp, #-120]	; 0x78
   218b8:	e5832000 	str	r2, [r3]
  return s0;
   218bc:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
}
   218c0:	e1a00003 	mov	r0, r3
   218c4:	e24bd014 	sub	sp, fp, #20
   218c8:	e8bd48f0 	pop	{r4, r5, r6, r7, fp, lr}
   218cc:	e12fff1e 	bx	lr

000218d0 <__errno>:

extern int * __libthread__errno (void);

int *
__errno ()
{
   218d0:	e92d4800 	push	{fp, lr}
   218d4:	e28db004 	add	fp, sp, #4
  return __libthread_errno ();
   218d8:	ebff7f7d 	bl	16d4 <__libthread_errno>
   218dc:	e1a03000 	mov	r3, r0
}
   218e0:	e1a00003 	mov	r0, r3
   218e4:	e24bd004 	sub	sp, fp, #4
   218e8:	e8bd4800 	pop	{fp, lr}
   218ec:	e12fff1e 	bx	lr

000218f0 <_exit>:
#include <Core/Core.h>

_VOID
_DEFUN (_exit, (rc),
	int rc)
{
   218f0:	e92d4800 	push	{fp, lr}
   218f4:	e28db004 	add	fp, sp, #4
   218f8:	e24dd008 	sub	sp, sp, #8
   218fc:	e50b0008 	str	r0, [fp, #-8]
	thread_exit (rc);
   21900:	e51b0008 	ldr	r0, [fp, #-8]
   21904:	ebffc2b3 	bl	123d8 <thread_exit>

  /* Convince GCC that this function never returns.  */
  for (;;)
    ;
   21908:	eafffffe 	b	21908 <_exit+0x18>

0002190c <_fclose_r>:

int
_DEFUN(_fclose_r, (rptr, fp),
      struct _reent *rptr _AND
      register FILE * fp)
{
   2190c:	e92d4810 	push	{r4, fp, lr}
   21910:	e28db008 	add	fp, sp, #8
   21914:	e24dd014 	sub	sp, sp, #20
   21918:	e50b0018 	str	r0, [fp, #-24]
   2191c:	e1a04001 	mov	r4, r1
  int r;

  if (fp == NULL)
   21920:	e3540000 	cmp	r4, #0
   21924:	1a000001 	bne	21930 <_fclose_r+0x24>
    return (0);			/* on NULL */
   21928:	e3a03000 	mov	r3, #0
   2192c:	ea000064 	b	21ac4 <_fclose_r+0x1b8>

  CHECK_INIT (rptr, fp);
   21930:	e51b3018 	ldr	r3, [fp, #-24]
   21934:	e50b3014 	str	r3, [fp, #-20]
   21938:	e51b3014 	ldr	r3, [fp, #-20]
   2193c:	e3530000 	cmp	r3, #0
   21940:	0a000005 	beq	2195c <_fclose_r+0x50>
   21944:	e51b3014 	ldr	r3, [fp, #-20]
   21948:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   2194c:	e3530000 	cmp	r3, #0
   21950:	1a000001 	bne	2195c <_fclose_r+0x50>
   21954:	e51b0014 	ldr	r0, [fp, #-20]
   21958:	ebffd30b 	bl	1658c <__sinit>
     interlocked locking with the sfp_lock. */
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);
   2195c:	e1d430bc 	ldrh	r3, [r4, #12]
   21960:	e1a03803 	lsl	r3, r3, #16
   21964:	e1a03823 	lsr	r3, r3, #16
   21968:	e2033c02 	and	r3, r3, #512	; 0x200
   2196c:	e3530000 	cmp	r3, #0
   21970:	1a000002 	bne	21980 <_fclose_r+0x74>
   21974:	e284305c 	add	r3, r4, #92	; 0x5c
   21978:	e1a00003 	mov	r0, r3
   2197c:	ebffd6bf 	bl	17480 <_dna_lock_acquire>

  if (fp->_flags == 0)		/* not open! */
   21980:	e1d430bc 	ldrh	r3, [r4, #12]
   21984:	e3530000 	cmp	r3, #0
   21988:	1a00000a 	bne	219b8 <_fclose_r+0xac>
    {
      _funlockfile (fp);
   2198c:	e1d430bc 	ldrh	r3, [r4, #12]
   21990:	e1a03803 	lsl	r3, r3, #16
   21994:	e1a03823 	lsr	r3, r3, #16
   21998:	e2033c02 	and	r3, r3, #512	; 0x200
   2199c:	e3530000 	cmp	r3, #0
   219a0:	1a000002 	bne	219b0 <_fclose_r+0xa4>
   219a4:	e284305c 	add	r3, r4, #92	; 0x5c
   219a8:	e1a00003 	mov	r0, r3
   219ac:	ebffd71a 	bl	1761c <_dna_lock_release>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
      pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif
      return (0);
   219b0:	e3a03000 	mov	r3, #0
   219b4:	ea000042 	b	21ac4 <_fclose_r+0x1b8>
    }
  /* Unconditionally flush to allow special handling for seekable read
     files to reposition file to last byte processed as opposed to
     last byte read ahead into the buffer.  */
  r = _fflush_r (rptr, fp);
   219b8:	e51b0018 	ldr	r0, [fp, #-24]
   219bc:	e1a01004 	mov	r1, r4
   219c0:	ebffd1a6 	bl	16060 <_fflush_r>
   219c4:	e50b0010 	str	r0, [fp, #-16]
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
   219c8:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
   219cc:	e3530000 	cmp	r3, #0
   219d0:	0a00000a 	beq	21a00 <_fclose_r+0xf4>
   219d4:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
   219d8:	e594201c 	ldr	r2, [r4, #28]
   219dc:	e51b0018 	ldr	r0, [fp, #-24]
   219e0:	e1a01002 	mov	r1, r2
   219e4:	e1a0e00f 	mov	lr, pc
   219e8:	e12fff13 	bx	r3
   219ec:	e1a03000 	mov	r3, r0
   219f0:	e3530000 	cmp	r3, #0
   219f4:	aa000001 	bge	21a00 <_fclose_r+0xf4>
    r = EOF;
   219f8:	e3e03000 	mvn	r3, #0
   219fc:	e50b3010 	str	r3, [fp, #-16]
  if (fp->_flags & __SMBF)
   21a00:	e1d430bc 	ldrh	r3, [r4, #12]
   21a04:	e1a03803 	lsl	r3, r3, #16
   21a08:	e1a03823 	lsr	r3, r3, #16
   21a0c:	e2033080 	and	r3, r3, #128	; 0x80
   21a10:	e3530000 	cmp	r3, #0
   21a14:	0a000003 	beq	21a28 <_fclose_r+0x11c>
    _free_r (rptr, (char *) fp->_bf._base);
   21a18:	e5943010 	ldr	r3, [r4, #16]
   21a1c:	e51b0018 	ldr	r0, [fp, #-24]
   21a20:	e1a01003 	mov	r1, r3
   21a24:	ebffd399 	bl	16890 <_free_r>
  if (HASUB (fp))
   21a28:	e5943030 	ldr	r3, [r4, #48]	; 0x30
   21a2c:	e3530000 	cmp	r3, #0
   21a30:	0a000009 	beq	21a5c <_fclose_r+0x150>
    FREEUB (rptr, fp);
   21a34:	e5942030 	ldr	r2, [r4, #48]	; 0x30
   21a38:	e2843040 	add	r3, r4, #64	; 0x40
   21a3c:	e1520003 	cmp	r2, r3
   21a40:	0a000003 	beq	21a54 <_fclose_r+0x148>
   21a44:	e5943030 	ldr	r3, [r4, #48]	; 0x30
   21a48:	e51b0018 	ldr	r0, [fp, #-24]
   21a4c:	e1a01003 	mov	r1, r3
   21a50:	ebffd38e 	bl	16890 <_free_r>
   21a54:	e3a03000 	mov	r3, #0
   21a58:	e5843030 	str	r3, [r4, #48]	; 0x30
  if (HASLB (fp))
   21a5c:	e5943044 	ldr	r3, [r4, #68]	; 0x44
   21a60:	e3530000 	cmp	r3, #0
   21a64:	0a000005 	beq	21a80 <_fclose_r+0x174>
    FREELB (rptr, fp);
   21a68:	e5943044 	ldr	r3, [r4, #68]	; 0x44
   21a6c:	e51b0018 	ldr	r0, [fp, #-24]
   21a70:	e1a01003 	mov	r1, r3
   21a74:	ebffd385 	bl	16890 <_free_r>
   21a78:	e3a03000 	mov	r3, #0
   21a7c:	e5843044 	str	r3, [r4, #68]	; 0x44
  __sfp_lock_acquire ();
   21a80:	ebffd2f6 	bl	16660 <__sfp_lock_acquire>
  fp->_flags = 0;		/* release this FILE for reuse */
   21a84:	e3a03000 	mov	r3, #0
   21a88:	e1c430bc 	strh	r3, [r4, #12]
  _funlockfile (fp);
   21a8c:	e1d430bc 	ldrh	r3, [r4, #12]
   21a90:	e1a03803 	lsl	r3, r3, #16
   21a94:	e1a03823 	lsr	r3, r3, #16
   21a98:	e2033c02 	and	r3, r3, #512	; 0x200
   21a9c:	e3530000 	cmp	r3, #0
   21aa0:	1a000002 	bne	21ab0 <_fclose_r+0x1a4>
   21aa4:	e284305c 	add	r3, r4, #92	; 0x5c
   21aa8:	e1a00003 	mov	r0, r3
   21aac:	ebffd6da 	bl	1761c <_dna_lock_release>
#ifndef __SINGLE_THREAD__
  __lock_close_recursive (fp->_lock);
   21ab0:	e284305c 	add	r3, r4, #92	; 0x5c
   21ab4:	e1a00003 	mov	r0, r3
   21ab8:	ebffd64b 	bl	173ec <_dna_lock_close>
#endif

  __sfp_lock_release ();
   21abc:	ebffd2ef 	bl	16680 <__sfp_lock_release>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
   21ac0:	e51b3010 	ldr	r3, [fp, #-16]
}
   21ac4:	e1a00003 	mov	r0, r3
   21ac8:	e24bd008 	sub	sp, fp, #8
   21acc:	e8bd4810 	pop	{r4, fp, lr}
   21ad0:	e12fff1e 	bx	lr

00021ad4 <fclose>:
#ifndef _REENT_ONLY

int
_DEFUN(fclose, (fp),
       register FILE * fp)
{
   21ad4:	e92d4800 	push	{fp, lr}
   21ad8:	e28db004 	add	fp, sp, #4
   21adc:	e1a03000 	mov	r3, r0
  return _fclose_r(_REENT, fp);
   21ae0:	e59f2020 	ldr	r2, [pc, #32]	; 21b08 <fclose+0x34>
   21ae4:	e5922000 	ldr	r2, [r2]
   21ae8:	e1a00002 	mov	r0, r2
   21aec:	e1a01003 	mov	r1, r3
   21af0:	ebffff85 	bl	2190c <_fclose_r>
   21af4:	e1a03000 	mov	r3, r0
}
   21af8:	e1a00003 	mov	r0, r3
   21afc:	e24bd004 	sub	sp, fp, #4
   21b00:	e8bd4800 	pop	{fp, lr}
   21b04:	e12fff1e 	bx	lr
   21b08:	0003e460 	.word	0x0003e460

00021b0c <__sfvwrite_r>:
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
   21b0c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   21b10:	e28db020 	add	fp, sp, #32
   21b14:	e24dd024 	sub	sp, sp, #36	; 0x24
   21b18:	e50b0040 	str	r0, [fp, #-64]	; 0x40
   21b1c:	e1a04001 	mov	r4, r1
   21b20:	e1a09002 	mov	r9, r2
  register size_t len;
  register _CONST char *p = NULL;
   21b24:	e3a07000 	mov	r7, #0
  register struct __siov *iov;
  register int w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
   21b28:	e5993008 	ldr	r3, [r9, #8]
   21b2c:	e1a06003 	mov	r6, r3
   21b30:	e3560000 	cmp	r6, #0
   21b34:	1a000001 	bne	21b40 <__sfvwrite_r+0x34>
    return 0;
   21b38:	e3a03000 	mov	r3, #0
   21b3c:	ea00018e 	b	2217c <__sfvwrite_r+0x670>

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   21b40:	e1d430bc 	ldrh	r3, [r4, #12]
   21b44:	e1a03803 	lsl	r3, r3, #16
   21b48:	e1a03823 	lsr	r3, r3, #16
   21b4c:	e2033008 	and	r3, r3, #8
   21b50:	e3530000 	cmp	r3, #0
   21b54:	0a000002 	beq	21b64 <__sfvwrite_r+0x58>
   21b58:	e5943010 	ldr	r3, [r4, #16]
   21b5c:	e3530000 	cmp	r3, #0
   21b60:	1a000007 	bne	21b84 <__sfvwrite_r+0x78>
   21b64:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   21b68:	e1a01004 	mov	r1, r4
   21b6c:	ebfff63a 	bl	1f45c <__swsetup_r>
   21b70:	e1a03000 	mov	r3, r0
   21b74:	e3530000 	cmp	r3, #0
   21b78:	0a000001 	beq	21b84 <__sfvwrite_r+0x78>
    return EOF;
   21b7c:	e3e03000 	mvn	r3, #0
   21b80:	ea00017d 	b	2217c <__sfvwrite_r+0x670>

  iov = uio->uio_iov;
   21b84:	e5998000 	ldr	r8, [r9]
  len = 0;
   21b88:	e3a06000 	mov	r6, #0
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   21b8c:	e1d430bc 	ldrh	r3, [r4, #12]
   21b90:	e1a03803 	lsl	r3, r3, #16
   21b94:	e1a03823 	lsr	r3, r3, #16
   21b98:	e2033002 	and	r3, r3, #2
   21b9c:	e3530000 	cmp	r3, #0
   21ba0:	0a00001e 	beq	21c20 <__sfvwrite_r+0x114>
      /*
       * Unbuffered: write up to BUFSIZ bytes at a time.
       */
      do
	{
	  GETIOV (;);
   21ba4:	ea000002 	b	21bb4 <__sfvwrite_r+0xa8>
   21ba8:	e5987000 	ldr	r7, [r8]
   21bac:	e5986004 	ldr	r6, [r8, #4]
   21bb0:	e2888008 	add	r8, r8, #8
   21bb4:	e3560000 	cmp	r6, #0
   21bb8:	0afffffa 	beq	21ba8 <__sfvwrite_r+0x9c>
	  w = fp->_write (ptr, fp->_cookie, p, MIN (len, BUFSIZ));
   21bbc:	e594c024 	ldr	ip, [r4, #36]	; 0x24
   21bc0:	e594201c 	ldr	r2, [r4, #28]
   21bc4:	e3560b01 	cmp	r6, #1024	; 0x400
   21bc8:	31a03006 	movcc	r3, r6
   21bcc:	23a03b01 	movcs	r3, #1024	; 0x400
   21bd0:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   21bd4:	e1a01002 	mov	r1, r2
   21bd8:	e1a02007 	mov	r2, r7
   21bdc:	e1a0e00f 	mov	lr, pc
   21be0:	e12fff1c 	bx	ip
   21be4:	e1a05000 	mov	r5, r0
	  if (w <= 0)
   21be8:	e3550000 	cmp	r5, #0
   21bec:	ca000000 	bgt	21bf4 <__sfvwrite_r+0xe8>
	    goto err;
   21bf0:	ea00015b 	b	22164 <__sfvwrite_r+0x658>
	  p += w;
   21bf4:	e1a03005 	mov	r3, r5
   21bf8:	e0877003 	add	r7, r7, r3
	  len -= w;
   21bfc:	e1a03005 	mov	r3, r5
   21c00:	e0636006 	rsb	r6, r3, r6
	}
      while ((uio->uio_resid -= w) != 0);
   21c04:	e5993008 	ldr	r3, [r9, #8]
   21c08:	e0653003 	rsb	r3, r5, r3
   21c0c:	e5893008 	str	r3, [r9, #8]
   21c10:	e5993008 	ldr	r3, [r9, #8]
   21c14:	e3530000 	cmp	r3, #0
   21c18:	1affffe1 	bne	21ba4 <__sfvwrite_r+0x98>
   21c1c:	ea00014e 	b	2215c <__sfvwrite_r+0x650>
    }
  else if ((fp->_flags & __SLBF) == 0)
   21c20:	e1d430bc 	ldrh	r3, [r4, #12]
   21c24:	e1a03803 	lsl	r3, r3, #16
   21c28:	e1a03823 	lsr	r3, r3, #16
   21c2c:	e2033001 	and	r3, r3, #1
   21c30:	e3530000 	cmp	r3, #0
   21c34:	1a0000c6 	bne	21f54 <__sfvwrite_r+0x448>
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
   21c38:	ea000002 	b	21c48 <__sfvwrite_r+0x13c>
   21c3c:	e5987000 	ldr	r7, [r8]
   21c40:	e5986004 	ldr	r6, [r8, #4]
   21c44:	e2888008 	add	r8, r8, #8
   21c48:	e3560000 	cmp	r6, #0
   21c4c:	0afffffa 	beq	21c3c <__sfvwrite_r+0x130>
	  w = fp->_w;
   21c50:	e5945008 	ldr	r5, [r4, #8]
	  if (fp->_flags & __SSTR)
   21c54:	e1d430bc 	ldrh	r3, [r4, #12]
   21c58:	e1a03803 	lsl	r3, r3, #16
   21c5c:	e1a03823 	lsr	r3, r3, #16
   21c60:	e2033c02 	and	r3, r3, #512	; 0x200
   21c64:	e3530000 	cmp	r3, #0
   21c68:	0a000077 	beq	21e4c <__sfvwrite_r+0x340>
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
   21c6c:	e1a03005 	mov	r3, r5
   21c70:	e1530006 	cmp	r3, r6
   21c74:	8a000061 	bhi	21e00 <__sfvwrite_r+0x2f4>
   21c78:	e1d430bc 	ldrh	r3, [r4, #12]
   21c7c:	e1a03803 	lsl	r3, r3, #16
   21c80:	e1a03823 	lsr	r3, r3, #16
   21c84:	e2033d12 	and	r3, r3, #1152	; 0x480
   21c88:	e3530000 	cmp	r3, #0
   21c8c:	0a00005b 	beq	21e00 <__sfvwrite_r+0x2f4>
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
   21c90:	e5943000 	ldr	r3, [r4]
   21c94:	e1a02003 	mov	r2, r3
   21c98:	e5943010 	ldr	r3, [r4, #16]
   21c9c:	e0633002 	rsb	r3, r3, r2
   21ca0:	e50b3038 	str	r3, [fp, #-56]	; 0x38
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   21ca4:	e5942014 	ldr	r2, [r4, #20]
   21ca8:	e1a03002 	mov	r3, r2
   21cac:	e1a03083 	lsl	r3, r3, #1
   21cb0:	e0833002 	add	r3, r3, r2
   21cb4:	e1a02fa3 	lsr	r2, r3, #31
   21cb8:	e0823003 	add	r3, r2, r3
   21cbc:	e1a030c3 	asr	r3, r3, #1
   21cc0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
		  if (newsize < curpos + len + 1)
   21cc4:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   21cc8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   21ccc:	e0833006 	add	r3, r3, r6
   21cd0:	e2833001 	add	r3, r3, #1
   21cd4:	e1520003 	cmp	r2, r3
   21cd8:	2a000003 	bcs	21cec <__sfvwrite_r+0x1e0>
		    newsize = curpos + len + 1;
   21cdc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   21ce0:	e0833006 	add	r3, r3, r6
   21ce4:	e2833001 	add	r3, r3, #1
   21ce8:	e50b3034 	str	r3, [fp, #-52]	; 0x34
		  if (fp->_flags & __SOPT)
   21cec:	e1d430bc 	ldrh	r3, [r4, #12]
   21cf0:	e1a03803 	lsl	r3, r3, #16
   21cf4:	e1a03823 	lsr	r3, r3, #16
   21cf8:	e2033b01 	and	r3, r3, #1024	; 0x400
   21cfc:	e3530000 	cmp	r3, #0
   21d00:	0a00001a 	beq	21d70 <__sfvwrite_r+0x264>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
   21d04:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   21d08:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   21d0c:	e1a01003 	mov	r1, r3
   21d10:	ebffd767 	bl	17ab4 <_malloc_r>
   21d14:	e50b0030 	str	r0, [fp, #-48]	; 0x30
		      if (!str)
   21d18:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   21d1c:	e3530000 	cmp	r3, #0
   21d20:	1a000003 	bne	21d34 <__sfvwrite_r+0x228>
			{
			  ptr->_errno = ENOMEM;
   21d24:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   21d28:	e3a0200c 	mov	r2, #12
   21d2c:	e5832000 	str	r2, [r3]
			  goto err;
   21d30:	ea00010b 	b	22164 <__sfvwrite_r+0x658>
			}
		      memcpy (str, fp->_bf._base, curpos);
   21d34:	e5942010 	ldr	r2, [r4, #16]
   21d38:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   21d3c:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   21d40:	e1a01002 	mov	r1, r2
   21d44:	e1a02003 	mov	r2, r3
   21d48:	ebffda20 	bl	185d0 <memcpy>
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
   21d4c:	e1d430bc 	ldrh	r3, [r4, #12]
   21d50:	e3c33d12 	bic	r3, r3, #1152	; 0x480
   21d54:	e1a03803 	lsl	r3, r3, #16
   21d58:	e1a03823 	lsr	r3, r3, #16
   21d5c:	e3833080 	orr	r3, r3, #128	; 0x80
   21d60:	e1a03803 	lsl	r3, r3, #16
   21d64:	e1a03823 	lsr	r3, r3, #16
   21d68:	e1c430bc 	strh	r3, [r4, #12]
   21d6c:	ea000016 	b	21dcc <__sfvwrite_r+0x2c0>
		    }
		  else
		    {
		      str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
   21d70:	e5942010 	ldr	r2, [r4, #16]
   21d74:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   21d78:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   21d7c:	e1a01002 	mov	r1, r2
   21d80:	e1a02003 	mov	r2, r3
   21d84:	eb0009e3 	bl	24518 <_realloc_r>
   21d88:	e50b0030 	str	r0, [fp, #-48]	; 0x30
							 newsize);
		      if (!str)
   21d8c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   21d90:	e3530000 	cmp	r3, #0
   21d94:	1a00000c 	bne	21dcc <__sfvwrite_r+0x2c0>
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
   21d98:	e5943010 	ldr	r3, [r4, #16]
   21d9c:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   21da0:	e1a01003 	mov	r1, r3
   21da4:	ebffd2b9 	bl	16890 <_free_r>
			  fp->_flags &=  ~__SMBF;
   21da8:	e1d430bc 	ldrh	r3, [r4, #12]
   21dac:	e3c33080 	bic	r3, r3, #128	; 0x80
   21db0:	e1a03803 	lsl	r3, r3, #16
   21db4:	e1a03823 	lsr	r3, r3, #16
   21db8:	e1c430bc 	strh	r3, [r4, #12]
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
   21dbc:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   21dc0:	e3a0200c 	mov	r2, #12
   21dc4:	e5832000 	str	r2, [r3]
			  goto err;
   21dc8:	ea0000e5 	b	22164 <__sfvwrite_r+0x658>
			}
		    }
		  fp->_bf._base = str;
   21dcc:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   21dd0:	e5843010 	str	r3, [r4, #16]
		  fp->_p = str + curpos;
   21dd4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   21dd8:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   21ddc:	e0823003 	add	r3, r2, r3
   21de0:	e5843000 	str	r3, [r4]
		  fp->_bf._size = newsize;
   21de4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   21de8:	e5843014 	str	r3, [r4, #20]
		  w = len;
   21dec:	e1a05006 	mov	r5, r6
		  fp->_w = newsize - curpos;
   21df0:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   21df4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   21df8:	e0633002 	rsb	r3, r3, r2
   21dfc:	e5843008 	str	r3, [r4, #8]
		}
	      if (len < w)
   21e00:	e1a03005 	mov	r3, r5
   21e04:	e1530006 	cmp	r3, r6
   21e08:	9a000000 	bls	21e10 <__sfvwrite_r+0x304>
		w = len;
   21e0c:	e1a05006 	mov	r5, r6
	      COPY (w);		/* copy MIN(fp->_w,len), */
   21e10:	e5942000 	ldr	r2, [r4]
   21e14:	e1a03005 	mov	r3, r5
   21e18:	e1a00002 	mov	r0, r2
   21e1c:	e1a01007 	mov	r1, r7
   21e20:	e1a02003 	mov	r2, r3
   21e24:	eb00026a 	bl	227d4 <memmove>
	      fp->_w -= w;
   21e28:	e5943008 	ldr	r3, [r4, #8]
   21e2c:	e0653003 	rsb	r3, r5, r3
   21e30:	e5843008 	str	r3, [r4, #8]
	      fp->_p += w;
   21e34:	e5942000 	ldr	r2, [r4]
   21e38:	e1a03005 	mov	r3, r5
   21e3c:	e0823003 	add	r3, r2, r3
   21e40:	e5843000 	str	r3, [r4]
	      w = len;		/* but pretend copied all */
   21e44:	e1a05006 	mov	r5, r6
   21e48:	ea000036 	b	21f28 <__sfvwrite_r+0x41c>
	    }
	  else if (fp->_p > fp->_bf._base && len > w)
   21e4c:	e5942000 	ldr	r2, [r4]
   21e50:	e5943010 	ldr	r3, [r4, #16]
   21e54:	e1520003 	cmp	r2, r3
   21e58:	9a000014 	bls	21eb0 <__sfvwrite_r+0x3a4>
   21e5c:	e1a03005 	mov	r3, r5
   21e60:	e1530006 	cmp	r3, r6
   21e64:	2a000011 	bcs	21eb0 <__sfvwrite_r+0x3a4>
	    {
	      /* fill and flush */
	      COPY (w);
   21e68:	e5942000 	ldr	r2, [r4]
   21e6c:	e1a03005 	mov	r3, r5
   21e70:	e1a00002 	mov	r0, r2
   21e74:	e1a01007 	mov	r1, r7
   21e78:	e1a02003 	mov	r2, r3
   21e7c:	eb000254 	bl	227d4 <memmove>
	      /* fp->_w -= w; *//* unneeded */
	      fp->_p += w;
   21e80:	e5942000 	ldr	r2, [r4]
   21e84:	e1a03005 	mov	r3, r5
   21e88:	e0823003 	add	r3, r2, r3
   21e8c:	e5843000 	str	r3, [r4]
	      if (_fflush_r (ptr, fp))
   21e90:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   21e94:	e1a01004 	mov	r1, r4
   21e98:	ebffd070 	bl	16060 <_fflush_r>
   21e9c:	e1a03000 	mov	r3, r0
   21ea0:	e3530000 	cmp	r3, #0
   21ea4:	0a000000 	beq	21eac <__sfvwrite_r+0x3a0>
		goto err;
   21ea8:	ea0000ad 	b	22164 <__sfvwrite_r+0x658>
	    {
	      /* fill and flush */
	      COPY (w);
	      /* fp->_w -= w; *//* unneeded */
	      fp->_p += w;
	      if (_fflush_r (ptr, fp))
   21eac:	ea00001d 	b	21f28 <__sfvwrite_r+0x41c>
		goto err;
	    }
	  else if (len >= (w = fp->_bf._size))
   21eb0:	e5945014 	ldr	r5, [r4, #20]
   21eb4:	e1a03005 	mov	r3, r5
   21eb8:	e1530006 	cmp	r3, r6
   21ebc:	8a00000b 	bhi	21ef0 <__sfvwrite_r+0x3e4>
	    {
	      /* write directly */
	      w = fp->_write (ptr, fp->_cookie, p, w);
   21ec0:	e594c024 	ldr	ip, [r4, #36]	; 0x24
   21ec4:	e594301c 	ldr	r3, [r4, #28]
   21ec8:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   21ecc:	e1a01003 	mov	r1, r3
   21ed0:	e1a02007 	mov	r2, r7
   21ed4:	e1a03005 	mov	r3, r5
   21ed8:	e1a0e00f 	mov	lr, pc
   21edc:	e12fff1c 	bx	ip
   21ee0:	e1a05000 	mov	r5, r0
	      if (w <= 0)
   21ee4:	e3550000 	cmp	r5, #0
   21ee8:	ca00000e 	bgt	21f28 <__sfvwrite_r+0x41c>
		goto err;
   21eec:	ea00009c 	b	22164 <__sfvwrite_r+0x658>
	    }
	  else
	    {
	      /* fill and done */
	      w = len;
   21ef0:	e1a05006 	mov	r5, r6
	      COPY (w);
   21ef4:	e5942000 	ldr	r2, [r4]
   21ef8:	e1a03005 	mov	r3, r5
   21efc:	e1a00002 	mov	r0, r2
   21f00:	e1a01007 	mov	r1, r7
   21f04:	e1a02003 	mov	r2, r3
   21f08:	eb000231 	bl	227d4 <memmove>
	      fp->_w -= w;
   21f0c:	e5943008 	ldr	r3, [r4, #8]
   21f10:	e0653003 	rsb	r3, r5, r3
   21f14:	e5843008 	str	r3, [r4, #8]
	      fp->_p += w;
   21f18:	e5942000 	ldr	r2, [r4]
   21f1c:	e1a03005 	mov	r3, r5
   21f20:	e0823003 	add	r3, r2, r3
   21f24:	e5843000 	str	r3, [r4]
	    }
	  p += w;
   21f28:	e1a03005 	mov	r3, r5
   21f2c:	e0877003 	add	r7, r7, r3
	  len -= w;
   21f30:	e1a03005 	mov	r3, r5
   21f34:	e0636006 	rsb	r6, r3, r6
	}
      while ((uio->uio_resid -= w) != 0);
   21f38:	e5993008 	ldr	r3, [r9, #8]
   21f3c:	e0653003 	rsb	r3, r5, r3
   21f40:	e5893008 	str	r3, [r9, #8]
   21f44:	e5993008 	ldr	r3, [r9, #8]
   21f48:	e3530000 	cmp	r3, #0
   21f4c:	1affff39 	bne	21c38 <__sfvwrite_r+0x12c>
   21f50:	ea000081 	b	2215c <__sfvwrite_r+0x650>
       * must check for newlines.  Compute the distance
       * to the first newline (including the newline),
       * or `infinity' if there is none, then pretend
       * that the amount to write is MIN(len,nldist).
       */
      nlknown = 0;
   21f54:	e3a03000 	mov	r3, #0
   21f58:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      nldist = 0;
   21f5c:	e3a03000 	mov	r3, #0
   21f60:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
      do
	{
	  GETIOV (nlknown = 0);
   21f64:	ea000004 	b	21f7c <__sfvwrite_r+0x470>
   21f68:	e3a03000 	mov	r3, #0
   21f6c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
   21f70:	e5987000 	ldr	r7, [r8]
   21f74:	e5986004 	ldr	r6, [r8, #4]
   21f78:	e2888008 	add	r8, r8, #8
   21f7c:	e3560000 	cmp	r6, #0
   21f80:	0afffff8 	beq	21f68 <__sfvwrite_r+0x45c>
	  if (!nlknown)
   21f84:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   21f88:	e3530000 	cmp	r3, #0
   21f8c:	1a000011 	bne	21fd8 <__sfvwrite_r+0x4cc>
	    {
	      nl = memchr ((_PTR) p, '\n', len);
   21f90:	e1a00007 	mov	r0, r7
   21f94:	e3a0100a 	mov	r1, #10
   21f98:	e1a02006 	mov	r2, r6
   21f9c:	eb00019a 	bl	2260c <memchr>
   21fa0:	e50b003c 	str	r0, [fp, #-60]	; 0x3c
	      nldist = nl ? nl + 1 - p : len + 1;
   21fa4:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   21fa8:	e3530000 	cmp	r3, #0
   21fac:	0a000005 	beq	21fc8 <__sfvwrite_r+0x4bc>
   21fb0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   21fb4:	e2833001 	add	r3, r3, #1
   21fb8:	e1a02003 	mov	r2, r3
   21fbc:	e1a03007 	mov	r3, r7
   21fc0:	e0633002 	rsb	r3, r3, r2
   21fc4:	ea000000 	b	21fcc <__sfvwrite_r+0x4c0>
   21fc8:	e2863001 	add	r3, r6, #1
   21fcc:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	      nlknown = 1;
   21fd0:	e3a03001 	mov	r3, #1
   21fd4:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	    }
	  s = MIN (len, nldist);
   21fd8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   21fdc:	e1530006 	cmp	r3, r6
   21fe0:	31a03003 	movcc	r3, r3
   21fe4:	21a03006 	movcs	r3, r6
   21fe8:	e1a0a003 	mov	sl, r3

//      cpu_dcache_inv_addr((void*)&(fp->_bf._size));
//      cpu_dcache_inv_addr((void*)&(fp->_w));
	  w = fp->_w + fp->_bf._size;
   21fec:	e5942008 	ldr	r2, [r4, #8]
   21ff0:	e5943014 	ldr	r3, [r4, #20]
   21ff4:	e0825003 	add	r5, r2, r3

      cpu_dcache_invalidate((void*)(fp), sizeof(struct __sFILE));
   21ff8:	e1a00004 	mov	r0, r4
   21ffc:	e3a01070 	mov	r1, #112	; 0x70
   22000:	ebffb98e 	bl	10640 <cpu_dcache_invalidate>
      cpu_dcache_invalidate((void*)&(fp->_bf._base), sizeof(unsigned char*));
   22004:	e2843010 	add	r3, r4, #16
   22008:	e1a00003 	mov	r0, r3
   2200c:	e3a01004 	mov	r1, #4
   22010:	ebffb98a 	bl	10640 <cpu_dcache_invalidate>
      cpu_dcache_invalidate((void*)&(fp->_p), sizeof(unsigned char*));
   22014:	e1a03004 	mov	r3, r4
   22018:	e1a00003 	mov	r0, r3
   2201c:	e3a01004 	mov	r1, #4
   22020:	ebffb986 	bl	10640 <cpu_dcache_invalidate>
	  if (fp->_p > fp->_bf._base && s > w)
   22024:	e5942000 	ldr	r2, [r4]
   22028:	e5943010 	ldr	r3, [r4, #16]
   2202c:	e1520003 	cmp	r2, r3
   22030:	9a000013 	bls	22084 <__sfvwrite_r+0x578>
   22034:	e15a0005 	cmp	sl, r5
   22038:	da000011 	ble	22084 <__sfvwrite_r+0x578>
	    {
	      COPY (w);
   2203c:	e5942000 	ldr	r2, [r4]
   22040:	e1a03005 	mov	r3, r5
   22044:	e1a00002 	mov	r0, r2
   22048:	e1a01007 	mov	r1, r7
   2204c:	e1a02003 	mov	r2, r3
   22050:	eb0001df 	bl	227d4 <memmove>
	      /* fp->_w -= w; */
	      fp->_p += w;
   22054:	e5942000 	ldr	r2, [r4]
   22058:	e1a03005 	mov	r3, r5
   2205c:	e0823003 	add	r3, r2, r3
   22060:	e5843000 	str	r3, [r4]
	      if (_fflush_r (ptr, fp))
   22064:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   22068:	e1a01004 	mov	r1, r4
   2206c:	ebffcffb 	bl	16060 <_fflush_r>
   22070:	e1a03000 	mov	r3, r0
   22074:	e3530000 	cmp	r3, #0
   22078:	0a000000 	beq	22080 <__sfvwrite_r+0x574>
		goto err;
   2207c:	ea000038 	b	22164 <__sfvwrite_r+0x658>
	  if (fp->_p > fp->_bf._base && s > w)
	    {
	      COPY (w);
	      /* fp->_w -= w; */
	      fp->_p += w;
	      if (_fflush_r (ptr, fp))
   22080:	ea00001c 	b	220f8 <__sfvwrite_r+0x5ec>
		goto err;
	    }
	  else if (s >= (w = fp->_bf._size))
   22084:	e5945014 	ldr	r5, [r4, #20]
   22088:	e155000a 	cmp	r5, sl
   2208c:	ca00000b 	bgt	220c0 <__sfvwrite_r+0x5b4>
	    {
	      w = fp->_write (ptr, fp->_cookie, p, w);
   22090:	e594c024 	ldr	ip, [r4, #36]	; 0x24
   22094:	e594301c 	ldr	r3, [r4, #28]
   22098:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   2209c:	e1a01003 	mov	r1, r3
   220a0:	e1a02007 	mov	r2, r7
   220a4:	e1a03005 	mov	r3, r5
   220a8:	e1a0e00f 	mov	lr, pc
   220ac:	e12fff1c 	bx	ip
   220b0:	e1a05000 	mov	r5, r0
	      if (w <= 0)
   220b4:	e3550000 	cmp	r5, #0
   220b8:	ca00000e 	bgt	220f8 <__sfvwrite_r+0x5ec>
		goto err;
   220bc:	ea000028 	b	22164 <__sfvwrite_r+0x658>
	    }
	  else
	    {
	      w = s;
   220c0:	e1a0500a 	mov	r5, sl
	      COPY (w);
   220c4:	e5942000 	ldr	r2, [r4]
   220c8:	e1a03005 	mov	r3, r5
   220cc:	e1a00002 	mov	r0, r2
   220d0:	e1a01007 	mov	r1, r7
   220d4:	e1a02003 	mov	r2, r3
   220d8:	eb0001bd 	bl	227d4 <memmove>
	      fp->_w -= w;
   220dc:	e5943008 	ldr	r3, [r4, #8]
   220e0:	e0653003 	rsb	r3, r5, r3
   220e4:	e5843008 	str	r3, [r4, #8]
	      fp->_p += w;
   220e8:	e5942000 	ldr	r2, [r4]
   220ec:	e1a03005 	mov	r3, r5
   220f0:	e0823003 	add	r3, r2, r3
   220f4:	e5843000 	str	r3, [r4]
	    }
	  if ((nldist -= w) == 0)
   220f8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   220fc:	e0653003 	rsb	r3, r5, r3
   22100:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   22104:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   22108:	e3530000 	cmp	r3, #0
   2210c:	1a000008 	bne	22134 <__sfvwrite_r+0x628>
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
   22110:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   22114:	e1a01004 	mov	r1, r4
   22118:	ebffcfd0 	bl	16060 <_fflush_r>
   2211c:	e1a03000 	mov	r3, r0
   22120:	e3530000 	cmp	r3, #0
   22124:	0a000000 	beq	2212c <__sfvwrite_r+0x620>
		goto err;
   22128:	ea00000d 	b	22164 <__sfvwrite_r+0x658>
	      nlknown = 0;
   2212c:	e3a03000 	mov	r3, #0
   22130:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	    }
	  p += w;
   22134:	e1a03005 	mov	r3, r5
   22138:	e0877003 	add	r7, r7, r3
	  len -= w;
   2213c:	e1a03005 	mov	r3, r5
   22140:	e0636006 	rsb	r6, r3, r6
	}
      while ((uio->uio_resid -= w) != 0);
   22144:	e5993008 	ldr	r3, [r9, #8]
   22148:	e0653003 	rsb	r3, r5, r3
   2214c:	e5893008 	str	r3, [r9, #8]
   22150:	e5993008 	ldr	r3, [r9, #8]
   22154:	e3530000 	cmp	r3, #0
   22158:	1affff81 	bne	21f64 <__sfvwrite_r+0x458>
    }
  return 0;
   2215c:	e3a03000 	mov	r3, #0
   22160:	ea000005 	b	2217c <__sfvwrite_r+0x670>

err:
  fp->_flags |= __SERR;
   22164:	e1d430bc 	ldrh	r3, [r4, #12]
   22168:	e3833040 	orr	r3, r3, #64	; 0x40
   2216c:	e1a03803 	lsl	r3, r3, #16
   22170:	e1a03823 	lsr	r3, r3, #16
   22174:	e1c430bc 	strh	r3, [r4, #12]
  return EOF;
   22178:	e3e03000 	mvn	r3, #0
}
   2217c:	e1a00003 	mov	r0, r3
   22180:	e24bd020 	sub	sp, fp, #32
   22184:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   22188:	e12fff1e 	bx	lr

0002218c <_setlocale_r>:
char *
_DEFUN(_setlocale_r, (p, category, locale),
       struct _reent *p _AND
       int category _AND
       _CONST char *locale)
{
   2218c:	e92d4800 	push	{fp, lr}
   22190:	e28db004 	add	fp, sp, #4
   22194:	e24dd010 	sub	sp, sp, #16
   22198:	e50b0008 	str	r0, [fp, #-8]
   2219c:	e50b100c 	str	r1, [fp, #-12]
   221a0:	e50b2010 	str	r2, [fp, #-16]
#ifndef _MB_CAPABLE
  if (locale)
   221a4:	e51b3010 	ldr	r3, [fp, #-16]
   221a8:	e3530000 	cmp	r3, #0
   221ac:	0a000013 	beq	22200 <_setlocale_r+0x74>
    { 
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
   221b0:	e51b0010 	ldr	r0, [fp, #-16]
   221b4:	e59f1058 	ldr	r1, [pc, #88]	; 22214 <_setlocale_r+0x88>
   221b8:	eb000d20 	bl	25640 <strcmp>
   221bc:	e1a03000 	mov	r3, r0
   221c0:	e3530000 	cmp	r3, #0
   221c4:	0a00000d 	beq	22200 <_setlocale_r+0x74>
   221c8:	e51b0010 	ldr	r0, [fp, #-16]
   221cc:	e59f1044 	ldr	r1, [pc, #68]	; 22218 <_setlocale_r+0x8c>
   221d0:	eb000d1a 	bl	25640 <strcmp>
   221d4:	e1a03000 	mov	r3, r0
   221d8:	e3530000 	cmp	r3, #0
   221dc:	0a000007 	beq	22200 <_setlocale_r+0x74>
	  && strcmp (locale, ""))
   221e0:	e51b0010 	ldr	r0, [fp, #-16]
   221e4:	e59f1030 	ldr	r1, [pc, #48]	; 2221c <_setlocale_r+0x90>
   221e8:	eb000d14 	bl	25640 <strcmp>
   221ec:	e1a03000 	mov	r3, r0
   221f0:	e3530000 	cmp	r3, #0
   221f4:	0a000001 	beq	22200 <_setlocale_r+0x74>
        return NULL;
   221f8:	e3a03000 	mov	r3, #0
   221fc:	ea000000 	b	22204 <_setlocale_r+0x78>
    }
  return "C";
   22200:	e59f3010 	ldr	r3, [pc, #16]	; 22218 <_setlocale_r+0x8c>
	  return NULL;
	}
    }
  return currentlocale ();
#endif /* !_MB_CAPABLE */
}
   22204:	e1a00003 	mov	r0, r3
   22208:	e24bd004 	sub	sp, fp, #4
   2220c:	e8bd4800 	pop	{fp, lr}
   22210:	e12fff1e 	bx	lr
   22214:	00033178 	.word	0x00033178
   22218:	00033180 	.word	0x00033180
   2221c:	00033174 	.word	0x00033174

00022220 <__locale_charset>:
}
#endif /* _MB_CAPABLE */

char *
_DEFUN_VOID(__locale_charset)
{
   22220:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   22224:	e28db000 	add	fp, sp, #0
#if 0//def __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->codeset;
#else
  return lc_ctype_charset;
   22228:	e59f300c 	ldr	r3, [pc, #12]	; 2223c <__locale_charset+0x1c>
#endif
}
   2222c:	e1a00003 	mov	r0, r3
   22230:	e24bd000 	sub	sp, fp, #0
   22234:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   22238:	e12fff1e 	bx	lr
   2223c:	0003e8c4 	.word	0x0003e8c4

00022240 <__locale_mb_cur_max>:

int
_DEFUN_VOID(__locale_mb_cur_max)
{
   22240:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   22244:	e28db000 	add	fp, sp, #0
#if 0//def __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->mb_cur_max[0];
#else
  return __mb_cur_max;
   22248:	e59f3010 	ldr	r3, [pc, #16]	; 22260 <__locale_mb_cur_max+0x20>
   2224c:	e5933000 	ldr	r3, [r3]
#endif
}
   22250:	e1a00003 	mov	r0, r3
   22254:	e24bd000 	sub	sp, fp, #0
   22258:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   2225c:	e12fff1e 	bx	lr
   22260:	0003e888 	.word	0x0003e888

00022264 <__locale_msgcharset>:


char *
_DEFUN_VOID(__locale_msgcharset)
{
   22264:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   22268:	e28db000 	add	fp, sp, #0
#ifdef __HAVE_LOCALE_INFO__
  return (char *) __get_current_messages_locale ()->codeset;
#else
  return lc_message_charset;
   2226c:	e59f300c 	ldr	r3, [pc, #12]	; 22280 <__locale_msgcharset+0x1c>
#endif
}
   22270:	e1a00003 	mov	r0, r3
   22274:	e24bd000 	sub	sp, fp, #0
   22278:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   2227c:	e12fff1e 	bx	lr
   22280:	0003e8e4 	.word	0x0003e8e4

00022284 <__locale_cjk_lang>:

int
_DEFUN_VOID(__locale_cjk_lang)
{
   22284:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   22288:	e28db000 	add	fp, sp, #0
  return lc_ctype_cjk_lang;
   2228c:	e59f3010 	ldr	r3, [pc, #16]	; 222a4 <__locale_cjk_lang+0x20>
   22290:	e5933000 	ldr	r3, [r3]
}
   22294:	e1a00003 	mov	r0, r3
   22298:	e24bd000 	sub	sp, fp, #0
   2229c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   222a0:	e12fff1e 	bx	lr
   222a4:	0013ea20 	.word	0x0013ea20

000222a8 <_localeconv_r>:

struct lconv *
_DEFUN(_localeconv_r, (data), 
      struct _reent *data)
{
   222a8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   222ac:	e28db000 	add	fp, sp, #0
   222b0:	e24dd00c 	sub	sp, sp, #12
   222b4:	e50b0008 	str	r0, [fp, #-8]
      lconv.int_p_sign_posn = m->p_sign_posn[0];
#endif /* !__HAVE_LOCALE_INFO_EXTENDED__ */
      __mlocale_changed = 0;
    }
#endif /* __HAVE_LOCALE_INFO__ */
  return (struct lconv *) &lconv;
   222b8:	e59f300c 	ldr	r3, [pc, #12]	; 222cc <_localeconv_r+0x24>
}
   222bc:	e1a00003 	mov	r0, r3
   222c0:	e24bd000 	sub	sp, fp, #0
   222c4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   222c8:	e12fff1e 	bx	lr
   222cc:	0003e88c 	.word	0x0003e88c

000222d0 <setlocale>:
   initialization work.  It calls _setlocale_r, though. */
char *
_DEFUN(setlocale, (category, locale),
       int category _AND
       _CONST char *locale)
{
   222d0:	e92d4800 	push	{fp, lr}
   222d4:	e28db004 	add	fp, sp, #4
   222d8:	e24dd008 	sub	sp, sp, #8
   222dc:	e50b0008 	str	r0, [fp, #-8]
   222e0:	e50b100c 	str	r1, [fp, #-12]
  return _setlocale_r (_REENT, category, locale);
   222e4:	e59f3024 	ldr	r3, [pc, #36]	; 22310 <setlocale+0x40>
   222e8:	e5933000 	ldr	r3, [r3]
   222ec:	e1a00003 	mov	r0, r3
   222f0:	e51b1008 	ldr	r1, [fp, #-8]
   222f4:	e51b200c 	ldr	r2, [fp, #-12]
   222f8:	ebffffa3 	bl	2218c <_setlocale_r>
   222fc:	e1a03000 	mov	r3, r0
}
   22300:	e1a00003 	mov	r0, r3
   22304:	e24bd004 	sub	sp, fp, #4
   22308:	e8bd4800 	pop	{fp, lr}
   2230c:	e12fff1e 	bx	lr
   22310:	0003e460 	.word	0x0003e460

00022314 <localeconv>:
#endif /* __CYGWIN__ */

struct lconv *
_DEFUN_VOID(localeconv)
{
   22314:	e92d4800 	push	{fp, lr}
   22318:	e28db004 	add	fp, sp, #4
  return _localeconv_r (_REENT);
   2231c:	e59f301c 	ldr	r3, [pc, #28]	; 22340 <localeconv+0x2c>
   22320:	e5933000 	ldr	r3, [r3]
   22324:	e1a00003 	mov	r0, r3
   22328:	ebffffde 	bl	222a8 <_localeconv_r>
   2232c:	e1a03000 	mov	r3, r0
}
   22330:	e1a00003 	mov	r0, r3
   22334:	e24bd004 	sub	sp, fp, #4
   22338:	e8bd4800 	pop	{fp, lr}
   2233c:	e12fff1e 	bx	lr
   22340:	0003e460 	.word	0x0003e460

00022344 <_lseek_r>:
_DEFUN (_lseek_r, (ptr, fd, pos, whence),
     struct _reent *ptr _AND
     int fd _AND
     _off_t pos _AND
     int whence)
{
   22344:	e92d4810 	push	{r4, fp, lr}
   22348:	e28db008 	add	fp, sp, #8
   2234c:	e24dd024 	sub	sp, sp, #36	; 0x24
   22350:	e50b0018 	str	r0, [fp, #-24]
   22354:	e50b101c 	str	r1, [fp, #-28]
   22358:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   2235c:	e50b3020 	str	r3, [fp, #-32]
  _off_t ret;

  errno = 0;
   22360:	e59f307c 	ldr	r3, [pc, #124]	; 223e4 <_lseek_r+0xa0>
   22364:	e3a02000 	mov	r2, #0
   22368:	e5832000 	str	r2, [r3]
  if ((ret = _lseek (fd, pos, whence)) == (_off_t) -1 && errno != 0)
   2236c:	e59b3004 	ldr	r3, [fp, #4]
   22370:	e58d3000 	str	r3, [sp]
   22374:	e51b001c 	ldr	r0, [fp, #-28]
   22378:	e24b3024 	sub	r3, fp, #36	; 0x24
   2237c:	e893000c 	ldm	r3, {r2, r3}
   22380:	eb001b6b 	bl	29134 <lseek>
   22384:	e50b0014 	str	r0, [fp, #-20]
   22388:	e50b1010 	str	r1, [fp, #-16]
   2238c:	e24b2014 	sub	r2, fp, #20
   22390:	e8920006 	ldm	r2, {r1, r2}
   22394:	e3e03000 	mvn	r3, #0
   22398:	e3e04000 	mvn	r4, #0
   2239c:	e1520004 	cmp	r2, r4
   223a0:	01510003 	cmpeq	r1, r3
   223a4:	1a000007 	bne	223c8 <_lseek_r+0x84>
   223a8:	e59f3034 	ldr	r3, [pc, #52]	; 223e4 <_lseek_r+0xa0>
   223ac:	e5933000 	ldr	r3, [r3]
   223b0:	e3530000 	cmp	r3, #0
   223b4:	0a000003 	beq	223c8 <_lseek_r+0x84>
    ptr->_errno = errno;
   223b8:	e59f3024 	ldr	r3, [pc, #36]	; 223e4 <_lseek_r+0xa0>
   223bc:	e5932000 	ldr	r2, [r3]
   223c0:	e51b3018 	ldr	r3, [fp, #-24]
   223c4:	e5832000 	str	r2, [r3]
  return ret;
   223c8:	e24b4014 	sub	r4, fp, #20
   223cc:	e8940018 	ldm	r4, {r3, r4}
}
   223d0:	e1a00003 	mov	r0, r3
   223d4:	e1a01004 	mov	r1, r4
   223d8:	e24bd008 	sub	sp, fp, #8
   223dc:	e8bd4810 	pop	{r4, fp, lr}
   223e0:	e12fff1e 	bx	lr
   223e4:	0018b940 	.word	0x0018b940

000223e8 <__smakebuf_r>:

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
   223e8:	e92d48f0 	push	{r4, r5, r6, r7, fp, lr}
   223ec:	e28db014 	add	fp, sp, #20
   223f0:	e24dd060 	sub	sp, sp, #96	; 0x60
   223f4:	e50b0070 	str	r0, [fp, #-112]	; 0x70
   223f8:	e1a04001 	mov	r4, r1
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   223fc:	e1d430bc 	ldrh	r3, [r4, #12]
   22400:	e1a03803 	lsl	r3, r3, #16
   22404:	e1a03823 	lsr	r3, r3, #16
   22408:	e2033002 	and	r3, r3, #2
   2240c:	e3530000 	cmp	r3, #0
   22410:	0a000006 	beq	22430 <__smakebuf_r+0x48>
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
   22414:	e2843043 	add	r3, r4, #67	; 0x43
   22418:	e5843000 	str	r3, [r4]
   2241c:	e5943000 	ldr	r3, [r4]
   22420:	e5843010 	str	r3, [r4, #16]
      fp->_bf._size = 1;
   22424:	e3a03001 	mov	r3, #1
   22428:	e5843014 	str	r3, [r4, #20]
   2242c:	ea000071 	b	225f8 <__smakebuf_r+0x210>
      return;
    }
#ifdef __USE_INTERNAL_STAT64
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
   22430:	e1d430be 	ldrh	r3, [r4, #14]
   22434:	e1a03803 	lsl	r3, r3, #16
   22438:	e1a03843 	asr	r3, r3, #16
   2243c:	e3530000 	cmp	r3, #0
   22440:	ba00000a 	blt	22470 <__smakebuf_r+0x88>
   22444:	e1d430be 	ldrh	r3, [r4, #14]
   22448:	e1a03803 	lsl	r3, r3, #16
   2244c:	e1a02843 	asr	r2, r3, #16
   22450:	e24b306c 	sub	r3, fp, #108	; 0x6c
   22454:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   22458:	e1a01002 	mov	r1, r2
   2245c:	e1a02003 	mov	r2, r3
   22460:	eb001af9 	bl	2904c <_fstat_r>
   22464:	e1a03000 	mov	r3, r0
   22468:	e3530000 	cmp	r3, #0
   2246c:	aa00000f 	bge	224b0 <__smakebuf_r+0xc8>
#endif
    {
      couldbetty = 0;
   22470:	e3a06000 	mov	r6, #0
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
   22474:	e1d430bc 	ldrh	r3, [r4, #12]
   22478:	e1a03803 	lsl	r3, r3, #16
   2247c:	e1a03823 	lsr	r3, r3, #16
   22480:	e2033080 	and	r3, r3, #128	; 0x80
   22484:	e3530000 	cmp	r3, #0
   22488:	0a000001 	beq	22494 <__smakebuf_r+0xac>
        size = _DEFAULT_ASPRINTF_BUFSIZE;
   2248c:	e3a05040 	mov	r5, #64	; 0x40
   22490:	ea000000 	b	22498 <__smakebuf_r+0xb0>
      else
        size = BUFSIZ;
   22494:	e3a05b01 	mov	r5, #1024	; 0x400
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   22498:	e1d430bc 	ldrh	r3, [r4, #12]
   2249c:	e3833b02 	orr	r3, r3, #2048	; 0x800
   224a0:	e1a03803 	lsl	r3, r3, #16
   224a4:	e1a03823 	lsr	r3, r3, #16
   224a8:	e1c430bc 	strh	r3, [r4, #12]
   224ac:	ea00001c 	b	22524 <__smakebuf_r+0x13c>
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
   224b0:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   224b4:	e2033a0f 	and	r3, r3, #61440	; 0xf000
   224b8:	e3530a02 	cmp	r3, #8192	; 0x2000
   224bc:	03a03001 	moveq	r3, #1
   224c0:	13a03000 	movne	r3, #0
   224c4:	e20330ff 	and	r3, r3, #255	; 0xff
   224c8:	e1a06003 	mov	r6, r3
#ifdef HAVE_BLKSIZE
      size = st.st_blksize <= 0 ? BUFSIZ : st.st_blksize;
#else
      size = BUFSIZ;
   224cc:	e3a05b01 	mov	r5, #1024	; 0x400
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   224d0:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   224d4:	e2033a0f 	and	r3, r3, #61440	; 0xf000
   224d8:	e3530902 	cmp	r3, #32768	; 0x8000
   224dc:	1a00000b 	bne	22510 <__smakebuf_r+0x128>
   224e0:	e5942028 	ldr	r2, [r4, #40]	; 0x28
   224e4:	e59f3118 	ldr	r3, [pc, #280]	; 22604 <__smakebuf_r+0x21c>
   224e8:	e1520003 	cmp	r2, r3
   224ec:	1a000007 	bne	22510 <__smakebuf_r+0x128>
	{
	  fp->_flags |= __SOPT;
   224f0:	e1d430bc 	ldrh	r3, [r4, #12]
   224f4:	e3833b01 	orr	r3, r3, #1024	; 0x400
   224f8:	e1a03803 	lsl	r3, r3, #16
   224fc:	e1a03823 	lsr	r3, r3, #16
   22500:	e1c430bc 	strh	r3, [r4, #12]
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
   22504:	e3a03b01 	mov	r3, #1024	; 0x400
   22508:	e584304c 	str	r3, [r4, #76]	; 0x4c
   2250c:	ea000004 	b	22524 <__smakebuf_r+0x13c>
#endif
	}
      else
	fp->_flags |= __SNPT;
   22510:	e1d430bc 	ldrh	r3, [r4, #12]
   22514:	e3833b02 	orr	r3, r3, #2048	; 0x800
   22518:	e1a03803 	lsl	r3, r3, #16
   2251c:	e1a03823 	lsr	r3, r3, #16
   22520:	e1c430bc 	strh	r3, [r4, #12]
#endif
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
   22524:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   22528:	e1a01005 	mov	r1, r5
   2252c:	ebffd560 	bl	17ab4 <_malloc_r>
   22530:	e1a07000 	mov	r7, r0
   22534:	e3570000 	cmp	r7, #0
   22538:	1a000011 	bne	22584 <__smakebuf_r+0x19c>
    {
      if (!(fp->_flags & __SSTR))
   2253c:	e1d430bc 	ldrh	r3, [r4, #12]
   22540:	e1a03803 	lsl	r3, r3, #16
   22544:	e1a03823 	lsr	r3, r3, #16
   22548:	e2033c02 	and	r3, r3, #512	; 0x200
   2254c:	e3530000 	cmp	r3, #0
   22550:	1a000028 	bne	225f8 <__smakebuf_r+0x210>
	{
	  fp->_flags |= __SNBF;
   22554:	e1d430bc 	ldrh	r3, [r4, #12]
   22558:	e3833002 	orr	r3, r3, #2
   2255c:	e1a03803 	lsl	r3, r3, #16
   22560:	e1a03823 	lsr	r3, r3, #16
   22564:	e1c430bc 	strh	r3, [r4, #12]
	  fp->_bf._base = fp->_p = fp->_nbuf;
   22568:	e2843043 	add	r3, r4, #67	; 0x43
   2256c:	e5843000 	str	r3, [r4]
   22570:	e5943000 	ldr	r3, [r4]
   22574:	e5843010 	str	r3, [r4, #16]
	  fp->_bf._size = 1;
   22578:	e3a03001 	mov	r3, #1
   2257c:	e5843014 	str	r3, [r4, #20]
   22580:	ea00001c 	b	225f8 <__smakebuf_r+0x210>
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
   22584:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   22588:	e59f2078 	ldr	r2, [pc, #120]	; 22608 <__smakebuf_r+0x220>
   2258c:	e583203c 	str	r2, [r3, #60]	; 0x3c
      fp->_flags |= __SMBF;
   22590:	e1d430bc 	ldrh	r3, [r4, #12]
   22594:	e3833080 	orr	r3, r3, #128	; 0x80
   22598:	e1a03803 	lsl	r3, r3, #16
   2259c:	e1a03823 	lsr	r3, r3, #16
   225a0:	e1c430bc 	strh	r3, [r4, #12]
      fp->_bf._base = fp->_p = (unsigned char *) p;
   225a4:	e5847000 	str	r7, [r4]
   225a8:	e5943000 	ldr	r3, [r4]
   225ac:	e5843010 	str	r3, [r4, #16]
      fp->_bf._size = size;
   225b0:	e1a03005 	mov	r3, r5
   225b4:	e5843014 	str	r3, [r4, #20]
      if (couldbetty && _isatty_r (ptr, fp->_file))
   225b8:	e3560000 	cmp	r6, #0
   225bc:	0a00000d 	beq	225f8 <__smakebuf_r+0x210>
   225c0:	e1d430be 	ldrh	r3, [r4, #14]
   225c4:	e1a03803 	lsl	r3, r3, #16
   225c8:	e1a03843 	asr	r3, r3, #16
   225cc:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   225d0:	e1a01003 	mov	r1, r3
   225d4:	eb001aba 	bl	290c4 <_isatty_r>
   225d8:	e1a03000 	mov	r3, r0
   225dc:	e3530000 	cmp	r3, #0
   225e0:	0a000004 	beq	225f8 <__smakebuf_r+0x210>
	fp->_flags |= __SLBF;
   225e4:	e1d430bc 	ldrh	r3, [r4, #12]
   225e8:	e3833001 	orr	r3, r3, #1
   225ec:	e1a03803 	lsl	r3, r3, #16
   225f0:	e1a03823 	lsr	r3, r3, #16
   225f4:	e1c430bc 	strh	r3, [r4, #12]
    }
}
   225f8:	e24bd014 	sub	sp, fp, #20
   225fc:	e8bd48f0 	pop	{r4, r5, r6, r7, fp, lr}
   22600:	e12fff1e 	bx	lr
   22604:	000190bc 	.word	0x000190bc
   22608:	00016538 	.word	0x00016538

0002260c <memchr>:
_PTR
_DEFUN (memchr, (src_void, c, length),
	_CONST _PTR src_void _AND
	int c _AND
	size_t length)
{
   2260c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   22610:	e28db000 	add	fp, sp, #0
   22614:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   22618:	e50b0020 	str	r0, [fp, #-32]
   2261c:	e50b1024 	str	r1, [fp, #-36]	; 0x24
   22620:	e50b2028 	str	r2, [fp, #-40]	; 0x28
  _CONST unsigned char *src = (_CONST unsigned char *) src_void;
   22624:	e51b3020 	ldr	r3, [fp, #-32]
   22628:	e50b3008 	str	r3, [fp, #-8]
  unsigned char d = c;
   2262c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   22630:	e54b3015 	strb	r3, [fp, #-21]
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  int i;

  while (UNALIGNED (src))
   22634:	ea000010 	b	2267c <memchr+0x70>
    {
      if (!length--)
   22638:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2263c:	e2432001 	sub	r2, r3, #1
   22640:	e50b2028 	str	r2, [fp, #-40]	; 0x28
   22644:	e3530000 	cmp	r3, #0
   22648:	1a000001 	bne	22654 <memchr+0x48>
        return NULL;
   2264c:	e3a03000 	mov	r3, #0
   22650:	ea000059 	b	227bc <memchr+0x1b0>
      if (*src == d)
   22654:	e51b3008 	ldr	r3, [fp, #-8]
   22658:	e5d33000 	ldrb	r3, [r3]
   2265c:	e55b2015 	ldrb	r2, [fp, #-21]
   22660:	e1520003 	cmp	r2, r3
   22664:	1a000001 	bne	22670 <memchr+0x64>
        return (void *) src;
   22668:	e51b3008 	ldr	r3, [fp, #-8]
   2266c:	ea000052 	b	227bc <memchr+0x1b0>
      src++;
   22670:	e51b3008 	ldr	r3, [fp, #-8]
   22674:	e2833001 	add	r3, r3, #1
   22678:	e50b3008 	str	r3, [fp, #-8]
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  int i;

  while (UNALIGNED (src))
   2267c:	e51b3008 	ldr	r3, [fp, #-8]
   22680:	e2033003 	and	r3, r3, #3
   22684:	e3530000 	cmp	r3, #0
   22688:	1affffea 	bne	22638 <memchr+0x2c>
      if (*src == d)
        return (void *) src;
      src++;
    }

  if (!TOO_SMALL (length))
   2268c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   22690:	e3530003 	cmp	r3, #3
   22694:	9a000037 	bls	22778 <memchr+0x16c>
         performs the bytewise search on word-sized segments if they
         contain the search character, which is detected by XORing
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
   22698:	e51b3008 	ldr	r3, [fp, #-8]
   2269c:	e50b300c 	str	r3, [fp, #-12]
      mask = d << 8 | d;
   226a0:	e55b3015 	ldrb	r3, [fp, #-21]
   226a4:	e1a02403 	lsl	r2, r3, #8
   226a8:	e55b3015 	ldrb	r3, [fp, #-21]
   226ac:	e1823003 	orr	r3, r2, r3
   226b0:	e50b3010 	str	r3, [fp, #-16]
      mask = mask << 16 | mask;
   226b4:	e51b3010 	ldr	r3, [fp, #-16]
   226b8:	e1a03803 	lsl	r3, r3, #16
   226bc:	e51b2010 	ldr	r2, [fp, #-16]
   226c0:	e1823003 	orr	r3, r2, r3
   226c4:	e50b3010 	str	r3, [fp, #-16]
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
   226c8:	e3a03020 	mov	r3, #32
   226cc:	e50b3014 	str	r3, [fp, #-20]
   226d0:	ea000008 	b	226f8 <memchr+0xec>
        mask = (mask << i) | mask;
   226d4:	e51b2010 	ldr	r2, [fp, #-16]
   226d8:	e51b3014 	ldr	r3, [fp, #-20]
   226dc:	e1a03312 	lsl	r3, r2, r3
   226e0:	e51b2010 	ldr	r2, [fp, #-16]
   226e4:	e1823003 	orr	r3, r2, r3
   226e8:	e50b3010 	str	r3, [fp, #-16]
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
   226ec:	e51b3014 	ldr	r3, [fp, #-20]
   226f0:	e1a03083 	lsl	r3, r3, #1
   226f4:	e50b3014 	str	r3, [fp, #-20]
   226f8:	e51b3014 	ldr	r3, [fp, #-20]
   226fc:	e353001f 	cmp	r3, #31
   22700:	9afffff3 	bls	226d4 <memchr+0xc8>
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
   22704:	ea000016 	b	22764 <memchr+0x158>
        {
          if (DETECTCHAR (*asrc, mask))
   22708:	e51b300c 	ldr	r3, [fp, #-12]
   2270c:	e5932000 	ldr	r2, [r3]
   22710:	e51b3010 	ldr	r3, [fp, #-16]
   22714:	e0222003 	eor	r2, r2, r3
   22718:	e59f30ac 	ldr	r3, [pc, #172]	; 227cc <memchr+0x1c0>
   2271c:	e0823003 	add	r3, r2, r3
   22720:	e51b200c 	ldr	r2, [fp, #-12]
   22724:	e5921000 	ldr	r1, [r2]
   22728:	e51b2010 	ldr	r2, [fp, #-16]
   2272c:	e0222001 	eor	r2, r2, r1
   22730:	e1e02002 	mvn	r2, r2
   22734:	e0022003 	and	r2, r2, r3
   22738:	e59f3090 	ldr	r3, [pc, #144]	; 227d0 <memchr+0x1c4>
   2273c:	e0033002 	and	r3, r3, r2
   22740:	e3530000 	cmp	r3, #0
   22744:	0a000000 	beq	2274c <memchr+0x140>
            break;
   22748:	ea000008 	b	22770 <memchr+0x164>
          length -= LBLOCKSIZE;
   2274c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   22750:	e2433004 	sub	r3, r3, #4
   22754:	e50b3028 	str	r3, [fp, #-40]	; 0x28
          asrc++;
   22758:	e51b300c 	ldr	r3, [fp, #-12]
   2275c:	e2833004 	add	r3, r3, #4
   22760:	e50b300c 	str	r3, [fp, #-12]
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
   22764:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   22768:	e3530003 	cmp	r3, #3
   2276c:	8affffe5 	bhi	22708 <memchr+0xfc>
        }

      /* If there are fewer than LBLOCKSIZE characters left,
         then we resort to the bytewise loop.  */

      src = (unsigned char *) asrc;
   22770:	e51b300c 	ldr	r3, [fp, #-12]
   22774:	e50b3008 	str	r3, [fp, #-8]
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
   22778:	ea000009 	b	227a4 <memchr+0x198>
    {
      if (*src == d)
   2277c:	e51b3008 	ldr	r3, [fp, #-8]
   22780:	e5d33000 	ldrb	r3, [r3]
   22784:	e55b2015 	ldrb	r2, [fp, #-21]
   22788:	e1520003 	cmp	r2, r3
   2278c:	1a000001 	bne	22798 <memchr+0x18c>
        return (void *) src;
   22790:	e51b3008 	ldr	r3, [fp, #-8]
   22794:	ea000008 	b	227bc <memchr+0x1b0>
      src++;
   22798:	e51b3008 	ldr	r3, [fp, #-8]
   2279c:	e2833001 	add	r3, r3, #1
   227a0:	e50b3008 	str	r3, [fp, #-8]
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
   227a4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   227a8:	e2432001 	sub	r2, r3, #1
   227ac:	e50b2028 	str	r2, [fp, #-40]	; 0x28
   227b0:	e3530000 	cmp	r3, #0
   227b4:	1afffff0 	bne	2277c <memchr+0x170>
      if (*src == d)
        return (void *) src;
      src++;
    }

  return NULL;
   227b8:	e3a03000 	mov	r3, #0
}
   227bc:	e1a00003 	mov	r0, r3
   227c0:	e24bd000 	sub	sp, fp, #0
   227c4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   227c8:	e12fff1e 	bx	lr
   227cc:	fefefeff 	.word	0xfefefeff
   227d0:	80808080 	.word	0x80808080

000227d4 <memmove>:
_PTR
_DEFUN (memmove, (dst_void, src_void, length),
	_PTR dst_void _AND
	_CONST _PTR src_void _AND
	size_t length)
{
   227d4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   227d8:	e28db000 	add	fp, sp, #0
   227dc:	e24dd024 	sub	sp, sp, #36	; 0x24
   227e0:	e50b0018 	str	r0, [fp, #-24]
   227e4:	e50b101c 	str	r1, [fp, #-28]
   227e8:	e50b2020 	str	r2, [fp, #-32]
	}
    }

  return dst_void;
#else
  char *dst = dst_void;
   227ec:	e51b3018 	ldr	r3, [fp, #-24]
   227f0:	e50b3008 	str	r3, [fp, #-8]
  _CONST char *src = src_void;
   227f4:	e51b301c 	ldr	r3, [fp, #-28]
   227f8:	e50b300c 	str	r3, [fp, #-12]
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
   227fc:	e51b200c 	ldr	r2, [fp, #-12]
   22800:	e51b3008 	ldr	r3, [fp, #-8]
   22804:	e1520003 	cmp	r2, r3
   22808:	2a00001e 	bcs	22888 <memmove+0xb4>
   2280c:	e51b200c 	ldr	r2, [fp, #-12]
   22810:	e51b3020 	ldr	r3, [fp, #-32]
   22814:	e0822003 	add	r2, r2, r3
   22818:	e51b3008 	ldr	r3, [fp, #-8]
   2281c:	e1520003 	cmp	r2, r3
   22820:	9a000018 	bls	22888 <memmove+0xb4>
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
   22824:	e51b200c 	ldr	r2, [fp, #-12]
   22828:	e51b3020 	ldr	r3, [fp, #-32]
   2282c:	e0823003 	add	r3, r2, r3
   22830:	e50b300c 	str	r3, [fp, #-12]
      dst += length;
   22834:	e51b2008 	ldr	r2, [fp, #-8]
   22838:	e51b3020 	ldr	r3, [fp, #-32]
   2283c:	e0823003 	add	r3, r2, r3
   22840:	e50b3008 	str	r3, [fp, #-8]
      while (length--)
   22844:	ea000009 	b	22870 <memmove+0x9c>
	{
	  *--dst = *--src;
   22848:	e51b3008 	ldr	r3, [fp, #-8]
   2284c:	e2433001 	sub	r3, r3, #1
   22850:	e50b3008 	str	r3, [fp, #-8]
   22854:	e51b300c 	ldr	r3, [fp, #-12]
   22858:	e2433001 	sub	r3, r3, #1
   2285c:	e50b300c 	str	r3, [fp, #-12]
   22860:	e51b300c 	ldr	r3, [fp, #-12]
   22864:	e5d32000 	ldrb	r2, [r3]
   22868:	e51b3008 	ldr	r3, [fp, #-8]
   2286c:	e5c32000 	strb	r2, [r3]
  if (src < dst && dst < src + length)
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
      while (length--)
   22870:	e51b3020 	ldr	r3, [fp, #-32]
   22874:	e2432001 	sub	r2, r3, #1
   22878:	e50b2020 	str	r2, [fp, #-32]
   2287c:	e3530000 	cmp	r3, #0
   22880:	1afffff0 	bne	22848 <memmove+0x74>
  char *dst = dst_void;
  _CONST char *src = src_void;
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
   22884:	ea000054 	b	229dc <memmove+0x208>
  else
    {
      /* Use optimizing algorithm for a non-destructive copy to closely 
         match memcpy. If the size is small or either SRC or DST is unaligned,
         then punt into the byte copy loop.  This should be rare.  */
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
   22888:	e51b3020 	ldr	r3, [fp, #-32]
   2288c:	e353000f 	cmp	r3, #15
   22890:	9a000043 	bls	229a4 <memmove+0x1d0>
   22894:	e51b200c 	ldr	r2, [fp, #-12]
   22898:	e51b3008 	ldr	r3, [fp, #-8]
   2289c:	e1823003 	orr	r3, r2, r3
   228a0:	e2033003 	and	r3, r3, #3
   228a4:	e3530000 	cmp	r3, #0
   228a8:	1a00003d 	bne	229a4 <memmove+0x1d0>
        {
          aligned_dst = (long*)dst;
   228ac:	e51b3008 	ldr	r3, [fp, #-8]
   228b0:	e50b3010 	str	r3, [fp, #-16]
          aligned_src = (long*)src;
   228b4:	e51b300c 	ldr	r3, [fp, #-12]
   228b8:	e50b3014 	str	r3, [fp, #-20]

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
   228bc:	ea000022 	b	2294c <memmove+0x178>
            {
              *aligned_dst++ = *aligned_src++;
   228c0:	e51b3010 	ldr	r3, [fp, #-16]
   228c4:	e2832004 	add	r2, r3, #4
   228c8:	e50b2010 	str	r2, [fp, #-16]
   228cc:	e51b2014 	ldr	r2, [fp, #-20]
   228d0:	e2821004 	add	r1, r2, #4
   228d4:	e50b1014 	str	r1, [fp, #-20]
   228d8:	e5922000 	ldr	r2, [r2]
   228dc:	e5832000 	str	r2, [r3]
              *aligned_dst++ = *aligned_src++;
   228e0:	e51b3010 	ldr	r3, [fp, #-16]
   228e4:	e2832004 	add	r2, r3, #4
   228e8:	e50b2010 	str	r2, [fp, #-16]
   228ec:	e51b2014 	ldr	r2, [fp, #-20]
   228f0:	e2821004 	add	r1, r2, #4
   228f4:	e50b1014 	str	r1, [fp, #-20]
   228f8:	e5922000 	ldr	r2, [r2]
   228fc:	e5832000 	str	r2, [r3]
              *aligned_dst++ = *aligned_src++;
   22900:	e51b3010 	ldr	r3, [fp, #-16]
   22904:	e2832004 	add	r2, r3, #4
   22908:	e50b2010 	str	r2, [fp, #-16]
   2290c:	e51b2014 	ldr	r2, [fp, #-20]
   22910:	e2821004 	add	r1, r2, #4
   22914:	e50b1014 	str	r1, [fp, #-20]
   22918:	e5922000 	ldr	r2, [r2]
   2291c:	e5832000 	str	r2, [r3]
              *aligned_dst++ = *aligned_src++;
   22920:	e51b3010 	ldr	r3, [fp, #-16]
   22924:	e2832004 	add	r2, r3, #4
   22928:	e50b2010 	str	r2, [fp, #-16]
   2292c:	e51b2014 	ldr	r2, [fp, #-20]
   22930:	e2821004 	add	r1, r2, #4
   22934:	e50b1014 	str	r1, [fp, #-20]
   22938:	e5922000 	ldr	r2, [r2]
   2293c:	e5832000 	str	r2, [r3]
              length -= BIGBLOCKSIZE;
   22940:	e51b3020 	ldr	r3, [fp, #-32]
   22944:	e2433010 	sub	r3, r3, #16
   22948:	e50b3020 	str	r3, [fp, #-32]
        {
          aligned_dst = (long*)dst;
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
   2294c:	e51b3020 	ldr	r3, [fp, #-32]
   22950:	e353000f 	cmp	r3, #15
   22954:	8affffd9 	bhi	228c0 <memmove+0xec>
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   22958:	ea00000a 	b	22988 <memmove+0x1b4>
            {
              *aligned_dst++ = *aligned_src++;
   2295c:	e51b3010 	ldr	r3, [fp, #-16]
   22960:	e2832004 	add	r2, r3, #4
   22964:	e50b2010 	str	r2, [fp, #-16]
   22968:	e51b2014 	ldr	r2, [fp, #-20]
   2296c:	e2821004 	add	r1, r2, #4
   22970:	e50b1014 	str	r1, [fp, #-20]
   22974:	e5922000 	ldr	r2, [r2]
   22978:	e5832000 	str	r2, [r3]
              length -= LITTLEBLOCKSIZE;
   2297c:	e51b3020 	ldr	r3, [fp, #-32]
   22980:	e2433004 	sub	r3, r3, #4
   22984:	e50b3020 	str	r3, [fp, #-32]
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   22988:	e51b3020 	ldr	r3, [fp, #-32]
   2298c:	e3530003 	cmp	r3, #3
   22990:	8afffff1 	bhi	2295c <memmove+0x188>
              *aligned_dst++ = *aligned_src++;
              length -= LITTLEBLOCKSIZE;
            }

          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
   22994:	e51b3010 	ldr	r3, [fp, #-16]
   22998:	e50b3008 	str	r3, [fp, #-8]
          src = (char*)aligned_src;
   2299c:	e51b3014 	ldr	r3, [fp, #-20]
   229a0:	e50b300c 	str	r3, [fp, #-12]
        }

      while (length--)
   229a4:	ea000007 	b	229c8 <memmove+0x1f4>
        {
          *dst++ = *src++;
   229a8:	e51b3008 	ldr	r3, [fp, #-8]
   229ac:	e2832001 	add	r2, r3, #1
   229b0:	e50b2008 	str	r2, [fp, #-8]
   229b4:	e51b200c 	ldr	r2, [fp, #-12]
   229b8:	e2821001 	add	r1, r2, #1
   229bc:	e50b100c 	str	r1, [fp, #-12]
   229c0:	e5d22000 	ldrb	r2, [r2]
   229c4:	e5c32000 	strb	r2, [r3]
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   229c8:	e51b3020 	ldr	r3, [fp, #-32]
   229cc:	e2432001 	sub	r2, r3, #1
   229d0:	e50b2020 	str	r2, [fp, #-32]
   229d4:	e3530000 	cmp	r3, #0
   229d8:	1afffff2 	bne	229a8 <memmove+0x1d4>
        {
          *dst++ = *src++;
        }
    }

  return dst_void;
   229dc:	e51b3018 	ldr	r3, [fp, #-24]
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   229e0:	e1a00003 	mov	r0, r3
   229e4:	e24bd000 	sub	sp, fp, #0
   229e8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   229ec:	e12fff1e 	bx	lr

000229f0 <_Balloc>:
#define _Kmax 15
*/

_Bigint *
_DEFUN (Balloc, (ptr, k), struct _reent *ptr _AND int k)
{
   229f0:	e92d4800 	push	{fp, lr}
   229f4:	e28db004 	add	fp, sp, #4
   229f8:	e24dd010 	sub	sp, sp, #16
   229fc:	e50b0010 	str	r0, [fp, #-16]
   22a00:	e50b1014 	str	r1, [fp, #-20]
  int x;
  _Bigint *rv ;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
   22a04:	e51b3010 	ldr	r3, [fp, #-16]
   22a08:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
   22a0c:	e3530000 	cmp	r3, #0
   22a10:	1a00000c 	bne	22a48 <_Balloc+0x58>
    {
      /* Allocate a list of pointers to the mprec objects */
      _REENT_MP_FREELIST(ptr) = (struct _Bigint **) _calloc_r (ptr, 
   22a14:	e51b0010 	ldr	r0, [fp, #-16]
   22a18:	e3a01004 	mov	r1, #4
   22a1c:	e3a02021 	mov	r2, #33	; 0x21
   22a20:	eb001841 	bl	28b2c <_calloc_r>
   22a24:	e1a02000 	mov	r2, r0
   22a28:	e51b3010 	ldr	r3, [fp, #-16]
   22a2c:	e583204c 	str	r2, [r3, #76]	; 0x4c
						      sizeof (struct _Bigint *),
						      _Kmax + 1);
      if (_REENT_MP_FREELIST(ptr) == NULL)
   22a30:	e51b3010 	ldr	r3, [fp, #-16]
   22a34:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
   22a38:	e3530000 	cmp	r3, #0
   22a3c:	1a000001 	bne	22a48 <_Balloc+0x58>
	{
	  return NULL;
   22a40:	e3a03000 	mov	r3, #0
   22a44:	ea000031 	b	22b10 <_Balloc+0x120>
	}
    }

  if ((rv = _REENT_MP_FREELIST(ptr)[k]) != 0)
   22a48:	e51b3010 	ldr	r3, [fp, #-16]
   22a4c:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
   22a50:	e51b3014 	ldr	r3, [fp, #-20]
   22a54:	e1a03103 	lsl	r3, r3, #2
   22a58:	e0823003 	add	r3, r2, r3
   22a5c:	e5933000 	ldr	r3, [r3]
   22a60:	e50b3008 	str	r3, [fp, #-8]
   22a64:	e51b3008 	ldr	r3, [fp, #-8]
   22a68:	e3530000 	cmp	r3, #0
   22a6c:	0a000008 	beq	22a94 <_Balloc+0xa4>
    {
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
   22a70:	e51b3010 	ldr	r3, [fp, #-16]
   22a74:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
   22a78:	e51b3014 	ldr	r3, [fp, #-20]
   22a7c:	e1a03103 	lsl	r3, r3, #2
   22a80:	e0823003 	add	r3, r2, r3
   22a84:	e51b2008 	ldr	r2, [fp, #-8]
   22a88:	e5922000 	ldr	r2, [r2]
   22a8c:	e5832000 	str	r2, [r3]
   22a90:	ea000016 	b	22af0 <_Balloc+0x100>
    }
  else
    {
      x = 1 << k;
   22a94:	e3a02001 	mov	r2, #1
   22a98:	e51b3014 	ldr	r3, [fp, #-20]
   22a9c:	e1a03312 	lsl	r3, r2, r3
   22aa0:	e50b300c 	str	r3, [fp, #-12]
      /* Allocate an mprec Bigint and stick in in the freelist */
      rv = (_Bigint *) _calloc_r (ptr,
				  1,
				  sizeof (_Bigint) +
   22aa4:	e51b300c 	ldr	r3, [fp, #-12]
    }
  else
    {
      x = 1 << k;
      /* Allocate an mprec Bigint and stick in in the freelist */
      rv = (_Bigint *) _calloc_r (ptr,
   22aa8:	e2833005 	add	r3, r3, #5
   22aac:	e1a03103 	lsl	r3, r3, #2
   22ab0:	e51b0010 	ldr	r0, [fp, #-16]
   22ab4:	e3a01001 	mov	r1, #1
   22ab8:	e1a02003 	mov	r2, r3
   22abc:	eb00181a 	bl	28b2c <_calloc_r>
   22ac0:	e50b0008 	str	r0, [fp, #-8]
				  1,
				  sizeof (_Bigint) +
				  (x-1) * sizeof(rv->_x));
      if (rv == NULL) return NULL;
   22ac4:	e51b3008 	ldr	r3, [fp, #-8]
   22ac8:	e3530000 	cmp	r3, #0
   22acc:	1a000001 	bne	22ad8 <_Balloc+0xe8>
   22ad0:	e3a03000 	mov	r3, #0
   22ad4:	ea00000d 	b	22b10 <_Balloc+0x120>
      rv->_k = k;
   22ad8:	e51b3008 	ldr	r3, [fp, #-8]
   22adc:	e51b2014 	ldr	r2, [fp, #-20]
   22ae0:	e5832004 	str	r2, [r3, #4]
      rv->_maxwds = x;
   22ae4:	e51b3008 	ldr	r3, [fp, #-8]
   22ae8:	e51b200c 	ldr	r2, [fp, #-12]
   22aec:	e5832008 	str	r2, [r3, #8]
    }
  rv->_sign = rv->_wds = 0;
   22af0:	e51b3008 	ldr	r3, [fp, #-8]
   22af4:	e3a02000 	mov	r2, #0
   22af8:	e5832010 	str	r2, [r3, #16]
   22afc:	e51b3008 	ldr	r3, [fp, #-8]
   22b00:	e5932010 	ldr	r2, [r3, #16]
   22b04:	e51b3008 	ldr	r3, [fp, #-8]
   22b08:	e583200c 	str	r2, [r3, #12]
  return rv;
   22b0c:	e51b3008 	ldr	r3, [fp, #-8]
}
   22b10:	e1a00003 	mov	r0, r3
   22b14:	e24bd004 	sub	sp, fp, #4
   22b18:	e8bd4800 	pop	{fp, lr}
   22b1c:	e12fff1e 	bx	lr

00022b20 <_Bfree>:

void
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
   22b20:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   22b24:	e28db000 	add	fp, sp, #0
   22b28:	e24dd00c 	sub	sp, sp, #12
   22b2c:	e50b0008 	str	r0, [fp, #-8]
   22b30:	e50b100c 	str	r1, [fp, #-12]
  _REENT_CHECK_MP(ptr);
  if (v)
   22b34:	e51b300c 	ldr	r3, [fp, #-12]
   22b38:	e3530000 	cmp	r3, #0
   22b3c:	0a000010 	beq	22b84 <_Bfree+0x64>
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   22b40:	e51b3008 	ldr	r3, [fp, #-8]
   22b44:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
   22b48:	e51b300c 	ldr	r3, [fp, #-12]
   22b4c:	e5933004 	ldr	r3, [r3, #4]
   22b50:	e1a03103 	lsl	r3, r3, #2
   22b54:	e0823003 	add	r3, r2, r3
   22b58:	e5932000 	ldr	r2, [r3]
   22b5c:	e51b300c 	ldr	r3, [fp, #-12]
   22b60:	e5832000 	str	r2, [r3]
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   22b64:	e51b3008 	ldr	r3, [fp, #-8]
   22b68:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
   22b6c:	e51b300c 	ldr	r3, [fp, #-12]
   22b70:	e5933004 	ldr	r3, [r3, #4]
   22b74:	e1a03103 	lsl	r3, r3, #2
   22b78:	e0823003 	add	r3, r2, r3
   22b7c:	e51b200c 	ldr	r2, [fp, #-12]
   22b80:	e5832000 	str	r2, [r3]
    }
}
   22b84:	e24bd000 	sub	sp, fp, #0
   22b88:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   22b8c:	e12fff1e 	bx	lr

00022b90 <__multadd>:
_DEFUN (multadd, (ptr, b, m, a),
	struct _reent *ptr _AND
	_Bigint * b _AND
	int m _AND
	int a)
{
   22b90:	e92d4800 	push	{fp, lr}
   22b94:	e28db004 	add	fp, sp, #4
   22b98:	e24dd030 	sub	sp, sp, #48	; 0x30
   22b9c:	e50b0028 	str	r0, [fp, #-40]	; 0x28
   22ba0:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
   22ba4:	e50b2030 	str	r2, [fp, #-48]	; 0x30
   22ba8:	e50b3034 	str	r3, [fp, #-52]	; 0x34
#ifdef Pack_32
  __ULong xi, z;
#endif
  _Bigint *b1;

  wds = b->_wds;
   22bac:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   22bb0:	e5933010 	ldr	r3, [r3, #16]
   22bb4:	e50b3010 	str	r3, [fp, #-16]
  x = b->_x;
   22bb8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   22bbc:	e2833014 	add	r3, r3, #20
   22bc0:	e50b300c 	str	r3, [fp, #-12]
  i = 0;
   22bc4:	e3a03000 	mov	r3, #0
   22bc8:	e50b3008 	str	r3, [fp, #-8]
  do
    {
#ifdef Pack_32
      xi = *x;
   22bcc:	e51b300c 	ldr	r3, [fp, #-12]
   22bd0:	e5933000 	ldr	r3, [r3]
   22bd4:	e50b3014 	str	r3, [fp, #-20]
      y = (xi & 0xffff) * m + a;
   22bd8:	e51b3014 	ldr	r3, [fp, #-20]
   22bdc:	e1a03803 	lsl	r3, r3, #16
   22be0:	e1a03823 	lsr	r3, r3, #16
   22be4:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   22be8:	e0020293 	mul	r2, r3, r2
   22bec:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   22bf0:	e0823003 	add	r3, r2, r3
   22bf4:	e50b3018 	str	r3, [fp, #-24]
      z = (xi >> 16) * m + (y >> 16);
   22bf8:	e51b3014 	ldr	r3, [fp, #-20]
   22bfc:	e1a03823 	lsr	r3, r3, #16
   22c00:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   22c04:	e0020293 	mul	r2, r3, r2
   22c08:	e51b3018 	ldr	r3, [fp, #-24]
   22c0c:	e1a03823 	lsr	r3, r3, #16
   22c10:	e0823003 	add	r3, r2, r3
   22c14:	e50b301c 	str	r3, [fp, #-28]
      a = (int) (z >> 16);
   22c18:	e51b301c 	ldr	r3, [fp, #-28]
   22c1c:	e1a03823 	lsr	r3, r3, #16
   22c20:	e50b3034 	str	r3, [fp, #-52]	; 0x34
      *x++ = (z << 16) + (y & 0xffff);
   22c24:	e51b200c 	ldr	r2, [fp, #-12]
   22c28:	e2823004 	add	r3, r2, #4
   22c2c:	e50b300c 	str	r3, [fp, #-12]
   22c30:	e51b301c 	ldr	r3, [fp, #-28]
   22c34:	e1a01803 	lsl	r1, r3, #16
   22c38:	e51b3018 	ldr	r3, [fp, #-24]
   22c3c:	e1a03803 	lsl	r3, r3, #16
   22c40:	e1a03823 	lsr	r3, r3, #16
   22c44:	e0813003 	add	r3, r1, r3
   22c48:	e5823000 	str	r3, [r2]
      y = *x * m + a;
      a = (int) (y >> 16);
      *x++ = y & 0xffff;
#endif
    }
  while (++i < wds);
   22c4c:	e51b3008 	ldr	r3, [fp, #-8]
   22c50:	e2833001 	add	r3, r3, #1
   22c54:	e50b3008 	str	r3, [fp, #-8]
   22c58:	e51b2008 	ldr	r2, [fp, #-8]
   22c5c:	e51b3010 	ldr	r3, [fp, #-16]
   22c60:	e1520003 	cmp	r2, r3
   22c64:	baffffd8 	blt	22bcc <__multadd+0x3c>
  if (a)
   22c68:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   22c6c:	e3530000 	cmp	r3, #0
   22c70:	0a00002a 	beq	22d20 <__multadd+0x190>
    {
      if (wds >= b->_maxwds)
   22c74:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   22c78:	e5932008 	ldr	r2, [r3, #8]
   22c7c:	e51b3010 	ldr	r3, [fp, #-16]
   22c80:	e1520003 	cmp	r2, r3
   22c84:	ca000017 	bgt	22ce8 <__multadd+0x158>
	{
	  b1 = Balloc (ptr, b->_k + 1);
   22c88:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   22c8c:	e5933004 	ldr	r3, [r3, #4]
   22c90:	e2833001 	add	r3, r3, #1
   22c94:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
   22c98:	e1a01003 	mov	r1, r3
   22c9c:	ebffff53 	bl	229f0 <_Balloc>
   22ca0:	e50b0020 	str	r0, [fp, #-32]
	  Bcopy (b1, b);
   22ca4:	e51b3020 	ldr	r3, [fp, #-32]
   22ca8:	e283100c 	add	r1, r3, #12
   22cac:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   22cb0:	e283200c 	add	r2, r3, #12
   22cb4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   22cb8:	e5933010 	ldr	r3, [r3, #16]
   22cbc:	e2833002 	add	r3, r3, #2
   22cc0:	e1a03103 	lsl	r3, r3, #2
   22cc4:	e1a00001 	mov	r0, r1
   22cc8:	e1a01002 	mov	r1, r2
   22ccc:	e1a02003 	mov	r2, r3
   22cd0:	ebffd63e 	bl	185d0 <memcpy>
	  Bfree (ptr, b);
   22cd4:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
   22cd8:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
   22cdc:	ebffff8f 	bl	22b20 <_Bfree>
	  b = b1;
   22ce0:	e51b3020 	ldr	r3, [fp, #-32]
   22ce4:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	}
      b->_x[wds++] = a;
   22ce8:	e51b3010 	ldr	r3, [fp, #-16]
   22cec:	e2832001 	add	r2, r3, #1
   22cf0:	e50b2010 	str	r2, [fp, #-16]
   22cf4:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   22cf8:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
   22cfc:	e2831004 	add	r1, r3, #4
   22d00:	e3a03004 	mov	r3, #4
   22d04:	e1a01101 	lsl	r1, r1, #2
   22d08:	e0801001 	add	r1, r0, r1
   22d0c:	e0813003 	add	r3, r1, r3
   22d10:	e5832000 	str	r2, [r3]
      b->_wds = wds;
   22d14:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   22d18:	e51b2010 	ldr	r2, [fp, #-16]
   22d1c:	e5832010 	str	r2, [r3, #16]
    }
  return b;
   22d20:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
}
   22d24:	e1a00003 	mov	r0, r3
   22d28:	e24bd004 	sub	sp, fp, #4
   22d2c:	e8bd4800 	pop	{fp, lr}
   22d30:	e12fff1e 	bx	lr

00022d34 <__s2b>:
	struct _reent * ptr _AND
	_CONST char *s _AND
	int nd0 _AND
	int nd _AND
	__ULong y9)
{
   22d34:	e92d4800 	push	{fp, lr}
   22d38:	e28db004 	add	fp, sp, #4
   22d3c:	e24dd028 	sub	sp, sp, #40	; 0x28
   22d40:	e50b0020 	str	r0, [fp, #-32]
   22d44:	e50b1024 	str	r1, [fp, #-36]	; 0x24
   22d48:	e50b2028 	str	r2, [fp, #-40]	; 0x28
   22d4c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
   22d50:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   22d54:	e2833008 	add	r3, r3, #8
   22d58:	e59f2150 	ldr	r2, [pc, #336]	; 22eb0 <__s2b+0x17c>
   22d5c:	e0c21293 	smull	r1, r2, r3, r2
   22d60:	e1a020c2 	asr	r2, r2, #1
   22d64:	e1a03fc3 	asr	r3, r3, #31
   22d68:	e0633002 	rsb	r3, r3, r2
   22d6c:	e50b3018 	str	r3, [fp, #-24]
  for (k = 0, y = 1; x > y; y <<= 1, k++);
   22d70:	e3a03000 	mov	r3, #0
   22d74:	e50b3010 	str	r3, [fp, #-16]
   22d78:	e3a03001 	mov	r3, #1
   22d7c:	e50b3014 	str	r3, [fp, #-20]
   22d80:	ea000005 	b	22d9c <__s2b+0x68>
   22d84:	e51b3014 	ldr	r3, [fp, #-20]
   22d88:	e1a03083 	lsl	r3, r3, #1
   22d8c:	e50b3014 	str	r3, [fp, #-20]
   22d90:	e51b3010 	ldr	r3, [fp, #-16]
   22d94:	e2833001 	add	r3, r3, #1
   22d98:	e50b3010 	str	r3, [fp, #-16]
   22d9c:	e51b2018 	ldr	r2, [fp, #-24]
   22da0:	e51b3014 	ldr	r3, [fp, #-20]
   22da4:	e1520003 	cmp	r2, r3
   22da8:	cafffff5 	bgt	22d84 <__s2b+0x50>
#ifdef Pack_32
  b = Balloc (ptr, k);
   22dac:	e51b0020 	ldr	r0, [fp, #-32]
   22db0:	e51b1010 	ldr	r1, [fp, #-16]
   22db4:	ebffff0d 	bl	229f0 <_Balloc>
   22db8:	e50b0008 	str	r0, [fp, #-8]
  b->_x[0] = y9;
   22dbc:	e51b3008 	ldr	r3, [fp, #-8]
   22dc0:	e59b2004 	ldr	r2, [fp, #4]
   22dc4:	e5832014 	str	r2, [r3, #20]
  b->_wds = 1;
   22dc8:	e51b3008 	ldr	r3, [fp, #-8]
   22dcc:	e3a02001 	mov	r2, #1
   22dd0:	e5832010 	str	r2, [r3, #16]
  b = Balloc (ptr, k + 1);
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
   22dd4:	e3a03009 	mov	r3, #9
   22dd8:	e50b300c 	str	r3, [fp, #-12]
  if (9 < nd0)
   22ddc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   22de0:	e3530009 	cmp	r3, #9
   22de4:	da000017 	ble	22e48 <__s2b+0x114>
    {
      s += 9;
   22de8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   22dec:	e2833009 	add	r3, r3, #9
   22df0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      do
	b = multadd (ptr, b, 10, *s++ - '0');
   22df4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   22df8:	e2832001 	add	r2, r3, #1
   22dfc:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   22e00:	e5d33000 	ldrb	r3, [r3]
   22e04:	e2433030 	sub	r3, r3, #48	; 0x30
   22e08:	e51b0020 	ldr	r0, [fp, #-32]
   22e0c:	e51b1008 	ldr	r1, [fp, #-8]
   22e10:	e3a0200a 	mov	r2, #10
   22e14:	ebffff5d 	bl	22b90 <__multadd>
   22e18:	e50b0008 	str	r0, [fp, #-8]
      while (++i < nd0);
   22e1c:	e51b300c 	ldr	r3, [fp, #-12]
   22e20:	e2833001 	add	r3, r3, #1
   22e24:	e50b300c 	str	r3, [fp, #-12]
   22e28:	e51b200c 	ldr	r2, [fp, #-12]
   22e2c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   22e30:	e1520003 	cmp	r2, r3
   22e34:	baffffee 	blt	22df4 <__s2b+0xc0>
      s++;
   22e38:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   22e3c:	e2833001 	add	r3, r3, #1
   22e40:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   22e44:	ea000002 	b	22e54 <__s2b+0x120>
    }
  else
    s += 10;
   22e48:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   22e4c:	e283300a 	add	r3, r3, #10
   22e50:	e50b3024 	str	r3, [fp, #-36]	; 0x24
  for (; i < nd; i++)
   22e54:	ea00000c 	b	22e8c <__s2b+0x158>
    b = multadd (ptr, b, 10, *s++ - '0');
   22e58:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   22e5c:	e2832001 	add	r2, r3, #1
   22e60:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   22e64:	e5d33000 	ldrb	r3, [r3]
   22e68:	e2433030 	sub	r3, r3, #48	; 0x30
   22e6c:	e51b0020 	ldr	r0, [fp, #-32]
   22e70:	e51b1008 	ldr	r1, [fp, #-8]
   22e74:	e3a0200a 	mov	r2, #10
   22e78:	ebffff44 	bl	22b90 <__multadd>
   22e7c:	e50b0008 	str	r0, [fp, #-8]
      while (++i < nd0);
      s++;
    }
  else
    s += 10;
  for (; i < nd; i++)
   22e80:	e51b300c 	ldr	r3, [fp, #-12]
   22e84:	e2833001 	add	r3, r3, #1
   22e88:	e50b300c 	str	r3, [fp, #-12]
   22e8c:	e51b200c 	ldr	r2, [fp, #-12]
   22e90:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   22e94:	e1520003 	cmp	r2, r3
   22e98:	baffffee 	blt	22e58 <__s2b+0x124>
    b = multadd (ptr, b, 10, *s++ - '0');
  return b;
   22e9c:	e51b3008 	ldr	r3, [fp, #-8]
}
   22ea0:	e1a00003 	mov	r0, r3
   22ea4:	e24bd004 	sub	sp, fp, #4
   22ea8:	e8bd4800 	pop	{fp, lr}
   22eac:	e12fff1e 	bx	lr
   22eb0:	38e38e39 	.word	0x38e38e39

00022eb4 <__hi0bits>:

int
_DEFUN (hi0bits,
	(x), register __ULong x)
{
   22eb4:	e92d0810 	push	{r4, fp}
   22eb8:	e28db004 	add	fp, sp, #4
   22ebc:	e1a03000 	mov	r3, r0
  register int k = 0;
   22ec0:	e3a04000 	mov	r4, #0

  if (!(x & 0xffff0000))
   22ec4:	e1a02823 	lsr	r2, r3, #16
   22ec8:	e1a02802 	lsl	r2, r2, #16
   22ecc:	e3520000 	cmp	r2, #0
   22ed0:	1a000001 	bne	22edc <__hi0bits+0x28>
    {
      k = 16;
   22ed4:	e3a04010 	mov	r4, #16
      x <<= 16;
   22ed8:	e1a03803 	lsl	r3, r3, #16
    }
  if (!(x & 0xff000000))
   22edc:	e20324ff 	and	r2, r3, #-16777216	; 0xff000000
   22ee0:	e3520000 	cmp	r2, #0
   22ee4:	1a000001 	bne	22ef0 <__hi0bits+0x3c>
    {
      k += 8;
   22ee8:	e2844008 	add	r4, r4, #8
      x <<= 8;
   22eec:	e1a03403 	lsl	r3, r3, #8
    }
  if (!(x & 0xf0000000))
   22ef0:	e203220f 	and	r2, r3, #-268435456	; 0xf0000000
   22ef4:	e3520000 	cmp	r2, #0
   22ef8:	1a000001 	bne	22f04 <__hi0bits+0x50>
    {
      k += 4;
   22efc:	e2844004 	add	r4, r4, #4
      x <<= 4;
   22f00:	e1a03203 	lsl	r3, r3, #4
    }
  if (!(x & 0xc0000000))
   22f04:	e2032103 	and	r2, r3, #-1073741824	; 0xc0000000
   22f08:	e3520000 	cmp	r2, #0
   22f0c:	1a000001 	bne	22f18 <__hi0bits+0x64>
    {
      k += 2;
   22f10:	e2844002 	add	r4, r4, #2
      x <<= 2;
   22f14:	e1a03103 	lsl	r3, r3, #2
    }
  if (!(x & 0x80000000))
   22f18:	e1a02003 	mov	r2, r3
   22f1c:	e3520000 	cmp	r2, #0
   22f20:	ba000005 	blt	22f3c <__hi0bits+0x88>
    {
      k++;
   22f24:	e2844001 	add	r4, r4, #1
      if (!(x & 0x40000000))
   22f28:	e2033101 	and	r3, r3, #1073741824	; 0x40000000
   22f2c:	e3530000 	cmp	r3, #0
   22f30:	1a000001 	bne	22f3c <__hi0bits+0x88>
	return 32;
   22f34:	e3a03020 	mov	r3, #32
   22f38:	ea000000 	b	22f40 <__hi0bits+0x8c>
    }
  return k;
   22f3c:	e1a03004 	mov	r3, r4
}
   22f40:	e1a00003 	mov	r0, r3
   22f44:	e24bd004 	sub	sp, fp, #4
   22f48:	e8bd0810 	pop	{r4, fp}
   22f4c:	e12fff1e 	bx	lr

00022f50 <__lo0bits>:

int
_DEFUN (lo0bits, (y), __ULong *y)
{
   22f50:	e92d0830 	push	{r4, r5, fp}
   22f54:	e28db008 	add	fp, sp, #8
   22f58:	e24dd00c 	sub	sp, sp, #12
   22f5c:	e50b0010 	str	r0, [fp, #-16]
  register int k;
  register __ULong x = *y;
   22f60:	e51b3010 	ldr	r3, [fp, #-16]
   22f64:	e5934000 	ldr	r4, [r3]

  if (x & 7)
   22f68:	e2043007 	and	r3, r4, #7
   22f6c:	e3530000 	cmp	r3, #0
   22f70:	0a000011 	beq	22fbc <__lo0bits+0x6c>
    {
      if (x & 1)
   22f74:	e2043001 	and	r3, r4, #1
   22f78:	e3530000 	cmp	r3, #0
   22f7c:	0a000001 	beq	22f88 <__lo0bits+0x38>
	return 0;
   22f80:	e3a03000 	mov	r3, #0
   22f84:	ea00002e 	b	23044 <__lo0bits+0xf4>
      if (x & 2)
   22f88:	e2043002 	and	r3, r4, #2
   22f8c:	e3530000 	cmp	r3, #0
   22f90:	0a000004 	beq	22fa8 <__lo0bits+0x58>
	{
	  *y = x >> 1;
   22f94:	e1a020a4 	lsr	r2, r4, #1
   22f98:	e51b3010 	ldr	r3, [fp, #-16]
   22f9c:	e5832000 	str	r2, [r3]
	  return 1;
   22fa0:	e3a03001 	mov	r3, #1
   22fa4:	ea000026 	b	23044 <__lo0bits+0xf4>
	}
      *y = x >> 2;
   22fa8:	e1a02124 	lsr	r2, r4, #2
   22fac:	e51b3010 	ldr	r3, [fp, #-16]
   22fb0:	e5832000 	str	r2, [r3]
      return 2;
   22fb4:	e3a03002 	mov	r3, #2
   22fb8:	ea000021 	b	23044 <__lo0bits+0xf4>
    }
  k = 0;
   22fbc:	e3a05000 	mov	r5, #0
  if (!(x & 0xffff))
   22fc0:	e1a03804 	lsl	r3, r4, #16
   22fc4:	e1a03823 	lsr	r3, r3, #16
   22fc8:	e3530000 	cmp	r3, #0
   22fcc:	1a000001 	bne	22fd8 <__lo0bits+0x88>
    {
      k = 16;
   22fd0:	e3a05010 	mov	r5, #16
      x >>= 16;
   22fd4:	e1a04824 	lsr	r4, r4, #16
    }
  if (!(x & 0xff))
   22fd8:	e20430ff 	and	r3, r4, #255	; 0xff
   22fdc:	e3530000 	cmp	r3, #0
   22fe0:	1a000001 	bne	22fec <__lo0bits+0x9c>
    {
      k += 8;
   22fe4:	e2855008 	add	r5, r5, #8
      x >>= 8;
   22fe8:	e1a04424 	lsr	r4, r4, #8
    }
  if (!(x & 0xf))
   22fec:	e204300f 	and	r3, r4, #15
   22ff0:	e3530000 	cmp	r3, #0
   22ff4:	1a000001 	bne	23000 <__lo0bits+0xb0>
    {
      k += 4;
   22ff8:	e2855004 	add	r5, r5, #4
      x >>= 4;
   22ffc:	e1a04224 	lsr	r4, r4, #4
    }
  if (!(x & 0x3))
   23000:	e2043003 	and	r3, r4, #3
   23004:	e3530000 	cmp	r3, #0
   23008:	1a000001 	bne	23014 <__lo0bits+0xc4>
    {
      k += 2;
   2300c:	e2855002 	add	r5, r5, #2
      x >>= 2;
   23010:	e1a04124 	lsr	r4, r4, #2
    }
  if (!(x & 1))
   23014:	e2043001 	and	r3, r4, #1
   23018:	e3530000 	cmp	r3, #0
   2301c:	1a000005 	bne	23038 <__lo0bits+0xe8>
    {
      k++;
   23020:	e2855001 	add	r5, r5, #1
      x >>= 1;
   23024:	e1a040a4 	lsr	r4, r4, #1
      if (!x & 1)
   23028:	e3540000 	cmp	r4, #0
   2302c:	1a000001 	bne	23038 <__lo0bits+0xe8>
	return 32;
   23030:	e3a03020 	mov	r3, #32
   23034:	ea000002 	b	23044 <__lo0bits+0xf4>
    }
  *y = x;
   23038:	e51b3010 	ldr	r3, [fp, #-16]
   2303c:	e5834000 	str	r4, [r3]
  return k;
   23040:	e1a03005 	mov	r3, r5
}
   23044:	e1a00003 	mov	r0, r3
   23048:	e24bd008 	sub	sp, fp, #8
   2304c:	e8bd0830 	pop	{r4, r5, fp}
   23050:	e12fff1e 	bx	lr

00023054 <__i2b>:

_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
   23054:	e92d4800 	push	{fp, lr}
   23058:	e28db004 	add	fp, sp, #4
   2305c:	e24dd010 	sub	sp, sp, #16
   23060:	e50b0010 	str	r0, [fp, #-16]
   23064:	e50b1014 	str	r1, [fp, #-20]
  _Bigint *b;

  b = Balloc (ptr, 1);
   23068:	e51b0010 	ldr	r0, [fp, #-16]
   2306c:	e3a01001 	mov	r1, #1
   23070:	ebfffe5e 	bl	229f0 <_Balloc>
   23074:	e50b0008 	str	r0, [fp, #-8]
  b->_x[0] = i;
   23078:	e51b2014 	ldr	r2, [fp, #-20]
   2307c:	e51b3008 	ldr	r3, [fp, #-8]
   23080:	e5832014 	str	r2, [r3, #20]
  b->_wds = 1;
   23084:	e51b3008 	ldr	r3, [fp, #-8]
   23088:	e3a02001 	mov	r2, #1
   2308c:	e5832010 	str	r2, [r3, #16]
  return b;
   23090:	e51b3008 	ldr	r3, [fp, #-8]
}
   23094:	e1a00003 	mov	r0, r3
   23098:	e24bd004 	sub	sp, fp, #4
   2309c:	e8bd4800 	pop	{fp, lr}
   230a0:	e12fff1e 	bx	lr

000230a4 <__multiply>:

_Bigint *
_DEFUN (mult, (ptr, a, b), struct _reent * ptr _AND _Bigint * a _AND _Bigint * b)
{
   230a4:	e92d4800 	push	{fp, lr}
   230a8:	e28db004 	add	fp, sp, #4
   230ac:	e24dd050 	sub	sp, sp, #80	; 0x50
   230b0:	e50b0048 	str	r0, [fp, #-72]	; 0x48
   230b4:	e50b104c 	str	r1, [fp, #-76]	; 0x4c
   230b8:	e50b2050 	str	r2, [fp, #-80]	; 0x50
  __ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
#ifdef Pack_32
  __ULong z2;
#endif

  if (a->_wds < b->_wds)
   230bc:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   230c0:	e5932010 	ldr	r2, [r3, #16]
   230c4:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   230c8:	e5933010 	ldr	r3, [r3, #16]
   230cc:	e1520003 	cmp	r2, r3
   230d0:	aa000005 	bge	230ec <__multiply+0x48>
    {
      c = a;
   230d4:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   230d8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      a = b;
   230dc:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   230e0:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
      b = c;
   230e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   230e8:	e50b3050 	str	r3, [fp, #-80]	; 0x50
    }
  k = a->_k;
   230ec:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   230f0:	e5933004 	ldr	r3, [r3, #4]
   230f4:	e50b3008 	str	r3, [fp, #-8]
  wa = a->_wds;
   230f8:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   230fc:	e5933010 	ldr	r3, [r3, #16]
   23100:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
  wb = b->_wds;
   23104:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   23108:	e5933010 	ldr	r3, [r3, #16]
   2310c:	e50b3030 	str	r3, [fp, #-48]	; 0x30
  wc = wa + wb;
   23110:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
   23114:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   23118:	e0823003 	add	r3, r2, r3
   2311c:	e50b300c 	str	r3, [fp, #-12]
  if (wc > a->_maxwds)
   23120:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   23124:	e5932008 	ldr	r2, [r3, #8]
   23128:	e51b300c 	ldr	r3, [fp, #-12]
   2312c:	e1520003 	cmp	r2, r3
   23130:	aa000002 	bge	23140 <__multiply+0x9c>
    k++;
   23134:	e51b3008 	ldr	r3, [fp, #-8]
   23138:	e2833001 	add	r3, r3, #1
   2313c:	e50b3008 	str	r3, [fp, #-8]
  c = Balloc (ptr, k);
   23140:	e51b0048 	ldr	r0, [fp, #-72]	; 0x48
   23144:	e51b1008 	ldr	r1, [fp, #-8]
   23148:	ebfffe28 	bl	229f0 <_Balloc>
   2314c:	e50b0028 	str	r0, [fp, #-40]	; 0x28
  for (x = c->_x, xa = x + wc; x < xa; x++)
   23150:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   23154:	e2833014 	add	r3, r3, #20
   23158:	e50b3014 	str	r3, [fp, #-20]
   2315c:	e51b300c 	ldr	r3, [fp, #-12]
   23160:	e1a03103 	lsl	r3, r3, #2
   23164:	e51b2014 	ldr	r2, [fp, #-20]
   23168:	e0823003 	add	r3, r2, r3
   2316c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   23170:	ea000005 	b	2318c <__multiply+0xe8>
    *x = 0;
   23174:	e51b3014 	ldr	r3, [fp, #-20]
   23178:	e3a02000 	mov	r2, #0
   2317c:	e5832000 	str	r2, [r3]
  wb = b->_wds;
  wc = wa + wb;
  if (wc > a->_maxwds)
    k++;
  c = Balloc (ptr, k);
  for (x = c->_x, xa = x + wc; x < xa; x++)
   23180:	e51b3014 	ldr	r3, [fp, #-20]
   23184:	e2833004 	add	r3, r3, #4
   23188:	e50b3014 	str	r3, [fp, #-20]
   2318c:	e51b2014 	ldr	r2, [fp, #-20]
   23190:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   23194:	e1520003 	cmp	r2, r3
   23198:	3afffff5 	bcc	23174 <__multiply+0xd0>
    *x = 0;
  xa = a->_x;
   2319c:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   231a0:	e2833014 	add	r3, r3, #20
   231a4:	e50b3034 	str	r3, [fp, #-52]	; 0x34
  xae = xa + wa;
   231a8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   231ac:	e1a03103 	lsl	r3, r3, #2
   231b0:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   231b4:	e0823003 	add	r3, r2, r3
   231b8:	e50b3038 	str	r3, [fp, #-56]	; 0x38
  xb = b->_x;
   231bc:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   231c0:	e2833014 	add	r3, r3, #20
   231c4:	e50b3018 	str	r3, [fp, #-24]
  xbe = xb + wb;
   231c8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   231cc:	e1a03103 	lsl	r3, r3, #2
   231d0:	e51b2018 	ldr	r2, [fp, #-24]
   231d4:	e0823003 	add	r3, r2, r3
   231d8:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
  xc0 = c->_x;
   231dc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   231e0:	e2833014 	add	r3, r3, #20
   231e4:	e50b3020 	str	r3, [fp, #-32]
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
   231e8:	ea000089 	b	23414 <__multiply+0x370>
    {
      if ((y = *xb & 0xffff) != 0)
   231ec:	e51b3018 	ldr	r3, [fp, #-24]
   231f0:	e5933000 	ldr	r3, [r3]
   231f4:	e1a03803 	lsl	r3, r3, #16
   231f8:	e1a03823 	lsr	r3, r3, #16
   231fc:	e50b3040 	str	r3, [fp, #-64]	; 0x40
   23200:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   23204:	e3530000 	cmp	r3, #0
   23208:	0a000038 	beq	232f0 <__multiply+0x24c>
	{
	  x = xa;
   2320c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   23210:	e50b3014 	str	r3, [fp, #-20]
	  xc = xc0;
   23214:	e51b3020 	ldr	r3, [fp, #-32]
   23218:	e50b301c 	str	r3, [fp, #-28]
	  carry = 0;
   2321c:	e3a03000 	mov	r3, #0
   23220:	e50b3010 	str	r3, [fp, #-16]
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   23224:	e51b3014 	ldr	r3, [fp, #-20]
   23228:	e5933000 	ldr	r3, [r3]
   2322c:	e1a03803 	lsl	r3, r3, #16
   23230:	e1a03823 	lsr	r3, r3, #16
   23234:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   23238:	e0020293 	mul	r2, r3, r2
   2323c:	e51b301c 	ldr	r3, [fp, #-28]
   23240:	e5933000 	ldr	r3, [r3]
   23244:	e1a03803 	lsl	r3, r3, #16
   23248:	e1a03823 	lsr	r3, r3, #16
   2324c:	e0822003 	add	r2, r2, r3
   23250:	e51b3010 	ldr	r3, [fp, #-16]
   23254:	e0823003 	add	r3, r2, r3
   23258:	e50b3044 	str	r3, [fp, #-68]	; 0x44
	      carry = z >> 16;
   2325c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   23260:	e1a03823 	lsr	r3, r3, #16
   23264:	e50b3010 	str	r3, [fp, #-16]
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   23268:	e51b3014 	ldr	r3, [fp, #-20]
   2326c:	e2832004 	add	r2, r3, #4
   23270:	e50b2014 	str	r2, [fp, #-20]
   23274:	e5933000 	ldr	r3, [r3]
   23278:	e1a03823 	lsr	r3, r3, #16
   2327c:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   23280:	e0020293 	mul	r2, r3, r2
   23284:	e51b301c 	ldr	r3, [fp, #-28]
   23288:	e5933000 	ldr	r3, [r3]
   2328c:	e1a03823 	lsr	r3, r3, #16
   23290:	e0822003 	add	r2, r2, r3
   23294:	e51b3010 	ldr	r3, [fp, #-16]
   23298:	e0823003 	add	r3, r2, r3
   2329c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	      carry = z2 >> 16;
   232a0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   232a4:	e1a03823 	lsr	r3, r3, #16
   232a8:	e50b3010 	str	r3, [fp, #-16]
	      Storeinc (xc, z2, z);
   232ac:	e51b201c 	ldr	r2, [fp, #-28]
   232b0:	e2823004 	add	r3, r2, #4
   232b4:	e50b301c 	str	r3, [fp, #-28]
   232b8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   232bc:	e1a01803 	lsl	r1, r3, #16
   232c0:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   232c4:	e1a03803 	lsl	r3, r3, #16
   232c8:	e1a03823 	lsr	r3, r3, #16
   232cc:	e1813003 	orr	r3, r1, r3
   232d0:	e5823000 	str	r3, [r2]
	    }
	  while (x < xae);
   232d4:	e51b2014 	ldr	r2, [fp, #-20]
   232d8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   232dc:	e1520003 	cmp	r2, r3
   232e0:	3affffcf 	bcc	23224 <__multiply+0x180>
	  *xc = carry;
   232e4:	e51b301c 	ldr	r3, [fp, #-28]
   232e8:	e51b2010 	ldr	r2, [fp, #-16]
   232ec:	e5832000 	str	r2, [r3]
	}
      if ((y = *xb >> 16) != 0)
   232f0:	e51b3018 	ldr	r3, [fp, #-24]
   232f4:	e5933000 	ldr	r3, [r3]
   232f8:	e1a03823 	lsr	r3, r3, #16
   232fc:	e50b3040 	str	r3, [fp, #-64]	; 0x40
   23300:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   23304:	e3530000 	cmp	r3, #0
   23308:	0a00003b 	beq	233fc <__multiply+0x358>
	{
	  x = xa;
   2330c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   23310:	e50b3014 	str	r3, [fp, #-20]
	  xc = xc0;
   23314:	e51b3020 	ldr	r3, [fp, #-32]
   23318:	e50b301c 	str	r3, [fp, #-28]
	  carry = 0;
   2331c:	e3a03000 	mov	r3, #0
   23320:	e50b3010 	str	r3, [fp, #-16]
	  z2 = *xc;
   23324:	e51b301c 	ldr	r3, [fp, #-28]
   23328:	e5933000 	ldr	r3, [r3]
   2332c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
   23330:	e51b3014 	ldr	r3, [fp, #-20]
   23334:	e5933000 	ldr	r3, [r3]
   23338:	e1a03803 	lsl	r3, r3, #16
   2333c:	e1a03823 	lsr	r3, r3, #16
   23340:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   23344:	e0020293 	mul	r2, r3, r2
   23348:	e51b301c 	ldr	r3, [fp, #-28]
   2334c:	e5933000 	ldr	r3, [r3]
   23350:	e1a03823 	lsr	r3, r3, #16
   23354:	e0822003 	add	r2, r2, r3
   23358:	e51b3010 	ldr	r3, [fp, #-16]
   2335c:	e0823003 	add	r3, r2, r3
   23360:	e50b3044 	str	r3, [fp, #-68]	; 0x44
	      carry = z >> 16;
   23364:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   23368:	e1a03823 	lsr	r3, r3, #16
   2336c:	e50b3010 	str	r3, [fp, #-16]
	      Storeinc (xc, z, z2);
   23370:	e51b201c 	ldr	r2, [fp, #-28]
   23374:	e2823004 	add	r3, r2, #4
   23378:	e50b301c 	str	r3, [fp, #-28]
   2337c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   23380:	e1a01803 	lsl	r1, r3, #16
   23384:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   23388:	e1a03803 	lsl	r3, r3, #16
   2338c:	e1a03823 	lsr	r3, r3, #16
   23390:	e1813003 	orr	r3, r1, r3
   23394:	e5823000 	str	r3, [r2]
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
   23398:	e51b3014 	ldr	r3, [fp, #-20]
   2339c:	e2832004 	add	r2, r3, #4
   233a0:	e50b2014 	str	r2, [fp, #-20]
   233a4:	e5933000 	ldr	r3, [r3]
   233a8:	e1a03823 	lsr	r3, r3, #16
   233ac:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   233b0:	e0020293 	mul	r2, r3, r2
   233b4:	e51b301c 	ldr	r3, [fp, #-28]
   233b8:	e5933000 	ldr	r3, [r3]
   233bc:	e1a03803 	lsl	r3, r3, #16
   233c0:	e1a03823 	lsr	r3, r3, #16
   233c4:	e0822003 	add	r2, r2, r3
   233c8:	e51b3010 	ldr	r3, [fp, #-16]
   233cc:	e0823003 	add	r3, r2, r3
   233d0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	      carry = z2 >> 16;
   233d4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   233d8:	e1a03823 	lsr	r3, r3, #16
   233dc:	e50b3010 	str	r3, [fp, #-16]
	    }
	  while (x < xae);
   233e0:	e51b2014 	ldr	r2, [fp, #-20]
   233e4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   233e8:	e1520003 	cmp	r2, r3
   233ec:	3affffcf 	bcc	23330 <__multiply+0x28c>
	  *xc = z2;
   233f0:	e51b301c 	ldr	r3, [fp, #-28]
   233f4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   233f8:	e5832000 	str	r2, [r3]
  xae = xa + wa;
  xb = b->_x;
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
   233fc:	e51b3018 	ldr	r3, [fp, #-24]
   23400:	e2833004 	add	r3, r3, #4
   23404:	e50b3018 	str	r3, [fp, #-24]
   23408:	e51b3020 	ldr	r3, [fp, #-32]
   2340c:	e2833004 	add	r3, r3, #4
   23410:	e50b3020 	str	r3, [fp, #-32]
   23414:	e51b2018 	ldr	r2, [fp, #-24]
   23418:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2341c:	e1520003 	cmp	r2, r3
   23420:	3affff71 	bcc	231ec <__multiply+0x148>
	  while (x < xae);
	  *xc = carry;
	}
    }
#endif
  for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
   23424:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   23428:	e2833014 	add	r3, r3, #20
   2342c:	e50b3020 	str	r3, [fp, #-32]
   23430:	e51b300c 	ldr	r3, [fp, #-12]
   23434:	e1a03103 	lsl	r3, r3, #2
   23438:	e51b2020 	ldr	r2, [fp, #-32]
   2343c:	e0823003 	add	r3, r2, r3
   23440:	e50b301c 	str	r3, [fp, #-28]
   23444:	ea000002 	b	23454 <__multiply+0x3b0>
   23448:	e51b300c 	ldr	r3, [fp, #-12]
   2344c:	e2433001 	sub	r3, r3, #1
   23450:	e50b300c 	str	r3, [fp, #-12]
   23454:	e51b300c 	ldr	r3, [fp, #-12]
   23458:	e3530000 	cmp	r3, #0
   2345c:	da000006 	ble	2347c <__multiply+0x3d8>
   23460:	e51b301c 	ldr	r3, [fp, #-28]
   23464:	e2433004 	sub	r3, r3, #4
   23468:	e50b301c 	str	r3, [fp, #-28]
   2346c:	e51b301c 	ldr	r3, [fp, #-28]
   23470:	e5933000 	ldr	r3, [r3]
   23474:	e3530000 	cmp	r3, #0
   23478:	0afffff2 	beq	23448 <__multiply+0x3a4>
  c->_wds = wc;
   2347c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   23480:	e51b200c 	ldr	r2, [fp, #-12]
   23484:	e5832010 	str	r2, [r3, #16]
  return c;
   23488:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
}
   2348c:	e1a00003 	mov	r0, r3
   23490:	e24bd004 	sub	sp, fp, #4
   23494:	e8bd4800 	pop	{fp, lr}
   23498:	e12fff1e 	bx	lr

0002349c <__pow5mult>:

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   2349c:	e92d4800 	push	{fp, lr}
   234a0:	e28db004 	add	fp, sp, #4
   234a4:	e24dd020 	sub	sp, sp, #32
   234a8:	e50b0018 	str	r0, [fp, #-24]
   234ac:	e50b101c 	str	r1, [fp, #-28]
   234b0:	e50b2020 	str	r2, [fp, #-32]
  _Bigint *b1, *p5, *p51;
  int i;
  static _CONST int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
   234b4:	e51b3020 	ldr	r3, [fp, #-32]
   234b8:	e2033003 	and	r3, r3, #3
   234bc:	e50b3010 	str	r3, [fp, #-16]
   234c0:	e51b3010 	ldr	r3, [fp, #-16]
   234c4:	e3530000 	cmp	r3, #0
   234c8:	0a000009 	beq	234f4 <__pow5mult+0x58>
    b = multadd (ptr, b, p05[i - 1], 0);
   234cc:	e51b3010 	ldr	r3, [fp, #-16]
   234d0:	e2432001 	sub	r2, r3, #1
   234d4:	e59f3144 	ldr	r3, [pc, #324]	; 23620 <__pow5mult+0x184>
   234d8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
   234dc:	e51b0018 	ldr	r0, [fp, #-24]
   234e0:	e51b101c 	ldr	r1, [fp, #-28]
   234e4:	e1a02003 	mov	r2, r3
   234e8:	e3a03000 	mov	r3, #0
   234ec:	ebfffda7 	bl	22b90 <__multadd>
   234f0:	e50b001c 	str	r0, [fp, #-28]

  if (!(k >>= 2))
   234f4:	e51b3020 	ldr	r3, [fp, #-32]
   234f8:	e1a03143 	asr	r3, r3, #2
   234fc:	e50b3020 	str	r3, [fp, #-32]
   23500:	e51b3020 	ldr	r3, [fp, #-32]
   23504:	e3530000 	cmp	r3, #0
   23508:	1a000001 	bne	23514 <__pow5mult+0x78>
    return b;
   2350c:	e51b301c 	ldr	r3, [fp, #-28]
   23510:	ea00003e 	b	23610 <__pow5mult+0x174>
  _REENT_CHECK_MP(ptr);
  if (!(p5 = _REENT_MP_P5S(ptr)))
   23514:	e51b3018 	ldr	r3, [fp, #-24]
   23518:	e5933048 	ldr	r3, [r3, #72]	; 0x48
   2351c:	e50b3008 	str	r3, [fp, #-8]
   23520:	e51b3008 	ldr	r3, [fp, #-8]
   23524:	e3530000 	cmp	r3, #0
   23528:	1a00000b 	bne	2355c <__pow5mult+0xc0>
    {
      /* first time */
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
   2352c:	e51b0018 	ldr	r0, [fp, #-24]
   23530:	e59f10ec 	ldr	r1, [pc, #236]	; 23624 <__pow5mult+0x188>
   23534:	ebfffec6 	bl	23054 <__i2b>
   23538:	e1a02000 	mov	r2, r0
   2353c:	e51b3018 	ldr	r3, [fp, #-24]
   23540:	e5832048 	str	r2, [r3, #72]	; 0x48
   23544:	e51b3018 	ldr	r3, [fp, #-24]
   23548:	e5933048 	ldr	r3, [r3, #72]	; 0x48
   2354c:	e50b3008 	str	r3, [fp, #-8]
      p5->_next = 0;
   23550:	e51b3008 	ldr	r3, [fp, #-8]
   23554:	e3a02000 	mov	r2, #0
   23558:	e5832000 	str	r2, [r3]
    }
  for (;;)
    {
      if (k & 1)
   2355c:	e51b3020 	ldr	r3, [fp, #-32]
   23560:	e2033001 	and	r3, r3, #1
   23564:	e3530000 	cmp	r3, #0
   23568:	0a000009 	beq	23594 <__pow5mult+0xf8>
	{
	  b1 = mult (ptr, b, p5);
   2356c:	e51b0018 	ldr	r0, [fp, #-24]
   23570:	e51b101c 	ldr	r1, [fp, #-28]
   23574:	e51b2008 	ldr	r2, [fp, #-8]
   23578:	ebfffec9 	bl	230a4 <__multiply>
   2357c:	e50b0014 	str	r0, [fp, #-20]
	  Bfree (ptr, b);
   23580:	e51b0018 	ldr	r0, [fp, #-24]
   23584:	e51b101c 	ldr	r1, [fp, #-28]
   23588:	ebfffd64 	bl	22b20 <_Bfree>
	  b = b1;
   2358c:	e51b3014 	ldr	r3, [fp, #-20]
   23590:	e50b301c 	str	r3, [fp, #-28]
	}
      if (!(k >>= 1))
   23594:	e51b3020 	ldr	r3, [fp, #-32]
   23598:	e1a030c3 	asr	r3, r3, #1
   2359c:	e50b3020 	str	r3, [fp, #-32]
   235a0:	e51b3020 	ldr	r3, [fp, #-32]
   235a4:	e3530000 	cmp	r3, #0
   235a8:	1a000002 	bne	235b8 <__pow5mult+0x11c>
	break;
   235ac:	e1a00000 	nop			; (mov r0, r0)
	  p51 = p5->_next = mult (ptr, p5, p5);
	  p51->_next = 0;
	}
      p5 = p51;
    }
  return b;
   235b0:	e51b301c 	ldr	r3, [fp, #-28]
   235b4:	ea000015 	b	23610 <__pow5mult+0x174>
	  Bfree (ptr, b);
	  b = b1;
	}
      if (!(k >>= 1))
	break;
      if (!(p51 = p5->_next))
   235b8:	e51b3008 	ldr	r3, [fp, #-8]
   235bc:	e5933000 	ldr	r3, [r3]
   235c0:	e50b300c 	str	r3, [fp, #-12]
   235c4:	e51b300c 	ldr	r3, [fp, #-12]
   235c8:	e3530000 	cmp	r3, #0
   235cc:	1a00000c 	bne	23604 <__pow5mult+0x168>
	{
	  p51 = p5->_next = mult (ptr, p5, p5);
   235d0:	e51b0018 	ldr	r0, [fp, #-24]
   235d4:	e51b1008 	ldr	r1, [fp, #-8]
   235d8:	e51b2008 	ldr	r2, [fp, #-8]
   235dc:	ebfffeb0 	bl	230a4 <__multiply>
   235e0:	e1a02000 	mov	r2, r0
   235e4:	e51b3008 	ldr	r3, [fp, #-8]
   235e8:	e5832000 	str	r2, [r3]
   235ec:	e51b3008 	ldr	r3, [fp, #-8]
   235f0:	e5933000 	ldr	r3, [r3]
   235f4:	e50b300c 	str	r3, [fp, #-12]
	  p51->_next = 0;
   235f8:	e51b300c 	ldr	r3, [fp, #-12]
   235fc:	e3a02000 	mov	r2, #0
   23600:	e5832000 	str	r2, [r3]
	}
      p5 = p51;
   23604:	e51b300c 	ldr	r3, [fp, #-12]
   23608:	e50b3008 	str	r3, [fp, #-8]
    }
   2360c:	eaffffd2 	b	2355c <__pow5mult+0xc0>
  return b;
}
   23610:	e1a00003 	mov	r0, r3
   23614:	e24bd004 	sub	sp, fp, #4
   23618:	e8bd4800 	pop	{fp, lr}
   2361c:	e12fff1e 	bx	lr
   23620:	000332a0 	.word	0x000332a0
   23624:	00000271 	.word	0x00000271

00023628 <__lshift>:

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   23628:	e92d4800 	push	{fp, lr}
   2362c:	e28db004 	add	fp, sp, #4
   23630:	e24dd038 	sub	sp, sp, #56	; 0x38
   23634:	e50b0030 	str	r0, [fp, #-48]	; 0x30
   23638:	e50b1034 	str	r1, [fp, #-52]	; 0x34
   2363c:	e50b2038 	str	r2, [fp, #-56]	; 0x38
  int i, k1, n, n1;
  _Bigint *b1;
  __ULong *x, *x1, *xe, z;

#ifdef Pack_32
  n = k >> 5;
   23640:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   23644:	e1a032c3 	asr	r3, r3, #5
   23648:	e50b3020 	str	r3, [fp, #-32]
#else
  n = k >> 4;
#endif
  k1 = b->_k;
   2364c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   23650:	e5933004 	ldr	r3, [r3, #4]
   23654:	e50b300c 	str	r3, [fp, #-12]
  n1 = n + b->_wds + 1;
   23658:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2365c:	e5932010 	ldr	r2, [r3, #16]
   23660:	e51b3020 	ldr	r3, [fp, #-32]
   23664:	e0823003 	add	r3, r2, r3
   23668:	e2833001 	add	r3, r3, #1
   2366c:	e50b3010 	str	r3, [fp, #-16]
  for (i = b->_maxwds; n1 > i; i <<= 1)
   23670:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   23674:	e5933008 	ldr	r3, [r3, #8]
   23678:	e50b3008 	str	r3, [fp, #-8]
   2367c:	ea000005 	b	23698 <__lshift+0x70>
    k1++;
   23680:	e51b300c 	ldr	r3, [fp, #-12]
   23684:	e2833001 	add	r3, r3, #1
   23688:	e50b300c 	str	r3, [fp, #-12]
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
   2368c:	e51b3008 	ldr	r3, [fp, #-8]
   23690:	e1a03083 	lsl	r3, r3, #1
   23694:	e50b3008 	str	r3, [fp, #-8]
   23698:	e51b2010 	ldr	r2, [fp, #-16]
   2369c:	e51b3008 	ldr	r3, [fp, #-8]
   236a0:	e1520003 	cmp	r2, r3
   236a4:	cafffff5 	bgt	23680 <__lshift+0x58>
    k1++;
  b1 = Balloc (ptr, k1);
   236a8:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   236ac:	e51b100c 	ldr	r1, [fp, #-12]
   236b0:	ebfffcce 	bl	229f0 <_Balloc>
   236b4:	e50b0024 	str	r0, [fp, #-36]	; 0x24
  x1 = b1->_x;
   236b8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   236bc:	e2833014 	add	r3, r3, #20
   236c0:	e50b3018 	str	r3, [fp, #-24]
  for (i = 0; i < n; i++)
   236c4:	e3a03000 	mov	r3, #0
   236c8:	e50b3008 	str	r3, [fp, #-8]
   236cc:	ea000007 	b	236f0 <__lshift+0xc8>
    *x1++ = 0;
   236d0:	e51b3018 	ldr	r3, [fp, #-24]
   236d4:	e2832004 	add	r2, r3, #4
   236d8:	e50b2018 	str	r2, [fp, #-24]
   236dc:	e3a02000 	mov	r2, #0
   236e0:	e5832000 	str	r2, [r3]
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
    k1++;
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
  for (i = 0; i < n; i++)
   236e4:	e51b3008 	ldr	r3, [fp, #-8]
   236e8:	e2833001 	add	r3, r3, #1
   236ec:	e50b3008 	str	r3, [fp, #-8]
   236f0:	e51b2008 	ldr	r2, [fp, #-8]
   236f4:	e51b3020 	ldr	r3, [fp, #-32]
   236f8:	e1520003 	cmp	r2, r3
   236fc:	bafffff3 	blt	236d0 <__lshift+0xa8>
    *x1++ = 0;
  x = b->_x;
   23700:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   23704:	e2833014 	add	r3, r3, #20
   23708:	e50b3014 	str	r3, [fp, #-20]
  xe = x + b->_wds;
   2370c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   23710:	e5933010 	ldr	r3, [r3, #16]
   23714:	e1a03103 	lsl	r3, r3, #2
   23718:	e51b2014 	ldr	r2, [fp, #-20]
   2371c:	e0823003 	add	r3, r2, r3
   23720:	e50b3028 	str	r3, [fp, #-40]	; 0x28
#ifdef Pack_32
  if (k &= 0x1f)
   23724:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   23728:	e203301f 	and	r3, r3, #31
   2372c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   23730:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   23734:	e3530000 	cmp	r3, #0
   23738:	0a000024 	beq	237d0 <__lshift+0x1a8>
    {
      k1 = 32 - k;
   2373c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   23740:	e2633020 	rsb	r3, r3, #32
   23744:	e50b300c 	str	r3, [fp, #-12]
      z = 0;
   23748:	e3a03000 	mov	r3, #0
   2374c:	e50b301c 	str	r3, [fp, #-28]
      do
	{
	  *x1++ = *x << k | z;
   23750:	e51b3018 	ldr	r3, [fp, #-24]
   23754:	e2832004 	add	r2, r3, #4
   23758:	e50b2018 	str	r2, [fp, #-24]
   2375c:	e51b2014 	ldr	r2, [fp, #-20]
   23760:	e5921000 	ldr	r1, [r2]
   23764:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   23768:	e1a01211 	lsl	r1, r1, r2
   2376c:	e51b201c 	ldr	r2, [fp, #-28]
   23770:	e1812002 	orr	r2, r1, r2
   23774:	e5832000 	str	r2, [r3]
	  z = *x++ >> k1;
   23778:	e51b3014 	ldr	r3, [fp, #-20]
   2377c:	e2832004 	add	r2, r3, #4
   23780:	e50b2014 	str	r2, [fp, #-20]
   23784:	e5932000 	ldr	r2, [r3]
   23788:	e51b300c 	ldr	r3, [fp, #-12]
   2378c:	e1a03332 	lsr	r3, r2, r3
   23790:	e50b301c 	str	r3, [fp, #-28]
	}
      while (x < xe);
   23794:	e51b2014 	ldr	r2, [fp, #-20]
   23798:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2379c:	e1520003 	cmp	r2, r3
   237a0:	3affffea 	bcc	23750 <__lshift+0x128>
      if ((*x1 = z) != 0)
   237a4:	e51b3018 	ldr	r3, [fp, #-24]
   237a8:	e51b201c 	ldr	r2, [fp, #-28]
   237ac:	e5832000 	str	r2, [r3]
   237b0:	e51b3018 	ldr	r3, [fp, #-24]
   237b4:	e5933000 	ldr	r3, [r3]
   237b8:	e3530000 	cmp	r3, #0
   237bc:	0a00000f 	beq	23800 <__lshift+0x1d8>
	++n1;
   237c0:	e51b3010 	ldr	r3, [fp, #-16]
   237c4:	e2833001 	add	r3, r3, #1
   237c8:	e50b3010 	str	r3, [fp, #-16]
   237cc:	ea00000b 	b	23800 <__lshift+0x1d8>
	++n1;
    }
#endif
  else
    do
      *x1++ = *x++;
   237d0:	e51b3018 	ldr	r3, [fp, #-24]
   237d4:	e2832004 	add	r2, r3, #4
   237d8:	e50b2018 	str	r2, [fp, #-24]
   237dc:	e51b2014 	ldr	r2, [fp, #-20]
   237e0:	e2821004 	add	r1, r2, #4
   237e4:	e50b1014 	str	r1, [fp, #-20]
   237e8:	e5922000 	ldr	r2, [r2]
   237ec:	e5832000 	str	r2, [r3]
    while (x < xe);
   237f0:	e51b2014 	ldr	r2, [fp, #-20]
   237f4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   237f8:	e1520003 	cmp	r2, r3
   237fc:	3afffff3 	bcc	237d0 <__lshift+0x1a8>
  b1->_wds = n1 - 1;
   23800:	e51b3010 	ldr	r3, [fp, #-16]
   23804:	e2432001 	sub	r2, r3, #1
   23808:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   2380c:	e5832010 	str	r2, [r3, #16]
  Bfree (ptr, b);
   23810:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   23814:	e51b1034 	ldr	r1, [fp, #-52]	; 0x34
   23818:	ebfffcc0 	bl	22b20 <_Bfree>
  return b1;
   2381c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
}
   23820:	e1a00003 	mov	r0, r3
   23824:	e24bd004 	sub	sp, fp, #4
   23828:	e8bd4800 	pop	{fp, lr}
   2382c:	e12fff1e 	bx	lr

00023830 <__mcmp>:

int
_DEFUN (cmp, (a, b), _Bigint * a _AND _Bigint * b)
{
   23830:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   23834:	e28db000 	add	fp, sp, #0
   23838:	e24dd024 	sub	sp, sp, #36	; 0x24
   2383c:	e50b0020 	str	r0, [fp, #-32]
   23840:	e50b1024 	str	r1, [fp, #-36]	; 0x24
  __ULong *xa, *xa0, *xb, *xb0;
  int i, j;

  i = a->_wds;
   23844:	e51b3020 	ldr	r3, [fp, #-32]
   23848:	e5933010 	ldr	r3, [r3, #16]
   2384c:	e50b3010 	str	r3, [fp, #-16]
  j = b->_wds;
   23850:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   23854:	e5933010 	ldr	r3, [r3, #16]
   23858:	e50b3014 	str	r3, [fp, #-20]
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
   2385c:	e51b2010 	ldr	r2, [fp, #-16]
   23860:	e51b3014 	ldr	r3, [fp, #-20]
   23864:	e0633002 	rsb	r3, r3, r2
   23868:	e50b3010 	str	r3, [fp, #-16]
   2386c:	e51b3010 	ldr	r3, [fp, #-16]
   23870:	e3530000 	cmp	r3, #0
   23874:	0a000001 	beq	23880 <__mcmp+0x50>
    return i;
   23878:	e51b3010 	ldr	r3, [fp, #-16]
   2387c:	ea00002d 	b	23938 <__mcmp+0x108>
  xa0 = a->_x;
   23880:	e51b3020 	ldr	r3, [fp, #-32]
   23884:	e2833014 	add	r3, r3, #20
   23888:	e50b3018 	str	r3, [fp, #-24]
  xa = xa0 + j;
   2388c:	e51b3014 	ldr	r3, [fp, #-20]
   23890:	e1a03103 	lsl	r3, r3, #2
   23894:	e51b2018 	ldr	r2, [fp, #-24]
   23898:	e0823003 	add	r3, r2, r3
   2389c:	e50b3008 	str	r3, [fp, #-8]
  xb0 = b->_x;
   238a0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   238a4:	e2833014 	add	r3, r3, #20
   238a8:	e50b301c 	str	r3, [fp, #-28]
  xb = xb0 + j;
   238ac:	e51b3014 	ldr	r3, [fp, #-20]
   238b0:	e1a03103 	lsl	r3, r3, #2
   238b4:	e51b201c 	ldr	r2, [fp, #-28]
   238b8:	e0823003 	add	r3, r2, r3
   238bc:	e50b300c 	str	r3, [fp, #-12]
  for (;;)
    {
      if (*--xa != *--xb)
   238c0:	e51b3008 	ldr	r3, [fp, #-8]
   238c4:	e2433004 	sub	r3, r3, #4
   238c8:	e50b3008 	str	r3, [fp, #-8]
   238cc:	e51b3008 	ldr	r3, [fp, #-8]
   238d0:	e5932000 	ldr	r2, [r3]
   238d4:	e51b300c 	ldr	r3, [fp, #-12]
   238d8:	e2433004 	sub	r3, r3, #4
   238dc:	e50b300c 	str	r3, [fp, #-12]
   238e0:	e51b300c 	ldr	r3, [fp, #-12]
   238e4:	e5933000 	ldr	r3, [r3]
   238e8:	e1520003 	cmp	r2, r3
   238ec:	0a000009 	beq	23918 <__mcmp+0xe8>
	return *xa < *xb ? -1 : 1;
   238f0:	e51b3008 	ldr	r3, [fp, #-8]
   238f4:	e5932000 	ldr	r2, [r3]
   238f8:	e51b300c 	ldr	r3, [fp, #-12]
   238fc:	e5933000 	ldr	r3, [r3]
   23900:	e1520003 	cmp	r2, r3
   23904:	2a000001 	bcs	23910 <__mcmp+0xe0>
   23908:	e3e03000 	mvn	r3, #0
   2390c:	ea000009 	b	23938 <__mcmp+0x108>
   23910:	e3a03001 	mov	r3, #1
   23914:	ea000007 	b	23938 <__mcmp+0x108>
      if (xa <= xa0)
   23918:	e51b2008 	ldr	r2, [fp, #-8]
   2391c:	e51b3018 	ldr	r3, [fp, #-24]
   23920:	e1520003 	cmp	r2, r3
   23924:	8a000002 	bhi	23934 <__mcmp+0x104>
	break;
   23928:	e1a00000 	nop			; (mov r0, r0)
    }
  return 0;
   2392c:	e3a03000 	mov	r3, #0
   23930:	ea000000 	b	23938 <__mcmp+0x108>
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
      if (xa <= xa0)
	break;
    }
   23934:	eaffffe1 	b	238c0 <__mcmp+0x90>
  return 0;
}
   23938:	e1a00003 	mov	r0, r3
   2393c:	e24bd000 	sub	sp, fp, #0
   23940:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   23944:	e12fff1e 	bx	lr

00023948 <__mdiff>:

_Bigint *
_DEFUN (diff, (ptr, a, b), struct _reent * ptr _AND
	_Bigint * a _AND _Bigint * b)
{
   23948:	e92d4800 	push	{fp, lr}
   2394c:	e28db004 	add	fp, sp, #4
   23950:	e24dd040 	sub	sp, sp, #64	; 0x40
   23954:	e50b0038 	str	r0, [fp, #-56]	; 0x38
   23958:	e50b103c 	str	r1, [fp, #-60]	; 0x3c
   2395c:	e50b2040 	str	r2, [fp, #-64]	; 0x40
  __ULong *xa, *xae, *xb, *xbe, *xc;
#ifdef Pack_32
  __Long z;
#endif

  i = cmp (a, b);
   23960:	e51b003c 	ldr	r0, [fp, #-60]	; 0x3c
   23964:	e51b1040 	ldr	r1, [fp, #-64]	; 0x40
   23968:	ebffffb0 	bl	23830 <__mcmp>
   2396c:	e50b0008 	str	r0, [fp, #-8]
  if (!i)
   23970:	e51b3008 	ldr	r3, [fp, #-8]
   23974:	e3530000 	cmp	r3, #0
   23978:	1a00000b 	bne	239ac <__mdiff+0x64>
    {
      c = Balloc (ptr, 0);
   2397c:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
   23980:	e3a01000 	mov	r1, #0
   23984:	ebfffc19 	bl	229f0 <_Balloc>
   23988:	e50b0020 	str	r0, [fp, #-32]
      c->_wds = 1;
   2398c:	e51b3020 	ldr	r3, [fp, #-32]
   23990:	e3a02001 	mov	r2, #1
   23994:	e5832010 	str	r2, [r3, #16]
      c->_x[0] = 0;
   23998:	e51b3020 	ldr	r3, [fp, #-32]
   2399c:	e3a02000 	mov	r2, #0
   239a0:	e5832014 	str	r2, [r3, #20]
      return c;
   239a4:	e51b3020 	ldr	r3, [fp, #-32]
   239a8:	ea000092 	b	23bf8 <__mdiff+0x2b0>
    }
  if (i < 0)
   239ac:	e51b3008 	ldr	r3, [fp, #-8]
   239b0:	e3530000 	cmp	r3, #0
   239b4:	aa000008 	bge	239dc <__mdiff+0x94>
    {
      c = a;
   239b8:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   239bc:	e50b3020 	str	r3, [fp, #-32]
      a = b;
   239c0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   239c4:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
      b = c;
   239c8:	e51b3020 	ldr	r3, [fp, #-32]
   239cc:	e50b3040 	str	r3, [fp, #-64]	; 0x40
      i = 1;
   239d0:	e3a03001 	mov	r3, #1
   239d4:	e50b3008 	str	r3, [fp, #-8]
   239d8:	ea000001 	b	239e4 <__mdiff+0x9c>
    }
  else
    i = 0;
   239dc:	e3a03000 	mov	r3, #0
   239e0:	e50b3008 	str	r3, [fp, #-8]
  c = Balloc (ptr, a->_k);
   239e4:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   239e8:	e5933004 	ldr	r3, [r3, #4]
   239ec:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
   239f0:	e1a01003 	mov	r1, r3
   239f4:	ebfffbfd 	bl	229f0 <_Balloc>
   239f8:	e50b0020 	str	r0, [fp, #-32]
  c->_sign = i;
   239fc:	e51b3020 	ldr	r3, [fp, #-32]
   23a00:	e51b2008 	ldr	r2, [fp, #-8]
   23a04:	e583200c 	str	r2, [r3, #12]
  wa = a->_wds;
   23a08:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   23a0c:	e5933010 	ldr	r3, [r3, #16]
   23a10:	e50b300c 	str	r3, [fp, #-12]
  xa = a->_x;
   23a14:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   23a18:	e2833014 	add	r3, r3, #20
   23a1c:	e50b3014 	str	r3, [fp, #-20]
  xae = xa + wa;
   23a20:	e51b300c 	ldr	r3, [fp, #-12]
   23a24:	e1a03103 	lsl	r3, r3, #2
   23a28:	e51b2014 	ldr	r2, [fp, #-20]
   23a2c:	e0823003 	add	r3, r2, r3
   23a30:	e50b3024 	str	r3, [fp, #-36]	; 0x24
  wb = b->_wds;
   23a34:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   23a38:	e5933010 	ldr	r3, [r3, #16]
   23a3c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
  xb = b->_x;
   23a40:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   23a44:	e2833014 	add	r3, r3, #20
   23a48:	e50b3018 	str	r3, [fp, #-24]
  xbe = xb + wb;
   23a4c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   23a50:	e1a03103 	lsl	r3, r3, #2
   23a54:	e51b2018 	ldr	r2, [fp, #-24]
   23a58:	e0823003 	add	r3, r2, r3
   23a5c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
  xc = c->_x;
   23a60:	e51b3020 	ldr	r3, [fp, #-32]
   23a64:	e2833014 	add	r3, r3, #20
   23a68:	e50b301c 	str	r3, [fp, #-28]
  borrow = 0;
   23a6c:	e3a03000 	mov	r3, #0
   23a70:	e50b3010 	str	r3, [fp, #-16]
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
   23a74:	e51b3014 	ldr	r3, [fp, #-20]
   23a78:	e5933000 	ldr	r3, [r3]
   23a7c:	e1a02803 	lsl	r2, r3, #16
   23a80:	e1a02822 	lsr	r2, r2, #16
   23a84:	e51b3018 	ldr	r3, [fp, #-24]
   23a88:	e5933000 	ldr	r3, [r3]
   23a8c:	e1a03803 	lsl	r3, r3, #16
   23a90:	e1a03823 	lsr	r3, r3, #16
   23a94:	e0632002 	rsb	r2, r3, r2
   23a98:	e51b3010 	ldr	r3, [fp, #-16]
   23a9c:	e0823003 	add	r3, r2, r3
   23aa0:	e50b3030 	str	r3, [fp, #-48]	; 0x30
      borrow = y >> 16;
   23aa4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   23aa8:	e1a03843 	asr	r3, r3, #16
   23aac:	e50b3010 	str	r3, [fp, #-16]
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
   23ab0:	e51b3014 	ldr	r3, [fp, #-20]
   23ab4:	e2832004 	add	r2, r3, #4
   23ab8:	e50b2014 	str	r2, [fp, #-20]
   23abc:	e5933000 	ldr	r3, [r3]
   23ac0:	e1a02823 	lsr	r2, r3, #16
   23ac4:	e51b3018 	ldr	r3, [fp, #-24]
   23ac8:	e2831004 	add	r1, r3, #4
   23acc:	e50b1018 	str	r1, [fp, #-24]
   23ad0:	e5933000 	ldr	r3, [r3]
   23ad4:	e1a03823 	lsr	r3, r3, #16
   23ad8:	e0632002 	rsb	r2, r3, r2
   23adc:	e51b3010 	ldr	r3, [fp, #-16]
   23ae0:	e0823003 	add	r3, r2, r3
   23ae4:	e50b3034 	str	r3, [fp, #-52]	; 0x34
      borrow = z >> 16;
   23ae8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   23aec:	e1a03843 	asr	r3, r3, #16
   23af0:	e50b3010 	str	r3, [fp, #-16]
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   23af4:	e51b201c 	ldr	r2, [fp, #-28]
   23af8:	e2823004 	add	r3, r2, #4
   23afc:	e50b301c 	str	r3, [fp, #-28]
   23b00:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   23b04:	e1a01803 	lsl	r1, r3, #16
   23b08:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   23b0c:	e1a03803 	lsl	r3, r3, #16
   23b10:	e1a03823 	lsr	r3, r3, #16
   23b14:	e1813003 	orr	r3, r1, r3
   23b18:	e5823000 	str	r3, [r2]
    }
  while (xb < xbe);
   23b1c:	e51b2018 	ldr	r2, [fp, #-24]
   23b20:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   23b24:	e1520003 	cmp	r2, r3
   23b28:	3affffd1 	bcc	23a74 <__mdiff+0x12c>
  while (xa < xae)
   23b2c:	ea00001e 	b	23bac <__mdiff+0x264>
    {
      y = (*xa & 0xffff) + borrow;
   23b30:	e51b3014 	ldr	r3, [fp, #-20]
   23b34:	e5933000 	ldr	r3, [r3]
   23b38:	e1a03803 	lsl	r3, r3, #16
   23b3c:	e1a03823 	lsr	r3, r3, #16
   23b40:	e51b2010 	ldr	r2, [fp, #-16]
   23b44:	e0833002 	add	r3, r3, r2
   23b48:	e50b3030 	str	r3, [fp, #-48]	; 0x30
      borrow = y >> 16;
   23b4c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   23b50:	e1a03843 	asr	r3, r3, #16
   23b54:	e50b3010 	str	r3, [fp, #-16]
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
   23b58:	e51b3014 	ldr	r3, [fp, #-20]
   23b5c:	e2832004 	add	r2, r3, #4
   23b60:	e50b2014 	str	r2, [fp, #-20]
   23b64:	e5933000 	ldr	r3, [r3]
   23b68:	e1a02823 	lsr	r2, r3, #16
   23b6c:	e51b3010 	ldr	r3, [fp, #-16]
   23b70:	e0823003 	add	r3, r2, r3
   23b74:	e50b3034 	str	r3, [fp, #-52]	; 0x34
      borrow = z >> 16;
   23b78:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   23b7c:	e1a03843 	asr	r3, r3, #16
   23b80:	e50b3010 	str	r3, [fp, #-16]
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   23b84:	e51b201c 	ldr	r2, [fp, #-28]
   23b88:	e2823004 	add	r3, r2, #4
   23b8c:	e50b301c 	str	r3, [fp, #-28]
   23b90:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   23b94:	e1a01803 	lsl	r1, r3, #16
   23b98:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   23b9c:	e1a03803 	lsl	r3, r3, #16
   23ba0:	e1a03823 	lsr	r3, r3, #16
   23ba4:	e1813003 	orr	r3, r1, r3
   23ba8:	e5823000 	str	r3, [r2]
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
    }
  while (xb < xbe);
  while (xa < xae)
   23bac:	e51b2014 	ldr	r2, [fp, #-20]
   23bb0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   23bb4:	e1520003 	cmp	r2, r3
   23bb8:	3affffdc 	bcc	23b30 <__mdiff+0x1e8>
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
   23bbc:	ea000002 	b	23bcc <__mdiff+0x284>
    wa--;
   23bc0:	e51b300c 	ldr	r3, [fp, #-12]
   23bc4:	e2433001 	sub	r3, r3, #1
   23bc8:	e50b300c 	str	r3, [fp, #-12]
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
   23bcc:	e51b301c 	ldr	r3, [fp, #-28]
   23bd0:	e2433004 	sub	r3, r3, #4
   23bd4:	e50b301c 	str	r3, [fp, #-28]
   23bd8:	e51b301c 	ldr	r3, [fp, #-28]
   23bdc:	e5933000 	ldr	r3, [r3]
   23be0:	e3530000 	cmp	r3, #0
   23be4:	0afffff5 	beq	23bc0 <__mdiff+0x278>
    wa--;
  c->_wds = wa;
   23be8:	e51b3020 	ldr	r3, [fp, #-32]
   23bec:	e51b200c 	ldr	r2, [fp, #-12]
   23bf0:	e5832010 	str	r2, [r3, #16]
  return c;
   23bf4:	e51b3020 	ldr	r3, [fp, #-32]
}
   23bf8:	e1a00003 	mov	r0, r3
   23bfc:	e24bd004 	sub	sp, fp, #4
   23c00:	e8bd4800 	pop	{fp, lr}
   23c04:	e12fff1e 	bx	lr

00023c08 <__ulp>:

double
_DEFUN (ulp, (_x), double _x)
{
   23c08:	e92d0810 	push	{r4, fp}
   23c0c:	e28db004 	add	fp, sp, #4
   23c10:	e24dd018 	sub	sp, sp, #24
   23c14:	e50b001c 	str	r0, [fp, #-28]
   23c18:	e50b1018 	str	r1, [fp, #-24]
  union double_union x, a;
  register __Long L;

  x.d = _x;
   23c1c:	e24b401c 	sub	r4, fp, #28
   23c20:	e8940018 	ldm	r4, {r3, r4}
   23c24:	e50b300c 	str	r3, [fp, #-12]
   23c28:	e50b4008 	str	r4, [fp, #-8]

  L = (word0 (x) & Exp_mask) - (P - 1) * Exp_msk1;
   23c2c:	e51b2008 	ldr	r2, [fp, #-8]
   23c30:	e59f3094 	ldr	r3, [pc, #148]	; 23ccc <__ulp+0xc4>
   23c34:	e0033002 	and	r3, r3, r2
   23c38:	e243350d 	sub	r3, r3, #54525952	; 0x3400000
   23c3c:	e1a04003 	mov	r4, r3
#ifndef Sudden_Underflow
  if (L > 0)
   23c40:	e3540000 	cmp	r4, #0
   23c44:	da000004 	ble	23c5c <__ulp+0x54>
    {
#endif
#ifdef IBM
      L |= Exp_msk1 >> 4;
#endif
      word0 (a) = L;
   23c48:	e1a03004 	mov	r3, r4
   23c4c:	e50b3010 	str	r3, [fp, #-16]
#ifndef _DOUBLE_IS_32BITS
      word1 (a) = 0;
   23c50:	e3a03000 	mov	r3, #0
   23c54:	e50b3014 	str	r3, [fp, #-20]
   23c58:	ea000014 	b	23cb0 <__ulp+0xa8>

#ifndef Sudden_Underflow
    }
  else
    {
      L = -L >> Exp_shift;
   23c5c:	e2643000 	rsb	r3, r4, #0
   23c60:	e1a04a43 	asr	r4, r3, #20
      if (L < Exp_shift)
   23c64:	e3540013 	cmp	r4, #19
   23c68:	ca000005 	bgt	23c84 <__ulp+0x7c>
	{
	  word0 (a) = 0x80000 >> L;
   23c6c:	e3a03702 	mov	r3, #524288	; 0x80000
   23c70:	e1a03453 	asr	r3, r3, r4
   23c74:	e50b3010 	str	r3, [fp, #-16]
#ifndef _DOUBLE_IS_32BITS
	  word1 (a) = 0;
   23c78:	e3a03000 	mov	r3, #0
   23c7c:	e50b3014 	str	r3, [fp, #-20]
   23c80:	ea00000a 	b	23cb0 <__ulp+0xa8>
#endif
	}
      else
	{
	  word0 (a) = 0;
   23c84:	e3a03000 	mov	r3, #0
   23c88:	e50b3010 	str	r3, [fp, #-16]
	  L -= Exp_shift;
   23c8c:	e2444014 	sub	r4, r4, #20
#ifndef _DOUBLE_IS_32BITS
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
   23c90:	e354001e 	cmp	r4, #30
   23c94:	ca000003 	bgt	23ca8 <__ulp+0xa0>
   23c98:	e264301f 	rsb	r3, r4, #31
   23c9c:	e3a02001 	mov	r2, #1
   23ca0:	e1a03312 	lsl	r3, r2, r3
   23ca4:	ea000000 	b	23cac <__ulp+0xa4>
   23ca8:	e3a03001 	mov	r3, #1
   23cac:	e50b3014 	str	r3, [fp, #-20]
#endif
	}
    }
#endif
  return a.d;
   23cb0:	e24b4014 	sub	r4, fp, #20
   23cb4:	e8940018 	ldm	r4, {r3, r4}
}
   23cb8:	e1a00003 	mov	r0, r3
   23cbc:	e1a01004 	mov	r1, r4
   23cc0:	e24bd004 	sub	sp, fp, #4
   23cc4:	e8bd0810 	pop	{r4, fp}
   23cc8:	e12fff1e 	bx	lr
   23ccc:	7ff00000 	.word	0x7ff00000

00023cd0 <__b2d>:

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   23cd0:	e92d4810 	push	{r4, fp, lr}
   23cd4:	e28db008 	add	fp, sp, #8
   23cd8:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   23cdc:	e50b0030 	str	r0, [fp, #-48]	; 0x30
   23ce0:	e50b1034 	str	r1, [fp, #-52]	; 0x34
#else
#define d0 word0(d)
#define d1 word1(d)
#endif

  xa0 = a->_x;
   23ce4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   23ce8:	e2833014 	add	r3, r3, #20
   23cec:	e50b3014 	str	r3, [fp, #-20]
  xa = xa0 + a->_wds;
   23cf0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   23cf4:	e5933010 	ldr	r3, [r3, #16]
   23cf8:	e1a03103 	lsl	r3, r3, #2
   23cfc:	e51b2014 	ldr	r2, [fp, #-20]
   23d00:	e0823003 	add	r3, r2, r3
   23d04:	e50b3010 	str	r3, [fp, #-16]
  y = *--xa;
   23d08:	e51b3010 	ldr	r3, [fp, #-16]
   23d0c:	e2433004 	sub	r3, r3, #4
   23d10:	e50b3010 	str	r3, [fp, #-16]
   23d14:	e51b3010 	ldr	r3, [fp, #-16]
   23d18:	e5933000 	ldr	r3, [r3]
   23d1c:	e50b3018 	str	r3, [fp, #-24]
#ifdef DEBUG
  if (!y)
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
   23d20:	e51b0018 	ldr	r0, [fp, #-24]
   23d24:	ebfffc62 	bl	22eb4 <__hi0bits>
   23d28:	e50b001c 	str	r0, [fp, #-28]
  *e = 32 - k;
   23d2c:	e51b301c 	ldr	r3, [fp, #-28]
   23d30:	e2632020 	rsb	r2, r3, #32
   23d34:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   23d38:	e5832000 	str	r2, [r3]
#ifdef Pack_32
  if (k < Ebits)
   23d3c:	e51b301c 	ldr	r3, [fp, #-28]
   23d40:	e353000a 	cmp	r3, #10
   23d44:	ca00001d 	bgt	23dc0 <__b2d+0xf0>
    {
      d0 = Exp_1 | y >> (Ebits - k);
   23d48:	e51b301c 	ldr	r3, [fp, #-28]
   23d4c:	e263300b 	rsb	r3, r3, #11
   23d50:	e51b2018 	ldr	r2, [fp, #-24]
   23d54:	e1a03332 	lsr	r3, r2, r3
   23d58:	e38335ff 	orr	r3, r3, #1069547520	; 0x3fc00000
   23d5c:	e3833603 	orr	r3, r3, #3145728	; 0x300000
   23d60:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      w = xa > xa0 ? *--xa : 0;
   23d64:	e51b2010 	ldr	r2, [fp, #-16]
   23d68:	e51b3014 	ldr	r3, [fp, #-20]
   23d6c:	e1520003 	cmp	r2, r3
   23d70:	9a000005 	bls	23d8c <__b2d+0xbc>
   23d74:	e51b3010 	ldr	r3, [fp, #-16]
   23d78:	e2433004 	sub	r3, r3, #4
   23d7c:	e50b3010 	str	r3, [fp, #-16]
   23d80:	e51b3010 	ldr	r3, [fp, #-16]
   23d84:	e5933000 	ldr	r3, [r3]
   23d88:	ea000000 	b	23d90 <__b2d+0xc0>
   23d8c:	e3a03000 	mov	r3, #0
   23d90:	e50b3020 	str	r3, [fp, #-32]
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
   23d94:	e51b301c 	ldr	r3, [fp, #-28]
   23d98:	e2833015 	add	r3, r3, #21
   23d9c:	e51b2018 	ldr	r2, [fp, #-24]
   23da0:	e1a02312 	lsl	r2, r2, r3
   23da4:	e51b301c 	ldr	r3, [fp, #-28]
   23da8:	e263300b 	rsb	r3, r3, #11
   23dac:	e51b1020 	ldr	r1, [fp, #-32]
   23db0:	e1a03331 	lsr	r3, r1, r3
   23db4:	e1823003 	orr	r3, r2, r3
   23db8:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
#endif
      goto ret_d;
   23dbc:	ea000038 	b	23ea4 <__b2d+0x1d4>
    }
  z = xa > xa0 ? *--xa : 0;
   23dc0:	e51b2010 	ldr	r2, [fp, #-16]
   23dc4:	e51b3014 	ldr	r3, [fp, #-20]
   23dc8:	e1520003 	cmp	r2, r3
   23dcc:	9a000005 	bls	23de8 <__b2d+0x118>
   23dd0:	e51b3010 	ldr	r3, [fp, #-16]
   23dd4:	e2433004 	sub	r3, r3, #4
   23dd8:	e50b3010 	str	r3, [fp, #-16]
   23ddc:	e51b3010 	ldr	r3, [fp, #-16]
   23de0:	e5933000 	ldr	r3, [r3]
   23de4:	ea000000 	b	23dec <__b2d+0x11c>
   23de8:	e3a03000 	mov	r3, #0
   23dec:	e50b3024 	str	r3, [fp, #-36]	; 0x24
  if (k -= Ebits)
   23df0:	e51b301c 	ldr	r3, [fp, #-28]
   23df4:	e243300b 	sub	r3, r3, #11
   23df8:	e50b301c 	str	r3, [fp, #-28]
   23dfc:	e51b301c 	ldr	r3, [fp, #-28]
   23e00:	e3530000 	cmp	r3, #0
   23e04:	0a000020 	beq	23e8c <__b2d+0x1bc>
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
   23e08:	e51b2018 	ldr	r2, [fp, #-24]
   23e0c:	e51b301c 	ldr	r3, [fp, #-28]
   23e10:	e1a02312 	lsl	r2, r2, r3
   23e14:	e51b301c 	ldr	r3, [fp, #-28]
   23e18:	e2633020 	rsb	r3, r3, #32
   23e1c:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
   23e20:	e1a03331 	lsr	r3, r1, r3
   23e24:	e1823003 	orr	r3, r2, r3
   23e28:	e38335ff 	orr	r3, r3, #1069547520	; 0x3fc00000
   23e2c:	e3833603 	orr	r3, r3, #3145728	; 0x300000
   23e30:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      y = xa > xa0 ? *--xa : 0;
   23e34:	e51b2010 	ldr	r2, [fp, #-16]
   23e38:	e51b3014 	ldr	r3, [fp, #-20]
   23e3c:	e1520003 	cmp	r2, r3
   23e40:	9a000005 	bls	23e5c <__b2d+0x18c>
   23e44:	e51b3010 	ldr	r3, [fp, #-16]
   23e48:	e2433004 	sub	r3, r3, #4
   23e4c:	e50b3010 	str	r3, [fp, #-16]
   23e50:	e51b3010 	ldr	r3, [fp, #-16]
   23e54:	e5933000 	ldr	r3, [r3]
   23e58:	ea000000 	b	23e60 <__b2d+0x190>
   23e5c:	e3a03000 	mov	r3, #0
   23e60:	e50b3018 	str	r3, [fp, #-24]
#ifndef _DOUBLE_IS_32BITS
      d1 = z << k | y >> (32 - k);
   23e64:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   23e68:	e51b301c 	ldr	r3, [fp, #-28]
   23e6c:	e1a02312 	lsl	r2, r2, r3
   23e70:	e51b301c 	ldr	r3, [fp, #-28]
   23e74:	e2633020 	rsb	r3, r3, #32
   23e78:	e51b1018 	ldr	r1, [fp, #-24]
   23e7c:	e1a03331 	lsr	r3, r1, r3
   23e80:	e1823003 	orr	r3, r2, r3
   23e84:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   23e88:	ea000005 	b	23ea4 <__b2d+0x1d4>
#endif
    }
  else
    {
      d0 = Exp_1 | y;
   23e8c:	e51b3018 	ldr	r3, [fp, #-24]
   23e90:	e38335ff 	orr	r3, r3, #1069547520	; 0x3fc00000
   23e94:	e3833603 	orr	r3, r3, #3145728	; 0x300000
   23e98:	e50b3028 	str	r3, [fp, #-40]	; 0x28
#ifndef _DOUBLE_IS_32BITS
      d1 = z;
   23e9c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   23ea0:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
  word1 (d) = d1 >> 16 | d1 << 16;
#else
#undef d0
#undef d1
#endif
  return d.d;
   23ea4:	e24b402c 	sub	r4, fp, #44	; 0x2c
   23ea8:	e8940018 	ldm	r4, {r3, r4}
}
   23eac:	e1a00003 	mov	r0, r3
   23eb0:	e1a01004 	mov	r1, r4
   23eb4:	e24bd008 	sub	sp, fp, #8
   23eb8:	e8bd4810 	pop	{r4, fp, lr}
   23ebc:	e12fff1e 	bx	lr

00023ec0 <__d2b>:
	struct _reent * ptr _AND
	double _d _AND
	int *e _AND
	int *bits)

{
   23ec0:	e92d4810 	push	{r4, fp, lr}
   23ec4:	e28db008 	add	fp, sp, #8
   23ec8:	e24dd03c 	sub	sp, sp, #60	; 0x3c
   23ecc:	e50b0038 	str	r0, [fp, #-56]	; 0x38
   23ed0:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   23ed4:	e50b3040 	str	r3, [fp, #-64]	; 0x40
  int de, i, k;
  __ULong *x, y, z;
#ifdef VAX
  __ULong d0, d1;
#endif
  d.d = _d;
   23ed8:	e24b4044 	sub	r4, fp, #68	; 0x44
   23edc:	e8940018 	ldm	r4, {r3, r4}
   23ee0:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   23ee4:	e50b4028 	str	r4, [fp, #-40]	; 0x28
  d0 = word0 (d) >> 16 | word0 (d) << 16;
  d1 = word1 (d) >> 16 | word1 (d) << 16;
#else
#define d0 word0(d)
#define d1 word1(d)
  d.d = _d;
   23ee8:	e24b4044 	sub	r4, fp, #68	; 0x44
   23eec:	e8940018 	ldm	r4, {r3, r4}
   23ef0:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   23ef4:	e50b4028 	str	r4, [fp, #-40]	; 0x28
#endif

#ifdef Pack_32
  b = Balloc (ptr, 1);
   23ef8:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
   23efc:	e3a01001 	mov	r1, #1
   23f00:	ebfffaba 	bl	229f0 <_Balloc>
   23f04:	e50b0018 	str	r0, [fp, #-24]
#else
  b = Balloc (ptr, 2);
#endif
  x = b->_x;
   23f08:	e51b3018 	ldr	r3, [fp, #-24]
   23f0c:	e2833014 	add	r3, r3, #20
   23f10:	e50b301c 	str	r3, [fp, #-28]

  z = d0 & Frac_mask;
   23f14:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   23f18:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
   23f1c:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   23f20:	e50b3034 	str	r3, [fp, #-52]	; 0x34
  d0 &= 0x7fffffff;		/* clear sign bit, which we ignore */
   23f24:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   23f28:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   23f2c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
   23f30:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   23f34:	e1a03a23 	lsr	r3, r3, #20
   23f38:	e50b3020 	str	r3, [fp, #-32]
   23f3c:	e51b3020 	ldr	r3, [fp, #-32]
   23f40:	e3530000 	cmp	r3, #0
   23f44:	0a000002 	beq	23f54 <__d2b+0x94>
    z |= Exp_msk1;
   23f48:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   23f4c:	e3833601 	orr	r3, r3, #1048576	; 0x100000
   23f50:	e50b3034 	str	r3, [fp, #-52]	; 0x34
#endif
#ifdef Pack_32
#ifndef _DOUBLE_IS_32BITS
  if (d1)
   23f54:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   23f58:	e3530000 	cmp	r3, #0
   23f5c:	0a000028 	beq	24004 <__d2b+0x144>
    {
      y = d1;
   23f60:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   23f64:	e50b3030 	str	r3, [fp, #-48]	; 0x30
      k = lo0bits (&y);
   23f68:	e24b3030 	sub	r3, fp, #48	; 0x30
   23f6c:	e1a00003 	mov	r0, r3
   23f70:	ebfffbf6 	bl	22f50 <__lo0bits>
   23f74:	e50b0014 	str	r0, [fp, #-20]
      if (k)
   23f78:	e51b3014 	ldr	r3, [fp, #-20]
   23f7c:	e3530000 	cmp	r3, #0
   23f80:	0a00000c 	beq	23fb8 <__d2b+0xf8>
	{
         x[0] = y | z << (32 - k);
   23f84:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   23f88:	e51b3014 	ldr	r3, [fp, #-20]
   23f8c:	e2633020 	rsb	r3, r3, #32
   23f90:	e1a02312 	lsl	r2, r2, r3
   23f94:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   23f98:	e1822003 	orr	r2, r2, r3
   23f9c:	e51b301c 	ldr	r3, [fp, #-28]
   23fa0:	e5832000 	str	r2, [r3]
	  z >>= k;
   23fa4:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   23fa8:	e51b3014 	ldr	r3, [fp, #-20]
   23fac:	e1a03332 	lsr	r3, r2, r3
   23fb0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   23fb4:	ea000002 	b	23fc4 <__d2b+0x104>
	}
      else
	x[0] = y;
   23fb8:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   23fbc:	e51b301c 	ldr	r3, [fp, #-28]
   23fc0:	e5832000 	str	r2, [r3]
      i = b->_wds = (x[1] = z) ? 2 : 1;
   23fc4:	e51b301c 	ldr	r3, [fp, #-28]
   23fc8:	e2833004 	add	r3, r3, #4
   23fcc:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   23fd0:	e5832000 	str	r2, [r3]
   23fd4:	e5933000 	ldr	r3, [r3]
   23fd8:	e3530000 	cmp	r3, #0
   23fdc:	0a000001 	beq	23fe8 <__d2b+0x128>
   23fe0:	e3a03002 	mov	r3, #2
   23fe4:	ea000000 	b	23fec <__d2b+0x12c>
   23fe8:	e3a03001 	mov	r3, #1
   23fec:	e51b2018 	ldr	r2, [fp, #-24]
   23ff0:	e5823010 	str	r3, [r2, #16]
   23ff4:	e51b3018 	ldr	r3, [fp, #-24]
   23ff8:	e5933010 	ldr	r3, [r3, #16]
   23ffc:	e50b3010 	str	r3, [fp, #-16]
   24000:	ea00000f 	b	24044 <__d2b+0x184>
    {
#ifdef DEBUG
      if (!z)
	Bug ("Zero passed to d2b");
#endif
      k = lo0bits (&z);
   24004:	e24b3034 	sub	r3, fp, #52	; 0x34
   24008:	e1a00003 	mov	r0, r3
   2400c:	ebfffbcf 	bl	22f50 <__lo0bits>
   24010:	e50b0014 	str	r0, [fp, #-20]
      x[0] = z;
   24014:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   24018:	e51b301c 	ldr	r3, [fp, #-28]
   2401c:	e5832000 	str	r2, [r3]
      i = b->_wds = 1;
   24020:	e51b3018 	ldr	r3, [fp, #-24]
   24024:	e3a02001 	mov	r2, #1
   24028:	e5832010 	str	r2, [r3, #16]
   2402c:	e51b3018 	ldr	r3, [fp, #-24]
   24030:	e5933010 	ldr	r3, [r3, #16]
   24034:	e50b3010 	str	r3, [fp, #-16]
#ifndef _DOUBLE_IS_32BITS
      k += 32;
   24038:	e51b3014 	ldr	r3, [fp, #-20]
   2403c:	e2833020 	add	r3, r3, #32
   24040:	e50b3014 	str	r3, [fp, #-20]
  while (!x[i])
    --i;
  b->_wds = i + 1;
#endif
#ifndef Sudden_Underflow
  if (de)
   24044:	e51b3020 	ldr	r3, [fp, #-32]
   24048:	e3530000 	cmp	r3, #0
   2404c:	0a00000b 	beq	24080 <__d2b+0x1c0>
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
   24050:	e51b3020 	ldr	r3, [fp, #-32]
   24054:	e2433e43 	sub	r3, r3, #1072	; 0x430
   24058:	e2433003 	sub	r3, r3, #3
   2405c:	e51b2014 	ldr	r2, [fp, #-20]
   24060:	e0832002 	add	r2, r3, r2
   24064:	e59b3004 	ldr	r3, [fp, #4]
   24068:	e5832000 	str	r2, [r3]
      *bits = P - k;
   2406c:	e51b3014 	ldr	r3, [fp, #-20]
   24070:	e2632035 	rsb	r2, r3, #53	; 0x35
   24074:	e59b3008 	ldr	r3, [fp, #8]
   24078:	e5832000 	str	r2, [r3]
   2407c:	ea000014 	b	240d4 <__d2b+0x214>
#endif
#ifndef Sudden_Underflow
    }
  else
    {
      *e = de - Bias - (P - 1) + 1 + k;
   24080:	e51b3020 	ldr	r3, [fp, #-32]
   24084:	e2433e43 	sub	r3, r3, #1072	; 0x430
   24088:	e2433002 	sub	r3, r3, #2
   2408c:	e51b2014 	ldr	r2, [fp, #-20]
   24090:	e0832002 	add	r2, r3, r2
   24094:	e59b3004 	ldr	r3, [fp, #4]
   24098:	e5832000 	str	r2, [r3]
#ifdef Pack_32
      *bits = 32 * i - hi0bits (x[i - 1]);
   2409c:	e51b3010 	ldr	r3, [fp, #-16]
   240a0:	e1a04283 	lsl	r4, r3, #5
   240a4:	e51b3010 	ldr	r3, [fp, #-16]
   240a8:	e2433107 	sub	r3, r3, #-1073741823	; 0xc0000001
   240ac:	e1a03103 	lsl	r3, r3, #2
   240b0:	e51b201c 	ldr	r2, [fp, #-28]
   240b4:	e0823003 	add	r3, r2, r3
   240b8:	e5933000 	ldr	r3, [r3]
   240bc:	e1a00003 	mov	r0, r3
   240c0:	ebfffb7b 	bl	22eb4 <__hi0bits>
   240c4:	e1a03000 	mov	r3, r0
   240c8:	e0632004 	rsb	r2, r3, r4
   240cc:	e59b3008 	ldr	r3, [fp, #8]
   240d0:	e5832000 	str	r2, [r3]
#else
      *bits = (i + 2) * 16 - hi0bits (x[i]);
#endif
    }
#endif
  return b;
   240d4:	e51b3018 	ldr	r3, [fp, #-24]
}
   240d8:	e1a00003 	mov	r0, r3
   240dc:	e24bd008 	sub	sp, fp, #8
   240e0:	e8bd4810 	pop	{r4, fp, lr}
   240e4:	e12fff1e 	bx	lr

000240e8 <__ratio>:
#undef d1

double
_DEFUN (ratio, (a, b), _Bigint * a _AND _Bigint * b)

{
   240e8:	e92d4810 	push	{r4, fp, lr}
   240ec:	e28db008 	add	fp, sp, #8
   240f0:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   240f4:	e50b0030 	str	r0, [fp, #-48]	; 0x30
   240f8:	e50b1034 	str	r1, [fp, #-52]	; 0x34
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
   240fc:	e24b3028 	sub	r3, fp, #40	; 0x28
   24100:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   24104:	e1a01003 	mov	r1, r3
   24108:	ebfffef0 	bl	23cd0 <__b2d>
   2410c:	e1a03000 	mov	r3, r0
   24110:	e1a04001 	mov	r4, r1
   24114:	e50b301c 	str	r3, [fp, #-28]
   24118:	e50b4018 	str	r4, [fp, #-24]
  db.d = b2d (b, &kb);
   2411c:	e24b302c 	sub	r3, fp, #44	; 0x2c
   24120:	e51b0034 	ldr	r0, [fp, #-52]	; 0x34
   24124:	e1a01003 	mov	r1, r3
   24128:	ebfffee8 	bl	23cd0 <__b2d>
   2412c:	e1a03000 	mov	r3, r0
   24130:	e1a04001 	mov	r4, r1
   24134:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   24138:	e50b4020 	str	r4, [fp, #-32]
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
   2413c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   24140:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   24144:	e0632002 	rsb	r2, r3, r2
   24148:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2414c:	e5931010 	ldr	r1, [r3, #16]
   24150:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   24154:	e5933010 	ldr	r3, [r3, #16]
   24158:	e0633001 	rsb	r3, r3, r1
   2415c:	e1a03283 	lsl	r3, r3, #5
   24160:	e0823003 	add	r3, r2, r3
   24164:	e50b3010 	str	r3, [fp, #-16]
      word0 (db) += (k >> 2) * Exp_msk1;
      if (k &= 3)
	db.d *= 1 << k;
    }
#else
  if (k > 0)
   24168:	e51b3010 	ldr	r3, [fp, #-16]
   2416c:	e3530000 	cmp	r3, #0
   24170:	da000005 	ble	2418c <__ratio+0xa4>
    word0 (da) += k * Exp_msk1;
   24174:	e51b2018 	ldr	r2, [fp, #-24]
   24178:	e51b3010 	ldr	r3, [fp, #-16]
   2417c:	e1a03a03 	lsl	r3, r3, #20
   24180:	e0823003 	add	r3, r2, r3
   24184:	e50b3018 	str	r3, [fp, #-24]
   24188:	ea000007 	b	241ac <__ratio+0xc4>
  else
    {
      k = -k;
   2418c:	e51b3010 	ldr	r3, [fp, #-16]
   24190:	e2633000 	rsb	r3, r3, #0
   24194:	e50b3010 	str	r3, [fp, #-16]
      word0 (db) += k * Exp_msk1;
   24198:	e51b2020 	ldr	r2, [fp, #-32]
   2419c:	e51b3010 	ldr	r3, [fp, #-16]
   241a0:	e1a03a03 	lsl	r3, r3, #20
   241a4:	e0823003 	add	r3, r2, r3
   241a8:	e50b3020 	str	r3, [fp, #-32]
    }
#endif
  return da.d / db.d;
   241ac:	e24b201c 	sub	r2, fp, #28
   241b0:	e8920006 	ldm	r2, {r1, r2}
   241b4:	e24b4024 	sub	r4, fp, #36	; 0x24
   241b8:	e8940018 	ldm	r4, {r3, r4}
   241bc:	e1a00001 	mov	r0, r1
   241c0:	e1a01002 	mov	r1, r2
   241c4:	e1a02003 	mov	r2, r3
   241c8:	e1a03004 	mov	r3, r4
   241cc:	ebffc2ef 	bl	14d90 <__aeabi_ddiv>
   241d0:	e1a03000 	mov	r3, r0
   241d4:	e1a04001 	mov	r4, r1
}
   241d8:	e1a00003 	mov	r0, r3
   241dc:	e1a01004 	mov	r1, r4
   241e0:	e24bd008 	sub	sp, fp, #8
   241e4:	e8bd4810 	pop	{r4, fp, lr}
   241e8:	e12fff1e 	bx	lr

000241ec <_mprec_log10>:


double
_DEFUN (_mprec_log10, (dig),
	int dig)
{
   241ec:	e92d4810 	push	{r4, fp, lr}
   241f0:	e28db008 	add	fp, sp, #8
   241f4:	e24dd014 	sub	sp, sp, #20
   241f8:	e50b0018 	str	r0, [fp, #-24]
  double v = 1.0;
   241fc:	e3a03000 	mov	r3, #0
   24200:	e59f4084 	ldr	r4, [pc, #132]	; 2428c <_mprec_log10+0xa0>
   24204:	e50b3014 	str	r3, [fp, #-20]
   24208:	e50b4010 	str	r4, [fp, #-16]
  if (dig < 24)
   2420c:	e51b3018 	ldr	r3, [fp, #-24]
   24210:	e3530017 	cmp	r3, #23
   24214:	ca000005 	bgt	24230 <_mprec_log10+0x44>
    return tens[dig];
   24218:	e59f2070 	ldr	r2, [pc, #112]	; 24290 <_mprec_log10+0xa4>
   2421c:	e51b3018 	ldr	r3, [fp, #-24]
   24220:	e1a03183 	lsl	r3, r3, #3
   24224:	e0823003 	add	r3, r2, r3
   24228:	e8930018 	ldm	r3, {r3, r4}
   2422c:	ea000011 	b	24278 <_mprec_log10+0x8c>
  while (dig > 0)
   24230:	ea00000b 	b	24264 <_mprec_log10+0x78>
    {
      v *= 10;
   24234:	e24b1014 	sub	r1, fp, #20
   24238:	e8910003 	ldm	r1, {r0, r1}
   2423c:	e3a02000 	mov	r2, #0
   24240:	e59f304c 	ldr	r3, [pc, #76]	; 24294 <_mprec_log10+0xa8>
   24244:	ebffc22d 	bl	14b00 <__aeabi_dmul>
   24248:	e1a03000 	mov	r3, r0
   2424c:	e1a04001 	mov	r4, r1
   24250:	e50b3014 	str	r3, [fp, #-20]
   24254:	e50b4010 	str	r4, [fp, #-16]
      dig--;
   24258:	e51b3018 	ldr	r3, [fp, #-24]
   2425c:	e2433001 	sub	r3, r3, #1
   24260:	e50b3018 	str	r3, [fp, #-24]
	int dig)
{
  double v = 1.0;
  if (dig < 24)
    return tens[dig];
  while (dig > 0)
   24264:	e51b3018 	ldr	r3, [fp, #-24]
   24268:	e3530000 	cmp	r3, #0
   2426c:	cafffff0 	bgt	24234 <_mprec_log10+0x48>
    {
      v *= 10;
      dig--;
    }
  return v;
   24270:	e24b4014 	sub	r4, fp, #20
   24274:	e8940018 	ldm	r4, {r3, r4}
}
   24278:	e1a00003 	mov	r0, r3
   2427c:	e1a01004 	mov	r1, r4
   24280:	e24bd008 	sub	sp, fp, #8
   24284:	e8bd4810 	pop	{r4, fp, lr}
   24288:	e12fff1e 	bx	lr
   2428c:	3ff00000 	.word	0x3ff00000
   24290:	00033188 	.word	0x00033188
   24294:	40240000 	.word	0x40240000

00024298 <__copybits>:
void
_DEFUN (copybits, (c, n, b),
	__ULong *c _AND
	int n _AND
	_Bigint *b)
{
   24298:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   2429c:	e28db000 	add	fp, sp, #0
   242a0:	e24dd024 	sub	sp, sp, #36	; 0x24
   242a4:	e50b0018 	str	r0, [fp, #-24]
   242a8:	e50b101c 	str	r1, [fp, #-28]
   242ac:	e50b2020 	str	r2, [fp, #-32]
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
   242b0:	e51b301c 	ldr	r3, [fp, #-28]
   242b4:	e2433001 	sub	r3, r3, #1
   242b8:	e1a032c3 	asr	r3, r3, #5
   242bc:	e2833001 	add	r3, r3, #1
   242c0:	e1a03103 	lsl	r3, r3, #2
   242c4:	e51b2018 	ldr	r2, [fp, #-24]
   242c8:	e0823003 	add	r3, r2, r3
   242cc:	e50b300c 	str	r3, [fp, #-12]
	x = b->_x;
   242d0:	e51b3020 	ldr	r3, [fp, #-32]
   242d4:	e2833014 	add	r3, r3, #20
   242d8:	e50b3008 	str	r3, [fp, #-8]
#ifdef Pack_32
	xe = x + b->_wds;
   242dc:	e51b3020 	ldr	r3, [fp, #-32]
   242e0:	e5933010 	ldr	r3, [r3, #16]
   242e4:	e1a03103 	lsl	r3, r3, #2
   242e8:	e51b2008 	ldr	r2, [fp, #-8]
   242ec:	e0823003 	add	r3, r2, r3
   242f0:	e50b3010 	str	r3, [fp, #-16]
	while(x < xe)
   242f4:	ea000007 	b	24318 <__copybits+0x80>
		*c++ = *x++;
   242f8:	e51b3018 	ldr	r3, [fp, #-24]
   242fc:	e2832004 	add	r2, r3, #4
   24300:	e50b2018 	str	r2, [fp, #-24]
   24304:	e51b2008 	ldr	r2, [fp, #-8]
   24308:	e2821004 	add	r1, r2, #4
   2430c:	e50b1008 	str	r1, [fp, #-8]
   24310:	e5922000 	ldr	r2, [r2]
   24314:	e5832000 	str	r2, [r3]

	ce = c + ((n-1) >> kshift) + 1;
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
	while(x < xe)
   24318:	e51b2008 	ldr	r2, [fp, #-8]
   2431c:	e51b3010 	ldr	r3, [fp, #-16]
   24320:	e1520003 	cmp	r2, r3
   24324:	3afffff3 	bcc	242f8 <__copybits+0x60>
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
   24328:	ea000004 	b	24340 <__copybits+0xa8>
		*c++ = 0;
   2432c:	e51b3018 	ldr	r3, [fp, #-24]
   24330:	e2832004 	add	r2, r3, #4
   24334:	e50b2018 	str	r2, [fp, #-24]
   24338:	e3a02000 	mov	r2, #0
   2433c:	e5832000 	str	r2, [r3]
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
   24340:	e51b2018 	ldr	r2, [fp, #-24]
   24344:	e51b300c 	ldr	r3, [fp, #-12]
   24348:	e1520003 	cmp	r2, r3
   2434c:	3afffff6 	bcc	2432c <__copybits+0x94>
		*c++ = 0;
}
   24350:	e24bd000 	sub	sp, fp, #0
   24354:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   24358:	e12fff1e 	bx	lr

0002435c <__any_on>:

__ULong
_DEFUN (any_on, (b, k),
	_Bigint *b _AND
	int k)
{
   2435c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   24360:	e28db000 	add	fp, sp, #0
   24364:	e24dd024 	sub	sp, sp, #36	; 0x24
   24368:	e50b0020 	str	r0, [fp, #-32]
   2436c:	e50b1024 	str	r1, [fp, #-36]	; 0x24
	int n, nwds;
	__ULong *x, *x0, x1, x2;

	x = b->_x;
   24370:	e51b3020 	ldr	r3, [fp, #-32]
   24374:	e2833014 	add	r3, r3, #20
   24378:	e50b300c 	str	r3, [fp, #-12]
	nwds = b->_wds;
   2437c:	e51b3020 	ldr	r3, [fp, #-32]
   24380:	e5933010 	ldr	r3, [r3, #16]
   24384:	e50b3010 	str	r3, [fp, #-16]
	n = k >> kshift;
   24388:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   2438c:	e1a032c3 	asr	r3, r3, #5
   24390:	e50b3008 	str	r3, [fp, #-8]
	if (n > nwds)
   24394:	e51b2008 	ldr	r2, [fp, #-8]
   24398:	e51b3010 	ldr	r3, [fp, #-16]
   2439c:	e1520003 	cmp	r2, r3
   243a0:	da000002 	ble	243b0 <__any_on+0x54>
		n = nwds;
   243a4:	e51b3010 	ldr	r3, [fp, #-16]
   243a8:	e50b3008 	str	r3, [fp, #-8]
   243ac:	ea00001f 	b	24430 <__any_on+0xd4>
	else if (n < nwds && (k &= kmask)) {
   243b0:	e51b2008 	ldr	r2, [fp, #-8]
   243b4:	e51b3010 	ldr	r3, [fp, #-16]
   243b8:	e1520003 	cmp	r2, r3
   243bc:	aa00001b 	bge	24430 <__any_on+0xd4>
   243c0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   243c4:	e203301f 	and	r3, r3, #31
   243c8:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   243cc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   243d0:	e3530000 	cmp	r3, #0
   243d4:	0a000015 	beq	24430 <__any_on+0xd4>
		x1 = x2 = x[n];
   243d8:	e51b3008 	ldr	r3, [fp, #-8]
   243dc:	e1a03103 	lsl	r3, r3, #2
   243e0:	e51b200c 	ldr	r2, [fp, #-12]
   243e4:	e0823003 	add	r3, r2, r3
   243e8:	e5933000 	ldr	r3, [r3]
   243ec:	e50b3014 	str	r3, [fp, #-20]
   243f0:	e51b3014 	ldr	r3, [fp, #-20]
   243f4:	e50b3018 	str	r3, [fp, #-24]
		x1 >>= k;
   243f8:	e51b2018 	ldr	r2, [fp, #-24]
   243fc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   24400:	e1a03332 	lsr	r3, r2, r3
   24404:	e50b3018 	str	r3, [fp, #-24]
		x1 <<= k;
   24408:	e51b2018 	ldr	r2, [fp, #-24]
   2440c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   24410:	e1a03312 	lsl	r3, r2, r3
   24414:	e50b3018 	str	r3, [fp, #-24]
		if (x1 != x2)
   24418:	e51b2018 	ldr	r2, [fp, #-24]
   2441c:	e51b3014 	ldr	r3, [fp, #-20]
   24420:	e1520003 	cmp	r2, r3
   24424:	0a000001 	beq	24430 <__any_on+0xd4>
			return 1;
   24428:	e3a03001 	mov	r3, #1
   2442c:	ea000015 	b	24488 <__any_on+0x12c>
		}
	x0 = x;
   24430:	e51b300c 	ldr	r3, [fp, #-12]
   24434:	e50b301c 	str	r3, [fp, #-28]
	x += n;
   24438:	e51b3008 	ldr	r3, [fp, #-8]
   2443c:	e1a03103 	lsl	r3, r3, #2
   24440:	e51b200c 	ldr	r2, [fp, #-12]
   24444:	e0823003 	add	r3, r2, r3
   24448:	e50b300c 	str	r3, [fp, #-12]
	while(x > x0)
   2444c:	ea000008 	b	24474 <__any_on+0x118>
		if (*--x)
   24450:	e51b300c 	ldr	r3, [fp, #-12]
   24454:	e2433004 	sub	r3, r3, #4
   24458:	e50b300c 	str	r3, [fp, #-12]
   2445c:	e51b300c 	ldr	r3, [fp, #-12]
   24460:	e5933000 	ldr	r3, [r3]
   24464:	e3530000 	cmp	r3, #0
   24468:	0a000001 	beq	24474 <__any_on+0x118>
			return 1;
   2446c:	e3a03001 	mov	r3, #1
   24470:	ea000004 	b	24488 <__any_on+0x12c>
		if (x1 != x2)
			return 1;
		}
	x0 = x;
	x += n;
	while(x > x0)
   24474:	e51b200c 	ldr	r2, [fp, #-12]
   24478:	e51b301c 	ldr	r3, [fp, #-28]
   2447c:	e1520003 	cmp	r2, r3
   24480:	8afffff2 	bhi	24450 <__any_on+0xf4>
		if (*--x)
			return 1;
	return 0;
   24484:	e3a03000 	mov	r3, #0
}
   24488:	e1a00003 	mov	r0, r3
   2448c:	e24bd000 	sub	sp, fp, #0
   24490:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   24494:	e12fff1e 	bx	lr

00024498 <_read_r>:
_DEFUN (_read_r, (ptr, fd, buf, cnt),
     struct _reent *ptr _AND
     int fd _AND
     _PTR buf _AND
     size_t cnt)
{
   24498:	e92d4800 	push	{fp, lr}
   2449c:	e28db004 	add	fp, sp, #4
   244a0:	e24dd018 	sub	sp, sp, #24
   244a4:	e50b0010 	str	r0, [fp, #-16]
   244a8:	e50b1014 	str	r1, [fp, #-20]
   244ac:	e50b2018 	str	r2, [fp, #-24]
   244b0:	e50b301c 	str	r3, [fp, #-28]
  _ssize_t ret;

  errno = 0;
   244b4:	e59f3058 	ldr	r3, [pc, #88]	; 24514 <_read_r+0x7c>
   244b8:	e3a02000 	mov	r2, #0
   244bc:	e5832000 	str	r2, [r3]
  if ((ret = (_ssize_t)_read (fd, buf, cnt)) == -1 && errno != 0)
   244c0:	e51b0014 	ldr	r0, [fp, #-20]
   244c4:	e51b1018 	ldr	r1, [fp, #-24]
   244c8:	e51b201c 	ldr	r2, [fp, #-28]
   244cc:	ebffd21c 	bl	18d44 <read>
   244d0:	e50b0008 	str	r0, [fp, #-8]
   244d4:	e51b3008 	ldr	r3, [fp, #-8]
   244d8:	e3730001 	cmn	r3, #1
   244dc:	1a000007 	bne	24500 <_read_r+0x68>
   244e0:	e59f302c 	ldr	r3, [pc, #44]	; 24514 <_read_r+0x7c>
   244e4:	e5933000 	ldr	r3, [r3]
   244e8:	e3530000 	cmp	r3, #0
   244ec:	0a000003 	beq	24500 <_read_r+0x68>
    ptr->_errno = errno;
   244f0:	e59f301c 	ldr	r3, [pc, #28]	; 24514 <_read_r+0x7c>
   244f4:	e5932000 	ldr	r2, [r3]
   244f8:	e51b3010 	ldr	r3, [fp, #-16]
   244fc:	e5832000 	str	r2, [r3]
  return ret;
   24500:	e51b3008 	ldr	r3, [fp, #-8]
}
   24504:	e1a00003 	mov	r0, r3
   24508:	e24bd004 	sub	sp, fp, #4
   2450c:	e8bd4800 	pop	{fp, lr}
   24510:	e12fff1e 	bx	lr
   24514:	0018b940 	.word	0x0018b940

00024518 <_realloc_r>:
#if __STD_C
Void_t* rEALLOc(RARG Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
#endif
{
   24518:	e92d4800 	push	{fp, lr}
   2451c:	e28db004 	add	fp, sp, #4
   24520:	e24dd078 	sub	sp, sp, #120	; 0x78
   24524:	e50b0070 	str	r0, [fp, #-112]	; 0x70
   24528:	e50b1074 	str	r1, [fp, #-116]	; 0x74
   2452c:	e50b2078 	str	r2, [fp, #-120]	; 0x78
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   24530:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   24534:	e3530000 	cmp	r3, #0
   24538:	1a000004 	bne	24550 <_realloc_r+0x38>
   2453c:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   24540:	e51b1078 	ldr	r1, [fp, #-120]	; 0x78
   24544:	ebffcd5a 	bl	17ab4 <_malloc_r>
   24548:	e1a03000 	mov	r3, r0
   2454c:	ea0002ed 	b	25108 <_realloc_r+0xbf0>

  MALLOC_LOCK;
   24550:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   24554:	ebffd0fd 	bl	18950 <__malloc_lock>

  newp    = oldp    = mem2chunk(oldmem);
   24558:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   2455c:	e2433008 	sub	r3, r3, #8
   24560:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   24564:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   24568:	e50b3008 	str	r3, [fp, #-8]
  newsize = oldsize = chunksize(oldp);
   2456c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   24570:	e5933004 	ldr	r3, [r3, #4]
   24574:	e3c33003 	bic	r3, r3, #3
   24578:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2457c:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   24580:	e50b300c 	str	r3, [fp, #-12]


  nb = request2size(bytes);
   24584:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   24588:	e283300b 	add	r3, r3, #11
   2458c:	e3530016 	cmp	r3, #22
   24590:	9a000003 	bls	245a4 <_realloc_r+0x8c>
   24594:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   24598:	e283300b 	add	r3, r3, #11
   2459c:	e3c33007 	bic	r3, r3, #7
   245a0:	ea000000 	b	245a8 <_realloc_r+0x90>
   245a4:	e3a03010 	mov	r3, #16
   245a8:	e50b3040 	str	r3, [fp, #-64]	; 0x40

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   245ac:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   245b0:	e3530000 	cmp	r3, #0
   245b4:	ba000003 	blt	245c8 <_realloc_r+0xb0>
   245b8:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   245bc:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   245c0:	e1520003 	cmp	r2, r3
   245c4:	2a000004 	bcs	245dc <_realloc_r+0xc4>
  {
    RERRNO = ENOMEM;
   245c8:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   245cc:	e3a0200c 	mov	r2, #12
   245d0:	e5832000 	str	r2, [r3]
    return 0;
   245d4:	e3a03000 	mov	r3, #0
   245d8:	ea0002ca 	b	25108 <_realloc_r+0xbf0>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
   245dc:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   245e0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   245e4:	e1520003 	cmp	r2, r3
   245e8:	aa00028d 	bge	25024 <_realloc_r+0xb0c>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
   245ec:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   245f0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   245f4:	e0823003 	add	r3, r2, r3
   245f8:	e50b3010 	str	r3, [fp, #-16]
    if (next == top || !inuse(next)) 
   245fc:	e59f3b14 	ldr	r3, [pc, #2836]	; 25118 <_realloc_r+0xc00>
   24600:	e5932008 	ldr	r2, [r3, #8]
   24604:	e51b3010 	ldr	r3, [fp, #-16]
   24608:	e1520003 	cmp	r2, r3
   2460c:	0a000008 	beq	24634 <_realloc_r+0x11c>
   24610:	e51b3010 	ldr	r3, [fp, #-16]
   24614:	e5933004 	ldr	r3, [r3, #4]
   24618:	e3c33001 	bic	r3, r3, #1
   2461c:	e51b2010 	ldr	r2, [fp, #-16]
   24620:	e0823003 	add	r3, r2, r3
   24624:	e5933004 	ldr	r3, [r3, #4]
   24628:	e2033001 	and	r3, r3, #1
   2462c:	e3530000 	cmp	r3, #0
   24630:	1a000045 	bne	2474c <_realloc_r+0x234>
    {
      nextsize = chunksize(next);
   24634:	e51b3010 	ldr	r3, [fp, #-16]
   24638:	e5933004 	ldr	r3, [r3, #4]
   2463c:	e3c33003 	bic	r3, r3, #3
   24640:	e50b3014 	str	r3, [fp, #-20]

      /* Forward into top only if a remainder */
      if (next == top)
   24644:	e59f3acc 	ldr	r3, [pc, #2764]	; 25118 <_realloc_r+0xc00>
   24648:	e5932008 	ldr	r2, [r3, #8]
   2464c:	e51b3010 	ldr	r3, [fp, #-16]
   24650:	e1520003 	cmp	r2, r3
   24654:	1a000023 	bne	246e8 <_realloc_r+0x1d0>
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
   24658:	e51b2014 	ldr	r2, [fp, #-20]
   2465c:	e51b300c 	ldr	r3, [fp, #-12]
   24660:	e0823003 	add	r3, r2, r3
   24664:	e1a02003 	mov	r2, r3
   24668:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   2466c:	e2833010 	add	r3, r3, #16
   24670:	e1520003 	cmp	r2, r3
   24674:	ba000033 	blt	24748 <_realloc_r+0x230>
        {
          newsize += nextsize;
   24678:	e51b200c 	ldr	r2, [fp, #-12]
   2467c:	e51b3014 	ldr	r3, [fp, #-20]
   24680:	e0823003 	add	r3, r2, r3
   24684:	e50b300c 	str	r3, [fp, #-12]
          top = chunk_at_offset(oldp, nb);
   24688:	e59f3a88 	ldr	r3, [pc, #2696]	; 25118 <_realloc_r+0xc00>
   2468c:	e51b1038 	ldr	r1, [fp, #-56]	; 0x38
   24690:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   24694:	e0812002 	add	r2, r1, r2
   24698:	e5832008 	str	r2, [r3, #8]
          set_head(top, (newsize - nb) | PREV_INUSE);
   2469c:	e59f3a74 	ldr	r3, [pc, #2676]	; 25118 <_realloc_r+0xc00>
   246a0:	e5933008 	ldr	r3, [r3, #8]
   246a4:	e51b100c 	ldr	r1, [fp, #-12]
   246a8:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   246ac:	e0622001 	rsb	r2, r2, r1
   246b0:	e3822001 	orr	r2, r2, #1
   246b4:	e5832004 	str	r2, [r3, #4]
          set_head_size(oldp, nb);
   246b8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   246bc:	e5933004 	ldr	r3, [r3, #4]
   246c0:	e2032001 	and	r2, r3, #1
   246c4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   246c8:	e1822003 	orr	r2, r2, r3
   246cc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   246d0:	e5832004 	str	r2, [r3, #4]
	  MALLOC_UNLOCK;
   246d4:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   246d8:	ebffd0a6 	bl	18978 <__malloc_unlock>
          return chunk2mem(oldp);
   246dc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   246e0:	e2833008 	add	r3, r3, #8
   246e4:	ea000287 	b	25108 <_realloc_r+0xbf0>
        }
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
   246e8:	e51b2014 	ldr	r2, [fp, #-20]
   246ec:	e51b300c 	ldr	r3, [fp, #-12]
   246f0:	e0823003 	add	r3, r2, r3
   246f4:	e1a02003 	mov	r2, r3
   246f8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   246fc:	e1520003 	cmp	r2, r3
   24700:	ba000010 	blt	24748 <_realloc_r+0x230>
      { 
        unlink(next, bck, fwd);
   24704:	e51b3010 	ldr	r3, [fp, #-16]
   24708:	e593300c 	ldr	r3, [r3, #12]
   2470c:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   24710:	e51b3010 	ldr	r3, [fp, #-16]
   24714:	e5933008 	ldr	r3, [r3, #8]
   24718:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   2471c:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   24720:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   24724:	e583200c 	str	r2, [r3, #12]
   24728:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2472c:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   24730:	e5832008 	str	r2, [r3, #8]
        newsize  += nextsize;
   24734:	e51b200c 	ldr	r2, [fp, #-12]
   24738:	e51b3014 	ldr	r3, [fp, #-20]
   2473c:	e0823003 	add	r3, r2, r3
   24740:	e50b300c 	str	r3, [fp, #-12]
        goto split;
   24744:	ea000236 	b	25024 <_realloc_r+0xb0c>
    if (next == top || !inuse(next)) 
    {
      nextsize = chunksize(next);

      /* Forward into top only if a remainder */
      if (next == top)
   24748:	ea000003 	b	2475c <_realloc_r+0x244>
        goto split;
      }
    }
    else
    {
      next = 0;
   2474c:	e3a03000 	mov	r3, #0
   24750:	e50b3010 	str	r3, [fp, #-16]
      nextsize = 0;
   24754:	e3a03000 	mov	r3, #0
   24758:	e50b3014 	str	r3, [fp, #-20]
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   2475c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   24760:	e5933004 	ldr	r3, [r3, #4]
   24764:	e2033001 	and	r3, r3, #1
   24768:	e3530000 	cmp	r3, #0
   2476c:	1a0001aa 	bne	24e1c <_realloc_r+0x904>
    {
      prev = prev_chunk(oldp);
   24770:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   24774:	e5933000 	ldr	r3, [r3]
   24778:	e2633000 	rsb	r3, r3, #0
   2477c:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   24780:	e0823003 	add	r3, r2, r3
   24784:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
      prevsize = chunksize(prev);
   24788:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   2478c:	e5933004 	ldr	r3, [r3, #4]
   24790:	e3c33003 	bic	r3, r3, #3
   24794:	e50b3050 	str	r3, [fp, #-80]	; 0x50

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
   24798:	e51b3010 	ldr	r3, [fp, #-16]
   2479c:	e3530000 	cmp	r3, #0
   247a0:	0a000121 	beq	24c2c <_realloc_r+0x714>
      {
        /* into top */
        if (next == top)
   247a4:	e59f396c 	ldr	r3, [pc, #2412]	; 25118 <_realloc_r+0xc00>
   247a8:	e5932008 	ldr	r2, [r3, #8]
   247ac:	e51b3010 	ldr	r3, [fp, #-16]
   247b0:	e1520003 	cmp	r2, r3
   247b4:	1a000093 	bne	24a08 <_realloc_r+0x4f0>
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
   247b8:	e51b2014 	ldr	r2, [fp, #-20]
   247bc:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   247c0:	e0822003 	add	r2, r2, r3
   247c4:	e51b300c 	ldr	r3, [fp, #-12]
   247c8:	e0823003 	add	r3, r2, r3
   247cc:	e1a02003 	mov	r2, r3
   247d0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   247d4:	e2833010 	add	r3, r3, #16
   247d8:	e1520003 	cmp	r2, r3
   247dc:	ba000112 	blt	24c2c <_realloc_r+0x714>
          {
            unlink(prev, bck, fwd);
   247e0:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   247e4:	e593300c 	ldr	r3, [r3, #12]
   247e8:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   247ec:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   247f0:	e5933008 	ldr	r3, [r3, #8]
   247f4:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   247f8:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   247fc:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   24800:	e583200c 	str	r2, [r3, #12]
   24804:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   24808:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   2480c:	e5832008 	str	r2, [r3, #8]
            newp = prev;
   24810:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   24814:	e50b3008 	str	r3, [fp, #-8]
            newsize += prevsize + nextsize;
   24818:	e51b2050 	ldr	r2, [fp, #-80]	; 0x50
   2481c:	e51b3014 	ldr	r3, [fp, #-20]
   24820:	e0823003 	add	r3, r2, r3
   24824:	e51b200c 	ldr	r2, [fp, #-12]
   24828:	e0823003 	add	r3, r2, r3
   2482c:	e50b300c 	str	r3, [fp, #-12]
            newmem = chunk2mem(newp);
   24830:	e51b3008 	ldr	r3, [fp, #-8]
   24834:	e2833008 	add	r3, r3, #8
   24838:	e50b3054 	str	r3, [fp, #-84]	; 0x54
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   2483c:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   24840:	e2433004 	sub	r3, r3, #4
   24844:	e50b3058 	str	r3, [fp, #-88]	; 0x58
   24848:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   2484c:	e3530024 	cmp	r3, #36	; 0x24
   24850:	8a000051 	bhi	2499c <_realloc_r+0x484>
   24854:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   24858:	e50b3018 	str	r3, [fp, #-24]
   2485c:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   24860:	e50b301c 	str	r3, [fp, #-28]
   24864:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   24868:	e3530013 	cmp	r3, #19
   2486c:	9a000035 	bls	24948 <_realloc_r+0x430>
   24870:	e51b301c 	ldr	r3, [fp, #-28]
   24874:	e2832004 	add	r2, r3, #4
   24878:	e50b201c 	str	r2, [fp, #-28]
   2487c:	e51b2018 	ldr	r2, [fp, #-24]
   24880:	e2821004 	add	r1, r2, #4
   24884:	e50b1018 	str	r1, [fp, #-24]
   24888:	e5922000 	ldr	r2, [r2]
   2488c:	e5832000 	str	r2, [r3]
   24890:	e51b301c 	ldr	r3, [fp, #-28]
   24894:	e2832004 	add	r2, r3, #4
   24898:	e50b201c 	str	r2, [fp, #-28]
   2489c:	e51b2018 	ldr	r2, [fp, #-24]
   248a0:	e2821004 	add	r1, r2, #4
   248a4:	e50b1018 	str	r1, [fp, #-24]
   248a8:	e5922000 	ldr	r2, [r2]
   248ac:	e5832000 	str	r2, [r3]
   248b0:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   248b4:	e353001b 	cmp	r3, #27
   248b8:	9a000022 	bls	24948 <_realloc_r+0x430>
   248bc:	e51b301c 	ldr	r3, [fp, #-28]
   248c0:	e2832004 	add	r2, r3, #4
   248c4:	e50b201c 	str	r2, [fp, #-28]
   248c8:	e51b2018 	ldr	r2, [fp, #-24]
   248cc:	e2821004 	add	r1, r2, #4
   248d0:	e50b1018 	str	r1, [fp, #-24]
   248d4:	e5922000 	ldr	r2, [r2]
   248d8:	e5832000 	str	r2, [r3]
   248dc:	e51b301c 	ldr	r3, [fp, #-28]
   248e0:	e2832004 	add	r2, r3, #4
   248e4:	e50b201c 	str	r2, [fp, #-28]
   248e8:	e51b2018 	ldr	r2, [fp, #-24]
   248ec:	e2821004 	add	r1, r2, #4
   248f0:	e50b1018 	str	r1, [fp, #-24]
   248f4:	e5922000 	ldr	r2, [r2]
   248f8:	e5832000 	str	r2, [r3]
   248fc:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   24900:	e3530023 	cmp	r3, #35	; 0x23
   24904:	9a00000f 	bls	24948 <_realloc_r+0x430>
   24908:	e51b301c 	ldr	r3, [fp, #-28]
   2490c:	e2832004 	add	r2, r3, #4
   24910:	e50b201c 	str	r2, [fp, #-28]
   24914:	e51b2018 	ldr	r2, [fp, #-24]
   24918:	e2821004 	add	r1, r2, #4
   2491c:	e50b1018 	str	r1, [fp, #-24]
   24920:	e5922000 	ldr	r2, [r2]
   24924:	e5832000 	str	r2, [r3]
   24928:	e51b301c 	ldr	r3, [fp, #-28]
   2492c:	e2832004 	add	r2, r3, #4
   24930:	e50b201c 	str	r2, [fp, #-28]
   24934:	e51b2018 	ldr	r2, [fp, #-24]
   24938:	e2821004 	add	r1, r2, #4
   2493c:	e50b1018 	str	r1, [fp, #-24]
   24940:	e5922000 	ldr	r2, [r2]
   24944:	e5832000 	str	r2, [r3]
   24948:	e51b301c 	ldr	r3, [fp, #-28]
   2494c:	e2832004 	add	r2, r3, #4
   24950:	e50b201c 	str	r2, [fp, #-28]
   24954:	e51b2018 	ldr	r2, [fp, #-24]
   24958:	e2821004 	add	r1, r2, #4
   2495c:	e50b1018 	str	r1, [fp, #-24]
   24960:	e5922000 	ldr	r2, [r2]
   24964:	e5832000 	str	r2, [r3]
   24968:	e51b301c 	ldr	r3, [fp, #-28]
   2496c:	e2832004 	add	r2, r3, #4
   24970:	e50b201c 	str	r2, [fp, #-28]
   24974:	e51b2018 	ldr	r2, [fp, #-24]
   24978:	e2821004 	add	r1, r2, #4
   2497c:	e50b1018 	str	r1, [fp, #-24]
   24980:	e5922000 	ldr	r2, [r2]
   24984:	e5832000 	str	r2, [r3]
   24988:	e51b3018 	ldr	r3, [fp, #-24]
   2498c:	e5932000 	ldr	r2, [r3]
   24990:	e51b301c 	ldr	r3, [fp, #-28]
   24994:	e5832000 	str	r2, [r3]
   24998:	ea000003 	b	249ac <_realloc_r+0x494>
   2499c:	e51b0054 	ldr	r0, [fp, #-84]	; 0x54
   249a0:	e51b1074 	ldr	r1, [fp, #-116]	; 0x74
   249a4:	e51b2058 	ldr	r2, [fp, #-88]	; 0x58
   249a8:	ebfff789 	bl	227d4 <memmove>
            top = chunk_at_offset(newp, nb);
   249ac:	e59f3764 	ldr	r3, [pc, #1892]	; 25118 <_realloc_r+0xc00>
   249b0:	e51b1008 	ldr	r1, [fp, #-8]
   249b4:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   249b8:	e0812002 	add	r2, r1, r2
   249bc:	e5832008 	str	r2, [r3, #8]
            set_head(top, (newsize - nb) | PREV_INUSE);
   249c0:	e59f3750 	ldr	r3, [pc, #1872]	; 25118 <_realloc_r+0xc00>
   249c4:	e5933008 	ldr	r3, [r3, #8]
   249c8:	e51b100c 	ldr	r1, [fp, #-12]
   249cc:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   249d0:	e0622001 	rsb	r2, r2, r1
   249d4:	e3822001 	orr	r2, r2, #1
   249d8:	e5832004 	str	r2, [r3, #4]
            set_head_size(newp, nb);
   249dc:	e51b3008 	ldr	r3, [fp, #-8]
   249e0:	e5933004 	ldr	r3, [r3, #4]
   249e4:	e2032001 	and	r2, r3, #1
   249e8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   249ec:	e1822003 	orr	r2, r2, r3
   249f0:	e51b3008 	ldr	r3, [fp, #-8]
   249f4:	e5832004 	str	r2, [r3, #4]
	    MALLOC_UNLOCK;
   249f8:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   249fc:	ebffcfdd 	bl	18978 <__malloc_unlock>
            return newmem;
   24a00:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   24a04:	ea0001bf 	b	25108 <_realloc_r+0xbf0>
          }
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
   24a08:	e51b2014 	ldr	r2, [fp, #-20]
   24a0c:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   24a10:	e0822003 	add	r2, r2, r3
   24a14:	e51b300c 	ldr	r3, [fp, #-12]
   24a18:	e0823003 	add	r3, r2, r3
   24a1c:	e1a02003 	mov	r2, r3
   24a20:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   24a24:	e1520003 	cmp	r2, r3
   24a28:	ba00007f 	blt	24c2c <_realloc_r+0x714>
        {
          unlink(next, bck, fwd);
   24a2c:	e51b3010 	ldr	r3, [fp, #-16]
   24a30:	e593300c 	ldr	r3, [r3, #12]
   24a34:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   24a38:	e51b3010 	ldr	r3, [fp, #-16]
   24a3c:	e5933008 	ldr	r3, [r3, #8]
   24a40:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   24a44:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   24a48:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   24a4c:	e583200c 	str	r2, [r3, #12]
   24a50:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   24a54:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   24a58:	e5832008 	str	r2, [r3, #8]
          unlink(prev, bck, fwd);
   24a5c:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   24a60:	e593300c 	ldr	r3, [r3, #12]
   24a64:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   24a68:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   24a6c:	e5933008 	ldr	r3, [r3, #8]
   24a70:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   24a74:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   24a78:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   24a7c:	e583200c 	str	r2, [r3, #12]
   24a80:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   24a84:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   24a88:	e5832008 	str	r2, [r3, #8]
          newp = prev;
   24a8c:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   24a90:	e50b3008 	str	r3, [fp, #-8]
          newsize += nextsize + prevsize;
   24a94:	e51b2014 	ldr	r2, [fp, #-20]
   24a98:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   24a9c:	e0823003 	add	r3, r2, r3
   24aa0:	e51b200c 	ldr	r2, [fp, #-12]
   24aa4:	e0823003 	add	r3, r2, r3
   24aa8:	e50b300c 	str	r3, [fp, #-12]
          newmem = chunk2mem(newp);
   24aac:	e51b3008 	ldr	r3, [fp, #-8]
   24ab0:	e2833008 	add	r3, r3, #8
   24ab4:	e50b3054 	str	r3, [fp, #-84]	; 0x54
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   24ab8:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   24abc:	e2433004 	sub	r3, r3, #4
   24ac0:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   24ac4:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   24ac8:	e3530024 	cmp	r3, #36	; 0x24
   24acc:	8a000051 	bhi	24c18 <_realloc_r+0x700>
   24ad0:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   24ad4:	e50b3020 	str	r3, [fp, #-32]
   24ad8:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   24adc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   24ae0:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   24ae4:	e3530013 	cmp	r3, #19
   24ae8:	9a000035 	bls	24bc4 <_realloc_r+0x6ac>
   24aec:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   24af0:	e2832004 	add	r2, r3, #4
   24af4:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   24af8:	e51b2020 	ldr	r2, [fp, #-32]
   24afc:	e2821004 	add	r1, r2, #4
   24b00:	e50b1020 	str	r1, [fp, #-32]
   24b04:	e5922000 	ldr	r2, [r2]
   24b08:	e5832000 	str	r2, [r3]
   24b0c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   24b10:	e2832004 	add	r2, r3, #4
   24b14:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   24b18:	e51b2020 	ldr	r2, [fp, #-32]
   24b1c:	e2821004 	add	r1, r2, #4
   24b20:	e50b1020 	str	r1, [fp, #-32]
   24b24:	e5922000 	ldr	r2, [r2]
   24b28:	e5832000 	str	r2, [r3]
   24b2c:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   24b30:	e353001b 	cmp	r3, #27
   24b34:	9a000022 	bls	24bc4 <_realloc_r+0x6ac>
   24b38:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   24b3c:	e2832004 	add	r2, r3, #4
   24b40:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   24b44:	e51b2020 	ldr	r2, [fp, #-32]
   24b48:	e2821004 	add	r1, r2, #4
   24b4c:	e50b1020 	str	r1, [fp, #-32]
   24b50:	e5922000 	ldr	r2, [r2]
   24b54:	e5832000 	str	r2, [r3]
   24b58:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   24b5c:	e2832004 	add	r2, r3, #4
   24b60:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   24b64:	e51b2020 	ldr	r2, [fp, #-32]
   24b68:	e2821004 	add	r1, r2, #4
   24b6c:	e50b1020 	str	r1, [fp, #-32]
   24b70:	e5922000 	ldr	r2, [r2]
   24b74:	e5832000 	str	r2, [r3]
   24b78:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   24b7c:	e3530023 	cmp	r3, #35	; 0x23
   24b80:	9a00000f 	bls	24bc4 <_realloc_r+0x6ac>
   24b84:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   24b88:	e2832004 	add	r2, r3, #4
   24b8c:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   24b90:	e51b2020 	ldr	r2, [fp, #-32]
   24b94:	e2821004 	add	r1, r2, #4
   24b98:	e50b1020 	str	r1, [fp, #-32]
   24b9c:	e5922000 	ldr	r2, [r2]
   24ba0:	e5832000 	str	r2, [r3]
   24ba4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   24ba8:	e2832004 	add	r2, r3, #4
   24bac:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   24bb0:	e51b2020 	ldr	r2, [fp, #-32]
   24bb4:	e2821004 	add	r1, r2, #4
   24bb8:	e50b1020 	str	r1, [fp, #-32]
   24bbc:	e5922000 	ldr	r2, [r2]
   24bc0:	e5832000 	str	r2, [r3]
   24bc4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   24bc8:	e2832004 	add	r2, r3, #4
   24bcc:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   24bd0:	e51b2020 	ldr	r2, [fp, #-32]
   24bd4:	e2821004 	add	r1, r2, #4
   24bd8:	e50b1020 	str	r1, [fp, #-32]
   24bdc:	e5922000 	ldr	r2, [r2]
   24be0:	e5832000 	str	r2, [r3]
   24be4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   24be8:	e2832004 	add	r2, r3, #4
   24bec:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   24bf0:	e51b2020 	ldr	r2, [fp, #-32]
   24bf4:	e2821004 	add	r1, r2, #4
   24bf8:	e50b1020 	str	r1, [fp, #-32]
   24bfc:	e5922000 	ldr	r2, [r2]
   24c00:	e5832000 	str	r2, [r3]
   24c04:	e51b3020 	ldr	r3, [fp, #-32]
   24c08:	e5932000 	ldr	r2, [r3]
   24c0c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   24c10:	e5832000 	str	r2, [r3]
          goto split;
   24c14:	ea000102 	b	25024 <_realloc_r+0xb0c>
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   24c18:	e51b0054 	ldr	r0, [fp, #-84]	; 0x54
   24c1c:	e51b1074 	ldr	r1, [fp, #-116]	; 0x74
   24c20:	e51b205c 	ldr	r2, [fp, #-92]	; 0x5c
   24c24:	ebfff6ea 	bl	227d4 <memmove>
          goto split;
   24c28:	ea0000fd 	b	25024 <_realloc_r+0xb0c>
        }
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
   24c2c:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   24c30:	e3530000 	cmp	r3, #0
   24c34:	0a000078 	beq	24e1c <_realloc_r+0x904>
   24c38:	e51b2050 	ldr	r2, [fp, #-80]	; 0x50
   24c3c:	e51b300c 	ldr	r3, [fp, #-12]
   24c40:	e0823003 	add	r3, r2, r3
   24c44:	e1a02003 	mov	r2, r3
   24c48:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   24c4c:	e1520003 	cmp	r2, r3
   24c50:	ba000071 	blt	24e1c <_realloc_r+0x904>
      {
        unlink(prev, bck, fwd);
   24c54:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   24c58:	e593300c 	ldr	r3, [r3, #12]
   24c5c:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   24c60:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   24c64:	e5933008 	ldr	r3, [r3, #8]
   24c68:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   24c6c:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   24c70:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   24c74:	e583200c 	str	r2, [r3, #12]
   24c78:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   24c7c:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   24c80:	e5832008 	str	r2, [r3, #8]
        newp = prev;
   24c84:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   24c88:	e50b3008 	str	r3, [fp, #-8]
        newsize += prevsize;
   24c8c:	e51b200c 	ldr	r2, [fp, #-12]
   24c90:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   24c94:	e0823003 	add	r3, r2, r3
   24c98:	e50b300c 	str	r3, [fp, #-12]
        newmem = chunk2mem(newp);
   24c9c:	e51b3008 	ldr	r3, [fp, #-8]
   24ca0:	e2833008 	add	r3, r3, #8
   24ca4:	e50b3054 	str	r3, [fp, #-84]	; 0x54
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   24ca8:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   24cac:	e2433004 	sub	r3, r3, #4
   24cb0:	e50b3060 	str	r3, [fp, #-96]	; 0x60
   24cb4:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   24cb8:	e3530024 	cmp	r3, #36	; 0x24
   24cbc:	8a000051 	bhi	24e08 <_realloc_r+0x8f0>
   24cc0:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   24cc4:	e50b3028 	str	r3, [fp, #-40]	; 0x28
   24cc8:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   24ccc:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   24cd0:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   24cd4:	e3530013 	cmp	r3, #19
   24cd8:	9a000035 	bls	24db4 <_realloc_r+0x89c>
   24cdc:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   24ce0:	e2832004 	add	r2, r3, #4
   24ce4:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   24ce8:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   24cec:	e2821004 	add	r1, r2, #4
   24cf0:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   24cf4:	e5922000 	ldr	r2, [r2]
   24cf8:	e5832000 	str	r2, [r3]
   24cfc:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   24d00:	e2832004 	add	r2, r3, #4
   24d04:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   24d08:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   24d0c:	e2821004 	add	r1, r2, #4
   24d10:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   24d14:	e5922000 	ldr	r2, [r2]
   24d18:	e5832000 	str	r2, [r3]
   24d1c:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   24d20:	e353001b 	cmp	r3, #27
   24d24:	9a000022 	bls	24db4 <_realloc_r+0x89c>
   24d28:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   24d2c:	e2832004 	add	r2, r3, #4
   24d30:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   24d34:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   24d38:	e2821004 	add	r1, r2, #4
   24d3c:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   24d40:	e5922000 	ldr	r2, [r2]
   24d44:	e5832000 	str	r2, [r3]
   24d48:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   24d4c:	e2832004 	add	r2, r3, #4
   24d50:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   24d54:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   24d58:	e2821004 	add	r1, r2, #4
   24d5c:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   24d60:	e5922000 	ldr	r2, [r2]
   24d64:	e5832000 	str	r2, [r3]
   24d68:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   24d6c:	e3530023 	cmp	r3, #35	; 0x23
   24d70:	9a00000f 	bls	24db4 <_realloc_r+0x89c>
   24d74:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   24d78:	e2832004 	add	r2, r3, #4
   24d7c:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   24d80:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   24d84:	e2821004 	add	r1, r2, #4
   24d88:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   24d8c:	e5922000 	ldr	r2, [r2]
   24d90:	e5832000 	str	r2, [r3]
   24d94:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   24d98:	e2832004 	add	r2, r3, #4
   24d9c:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   24da0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   24da4:	e2821004 	add	r1, r2, #4
   24da8:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   24dac:	e5922000 	ldr	r2, [r2]
   24db0:	e5832000 	str	r2, [r3]
   24db4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   24db8:	e2832004 	add	r2, r3, #4
   24dbc:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   24dc0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   24dc4:	e2821004 	add	r1, r2, #4
   24dc8:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   24dcc:	e5922000 	ldr	r2, [r2]
   24dd0:	e5832000 	str	r2, [r3]
   24dd4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   24dd8:	e2832004 	add	r2, r3, #4
   24ddc:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   24de0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   24de4:	e2821004 	add	r1, r2, #4
   24de8:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   24dec:	e5922000 	ldr	r2, [r2]
   24df0:	e5832000 	str	r2, [r3]
   24df4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   24df8:	e5932000 	ldr	r2, [r3]
   24dfc:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   24e00:	e5832000 	str	r2, [r3]
        goto split;
   24e04:	ea000086 	b	25024 <_realloc_r+0xb0c>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   24e08:	e51b0054 	ldr	r0, [fp, #-84]	; 0x54
   24e0c:	e51b1074 	ldr	r1, [fp, #-116]	; 0x74
   24e10:	e51b2060 	ldr	r2, [fp, #-96]	; 0x60
   24e14:	ebfff66e 	bl	227d4 <memmove>
        goto split;
   24e18:	ea000081 	b	25024 <_realloc_r+0xb0c>
      }
    }

    /* Must allocate */

    newmem = mALLOc (RCALL bytes);
   24e1c:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   24e20:	e51b1078 	ldr	r1, [fp, #-120]	; 0x78
   24e24:	ebffcb22 	bl	17ab4 <_malloc_r>
   24e28:	e50b0054 	str	r0, [fp, #-84]	; 0x54

    if (newmem == 0)  /* propagate failure */
   24e2c:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   24e30:	e3530000 	cmp	r3, #0
   24e34:	1a000003 	bne	24e48 <_realloc_r+0x930>
    {
      MALLOC_UNLOCK;
   24e38:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   24e3c:	ebffcecd 	bl	18978 <__malloc_unlock>
      return 0;
   24e40:	e3a03000 	mov	r3, #0
   24e44:	ea0000af 	b	25108 <_realloc_r+0xbf0>
    }

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
   24e48:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   24e4c:	e2433008 	sub	r3, r3, #8
   24e50:	e50b3008 	str	r3, [fp, #-8]
   24e54:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   24e58:	e5933004 	ldr	r3, [r3, #4]
   24e5c:	e3c33001 	bic	r3, r3, #1
   24e60:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   24e64:	e0823003 	add	r3, r2, r3
   24e68:	e51b2008 	ldr	r2, [fp, #-8]
   24e6c:	e1520003 	cmp	r2, r3
   24e70:	1a000008 	bne	24e98 <_realloc_r+0x980>
    {
      newsize += chunksize(newp);
   24e74:	e51b3008 	ldr	r3, [fp, #-8]
   24e78:	e5933004 	ldr	r3, [r3, #4]
   24e7c:	e3c33003 	bic	r3, r3, #3
   24e80:	e51b200c 	ldr	r2, [fp, #-12]
   24e84:	e0823003 	add	r3, r2, r3
   24e88:	e50b300c 	str	r3, [fp, #-12]
      newp = oldp;
   24e8c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   24e90:	e50b3008 	str	r3, [fp, #-8]
      goto split;
   24e94:	ea000062 	b	25024 <_realloc_r+0xb0c>
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   24e98:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   24e9c:	e2433004 	sub	r3, r3, #4
   24ea0:	e50b3064 	str	r3, [fp, #-100]	; 0x64
   24ea4:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   24ea8:	e3530024 	cmp	r3, #36	; 0x24
   24eac:	8a000051 	bhi	24ff8 <_realloc_r+0xae0>
   24eb0:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   24eb4:	e50b3030 	str	r3, [fp, #-48]	; 0x30
   24eb8:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   24ebc:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   24ec0:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   24ec4:	e3530013 	cmp	r3, #19
   24ec8:	9a000035 	bls	24fa4 <_realloc_r+0xa8c>
   24ecc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   24ed0:	e2832004 	add	r2, r3, #4
   24ed4:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   24ed8:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   24edc:	e2821004 	add	r1, r2, #4
   24ee0:	e50b1030 	str	r1, [fp, #-48]	; 0x30
   24ee4:	e5922000 	ldr	r2, [r2]
   24ee8:	e5832000 	str	r2, [r3]
   24eec:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   24ef0:	e2832004 	add	r2, r3, #4
   24ef4:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   24ef8:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   24efc:	e2821004 	add	r1, r2, #4
   24f00:	e50b1030 	str	r1, [fp, #-48]	; 0x30
   24f04:	e5922000 	ldr	r2, [r2]
   24f08:	e5832000 	str	r2, [r3]
   24f0c:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   24f10:	e353001b 	cmp	r3, #27
   24f14:	9a000022 	bls	24fa4 <_realloc_r+0xa8c>
   24f18:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   24f1c:	e2832004 	add	r2, r3, #4
   24f20:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   24f24:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   24f28:	e2821004 	add	r1, r2, #4
   24f2c:	e50b1030 	str	r1, [fp, #-48]	; 0x30
   24f30:	e5922000 	ldr	r2, [r2]
   24f34:	e5832000 	str	r2, [r3]
   24f38:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   24f3c:	e2832004 	add	r2, r3, #4
   24f40:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   24f44:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   24f48:	e2821004 	add	r1, r2, #4
   24f4c:	e50b1030 	str	r1, [fp, #-48]	; 0x30
   24f50:	e5922000 	ldr	r2, [r2]
   24f54:	e5832000 	str	r2, [r3]
   24f58:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   24f5c:	e3530023 	cmp	r3, #35	; 0x23
   24f60:	9a00000f 	bls	24fa4 <_realloc_r+0xa8c>
   24f64:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   24f68:	e2832004 	add	r2, r3, #4
   24f6c:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   24f70:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   24f74:	e2821004 	add	r1, r2, #4
   24f78:	e50b1030 	str	r1, [fp, #-48]	; 0x30
   24f7c:	e5922000 	ldr	r2, [r2]
   24f80:	e5832000 	str	r2, [r3]
   24f84:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   24f88:	e2832004 	add	r2, r3, #4
   24f8c:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   24f90:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   24f94:	e2821004 	add	r1, r2, #4
   24f98:	e50b1030 	str	r1, [fp, #-48]	; 0x30
   24f9c:	e5922000 	ldr	r2, [r2]
   24fa0:	e5832000 	str	r2, [r3]
   24fa4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   24fa8:	e2832004 	add	r2, r3, #4
   24fac:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   24fb0:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   24fb4:	e2821004 	add	r1, r2, #4
   24fb8:	e50b1030 	str	r1, [fp, #-48]	; 0x30
   24fbc:	e5922000 	ldr	r2, [r2]
   24fc0:	e5832000 	str	r2, [r3]
   24fc4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   24fc8:	e2832004 	add	r2, r3, #4
   24fcc:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   24fd0:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   24fd4:	e2821004 	add	r1, r2, #4
   24fd8:	e50b1030 	str	r1, [fp, #-48]	; 0x30
   24fdc:	e5922000 	ldr	r2, [r2]
   24fe0:	e5832000 	str	r2, [r3]
   24fe4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   24fe8:	e5932000 	ldr	r2, [r3]
   24fec:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   24ff0:	e5832000 	str	r2, [r3]
   24ff4:	ea000003 	b	25008 <_realloc_r+0xaf0>
   24ff8:	e51b0054 	ldr	r0, [fp, #-84]	; 0x54
   24ffc:	e51b1074 	ldr	r1, [fp, #-116]	; 0x74
   25000:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
   25004:	ebfff5f2 	bl	227d4 <memmove>
    fREe(RCALL oldmem);
   25008:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   2500c:	e51b1074 	ldr	r1, [fp, #-116]	; 0x74
   25010:	ebffc61e 	bl	16890 <_free_r>
    MALLOC_UNLOCK;
   25014:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   25018:	ebffce56 	bl	18978 <__malloc_unlock>
    return newmem;
   2501c:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   25020:	ea000038 	b	25108 <_realloc_r+0xbf0>
  }


 split:  /* split off extra room in old or expanded chunk */

  remainder_size = long_sub_size_t(newsize, nb);
   25024:	e51b200c 	ldr	r2, [fp, #-12]
   25028:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   2502c:	e0633002 	rsb	r3, r3, r2
   25030:	e50b3068 	str	r3, [fp, #-104]	; 0x68

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
   25034:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   25038:	e353000f 	cmp	r3, #15
   2503c:	9a00001d 	bls	250b8 <_realloc_r+0xba0>
  {
    remainder = chunk_at_offset(newp, nb);
   25040:	e51b2008 	ldr	r2, [fp, #-8]
   25044:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   25048:	e0823003 	add	r3, r2, r3
   2504c:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
    set_head_size(newp, nb);
   25050:	e51b3008 	ldr	r3, [fp, #-8]
   25054:	e5933004 	ldr	r3, [r3, #4]
   25058:	e2032001 	and	r2, r3, #1
   2505c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   25060:	e1822003 	orr	r2, r2, r3
   25064:	e51b3008 	ldr	r3, [fp, #-8]
   25068:	e5832004 	str	r2, [r3, #4]
    set_head(remainder, remainder_size | PREV_INUSE);
   2506c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   25070:	e3832001 	orr	r2, r3, #1
   25074:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   25078:	e5832004 	str	r2, [r3, #4]
    set_inuse_bit_at_offset(remainder, remainder_size);
   2507c:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
   25080:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   25084:	e0823003 	add	r3, r2, r3
   25088:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   2508c:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   25090:	e0812002 	add	r2, r1, r2
   25094:	e5922004 	ldr	r2, [r2, #4]
   25098:	e3822001 	orr	r2, r2, #1
   2509c:	e5832004 	str	r2, [r3, #4]
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
   250a0:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   250a4:	e2833008 	add	r3, r3, #8
   250a8:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   250ac:	e1a01003 	mov	r1, r3
   250b0:	ebffc5f6 	bl	16890 <_free_r>
   250b4:	ea00000f 	b	250f8 <_realloc_r+0xbe0>
  }
  else
  {
    set_head_size(newp, newsize);
   250b8:	e51b3008 	ldr	r3, [fp, #-8]
   250bc:	e5933004 	ldr	r3, [r3, #4]
   250c0:	e2032001 	and	r2, r3, #1
   250c4:	e51b300c 	ldr	r3, [fp, #-12]
   250c8:	e1822003 	orr	r2, r2, r3
   250cc:	e51b3008 	ldr	r3, [fp, #-8]
   250d0:	e5832004 	str	r2, [r3, #4]
    set_inuse_bit_at_offset(newp, newsize);
   250d4:	e51b2008 	ldr	r2, [fp, #-8]
   250d8:	e51b300c 	ldr	r3, [fp, #-12]
   250dc:	e0823003 	add	r3, r2, r3
   250e0:	e51b1008 	ldr	r1, [fp, #-8]
   250e4:	e51b200c 	ldr	r2, [fp, #-12]
   250e8:	e0812002 	add	r2, r1, r2
   250ec:	e5922004 	ldr	r2, [r2, #4]
   250f0:	e3822001 	orr	r2, r2, #1
   250f4:	e5832004 	str	r2, [r3, #4]
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
   250f8:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   250fc:	ebffce1d 	bl	18978 <__malloc_unlock>
  return chunk2mem(newp);
   25100:	e51b3008 	ldr	r3, [fp, #-8]
   25104:	e2833008 	add	r3, r3, #8

#endif /* MALLOC_PROVIDED */
}
   25108:	e1a00003 	mov	r0, r3
   2510c:	e24bd004 	sub	sp, fp, #4
   25110:	e8bd4800 	pop	{fp, lr}
   25114:	e12fff1e 	bx	lr
   25118:	0003e468 	.word	0x0003e468

0002511c <cleanup_glue>:

void
_DEFUN (cleanup_glue, (ptr, glue),
     struct _reent *ptr _AND
     struct _glue *glue)
{
   2511c:	e92d4800 	push	{fp, lr}
   25120:	e28db004 	add	fp, sp, #4
   25124:	e24dd008 	sub	sp, sp, #8
   25128:	e50b0008 	str	r0, [fp, #-8]
   2512c:	e50b100c 	str	r1, [fp, #-12]
  /* Have to reclaim these in reverse order: */
  if (glue->_next)
   25130:	e51b300c 	ldr	r3, [fp, #-12]
   25134:	e5933000 	ldr	r3, [r3]
   25138:	e3530000 	cmp	r3, #0
   2513c:	0a000004 	beq	25154 <cleanup_glue+0x38>
    cleanup_glue (ptr, glue->_next);
   25140:	e51b300c 	ldr	r3, [fp, #-12]
   25144:	e5933000 	ldr	r3, [r3]
   25148:	e51b0008 	ldr	r0, [fp, #-8]
   2514c:	e1a01003 	mov	r1, r3
   25150:	ebfffff1 	bl	2511c <cleanup_glue>

  _free_r (ptr, glue);
   25154:	e51b0008 	ldr	r0, [fp, #-8]
   25158:	e51b100c 	ldr	r1, [fp, #-12]
   2515c:	ebffc5cb 	bl	16890 <_free_r>
}
   25160:	e24bd004 	sub	sp, fp, #4
   25164:	e8bd4800 	pop	{fp, lr}
   25168:	e12fff1e 	bx	lr

0002516c <_reclaim_reent>:

void
_DEFUN (_reclaim_reent, (ptr),
     struct _reent *ptr)
{
   2516c:	e92d4800 	push	{fp, lr}
   25170:	e28db004 	add	fp, sp, #4
   25174:	e24dd020 	sub	sp, sp, #32
   25178:	e50b0020 	str	r0, [fp, #-32]
  if (ptr != _impure_ptr)
   2517c:	e59f31a8 	ldr	r3, [pc, #424]	; 2532c <_reclaim_reent+0x1c0>
   25180:	e5933000 	ldr	r3, [r3]
   25184:	e51b2020 	ldr	r2, [fp, #-32]
   25188:	e1520003 	cmp	r2, r3
   2518c:	0a000063 	beq	25320 <_reclaim_reent+0x1b4>
      /* used by mprec routines. */
#ifdef _REENT_SMALL
      if (ptr->_mp)	/* don't bother allocating it! */
      {
#endif
      if (_REENT_MP_FREELIST(ptr))
   25190:	e51b3020 	ldr	r3, [fp, #-32]
   25194:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
   25198:	e3530000 	cmp	r3, #0
   2519c:	0a000020 	beq	25224 <_reclaim_reent+0xb8>
	{
	  int i;
	  for (i = 0; i < _Kmax; i++) 
   251a0:	e3a03000 	mov	r3, #0
   251a4:	e50b3008 	str	r3, [fp, #-8]
   251a8:	ea000015 	b	25204 <_reclaim_reent+0x98>
	    {
	      struct _Bigint *thisone, *nextone;
	
	      nextone = _REENT_MP_FREELIST(ptr)[i];
   251ac:	e51b3020 	ldr	r3, [fp, #-32]
   251b0:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
   251b4:	e51b3008 	ldr	r3, [fp, #-8]
   251b8:	e1a03103 	lsl	r3, r3, #2
   251bc:	e0823003 	add	r3, r2, r3
   251c0:	e5933000 	ldr	r3, [r3]
   251c4:	e50b300c 	str	r3, [fp, #-12]
	      while (nextone)
   251c8:	ea000007 	b	251ec <_reclaim_reent+0x80>
		{
		  thisone = nextone;
   251cc:	e51b300c 	ldr	r3, [fp, #-12]
   251d0:	e50b3014 	str	r3, [fp, #-20]
		  nextone = nextone->_next;
   251d4:	e51b300c 	ldr	r3, [fp, #-12]
   251d8:	e5933000 	ldr	r3, [r3]
   251dc:	e50b300c 	str	r3, [fp, #-12]
		  _free_r (ptr, thisone);
   251e0:	e51b0020 	ldr	r0, [fp, #-32]
   251e4:	e51b1014 	ldr	r1, [fp, #-20]
   251e8:	ebffc5a8 	bl	16890 <_free_r>
	  for (i = 0; i < _Kmax; i++) 
	    {
	      struct _Bigint *thisone, *nextone;
	
	      nextone = _REENT_MP_FREELIST(ptr)[i];
	      while (nextone)
   251ec:	e51b300c 	ldr	r3, [fp, #-12]
   251f0:	e3530000 	cmp	r3, #0
   251f4:	1afffff4 	bne	251cc <_reclaim_reent+0x60>
      {
#endif
      if (_REENT_MP_FREELIST(ptr))
	{
	  int i;
	  for (i = 0; i < _Kmax; i++) 
   251f8:	e51b3008 	ldr	r3, [fp, #-8]
   251fc:	e2833001 	add	r3, r3, #1
   25200:	e50b3008 	str	r3, [fp, #-8]
   25204:	e51b3008 	ldr	r3, [fp, #-8]
   25208:	e353001f 	cmp	r3, #31
   2520c:	9affffe6 	bls	251ac <_reclaim_reent+0x40>
		  nextone = nextone->_next;
		  _free_r (ptr, thisone);
		}
	    }    

	  _free_r (ptr, _REENT_MP_FREELIST(ptr));
   25210:	e51b3020 	ldr	r3, [fp, #-32]
   25214:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
   25218:	e51b0020 	ldr	r0, [fp, #-32]
   2521c:	e1a01003 	mov	r1, r3
   25220:	ebffc59a 	bl	16890 <_free_r>
	}
      if (_REENT_MP_RESULT(ptr))
   25224:	e51b3020 	ldr	r3, [fp, #-32]
   25228:	e5933040 	ldr	r3, [r3, #64]	; 0x40
   2522c:	e3530000 	cmp	r3, #0
   25230:	0a000004 	beq	25248 <_reclaim_reent+0xdc>
	_free_r (ptr, _REENT_MP_RESULT(ptr));
   25234:	e51b3020 	ldr	r3, [fp, #-32]
   25238:	e5933040 	ldr	r3, [r3, #64]	; 0x40
   2523c:	e51b0020 	ldr	r0, [fp, #-32]
   25240:	e1a01003 	mov	r1, r3
   25244:	ebffc591 	bl	16890 <_free_r>
      /* atexit stuff */
# ifdef _REENT_SMALL
      if (ptr->_atexit && ptr->_atexit->_on_exit_args_ptr)
	_free_r (ptr, ptr->_atexit->_on_exit_args_ptr);
# else
      if ((ptr->_atexit) && (ptr->_atexit != &ptr->_atexit0))
   25248:	e51b3020 	ldr	r3, [fp, #-32]
   2524c:	e5933148 	ldr	r3, [r3, #328]	; 0x148
   25250:	e3530000 	cmp	r3, #0
   25254:	0a000016 	beq	252b4 <_reclaim_reent+0x148>
   25258:	e51b3020 	ldr	r3, [fp, #-32]
   2525c:	e5932148 	ldr	r2, [r3, #328]	; 0x148
   25260:	e51b3020 	ldr	r3, [fp, #-32]
   25264:	e2833f53 	add	r3, r3, #332	; 0x14c
   25268:	e1520003 	cmp	r2, r3
   2526c:	0a000010 	beq	252b4 <_reclaim_reent+0x148>
	{
	  struct _atexit *p, *q;
	  for (p = ptr->_atexit; p != &ptr->_atexit0;)
   25270:	e51b3020 	ldr	r3, [fp, #-32]
   25274:	e5933148 	ldr	r3, [r3, #328]	; 0x148
   25278:	e50b3010 	str	r3, [fp, #-16]
   2527c:	ea000007 	b	252a0 <_reclaim_reent+0x134>
	    {
	      q = p;
   25280:	e51b3010 	ldr	r3, [fp, #-16]
   25284:	e50b3018 	str	r3, [fp, #-24]
	      p = p->_next;
   25288:	e51b3010 	ldr	r3, [fp, #-16]
   2528c:	e5933000 	ldr	r3, [r3]
   25290:	e50b3010 	str	r3, [fp, #-16]
	      _free_r (ptr, q);
   25294:	e51b0020 	ldr	r0, [fp, #-32]
   25298:	e51b1018 	ldr	r1, [fp, #-24]
   2529c:	ebffc57b 	bl	16890 <_free_r>
	_free_r (ptr, ptr->_atexit->_on_exit_args_ptr);
# else
      if ((ptr->_atexit) && (ptr->_atexit != &ptr->_atexit0))
	{
	  struct _atexit *p, *q;
	  for (p = ptr->_atexit; p != &ptr->_atexit0;)
   252a0:	e51b3020 	ldr	r3, [fp, #-32]
   252a4:	e2832f53 	add	r2, r3, #332	; 0x14c
   252a8:	e51b3010 	ldr	r3, [fp, #-16]
   252ac:	e1520003 	cmp	r2, r3
   252b0:	1afffff2 	bne	25280 <_reclaim_reent+0x114>
	    }
	}
# endif
#endif

      if (ptr->_cvtbuf)
   252b4:	e51b3020 	ldr	r3, [fp, #-32]
   252b8:	e5933054 	ldr	r3, [r3, #84]	; 0x54
   252bc:	e3530000 	cmp	r3, #0
   252c0:	0a000004 	beq	252d8 <_reclaim_reent+0x16c>
	_free_r (ptr, ptr->_cvtbuf);
   252c4:	e51b3020 	ldr	r3, [fp, #-32]
   252c8:	e5933054 	ldr	r3, [r3, #84]	; 0x54
   252cc:	e51b0020 	ldr	r0, [fp, #-32]
   252d0:	e1a01003 	mov	r1, r3
   252d4:	ebffc56d 	bl	16890 <_free_r>
	   do it safely considering that a signal may be delivered immediately
	   after the free?
	  if (ptr->_sig_func)
	_free_r (ptr, ptr->_sig_func);*/

      if (ptr->__sdidinit)
   252d8:	e51b3020 	ldr	r3, [fp, #-32]
   252dc:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   252e0:	e3530000 	cmp	r3, #0
   252e4:	0a00000d 	beq	25320 <_reclaim_reent+0x1b4>
	{
	  /* cleanup won't reclaim memory 'coz usually it's run
	     before the program exits, and who wants to wait for that? */
	  ptr->__cleanup (ptr);
   252e8:	e51b3020 	ldr	r3, [fp, #-32]
   252ec:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
   252f0:	e51b0020 	ldr	r0, [fp, #-32]
   252f4:	e1a0e00f 	mov	lr, pc
   252f8:	e12fff13 	bx	r3

	  if (ptr->__sglue._next)
   252fc:	e51b3020 	ldr	r3, [fp, #-32]
   25300:	e59332e0 	ldr	r3, [r3, #736]	; 0x2e0
   25304:	e3530000 	cmp	r3, #0
   25308:	0a000004 	beq	25320 <_reclaim_reent+0x1b4>
	    cleanup_glue (ptr, ptr->__sglue._next);
   2530c:	e51b3020 	ldr	r3, [fp, #-32]
   25310:	e59332e0 	ldr	r3, [r3, #736]	; 0x2e0
   25314:	e51b0020 	ldr	r0, [fp, #-32]
   25318:	e1a01003 	mov	r1, r3
   2531c:	ebffff7e 	bl	2511c <cleanup_glue>
	}

      /* Malloc memory not reclaimed; no good way to return memory anyway. */

    }
}
   25320:	e24bd004 	sub	sp, fp, #4
   25324:	e8bd4800 	pop	{fp, lr}
   25328:	e12fff1e 	bx	lr
   2532c:	0003e460 	.word	0x0003e460

00025330 <sbrk>:
extern uint8_t * OS_USER_HEAP_ADDRESS;

void *
_DEFUN (_sbrk, (incr),
     int incr)
{ 
   25330:	e92d4800 	push	{fp, lr}
   25334:	e28db004 	add	fp, sp, #4
   25338:	e24dd010 	sub	sp, sp, #16
   2533c:	e50b0010 	str	r0, [fp, #-16]
  uint8_t * ptr_start = NULL;
   25340:	e3a03000 	mov	r3, #0
   25344:	e50b3008 	str	r3, [fp, #-8]
 
  cpu_dcache_invalidate((void*)&OS_USER_HEAP_ADDRESS, sizeof(uint8_t*));
   25348:	e59f0044 	ldr	r0, [pc, #68]	; 25394 <sbrk+0x64>
   2534c:	e3a01004 	mov	r1, #4
   25350:	ebffacba 	bl	10640 <cpu_dcache_invalidate>
  ptr_start = (uint8_t *)(((uint32_t)(OS_USER_HEAP_ADDRESS + 8)) & 0xFFFFFFF8);
   25354:	e59f3038 	ldr	r3, [pc, #56]	; 25394 <sbrk+0x64>
   25358:	e5933000 	ldr	r3, [r3]
   2535c:	e2833008 	add	r3, r3, #8
   25360:	e3c33007 	bic	r3, r3, #7
   25364:	e50b3008 	str	r3, [fp, #-8]
  OS_USER_HEAP_ADDRESS = OS_USER_HEAP_ADDRESS + incr; 
   25368:	e59f3024 	ldr	r3, [pc, #36]	; 25394 <sbrk+0x64>
   2536c:	e5932000 	ldr	r2, [r3]
   25370:	e51b3010 	ldr	r3, [fp, #-16]
   25374:	e0822003 	add	r2, r2, r3
   25378:	e59f3014 	ldr	r3, [pc, #20]	; 25394 <sbrk+0x64>
   2537c:	e5832000 	str	r2, [r3]

  return ptr_start;
   25380:	e51b3008 	ldr	r3, [fp, #-8]
} 
   25384:	e1a00003 	mov	r0, r3
   25388:	e24bd004 	sub	sp, fp, #4
   2538c:	e8bd4800 	pop	{fp, lr}
   25390:	e12fff1e 	bx	lr
   25394:	0003e93c 	.word	0x0003e93c

00025398 <__fpclassifyd>:

#include "fdlibm.h"

int
__fpclassifyd (double x)
{
   25398:	e92d0810 	push	{r4, fp}
   2539c:	e28db004 	add	fp, sp, #4
   253a0:	e24dd018 	sub	sp, sp, #24
   253a4:	e50b001c 	str	r0, [fp, #-28]
   253a8:	e50b1018 	str	r1, [fp, #-24]
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);
   253ac:	e24b401c 	sub	r4, fp, #28
   253b0:	e8940018 	ldm	r4, {r3, r4}
   253b4:	e50b3014 	str	r3, [fp, #-20]
   253b8:	e50b4010 	str	r4, [fp, #-16]
   253bc:	e51b3010 	ldr	r3, [fp, #-16]
   253c0:	e50b3008 	str	r3, [fp, #-8]
   253c4:	e51b3014 	ldr	r3, [fp, #-20]
   253c8:	e50b300c 	str	r3, [fp, #-12]

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
   253cc:	e51b3008 	ldr	r3, [fp, #-8]
   253d0:	e3530000 	cmp	r3, #0
   253d4:	1a000002 	bne	253e4 <__fpclassifyd+0x4c>
   253d8:	e51b300c 	ldr	r3, [fp, #-12]
   253dc:	e3530000 	cmp	r3, #0
   253e0:	0a000005 	beq	253fc <__fpclassifyd+0x64>
   253e4:	e51b3008 	ldr	r3, [fp, #-8]
   253e8:	e3530102 	cmp	r3, #-2147483648	; 0x80000000
   253ec:	1a000004 	bne	25404 <__fpclassifyd+0x6c>
      (msw == 0x80000000 && lsw == 0x00000000))
   253f0:	e51b300c 	ldr	r3, [fp, #-12]
   253f4:	e3530000 	cmp	r3, #0
   253f8:	1a000001 	bne	25404 <__fpclassifyd+0x6c>
    return FP_ZERO;
   253fc:	e3a03002 	mov	r3, #2
   25400:	ea00002b 	b	254b4 <__fpclassifyd+0x11c>
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
   25404:	e51b3008 	ldr	r3, [fp, #-8]
   25408:	e3530601 	cmp	r3, #1048576	; 0x100000
   2540c:	3a000003 	bcc	25420 <__fpclassifyd+0x88>
   25410:	e51b2008 	ldr	r2, [fp, #-8]
   25414:	e59f30a8 	ldr	r3, [pc, #168]	; 254c4 <__fpclassifyd+0x12c>
   25418:	e1520003 	cmp	r2, r3
   2541c:	9a000006 	bls	2543c <__fpclassifyd+0xa4>
   25420:	e51b2008 	ldr	r2, [fp, #-8]
   25424:	e59f309c 	ldr	r3, [pc, #156]	; 254c8 <__fpclassifyd+0x130>
   25428:	e1520003 	cmp	r2, r3
   2542c:	9a000004 	bls	25444 <__fpclassifyd+0xac>
           (msw >= 0x80100000 && msw <= 0xffefffff))
   25430:	e51b3008 	ldr	r3, [fp, #-8]
   25434:	e3730601 	cmn	r3, #1048576	; 0x100000
   25438:	2a000001 	bcs	25444 <__fpclassifyd+0xac>
    return FP_NORMAL;
   2543c:	e3a03004 	mov	r3, #4
   25440:	ea00001b 	b	254b4 <__fpclassifyd+0x11c>
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
   25444:	e51b3008 	ldr	r3, [fp, #-8]
   25448:	e3530601 	cmp	r3, #1048576	; 0x100000
   2544c:	3a000006 	bcc	2546c <__fpclassifyd+0xd4>
           (msw >= 0x80000000 && msw <= 0x800fffff))
   25450:	e51b3008 	ldr	r3, [fp, #-8]
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
   25454:	e3530000 	cmp	r3, #0
   25458:	aa000005 	bge	25474 <__fpclassifyd+0xdc>
           (msw >= 0x80000000 && msw <= 0x800fffff))
   2545c:	e51b2008 	ldr	r2, [fp, #-8]
   25460:	e59f3060 	ldr	r3, [pc, #96]	; 254c8 <__fpclassifyd+0x130>
   25464:	e1520003 	cmp	r2, r3
   25468:	8a000001 	bhi	25474 <__fpclassifyd+0xdc>
    /* zero is already handled above */
    return FP_SUBNORMAL;
   2546c:	e3a03003 	mov	r3, #3
   25470:	ea00000f 	b	254b4 <__fpclassifyd+0x11c>
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
   25474:	e51b2008 	ldr	r2, [fp, #-8]
   25478:	e59f304c 	ldr	r3, [pc, #76]	; 254cc <__fpclassifyd+0x134>
   2547c:	e1520003 	cmp	r2, r3
   25480:	1a000002 	bne	25490 <__fpclassifyd+0xf8>
   25484:	e51b300c 	ldr	r3, [fp, #-12]
   25488:	e3530000 	cmp	r3, #0
   2548c:	0a000005 	beq	254a8 <__fpclassifyd+0x110>
   25490:	e51b3008 	ldr	r3, [fp, #-8]
   25494:	e3730601 	cmn	r3, #1048576	; 0x100000
   25498:	1a000004 	bne	254b0 <__fpclassifyd+0x118>
           (msw == 0xfff00000 && lsw == 0x00000000))
   2549c:	e51b300c 	ldr	r3, [fp, #-12]
   254a0:	e3530000 	cmp	r3, #0
   254a4:	1a000001 	bne	254b0 <__fpclassifyd+0x118>
    return FP_INFINITE;
   254a8:	e3a03001 	mov	r3, #1
   254ac:	ea000000 	b	254b4 <__fpclassifyd+0x11c>
  else
    return FP_NAN;
   254b0:	e3a03000 	mov	r3, #0
}
   254b4:	e1a00003 	mov	r0, r3
   254b8:	e24bd004 	sub	sp, fp, #4
   254bc:	e8bd0810 	pop	{r4, fp}
   254c0:	e12fff1e 	bx	lr
   254c4:	7fefffff 	.word	0x7fefffff
   254c8:	800fffff 	.word	0x800fffff
   254cc:	7ff00000 	.word	0x7ff00000

000254d0 <frexp>:
	double frexp(double x, int *eptr)
#else
	double frexp(x, eptr)
	double x; int *eptr;
#endif
{
   254d0:	e92d4810 	push	{r4, fp, lr}
   254d4:	e28db008 	add	fp, sp, #8
   254d8:	e24dd03c 	sub	sp, sp, #60	; 0x3c
   254dc:	e50b003c 	str	r0, [fp, #-60]	; 0x3c
   254e0:	e50b1038 	str	r1, [fp, #-56]	; 0x38
   254e4:	e50b2040 	str	r2, [fp, #-64]	; 0x40
	__int32_t hx, ix, lx;
	EXTRACT_WORDS(hx,lx,x);
   254e8:	e24b403c 	sub	r4, fp, #60	; 0x3c
   254ec:	e8940018 	ldm	r4, {r3, r4}
   254f0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   254f4:	e50b4020 	str	r4, [fp, #-32]
   254f8:	e51b3020 	ldr	r3, [fp, #-32]
   254fc:	e50b3010 	str	r3, [fp, #-16]
   25500:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   25504:	e50b3018 	str	r3, [fp, #-24]
	ix = 0x7fffffff&hx;
   25508:	e51b3010 	ldr	r3, [fp, #-16]
   2550c:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   25510:	e50b3014 	str	r3, [fp, #-20]
	*eptr = 0;
   25514:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   25518:	e3a02000 	mov	r2, #0
   2551c:	e5832000 	str	r2, [r3]
	if(ix>=0x7ff00000||((ix|lx)==0)) return x;	/* 0,inf,nan */
   25520:	e51b2014 	ldr	r2, [fp, #-20]
   25524:	e59f310c 	ldr	r3, [pc, #268]	; 25638 <frexp+0x168>
   25528:	e1520003 	cmp	r2, r3
   2552c:	ca000004 	bgt	25544 <frexp+0x74>
   25530:	e51b2014 	ldr	r2, [fp, #-20]
   25534:	e51b3018 	ldr	r3, [fp, #-24]
   25538:	e1823003 	orr	r3, r2, r3
   2553c:	e3530000 	cmp	r3, #0
   25540:	1a000002 	bne	25550 <frexp+0x80>
   25544:	e24b403c 	sub	r4, fp, #60	; 0x3c
   25548:	e8940018 	ldm	r4, {r3, r4}
   2554c:	ea000034 	b	25624 <frexp+0x154>
	if (ix<0x00100000) {		/* subnormal */
   25550:	e51b3014 	ldr	r3, [fp, #-20]
   25554:	e3530601 	cmp	r3, #1048576	; 0x100000
   25558:	aa000016 	bge	255b8 <frexp+0xe8>
	    x *= two54;
   2555c:	e3a03000 	mov	r3, #0
   25560:	e59f40d4 	ldr	r4, [pc, #212]	; 2563c <frexp+0x16c>
   25564:	e24b103c 	sub	r1, fp, #60	; 0x3c
   25568:	e8910003 	ldm	r1, {r0, r1}
   2556c:	e1a02003 	mov	r2, r3
   25570:	e1a03004 	mov	r3, r4
   25574:	ebffbd61 	bl	14b00 <__aeabi_dmul>
   25578:	e1a03000 	mov	r3, r0
   2557c:	e1a04001 	mov	r4, r1
   25580:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   25584:	e50b4038 	str	r4, [fp, #-56]	; 0x38
	    GET_HIGH_WORD(hx,x);
   25588:	e24b403c 	sub	r4, fp, #60	; 0x3c
   2558c:	e8940018 	ldm	r4, {r3, r4}
   25590:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   25594:	e50b4028 	str	r4, [fp, #-40]	; 0x28
   25598:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2559c:	e50b3010 	str	r3, [fp, #-16]
	    ix = hx&0x7fffffff;
   255a0:	e51b3010 	ldr	r3, [fp, #-16]
   255a4:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   255a8:	e50b3014 	str	r3, [fp, #-20]
	    *eptr = -54;
   255ac:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   255b0:	e3e02035 	mvn	r2, #53	; 0x35
   255b4:	e5832000 	str	r2, [r3]
	}
	*eptr += (ix>>20)-1022;
   255b8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   255bc:	e5932000 	ldr	r2, [r3]
   255c0:	e51b3014 	ldr	r3, [fp, #-20]
   255c4:	e1a03a43 	asr	r3, r3, #20
   255c8:	e2433fff 	sub	r3, r3, #1020	; 0x3fc
   255cc:	e2433002 	sub	r3, r3, #2
   255d0:	e0822003 	add	r2, r2, r3
   255d4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   255d8:	e5832000 	str	r2, [r3]
	hx = (hx&0x800fffff)|0x3fe00000;
   255dc:	e51b3010 	ldr	r3, [fp, #-16]
   255e0:	e3c3347f 	bic	r3, r3, #2130706432	; 0x7f000000
   255e4:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   255e8:	e38335ff 	orr	r3, r3, #1069547520	; 0x3fc00000
   255ec:	e3833602 	orr	r3, r3, #2097152	; 0x200000
   255f0:	e50b3010 	str	r3, [fp, #-16]
	SET_HIGH_WORD(x,hx);
   255f4:	e24b403c 	sub	r4, fp, #60	; 0x3c
   255f8:	e8940018 	ldm	r4, {r3, r4}
   255fc:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   25600:	e50b4030 	str	r4, [fp, #-48]	; 0x30
   25604:	e51b3010 	ldr	r3, [fp, #-16]
   25608:	e50b3030 	str	r3, [fp, #-48]	; 0x30
   2560c:	e24b4034 	sub	r4, fp, #52	; 0x34
   25610:	e8940018 	ldm	r4, {r3, r4}
   25614:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   25618:	e50b4038 	str	r4, [fp, #-56]	; 0x38
	return x;
   2561c:	e24b403c 	sub	r4, fp, #60	; 0x3c
   25620:	e8940018 	ldm	r4, {r3, r4}
}
   25624:	e1a00003 	mov	r0, r3
   25628:	e1a01004 	mov	r1, r4
   2562c:	e24bd008 	sub	sp, fp, #8
   25630:	e8bd4810 	pop	{r4, fp, lr}
   25634:	e12fff1e 	bx	lr
   25638:	7fefffff 	.word	0x7fefffff
   2563c:	43500000 	.word	0x43500000

00025640 <strcmp>:
#define magic2(REG) REG, lsl #7
#endif

        optpld  r0
        optpld  r1
        eor     r2, r0, r1
   25640:	e0202001 	eor	r2, r0, r1
        tst     r2, #3
   25644:	e3120003 	tst	r2, #3
        /* Strings not at same byte offset from a word boundary.  */
        bne     .Lstrcmp_unaligned
   25648:	1a000021 	bne	256d4 <strcmp+0x94>
        ands    r2, r0, #3
   2564c:	e2102003 	ands	r2, r0, #3
        bic     r0, r0, #3
   25650:	e3c00003 	bic	r0, r0, #3
        bic     r1, r1, #3
   25654:	e3c11003 	bic	r1, r1, #3
        ldr     ip, [r0], #4
   25658:	e490c004 	ldr	ip, [r0], #4
        it      eq
        ldreq   r3, [r1], #4
   2565c:	04913004 	ldreq	r3, [r1], #4
        beq     1f
   25660:	0a000006 	beq	25680 <strcmp+0x40>
        /* Although s1 and s2 have identical initial alignment, they are
        not currently word aligned.  Rather than comparing bytes,
	make sure that any bytes fetched from before the addressed
	bytes are forced to 0xff.  Then they will always compare
	equal.  */
        eor     r2, r2, #3
   25664:	e2222003 	eor	r2, r2, #3
        lsl     r2, r2, #3
   25668:	e1a02182 	lsl	r2, r2, #3
        mvn     r3, MSB
   2566c:	e3e034ff 	mvn	r3, #-16777216	; 0xff000000
        S2LOMEM        r2, r3, r2
   25670:	e1a02233 	lsr	r2, r3, r2
        ldr     r3, [r1], #4
   25674:	e4913004 	ldr	r3, [r1], #4
        orr     ip, ip, r2
   25678:	e18cc002 	orr	ip, ip, r2
        orr     r3, r3, r2
   2567c:	e1833002 	orr	r3, r3, r2
1:
#ifndef __thumb2__
              /* Load the 'magic' constant 0x01010101.  */
        str     r4, [sp, #-4]!
   25680:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
        mov     r4, #1
   25684:	e3a04001 	mov	r4, #1
        orr     r4, r4, r4, lsl #8
   25688:	e1844404 	orr	r4, r4, r4, lsl #8
        orr     r4, r4, r4, lsl #16
   2568c:	e1844804 	orr	r4, r4, r4, lsl #16
#endif
        .p2align        2
4:
        optpld  r0, #8
        optpld  r1, #8
        sub     r2, ip, magic1(r4)
   25690:	e04c2004 	sub	r2, ip, r4
        cmp     ip, r3
   25694:	e15c0003 	cmp	ip, r3
        itttt   eq
        /* check for any zero bytes in first word */
        biceq   r2, r2, ip
   25698:	01c2200c 	biceq	r2, r2, ip
        tsteq   r2, magic2(r4)
   2569c:	01120384 	tsteq	r2, r4, lsl #7
        ldreq   ip, [r0], #4
   256a0:	0490c004 	ldreq	ip, [r0], #4
        ldreq   r3, [r1], #4
   256a4:	04913004 	ldreq	r3, [r1], #4
        beq     4b
   256a8:	0afffff8 	beq	25690 <strcmp+0x50>
2:
        /* There's a zero or a different byte in the word */
        S2HIMEM  r0, ip, #24
   256ac:	e1a00c0c 	lsl	r0, ip, #24
        S2LOMEM  ip, ip, #8
   256b0:	e1a0c42c 	lsr	ip, ip, #8
        cmp     r0, #1
   256b4:	e3500001 	cmp	r0, #1
        it      cs
        cmpcs   r0, r3, S2HIMEM #24
   256b8:	21500c03 	cmpcs	r0, r3, lsl #24
        it      eq
        S2LOMEMEQ r3, r3, #8
   256bc:	01a03423 	lsreq	r3, r3, #8
        beq     2b
   256c0:	0afffff9 	beq	256ac <strcmp+0x6c>
        little-endian case we can't just shift the interesting bits
        up.  */
#ifdef __ARMEB__
        sub     r0, r0, r3, lsr #24
#else
        and     r3, r3, #255
   256c4:	e20330ff 	and	r3, r3, #255	; 0xff
#ifdef __thumb2__
        /* No RSB instruction in Thumb2 */
        lsr     r0, r0, #24
        sub     r0, r0, r3
#else
        rsb     r0, r3, r0, lsr #24
   256c8:	e0630c20 	rsb	r0, r3, r0, lsr #24
#endif
#endif
#ifndef __thumb2__
        ldr     r4, [sp], #4
   256cc:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
#endif
        RETURN
   256d0:	e12fff1e 	bx	lr
        t1  .req ip
        @ r3 is scratch

        /* First of all, compare bytes until wp1(sp1) is word-aligned. */
1:
        tst     wp1, #3
   256d4:	e3100003 	tst	r0, #3
        beq     2f
   256d8:	0a000006 	beq	256f8 <strcmp+0xb8>
        ldrb    r2, [wp1], #1
   256dc:	e4d02001 	ldrb	r2, [r0], #1
        ldrb    r3, [wp2], #1
   256e0:	e4d13001 	ldrb	r3, [r1], #1
        cmp     r2, #1
   256e4:	e3520001 	cmp	r2, #1
        it      cs
        cmpcs   r2, r3
   256e8:	21520003 	cmpcs	r2, r3
        beq     1b
   256ec:	0afffff8 	beq	256d4 <strcmp+0x94>
        sub     r0, r2, r3
   256f0:	e0420003 	sub	r0, r2, r3
        RETURN
   256f4:	e12fff1e 	bx	lr

2:
        str     r5, [sp, #-4]!
   256f8:	e52d5004 	push	{r5}		; (str r5, [sp, #-4]!)
        str     r4, [sp, #-4]!
   256fc:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
        //stmfd   sp!, {r4, r5}
        mov     b1, #1
   25700:	e3a02001 	mov	r2, #1
        orr     b1, b1, b1, lsl #8
   25704:	e1822402 	orr	r2, r2, r2, lsl #8
        orr     b1, b1, b1, lsl #16
   25708:	e1822802 	orr	r2, r2, r2, lsl #16

        and     t1, wp2, #3
   2570c:	e201c003 	and	ip, r1, #3
        bic     wp2, wp2, #3
   25710:	e3c11003 	bic	r1, r1, #3
        ldr     w1, [wp1], #4
   25714:	e4904004 	ldr	r4, [r0], #4
        ldr     w2, [wp2], #4
   25718:	e4915004 	ldr	r5, [r1], #4
        cmp     t1, #2
   2571c:	e35c0002 	cmp	ip, #2
        beq     2f
   25720:	0a000017 	beq	25784 <strcmp+0x144>
        bhi     3f
   25724:	8a00002d 	bhi	257e0 <strcmp+0x1a0>

        /* Critical inner Loop: Block with 3 bytes initial overlap */
        .p2align        2
1:
        bic     t1, w1, MSB
   25728:	e3c4c4ff 	bic	ip, r4, #-16777216	; 0xff000000
        cmp     t1, w2, S2LOMEM #8
   2572c:	e15c0425 	cmp	ip, r5, lsr #8
        sub     r3, w1, b1
   25730:	e0443002 	sub	r3, r4, r2
        bic     r3, r3, w1
   25734:	e1c33004 	bic	r3, r3, r4
        bne     4f
   25738:	1a000007 	bne	2575c <strcmp+0x11c>
        ands    r3, r3, b1, lsl #7
   2573c:	e0133382 	ands	r3, r3, r2, lsl #7
        it      eq
        ldreq   w2, [wp2], #4
   25740:	04915004 	ldreq	r5, [r1], #4
        bne     5f
   25744:	1a000006 	bne	25764 <strcmp+0x124>
        eor     t1, t1, w1
   25748:	e02cc004 	eor	ip, ip, r4
        cmp     t1, w2, S2HIMEM #24
   2574c:	e15c0c05 	cmp	ip, r5, lsl #24
        bne     6f
   25750:	1a000008 	bne	25778 <strcmp+0x138>
        ldr     w1, [wp1], #4
   25754:	e4904004 	ldr	r4, [r0], #4
        b       1b
   25758:	eafffff2 	b	25728 <strcmp+0xe8>
4:
        S2LOMEM        w2, w2, #8
   2575c:	e1a05425 	lsr	r5, r5, #8
        b       8f
   25760:	ea000037 	b	25844 <strcmp+0x204>
        itt     ne
        tstne   w1, #0x00ff0000
        tstne   w1, #0x0000ff00
        beq     7f
#else
        bics    r3, r3, #0xff000000
   25764:	e3d334ff 	bics	r3, r3, #-16777216	; 0xff000000
        bne     7f
   25768:	1a000031 	bne	25834 <strcmp+0x1f4>
#endif
        ldrb    w2, [wp2]
   2576c:	e5d15000 	ldrb	r5, [r1]
        S2LOMEM  t1, w1, #24
   25770:	e1a0cc24 	lsr	ip, r4, #24
#ifdef __ARMEB__
        lsl     w2, w2, #24
#endif
        b       8f
   25774:	ea000032 	b	25844 <strcmp+0x204>

6:
        S2LOMEM  t1, w1, #24
   25778:	e1a0cc24 	lsr	ip, r4, #24
        and     w2, w2, LSB
   2577c:	e20550ff 	and	r5, r5, #255	; 0xff
        b       8f
   25780:	ea00002f 	b	25844 <strcmp+0x204>

        /* Critical inner Loop: Block with 2 bytes initial overlap */
        .p2align        2
2:
        S2HIMEM  t1, w1, #16
   25784:	e1a0c804 	lsl	ip, r4, #16
        sub     r3, w1, b1
   25788:	e0443002 	sub	r3, r4, r2
        S2LOMEM  t1, t1, #16
   2578c:	e1a0c82c 	lsr	ip, ip, #16
        bic     r3, r3, w1
   25790:	e1c33004 	bic	r3, r3, r4
        cmp     t1, w2, S2LOMEM #16
   25794:	e15c0825 	cmp	ip, r5, lsr #16
        bne     4f
   25798:	1a00000e 	bne	257d8 <strcmp+0x198>
        ands    r3, r3, b1, lsl #7
   2579c:	e0133382 	ands	r3, r3, r2, lsl #7
        it      eq
        ldreq   w2, [wp2], #4
   257a0:	04915004 	ldreq	r5, [r1], #4
        bne     5f
   257a4:	1a000004 	bne	257bc <strcmp+0x17c>
        eor     t1, t1, w1
   257a8:	e02cc004 	eor	ip, ip, r4
        cmp     t1, w2, S2HIMEM #16
   257ac:	e15c0805 	cmp	ip, r5, lsl #16
        bne     6f
   257b0:	1a000006 	bne	257d0 <strcmp+0x190>
        ldr     w1, [wp1], #4
   257b4:	e4904004 	ldr	r4, [r0], #4
        b       2b
   257b8:	eafffff1 	b	25784 <strcmp+0x144>
        tst     w1, #0xff000000
        it      ne
        tstne   w1, #0x00ff0000
        beq     7f
#else
        lsls    r3, r3, #16
   257bc:	e1b03803 	lsls	r3, r3, #16
        bne     7f
   257c0:	1a00001b 	bne	25834 <strcmp+0x1f4>
#endif
        ldrh    w2, [wp2]
   257c4:	e1d150b0 	ldrh	r5, [r1]
        S2LOMEM  t1, w1, #16
   257c8:	e1a0c824 	lsr	ip, r4, #16
#ifdef __ARMEB__
        lsl     w2, w2, #16
#endif
        b       8f
   257cc:	ea00001c 	b	25844 <strcmp+0x204>

6:
        S2HIMEM  w2, w2, #16
   257d0:	e1a05805 	lsl	r5, r5, #16
        S2LOMEM  t1, w1, #16
   257d4:	e1a0c824 	lsr	ip, r4, #16
4:
        S2LOMEM  w2, w2, #16
   257d8:	e1a05825 	lsr	r5, r5, #16
        b       8f
   257dc:	ea000018 	b	25844 <strcmp+0x204>

        /* Critical inner Loop: Block with 1 byte initial overlap */
        .p2align        2
3:
        and     t1, w1, LSB
   257e0:	e204c0ff 	and	ip, r4, #255	; 0xff
        cmp     t1, w2, S2LOMEM #24
   257e4:	e15c0c25 	cmp	ip, r5, lsr #24
        sub     r3, w1, b1
   257e8:	e0443002 	sub	r3, r4, r2
        bic     r3, r3, w1
   257ec:	e1c33004 	bic	r3, r3, r4
        bne     4f
   257f0:	1a000007 	bne	25814 <strcmp+0x1d4>
        ands    r3, r3, b1, lsl #7
   257f4:	e0133382 	ands	r3, r3, r2, lsl #7
        it      eq
        ldreq   w2, [wp2], #4
   257f8:	04915004 	ldreq	r5, [r1], #4
        bne     5f
   257fc:	1a000006 	bne	2581c <strcmp+0x1dc>
        eor     t1, t1, w1
   25800:	e02cc004 	eor	ip, ip, r4
        cmp     t1, w2, S2HIMEM #8
   25804:	e15c0405 	cmp	ip, r5, lsl #8
        bne     6f
   25808:	1a000006 	bne	25828 <strcmp+0x1e8>
        ldr     w1, [wp1], #4
   2580c:	e4904004 	ldr	r4, [r0], #4
        b       3b
   25810:	eafffff2 	b	257e0 <strcmp+0x1a0>
4:
        S2LOMEM  w2, w2, #24
   25814:	e1a05c25 	lsr	r5, r5, #24
        b       8f
   25818:	ea000009 	b	25844 <strcmp+0x204>
5:
        /* The syndrome value may contain false ones if the string ends
        with the bytes 0x01 0x00 */
        tst     w1, LSB
   2581c:	e31400ff 	tst	r4, #255	; 0xff
        beq     7f
   25820:	0a000003 	beq	25834 <strcmp+0x1f4>
        ldr     w2, [wp2], #4
   25824:	e4915004 	ldr	r5, [r1], #4
6:
        S2LOMEM  t1, w1, #8
   25828:	e1a0c424 	lsr	ip, r4, #8
        bic     w2, w2, MSB
   2582c:	e3c554ff 	bic	r5, r5, #-16777216	; 0xff000000
        b       8f
   25830:	ea000003 	b	25844 <strcmp+0x204>
7:
        mov     r0, #0
   25834:	e3a00000 	mov	r0, #0
        //ldmfd   sp!, {r4, r5}
        ldr     r4, [sp], #4
   25838:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
        ldr     r5, [sp], #4
   2583c:	e49d5004 	pop	{r5}		; (ldr r5, [sp], #4)
        RETURN
   25840:	e12fff1e 	bx	lr
8:
        and     r2, t1, LSB
   25844:	e20c20ff 	and	r2, ip, #255	; 0xff
        and     r0, w2, LSB
   25848:	e20500ff 	and	r0, r5, #255	; 0xff
        cmp     r0, #1
   2584c:	e3500001 	cmp	r0, #1
        it      cs
        cmpcs   r0, r2
   25850:	21500002 	cmpcs	r0, r2
        itt     eq
        S2LOMEMEQ        t1, t1, #8
   25854:	01a0c42c 	lsreq	ip, ip, #8
        S2LOMEMEQ        w2, w2, #8
   25858:	01a05425 	lsreq	r5, r5, #8
        beq     8b
   2585c:	0afffff8 	beq	25844 <strcmp+0x204>
        sub     r0, r2, r0
   25860:	e0420000 	sub	r0, r2, r0
        //ldmfd   sp!, {r4, r5}
        ldr     r4, [sp], #4
   25864:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
        ldr     r5, [sp], #4
   25868:	e49d5004 	pop	{r5}		; (ldr r5, [sp], #4)
        RETURN
   2586c:	e12fff1e 	bx	lr

00025870 <strncpy>:
char *
_DEFUN (strncpy, (dst0, src0),
	char *__restrict dst0 _AND
	_CONST char *__restrict src0 _AND
	size_t count)
{
   25870:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   25874:	e28db000 	add	fp, sp, #0
   25878:	e24dd024 	sub	sp, sp, #36	; 0x24
   2587c:	e50b0018 	str	r0, [fp, #-24]
   25880:	e50b101c 	str	r1, [fp, #-28]
   25884:	e50b2020 	str	r2, [fp, #-32]
  while (count-- > 0)
    *dscan++ = '\0';

  return dst0;
#else
  char *dst = dst0;
   25888:	e51b3018 	ldr	r3, [fp, #-24]
   2588c:	e50b3008 	str	r3, [fp, #-8]
  _CONST char *src = src0;
   25890:	e51b301c 	ldr	r3, [fp, #-28]
   25894:	e50b300c 	str	r3, [fp, #-12]
  long *aligned_dst;
  _CONST long *aligned_src;

  /* If SRC and DEST is aligned and count large enough, then copy words.  */
  if (!UNALIGNED (src, dst) && !TOO_SMALL (count))
   25898:	e51b200c 	ldr	r2, [fp, #-12]
   2589c:	e51b3008 	ldr	r3, [fp, #-8]
   258a0:	e1823003 	orr	r3, r2, r3
   258a4:	e2033003 	and	r3, r3, #3
   258a8:	e3530000 	cmp	r3, #0
   258ac:	1a000026 	bne	2594c <strncpy+0xdc>
   258b0:	e51b3020 	ldr	r3, [fp, #-32]
   258b4:	e3530003 	cmp	r3, #3
   258b8:	9a000023 	bls	2594c <strncpy+0xdc>
    {
      aligned_dst = (long*)dst;
   258bc:	e51b3008 	ldr	r3, [fp, #-8]
   258c0:	e50b3010 	str	r3, [fp, #-16]
      aligned_src = (long*)src;
   258c4:	e51b300c 	ldr	r3, [fp, #-12]
   258c8:	e50b3014 	str	r3, [fp, #-20]

      /* SRC and DEST are both "long int" aligned, try to do "long int"
	 sized copies.  */
      while (count >= sizeof (long int) && !DETECTNULL(*aligned_src))
   258cc:	ea00000a 	b	258fc <strncpy+0x8c>
	{
	  count -= sizeof (long int);
   258d0:	e51b3020 	ldr	r3, [fp, #-32]
   258d4:	e2433004 	sub	r3, r3, #4
   258d8:	e50b3020 	str	r3, [fp, #-32]
	  *aligned_dst++ = *aligned_src++;
   258dc:	e51b3010 	ldr	r3, [fp, #-16]
   258e0:	e2832004 	add	r2, r3, #4
   258e4:	e50b2010 	str	r2, [fp, #-16]
   258e8:	e51b2014 	ldr	r2, [fp, #-20]
   258ec:	e2821004 	add	r1, r2, #4
   258f0:	e50b1014 	str	r1, [fp, #-20]
   258f4:	e5922000 	ldr	r2, [r2]
   258f8:	e5832000 	str	r2, [r3]
      aligned_dst = (long*)dst;
      aligned_src = (long*)src;

      /* SRC and DEST are both "long int" aligned, try to do "long int"
	 sized copies.  */
      while (count >= sizeof (long int) && !DETECTNULL(*aligned_src))
   258fc:	e51b3020 	ldr	r3, [fp, #-32]
   25900:	e3530003 	cmp	r3, #3
   25904:	9a00000c 	bls	2593c <strncpy+0xcc>
   25908:	e51b3014 	ldr	r3, [fp, #-20]
   2590c:	e5932000 	ldr	r2, [r3]
   25910:	e59f30c0 	ldr	r3, [pc, #192]	; 259d8 <strncpy+0x168>
   25914:	e0823003 	add	r3, r2, r3
   25918:	e51b2014 	ldr	r2, [fp, #-20]
   2591c:	e5922000 	ldr	r2, [r2]
   25920:	e1e02002 	mvn	r2, r2
   25924:	e0033002 	and	r3, r3, r2
   25928:	e1a02003 	mov	r2, r3
   2592c:	e59f30a8 	ldr	r3, [pc, #168]	; 259dc <strncpy+0x16c>
   25930:	e0033002 	and	r3, r3, r2
   25934:	e3530000 	cmp	r3, #0
   25938:	0affffe4 	beq	258d0 <strncpy+0x60>
	{
	  count -= sizeof (long int);
	  *aligned_dst++ = *aligned_src++;
	}

      dst = (char*)aligned_dst;
   2593c:	e51b3010 	ldr	r3, [fp, #-16]
   25940:	e50b3008 	str	r3, [fp, #-8]
      src = (char*)aligned_src;
   25944:	e51b3014 	ldr	r3, [fp, #-20]
   25948:	e50b300c 	str	r3, [fp, #-12]
    }

  while (count > 0)
   2594c:	ea00000e 	b	2598c <strncpy+0x11c>
    {
      --count;
   25950:	e51b3020 	ldr	r3, [fp, #-32]
   25954:	e2433001 	sub	r3, r3, #1
   25958:	e50b3020 	str	r3, [fp, #-32]
      if ((*dst++ = *src++) == '\0')
   2595c:	e51b3008 	ldr	r3, [fp, #-8]
   25960:	e2832001 	add	r2, r3, #1
   25964:	e50b2008 	str	r2, [fp, #-8]
   25968:	e51b200c 	ldr	r2, [fp, #-12]
   2596c:	e2821001 	add	r1, r2, #1
   25970:	e50b100c 	str	r1, [fp, #-12]
   25974:	e5d22000 	ldrb	r2, [r2]
   25978:	e5c32000 	strb	r2, [r3]
   2597c:	e5d33000 	ldrb	r3, [r3]
   25980:	e3530000 	cmp	r3, #0
   25984:	1a000000 	bne	2598c <strncpy+0x11c>
	break;
   25988:	ea000002 	b	25998 <strncpy+0x128>

      dst = (char*)aligned_dst;
      src = (char*)aligned_src;
    }

  while (count > 0)
   2598c:	e51b3020 	ldr	r3, [fp, #-32]
   25990:	e3530000 	cmp	r3, #0
   25994:	1affffed 	bne	25950 <strncpy+0xe0>
      --count;
      if ((*dst++ = *src++) == '\0')
	break;
    }

  while (count-- > 0)
   25998:	ea000004 	b	259b0 <strncpy+0x140>
    *dst++ = '\0';
   2599c:	e51b3008 	ldr	r3, [fp, #-8]
   259a0:	e2832001 	add	r2, r3, #1
   259a4:	e50b2008 	str	r2, [fp, #-8]
   259a8:	e3a02000 	mov	r2, #0
   259ac:	e5c32000 	strb	r2, [r3]
      --count;
      if ((*dst++ = *src++) == '\0')
	break;
    }

  while (count-- > 0)
   259b0:	e51b3020 	ldr	r3, [fp, #-32]
   259b4:	e2432001 	sub	r2, r3, #1
   259b8:	e50b2020 	str	r2, [fp, #-32]
   259bc:	e3530000 	cmp	r3, #0
   259c0:	1afffff5 	bne	2599c <strncpy+0x12c>
    *dst++ = '\0';

  return dst0;
   259c4:	e51b3018 	ldr	r3, [fp, #-24]
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   259c8:	e1a00003 	mov	r0, r3
   259cc:	e24bd000 	sub	sp, fp, #0
   259d0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   259d4:	e12fff1e 	bx	lr
   259d8:	fefefeff 	.word	0xfefefeff
   259dc:	80808080 	.word	0x80808080

000259e0 <__ssprint_r>:
int
_DEFUN(__ssprint_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       FILE *fp _AND
       register struct __suio *uio)
{
   259e0:	e92d49f0 	push	{r4, r5, r6, r7, r8, fp, lr}
   259e4:	e28db018 	add	fp, sp, #24
   259e8:	e24dd01c 	sub	sp, sp, #28
   259ec:	e50b0030 	str	r0, [fp, #-48]	; 0x30
   259f0:	e50b1034 	str	r1, [fp, #-52]	; 0x34
   259f4:	e1a06002 	mov	r6, r2
	register size_t len;
	register int w;
	register struct __siov *iov;
	register _CONST char *p = NULL;
   259f8:	e3a07000 	mov	r7, #0

	iov = uio->uio_iov;
   259fc:	e5968000 	ldr	r8, [r6]
	len = 0;
   25a00:	e3a05000 	mov	r5, #0

	if (uio->uio_resid == 0) {
   25a04:	e5963008 	ldr	r3, [r6, #8]
   25a08:	e3530000 	cmp	r3, #0
   25a0c:	1a000003 	bne	25a20 <__ssprint_r+0x40>
		uio->uio_iovcnt = 0;
   25a10:	e3a03000 	mov	r3, #0
   25a14:	e5863004 	str	r3, [r6, #4]
		return (0);
   25a18:	e3a03000 	mov	r3, #0
   25a1c:	ea0000a8 	b	25cc4 <__ssprint_r+0x2e4>
	}

        do {
		while (len == 0) {
   25a20:	ea000002 	b	25a30 <__ssprint_r+0x50>
			p = iov->iov_base;
   25a24:	e5987000 	ldr	r7, [r8]
			len = iov->iov_len;
   25a28:	e5985004 	ldr	r5, [r8, #4]
			iov++;
   25a2c:	e2888008 	add	r8, r8, #8
		uio->uio_iovcnt = 0;
		return (0);
	}

        do {
		while (len == 0) {
   25a30:	e3550000 	cmp	r5, #0
   25a34:	0afffffa 	beq	25a24 <__ssprint_r+0x44>
			p = iov->iov_base;
			len = iov->iov_len;
			iov++;
		}
		w = fp->_w;
   25a38:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25a3c:	e5934008 	ldr	r4, [r3, #8]
		if (len >= w && fp->_flags & (__SMBF | __SOPT)) {
   25a40:	e1a03004 	mov	r3, r4
   25a44:	e1530005 	cmp	r3, r5
   25a48:	8a00006a 	bhi	25bf8 <__ssprint_r+0x218>
   25a4c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25a50:	e1d330bc 	ldrh	r3, [r3, #12]
   25a54:	e1a03803 	lsl	r3, r3, #16
   25a58:	e1a03823 	lsr	r3, r3, #16
   25a5c:	e2033d12 	and	r3, r3, #1152	; 0x480
   25a60:	e3530000 	cmp	r3, #0
   25a64:	0a000063 	beq	25bf8 <__ssprint_r+0x218>
			/* must be asprintf family */
			unsigned char *str;
			int curpos = (fp->_p - fp->_bf._base);
   25a68:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25a6c:	e5933000 	ldr	r3, [r3]
   25a70:	e1a02003 	mov	r2, r3
   25a74:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25a78:	e5933010 	ldr	r3, [r3, #16]
   25a7c:	e0633002 	rsb	r3, r3, r2
   25a80:	e50b3028 	str	r3, [fp, #-40]	; 0x28
			 * than (1+sqrt(5))/2 to accomodate malloc
		 	 * overhead. asprintf EXPECTS us to overallocate, so
		 	 * that it can add a trailing \0 without
		 	 * reallocating.  The new allocation should thus be
		 	 * max(prev_size*1.5, curpos+len+1). */
			int newsize = fp->_bf._size * 3 / 2;
   25a84:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25a88:	e5932014 	ldr	r2, [r3, #20]
   25a8c:	e1a03002 	mov	r3, r2
   25a90:	e1a03083 	lsl	r3, r3, #1
   25a94:	e0833002 	add	r3, r3, r2
   25a98:	e1a02fa3 	lsr	r2, r3, #31
   25a9c:	e0823003 	add	r3, r2, r3
   25aa0:	e1a030c3 	asr	r3, r3, #1
   25aa4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
			if (newsize < curpos + len + 1)
   25aa8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   25aac:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   25ab0:	e0833005 	add	r3, r3, r5
   25ab4:	e2833001 	add	r3, r3, #1
   25ab8:	e1520003 	cmp	r2, r3
   25abc:	2a000003 	bcs	25ad0 <__ssprint_r+0xf0>
				newsize = curpos + len + 1;
   25ac0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   25ac4:	e0833005 	add	r3, r3, r5
   25ac8:	e2833001 	add	r3, r3, #1
   25acc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
			if (fp->_flags & __SOPT)
   25ad0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25ad4:	e1d330bc 	ldrh	r3, [r3, #12]
   25ad8:	e1a03803 	lsl	r3, r3, #16
   25adc:	e1a03823 	lsr	r3, r3, #16
   25ae0:	e2033b01 	and	r3, r3, #1024	; 0x400
   25ae4:	e3530000 	cmp	r3, #0
   25ae8:	0a00001d 	beq	25b64 <__ssprint_r+0x184>
			{
				/* asnprintf leaves original buffer alone.  */
				str = (unsigned char *)_malloc_r (ptr, newsize);
   25aec:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   25af0:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   25af4:	e1a01003 	mov	r1, r3
   25af8:	ebffc7ed 	bl	17ab4 <_malloc_r>
   25afc:	e50b0020 	str	r0, [fp, #-32]
				if (!str)
   25b00:	e51b3020 	ldr	r3, [fp, #-32]
   25b04:	e3530000 	cmp	r3, #0
   25b08:	1a000003 	bne	25b1c <__ssprint_r+0x13c>
				{
					ptr->_errno = ENOMEM;
   25b0c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   25b10:	e3a0200c 	mov	r2, #12
   25b14:	e5832000 	str	r2, [r3]
					goto err;
   25b18:	ea00005d 	b	25c94 <__ssprint_r+0x2b4>
				}
				memcpy (str, fp->_bf._base, curpos);
   25b1c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25b20:	e5932010 	ldr	r2, [r3, #16]
   25b24:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   25b28:	e51b0020 	ldr	r0, [fp, #-32]
   25b2c:	e1a01002 	mov	r1, r2
   25b30:	e1a02003 	mov	r2, r3
   25b34:	ebffcaa5 	bl	185d0 <memcpy>
				fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
   25b38:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25b3c:	e1d330bc 	ldrh	r3, [r3, #12]
   25b40:	e3c33d12 	bic	r3, r3, #1152	; 0x480
   25b44:	e1a03803 	lsl	r3, r3, #16
   25b48:	e1a03823 	lsr	r3, r3, #16
   25b4c:	e3833080 	orr	r3, r3, #128	; 0x80
   25b50:	e1a03803 	lsl	r3, r3, #16
   25b54:	e1a02823 	lsr	r2, r3, #16
   25b58:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25b5c:	e1c320bc 	strh	r2, [r3, #12]
   25b60:	ea000013 	b	25bb4 <__ssprint_r+0x1d4>
			}
			else
			{
				str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
   25b64:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25b68:	e5932010 	ldr	r2, [r3, #16]
   25b6c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   25b70:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   25b74:	e1a01002 	mov	r1, r2
   25b78:	e1a02003 	mov	r2, r3
   25b7c:	ebfffa65 	bl	24518 <_realloc_r>
   25b80:	e50b0020 	str	r0, [fp, #-32]
						newsize);
				if (!str) {
   25b84:	e51b3020 	ldr	r3, [fp, #-32]
   25b88:	e3530000 	cmp	r3, #0
   25b8c:	1a000008 	bne	25bb4 <__ssprint_r+0x1d4>
					/* Free unneeded buffer.  */
					_free_r (ptr, fp->_bf._base);
   25b90:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25b94:	e5933010 	ldr	r3, [r3, #16]
   25b98:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   25b9c:	e1a01003 	mov	r1, r3
   25ba0:	ebffc33a 	bl	16890 <_free_r>
					/* Ensure correct errno, even if free
					 * changed it.  */
					ptr->_errno = ENOMEM;
   25ba4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   25ba8:	e3a0200c 	mov	r2, #12
   25bac:	e5832000 	str	r2, [r3]
					goto err;
   25bb0:	ea000037 	b	25c94 <__ssprint_r+0x2b4>
				}
			}
			fp->_bf._base = str;
   25bb4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25bb8:	e51b2020 	ldr	r2, [fp, #-32]
   25bbc:	e5832010 	str	r2, [r3, #16]
			fp->_p = str + curpos;
   25bc0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   25bc4:	e51b2020 	ldr	r2, [fp, #-32]
   25bc8:	e0822003 	add	r2, r2, r3
   25bcc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25bd0:	e5832000 	str	r2, [r3]
			fp->_bf._size = newsize;
   25bd4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25bd8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   25bdc:	e5832014 	str	r2, [r3, #20]
			w = len;
   25be0:	e1a04005 	mov	r4, r5
			fp->_w = newsize - curpos;
   25be4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   25be8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   25bec:	e0632002 	rsb	r2, r3, r2
   25bf0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25bf4:	e5832008 	str	r2, [r3, #8]
		}
		if (len < w)
   25bf8:	e1a03004 	mov	r3, r4
   25bfc:	e1530005 	cmp	r3, r5
   25c00:	9a000000 	bls	25c08 <__ssprint_r+0x228>
			w = len;
   25c04:	e1a04005 	mov	r4, r5
		(void)memmove ((_PTR) fp->_p, (_PTR) p, (size_t) (w));
   25c08:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25c0c:	e5932000 	ldr	r2, [r3]
   25c10:	e1a03004 	mov	r3, r4
   25c14:	e1a00002 	mov	r0, r2
   25c18:	e1a01007 	mov	r1, r7
   25c1c:	e1a02003 	mov	r2, r3
   25c20:	ebfff2eb 	bl	227d4 <memmove>
		fp->_w -= w;
   25c24:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25c28:	e5933008 	ldr	r3, [r3, #8]
   25c2c:	e0642003 	rsb	r2, r4, r3
   25c30:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25c34:	e5832008 	str	r2, [r3, #8]
		fp->_p += w;
   25c38:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25c3c:	e5932000 	ldr	r2, [r3]
   25c40:	e1a03004 	mov	r3, r4
   25c44:	e0822003 	add	r2, r2, r3
   25c48:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25c4c:	e5832000 	str	r2, [r3]
		w = len;          /* pretend we copied all */
   25c50:	e1a04005 	mov	r4, r5
		p += w;
   25c54:	e1a03004 	mov	r3, r4
   25c58:	e0877003 	add	r7, r7, r3
		len -= w;
   25c5c:	e1a03004 	mov	r3, r4
   25c60:	e0635005 	rsb	r5, r3, r5
        } while ((uio->uio_resid -= w) != 0);
   25c64:	e5963008 	ldr	r3, [r6, #8]
   25c68:	e0643003 	rsb	r3, r4, r3
   25c6c:	e5863008 	str	r3, [r6, #8]
   25c70:	e5963008 	ldr	r3, [r6, #8]
   25c74:	e3530000 	cmp	r3, #0
   25c78:	1affff68 	bne	25a20 <__ssprint_r+0x40>

	uio->uio_resid = 0;
   25c7c:	e3a03000 	mov	r3, #0
   25c80:	e5863008 	str	r3, [r6, #8]
	uio->uio_iovcnt = 0;
   25c84:	e3a03000 	mov	r3, #0
   25c88:	e5863004 	str	r3, [r6, #4]
	return 0;
   25c8c:	e3a03000 	mov	r3, #0
   25c90:	ea00000b 	b	25cc4 <__ssprint_r+0x2e4>

err:
  fp->_flags |= __SERR;
   25c94:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25c98:	e1d330bc 	ldrh	r3, [r3, #12]
   25c9c:	e3833040 	orr	r3, r3, #64	; 0x40
   25ca0:	e1a03803 	lsl	r3, r3, #16
   25ca4:	e1a02823 	lsr	r2, r3, #16
   25ca8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   25cac:	e1c320bc 	strh	r2, [r3, #12]
  uio->uio_resid = 0;
   25cb0:	e3a03000 	mov	r3, #0
   25cb4:	e5863008 	str	r3, [r6, #8]
  uio->uio_iovcnt = 0;
   25cb8:	e3a03000 	mov	r3, #0
   25cbc:	e5863004 	str	r3, [r6, #4]
  return EOF;
   25cc0:	e3e03000 	mvn	r3, #0
}
   25cc4:	e1a00003 	mov	r0, r3
   25cc8:	e24bd018 	sub	sp, fp, #24
   25ccc:	e8bd49f0 	pop	{r4, r5, r6, r7, r8, fp, lr}
   25cd0:	e12fff1e 	bx	lr

00025cd4 <_svfiprintf_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
   25cd4:	e92d4bf0 	push	{r4, r5, r6, r7, r8, r9, fp, lr}
   25cd8:	e28db01c 	add	fp, sp, #28
   25cdc:	e24dde12 	sub	sp, sp, #288	; 0x120
   25ce0:	e50b0120 	str	r0, [fp, #-288]	; 0x120
   25ce4:	e50b1124 	str	r1, [fp, #-292]	; 0x124
   25ce8:	e50b2128 	str	r2, [fp, #-296]	; 0x128
   25cec:	e50b312c 	str	r3, [fp, #-300]	; 0x12c
	int width;		/* width from format (%8d), or 0 */
	int prec;		/* precision from format (%.3d), or -1 */
	char sign;		/* sign prefix (' ', '+', '-', or \0) */
#ifdef _WANT_IO_C99_FORMATS
				/* locale specific numeric grouping */
	char *thousands_sep = NULL;
   25cf0:	e3a03000 	mov	r3, #0
   25cf4:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	size_t thsnd_len = 0;
   25cf8:	e3a03000 	mov	r3, #0
   25cfc:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	const char *grouping = NULL;
   25d00:	e3a03000 	mov	r3, #0
   25d04:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	int expsize = 0;	/* character count for expstr */
	char expstr[MAXEXPLEN];	/* buffer for exponent string */
	int lead;		/* sig figs before decimal or group sep */
#endif /* FLOATING_POINT */
#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
	int ndig = 0;		/* actual number of digits returned by cvt */
   25d08:	e3a03000 	mov	r3, #0
   25d0c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
   25d10:	e3a03000 	mov	r3, #0
   25d14:	e50b3058 	str	r3, [fp, #-88]	; 0x58
	char ox[2];		/* space for 0x hex-prefix */
#ifdef _MB_CAPABLE
	wchar_t wc;
	mbstate_t state;        /* mbtowc calls from library must not change state */
#endif
	char *malloc_buf = NULL;/* handy pointer for malloced buffers */
   25d18:	e3a03000 	mov	r3, #0
   25d1c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
		return (__sbprintf (data, fp, fmt0, ap));
	}
#endif
#else /* STRING_ONLY */
        /* Create initial buffer if we are called by asprintf family.  */
        if (fp->_flags & __SMBF && !fp->_bf._base)
   25d20:	e51b3124 	ldr	r3, [fp, #-292]	; 0x124
   25d24:	e1d330bc 	ldrh	r3, [r3, #12]
   25d28:	e1a03803 	lsl	r3, r3, #16
   25d2c:	e1a03823 	lsr	r3, r3, #16
   25d30:	e2033080 	and	r3, r3, #128	; 0x80
   25d34:	e3530000 	cmp	r3, #0
   25d38:	0a000019 	beq	25da4 <_svfiprintf_r+0xd0>
   25d3c:	e51b3124 	ldr	r3, [fp, #-292]	; 0x124
   25d40:	e5933010 	ldr	r3, [r3, #16]
   25d44:	e3530000 	cmp	r3, #0
   25d48:	1a000015 	bne	25da4 <_svfiprintf_r+0xd0>
        {
		fp->_bf._base = fp->_p = _malloc_r (data, 64);
   25d4c:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   25d50:	e3a01040 	mov	r1, #64	; 0x40
   25d54:	ebffc756 	bl	17ab4 <_malloc_r>
   25d58:	e1a02000 	mov	r2, r0
   25d5c:	e51b3124 	ldr	r3, [fp, #-292]	; 0x124
   25d60:	e5832000 	str	r2, [r3]
   25d64:	e51b3124 	ldr	r3, [fp, #-292]	; 0x124
   25d68:	e5932000 	ldr	r2, [r3]
   25d6c:	e51b3124 	ldr	r3, [fp, #-292]	; 0x124
   25d70:	e5832010 	str	r2, [r3, #16]
		if (!fp->_p)
   25d74:	e51b3124 	ldr	r3, [fp, #-292]	; 0x124
   25d78:	e5933000 	ldr	r3, [r3]
   25d7c:	e3530000 	cmp	r3, #0
   25d80:	1a000004 	bne	25d98 <_svfiprintf_r+0xc4>
		{
			data->_errno = ENOMEM;
   25d84:	e51b3120 	ldr	r3, [fp, #-288]	; 0x120
   25d88:	e3a0200c 	mov	r2, #12
   25d8c:	e5832000 	str	r2, [r3]
			return EOF;
   25d90:	e3e03000 	mvn	r3, #0
   25d94:	ea0004fb 	b	27188 <_svfiprintf_r+0x14b4>
		}
		fp->_bf._size = 64;
   25d98:	e51b3124 	ldr	r3, [fp, #-292]	; 0x124
   25d9c:	e3a02040 	mov	r2, #64	; 0x40
   25da0:	e5832014 	str	r2, [r3, #20]
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
   25da4:	e51b8128 	ldr	r8, [fp, #-296]	; 0x128
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   25da8:	e24b50b4 	sub	r5, fp, #180	; 0xb4
   25dac:	e50b5074 	str	r5, [fp, #-116]	; 0x74
	uio.uio_resid = 0;
   25db0:	e3a03000 	mov	r3, #0
   25db4:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
	uio.uio_iovcnt = 0;
   25db8:	e3a03000 	mov	r3, #0
   25dbc:	e50b3070 	str	r3, [fp, #-112]	; 0x70
#endif
	ret = 0;
   25dc0:	e3a03000 	mov	r3, #0
   25dc4:	e50b3020 	str	r3, [fp, #-32]

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
	        cp = fmt;
   25dc8:	e1a06008 	mov	r6, r8
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   25dcc:	ea000000 	b	25dd4 <_svfiprintf_r+0x100>
                    fmt += 1;
   25dd0:	e2888001 	add	r8, r8, #1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   25dd4:	e5d83000 	ldrb	r3, [r8]
   25dd8:	e3530000 	cmp	r3, #0
   25ddc:	0a000002 	beq	25dec <_svfiprintf_r+0x118>
   25de0:	e5d83000 	ldrb	r3, [r8]
   25de4:	e3530025 	cmp	r3, #37	; 0x25
   25de8:	1afffff8 	bne	25dd0 <_svfiprintf_r+0xfc>
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
   25dec:	e1a02008 	mov	r2, r8
   25df0:	e1a03006 	mov	r3, r6
   25df4:	e0634002 	rsb	r4, r3, r2
   25df8:	e3540000 	cmp	r4, #0
   25dfc:	0a000019 	beq	25e68 <_svfiprintf_r+0x194>
			PRINT (cp, m);
   25e00:	e5856000 	str	r6, [r5]
   25e04:	e1a03004 	mov	r3, r4
   25e08:	e5853004 	str	r3, [r5, #4]
   25e0c:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   25e10:	e0833004 	add	r3, r3, r4
   25e14:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   25e18:	e2855008 	add	r5, r5, #8
   25e1c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   25e20:	e2833001 	add	r3, r3, #1
   25e24:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   25e28:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   25e2c:	e3530007 	cmp	r3, #7
   25e30:	da000009 	ble	25e5c <_svfiprintf_r+0x188>
   25e34:	e24b3074 	sub	r3, fp, #116	; 0x74
   25e38:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   25e3c:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   25e40:	e1a02003 	mov	r2, r3
   25e44:	ebfffee5 	bl	259e0 <__ssprint_r>
   25e48:	e1a03000 	mov	r3, r0
   25e4c:	e3530000 	cmp	r3, #0
   25e50:	0a000000 	beq	25e58 <_svfiprintf_r+0x184>
   25e54:	ea0004ba 	b	27144 <_svfiprintf_r+0x1470>
   25e58:	e24b50b4 	sub	r5, fp, #180	; 0xb4
			ret += m;
   25e5c:	e51b3020 	ldr	r3, [fp, #-32]
   25e60:	e0833004 	add	r3, r3, r4
   25e64:	e50b3020 	str	r3, [fp, #-32]
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   25e68:	e5d83000 	ldrb	r3, [r8]
   25e6c:	e3530000 	cmp	r3, #0
   25e70:	1a000000 	bne	25e78 <_svfiprintf_r+0x1a4>
                    goto done;
   25e74:	ea0004a3 	b	27108 <_svfiprintf_r+0x1434>
#endif
		fmt_anchor = fmt;
   25e78:	e50b8060 	str	r8, [fp, #-96]	; 0x60
		fmt++;		/* skip over '%' */
   25e7c:	e2888001 	add	r8, r8, #1

		flags = 0;
   25e80:	e3a04000 	mov	r4, #0
		dprec = 0;
   25e84:	e3a03000 	mov	r3, #0
   25e88:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
		width = 0;
   25e8c:	e3a03000 	mov	r3, #0
   25e90:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		prec = -1;
   25e94:	e3e03000 	mvn	r3, #0
   25e98:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		sign = '\0';
   25e9c:	e3a03000 	mov	r3, #0
   25ea0:	e54b3065 	strb	r3, [fp, #-101]	; 0x65
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   25ea4:	e1a03008 	mov	r3, r8
   25ea8:	e2838001 	add	r8, r3, #1
   25eac:	e5d33000 	ldrb	r3, [r3]
   25eb0:	e1a09003 	mov	r9, r3
reswitch:	switch (ch) {
   25eb4:	e2493020 	sub	r3, r9, #32
   25eb8:	e353005a 	cmp	r3, #90	; 0x5a
   25ebc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   25ec0:	ea000318 	b	26b28 <_svfiprintf_r+0xe54>
   25ec4:	00026094 	.word	0x00026094
   25ec8:	00026b28 	.word	0x00026b28
   25ecc:	00026b28 	.word	0x00026b28
   25ed0:	000260ac 	.word	0x000260ac
   25ed4:	00026b28 	.word	0x00026b28
   25ed8:	00026b28 	.word	0x00026b28
   25edc:	00026b28 	.word	0x00026b28
   25ee0:	00026030 	.word	0x00026030
   25ee4:	00026b28 	.word	0x00026b28
   25ee8:	00026b28 	.word	0x00026b28
   25eec:	000260b4 	.word	0x000260b4
   25ef0:	000260ec 	.word	0x000260ec
   25ef4:	00026b28 	.word	0x00026b28
   25ef8:	000260e4 	.word	0x000260e4
   25efc:	000260f8 	.word	0x000260f8
   25f00:	00026b28 	.word	0x00026b28
   25f04:	00026194 	.word	0x00026194
   25f08:	0002619c 	.word	0x0002619c
   25f0c:	0002619c 	.word	0x0002619c
   25f10:	0002619c 	.word	0x0002619c
   25f14:	0002619c 	.word	0x0002619c
   25f18:	0002619c 	.word	0x0002619c
   25f1c:	0002619c 	.word	0x0002619c
   25f20:	0002619c 	.word	0x0002619c
   25f24:	0002619c 	.word	0x0002619c
   25f28:	0002619c 	.word	0x0002619c
   25f2c:	00026b28 	.word	0x00026b28
   25f30:	00026b28 	.word	0x00026b28
   25f34:	00026b28 	.word	0x00026b28
   25f38:	00026b28 	.word	0x00026b28
   25f3c:	00026b28 	.word	0x00026b28
   25f40:	00026b28 	.word	0x00026b28
   25f44:	00026b28 	.word	0x00026b28
   25f48:	00026b28 	.word	0x00026b28
   25f4c:	00026b28 	.word	0x00026b28
   25f50:	00026230 	.word	0x00026230
   25f54:	00026260 	.word	0x00026260
   25f58:	00026b28 	.word	0x00026b28
   25f5c:	00026b28 	.word	0x00026b28
   25f60:	00026b28 	.word	0x00026b28
   25f64:	00026b28 	.word	0x00026b28
   25f68:	00026b28 	.word	0x00026b28
   25f6c:	00026b28 	.word	0x00026b28
   25f70:	00026b28 	.word	0x00026b28
   25f74:	00026b28 	.word	0x00026b28
   25f78:	00026b28 	.word	0x00026b28
   25f7c:	00026b28 	.word	0x00026b28
   25f80:	00026450 	.word	0x00026450
   25f84:	00026b28 	.word	0x00026b28
   25f88:	00026b28 	.word	0x00026b28
   25f8c:	00026b28 	.word	0x00026b28
   25f90:	00026580 	.word	0x00026580
   25f94:	00026b28 	.word	0x00026b28
   25f98:	00026640 	.word	0x00026640
   25f9c:	00026b28 	.word	0x00026b28
   25fa0:	00026b28 	.word	0x00026b28
   25fa4:	00026720 	.word	0x00026720
   25fa8:	00026b28 	.word	0x00026b28
   25fac:	00026b28 	.word	0x00026b28
   25fb0:	00026b28 	.word	0x00026b28
   25fb4:	00026b28 	.word	0x00026b28
   25fb8:	00026b28 	.word	0x00026b28
   25fbc:	00026b28 	.word	0x00026b28
   25fc0:	00026b28 	.word	0x00026b28
   25fc4:	00026b28 	.word	0x00026b28
   25fc8:	00026b28 	.word	0x00026b28
   25fcc:	00026b28 	.word	0x00026b28
   25fd0:	00026230 	.word	0x00026230
   25fd4:	00026264 	.word	0x00026264
   25fd8:	00026b28 	.word	0x00026b28
   25fdc:	00026b28 	.word	0x00026b28
   25fe0:	00026b28 	.word	0x00026b28
   25fe4:	000261e0 	.word	0x000261e0
   25fe8:	00026264 	.word	0x00026264
   25fec:	00026228 	.word	0x00026228
   25ff0:	00026b28 	.word	0x00026b28
   25ff4:	00026200 	.word	0x00026200
   25ff8:	00026b28 	.word	0x00026b28
   25ffc:	00026380 	.word	0x00026380
   26000:	00026454 	.word	0x00026454
   26004:	00026534 	.word	0x00026534
   26008:	00026220 	.word	0x00026220
   2600c:	00026b28 	.word	0x00026b28
   26010:	00026580 	.word	0x00026580
   26014:	00025ea4 	.word	0x00025ea4
   26018:	00026644 	.word	0x00026644
   2601c:	00026b28 	.word	0x00026b28
   26020:	00026b28 	.word	0x00026b28
   26024:	0002672c 	.word	0x0002672c
   26028:	00026b28 	.word	0x00026b28
   2602c:	00025ea4 	.word	0x00025ea4
#ifdef _WANT_IO_C99_FORMATS
		case '\'':
			thousands_sep = _localeconv_r (data)->thousands_sep;
   26030:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   26034:	ebfff09b 	bl	222a8 <_localeconv_r>
   26038:	e1a03000 	mov	r3, r0
   2603c:	e5933004 	ldr	r3, [r3, #4]
   26040:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
			thsnd_len = strlen (thousands_sep);
   26044:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
   26048:	ebffcc98 	bl	192b0 <strlen>
   2604c:	e50b0030 	str	r0, [fp, #-48]	; 0x30
			grouping = _localeconv_r (data)->grouping;
   26050:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   26054:	ebfff093 	bl	222a8 <_localeconv_r>
   26058:	e1a03000 	mov	r3, r0
   2605c:	e5933008 	ldr	r3, [r3, #8]
   26060:	e50b3034 	str	r3, [fp, #-52]	; 0x34
			if (thsnd_len > 0 && grouping && *grouping)
   26064:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   26068:	e3530000 	cmp	r3, #0
   2606c:	0a000007 	beq	26090 <_svfiprintf_r+0x3bc>
   26070:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   26074:	e3530000 	cmp	r3, #0
   26078:	0a000004 	beq	26090 <_svfiprintf_r+0x3bc>
   2607c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   26080:	e5d33000 	ldrb	r3, [r3]
   26084:	e3530000 	cmp	r3, #0
   26088:	0a000000 	beq	26090 <_svfiprintf_r+0x3bc>
			  flags |= GROUPING;
   2608c:	e3844b01 	orr	r4, r4, #1024	; 0x400
			goto rflag;
   26090:	eaffff83 	b	25ea4 <_svfiprintf_r+0x1d0>
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
   26094:	e55b3065 	ldrb	r3, [fp, #-101]	; 0x65
   26098:	e3530000 	cmp	r3, #0
   2609c:	1a000001 	bne	260a8 <_svfiprintf_r+0x3d4>
				sign = ' ';
   260a0:	e3a03020 	mov	r3, #32
   260a4:	e54b3065 	strb	r3, [fp, #-101]	; 0x65
			goto rflag;
   260a8:	eaffff7d 	b	25ea4 <_svfiprintf_r+0x1d0>
		case '#':
			flags |= ALT;
   260ac:	e3844001 	orr	r4, r4, #1
			goto rflag;
   260b0:	eaffff7b 	b	25ea4 <_svfiprintf_r+0x1d0>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   260b4:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   260b8:	e2832004 	add	r2, r3, #4
   260bc:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   260c0:	e5933000 	ldr	r3, [r3]
   260c4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
   260c8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   260cc:	e3530000 	cmp	r3, #0
   260d0:	ba000000 	blt	260d8 <_svfiprintf_r+0x404>
				goto rflag;
   260d4:	eaffff72 	b	25ea4 <_svfiprintf_r+0x1d0>
			width = -width;
   260d8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   260dc:	e2633000 	rsb	r3, r3, #0
   260e0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
   260e4:	e3844004 	orr	r4, r4, #4
			goto rflag;
   260e8:	eaffff6d 	b	25ea4 <_svfiprintf_r+0x1d0>
		case '+':
			sign = '+';
   260ec:	e3a0302b 	mov	r3, #43	; 0x2b
   260f0:	e54b3065 	strb	r3, [fp, #-101]	; 0x65
			goto rflag;
   260f4:	eaffff6a 	b	25ea4 <_svfiprintf_r+0x1d0>
		case '.':
			if ((ch = *fmt++) == '*') {
   260f8:	e1a03008 	mov	r3, r8
   260fc:	e2838001 	add	r8, r3, #1
   26100:	e5d33000 	ldrb	r3, [r3]
   26104:	e1a09003 	mov	r9, r3
   26108:	e359002a 	cmp	r9, #42	; 0x2a
   2610c:	1a00000a 	bne	2613c <_svfiprintf_r+0x468>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   26110:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   26114:	e2832004 	add	r2, r3, #4
   26118:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   2611c:	e5933000 	ldr	r3, [r3]
   26120:	e50b3028 	str	r3, [fp, #-40]	; 0x28
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   26124:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   26128:	e3530000 	cmp	r3, #0
   2612c:	aa000001 	bge	26138 <_svfiprintf_r+0x464>
					prec = -1;
   26130:	e3e03000 	mvn	r3, #0
   26134:	e50b3028 	str	r3, [fp, #-40]	; 0x28
				goto rflag;
   26138:	eaffff59 	b	25ea4 <_svfiprintf_r+0x1d0>
			}
			n = 0;
   2613c:	e3a07000 	mov	r7, #0
			while (is_digit (ch)) {
   26140:	ea00000a 	b	26170 <_svfiprintf_r+0x49c>
				n = 10 * n + to_digit (ch);
   26144:	e1a03007 	mov	r3, r7
   26148:	e1a03103 	lsl	r3, r3, #2
   2614c:	e0833007 	add	r3, r3, r7
   26150:	e1a03083 	lsl	r3, r3, #1
   26154:	e1a02003 	mov	r2, r3
   26158:	e2493030 	sub	r3, r9, #48	; 0x30
   2615c:	e0827003 	add	r7, r2, r3
				ch = *fmt++;
   26160:	e1a03008 	mov	r3, r8
   26164:	e2838001 	add	r8, r3, #1
   26168:	e5d33000 	ldrb	r3, [r3]
   2616c:	e1a09003 	mov	r9, r3
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   26170:	e2493030 	sub	r3, r9, #48	; 0x30
   26174:	e3530009 	cmp	r3, #9
   26178:	9afffff1 	bls	26144 <_svfiprintf_r+0x470>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
   2617c:	e3e03000 	mvn	r3, #0
   26180:	e1570003 	cmp	r7, r3
   26184:	a1a03007 	movge	r3, r7
   26188:	b1a03003 	movlt	r3, r3
   2618c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
			goto reswitch;
   26190:	eaffff47 	b	25eb4 <_svfiprintf_r+0x1e0>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
   26194:	e3844080 	orr	r4, r4, #128	; 0x80
			goto rflag;
   26198:	eaffff41 	b	25ea4 <_svfiprintf_r+0x1d0>
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
   2619c:	e3a07000 	mov	r7, #0
			do {
				n = 10 * n + to_digit (ch);
   261a0:	e1a03007 	mov	r3, r7
   261a4:	e1a03103 	lsl	r3, r3, #2
   261a8:	e0833007 	add	r3, r3, r7
   261ac:	e1a03083 	lsl	r3, r3, #1
   261b0:	e1a02003 	mov	r2, r3
   261b4:	e2493030 	sub	r3, r9, #48	; 0x30
   261b8:	e0827003 	add	r7, r2, r3
				ch = *fmt++;
   261bc:	e1a03008 	mov	r3, r8
   261c0:	e2838001 	add	r8, r3, #1
   261c4:	e5d33000 	ldrb	r3, [r3]
   261c8:	e1a09003 	mov	r9, r3
			} while (is_digit (ch));
   261cc:	e2493030 	sub	r3, r9, #48	; 0x30
   261d0:	e3530009 	cmp	r3, #9
   261d4:	9afffff1 	bls	261a0 <_svfiprintf_r+0x4cc>
				}
				else
					goto error;
			}
#endif /* !_NO_POS_ARGS */
			width = n;
   261d8:	e50b7024 	str	r7, [fp, #-36]	; 0x24
			goto reswitch;
   261dc:	eaffff34 	b	25eb4 <_svfiprintf_r+0x1e0>
			flags |= LONGDBL;
			goto rflag;
#endif
		case 'h':
#ifdef _WANT_IO_C99_FORMATS
			if (*fmt == 'h') {
   261e0:	e5d83000 	ldrb	r3, [r8]
   261e4:	e3530068 	cmp	r3, #104	; 0x68
   261e8:	1a000002 	bne	261f8 <_svfiprintf_r+0x524>
				fmt++;
   261ec:	e2888001 	add	r8, r8, #1
				flags |= CHARINT;
   261f0:	e3844c02 	orr	r4, r4, #512	; 0x200
   261f4:	ea000000 	b	261fc <_svfiprintf_r+0x528>
			} else
#endif
				flags |= SHORTINT;
   261f8:	e3844040 	orr	r4, r4, #64	; 0x40
			goto rflag;
   261fc:	eaffff28 	b	25ea4 <_svfiprintf_r+0x1d0>
		case 'l':
#if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
			if (*fmt == 'l') {
   26200:	e5d83000 	ldrb	r3, [r8]
   26204:	e353006c 	cmp	r3, #108	; 0x6c
   26208:	1a000002 	bne	26218 <_svfiprintf_r+0x544>
				fmt++;
   2620c:	e2888001 	add	r8, r8, #1
				flags |= QUADINT;
   26210:	e3844020 	orr	r4, r4, #32
   26214:	ea000000 	b	2621c <_svfiprintf_r+0x548>
			} else
#endif
				flags |= LONGINT;
   26218:	e3844010 	orr	r4, r4, #16
			goto rflag;
   2621c:	eaffff20 	b	25ea4 <_svfiprintf_r+0x1d0>
		case 'q': /* extension */
			flags |= QUADINT;
   26220:	e3844020 	orr	r4, r4, #32
			goto rflag;
   26224:	eaffff1e 	b	25ea4 <_svfiprintf_r+0x1d0>
#ifdef _WANT_IO_C99_FORMATS
		case 'j':
		  if (sizeof (intmax_t) == sizeof (long))
		    flags |= LONGINT;
		  else
		    flags |= QUADINT;
   26228:	e3844020 	orr	r4, r4, #32
		  goto rflag;
   2622c:	eaffff1c 	b	25ea4 <_svfiprintf_r+0x1d0>
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
   26230:	e24b6f46 	sub	r6, fp, #280	; 0x118
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   26234:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   26238:	e2832004 	add	r2, r3, #4
   2623c:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   26240:	e5933000 	ldr	r3, [r3]
   26244:	e20330ff 	and	r3, r3, #255	; 0xff
   26248:	e5c63000 	strb	r3, [r6]
				size = 1;
   2624c:	e3a03001 	mov	r3, #1
   26250:	e50b3054 	str	r3, [fp, #-84]	; 0x54
			}
			sign = '\0';
   26254:	e3a03000 	mov	r3, #0
   26258:	e54b3065 	strb	r3, [fp, #-101]	; 0x65
			break;
   2625c:	ea00023c 	b	26b54 <_svfiprintf_r+0xe80>
		case 'D':  /* extension */
			flags |= LONGINT;
   26260:	e3844010 	orr	r4, r4, #16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   26264:	e2043020 	and	r3, r4, #32
   26268:	e3530000 	cmp	r3, #0
   2626c:	0a000006 	beq	2628c <_svfiprintf_r+0x5b8>
   26270:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   26274:	e2833007 	add	r3, r3, #7
   26278:	e3c33007 	bic	r3, r3, #7
   2627c:	e2832008 	add	r2, r3, #8
   26280:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   26284:	e893000c 	ldm	r3, {r2, r3}
   26288:	ea00002a 	b	26338 <_svfiprintf_r+0x664>
   2628c:	e2043010 	and	r3, r4, #16
   26290:	e3530000 	cmp	r3, #0
   26294:	0a000006 	beq	262b4 <_svfiprintf_r+0x5e0>
   26298:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   2629c:	e2832004 	add	r2, r3, #4
   262a0:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   262a4:	e5933000 	ldr	r3, [r3]
   262a8:	e1a02003 	mov	r2, r3
   262ac:	e1a03fc2 	asr	r3, r2, #31
   262b0:	ea000020 	b	26338 <_svfiprintf_r+0x664>
   262b4:	e2043040 	and	r3, r4, #64	; 0x40
   262b8:	e3530000 	cmp	r3, #0
   262bc:	0a00000a 	beq	262ec <_svfiprintf_r+0x618>
   262c0:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   262c4:	e2832004 	add	r2, r3, #4
   262c8:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   262cc:	e5933000 	ldr	r3, [r3]
   262d0:	e1a03803 	lsl	r3, r3, #16
   262d4:	e1a01823 	lsr	r1, r3, #16
   262d8:	e1a03801 	lsl	r3, r1, #16
   262dc:	e1a03843 	asr	r3, r3, #16
   262e0:	e1a02003 	mov	r2, r3
   262e4:	e1a03fc2 	asr	r3, r2, #31
   262e8:	ea000012 	b	26338 <_svfiprintf_r+0x664>
   262ec:	e2043c02 	and	r3, r4, #512	; 0x200
   262f0:	e3530000 	cmp	r3, #0
   262f4:	0a000009 	beq	26320 <_svfiprintf_r+0x64c>
   262f8:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   262fc:	e2832004 	add	r2, r3, #4
   26300:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   26304:	e5933000 	ldr	r3, [r3]
   26308:	e20310ff 	and	r1, r3, #255	; 0xff
   2630c:	e1a03c01 	lsl	r3, r1, #24
   26310:	e1a03c43 	asr	r3, r3, #24
   26314:	e1a02003 	mov	r2, r3
   26318:	e1a03fc2 	asr	r3, r2, #31
   2631c:	ea000005 	b	26338 <_svfiprintf_r+0x664>
   26320:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   26324:	e2832004 	add	r2, r3, #4
   26328:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   2632c:	e5933000 	ldr	r3, [r3]
   26330:	e1a02003 	mov	r2, r3
   26334:	e1a03fc2 	asr	r3, r2, #31
   26338:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   2633c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
   26340:	e24b3044 	sub	r3, fp, #68	; 0x44
   26344:	e893000c 	ldm	r3, {r2, r3}
   26348:	e3520000 	cmp	r2, #0
   2634c:	e2d31000 	sbcs	r1, r3, #0
   26350:	aa000007 	bge	26374 <_svfiprintf_r+0x6a0>
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
   26354:	e24b3044 	sub	r3, fp, #68	; 0x44
   26358:	e893000c 	ldm	r3, {r2, r3}
   2635c:	e2722000 	rsbs	r2, r2, #0
   26360:	e2e33000 	rsc	r3, r3, #0
   26364:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   26368:	e50b3040 	str	r3, [fp, #-64]	; 0x40
				sign = '-';
   2636c:	e3a0302d 	mov	r3, #45	; 0x2d
   26370:	e54b3065 	strb	r3, [fp, #-101]	; 0x65
			}
			base = DEC;
   26374:	e3a03001 	mov	r3, #1
   26378:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
			goto number;
   2637c:	ea000131 	b	26848 <_svfiprintf_r+0xb74>
			flags &= ~LONGINT;
			goto string;
#endif
		case 'n':
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
   26380:	e2043020 	and	r3, r4, #32
   26384:	e3530000 	cmp	r3, #0
   26388:	0a000007 	beq	263ac <_svfiprintf_r+0x6d8>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
   2638c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   26390:	e2832004 	add	r2, r3, #4
   26394:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   26398:	e5932000 	ldr	r2, [r3]
   2639c:	e51b3020 	ldr	r3, [fp, #-32]
   263a0:	e1a04fc3 	asr	r4, r3, #31
   263a4:	e8820018 	stm	r2, {r3, r4}
   263a8:	ea000027 	b	2644c <_svfiprintf_r+0x778>
			else
#endif
			if (flags & LONGINT)
   263ac:	e2043010 	and	r3, r4, #16
   263b0:	e3530000 	cmp	r3, #0
   263b4:	0a000006 	beq	263d4 <_svfiprintf_r+0x700>
				*GET_ARG (N, ap, long_ptr_t) = ret;
   263b8:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   263bc:	e2832004 	add	r2, r3, #4
   263c0:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   263c4:	e5933000 	ldr	r3, [r3]
   263c8:	e51b2020 	ldr	r2, [fp, #-32]
   263cc:	e5832000 	str	r2, [r3]
   263d0:	ea00001d 	b	2644c <_svfiprintf_r+0x778>
			else if (flags & SHORTINT)
   263d4:	e2043040 	and	r3, r4, #64	; 0x40
   263d8:	e3530000 	cmp	r3, #0
   263dc:	0a000008 	beq	26404 <_svfiprintf_r+0x730>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   263e0:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   263e4:	e2832004 	add	r2, r3, #4
   263e8:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   263ec:	e5933000 	ldr	r3, [r3]
   263f0:	e51b2020 	ldr	r2, [fp, #-32]
   263f4:	e1a02802 	lsl	r2, r2, #16
   263f8:	e1a02822 	lsr	r2, r2, #16
   263fc:	e1c320b0 	strh	r2, [r3]
   26400:	ea000011 	b	2644c <_svfiprintf_r+0x778>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
   26404:	e2043c02 	and	r3, r4, #512	; 0x200
   26408:	e3530000 	cmp	r3, #0
   2640c:	0a000007 	beq	26430 <_svfiprintf_r+0x75c>
				*GET_ARG (N, ap, char_ptr_t) = ret;
   26410:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   26414:	e2832004 	add	r2, r3, #4
   26418:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   2641c:	e5933000 	ldr	r3, [r3]
   26420:	e51b2020 	ldr	r2, [fp, #-32]
   26424:	e20220ff 	and	r2, r2, #255	; 0xff
   26428:	e5c32000 	strb	r2, [r3]
   2642c:	ea000006 	b	2644c <_svfiprintf_r+0x778>
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
   26430:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   26434:	e2832004 	add	r2, r3, #4
   26438:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   2643c:	e5933000 	ldr	r3, [r3]
   26440:	e51b2020 	ldr	r2, [fp, #-32]
   26444:	e5832000 	str	r2, [r3]
			continue;	/* no output */
   26448:	ea00032d 	b	27104 <_svfiprintf_r+0x1430>
   2644c:	ea00032c 	b	27104 <_svfiprintf_r+0x1430>
		case 'O': /* extension */
			flags |= LONGINT;
   26450:	e3844010 	orr	r4, r4, #16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   26454:	e2043020 	and	r3, r4, #32
   26458:	e3530000 	cmp	r3, #0
   2645c:	0a000006 	beq	2647c <_svfiprintf_r+0x7a8>
   26460:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   26464:	e2833007 	add	r3, r3, #7
   26468:	e3c33007 	bic	r3, r3, #7
   2646c:	e2832008 	add	r2, r3, #8
   26470:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   26474:	e893000c 	ldm	r3, {r2, r3}
   26478:	ea000027 	b	2651c <_svfiprintf_r+0x848>
   2647c:	e2043010 	and	r3, r4, #16
   26480:	e3530000 	cmp	r3, #0
   26484:	0a000006 	beq	264a4 <_svfiprintf_r+0x7d0>
   26488:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   2648c:	e2832004 	add	r2, r3, #4
   26490:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   26494:	e5933000 	ldr	r3, [r3]
   26498:	e1a02003 	mov	r2, r3
   2649c:	e3a03000 	mov	r3, #0
   264a0:	ea00001d 	b	2651c <_svfiprintf_r+0x848>
   264a4:	e2043040 	and	r3, r4, #64	; 0x40
   264a8:	e3530000 	cmp	r3, #0
   264ac:	0a000009 	beq	264d8 <_svfiprintf_r+0x804>
   264b0:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   264b4:	e2832004 	add	r2, r3, #4
   264b8:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   264bc:	e5933000 	ldr	r3, [r3]
   264c0:	e1a03803 	lsl	r3, r3, #16
   264c4:	e1a01823 	lsr	r1, r3, #16
   264c8:	e1a03001 	mov	r3, r1
   264cc:	e1a02003 	mov	r2, r3
   264d0:	e3a03000 	mov	r3, #0
   264d4:	ea000010 	b	2651c <_svfiprintf_r+0x848>
   264d8:	e2043c02 	and	r3, r4, #512	; 0x200
   264dc:	e3530000 	cmp	r3, #0
   264e0:	0a000007 	beq	26504 <_svfiprintf_r+0x830>
   264e4:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   264e8:	e2832004 	add	r2, r3, #4
   264ec:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   264f0:	e5933000 	ldr	r3, [r3]
   264f4:	e20330ff 	and	r3, r3, #255	; 0xff
   264f8:	e20320ff 	and	r2, r3, #255	; 0xff
   264fc:	e3a03000 	mov	r3, #0
   26500:	ea000005 	b	2651c <_svfiprintf_r+0x848>
   26504:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   26508:	e2832004 	add	r2, r3, #4
   2650c:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   26510:	e5933000 	ldr	r3, [r3]
   26514:	e1a02003 	mov	r2, r3
   26518:	e3a03000 	mov	r3, #0
   2651c:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   26520:	e50b3040 	str	r3, [fp, #-64]	; 0x40
			base = OCT;
   26524:	e3a03000 	mov	r3, #0
   26528:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
   2652c:	e3c44b01 	bic	r4, r4, #1024	; 0x400
#endif
			goto nosign;
   26530:	ea0000c2 	b	26840 <_svfiprintf_r+0xb6c>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   26534:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   26538:	e2832004 	add	r2, r3, #4
   2653c:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   26540:	e5933000 	ldr	r3, [r3]
   26544:	e1a02003 	mov	r2, r3
   26548:	e3a03000 	mov	r3, #0
   2654c:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   26550:	e50b3040 	str	r3, [fp, #-64]	; 0x40
			base = HEX;
   26554:	e3a03002 	mov	r3, #2
   26558:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
			xdigs = "0123456789abcdef";
   2655c:	e59f3c34 	ldr	r3, [pc, #3124]	; 27198 <_svfiprintf_r+0x14c4>
   26560:	e50b3058 	str	r3, [fp, #-88]	; 0x58
			flags |= HEXPREFIX;
   26564:	e3844002 	orr	r4, r4, #2
			ox[0] = '0';
   26568:	e3a03030 	mov	r3, #48	; 0x30
   2656c:	e54b311c 	strb	r3, [fp, #-284]	; 0x11c
			ox[1] = ch = 'x';
   26570:	e3a09078 	mov	r9, #120	; 0x78
   26574:	e3a03078 	mov	r3, #120	; 0x78
   26578:	e54b311b 	strb	r3, [fp, #-283]	; 0x11b
			goto nosign;
   2657c:	ea0000af 	b	26840 <_svfiprintf_r+0xb6c>
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   26580:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   26584:	e2832004 	add	r2, r3, #4
   26588:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   2658c:	e5936000 	ldr	r6, [r3]
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
   26590:	e3a03000 	mov	r3, #0
   26594:	e54b3065 	strb	r3, [fp, #-101]	; 0x65
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
   26598:	e3560000 	cmp	r6, #0
   2659c:	1a000006 	bne	265bc <_svfiprintf_r+0x8e8>
				cp = "(null)";
   265a0:	e59f6bf4 	ldr	r6, [pc, #3060]	; 2719c <_svfiprintf_r+0x14c8>
				size = ((unsigned) prec > 6U) ? 6 : prec;
   265a4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   265a8:	e3530006 	cmp	r3, #6
   265ac:	31a03003 	movcc	r3, r3
   265b0:	23a03006 	movcs	r3, #6
   265b4:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   265b8:	ea00001f 	b	2663c <_svfiprintf_r+0x968>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
   265bc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   265c0:	e3530000 	cmp	r3, #0
   265c4:	ba000017 	blt	26628 <_svfiprintf_r+0x954>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
   265c8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   265cc:	e1a00006 	mov	r0, r6
   265d0:	e3a01000 	mov	r1, #0
   265d4:	e1a02003 	mov	r2, r3
   265d8:	ebfff00b 	bl	2260c <memchr>
   265dc:	e50b0064 	str	r0, [fp, #-100]	; 0x64

				if (p != NULL) {
   265e0:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   265e4:	e3530000 	cmp	r3, #0
   265e8:	0a00000a 	beq	26618 <_svfiprintf_r+0x944>
					size = p - cp;
   265ec:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
   265f0:	e1a03006 	mov	r3, r6
   265f4:	e0633002 	rsb	r3, r3, r2
   265f8:	e50b3054 	str	r3, [fp, #-84]	; 0x54
					if (size > prec)
   265fc:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   26600:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   26604:	e1520003 	cmp	r2, r3
   26608:	da000005 	ble	26624 <_svfiprintf_r+0x950>
						size = prec;
   2660c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   26610:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   26614:	ea000008 	b	2663c <_svfiprintf_r+0x968>
				} else
					size = prec;
   26618:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2661c:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   26620:	ea000005 	b	2663c <_svfiprintf_r+0x968>
   26624:	ea000004 	b	2663c <_svfiprintf_r+0x968>
			} else
				size = strlen (cp);
   26628:	e1a00006 	mov	r0, r6
   2662c:	ebffcb1f 	bl	192b0 <strlen>
   26630:	e1a03000 	mov	r3, r0
   26634:	e50b3054 	str	r3, [fp, #-84]	; 0x54

			break;
   26638:	ea000145 	b	26b54 <_svfiprintf_r+0xe80>
   2663c:	ea000144 	b	26b54 <_svfiprintf_r+0xe80>
		case 'U': /* extension */
			flags |= LONGINT;
   26640:	e3844010 	orr	r4, r4, #16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   26644:	e2043020 	and	r3, r4, #32
   26648:	e3530000 	cmp	r3, #0
   2664c:	0a000006 	beq	2666c <_svfiprintf_r+0x998>
   26650:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   26654:	e2833007 	add	r3, r3, #7
   26658:	e3c33007 	bic	r3, r3, #7
   2665c:	e2832008 	add	r2, r3, #8
   26660:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   26664:	e893000c 	ldm	r3, {r2, r3}
   26668:	ea000027 	b	2670c <_svfiprintf_r+0xa38>
   2666c:	e2043010 	and	r3, r4, #16
   26670:	e3530000 	cmp	r3, #0
   26674:	0a000006 	beq	26694 <_svfiprintf_r+0x9c0>
   26678:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   2667c:	e2832004 	add	r2, r3, #4
   26680:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   26684:	e5933000 	ldr	r3, [r3]
   26688:	e1a02003 	mov	r2, r3
   2668c:	e3a03000 	mov	r3, #0
   26690:	ea00001d 	b	2670c <_svfiprintf_r+0xa38>
   26694:	e2043040 	and	r3, r4, #64	; 0x40
   26698:	e3530000 	cmp	r3, #0
   2669c:	0a000009 	beq	266c8 <_svfiprintf_r+0x9f4>
   266a0:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   266a4:	e2832004 	add	r2, r3, #4
   266a8:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   266ac:	e5933000 	ldr	r3, [r3]
   266b0:	e1a03803 	lsl	r3, r3, #16
   266b4:	e1a01823 	lsr	r1, r3, #16
   266b8:	e1a03001 	mov	r3, r1
   266bc:	e1a02003 	mov	r2, r3
   266c0:	e3a03000 	mov	r3, #0
   266c4:	ea000010 	b	2670c <_svfiprintf_r+0xa38>
   266c8:	e2043c02 	and	r3, r4, #512	; 0x200
   266cc:	e3530000 	cmp	r3, #0
   266d0:	0a000007 	beq	266f4 <_svfiprintf_r+0xa20>
   266d4:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   266d8:	e2832004 	add	r2, r3, #4
   266dc:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   266e0:	e5933000 	ldr	r3, [r3]
   266e4:	e20330ff 	and	r3, r3, #255	; 0xff
   266e8:	e20320ff 	and	r2, r3, #255	; 0xff
   266ec:	e3a03000 	mov	r3, #0
   266f0:	ea000005 	b	2670c <_svfiprintf_r+0xa38>
   266f4:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   266f8:	e2832004 	add	r2, r3, #4
   266fc:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   26700:	e5933000 	ldr	r3, [r3]
   26704:	e1a02003 	mov	r2, r3
   26708:	e3a03000 	mov	r3, #0
   2670c:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   26710:	e50b3040 	str	r3, [fp, #-64]	; 0x40
			base = DEC;
   26714:	e3a03001 	mov	r3, #1
   26718:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
			goto nosign;
   2671c:	ea000047 	b	26840 <_svfiprintf_r+0xb6c>
		case 'X':
			xdigs = "0123456789ABCDEF";
   26720:	e59f3a78 	ldr	r3, [pc, #2680]	; 271a0 <_svfiprintf_r+0x14cc>
   26724:	e50b3058 	str	r3, [fp, #-88]	; 0x58
			goto hex;
   26728:	ea000001 	b	26734 <_svfiprintf_r+0xa60>
		case 'x':
			xdigs = "0123456789abcdef";
   2672c:	e59f3a64 	ldr	r3, [pc, #2660]	; 27198 <_svfiprintf_r+0x14c4>
   26730:	e50b3058 	str	r3, [fp, #-88]	; 0x58
hex:			_uquad = UARG ();
   26734:	e2043020 	and	r3, r4, #32
   26738:	e3530000 	cmp	r3, #0
   2673c:	0a000006 	beq	2675c <_svfiprintf_r+0xa88>
   26740:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   26744:	e2833007 	add	r3, r3, #7
   26748:	e3c33007 	bic	r3, r3, #7
   2674c:	e2832008 	add	r2, r3, #8
   26750:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   26754:	e893000c 	ldm	r3, {r2, r3}
   26758:	ea000027 	b	267fc <_svfiprintf_r+0xb28>
   2675c:	e2043010 	and	r3, r4, #16
   26760:	e3530000 	cmp	r3, #0
   26764:	0a000006 	beq	26784 <_svfiprintf_r+0xab0>
   26768:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   2676c:	e2832004 	add	r2, r3, #4
   26770:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   26774:	e5933000 	ldr	r3, [r3]
   26778:	e1a02003 	mov	r2, r3
   2677c:	e3a03000 	mov	r3, #0
   26780:	ea00001d 	b	267fc <_svfiprintf_r+0xb28>
   26784:	e2043040 	and	r3, r4, #64	; 0x40
   26788:	e3530000 	cmp	r3, #0
   2678c:	0a000009 	beq	267b8 <_svfiprintf_r+0xae4>
   26790:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   26794:	e2832004 	add	r2, r3, #4
   26798:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   2679c:	e5933000 	ldr	r3, [r3]
   267a0:	e1a03803 	lsl	r3, r3, #16
   267a4:	e1a01823 	lsr	r1, r3, #16
   267a8:	e1a03001 	mov	r3, r1
   267ac:	e1a02003 	mov	r2, r3
   267b0:	e3a03000 	mov	r3, #0
   267b4:	ea000010 	b	267fc <_svfiprintf_r+0xb28>
   267b8:	e2043c02 	and	r3, r4, #512	; 0x200
   267bc:	e3530000 	cmp	r3, #0
   267c0:	0a000007 	beq	267e4 <_svfiprintf_r+0xb10>
   267c4:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   267c8:	e2832004 	add	r2, r3, #4
   267cc:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   267d0:	e5933000 	ldr	r3, [r3]
   267d4:	e20330ff 	and	r3, r3, #255	; 0xff
   267d8:	e20320ff 	and	r2, r3, #255	; 0xff
   267dc:	e3a03000 	mov	r3, #0
   267e0:	ea000005 	b	267fc <_svfiprintf_r+0xb28>
   267e4:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   267e8:	e2832004 	add	r2, r3, #4
   267ec:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   267f0:	e5933000 	ldr	r3, [r3]
   267f4:	e1a02003 	mov	r2, r3
   267f8:	e3a03000 	mov	r3, #0
   267fc:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   26800:	e50b3040 	str	r3, [fp, #-64]	; 0x40
			base = HEX;
   26804:	e3a03002 	mov	r3, #2
   26808:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
   2680c:	e2043001 	and	r3, r4, #1
   26810:	e3530000 	cmp	r3, #0
   26814:	0a000008 	beq	2683c <_svfiprintf_r+0xb68>
   26818:	e24b3044 	sub	r3, fp, #68	; 0x44
   2681c:	e893000c 	ldm	r3, {r2, r3}
   26820:	e1921003 	orrs	r1, r2, r3
   26824:	0a000004 	beq	2683c <_svfiprintf_r+0xb68>
				ox[0] = '0';
   26828:	e3a03030 	mov	r3, #48	; 0x30
   2682c:	e54b311c 	strb	r3, [fp, #-284]	; 0x11c
				ox[1] = ch;
   26830:	e20930ff 	and	r3, r9, #255	; 0xff
   26834:	e54b311b 	strb	r3, [fp, #-283]	; 0x11b
				flags |= HEXPREFIX;
   26838:	e3844002 	orr	r4, r4, #2
			}

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
   2683c:	e3c44b01 	bic	r4, r4, #1024	; 0x400
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   26840:	e3a03000 	mov	r3, #0
   26844:	e54b3065 	strb	r3, [fp, #-101]	; 0x65
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   26848:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2684c:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   26850:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   26854:	e3530000 	cmp	r3, #0
   26858:	ba000000 	blt	26860 <_svfiprintf_r+0xb8c>
				flags &= ~ZEROPAD;
   2685c:	e3c44080 	bic	r4, r4, #128	; 0x80
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   26860:	e24b6f46 	sub	r6, fp, #280	; 0x118
   26864:	e2866064 	add	r6, r6, #100	; 0x64
			if (_uquad != 0 || prec != 0) {
   26868:	e24b3044 	sub	r3, fp, #68	; 0x44
   2686c:	e893000c 	ldm	r3, {r2, r3}
   26870:	e1921003 	orrs	r1, r2, r3
   26874:	1a000002 	bne	26884 <_svfiprintf_r+0xbb0>
   26878:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2687c:	e3530000 	cmp	r3, #0
   26880:	0a000099 	beq	26aec <_svfiprintf_r+0xe18>
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   26884:	e55b3045 	ldrb	r3, [fp, #-69]	; 0x45
   26888:	e3530001 	cmp	r3, #1
   2688c:	0a000026 	beq	2692c <_svfiprintf_r+0xc58>
   26890:	e3530002 	cmp	r3, #2
   26894:	0a000073 	beq	26a68 <_svfiprintf_r+0xd94>
   26898:	e3530000 	cmp	r3, #0
   2689c:	1a00008a 	bne	26acc <_svfiprintf_r+0xdf8>
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   268a0:	e2466001 	sub	r6, r6, #1
   268a4:	e55b3044 	ldrb	r3, [fp, #-68]	; 0x44
   268a8:	e2033007 	and	r3, r3, #7
   268ac:	e20330ff 	and	r3, r3, #255	; 0xff
   268b0:	e2833030 	add	r3, r3, #48	; 0x30
   268b4:	e20330ff 	and	r3, r3, #255	; 0xff
   268b8:	e5c63000 	strb	r3, [r6]
						_uquad >>= 3;
   268bc:	e24b3044 	sub	r3, fp, #68	; 0x44
   268c0:	e893000c 	ldm	r3, {r2, r3}
   268c4:	e1a011a2 	lsr	r1, r2, #3
   268c8:	e50b1134 	str	r1, [fp, #-308]	; 0x134
   268cc:	e51b1134 	ldr	r1, [fp, #-308]	; 0x134
   268d0:	e1811e83 	orr	r1, r1, r3, lsl #29
   268d4:	e50b1134 	str	r1, [fp, #-308]	; 0x134
   268d8:	e1a011a3 	lsr	r1, r3, #3
   268dc:	e50b1130 	str	r1, [fp, #-304]	; 0x130
   268e0:	e24b3f4d 	sub	r3, fp, #308	; 0x134
   268e4:	e893000c 	ldm	r3, {r2, r3}
   268e8:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   268ec:	e50b3040 	str	r3, [fp, #-64]	; 0x40
					} while (_uquad);
   268f0:	e24b3044 	sub	r3, fp, #68	; 0x44
   268f4:	e893000c 	ldm	r3, {r2, r3}
   268f8:	e1921003 	orrs	r1, r2, r3
   268fc:	1affffe7 	bne	268a0 <_svfiprintf_r+0xbcc>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
   26900:	e2043001 	and	r3, r4, #1
   26904:	e3530000 	cmp	r3, #0
   26908:	0a000006 	beq	26928 <_svfiprintf_r+0xc54>
   2690c:	e5d63000 	ldrb	r3, [r6]
   26910:	e3530030 	cmp	r3, #48	; 0x30
   26914:	0a000003 	beq	26928 <_svfiprintf_r+0xc54>
						*--cp = '0';
   26918:	e2466001 	sub	r6, r6, #1
   2691c:	e3a03030 	mov	r3, #48	; 0x30
   26920:	e5c63000 	strb	r3, [r6]
					break;
   26924:	ea00006f 	b	26ae8 <_svfiprintf_r+0xe14>
   26928:	ea00006e 	b	26ae8 <_svfiprintf_r+0xe14>

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   2692c:	e24b3044 	sub	r3, fp, #68	; 0x44
   26930:	e893000c 	ldm	r3, {r2, r3}
   26934:	e3530000 	cmp	r3, #0
   26938:	03520009 	cmpeq	r2, #9
   2693c:	8a000005 	bhi	26958 <_svfiprintf_r+0xc84>
						*--cp = to_char(_uquad);
   26940:	e2466001 	sub	r6, r6, #1
   26944:	e55b3044 	ldrb	r3, [fp, #-68]	; 0x44
   26948:	e2833030 	add	r3, r3, #48	; 0x30
   2694c:	e20330ff 	and	r3, r3, #255	; 0xff
   26950:	e5c63000 	strb	r3, [r6]
						break;
   26954:	ea000063 	b	26ae8 <_svfiprintf_r+0xe14>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
   26958:	e3a03000 	mov	r3, #0
   2695c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   26960:	e2466001 	sub	r6, r6, #1
   26964:	e24b3044 	sub	r3, fp, #68	; 0x44
   26968:	e893000c 	ldm	r3, {r2, r3}
   2696c:	e1a00002 	mov	r0, r2
   26970:	e1a01003 	mov	r1, r3
   26974:	e3a0200a 	mov	r2, #10
   26978:	e3a03000 	mov	r3, #0
   2697c:	ebffb9ff 	bl	15180 <__aeabi_uldivmod>
   26980:	e20230ff 	and	r3, r2, #255	; 0xff
   26984:	e2833030 	add	r3, r3, #48	; 0x30
   26988:	e20330ff 	and	r3, r3, #255	; 0xff
   2698c:	e5c63000 	strb	r3, [r6]
#ifdef _WANT_IO_C99_FORMATS
					  ndig++;
   26990:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   26994:	e2833001 	add	r3, r3, #1
   26998:	e50b3038 	str	r3, [fp, #-56]	; 0x38
					  /* If (*grouping == CHAR_MAX) then no
					     more grouping */
					  if ((flags & GROUPING)
   2699c:	e2043b01 	and	r3, r4, #1024	; 0x400
   269a0:	e3530000 	cmp	r3, #0
   269a4:	0a00001f 	beq	26a28 <_svfiprintf_r+0xd54>
					      && ndig == *grouping
   269a8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   269ac:	e5d33000 	ldrb	r3, [r3]
   269b0:	e1a02003 	mov	r2, r3
   269b4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   269b8:	e1520003 	cmp	r2, r3
   269bc:	1a000019 	bne	26a28 <_svfiprintf_r+0xd54>
					      && *grouping != CHAR_MAX
   269c0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   269c4:	e5d33000 	ldrb	r3, [r3]
   269c8:	e35300ff 	cmp	r3, #255	; 0xff
   269cc:	0a000015 	beq	26a28 <_svfiprintf_r+0xd54>
					      && _uquad > 9) {
   269d0:	e24b3044 	sub	r3, fp, #68	; 0x44
   269d4:	e893000c 	ldm	r3, {r2, r3}
   269d8:	e3530000 	cmp	r3, #0
   269dc:	03520009 	cmpeq	r2, #9
   269e0:	9a000010 	bls	26a28 <_svfiprintf_r+0xd54>
					    cp -= thsnd_len;
   269e4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   269e8:	e2633000 	rsb	r3, r3, #0
   269ec:	e0866003 	add	r6, r6, r3
					    strncpy (cp, thousands_sep,
   269f0:	e1a00006 	mov	r0, r6
   269f4:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
   269f8:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   269fc:	ebfffb9b 	bl	25870 <strncpy>
						     thsnd_len);
					    ndig = 0;
   26a00:	e3a03000 	mov	r3, #0
   26a04:	e50b3038 	str	r3, [fp, #-56]	; 0x38
					    /* If (grouping[1] == '\0') then we
					       have to use *grouping character
					       (last grouping rule) for all
					       next cases. */
					    if (grouping[1] != '\0')
   26a08:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   26a0c:	e2833001 	add	r3, r3, #1
   26a10:	e5d33000 	ldrb	r3, [r3]
   26a14:	e3530000 	cmp	r3, #0
   26a18:	0a000002 	beq	26a28 <_svfiprintf_r+0xd54>
					      grouping++;
   26a1c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   26a20:	e2833001 	add	r3, r3, #1
   26a24:	e50b3034 	str	r3, [fp, #-52]	; 0x34
					  }
#endif
					  _uquad /= 10;
   26a28:	e24b3044 	sub	r3, fp, #68	; 0x44
   26a2c:	e893000c 	ldm	r3, {r2, r3}
   26a30:	e1a00002 	mov	r0, r2
   26a34:	e1a01003 	mov	r1, r3
   26a38:	e3a0200a 	mov	r2, #10
   26a3c:	e3a03000 	mov	r3, #0
   26a40:	ebffb9ce 	bl	15180 <__aeabi_uldivmod>
   26a44:	e1a02000 	mov	r2, r0
   26a48:	e1a03001 	mov	r3, r1
   26a4c:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   26a50:	e50b3040 	str	r3, [fp, #-64]	; 0x40
					} while (_uquad != 0);
   26a54:	e24b3044 	sub	r3, fp, #68	; 0x44
   26a58:	e893000c 	ldm	r3, {r2, r3}
   26a5c:	e1921003 	orrs	r1, r2, r3
   26a60:	1affffbe 	bne	26960 <_svfiprintf_r+0xc8c>
					break;
   26a64:	ea00001f 	b	26ae8 <_svfiprintf_r+0xe14>

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   26a68:	e2466001 	sub	r6, r6, #1
   26a6c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   26a70:	e203300f 	and	r3, r3, #15
   26a74:	e51b2058 	ldr	r2, [fp, #-88]	; 0x58
   26a78:	e0823003 	add	r3, r2, r3
   26a7c:	e5d33000 	ldrb	r3, [r3]
   26a80:	e5c63000 	strb	r3, [r6]
						_uquad >>= 4;
   26a84:	e24b3044 	sub	r3, fp, #68	; 0x44
   26a88:	e893000c 	ldm	r3, {r2, r3}
   26a8c:	e1a01222 	lsr	r1, r2, #4
   26a90:	e50b113c 	str	r1, [fp, #-316]	; 0x13c
   26a94:	e51b113c 	ldr	r1, [fp, #-316]	; 0x13c
   26a98:	e1811e03 	orr	r1, r1, r3, lsl #28
   26a9c:	e50b113c 	str	r1, [fp, #-316]	; 0x13c
   26aa0:	e1a01223 	lsr	r1, r3, #4
   26aa4:	e50b1138 	str	r1, [fp, #-312]	; 0x138
   26aa8:	e24b3f4f 	sub	r3, fp, #316	; 0x13c
   26aac:	e893000c 	ldm	r3, {r2, r3}
   26ab0:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   26ab4:	e50b3040 	str	r3, [fp, #-64]	; 0x40
					} while (_uquad);
   26ab8:	e24b3044 	sub	r3, fp, #68	; 0x44
   26abc:	e893000c 	ldm	r3, {r2, r3}
   26ac0:	e1921003 	orrs	r1, r2, r3
   26ac4:	1affffe7 	bne	26a68 <_svfiprintf_r+0xd94>
					break;
   26ac8:	ea000006 	b	26ae8 <_svfiprintf_r+0xe14>

				default:
					cp = "bug in vfprintf: bad base";
   26acc:	e59f66d0 	ldr	r6, [pc, #1744]	; 271a4 <_svfiprintf_r+0x14d0>
					size = strlen (cp);
   26ad0:	e1a00006 	mov	r0, r6
   26ad4:	ebffc9f5 	bl	192b0 <strlen>
   26ad8:	e1a03000 	mov	r3, r0
   26adc:	e50b3054 	str	r3, [fp, #-84]	; 0x54
					goto skipsize;
   26ae0:	e1a00000 	nop			; (mov r0, r0)
                       else if (base == OCT && (flags & ALT))
                         *--cp = '0';

			size = buf + BUF - cp;
		skipsize:
			break;
   26ae4:	ea00001a 	b	26b54 <_svfiprintf_r+0xe80>
				default:
					cp = "bug in vfprintf: bad base";
					size = strlen (cp);
					goto skipsize;
				}
			}
   26ae8:	ea000008 	b	26b10 <_svfiprintf_r+0xe3c>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   26aec:	e55b3045 	ldrb	r3, [fp, #-69]	; 0x45
   26af0:	e3530000 	cmp	r3, #0
   26af4:	1a000005 	bne	26b10 <_svfiprintf_r+0xe3c>
   26af8:	e2043001 	and	r3, r4, #1
   26afc:	e3530000 	cmp	r3, #0
   26b00:	0a000002 	beq	26b10 <_svfiprintf_r+0xe3c>
                         *--cp = '0';
   26b04:	e2466001 	sub	r6, r6, #1
   26b08:	e3a03030 	mov	r3, #48	; 0x30
   26b0c:	e5c63000 	strb	r3, [r6]

			size = buf + BUF - cp;
   26b10:	e24b3f46 	sub	r3, fp, #280	; 0x118
   26b14:	e2833064 	add	r3, r3, #100	; 0x64
   26b18:	e1a02006 	mov	r2, r6
   26b1c:	e0623003 	rsb	r3, r2, r3
   26b20:	e50b3054 	str	r3, [fp, #-84]	; 0x54
		skipsize:
			break;
   26b24:	ea00000a 	b	26b54 <_svfiprintf_r+0xe80>
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
   26b28:	e3590000 	cmp	r9, #0
   26b2c:	1a000000 	bne	26b34 <_svfiprintf_r+0xe60>
				goto done;
   26b30:	ea000174 	b	27108 <_svfiprintf_r+0x1434>
			/* pretend it was %c with argument ch */
			cp = buf;
   26b34:	e24b6f46 	sub	r6, fp, #280	; 0x118
			*cp = ch;
   26b38:	e20930ff 	and	r3, r9, #255	; 0xff
   26b3c:	e5c63000 	strb	r3, [r6]
			size = 1;
   26b40:	e3a03001 	mov	r3, #1
   26b44:	e50b3054 	str	r3, [fp, #-84]	; 0x54
			sign = '\0';
   26b48:	e3a03000 	mov	r3, #0
   26b4c:	e54b3065 	strb	r3, [fp, #-101]	; 0x65
			break;
   26b50:	e1a00000 	nop			; (mov r0, r0)
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
   26b54:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   26b58:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   26b5c:	e1520003 	cmp	r2, r3
   26b60:	a1a03002 	movge	r3, r2
   26b64:	b1a03003 	movlt	r3, r3
   26b68:	e50b3050 	str	r3, [fp, #-80]	; 0x50
		if (sign)
   26b6c:	e55b3065 	ldrb	r3, [fp, #-101]	; 0x65
   26b70:	e3530000 	cmp	r3, #0
   26b74:	0a000002 	beq	26b84 <_svfiprintf_r+0xeb0>
			realsz++;
   26b78:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   26b7c:	e2833001 	add	r3, r3, #1
   26b80:	e50b3050 	str	r3, [fp, #-80]	; 0x50
		if (flags & HEXPREFIX)
   26b84:	e2043002 	and	r3, r4, #2
   26b88:	e3530000 	cmp	r3, #0
   26b8c:	0a000002 	beq	26b9c <_svfiprintf_r+0xec8>
			realsz+= 2;
   26b90:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   26b94:	e2833002 	add	r3, r3, #2
   26b98:	e50b3050 	str	r3, [fp, #-80]	; 0x50

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   26b9c:	e2043084 	and	r3, r4, #132	; 0x84
   26ba0:	e3530000 	cmp	r3, #0
   26ba4:	1a000038 	bne	26c8c <_svfiprintf_r+0xfb8>
			PAD (width - realsz, blanks);
   26ba8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   26bac:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   26bb0:	e0637002 	rsb	r7, r3, r2
   26bb4:	e3570000 	cmp	r7, #0
   26bb8:	da000033 	ble	26c8c <_svfiprintf_r+0xfb8>
   26bbc:	ea000018 	b	26c24 <_svfiprintf_r+0xf50>
   26bc0:	e59f35e0 	ldr	r3, [pc, #1504]	; 271a8 <_svfiprintf_r+0x14d4>
   26bc4:	e5853000 	str	r3, [r5]
   26bc8:	e3a03010 	mov	r3, #16
   26bcc:	e5853004 	str	r3, [r5, #4]
   26bd0:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   26bd4:	e2833010 	add	r3, r3, #16
   26bd8:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   26bdc:	e2855008 	add	r5, r5, #8
   26be0:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26be4:	e2833001 	add	r3, r3, #1
   26be8:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   26bec:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26bf0:	e3530007 	cmp	r3, #7
   26bf4:	da000009 	ble	26c20 <_svfiprintf_r+0xf4c>
   26bf8:	e24b3074 	sub	r3, fp, #116	; 0x74
   26bfc:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   26c00:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   26c04:	e1a02003 	mov	r2, r3
   26c08:	ebfffb74 	bl	259e0 <__ssprint_r>
   26c0c:	e1a03000 	mov	r3, r0
   26c10:	e3530000 	cmp	r3, #0
   26c14:	0a000000 	beq	26c1c <_svfiprintf_r+0xf48>
   26c18:	ea000149 	b	27144 <_svfiprintf_r+0x1470>
   26c1c:	e24b50b4 	sub	r5, fp, #180	; 0xb4
   26c20:	e2477010 	sub	r7, r7, #16
   26c24:	e3570010 	cmp	r7, #16
   26c28:	caffffe4 	bgt	26bc0 <_svfiprintf_r+0xeec>
   26c2c:	e59f3574 	ldr	r3, [pc, #1396]	; 271a8 <_svfiprintf_r+0x14d4>
   26c30:	e5853000 	str	r3, [r5]
   26c34:	e1a03007 	mov	r3, r7
   26c38:	e5853004 	str	r3, [r5, #4]
   26c3c:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   26c40:	e0833007 	add	r3, r3, r7
   26c44:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   26c48:	e2855008 	add	r5, r5, #8
   26c4c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26c50:	e2833001 	add	r3, r3, #1
   26c54:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   26c58:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26c5c:	e3530007 	cmp	r3, #7
   26c60:	da000009 	ble	26c8c <_svfiprintf_r+0xfb8>
   26c64:	e24b3074 	sub	r3, fp, #116	; 0x74
   26c68:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   26c6c:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   26c70:	e1a02003 	mov	r2, r3
   26c74:	ebfffb59 	bl	259e0 <__ssprint_r>
   26c78:	e1a03000 	mov	r3, r0
   26c7c:	e3530000 	cmp	r3, #0
   26c80:	0a000000 	beq	26c88 <_svfiprintf_r+0xfb4>
   26c84:	ea00012e 	b	27144 <_svfiprintf_r+0x1470>
   26c88:	e24b50b4 	sub	r5, fp, #180	; 0xb4

		/* prefix */
		if (sign)
   26c8c:	e55b3065 	ldrb	r3, [fp, #-101]	; 0x65
   26c90:	e3530000 	cmp	r3, #0
   26c94:	0a000017 	beq	26cf8 <_svfiprintf_r+0x1024>
			PRINT (&sign, 1);
   26c98:	e24b3065 	sub	r3, fp, #101	; 0x65
   26c9c:	e5853000 	str	r3, [r5]
   26ca0:	e3a03001 	mov	r3, #1
   26ca4:	e5853004 	str	r3, [r5, #4]
   26ca8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   26cac:	e2833001 	add	r3, r3, #1
   26cb0:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   26cb4:	e2855008 	add	r5, r5, #8
   26cb8:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26cbc:	e2833001 	add	r3, r3, #1
   26cc0:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   26cc4:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26cc8:	e3530007 	cmp	r3, #7
   26ccc:	da000009 	ble	26cf8 <_svfiprintf_r+0x1024>
   26cd0:	e24b3074 	sub	r3, fp, #116	; 0x74
   26cd4:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   26cd8:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   26cdc:	e1a02003 	mov	r2, r3
   26ce0:	ebfffb3e 	bl	259e0 <__ssprint_r>
   26ce4:	e1a03000 	mov	r3, r0
   26ce8:	e3530000 	cmp	r3, #0
   26cec:	0a000000 	beq	26cf4 <_svfiprintf_r+0x1020>
   26cf0:	ea000113 	b	27144 <_svfiprintf_r+0x1470>
   26cf4:	e24b50b4 	sub	r5, fp, #180	; 0xb4
		if (flags & HEXPREFIX)
   26cf8:	e2043002 	and	r3, r4, #2
   26cfc:	e3530000 	cmp	r3, #0
   26d00:	0a000017 	beq	26d64 <_svfiprintf_r+0x1090>
			PRINT (ox, 2);
   26d04:	e24b3f47 	sub	r3, fp, #284	; 0x11c
   26d08:	e5853000 	str	r3, [r5]
   26d0c:	e3a03002 	mov	r3, #2
   26d10:	e5853004 	str	r3, [r5, #4]
   26d14:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   26d18:	e2833002 	add	r3, r3, #2
   26d1c:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   26d20:	e2855008 	add	r5, r5, #8
   26d24:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26d28:	e2833001 	add	r3, r3, #1
   26d2c:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   26d30:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26d34:	e3530007 	cmp	r3, #7
   26d38:	da000009 	ble	26d64 <_svfiprintf_r+0x1090>
   26d3c:	e24b3074 	sub	r3, fp, #116	; 0x74
   26d40:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   26d44:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   26d48:	e1a02003 	mov	r2, r3
   26d4c:	ebfffb23 	bl	259e0 <__ssprint_r>
   26d50:	e1a03000 	mov	r3, r0
   26d54:	e3530000 	cmp	r3, #0
   26d58:	0a000000 	beq	26d60 <_svfiprintf_r+0x108c>
   26d5c:	ea0000f8 	b	27144 <_svfiprintf_r+0x1470>
   26d60:	e24b50b4 	sub	r5, fp, #180	; 0xb4

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   26d64:	e2043084 	and	r3, r4, #132	; 0x84
   26d68:	e3530080 	cmp	r3, #128	; 0x80
   26d6c:	1a000038 	bne	26e54 <_svfiprintf_r+0x1180>
			PAD (width - realsz, zeroes);
   26d70:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   26d74:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   26d78:	e0637002 	rsb	r7, r3, r2
   26d7c:	e3570000 	cmp	r7, #0
   26d80:	da000033 	ble	26e54 <_svfiprintf_r+0x1180>
   26d84:	ea000018 	b	26dec <_svfiprintf_r+0x1118>
   26d88:	e59f341c 	ldr	r3, [pc, #1052]	; 271ac <_svfiprintf_r+0x14d8>
   26d8c:	e5853000 	str	r3, [r5]
   26d90:	e3a03010 	mov	r3, #16
   26d94:	e5853004 	str	r3, [r5, #4]
   26d98:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   26d9c:	e2833010 	add	r3, r3, #16
   26da0:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   26da4:	e2855008 	add	r5, r5, #8
   26da8:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26dac:	e2833001 	add	r3, r3, #1
   26db0:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   26db4:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26db8:	e3530007 	cmp	r3, #7
   26dbc:	da000009 	ble	26de8 <_svfiprintf_r+0x1114>
   26dc0:	e24b3074 	sub	r3, fp, #116	; 0x74
   26dc4:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   26dc8:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   26dcc:	e1a02003 	mov	r2, r3
   26dd0:	ebfffb02 	bl	259e0 <__ssprint_r>
   26dd4:	e1a03000 	mov	r3, r0
   26dd8:	e3530000 	cmp	r3, #0
   26ddc:	0a000000 	beq	26de4 <_svfiprintf_r+0x1110>
   26de0:	ea0000d7 	b	27144 <_svfiprintf_r+0x1470>
   26de4:	e24b50b4 	sub	r5, fp, #180	; 0xb4
   26de8:	e2477010 	sub	r7, r7, #16
   26dec:	e3570010 	cmp	r7, #16
   26df0:	caffffe4 	bgt	26d88 <_svfiprintf_r+0x10b4>
   26df4:	e59f33b0 	ldr	r3, [pc, #944]	; 271ac <_svfiprintf_r+0x14d8>
   26df8:	e5853000 	str	r3, [r5]
   26dfc:	e1a03007 	mov	r3, r7
   26e00:	e5853004 	str	r3, [r5, #4]
   26e04:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   26e08:	e0833007 	add	r3, r3, r7
   26e0c:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   26e10:	e2855008 	add	r5, r5, #8
   26e14:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26e18:	e2833001 	add	r3, r3, #1
   26e1c:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   26e20:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26e24:	e3530007 	cmp	r3, #7
   26e28:	da000009 	ble	26e54 <_svfiprintf_r+0x1180>
   26e2c:	e24b3074 	sub	r3, fp, #116	; 0x74
   26e30:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   26e34:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   26e38:	e1a02003 	mov	r2, r3
   26e3c:	ebfffae7 	bl	259e0 <__ssprint_r>
   26e40:	e1a03000 	mov	r3, r0
   26e44:	e3530000 	cmp	r3, #0
   26e48:	0a000000 	beq	26e50 <_svfiprintf_r+0x117c>
   26e4c:	ea0000bc 	b	27144 <_svfiprintf_r+0x1470>
   26e50:	e24b50b4 	sub	r5, fp, #180	; 0xb4

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   26e54:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   26e58:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   26e5c:	e0637002 	rsb	r7, r3, r2
   26e60:	e3570000 	cmp	r7, #0
   26e64:	da000033 	ble	26f38 <_svfiprintf_r+0x1264>
   26e68:	ea000018 	b	26ed0 <_svfiprintf_r+0x11fc>
   26e6c:	e59f3338 	ldr	r3, [pc, #824]	; 271ac <_svfiprintf_r+0x14d8>
   26e70:	e5853000 	str	r3, [r5]
   26e74:	e3a03010 	mov	r3, #16
   26e78:	e5853004 	str	r3, [r5, #4]
   26e7c:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   26e80:	e2833010 	add	r3, r3, #16
   26e84:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   26e88:	e2855008 	add	r5, r5, #8
   26e8c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26e90:	e2833001 	add	r3, r3, #1
   26e94:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   26e98:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26e9c:	e3530007 	cmp	r3, #7
   26ea0:	da000009 	ble	26ecc <_svfiprintf_r+0x11f8>
   26ea4:	e24b3074 	sub	r3, fp, #116	; 0x74
   26ea8:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   26eac:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   26eb0:	e1a02003 	mov	r2, r3
   26eb4:	ebfffac9 	bl	259e0 <__ssprint_r>
   26eb8:	e1a03000 	mov	r3, r0
   26ebc:	e3530000 	cmp	r3, #0
   26ec0:	0a000000 	beq	26ec8 <_svfiprintf_r+0x11f4>
   26ec4:	ea00009e 	b	27144 <_svfiprintf_r+0x1470>
   26ec8:	e24b50b4 	sub	r5, fp, #180	; 0xb4
   26ecc:	e2477010 	sub	r7, r7, #16
   26ed0:	e3570010 	cmp	r7, #16
   26ed4:	caffffe4 	bgt	26e6c <_svfiprintf_r+0x1198>
   26ed8:	e59f32cc 	ldr	r3, [pc, #716]	; 271ac <_svfiprintf_r+0x14d8>
   26edc:	e5853000 	str	r3, [r5]
   26ee0:	e1a03007 	mov	r3, r7
   26ee4:	e5853004 	str	r3, [r5, #4]
   26ee8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   26eec:	e0833007 	add	r3, r3, r7
   26ef0:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   26ef4:	e2855008 	add	r5, r5, #8
   26ef8:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26efc:	e2833001 	add	r3, r3, #1
   26f00:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   26f04:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26f08:	e3530007 	cmp	r3, #7
   26f0c:	da000009 	ble	26f38 <_svfiprintf_r+0x1264>
   26f10:	e24b3074 	sub	r3, fp, #116	; 0x74
   26f14:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   26f18:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   26f1c:	e1a02003 	mov	r2, r3
   26f20:	ebfffaae 	bl	259e0 <__ssprint_r>
   26f24:	e1a03000 	mov	r3, r0
   26f28:	e3530000 	cmp	r3, #0
   26f2c:	0a000000 	beq	26f34 <_svfiprintf_r+0x1260>
   26f30:	ea000083 	b	27144 <_svfiprintf_r+0x1470>
   26f34:	e24b50b4 	sub	r5, fp, #180	; 0xb4
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   26f38:	e5856000 	str	r6, [r5]
   26f3c:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   26f40:	e5853004 	str	r3, [r5, #4]
   26f44:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
   26f48:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   26f4c:	e0823003 	add	r3, r2, r3
   26f50:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   26f54:	e2855008 	add	r5, r5, #8
   26f58:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26f5c:	e2833001 	add	r3, r3, #1
   26f60:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   26f64:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26f68:	e3530007 	cmp	r3, #7
   26f6c:	da000009 	ble	26f98 <_svfiprintf_r+0x12c4>
   26f70:	e24b3074 	sub	r3, fp, #116	; 0x74
   26f74:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   26f78:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   26f7c:	e1a02003 	mov	r2, r3
   26f80:	ebfffa96 	bl	259e0 <__ssprint_r>
   26f84:	e1a03000 	mov	r3, r0
   26f88:	e3530000 	cmp	r3, #0
   26f8c:	0a000000 	beq	26f94 <_svfiprintf_r+0x12c0>
   26f90:	ea00006b 	b	27144 <_svfiprintf_r+0x1470>
   26f94:	e24b50b4 	sub	r5, fp, #180	; 0xb4
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   26f98:	e2043004 	and	r3, r4, #4
   26f9c:	e3530000 	cmp	r3, #0
   26fa0:	0a000038 	beq	27088 <_svfiprintf_r+0x13b4>
			PAD (width - realsz, blanks);
   26fa4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   26fa8:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   26fac:	e0637002 	rsb	r7, r3, r2
   26fb0:	e3570000 	cmp	r7, #0
   26fb4:	da000033 	ble	27088 <_svfiprintf_r+0x13b4>
   26fb8:	ea000018 	b	27020 <_svfiprintf_r+0x134c>
   26fbc:	e59f31e4 	ldr	r3, [pc, #484]	; 271a8 <_svfiprintf_r+0x14d4>
   26fc0:	e5853000 	str	r3, [r5]
   26fc4:	e3a03010 	mov	r3, #16
   26fc8:	e5853004 	str	r3, [r5, #4]
   26fcc:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   26fd0:	e2833010 	add	r3, r3, #16
   26fd4:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   26fd8:	e2855008 	add	r5, r5, #8
   26fdc:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26fe0:	e2833001 	add	r3, r3, #1
   26fe4:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   26fe8:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   26fec:	e3530007 	cmp	r3, #7
   26ff0:	da000009 	ble	2701c <_svfiprintf_r+0x1348>
   26ff4:	e24b3074 	sub	r3, fp, #116	; 0x74
   26ff8:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   26ffc:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   27000:	e1a02003 	mov	r2, r3
   27004:	ebfffa75 	bl	259e0 <__ssprint_r>
   27008:	e1a03000 	mov	r3, r0
   2700c:	e3530000 	cmp	r3, #0
   27010:	0a000000 	beq	27018 <_svfiprintf_r+0x1344>
   27014:	ea00004a 	b	27144 <_svfiprintf_r+0x1470>
   27018:	e24b50b4 	sub	r5, fp, #180	; 0xb4
   2701c:	e2477010 	sub	r7, r7, #16
   27020:	e3570010 	cmp	r7, #16
   27024:	caffffe4 	bgt	26fbc <_svfiprintf_r+0x12e8>
   27028:	e59f3178 	ldr	r3, [pc, #376]	; 271a8 <_svfiprintf_r+0x14d4>
   2702c:	e5853000 	str	r3, [r5]
   27030:	e1a03007 	mov	r3, r7
   27034:	e5853004 	str	r3, [r5, #4]
   27038:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   2703c:	e0833007 	add	r3, r3, r7
   27040:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   27044:	e2855008 	add	r5, r5, #8
   27048:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   2704c:	e2833001 	add	r3, r3, #1
   27050:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   27054:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   27058:	e3530007 	cmp	r3, #7
   2705c:	da000009 	ble	27088 <_svfiprintf_r+0x13b4>
   27060:	e24b3074 	sub	r3, fp, #116	; 0x74
   27064:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   27068:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   2706c:	e1a02003 	mov	r2, r3
   27070:	ebfffa5a 	bl	259e0 <__ssprint_r>
   27074:	e1a03000 	mov	r3, r0
   27078:	e3530000 	cmp	r3, #0
   2707c:	0a000000 	beq	27084 <_svfiprintf_r+0x13b0>
   27080:	ea00002f 	b	27144 <_svfiprintf_r+0x1470>
   27084:	e24b50b4 	sub	r5, fp, #180	; 0xb4

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   27088:	e51b2050 	ldr	r2, [fp, #-80]	; 0x50
   2708c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   27090:	e1520003 	cmp	r2, r3
   27094:	a1a03002 	movge	r3, r2
   27098:	b1a03003 	movlt	r3, r3
   2709c:	e51b2020 	ldr	r2, [fp, #-32]
   270a0:	e0823003 	add	r3, r2, r3
   270a4:	e50b3020 	str	r3, [fp, #-32]

		FLUSH ();	/* copy out the I/O vectors */
   270a8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   270ac:	e3530000 	cmp	r3, #0
   270b0:	0a000008 	beq	270d8 <_svfiprintf_r+0x1404>
   270b4:	e24b3074 	sub	r3, fp, #116	; 0x74
   270b8:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   270bc:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   270c0:	e1a02003 	mov	r2, r3
   270c4:	ebfffa45 	bl	259e0 <__ssprint_r>
   270c8:	e1a03000 	mov	r3, r0
   270cc:	e3530000 	cmp	r3, #0
   270d0:	0a000000 	beq	270d8 <_svfiprintf_r+0x1404>
   270d4:	ea00001a 	b	27144 <_svfiprintf_r+0x1470>
   270d8:	e3a03000 	mov	r3, #0
   270dc:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   270e0:	e24b50b4 	sub	r5, fp, #180	; 0xb4

                if (malloc_buf != NULL) {
   270e4:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   270e8:	e3530000 	cmp	r3, #0
   270ec:	0a000004 	beq	27104 <_svfiprintf_r+0x1430>
			_free_r (data, malloc_buf);
   270f0:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   270f4:	e51b105c 	ldr	r1, [fp, #-92]	; 0x5c
   270f8:	ebffbde4 	bl	16890 <_free_r>
			malloc_buf = NULL;
   270fc:	e3a03000 	mov	r3, #0
   27100:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
		}
	}
   27104:	eafffb2f 	b	25dc8 <_svfiprintf_r+0xf4>
done:
	FLUSH ();
   27108:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   2710c:	e3530000 	cmp	r3, #0
   27110:	0a000008 	beq	27138 <_svfiprintf_r+0x1464>
   27114:	e24b3074 	sub	r3, fp, #116	; 0x74
   27118:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   2711c:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   27120:	e1a02003 	mov	r2, r3
   27124:	ebfffa2d 	bl	259e0 <__ssprint_r>
   27128:	e1a03000 	mov	r3, r0
   2712c:	e3530000 	cmp	r3, #0
   27130:	0a000000 	beq	27138 <_svfiprintf_r+0x1464>
   27134:	ea000002 	b	27144 <_svfiprintf_r+0x1470>
   27138:	e3a03000 	mov	r3, #0
   2713c:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   27140:	e24b50b4 	sub	r5, fp, #180	; 0xb4
error:
	if (malloc_buf != NULL)
   27144:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   27148:	e3530000 	cmp	r3, #0
   2714c:	0a000002 	beq	2715c <_svfiprintf_r+0x1488>
		_free_r (data, malloc_buf);
   27150:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   27154:	e51b105c 	ldr	r1, [fp, #-92]	; 0x5c
   27158:	ebffbdcc 	bl	16890 <_free_r>
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
   2715c:	e51b3124 	ldr	r3, [fp, #-292]	; 0x124
   27160:	e1d330bc 	ldrh	r3, [r3, #12]
   27164:	e1a03803 	lsl	r3, r3, #16
   27168:	e1a03823 	lsr	r3, r3, #16
   2716c:	e2033040 	and	r3, r3, #64	; 0x40
   27170:	e3530000 	cmp	r3, #0
   27174:	1a000001 	bne	27180 <_svfiprintf_r+0x14ac>
   27178:	e51b3020 	ldr	r3, [fp, #-32]
   2717c:	ea000000 	b	27184 <_svfiprintf_r+0x14b0>
   27180:	e3e03000 	mvn	r3, #0
   27184:	e1a00000 	nop			; (mov r0, r0)
	/* NOTREACHED */
}
   27188:	e1a00003 	mov	r0, r3
   2718c:	e24bd01c 	sub	sp, fp, #28
   27190:	e8bd4bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, lr}
   27194:	e12fff1e 	bx	lr
   27198:	000332b8 	.word	0x000332b8
   2719c:	000332cc 	.word	0x000332cc
   271a0:	000332d4 	.word	0x000332d4
   271a4:	000332e8 	.word	0x000332e8
   271a8:	00033304 	.word	0x00033304
   271ac:	00033314 	.word	0x00033314

000271b0 <__sprint_r>:
int
_DEFUN(__sprint_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       FILE *fp _AND
       register struct __suio *uio)
{
   271b0:	e92d4830 	push	{r4, r5, fp, lr}
   271b4:	e28db00c 	add	fp, sp, #12
   271b8:	e24dd018 	sub	sp, sp, #24
   271bc:	e50b0020 	str	r0, [fp, #-32]
   271c0:	e50b1024 	str	r1, [fp, #-36]	; 0x24
   271c4:	e1a04002 	mov	r4, r2
	register int err = 0;
   271c8:	e3a05000 	mov	r5, #0

	if (uio->uio_resid == 0) {
   271cc:	e5943008 	ldr	r3, [r4, #8]
   271d0:	e3530000 	cmp	r3, #0
   271d4:	1a000003 	bne	271e8 <__sprint_r+0x38>
		uio->uio_iovcnt = 0;
   271d8:	e3a03000 	mov	r3, #0
   271dc:	e5843004 	str	r3, [r4, #4]
		return (0);
   271e0:	e3a03000 	mov	r3, #0
   271e4:	ea00003d 	b	272e0 <__sprint_r+0x130>
	}
#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
   271e8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   271ec:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
   271f0:	e2033a02 	and	r3, r3, #8192	; 0x2000
   271f4:	e3530000 	cmp	r3, #0
   271f8:	0a00002e 	beq	272b8 <__sprint_r+0x108>
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
   271fc:	e5943000 	ldr	r3, [r4]
   27200:	e50b3010 	str	r3, [fp, #-16]
		for (; uio->uio_resid != 0;
   27204:	ea000027 	b	272a8 <__sprint_r+0xf8>
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
   27208:	e51b3010 	ldr	r3, [fp, #-16]
   2720c:	e5933000 	ldr	r3, [r3]
   27210:	e50b3018 	str	r3, [fp, #-24]
			len = iov->iov_len / sizeof (wchar_t);
   27214:	e51b3010 	ldr	r3, [fp, #-16]
   27218:	e5933004 	ldr	r3, [r3, #4]
   2721c:	e1a03123 	lsr	r3, r3, #2
   27220:	e50b301c 	str	r3, [fp, #-28]
			for (i = 0; i < len; i++) {
   27224:	e3a03000 	mov	r3, #0
   27228:	e50b3014 	str	r3, [fp, #-20]
   2722c:	ea000010 	b	27274 <__sprint_r+0xc4>
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
   27230:	e51b3014 	ldr	r3, [fp, #-20]
   27234:	e1a03103 	lsl	r3, r3, #2
   27238:	e51b2018 	ldr	r2, [fp, #-24]
   2723c:	e0823003 	add	r3, r2, r3
   27240:	e5933000 	ldr	r3, [r3]
   27244:	e51b0020 	ldr	r0, [fp, #-32]
   27248:	e1a01003 	mov	r1, r3
   2724c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   27250:	eb000727 	bl	28ef4 <_fputwc_r>
   27254:	e1a03000 	mov	r3, r0
   27258:	e3730001 	cmn	r3, #1
   2725c:	1a000001 	bne	27268 <__sprint_r+0xb8>
					err = -1;
   27260:	e3e05000 	mvn	r5, #0
					goto out;
   27264:	ea000018 	b	272cc <__sprint_r+0x11c>
		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
			for (i = 0; i < len; i++) {
   27268:	e51b3014 	ldr	r3, [fp, #-20]
   2726c:	e2833001 	add	r3, r3, #1
   27270:	e50b3014 	str	r3, [fp, #-20]
   27274:	e51b2014 	ldr	r2, [fp, #-20]
   27278:	e51b301c 	ldr	r3, [fp, #-28]
   2727c:	e1520003 	cmp	r2, r3
   27280:	baffffea 	blt	27230 <__sprint_r+0x80>
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
   27284:	e5943008 	ldr	r3, [r4, #8]
   27288:	e1a02003 	mov	r2, r3
   2728c:	e51b301c 	ldr	r3, [fp, #-28]
   27290:	e1a03103 	lsl	r3, r3, #2
   27294:	e0633002 	rsb	r3, r3, r2
   27298:	e5843008 	str	r3, [r4, #8]
   2729c:	e51b3010 	ldr	r3, [fp, #-16]
   272a0:	e2833008 	add	r3, r3, #8
   272a4:	e50b3010 	str	r3, [fp, #-16]
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
   272a8:	e5943008 	ldr	r3, [r4, #8]
   272ac:	e3530000 	cmp	r3, #0
   272b0:	1affffd4 	bne	27208 <__sprint_r+0x58>
   272b4:	ea000004 	b	272cc <__sprint_r+0x11c>
				}
			}
		}
	} else
#endif
		err = __sfvwrite_r(ptr, fp, uio);
   272b8:	e51b0020 	ldr	r0, [fp, #-32]
   272bc:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
   272c0:	e1a02004 	mov	r2, r4
   272c4:	ebffea10 	bl	21b0c <__sfvwrite_r>
   272c8:	e1a05000 	mov	r5, r0
out:
	uio->uio_resid = 0;
   272cc:	e3a03000 	mov	r3, #0
   272d0:	e5843008 	str	r3, [r4, #8]
	uio->uio_iovcnt = 0;
   272d4:	e3a03000 	mov	r3, #0
   272d8:	e5843004 	str	r3, [r4, #4]
	return (err);
   272dc:	e1a03005 	mov	r3, r5
}
   272e0:	e1a00003 	mov	r0, r3
   272e4:	e24bd00c 	sub	sp, fp, #12
   272e8:	e8bd4830 	pop	{r4, r5, fp, lr}
   272ec:	e12fff1e 	bx	lr

000272f0 <__sbprintf>:
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   272f0:	e92d4810 	push	{r4, fp, lr}
   272f4:	e28db008 	add	fp, sp, #8
   272f8:	e24ddd12 	sub	sp, sp, #1152	; 0x480
   272fc:	e24dd00c 	sub	sp, sp, #12
   27300:	e50b0488 	str	r0, [fp, #-1160]	; 0x488
   27304:	e1a04001 	mov	r4, r1
   27308:	e50b248c 	str	r2, [fp, #-1164]	; 0x48c
   2730c:	e50b3490 	str	r3, [fp, #-1168]	; 0x490
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   27310:	e1d430bc 	ldrh	r3, [r4, #12]
   27314:	e3c33002 	bic	r3, r3, #2
   27318:	e1a03803 	lsl	r3, r3, #16
   2731c:	e1a03823 	lsr	r3, r3, #16
   27320:	e14b37b8 	strh	r3, [fp, #-120]	; 0xffffff88
	fake._flags2 = fp->_flags2;
   27324:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
   27328:	e50b3018 	str	r3, [fp, #-24]
	fake._file = fp->_file;
   2732c:	e1d430be 	ldrh	r3, [r4, #14]
   27330:	e14b37b6 	strh	r3, [fp, #-118]	; 0xffffff8a
	fake._cookie = fp->_cookie;
   27334:	e594301c 	ldr	r3, [r4, #28]
   27338:	e50b3068 	str	r3, [fp, #-104]	; 0x68
	fake._write = fp->_write;
   2733c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
   27340:	e50b3060 	str	r3, [fp, #-96]	; 0x60

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   27344:	e24b3e47 	sub	r3, fp, #1136	; 0x470
   27348:	e243300c 	sub	r3, r3, #12
   2734c:	e2433008 	sub	r3, r3, #8
   27350:	e50b3084 	str	r3, [fp, #-132]	; 0x84
   27354:	e51b3084 	ldr	r3, [fp, #-132]	; 0x84
   27358:	e50b3074 	str	r3, [fp, #-116]	; 0x74
	fake._bf._size = fake._w = sizeof (buf);
   2735c:	e3a03b01 	mov	r3, #1024	; 0x400
   27360:	e50b307c 	str	r3, [fp, #-124]	; 0x7c
   27364:	e51b307c 	ldr	r3, [fp, #-124]	; 0x7c
   27368:	e50b3070 	str	r3, [fp, #-112]	; 0x70
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
   2736c:	e3a03000 	mov	r3, #0
   27370:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
   27374:	e24b3084 	sub	r3, fp, #132	; 0x84
   27378:	e283305c 	add	r3, r3, #92	; 0x5c
   2737c:	e1a00003 	mov	r0, r3
   27380:	ebffbfed 	bl	1733c <_dna_lock_init>
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   27384:	e24b3084 	sub	r3, fp, #132	; 0x84
   27388:	e51b0488 	ldr	r0, [fp, #-1160]	; 0x488
   2738c:	e1a01003 	mov	r1, r3
   27390:	e51b248c 	ldr	r2, [fp, #-1164]	; 0x48c
   27394:	e51b3490 	ldr	r3, [fp, #-1168]	; 0x490
   27398:	eb000034 	bl	27470 <_vfiprintf_r>
   2739c:	e50b0010 	str	r0, [fp, #-16]
	if (ret >= 0 && _fflush_r (rptr, &fake))
   273a0:	e51b3010 	ldr	r3, [fp, #-16]
   273a4:	e3530000 	cmp	r3, #0
   273a8:	ba000008 	blt	273d0 <__sbprintf+0xe0>
   273ac:	e24b3084 	sub	r3, fp, #132	; 0x84
   273b0:	e51b0488 	ldr	r0, [fp, #-1160]	; 0x488
   273b4:	e1a01003 	mov	r1, r3
   273b8:	ebffbb28 	bl	16060 <_fflush_r>
   273bc:	e1a03000 	mov	r3, r0
   273c0:	e3530000 	cmp	r3, #0
   273c4:	0a000001 	beq	273d0 <__sbprintf+0xe0>
		ret = EOF;
   273c8:	e3e03000 	mvn	r3, #0
   273cc:	e50b3010 	str	r3, [fp, #-16]
	if (fake._flags & __SERR)
   273d0:	e15b37b8 	ldrh	r3, [fp, #-120]	; 0xffffff88
   273d4:	e1a03803 	lsl	r3, r3, #16
   273d8:	e1a03823 	lsr	r3, r3, #16
   273dc:	e2033040 	and	r3, r3, #64	; 0x40
   273e0:	e3530000 	cmp	r3, #0
   273e4:	0a000004 	beq	273fc <__sbprintf+0x10c>
		fp->_flags |= __SERR;
   273e8:	e1d430bc 	ldrh	r3, [r4, #12]
   273ec:	e3833040 	orr	r3, r3, #64	; 0x40
   273f0:	e1a03803 	lsl	r3, r3, #16
   273f4:	e1a03823 	lsr	r3, r3, #16
   273f8:	e1c430bc 	strh	r3, [r4, #12]

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
   273fc:	e24b3084 	sub	r3, fp, #132	; 0x84
   27400:	e283305c 	add	r3, r3, #92	; 0x5c
   27404:	e1a00003 	mov	r0, r3
   27408:	ebffbff7 	bl	173ec <_dna_lock_close>
#endif
	return (ret);
   2740c:	e51b3010 	ldr	r3, [fp, #-16]
}
   27410:	e1a00003 	mov	r0, r3
   27414:	e24bd008 	sub	sp, fp, #8
   27418:	e8bd4810 	pop	{r4, fp, lr}
   2741c:	e12fff1e 	bx	lr

00027420 <vfiprintf>:
int
_DEFUN(VFPRINTF, (fp, fmt0, ap),
       FILE * fp         _AND
       _CONST char *fmt0 _AND
       va_list ap)
{
   27420:	e92d4800 	push	{fp, lr}
   27424:	e28db004 	add	fp, sp, #4
   27428:	e24dd018 	sub	sp, sp, #24
   2742c:	e50b0010 	str	r0, [fp, #-16]
   27430:	e50b1014 	str	r1, [fp, #-20]
   27434:	e50b2018 	str	r2, [fp, #-24]
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   27438:	e59f302c 	ldr	r3, [pc, #44]	; 2746c <vfiprintf+0x4c>
   2743c:	e5933000 	ldr	r3, [r3]
   27440:	e1a00003 	mov	r0, r3
   27444:	e51b1010 	ldr	r1, [fp, #-16]
   27448:	e51b2014 	ldr	r2, [fp, #-20]
   2744c:	e51b3018 	ldr	r3, [fp, #-24]
   27450:	eb000006 	bl	27470 <_vfiprintf_r>
   27454:	e50b0008 	str	r0, [fp, #-8]
  return result;
   27458:	e51b3008 	ldr	r3, [fp, #-8]
}
   2745c:	e1a00003 	mov	r0, r3
   27460:	e24bd004 	sub	sp, fp, #4
   27464:	e8bd4800 	pop	{fp, lr}
   27468:	e12fff1e 	bx	lr
   2746c:	0003e460 	.word	0x0003e460

00027470 <_vfiprintf_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
   27470:	e92d4bf0 	push	{r4, r5, r6, r7, r8, r9, fp, lr}
   27474:	e28db01c 	add	fp, sp, #28
   27478:	e24ddf4a 	sub	sp, sp, #296	; 0x128
   2747c:	e50b0128 	str	r0, [fp, #-296]	; 0x128
   27480:	e50b112c 	str	r1, [fp, #-300]	; 0x12c
   27484:	e50b2130 	str	r2, [fp, #-304]	; 0x130
   27488:	e50b3134 	str	r3, [fp, #-308]	; 0x134
	int width;		/* width from format (%8d), or 0 */
	int prec;		/* precision from format (%.3d), or -1 */
	char sign;		/* sign prefix (' ', '+', '-', or \0) */
#ifdef _WANT_IO_C99_FORMATS
				/* locale specific numeric grouping */
	char *thousands_sep = NULL;
   2748c:	e3a03000 	mov	r3, #0
   27490:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	size_t thsnd_len = 0;
   27494:	e3a03000 	mov	r3, #0
   27498:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	const char *grouping = NULL;
   2749c:	e3a03000 	mov	r3, #0
   274a0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	int expsize = 0;	/* character count for expstr */
	char expstr[MAXEXPLEN];	/* buffer for exponent string */
	int lead;		/* sig figs before decimal or group sep */
#endif /* FLOATING_POINT */
#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
	int ndig = 0;		/* actual number of digits returned by cvt */
   274a4:	e3a03000 	mov	r3, #0
   274a8:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
   274ac:	e3a03000 	mov	r3, #0
   274b0:	e50b3058 	str	r3, [fp, #-88]	; 0x58
	char ox[2];		/* space for 0x hex-prefix */
#ifdef _MB_CAPABLE
	wchar_t wc;
	mbstate_t state;        /* mbtowc calls from library must not change state */
#endif
	char *malloc_buf = NULL;/* handy pointer for malloced buffers */
   274b4:	e3a03000 	mov	r3, #0
   274b8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
    CHECK_INIT (data, fp);
   274bc:	e51b3128 	ldr	r3, [fp, #-296]	; 0x128
   274c0:	e50b3060 	str	r3, [fp, #-96]	; 0x60
   274c4:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   274c8:	e3530000 	cmp	r3, #0
   274cc:	0a000005 	beq	274e8 <_vfiprintf_r+0x78>
   274d0:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   274d4:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   274d8:	e3530000 	cmp	r3, #0
   274dc:	1a000001 	bne	274e8 <_vfiprintf_r+0x78>
   274e0:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   274e4:	ebffbc28 	bl	1658c <__sinit>
    cpu_dcache_invalidate((void*)&(fp->_flags), sizeof(short));
   274e8:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   274ec:	e283300c 	add	r3, r3, #12
   274f0:	e1a00003 	mov	r0, r3
   274f4:	e3a01002 	mov	r1, #2
   274f8:	ebffa450 	bl	10640 <cpu_dcache_invalidate>
    cpu_dcache_invalidate((void*)&(fp->_lock) , sizeof(_flock_t));
   274fc:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   27500:	e283305c 	add	r3, r3, #92	; 0x5c
   27504:	e1a00003 	mov	r0, r3
   27508:	e3a01008 	mov	r1, #8
   2750c:	ebffa44b 	bl	10640 <cpu_dcache_invalidate>
	_newlib_flockfile_start (fp);
   27510:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   27514:	e1d330bc 	ldrh	r3, [r3, #12]
   27518:	e1a03803 	lsl	r3, r3, #16
   2751c:	e1a03823 	lsr	r3, r3, #16
   27520:	e2033c02 	and	r3, r3, #512	; 0x200
   27524:	e3530000 	cmp	r3, #0
   27528:	1a000003 	bne	2753c <_vfiprintf_r+0xcc>
   2752c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   27530:	e283305c 	add	r3, r3, #92	; 0x5c
   27534:	e1a00003 	mov	r0, r3
   27538:	ebffbfd0 	bl	17480 <_dna_lock_acquire>

    cpu_dcache_invalidate((void*)&(fp), sizeof(struct __sFILE));
   2753c:	e24b3f4b 	sub	r3, fp, #300	; 0x12c
   27540:	e1a00003 	mov	r0, r3
   27544:	e3a01070 	mov	r1, #112	; 0x70
   27548:	ebffa43c 	bl	10640 <cpu_dcache_invalidate>
    cpu_dcache_invalidate((void*)&(fp->_flags) ,sizeof(short));
   2754c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   27550:	e283300c 	add	r3, r3, #12
   27554:	e1a00003 	mov	r0, r3
   27558:	e3a01002 	mov	r1, #2
   2755c:	ebffa437 	bl	10640 <cpu_dcache_invalidate>
    cpu_dcache_invalidate((void*)&(fp->_flags2), sizeof(int));
   27560:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   27564:	e283306c 	add	r3, r3, #108	; 0x6c
   27568:	e1a00003 	mov	r0, r3
   2756c:	e3a01004 	mov	r1, #4
   27570:	ebffa432 	bl	10640 <cpu_dcache_invalidate>
    ORIENT(fp, -1);
   27574:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   27578:	e1d330bc 	ldrh	r3, [r3, #12]
   2757c:	e1a03803 	lsl	r3, r3, #16
   27580:	e1a03823 	lsr	r3, r3, #16
   27584:	e2033a02 	and	r3, r3, #8192	; 0x2000
   27588:	e3530000 	cmp	r3, #0
   2758c:	1a00000b 	bne	275c0 <_vfiprintf_r+0x150>
   27590:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   27594:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   27598:	e1d220bc 	ldrh	r2, [r2, #12]
   2759c:	e3822a02 	orr	r2, r2, #8192	; 0x2000
   275a0:	e1a02802 	lsl	r2, r2, #16
   275a4:	e1a02822 	lsr	r2, r2, #16
   275a8:	e1c320bc 	strh	r2, [r3, #12]
   275ac:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   275b0:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   275b4:	e592206c 	ldr	r2, [r2, #108]	; 0x6c
   275b8:	e3c22a02 	bic	r2, r2, #8192	; 0x2000
   275bc:	e583206c 	str	r2, [r3, #108]	; 0x6c

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   275c0:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   275c4:	e1d330bc 	ldrh	r3, [r3, #12]
   275c8:	e1a03803 	lsl	r3, r3, #16
   275cc:	e1a03823 	lsr	r3, r3, #16
   275d0:	e2033008 	and	r3, r3, #8
   275d4:	e3530000 	cmp	r3, #0
   275d8:	0a000003 	beq	275ec <_vfiprintf_r+0x17c>
   275dc:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   275e0:	e5933010 	ldr	r3, [r3, #16]
   275e4:	e3530000 	cmp	r3, #0
   275e8:	1a000013 	bne	2763c <_vfiprintf_r+0x1cc>
   275ec:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   275f0:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   275f4:	e1a01003 	mov	r1, r3
   275f8:	ebffdf97 	bl	1f45c <__swsetup_r>
   275fc:	e1a03000 	mov	r3, r0
   27600:	e3530000 	cmp	r3, #0
   27604:	0a00000c 	beq	2763c <_vfiprintf_r+0x1cc>
		_newlib_flockfile_exit (fp);
   27608:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   2760c:	e1d330bc 	ldrh	r3, [r3, #12]
   27610:	e1a03803 	lsl	r3, r3, #16
   27614:	e1a03823 	lsr	r3, r3, #16
   27618:	e2033c02 	and	r3, r3, #512	; 0x200
   2761c:	e3530000 	cmp	r3, #0
   27620:	1a000003 	bne	27634 <_vfiprintf_r+0x1c4>
   27624:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   27628:	e283305c 	add	r3, r3, #92	; 0x5c
   2762c:	e1a00003 	mov	r0, r3
   27630:	ebffbff9 	bl	1761c <_dna_lock_release>
		return (EOF);
   27634:	e3e03000 	mvn	r3, #0
   27638:	ea000531 	b	28b04 <_vfiprintf_r+0x1694>
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   2763c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   27640:	e1d330bc 	ldrh	r3, [r3, #12]
   27644:	e1a03803 	lsl	r3, r3, #16
   27648:	e1a03823 	lsr	r3, r3, #16
   2764c:	e203301a 	and	r3, r3, #26
   27650:	e353000a 	cmp	r3, #10
   27654:	1a000018 	bne	276bc <_vfiprintf_r+0x24c>
	    fp->_file >= 0) {
   27658:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   2765c:	e1d330be 	ldrh	r3, [r3, #14]
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   27660:	e1a03803 	lsl	r3, r3, #16
   27664:	e1a03843 	asr	r3, r3, #16
   27668:	e3530000 	cmp	r3, #0
   2766c:	ba000012 	blt	276bc <_vfiprintf_r+0x24c>
	    fp->_file >= 0) {
		_newlib_flockfile_exit (fp);
   27670:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   27674:	e1d330bc 	ldrh	r3, [r3, #12]
   27678:	e1a03803 	lsl	r3, r3, #16
   2767c:	e1a03823 	lsr	r3, r3, #16
   27680:	e2033c02 	and	r3, r3, #512	; 0x200
   27684:	e3530000 	cmp	r3, #0
   27688:	1a000003 	bne	2769c <_vfiprintf_r+0x22c>
   2768c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   27690:	e283305c 	add	r3, r3, #92	; 0x5c
   27694:	e1a00003 	mov	r0, r3
   27698:	ebffbfdf 	bl	1761c <_dna_lock_release>
		return (__sbprintf (data, fp, fmt0, ap));
   2769c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   276a0:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   276a4:	e1a01003 	mov	r1, r3
   276a8:	e51b2130 	ldr	r2, [fp, #-304]	; 0x130
   276ac:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   276b0:	ebffff0e 	bl	272f0 <__sbprintf>
   276b4:	e1a03000 	mov	r3, r0
   276b8:	ea000511 	b	28b04 <_vfiprintf_r+0x1694>
		}
		fp->_bf._size = 64;
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
   276bc:	e51b8130 	ldr	r8, [fp, #-304]	; 0x130
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   276c0:	e24b50b8 	sub	r5, fp, #184	; 0xb8
   276c4:	e50b5078 	str	r5, [fp, #-120]	; 0x78
	uio.uio_resid = 0;
   276c8:	e3a03000 	mov	r3, #0
   276cc:	e50b3070 	str	r3, [fp, #-112]	; 0x70
	uio.uio_iovcnt = 0;
   276d0:	e3a03000 	mov	r3, #0
   276d4:	e50b3074 	str	r3, [fp, #-116]	; 0x74
#endif
	ret = 0;
   276d8:	e3a03000 	mov	r3, #0
   276dc:	e50b3020 	str	r3, [fp, #-32]

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
	        cp = fmt;
   276e0:	e1a06008 	mov	r6, r8
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   276e4:	ea000000 	b	276ec <_vfiprintf_r+0x27c>
                    fmt += 1;
   276e8:	e2888001 	add	r8, r8, #1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   276ec:	e5d83000 	ldrb	r3, [r8]
   276f0:	e3530000 	cmp	r3, #0
   276f4:	0a000002 	beq	27704 <_vfiprintf_r+0x294>
   276f8:	e5d83000 	ldrb	r3, [r8]
   276fc:	e3530025 	cmp	r3, #37	; 0x25
   27700:	1afffff8 	bne	276e8 <_vfiprintf_r+0x278>
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
   27704:	e1a02008 	mov	r2, r8
   27708:	e1a03006 	mov	r3, r6
   2770c:	e0634002 	rsb	r4, r3, r2
   27710:	e3540000 	cmp	r4, #0
   27714:	0a00001a 	beq	27784 <_vfiprintf_r+0x314>
			PRINT (cp, m);
   27718:	e5856000 	str	r6, [r5]
   2771c:	e1a03004 	mov	r3, r4
   27720:	e5853004 	str	r3, [r5, #4]
   27724:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   27728:	e0833004 	add	r3, r3, r4
   2772c:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   27730:	e2855008 	add	r5, r5, #8
   27734:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   27738:	e2833001 	add	r3, r3, #1
   2773c:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   27740:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   27744:	e3530007 	cmp	r3, #7
   27748:	da00000a 	ble	27778 <_vfiprintf_r+0x308>
   2774c:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   27750:	e24b3078 	sub	r3, fp, #120	; 0x78
   27754:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   27758:	e1a01002 	mov	r1, r2
   2775c:	e1a02003 	mov	r2, r3
   27760:	ebfffe92 	bl	271b0 <__sprint_r>
   27764:	e1a03000 	mov	r3, r0
   27768:	e3530000 	cmp	r3, #0
   2776c:	0a000000 	beq	27774 <_vfiprintf_r+0x304>
   27770:	ea0004c7 	b	28a94 <_vfiprintf_r+0x1624>
   27774:	e24b50b8 	sub	r5, fp, #184	; 0xb8
			ret += m;
   27778:	e51b3020 	ldr	r3, [fp, #-32]
   2777c:	e0833004 	add	r3, r3, r4
   27780:	e50b3020 	str	r3, [fp, #-32]
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   27784:	e5d83000 	ldrb	r3, [r8]
   27788:	e3530000 	cmp	r3, #0
   2778c:	1a000000 	bne	27794 <_vfiprintf_r+0x324>
                    goto done;
   27790:	ea0004af 	b	28a54 <_vfiprintf_r+0x15e4>
#endif
		fmt_anchor = fmt;
   27794:	e50b8064 	str	r8, [fp, #-100]	; 0x64
		fmt++;		/* skip over '%' */
   27798:	e2888001 	add	r8, r8, #1

		flags = 0;
   2779c:	e3a04000 	mov	r4, #0
		dprec = 0;
   277a0:	e3a03000 	mov	r3, #0
   277a4:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
		width = 0;
   277a8:	e3a03000 	mov	r3, #0
   277ac:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		prec = -1;
   277b0:	e3e03000 	mvn	r3, #0
   277b4:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		sign = '\0';
   277b8:	e3a03000 	mov	r3, #0
   277bc:	e54b3069 	strb	r3, [fp, #-105]	; 0x69
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   277c0:	e1a03008 	mov	r3, r8
   277c4:	e2838001 	add	r8, r3, #1
   277c8:	e5d33000 	ldrb	r3, [r3]
   277cc:	e1a09003 	mov	r9, r3
reswitch:	switch (ch) {
   277d0:	e2493020 	sub	r3, r9, #32
   277d4:	e353005a 	cmp	r3, #90	; 0x5a
   277d8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   277dc:	ea000318 	b	28444 <_vfiprintf_r+0xfd4>
   277e0:	000279b0 	.word	0x000279b0
   277e4:	00028444 	.word	0x00028444
   277e8:	00028444 	.word	0x00028444
   277ec:	000279c8 	.word	0x000279c8
   277f0:	00028444 	.word	0x00028444
   277f4:	00028444 	.word	0x00028444
   277f8:	00028444 	.word	0x00028444
   277fc:	0002794c 	.word	0x0002794c
   27800:	00028444 	.word	0x00028444
   27804:	00028444 	.word	0x00028444
   27808:	000279d0 	.word	0x000279d0
   2780c:	00027a08 	.word	0x00027a08
   27810:	00028444 	.word	0x00028444
   27814:	00027a00 	.word	0x00027a00
   27818:	00027a14 	.word	0x00027a14
   2781c:	00028444 	.word	0x00028444
   27820:	00027ab0 	.word	0x00027ab0
   27824:	00027ab8 	.word	0x00027ab8
   27828:	00027ab8 	.word	0x00027ab8
   2782c:	00027ab8 	.word	0x00027ab8
   27830:	00027ab8 	.word	0x00027ab8
   27834:	00027ab8 	.word	0x00027ab8
   27838:	00027ab8 	.word	0x00027ab8
   2783c:	00027ab8 	.word	0x00027ab8
   27840:	00027ab8 	.word	0x00027ab8
   27844:	00027ab8 	.word	0x00027ab8
   27848:	00028444 	.word	0x00028444
   2784c:	00028444 	.word	0x00028444
   27850:	00028444 	.word	0x00028444
   27854:	00028444 	.word	0x00028444
   27858:	00028444 	.word	0x00028444
   2785c:	00028444 	.word	0x00028444
   27860:	00028444 	.word	0x00028444
   27864:	00028444 	.word	0x00028444
   27868:	00028444 	.word	0x00028444
   2786c:	00027b4c 	.word	0x00027b4c
   27870:	00027b7c 	.word	0x00027b7c
   27874:	00028444 	.word	0x00028444
   27878:	00028444 	.word	0x00028444
   2787c:	00028444 	.word	0x00028444
   27880:	00028444 	.word	0x00028444
   27884:	00028444 	.word	0x00028444
   27888:	00028444 	.word	0x00028444
   2788c:	00028444 	.word	0x00028444
   27890:	00028444 	.word	0x00028444
   27894:	00028444 	.word	0x00028444
   27898:	00028444 	.word	0x00028444
   2789c:	00027d6c 	.word	0x00027d6c
   278a0:	00028444 	.word	0x00028444
   278a4:	00028444 	.word	0x00028444
   278a8:	00028444 	.word	0x00028444
   278ac:	00027e9c 	.word	0x00027e9c
   278b0:	00028444 	.word	0x00028444
   278b4:	00027f5c 	.word	0x00027f5c
   278b8:	00028444 	.word	0x00028444
   278bc:	00028444 	.word	0x00028444
   278c0:	0002803c 	.word	0x0002803c
   278c4:	00028444 	.word	0x00028444
   278c8:	00028444 	.word	0x00028444
   278cc:	00028444 	.word	0x00028444
   278d0:	00028444 	.word	0x00028444
   278d4:	00028444 	.word	0x00028444
   278d8:	00028444 	.word	0x00028444
   278dc:	00028444 	.word	0x00028444
   278e0:	00028444 	.word	0x00028444
   278e4:	00028444 	.word	0x00028444
   278e8:	00028444 	.word	0x00028444
   278ec:	00027b4c 	.word	0x00027b4c
   278f0:	00027b80 	.word	0x00027b80
   278f4:	00028444 	.word	0x00028444
   278f8:	00028444 	.word	0x00028444
   278fc:	00028444 	.word	0x00028444
   27900:	00027afc 	.word	0x00027afc
   27904:	00027b80 	.word	0x00027b80
   27908:	00027b44 	.word	0x00027b44
   2790c:	00028444 	.word	0x00028444
   27910:	00027b1c 	.word	0x00027b1c
   27914:	00028444 	.word	0x00028444
   27918:	00027c9c 	.word	0x00027c9c
   2791c:	00027d70 	.word	0x00027d70
   27920:	00027e50 	.word	0x00027e50
   27924:	00027b3c 	.word	0x00027b3c
   27928:	00028444 	.word	0x00028444
   2792c:	00027e9c 	.word	0x00027e9c
   27930:	000277c0 	.word	0x000277c0
   27934:	00027f60 	.word	0x00027f60
   27938:	00028444 	.word	0x00028444
   2793c:	00028444 	.word	0x00028444
   27940:	00028048 	.word	0x00028048
   27944:	00028444 	.word	0x00028444
   27948:	000277c0 	.word	0x000277c0
#ifdef _WANT_IO_C99_FORMATS
		case '\'':
			thousands_sep = _localeconv_r (data)->thousands_sep;
   2794c:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   27950:	ebffea54 	bl	222a8 <_localeconv_r>
   27954:	e1a03000 	mov	r3, r0
   27958:	e5933004 	ldr	r3, [r3, #4]
   2795c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
			thsnd_len = strlen (thousands_sep);
   27960:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
   27964:	ebffc651 	bl	192b0 <strlen>
   27968:	e50b0030 	str	r0, [fp, #-48]	; 0x30
			grouping = _localeconv_r (data)->grouping;
   2796c:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   27970:	ebffea4c 	bl	222a8 <_localeconv_r>
   27974:	e1a03000 	mov	r3, r0
   27978:	e5933008 	ldr	r3, [r3, #8]
   2797c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
			if (thsnd_len > 0 && grouping && *grouping)
   27980:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   27984:	e3530000 	cmp	r3, #0
   27988:	0a000007 	beq	279ac <_vfiprintf_r+0x53c>
   2798c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   27990:	e3530000 	cmp	r3, #0
   27994:	0a000004 	beq	279ac <_vfiprintf_r+0x53c>
   27998:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2799c:	e5d33000 	ldrb	r3, [r3]
   279a0:	e3530000 	cmp	r3, #0
   279a4:	0a000000 	beq	279ac <_vfiprintf_r+0x53c>
			  flags |= GROUPING;
   279a8:	e3844b01 	orr	r4, r4, #1024	; 0x400
			goto rflag;
   279ac:	eaffff83 	b	277c0 <_vfiprintf_r+0x350>
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
   279b0:	e55b3069 	ldrb	r3, [fp, #-105]	; 0x69
   279b4:	e3530000 	cmp	r3, #0
   279b8:	1a000001 	bne	279c4 <_vfiprintf_r+0x554>
				sign = ' ';
   279bc:	e3a03020 	mov	r3, #32
   279c0:	e54b3069 	strb	r3, [fp, #-105]	; 0x69
			goto rflag;
   279c4:	eaffff7d 	b	277c0 <_vfiprintf_r+0x350>
		case '#':
			flags |= ALT;
   279c8:	e3844001 	orr	r4, r4, #1
			goto rflag;
   279cc:	eaffff7b 	b	277c0 <_vfiprintf_r+0x350>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   279d0:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   279d4:	e2832004 	add	r2, r3, #4
   279d8:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   279dc:	e5933000 	ldr	r3, [r3]
   279e0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
   279e4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   279e8:	e3530000 	cmp	r3, #0
   279ec:	ba000000 	blt	279f4 <_vfiprintf_r+0x584>
				goto rflag;
   279f0:	eaffff72 	b	277c0 <_vfiprintf_r+0x350>
			width = -width;
   279f4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   279f8:	e2633000 	rsb	r3, r3, #0
   279fc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
   27a00:	e3844004 	orr	r4, r4, #4
			goto rflag;
   27a04:	eaffff6d 	b	277c0 <_vfiprintf_r+0x350>
		case '+':
			sign = '+';
   27a08:	e3a0302b 	mov	r3, #43	; 0x2b
   27a0c:	e54b3069 	strb	r3, [fp, #-105]	; 0x69
			goto rflag;
   27a10:	eaffff6a 	b	277c0 <_vfiprintf_r+0x350>
		case '.':
			if ((ch = *fmt++) == '*') {
   27a14:	e1a03008 	mov	r3, r8
   27a18:	e2838001 	add	r8, r3, #1
   27a1c:	e5d33000 	ldrb	r3, [r3]
   27a20:	e1a09003 	mov	r9, r3
   27a24:	e359002a 	cmp	r9, #42	; 0x2a
   27a28:	1a00000a 	bne	27a58 <_vfiprintf_r+0x5e8>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   27a2c:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27a30:	e2832004 	add	r2, r3, #4
   27a34:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27a38:	e5933000 	ldr	r3, [r3]
   27a3c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   27a40:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   27a44:	e3530000 	cmp	r3, #0
   27a48:	aa000001 	bge	27a54 <_vfiprintf_r+0x5e4>
					prec = -1;
   27a4c:	e3e03000 	mvn	r3, #0
   27a50:	e50b3028 	str	r3, [fp, #-40]	; 0x28
				goto rflag;
   27a54:	eaffff59 	b	277c0 <_vfiprintf_r+0x350>
			}
			n = 0;
   27a58:	e3a07000 	mov	r7, #0
			while (is_digit (ch)) {
   27a5c:	ea00000a 	b	27a8c <_vfiprintf_r+0x61c>
				n = 10 * n + to_digit (ch);
   27a60:	e1a03007 	mov	r3, r7
   27a64:	e1a03103 	lsl	r3, r3, #2
   27a68:	e0833007 	add	r3, r3, r7
   27a6c:	e1a03083 	lsl	r3, r3, #1
   27a70:	e1a02003 	mov	r2, r3
   27a74:	e2493030 	sub	r3, r9, #48	; 0x30
   27a78:	e0827003 	add	r7, r2, r3
				ch = *fmt++;
   27a7c:	e1a03008 	mov	r3, r8
   27a80:	e2838001 	add	r8, r3, #1
   27a84:	e5d33000 	ldrb	r3, [r3]
   27a88:	e1a09003 	mov	r9, r3
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   27a8c:	e2493030 	sub	r3, r9, #48	; 0x30
   27a90:	e3530009 	cmp	r3, #9
   27a94:	9afffff1 	bls	27a60 <_vfiprintf_r+0x5f0>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
   27a98:	e3e03000 	mvn	r3, #0
   27a9c:	e1570003 	cmp	r7, r3
   27aa0:	a1a03007 	movge	r3, r7
   27aa4:	b1a03003 	movlt	r3, r3
   27aa8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
			goto reswitch;
   27aac:	eaffff47 	b	277d0 <_vfiprintf_r+0x360>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
   27ab0:	e3844080 	orr	r4, r4, #128	; 0x80
			goto rflag;
   27ab4:	eaffff41 	b	277c0 <_vfiprintf_r+0x350>
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
   27ab8:	e3a07000 	mov	r7, #0
			do {
				n = 10 * n + to_digit (ch);
   27abc:	e1a03007 	mov	r3, r7
   27ac0:	e1a03103 	lsl	r3, r3, #2
   27ac4:	e0833007 	add	r3, r3, r7
   27ac8:	e1a03083 	lsl	r3, r3, #1
   27acc:	e1a02003 	mov	r2, r3
   27ad0:	e2493030 	sub	r3, r9, #48	; 0x30
   27ad4:	e0827003 	add	r7, r2, r3
				ch = *fmt++;
   27ad8:	e1a03008 	mov	r3, r8
   27adc:	e2838001 	add	r8, r3, #1
   27ae0:	e5d33000 	ldrb	r3, [r3]
   27ae4:	e1a09003 	mov	r9, r3
			} while (is_digit (ch));
   27ae8:	e2493030 	sub	r3, r9, #48	; 0x30
   27aec:	e3530009 	cmp	r3, #9
   27af0:	9afffff1 	bls	27abc <_vfiprintf_r+0x64c>
				}
				else
					goto error;
			}
#endif /* !_NO_POS_ARGS */
			width = n;
   27af4:	e50b7024 	str	r7, [fp, #-36]	; 0x24
			goto reswitch;
   27af8:	eaffff34 	b	277d0 <_vfiprintf_r+0x360>
			flags |= LONGDBL;
			goto rflag;
#endif
		case 'h':
#ifdef _WANT_IO_C99_FORMATS
			if (*fmt == 'h') {
   27afc:	e5d83000 	ldrb	r3, [r8]
   27b00:	e3530068 	cmp	r3, #104	; 0x68
   27b04:	1a000002 	bne	27b14 <_vfiprintf_r+0x6a4>
				fmt++;
   27b08:	e2888001 	add	r8, r8, #1
				flags |= CHARINT;
   27b0c:	e3844c02 	orr	r4, r4, #512	; 0x200
   27b10:	ea000000 	b	27b18 <_vfiprintf_r+0x6a8>
			} else
#endif
				flags |= SHORTINT;
   27b14:	e3844040 	orr	r4, r4, #64	; 0x40
			goto rflag;
   27b18:	eaffff28 	b	277c0 <_vfiprintf_r+0x350>
		case 'l':
#if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
			if (*fmt == 'l') {
   27b1c:	e5d83000 	ldrb	r3, [r8]
   27b20:	e353006c 	cmp	r3, #108	; 0x6c
   27b24:	1a000002 	bne	27b34 <_vfiprintf_r+0x6c4>
				fmt++;
   27b28:	e2888001 	add	r8, r8, #1
				flags |= QUADINT;
   27b2c:	e3844020 	orr	r4, r4, #32
   27b30:	ea000000 	b	27b38 <_vfiprintf_r+0x6c8>
			} else
#endif
				flags |= LONGINT;
   27b34:	e3844010 	orr	r4, r4, #16
			goto rflag;
   27b38:	eaffff20 	b	277c0 <_vfiprintf_r+0x350>
		case 'q': /* extension */
			flags |= QUADINT;
   27b3c:	e3844020 	orr	r4, r4, #32
			goto rflag;
   27b40:	eaffff1e 	b	277c0 <_vfiprintf_r+0x350>
#ifdef _WANT_IO_C99_FORMATS
		case 'j':
		  if (sizeof (intmax_t) == sizeof (long))
		    flags |= LONGINT;
		  else
		    flags |= QUADINT;
   27b44:	e3844020 	orr	r4, r4, #32
		  goto rflag;
   27b48:	eaffff1c 	b	277c0 <_vfiprintf_r+0x350>
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
   27b4c:	e24b6f47 	sub	r6, fp, #284	; 0x11c
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   27b50:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27b54:	e2832004 	add	r2, r3, #4
   27b58:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27b5c:	e5933000 	ldr	r3, [r3]
   27b60:	e20330ff 	and	r3, r3, #255	; 0xff
   27b64:	e5c63000 	strb	r3, [r6]
				size = 1;
   27b68:	e3a03001 	mov	r3, #1
   27b6c:	e50b3054 	str	r3, [fp, #-84]	; 0x54
			}
			sign = '\0';
   27b70:	e3a03000 	mov	r3, #0
   27b74:	e54b3069 	strb	r3, [fp, #-105]	; 0x69
			break;
   27b78:	ea00023c 	b	28470 <_vfiprintf_r+0x1000>
		case 'D':  /* extension */
			flags |= LONGINT;
   27b7c:	e3844010 	orr	r4, r4, #16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   27b80:	e2043020 	and	r3, r4, #32
   27b84:	e3530000 	cmp	r3, #0
   27b88:	0a000006 	beq	27ba8 <_vfiprintf_r+0x738>
   27b8c:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27b90:	e2833007 	add	r3, r3, #7
   27b94:	e3c33007 	bic	r3, r3, #7
   27b98:	e2832008 	add	r2, r3, #8
   27b9c:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27ba0:	e893000c 	ldm	r3, {r2, r3}
   27ba4:	ea00002a 	b	27c54 <_vfiprintf_r+0x7e4>
   27ba8:	e2043010 	and	r3, r4, #16
   27bac:	e3530000 	cmp	r3, #0
   27bb0:	0a000006 	beq	27bd0 <_vfiprintf_r+0x760>
   27bb4:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27bb8:	e2832004 	add	r2, r3, #4
   27bbc:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27bc0:	e5933000 	ldr	r3, [r3]
   27bc4:	e1a02003 	mov	r2, r3
   27bc8:	e1a03fc2 	asr	r3, r2, #31
   27bcc:	ea000020 	b	27c54 <_vfiprintf_r+0x7e4>
   27bd0:	e2043040 	and	r3, r4, #64	; 0x40
   27bd4:	e3530000 	cmp	r3, #0
   27bd8:	0a00000a 	beq	27c08 <_vfiprintf_r+0x798>
   27bdc:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27be0:	e2832004 	add	r2, r3, #4
   27be4:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27be8:	e5933000 	ldr	r3, [r3]
   27bec:	e1a03803 	lsl	r3, r3, #16
   27bf0:	e1a01823 	lsr	r1, r3, #16
   27bf4:	e1a03801 	lsl	r3, r1, #16
   27bf8:	e1a03843 	asr	r3, r3, #16
   27bfc:	e1a02003 	mov	r2, r3
   27c00:	e1a03fc2 	asr	r3, r2, #31
   27c04:	ea000012 	b	27c54 <_vfiprintf_r+0x7e4>
   27c08:	e2043c02 	and	r3, r4, #512	; 0x200
   27c0c:	e3530000 	cmp	r3, #0
   27c10:	0a000009 	beq	27c3c <_vfiprintf_r+0x7cc>
   27c14:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27c18:	e2832004 	add	r2, r3, #4
   27c1c:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27c20:	e5933000 	ldr	r3, [r3]
   27c24:	e20310ff 	and	r1, r3, #255	; 0xff
   27c28:	e1a03c01 	lsl	r3, r1, #24
   27c2c:	e1a03c43 	asr	r3, r3, #24
   27c30:	e1a02003 	mov	r2, r3
   27c34:	e1a03fc2 	asr	r3, r2, #31
   27c38:	ea000005 	b	27c54 <_vfiprintf_r+0x7e4>
   27c3c:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27c40:	e2832004 	add	r2, r3, #4
   27c44:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27c48:	e5933000 	ldr	r3, [r3]
   27c4c:	e1a02003 	mov	r2, r3
   27c50:	e1a03fc2 	asr	r3, r2, #31
   27c54:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   27c58:	e50b3040 	str	r3, [fp, #-64]	; 0x40
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
   27c5c:	e24b3044 	sub	r3, fp, #68	; 0x44
   27c60:	e893000c 	ldm	r3, {r2, r3}
   27c64:	e3520000 	cmp	r2, #0
   27c68:	e2d31000 	sbcs	r1, r3, #0
   27c6c:	aa000007 	bge	27c90 <_vfiprintf_r+0x820>
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
   27c70:	e24b3044 	sub	r3, fp, #68	; 0x44
   27c74:	e893000c 	ldm	r3, {r2, r3}
   27c78:	e2722000 	rsbs	r2, r2, #0
   27c7c:	e2e33000 	rsc	r3, r3, #0
   27c80:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   27c84:	e50b3040 	str	r3, [fp, #-64]	; 0x40
				sign = '-';
   27c88:	e3a0302d 	mov	r3, #45	; 0x2d
   27c8c:	e54b3069 	strb	r3, [fp, #-105]	; 0x69
			}
			base = DEC;
   27c90:	e3a03001 	mov	r3, #1
   27c94:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
			goto number;
   27c98:	ea000131 	b	28164 <_vfiprintf_r+0xcf4>
			flags &= ~LONGINT;
			goto string;
#endif
		case 'n':
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
   27c9c:	e2043020 	and	r3, r4, #32
   27ca0:	e3530000 	cmp	r3, #0
   27ca4:	0a000007 	beq	27cc8 <_vfiprintf_r+0x858>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
   27ca8:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27cac:	e2832004 	add	r2, r3, #4
   27cb0:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27cb4:	e5932000 	ldr	r2, [r3]
   27cb8:	e51b3020 	ldr	r3, [fp, #-32]
   27cbc:	e1a04fc3 	asr	r4, r3, #31
   27cc0:	e8820018 	stm	r2, {r3, r4}
   27cc4:	ea000027 	b	27d68 <_vfiprintf_r+0x8f8>
			else
#endif
			if (flags & LONGINT)
   27cc8:	e2043010 	and	r3, r4, #16
   27ccc:	e3530000 	cmp	r3, #0
   27cd0:	0a000006 	beq	27cf0 <_vfiprintf_r+0x880>
				*GET_ARG (N, ap, long_ptr_t) = ret;
   27cd4:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27cd8:	e2832004 	add	r2, r3, #4
   27cdc:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27ce0:	e5933000 	ldr	r3, [r3]
   27ce4:	e51b2020 	ldr	r2, [fp, #-32]
   27ce8:	e5832000 	str	r2, [r3]
   27cec:	ea00001d 	b	27d68 <_vfiprintf_r+0x8f8>
			else if (flags & SHORTINT)
   27cf0:	e2043040 	and	r3, r4, #64	; 0x40
   27cf4:	e3530000 	cmp	r3, #0
   27cf8:	0a000008 	beq	27d20 <_vfiprintf_r+0x8b0>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   27cfc:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27d00:	e2832004 	add	r2, r3, #4
   27d04:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27d08:	e5933000 	ldr	r3, [r3]
   27d0c:	e51b2020 	ldr	r2, [fp, #-32]
   27d10:	e1a02802 	lsl	r2, r2, #16
   27d14:	e1a02822 	lsr	r2, r2, #16
   27d18:	e1c320b0 	strh	r2, [r3]
   27d1c:	ea000011 	b	27d68 <_vfiprintf_r+0x8f8>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
   27d20:	e2043c02 	and	r3, r4, #512	; 0x200
   27d24:	e3530000 	cmp	r3, #0
   27d28:	0a000007 	beq	27d4c <_vfiprintf_r+0x8dc>
				*GET_ARG (N, ap, char_ptr_t) = ret;
   27d2c:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27d30:	e2832004 	add	r2, r3, #4
   27d34:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27d38:	e5933000 	ldr	r3, [r3]
   27d3c:	e51b2020 	ldr	r2, [fp, #-32]
   27d40:	e20220ff 	and	r2, r2, #255	; 0xff
   27d44:	e5c32000 	strb	r2, [r3]
   27d48:	ea000006 	b	27d68 <_vfiprintf_r+0x8f8>
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
   27d4c:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27d50:	e2832004 	add	r2, r3, #4
   27d54:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27d58:	e5933000 	ldr	r3, [r3]
   27d5c:	e51b2020 	ldr	r2, [fp, #-32]
   27d60:	e5832000 	str	r2, [r3]
			continue;	/* no output */
   27d64:	ea000339 	b	28a50 <_vfiprintf_r+0x15e0>
   27d68:	ea000338 	b	28a50 <_vfiprintf_r+0x15e0>
		case 'O': /* extension */
			flags |= LONGINT;
   27d6c:	e3844010 	orr	r4, r4, #16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   27d70:	e2043020 	and	r3, r4, #32
   27d74:	e3530000 	cmp	r3, #0
   27d78:	0a000006 	beq	27d98 <_vfiprintf_r+0x928>
   27d7c:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27d80:	e2833007 	add	r3, r3, #7
   27d84:	e3c33007 	bic	r3, r3, #7
   27d88:	e2832008 	add	r2, r3, #8
   27d8c:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27d90:	e893000c 	ldm	r3, {r2, r3}
   27d94:	ea000027 	b	27e38 <_vfiprintf_r+0x9c8>
   27d98:	e2043010 	and	r3, r4, #16
   27d9c:	e3530000 	cmp	r3, #0
   27da0:	0a000006 	beq	27dc0 <_vfiprintf_r+0x950>
   27da4:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27da8:	e2832004 	add	r2, r3, #4
   27dac:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27db0:	e5933000 	ldr	r3, [r3]
   27db4:	e1a02003 	mov	r2, r3
   27db8:	e3a03000 	mov	r3, #0
   27dbc:	ea00001d 	b	27e38 <_vfiprintf_r+0x9c8>
   27dc0:	e2043040 	and	r3, r4, #64	; 0x40
   27dc4:	e3530000 	cmp	r3, #0
   27dc8:	0a000009 	beq	27df4 <_vfiprintf_r+0x984>
   27dcc:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27dd0:	e2832004 	add	r2, r3, #4
   27dd4:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27dd8:	e5933000 	ldr	r3, [r3]
   27ddc:	e1a03803 	lsl	r3, r3, #16
   27de0:	e1a01823 	lsr	r1, r3, #16
   27de4:	e1a03001 	mov	r3, r1
   27de8:	e1a02003 	mov	r2, r3
   27dec:	e3a03000 	mov	r3, #0
   27df0:	ea000010 	b	27e38 <_vfiprintf_r+0x9c8>
   27df4:	e2043c02 	and	r3, r4, #512	; 0x200
   27df8:	e3530000 	cmp	r3, #0
   27dfc:	0a000007 	beq	27e20 <_vfiprintf_r+0x9b0>
   27e00:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27e04:	e2832004 	add	r2, r3, #4
   27e08:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27e0c:	e5933000 	ldr	r3, [r3]
   27e10:	e20330ff 	and	r3, r3, #255	; 0xff
   27e14:	e20320ff 	and	r2, r3, #255	; 0xff
   27e18:	e3a03000 	mov	r3, #0
   27e1c:	ea000005 	b	27e38 <_vfiprintf_r+0x9c8>
   27e20:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27e24:	e2832004 	add	r2, r3, #4
   27e28:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27e2c:	e5933000 	ldr	r3, [r3]
   27e30:	e1a02003 	mov	r2, r3
   27e34:	e3a03000 	mov	r3, #0
   27e38:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   27e3c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
			base = OCT;
   27e40:	e3a03000 	mov	r3, #0
   27e44:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
   27e48:	e3c44b01 	bic	r4, r4, #1024	; 0x400
#endif
			goto nosign;
   27e4c:	ea0000c2 	b	2815c <_vfiprintf_r+0xcec>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   27e50:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27e54:	e2832004 	add	r2, r3, #4
   27e58:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27e5c:	e5933000 	ldr	r3, [r3]
   27e60:	e1a02003 	mov	r2, r3
   27e64:	e3a03000 	mov	r3, #0
   27e68:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   27e6c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
			base = HEX;
   27e70:	e3a03002 	mov	r3, #2
   27e74:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
			xdigs = "0123456789abcdef";
   27e78:	e59f3c94 	ldr	r3, [pc, #3220]	; 28b14 <_vfiprintf_r+0x16a4>
   27e7c:	e50b3058 	str	r3, [fp, #-88]	; 0x58
			flags |= HEXPREFIX;
   27e80:	e3844002 	orr	r4, r4, #2
			ox[0] = '0';
   27e84:	e3a03030 	mov	r3, #48	; 0x30
   27e88:	e54b3120 	strb	r3, [fp, #-288]	; 0x120
			ox[1] = ch = 'x';
   27e8c:	e3a09078 	mov	r9, #120	; 0x78
   27e90:	e3a03078 	mov	r3, #120	; 0x78
   27e94:	e54b311f 	strb	r3, [fp, #-287]	; 0x11f
			goto nosign;
   27e98:	ea0000af 	b	2815c <_vfiprintf_r+0xcec>
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   27e9c:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27ea0:	e2832004 	add	r2, r3, #4
   27ea4:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27ea8:	e5936000 	ldr	r6, [r3]
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
   27eac:	e3a03000 	mov	r3, #0
   27eb0:	e54b3069 	strb	r3, [fp, #-105]	; 0x69
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
   27eb4:	e3560000 	cmp	r6, #0
   27eb8:	1a000006 	bne	27ed8 <_vfiprintf_r+0xa68>
				cp = "(null)";
   27ebc:	e59f6c54 	ldr	r6, [pc, #3156]	; 28b18 <_vfiprintf_r+0x16a8>
				size = ((unsigned) prec > 6U) ? 6 : prec;
   27ec0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   27ec4:	e3530006 	cmp	r3, #6
   27ec8:	31a03003 	movcc	r3, r3
   27ecc:	23a03006 	movcs	r3, #6
   27ed0:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   27ed4:	ea00001f 	b	27f58 <_vfiprintf_r+0xae8>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
   27ed8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   27edc:	e3530000 	cmp	r3, #0
   27ee0:	ba000017 	blt	27f44 <_vfiprintf_r+0xad4>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
   27ee4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   27ee8:	e1a00006 	mov	r0, r6
   27eec:	e3a01000 	mov	r1, #0
   27ef0:	e1a02003 	mov	r2, r3
   27ef4:	ebffe9c4 	bl	2260c <memchr>
   27ef8:	e50b0068 	str	r0, [fp, #-104]	; 0x68

				if (p != NULL) {
   27efc:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   27f00:	e3530000 	cmp	r3, #0
   27f04:	0a00000a 	beq	27f34 <_vfiprintf_r+0xac4>
					size = p - cp;
   27f08:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   27f0c:	e1a03006 	mov	r3, r6
   27f10:	e0633002 	rsb	r3, r3, r2
   27f14:	e50b3054 	str	r3, [fp, #-84]	; 0x54
					if (size > prec)
   27f18:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   27f1c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   27f20:	e1520003 	cmp	r2, r3
   27f24:	da000005 	ble	27f40 <_vfiprintf_r+0xad0>
						size = prec;
   27f28:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   27f2c:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   27f30:	ea000008 	b	27f58 <_vfiprintf_r+0xae8>
				} else
					size = prec;
   27f34:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   27f38:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   27f3c:	ea000005 	b	27f58 <_vfiprintf_r+0xae8>
   27f40:	ea000004 	b	27f58 <_vfiprintf_r+0xae8>
			} else
				size = strlen (cp);
   27f44:	e1a00006 	mov	r0, r6
   27f48:	ebffc4d8 	bl	192b0 <strlen>
   27f4c:	e1a03000 	mov	r3, r0
   27f50:	e50b3054 	str	r3, [fp, #-84]	; 0x54

			break;
   27f54:	ea000145 	b	28470 <_vfiprintf_r+0x1000>
   27f58:	ea000144 	b	28470 <_vfiprintf_r+0x1000>
		case 'U': /* extension */
			flags |= LONGINT;
   27f5c:	e3844010 	orr	r4, r4, #16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   27f60:	e2043020 	and	r3, r4, #32
   27f64:	e3530000 	cmp	r3, #0
   27f68:	0a000006 	beq	27f88 <_vfiprintf_r+0xb18>
   27f6c:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27f70:	e2833007 	add	r3, r3, #7
   27f74:	e3c33007 	bic	r3, r3, #7
   27f78:	e2832008 	add	r2, r3, #8
   27f7c:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27f80:	e893000c 	ldm	r3, {r2, r3}
   27f84:	ea000027 	b	28028 <_vfiprintf_r+0xbb8>
   27f88:	e2043010 	and	r3, r4, #16
   27f8c:	e3530000 	cmp	r3, #0
   27f90:	0a000006 	beq	27fb0 <_vfiprintf_r+0xb40>
   27f94:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27f98:	e2832004 	add	r2, r3, #4
   27f9c:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27fa0:	e5933000 	ldr	r3, [r3]
   27fa4:	e1a02003 	mov	r2, r3
   27fa8:	e3a03000 	mov	r3, #0
   27fac:	ea00001d 	b	28028 <_vfiprintf_r+0xbb8>
   27fb0:	e2043040 	and	r3, r4, #64	; 0x40
   27fb4:	e3530000 	cmp	r3, #0
   27fb8:	0a000009 	beq	27fe4 <_vfiprintf_r+0xb74>
   27fbc:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27fc0:	e2832004 	add	r2, r3, #4
   27fc4:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27fc8:	e5933000 	ldr	r3, [r3]
   27fcc:	e1a03803 	lsl	r3, r3, #16
   27fd0:	e1a01823 	lsr	r1, r3, #16
   27fd4:	e1a03001 	mov	r3, r1
   27fd8:	e1a02003 	mov	r2, r3
   27fdc:	e3a03000 	mov	r3, #0
   27fe0:	ea000010 	b	28028 <_vfiprintf_r+0xbb8>
   27fe4:	e2043c02 	and	r3, r4, #512	; 0x200
   27fe8:	e3530000 	cmp	r3, #0
   27fec:	0a000007 	beq	28010 <_vfiprintf_r+0xba0>
   27ff0:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   27ff4:	e2832004 	add	r2, r3, #4
   27ff8:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   27ffc:	e5933000 	ldr	r3, [r3]
   28000:	e20330ff 	and	r3, r3, #255	; 0xff
   28004:	e20320ff 	and	r2, r3, #255	; 0xff
   28008:	e3a03000 	mov	r3, #0
   2800c:	ea000005 	b	28028 <_vfiprintf_r+0xbb8>
   28010:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   28014:	e2832004 	add	r2, r3, #4
   28018:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   2801c:	e5933000 	ldr	r3, [r3]
   28020:	e1a02003 	mov	r2, r3
   28024:	e3a03000 	mov	r3, #0
   28028:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   2802c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
			base = DEC;
   28030:	e3a03001 	mov	r3, #1
   28034:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
			goto nosign;
   28038:	ea000047 	b	2815c <_vfiprintf_r+0xcec>
		case 'X':
			xdigs = "0123456789ABCDEF";
   2803c:	e59f3ad8 	ldr	r3, [pc, #2776]	; 28b1c <_vfiprintf_r+0x16ac>
   28040:	e50b3058 	str	r3, [fp, #-88]	; 0x58
			goto hex;
   28044:	ea000001 	b	28050 <_vfiprintf_r+0xbe0>
		case 'x':
			xdigs = "0123456789abcdef";
   28048:	e59f3ac4 	ldr	r3, [pc, #2756]	; 28b14 <_vfiprintf_r+0x16a4>
   2804c:	e50b3058 	str	r3, [fp, #-88]	; 0x58
hex:			_uquad = UARG ();
   28050:	e2043020 	and	r3, r4, #32
   28054:	e3530000 	cmp	r3, #0
   28058:	0a000006 	beq	28078 <_vfiprintf_r+0xc08>
   2805c:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   28060:	e2833007 	add	r3, r3, #7
   28064:	e3c33007 	bic	r3, r3, #7
   28068:	e2832008 	add	r2, r3, #8
   2806c:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   28070:	e893000c 	ldm	r3, {r2, r3}
   28074:	ea000027 	b	28118 <_vfiprintf_r+0xca8>
   28078:	e2043010 	and	r3, r4, #16
   2807c:	e3530000 	cmp	r3, #0
   28080:	0a000006 	beq	280a0 <_vfiprintf_r+0xc30>
   28084:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   28088:	e2832004 	add	r2, r3, #4
   2808c:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   28090:	e5933000 	ldr	r3, [r3]
   28094:	e1a02003 	mov	r2, r3
   28098:	e3a03000 	mov	r3, #0
   2809c:	ea00001d 	b	28118 <_vfiprintf_r+0xca8>
   280a0:	e2043040 	and	r3, r4, #64	; 0x40
   280a4:	e3530000 	cmp	r3, #0
   280a8:	0a000009 	beq	280d4 <_vfiprintf_r+0xc64>
   280ac:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   280b0:	e2832004 	add	r2, r3, #4
   280b4:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   280b8:	e5933000 	ldr	r3, [r3]
   280bc:	e1a03803 	lsl	r3, r3, #16
   280c0:	e1a01823 	lsr	r1, r3, #16
   280c4:	e1a03001 	mov	r3, r1
   280c8:	e1a02003 	mov	r2, r3
   280cc:	e3a03000 	mov	r3, #0
   280d0:	ea000010 	b	28118 <_vfiprintf_r+0xca8>
   280d4:	e2043c02 	and	r3, r4, #512	; 0x200
   280d8:	e3530000 	cmp	r3, #0
   280dc:	0a000007 	beq	28100 <_vfiprintf_r+0xc90>
   280e0:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   280e4:	e2832004 	add	r2, r3, #4
   280e8:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   280ec:	e5933000 	ldr	r3, [r3]
   280f0:	e20330ff 	and	r3, r3, #255	; 0xff
   280f4:	e20320ff 	and	r2, r3, #255	; 0xff
   280f8:	e3a03000 	mov	r3, #0
   280fc:	ea000005 	b	28118 <_vfiprintf_r+0xca8>
   28100:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   28104:	e2832004 	add	r2, r3, #4
   28108:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   2810c:	e5933000 	ldr	r3, [r3]
   28110:	e1a02003 	mov	r2, r3
   28114:	e3a03000 	mov	r3, #0
   28118:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   2811c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
			base = HEX;
   28120:	e3a03002 	mov	r3, #2
   28124:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
   28128:	e2043001 	and	r3, r4, #1
   2812c:	e3530000 	cmp	r3, #0
   28130:	0a000008 	beq	28158 <_vfiprintf_r+0xce8>
   28134:	e24b3044 	sub	r3, fp, #68	; 0x44
   28138:	e893000c 	ldm	r3, {r2, r3}
   2813c:	e1921003 	orrs	r1, r2, r3
   28140:	0a000004 	beq	28158 <_vfiprintf_r+0xce8>
				ox[0] = '0';
   28144:	e3a03030 	mov	r3, #48	; 0x30
   28148:	e54b3120 	strb	r3, [fp, #-288]	; 0x120
				ox[1] = ch;
   2814c:	e20930ff 	and	r3, r9, #255	; 0xff
   28150:	e54b311f 	strb	r3, [fp, #-287]	; 0x11f
				flags |= HEXPREFIX;
   28154:	e3844002 	orr	r4, r4, #2
			}

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
   28158:	e3c44b01 	bic	r4, r4, #1024	; 0x400
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   2815c:	e3a03000 	mov	r3, #0
   28160:	e54b3069 	strb	r3, [fp, #-105]	; 0x69
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   28164:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   28168:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   2816c:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   28170:	e3530000 	cmp	r3, #0
   28174:	ba000000 	blt	2817c <_vfiprintf_r+0xd0c>
				flags &= ~ZEROPAD;
   28178:	e3c44080 	bic	r4, r4, #128	; 0x80
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   2817c:	e24b6f47 	sub	r6, fp, #284	; 0x11c
   28180:	e2866064 	add	r6, r6, #100	; 0x64
			if (_uquad != 0 || prec != 0) {
   28184:	e24b3044 	sub	r3, fp, #68	; 0x44
   28188:	e893000c 	ldm	r3, {r2, r3}
   2818c:	e1921003 	orrs	r1, r2, r3
   28190:	1a000002 	bne	281a0 <_vfiprintf_r+0xd30>
   28194:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   28198:	e3530000 	cmp	r3, #0
   2819c:	0a000099 	beq	28408 <_vfiprintf_r+0xf98>
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   281a0:	e55b3045 	ldrb	r3, [fp, #-69]	; 0x45
   281a4:	e3530001 	cmp	r3, #1
   281a8:	0a000026 	beq	28248 <_vfiprintf_r+0xdd8>
   281ac:	e3530002 	cmp	r3, #2
   281b0:	0a000073 	beq	28384 <_vfiprintf_r+0xf14>
   281b4:	e3530000 	cmp	r3, #0
   281b8:	1a00008a 	bne	283e8 <_vfiprintf_r+0xf78>
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   281bc:	e2466001 	sub	r6, r6, #1
   281c0:	e55b3044 	ldrb	r3, [fp, #-68]	; 0x44
   281c4:	e2033007 	and	r3, r3, #7
   281c8:	e20330ff 	and	r3, r3, #255	; 0xff
   281cc:	e2833030 	add	r3, r3, #48	; 0x30
   281d0:	e20330ff 	and	r3, r3, #255	; 0xff
   281d4:	e5c63000 	strb	r3, [r6]
						_uquad >>= 3;
   281d8:	e24b3044 	sub	r3, fp, #68	; 0x44
   281dc:	e893000c 	ldm	r3, {r2, r3}
   281e0:	e1a011a2 	lsr	r1, r2, #3
   281e4:	e50b113c 	str	r1, [fp, #-316]	; 0x13c
   281e8:	e51b113c 	ldr	r1, [fp, #-316]	; 0x13c
   281ec:	e1811e83 	orr	r1, r1, r3, lsl #29
   281f0:	e50b113c 	str	r1, [fp, #-316]	; 0x13c
   281f4:	e1a011a3 	lsr	r1, r3, #3
   281f8:	e50b1138 	str	r1, [fp, #-312]	; 0x138
   281fc:	e24b3f4f 	sub	r3, fp, #316	; 0x13c
   28200:	e893000c 	ldm	r3, {r2, r3}
   28204:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   28208:	e50b3040 	str	r3, [fp, #-64]	; 0x40
					} while (_uquad);
   2820c:	e24b3044 	sub	r3, fp, #68	; 0x44
   28210:	e893000c 	ldm	r3, {r2, r3}
   28214:	e1921003 	orrs	r1, r2, r3
   28218:	1affffe7 	bne	281bc <_vfiprintf_r+0xd4c>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
   2821c:	e2043001 	and	r3, r4, #1
   28220:	e3530000 	cmp	r3, #0
   28224:	0a000006 	beq	28244 <_vfiprintf_r+0xdd4>
   28228:	e5d63000 	ldrb	r3, [r6]
   2822c:	e3530030 	cmp	r3, #48	; 0x30
   28230:	0a000003 	beq	28244 <_vfiprintf_r+0xdd4>
						*--cp = '0';
   28234:	e2466001 	sub	r6, r6, #1
   28238:	e3a03030 	mov	r3, #48	; 0x30
   2823c:	e5c63000 	strb	r3, [r6]
					break;
   28240:	ea00006f 	b	28404 <_vfiprintf_r+0xf94>
   28244:	ea00006e 	b	28404 <_vfiprintf_r+0xf94>

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   28248:	e24b3044 	sub	r3, fp, #68	; 0x44
   2824c:	e893000c 	ldm	r3, {r2, r3}
   28250:	e3530000 	cmp	r3, #0
   28254:	03520009 	cmpeq	r2, #9
   28258:	8a000005 	bhi	28274 <_vfiprintf_r+0xe04>
						*--cp = to_char(_uquad);
   2825c:	e2466001 	sub	r6, r6, #1
   28260:	e55b3044 	ldrb	r3, [fp, #-68]	; 0x44
   28264:	e2833030 	add	r3, r3, #48	; 0x30
   28268:	e20330ff 	and	r3, r3, #255	; 0xff
   2826c:	e5c63000 	strb	r3, [r6]
						break;
   28270:	ea000063 	b	28404 <_vfiprintf_r+0xf94>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
   28274:	e3a03000 	mov	r3, #0
   28278:	e50b3038 	str	r3, [fp, #-56]	; 0x38
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   2827c:	e2466001 	sub	r6, r6, #1
   28280:	e24b3044 	sub	r3, fp, #68	; 0x44
   28284:	e893000c 	ldm	r3, {r2, r3}
   28288:	e1a00002 	mov	r0, r2
   2828c:	e1a01003 	mov	r1, r3
   28290:	e3a0200a 	mov	r2, #10
   28294:	e3a03000 	mov	r3, #0
   28298:	ebffb3b8 	bl	15180 <__aeabi_uldivmod>
   2829c:	e20230ff 	and	r3, r2, #255	; 0xff
   282a0:	e2833030 	add	r3, r3, #48	; 0x30
   282a4:	e20330ff 	and	r3, r3, #255	; 0xff
   282a8:	e5c63000 	strb	r3, [r6]
#ifdef _WANT_IO_C99_FORMATS
					  ndig++;
   282ac:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   282b0:	e2833001 	add	r3, r3, #1
   282b4:	e50b3038 	str	r3, [fp, #-56]	; 0x38
					  /* If (*grouping == CHAR_MAX) then no
					     more grouping */
					  if ((flags & GROUPING)
   282b8:	e2043b01 	and	r3, r4, #1024	; 0x400
   282bc:	e3530000 	cmp	r3, #0
   282c0:	0a00001f 	beq	28344 <_vfiprintf_r+0xed4>
					      && ndig == *grouping
   282c4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   282c8:	e5d33000 	ldrb	r3, [r3]
   282cc:	e1a02003 	mov	r2, r3
   282d0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   282d4:	e1520003 	cmp	r2, r3
   282d8:	1a000019 	bne	28344 <_vfiprintf_r+0xed4>
					      && *grouping != CHAR_MAX
   282dc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   282e0:	e5d33000 	ldrb	r3, [r3]
   282e4:	e35300ff 	cmp	r3, #255	; 0xff
   282e8:	0a000015 	beq	28344 <_vfiprintf_r+0xed4>
					      && _uquad > 9) {
   282ec:	e24b3044 	sub	r3, fp, #68	; 0x44
   282f0:	e893000c 	ldm	r3, {r2, r3}
   282f4:	e3530000 	cmp	r3, #0
   282f8:	03520009 	cmpeq	r2, #9
   282fc:	9a000010 	bls	28344 <_vfiprintf_r+0xed4>
					    cp -= thsnd_len;
   28300:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   28304:	e2633000 	rsb	r3, r3, #0
   28308:	e0866003 	add	r6, r6, r3
					    strncpy (cp, thousands_sep,
   2830c:	e1a00006 	mov	r0, r6
   28310:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
   28314:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   28318:	ebfff554 	bl	25870 <strncpy>
						     thsnd_len);
					    ndig = 0;
   2831c:	e3a03000 	mov	r3, #0
   28320:	e50b3038 	str	r3, [fp, #-56]	; 0x38
					    /* If (grouping[1] == '\0') then we
					       have to use *grouping character
					       (last grouping rule) for all
					       next cases. */
					    if (grouping[1] != '\0')
   28324:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   28328:	e2833001 	add	r3, r3, #1
   2832c:	e5d33000 	ldrb	r3, [r3]
   28330:	e3530000 	cmp	r3, #0
   28334:	0a000002 	beq	28344 <_vfiprintf_r+0xed4>
					      grouping++;
   28338:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2833c:	e2833001 	add	r3, r3, #1
   28340:	e50b3034 	str	r3, [fp, #-52]	; 0x34
					  }
#endif
					  _uquad /= 10;
   28344:	e24b3044 	sub	r3, fp, #68	; 0x44
   28348:	e893000c 	ldm	r3, {r2, r3}
   2834c:	e1a00002 	mov	r0, r2
   28350:	e1a01003 	mov	r1, r3
   28354:	e3a0200a 	mov	r2, #10
   28358:	e3a03000 	mov	r3, #0
   2835c:	ebffb387 	bl	15180 <__aeabi_uldivmod>
   28360:	e1a02000 	mov	r2, r0
   28364:	e1a03001 	mov	r3, r1
   28368:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   2836c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
					} while (_uquad != 0);
   28370:	e24b3044 	sub	r3, fp, #68	; 0x44
   28374:	e893000c 	ldm	r3, {r2, r3}
   28378:	e1921003 	orrs	r1, r2, r3
   2837c:	1affffbe 	bne	2827c <_vfiprintf_r+0xe0c>
					break;
   28380:	ea00001f 	b	28404 <_vfiprintf_r+0xf94>

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   28384:	e2466001 	sub	r6, r6, #1
   28388:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2838c:	e203300f 	and	r3, r3, #15
   28390:	e51b2058 	ldr	r2, [fp, #-88]	; 0x58
   28394:	e0823003 	add	r3, r2, r3
   28398:	e5d33000 	ldrb	r3, [r3]
   2839c:	e5c63000 	strb	r3, [r6]
						_uquad >>= 4;
   283a0:	e24b3044 	sub	r3, fp, #68	; 0x44
   283a4:	e893000c 	ldm	r3, {r2, r3}
   283a8:	e1a01222 	lsr	r1, r2, #4
   283ac:	e50b1144 	str	r1, [fp, #-324]	; 0x144
   283b0:	e51b1144 	ldr	r1, [fp, #-324]	; 0x144
   283b4:	e1811e03 	orr	r1, r1, r3, lsl #28
   283b8:	e50b1144 	str	r1, [fp, #-324]	; 0x144
   283bc:	e1a01223 	lsr	r1, r3, #4
   283c0:	e50b1140 	str	r1, [fp, #-320]	; 0x140
   283c4:	e24b3f51 	sub	r3, fp, #324	; 0x144
   283c8:	e893000c 	ldm	r3, {r2, r3}
   283cc:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   283d0:	e50b3040 	str	r3, [fp, #-64]	; 0x40
					} while (_uquad);
   283d4:	e24b3044 	sub	r3, fp, #68	; 0x44
   283d8:	e893000c 	ldm	r3, {r2, r3}
   283dc:	e1921003 	orrs	r1, r2, r3
   283e0:	1affffe7 	bne	28384 <_vfiprintf_r+0xf14>
					break;
   283e4:	ea000006 	b	28404 <_vfiprintf_r+0xf94>

				default:
					cp = "bug in vfprintf: bad base";
   283e8:	e59f6730 	ldr	r6, [pc, #1840]	; 28b20 <_vfiprintf_r+0x16b0>
					size = strlen (cp);
   283ec:	e1a00006 	mov	r0, r6
   283f0:	ebffc3ae 	bl	192b0 <strlen>
   283f4:	e1a03000 	mov	r3, r0
   283f8:	e50b3054 	str	r3, [fp, #-84]	; 0x54
					goto skipsize;
   283fc:	e1a00000 	nop			; (mov r0, r0)
                       else if (base == OCT && (flags & ALT))
                         *--cp = '0';

			size = buf + BUF - cp;
		skipsize:
			break;
   28400:	ea00001a 	b	28470 <_vfiprintf_r+0x1000>
				default:
					cp = "bug in vfprintf: bad base";
					size = strlen (cp);
					goto skipsize;
				}
			}
   28404:	ea000008 	b	2842c <_vfiprintf_r+0xfbc>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   28408:	e55b3045 	ldrb	r3, [fp, #-69]	; 0x45
   2840c:	e3530000 	cmp	r3, #0
   28410:	1a000005 	bne	2842c <_vfiprintf_r+0xfbc>
   28414:	e2043001 	and	r3, r4, #1
   28418:	e3530000 	cmp	r3, #0
   2841c:	0a000002 	beq	2842c <_vfiprintf_r+0xfbc>
                         *--cp = '0';
   28420:	e2466001 	sub	r6, r6, #1
   28424:	e3a03030 	mov	r3, #48	; 0x30
   28428:	e5c63000 	strb	r3, [r6]

			size = buf + BUF - cp;
   2842c:	e24b3f47 	sub	r3, fp, #284	; 0x11c
   28430:	e2833064 	add	r3, r3, #100	; 0x64
   28434:	e1a02006 	mov	r2, r6
   28438:	e0623003 	rsb	r3, r2, r3
   2843c:	e50b3054 	str	r3, [fp, #-84]	; 0x54
		skipsize:
			break;
   28440:	ea00000a 	b	28470 <_vfiprintf_r+0x1000>
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
   28444:	e3590000 	cmp	r9, #0
   28448:	1a000000 	bne	28450 <_vfiprintf_r+0xfe0>
				goto done;
   2844c:	ea000180 	b	28a54 <_vfiprintf_r+0x15e4>
			/* pretend it was %c with argument ch */
			cp = buf;
   28450:	e24b6f47 	sub	r6, fp, #284	; 0x11c
			*cp = ch;
   28454:	e20930ff 	and	r3, r9, #255	; 0xff
   28458:	e5c63000 	strb	r3, [r6]
			size = 1;
   2845c:	e3a03001 	mov	r3, #1
   28460:	e50b3054 	str	r3, [fp, #-84]	; 0x54
			sign = '\0';
   28464:	e3a03000 	mov	r3, #0
   28468:	e54b3069 	strb	r3, [fp, #-105]	; 0x69
			break;
   2846c:	e1a00000 	nop			; (mov r0, r0)
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
   28470:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   28474:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   28478:	e1520003 	cmp	r2, r3
   2847c:	a1a03002 	movge	r3, r2
   28480:	b1a03003 	movlt	r3, r3
   28484:	e50b3050 	str	r3, [fp, #-80]	; 0x50
		if (sign)
   28488:	e55b3069 	ldrb	r3, [fp, #-105]	; 0x69
   2848c:	e3530000 	cmp	r3, #0
   28490:	0a000002 	beq	284a0 <_vfiprintf_r+0x1030>
			realsz++;
   28494:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   28498:	e2833001 	add	r3, r3, #1
   2849c:	e50b3050 	str	r3, [fp, #-80]	; 0x50
		if (flags & HEXPREFIX)
   284a0:	e2043002 	and	r3, r4, #2
   284a4:	e3530000 	cmp	r3, #0
   284a8:	0a000002 	beq	284b8 <_vfiprintf_r+0x1048>
			realsz+= 2;
   284ac:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   284b0:	e2833002 	add	r3, r3, #2
   284b4:	e50b3050 	str	r3, [fp, #-80]	; 0x50

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   284b8:	e2043084 	and	r3, r4, #132	; 0x84
   284bc:	e3530000 	cmp	r3, #0
   284c0:	1a00003a 	bne	285b0 <_vfiprintf_r+0x1140>
			PAD (width - realsz, blanks);
   284c4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   284c8:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   284cc:	e0637002 	rsb	r7, r3, r2
   284d0:	e3570000 	cmp	r7, #0
   284d4:	da000035 	ble	285b0 <_vfiprintf_r+0x1140>
   284d8:	ea000019 	b	28544 <_vfiprintf_r+0x10d4>
   284dc:	e59f3640 	ldr	r3, [pc, #1600]	; 28b24 <_vfiprintf_r+0x16b4>
   284e0:	e5853000 	str	r3, [r5]
   284e4:	e3a03010 	mov	r3, #16
   284e8:	e5853004 	str	r3, [r5, #4]
   284ec:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   284f0:	e2833010 	add	r3, r3, #16
   284f4:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   284f8:	e2855008 	add	r5, r5, #8
   284fc:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   28500:	e2833001 	add	r3, r3, #1
   28504:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   28508:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   2850c:	e3530007 	cmp	r3, #7
   28510:	da00000a 	ble	28540 <_vfiprintf_r+0x10d0>
   28514:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   28518:	e24b3078 	sub	r3, fp, #120	; 0x78
   2851c:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   28520:	e1a01002 	mov	r1, r2
   28524:	e1a02003 	mov	r2, r3
   28528:	ebfffb20 	bl	271b0 <__sprint_r>
   2852c:	e1a03000 	mov	r3, r0
   28530:	e3530000 	cmp	r3, #0
   28534:	0a000000 	beq	2853c <_vfiprintf_r+0x10cc>
   28538:	ea000155 	b	28a94 <_vfiprintf_r+0x1624>
   2853c:	e24b50b8 	sub	r5, fp, #184	; 0xb8
   28540:	e2477010 	sub	r7, r7, #16
   28544:	e3570010 	cmp	r7, #16
   28548:	caffffe3 	bgt	284dc <_vfiprintf_r+0x106c>
   2854c:	e59f35d0 	ldr	r3, [pc, #1488]	; 28b24 <_vfiprintf_r+0x16b4>
   28550:	e5853000 	str	r3, [r5]
   28554:	e1a03007 	mov	r3, r7
   28558:	e5853004 	str	r3, [r5, #4]
   2855c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   28560:	e0833007 	add	r3, r3, r7
   28564:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   28568:	e2855008 	add	r5, r5, #8
   2856c:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   28570:	e2833001 	add	r3, r3, #1
   28574:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   28578:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   2857c:	e3530007 	cmp	r3, #7
   28580:	da00000a 	ble	285b0 <_vfiprintf_r+0x1140>
   28584:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   28588:	e24b3078 	sub	r3, fp, #120	; 0x78
   2858c:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   28590:	e1a01002 	mov	r1, r2
   28594:	e1a02003 	mov	r2, r3
   28598:	ebfffb04 	bl	271b0 <__sprint_r>
   2859c:	e1a03000 	mov	r3, r0
   285a0:	e3530000 	cmp	r3, #0
   285a4:	0a000000 	beq	285ac <_vfiprintf_r+0x113c>
   285a8:	ea000139 	b	28a94 <_vfiprintf_r+0x1624>
   285ac:	e24b50b8 	sub	r5, fp, #184	; 0xb8

		/* prefix */
		if (sign)
   285b0:	e55b3069 	ldrb	r3, [fp, #-105]	; 0x69
   285b4:	e3530000 	cmp	r3, #0
   285b8:	0a000018 	beq	28620 <_vfiprintf_r+0x11b0>
			PRINT (&sign, 1);
   285bc:	e24b3069 	sub	r3, fp, #105	; 0x69
   285c0:	e5853000 	str	r3, [r5]
   285c4:	e3a03001 	mov	r3, #1
   285c8:	e5853004 	str	r3, [r5, #4]
   285cc:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   285d0:	e2833001 	add	r3, r3, #1
   285d4:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   285d8:	e2855008 	add	r5, r5, #8
   285dc:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   285e0:	e2833001 	add	r3, r3, #1
   285e4:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   285e8:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   285ec:	e3530007 	cmp	r3, #7
   285f0:	da00000a 	ble	28620 <_vfiprintf_r+0x11b0>
   285f4:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   285f8:	e24b3078 	sub	r3, fp, #120	; 0x78
   285fc:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   28600:	e1a01002 	mov	r1, r2
   28604:	e1a02003 	mov	r2, r3
   28608:	ebfffae8 	bl	271b0 <__sprint_r>
   2860c:	e1a03000 	mov	r3, r0
   28610:	e3530000 	cmp	r3, #0
   28614:	0a000000 	beq	2861c <_vfiprintf_r+0x11ac>
   28618:	ea00011d 	b	28a94 <_vfiprintf_r+0x1624>
   2861c:	e24b50b8 	sub	r5, fp, #184	; 0xb8
		if (flags & HEXPREFIX)
   28620:	e2043002 	and	r3, r4, #2
   28624:	e3530000 	cmp	r3, #0
   28628:	0a000018 	beq	28690 <_vfiprintf_r+0x1220>
			PRINT (ox, 2);
   2862c:	e24b3e12 	sub	r3, fp, #288	; 0x120
   28630:	e5853000 	str	r3, [r5]
   28634:	e3a03002 	mov	r3, #2
   28638:	e5853004 	str	r3, [r5, #4]
   2863c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   28640:	e2833002 	add	r3, r3, #2
   28644:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   28648:	e2855008 	add	r5, r5, #8
   2864c:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   28650:	e2833001 	add	r3, r3, #1
   28654:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   28658:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   2865c:	e3530007 	cmp	r3, #7
   28660:	da00000a 	ble	28690 <_vfiprintf_r+0x1220>
   28664:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   28668:	e24b3078 	sub	r3, fp, #120	; 0x78
   2866c:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   28670:	e1a01002 	mov	r1, r2
   28674:	e1a02003 	mov	r2, r3
   28678:	ebfffacc 	bl	271b0 <__sprint_r>
   2867c:	e1a03000 	mov	r3, r0
   28680:	e3530000 	cmp	r3, #0
   28684:	0a000000 	beq	2868c <_vfiprintf_r+0x121c>
   28688:	ea000101 	b	28a94 <_vfiprintf_r+0x1624>
   2868c:	e24b50b8 	sub	r5, fp, #184	; 0xb8

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   28690:	e2043084 	and	r3, r4, #132	; 0x84
   28694:	e3530080 	cmp	r3, #128	; 0x80
   28698:	1a00003a 	bne	28788 <_vfiprintf_r+0x1318>
			PAD (width - realsz, zeroes);
   2869c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   286a0:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   286a4:	e0637002 	rsb	r7, r3, r2
   286a8:	e3570000 	cmp	r7, #0
   286ac:	da000035 	ble	28788 <_vfiprintf_r+0x1318>
   286b0:	ea000019 	b	2871c <_vfiprintf_r+0x12ac>
   286b4:	e59f346c 	ldr	r3, [pc, #1132]	; 28b28 <_vfiprintf_r+0x16b8>
   286b8:	e5853000 	str	r3, [r5]
   286bc:	e3a03010 	mov	r3, #16
   286c0:	e5853004 	str	r3, [r5, #4]
   286c4:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   286c8:	e2833010 	add	r3, r3, #16
   286cc:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   286d0:	e2855008 	add	r5, r5, #8
   286d4:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   286d8:	e2833001 	add	r3, r3, #1
   286dc:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   286e0:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   286e4:	e3530007 	cmp	r3, #7
   286e8:	da00000a 	ble	28718 <_vfiprintf_r+0x12a8>
   286ec:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   286f0:	e24b3078 	sub	r3, fp, #120	; 0x78
   286f4:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   286f8:	e1a01002 	mov	r1, r2
   286fc:	e1a02003 	mov	r2, r3
   28700:	ebfffaaa 	bl	271b0 <__sprint_r>
   28704:	e1a03000 	mov	r3, r0
   28708:	e3530000 	cmp	r3, #0
   2870c:	0a000000 	beq	28714 <_vfiprintf_r+0x12a4>
   28710:	ea0000df 	b	28a94 <_vfiprintf_r+0x1624>
   28714:	e24b50b8 	sub	r5, fp, #184	; 0xb8
   28718:	e2477010 	sub	r7, r7, #16
   2871c:	e3570010 	cmp	r7, #16
   28720:	caffffe3 	bgt	286b4 <_vfiprintf_r+0x1244>
   28724:	e59f33fc 	ldr	r3, [pc, #1020]	; 28b28 <_vfiprintf_r+0x16b8>
   28728:	e5853000 	str	r3, [r5]
   2872c:	e1a03007 	mov	r3, r7
   28730:	e5853004 	str	r3, [r5, #4]
   28734:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   28738:	e0833007 	add	r3, r3, r7
   2873c:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   28740:	e2855008 	add	r5, r5, #8
   28744:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   28748:	e2833001 	add	r3, r3, #1
   2874c:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   28750:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   28754:	e3530007 	cmp	r3, #7
   28758:	da00000a 	ble	28788 <_vfiprintf_r+0x1318>
   2875c:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   28760:	e24b3078 	sub	r3, fp, #120	; 0x78
   28764:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   28768:	e1a01002 	mov	r1, r2
   2876c:	e1a02003 	mov	r2, r3
   28770:	ebfffa8e 	bl	271b0 <__sprint_r>
   28774:	e1a03000 	mov	r3, r0
   28778:	e3530000 	cmp	r3, #0
   2877c:	0a000000 	beq	28784 <_vfiprintf_r+0x1314>
   28780:	ea0000c3 	b	28a94 <_vfiprintf_r+0x1624>
   28784:	e24b50b8 	sub	r5, fp, #184	; 0xb8

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   28788:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   2878c:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   28790:	e0637002 	rsb	r7, r3, r2
   28794:	e3570000 	cmp	r7, #0
   28798:	da000035 	ble	28874 <_vfiprintf_r+0x1404>
   2879c:	ea000019 	b	28808 <_vfiprintf_r+0x1398>
   287a0:	e59f3380 	ldr	r3, [pc, #896]	; 28b28 <_vfiprintf_r+0x16b8>
   287a4:	e5853000 	str	r3, [r5]
   287a8:	e3a03010 	mov	r3, #16
   287ac:	e5853004 	str	r3, [r5, #4]
   287b0:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   287b4:	e2833010 	add	r3, r3, #16
   287b8:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   287bc:	e2855008 	add	r5, r5, #8
   287c0:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   287c4:	e2833001 	add	r3, r3, #1
   287c8:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   287cc:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   287d0:	e3530007 	cmp	r3, #7
   287d4:	da00000a 	ble	28804 <_vfiprintf_r+0x1394>
   287d8:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   287dc:	e24b3078 	sub	r3, fp, #120	; 0x78
   287e0:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   287e4:	e1a01002 	mov	r1, r2
   287e8:	e1a02003 	mov	r2, r3
   287ec:	ebfffa6f 	bl	271b0 <__sprint_r>
   287f0:	e1a03000 	mov	r3, r0
   287f4:	e3530000 	cmp	r3, #0
   287f8:	0a000000 	beq	28800 <_vfiprintf_r+0x1390>
   287fc:	ea0000a4 	b	28a94 <_vfiprintf_r+0x1624>
   28800:	e24b50b8 	sub	r5, fp, #184	; 0xb8
   28804:	e2477010 	sub	r7, r7, #16
   28808:	e3570010 	cmp	r7, #16
   2880c:	caffffe3 	bgt	287a0 <_vfiprintf_r+0x1330>
   28810:	e59f3310 	ldr	r3, [pc, #784]	; 28b28 <_vfiprintf_r+0x16b8>
   28814:	e5853000 	str	r3, [r5]
   28818:	e1a03007 	mov	r3, r7
   2881c:	e5853004 	str	r3, [r5, #4]
   28820:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   28824:	e0833007 	add	r3, r3, r7
   28828:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   2882c:	e2855008 	add	r5, r5, #8
   28830:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   28834:	e2833001 	add	r3, r3, #1
   28838:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   2883c:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   28840:	e3530007 	cmp	r3, #7
   28844:	da00000a 	ble	28874 <_vfiprintf_r+0x1404>
   28848:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   2884c:	e24b3078 	sub	r3, fp, #120	; 0x78
   28850:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   28854:	e1a01002 	mov	r1, r2
   28858:	e1a02003 	mov	r2, r3
   2885c:	ebfffa53 	bl	271b0 <__sprint_r>
   28860:	e1a03000 	mov	r3, r0
   28864:	e3530000 	cmp	r3, #0
   28868:	0a000000 	beq	28870 <_vfiprintf_r+0x1400>
   2886c:	ea000088 	b	28a94 <_vfiprintf_r+0x1624>
   28870:	e24b50b8 	sub	r5, fp, #184	; 0xb8
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   28874:	e5856000 	str	r6, [r5]
   28878:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   2887c:	e5853004 	str	r3, [r5, #4]
   28880:	e51b2070 	ldr	r2, [fp, #-112]	; 0x70
   28884:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   28888:	e0823003 	add	r3, r2, r3
   2888c:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   28890:	e2855008 	add	r5, r5, #8
   28894:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   28898:	e2833001 	add	r3, r3, #1
   2889c:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   288a0:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   288a4:	e3530007 	cmp	r3, #7
   288a8:	da00000a 	ble	288d8 <_vfiprintf_r+0x1468>
   288ac:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   288b0:	e24b3078 	sub	r3, fp, #120	; 0x78
   288b4:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   288b8:	e1a01002 	mov	r1, r2
   288bc:	e1a02003 	mov	r2, r3
   288c0:	ebfffa3a 	bl	271b0 <__sprint_r>
   288c4:	e1a03000 	mov	r3, r0
   288c8:	e3530000 	cmp	r3, #0
   288cc:	0a000000 	beq	288d4 <_vfiprintf_r+0x1464>
   288d0:	ea00006f 	b	28a94 <_vfiprintf_r+0x1624>
   288d4:	e24b50b8 	sub	r5, fp, #184	; 0xb8
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   288d8:	e2043004 	and	r3, r4, #4
   288dc:	e3530000 	cmp	r3, #0
   288e0:	0a00003a 	beq	289d0 <_vfiprintf_r+0x1560>
			PAD (width - realsz, blanks);
   288e4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   288e8:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   288ec:	e0637002 	rsb	r7, r3, r2
   288f0:	e3570000 	cmp	r7, #0
   288f4:	da000035 	ble	289d0 <_vfiprintf_r+0x1560>
   288f8:	ea000019 	b	28964 <_vfiprintf_r+0x14f4>
   288fc:	e59f3220 	ldr	r3, [pc, #544]	; 28b24 <_vfiprintf_r+0x16b4>
   28900:	e5853000 	str	r3, [r5]
   28904:	e3a03010 	mov	r3, #16
   28908:	e5853004 	str	r3, [r5, #4]
   2890c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   28910:	e2833010 	add	r3, r3, #16
   28914:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   28918:	e2855008 	add	r5, r5, #8
   2891c:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   28920:	e2833001 	add	r3, r3, #1
   28924:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   28928:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   2892c:	e3530007 	cmp	r3, #7
   28930:	da00000a 	ble	28960 <_vfiprintf_r+0x14f0>
   28934:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   28938:	e24b3078 	sub	r3, fp, #120	; 0x78
   2893c:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   28940:	e1a01002 	mov	r1, r2
   28944:	e1a02003 	mov	r2, r3
   28948:	ebfffa18 	bl	271b0 <__sprint_r>
   2894c:	e1a03000 	mov	r3, r0
   28950:	e3530000 	cmp	r3, #0
   28954:	0a000000 	beq	2895c <_vfiprintf_r+0x14ec>
   28958:	ea00004d 	b	28a94 <_vfiprintf_r+0x1624>
   2895c:	e24b50b8 	sub	r5, fp, #184	; 0xb8
   28960:	e2477010 	sub	r7, r7, #16
   28964:	e3570010 	cmp	r7, #16
   28968:	caffffe3 	bgt	288fc <_vfiprintf_r+0x148c>
   2896c:	e59f31b0 	ldr	r3, [pc, #432]	; 28b24 <_vfiprintf_r+0x16b4>
   28970:	e5853000 	str	r3, [r5]
   28974:	e1a03007 	mov	r3, r7
   28978:	e5853004 	str	r3, [r5, #4]
   2897c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   28980:	e0833007 	add	r3, r3, r7
   28984:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   28988:	e2855008 	add	r5, r5, #8
   2898c:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   28990:	e2833001 	add	r3, r3, #1
   28994:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   28998:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   2899c:	e3530007 	cmp	r3, #7
   289a0:	da00000a 	ble	289d0 <_vfiprintf_r+0x1560>
   289a4:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   289a8:	e24b3078 	sub	r3, fp, #120	; 0x78
   289ac:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   289b0:	e1a01002 	mov	r1, r2
   289b4:	e1a02003 	mov	r2, r3
   289b8:	ebfff9fc 	bl	271b0 <__sprint_r>
   289bc:	e1a03000 	mov	r3, r0
   289c0:	e3530000 	cmp	r3, #0
   289c4:	0a000000 	beq	289cc <_vfiprintf_r+0x155c>
   289c8:	ea000031 	b	28a94 <_vfiprintf_r+0x1624>
   289cc:	e24b50b8 	sub	r5, fp, #184	; 0xb8

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   289d0:	e51b2050 	ldr	r2, [fp, #-80]	; 0x50
   289d4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   289d8:	e1520003 	cmp	r2, r3
   289dc:	a1a03002 	movge	r3, r2
   289e0:	b1a03003 	movlt	r3, r3
   289e4:	e51b2020 	ldr	r2, [fp, #-32]
   289e8:	e0823003 	add	r3, r2, r3
   289ec:	e50b3020 	str	r3, [fp, #-32]

		FLUSH ();	/* copy out the I/O vectors */
   289f0:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   289f4:	e3530000 	cmp	r3, #0
   289f8:	0a000009 	beq	28a24 <_vfiprintf_r+0x15b4>
   289fc:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   28a00:	e24b3078 	sub	r3, fp, #120	; 0x78
   28a04:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   28a08:	e1a01002 	mov	r1, r2
   28a0c:	e1a02003 	mov	r2, r3
   28a10:	ebfff9e6 	bl	271b0 <__sprint_r>
   28a14:	e1a03000 	mov	r3, r0
   28a18:	e3530000 	cmp	r3, #0
   28a1c:	0a000000 	beq	28a24 <_vfiprintf_r+0x15b4>
   28a20:	ea00001b 	b	28a94 <_vfiprintf_r+0x1624>
   28a24:	e3a03000 	mov	r3, #0
   28a28:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   28a2c:	e24b50b8 	sub	r5, fp, #184	; 0xb8

                if (malloc_buf != NULL) {
   28a30:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   28a34:	e3530000 	cmp	r3, #0
   28a38:	0a000004 	beq	28a50 <_vfiprintf_r+0x15e0>
			_free_r (data, malloc_buf);
   28a3c:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   28a40:	e51b105c 	ldr	r1, [fp, #-92]	; 0x5c
   28a44:	ebffb791 	bl	16890 <_free_r>
			malloc_buf = NULL;
   28a48:	e3a03000 	mov	r3, #0
   28a4c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
		}
	}
   28a50:	eafffb22 	b	276e0 <_vfiprintf_r+0x270>
done:
	FLUSH ();
   28a54:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   28a58:	e3530000 	cmp	r3, #0
   28a5c:	0a000009 	beq	28a88 <_vfiprintf_r+0x1618>
   28a60:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   28a64:	e24b3078 	sub	r3, fp, #120	; 0x78
   28a68:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   28a6c:	e1a01002 	mov	r1, r2
   28a70:	e1a02003 	mov	r2, r3
   28a74:	ebfff9cd 	bl	271b0 <__sprint_r>
   28a78:	e1a03000 	mov	r3, r0
   28a7c:	e3530000 	cmp	r3, #0
   28a80:	0a000000 	beq	28a88 <_vfiprintf_r+0x1618>
   28a84:	ea000002 	b	28a94 <_vfiprintf_r+0x1624>
   28a88:	e3a03000 	mov	r3, #0
   28a8c:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   28a90:	e24b50b8 	sub	r5, fp, #184	; 0xb8
error:
	if (malloc_buf != NULL)
   28a94:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   28a98:	e3530000 	cmp	r3, #0
   28a9c:	0a000002 	beq	28aac <_vfiprintf_r+0x163c>
		_free_r (data, malloc_buf);
   28aa0:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   28aa4:	e51b105c 	ldr	r1, [fp, #-92]	; 0x5c
   28aa8:	ebffb778 	bl	16890 <_free_r>
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
   28aac:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   28ab0:	e1d330bc 	ldrh	r3, [r3, #12]
   28ab4:	e1a03803 	lsl	r3, r3, #16
   28ab8:	e1a03823 	lsr	r3, r3, #16
   28abc:	e2033c02 	and	r3, r3, #512	; 0x200
   28ac0:	e3530000 	cmp	r3, #0
   28ac4:	1a000003 	bne	28ad8 <_vfiprintf_r+0x1668>
   28ac8:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   28acc:	e283305c 	add	r3, r3, #92	; 0x5c
   28ad0:	e1a00003 	mov	r0, r3
   28ad4:	ebffbad0 	bl	1761c <_dna_lock_release>
#endif
	return (__sferror (fp) ? EOF : ret);
   28ad8:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   28adc:	e1d330bc 	ldrh	r3, [r3, #12]
   28ae0:	e1a03803 	lsl	r3, r3, #16
   28ae4:	e1a03823 	lsr	r3, r3, #16
   28ae8:	e2033040 	and	r3, r3, #64	; 0x40
   28aec:	e3530000 	cmp	r3, #0
   28af0:	1a000001 	bne	28afc <_vfiprintf_r+0x168c>
   28af4:	e51b3020 	ldr	r3, [fp, #-32]
   28af8:	ea000000 	b	28b00 <_vfiprintf_r+0x1690>
   28afc:	e3e03000 	mvn	r3, #0
   28b00:	e1a00000 	nop			; (mov r0, r0)
	/* NOTREACHED */
}
   28b04:	e1a00003 	mov	r0, r3
   28b08:	e24bd01c 	sub	sp, fp, #28
   28b0c:	e8bd4bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, lr}
   28b10:	e12fff1e 	bx	lr
   28b14:	00033324 	.word	0x00033324
   28b18:	00033338 	.word	0x00033338
   28b1c:	00033340 	.word	0x00033340
   28b20:	00033354 	.word	0x00033354
   28b24:	00033370 	.word	0x00033370
   28b28:	00033380 	.word	0x00033380

00028b2c <_calloc_r>:
#if __STD_C
Void_t* cALLOc(RARG size_t n, size_t elem_size)
#else
Void_t* cALLOc(RARG n, elem_size) RDECL size_t n; size_t elem_size;
#endif
{
   28b2c:	e92d4800 	push	{fp, lr}
   28b30:	e28db004 	add	fp, sp, #4
   28b34:	e24dd028 	sub	sp, sp, #40	; 0x28
   28b38:	e50b0020 	str	r0, [fp, #-32]
   28b3c:	e50b1024 	str	r1, [fp, #-36]	; 0x24
   28b40:	e50b2028 	str	r2, [fp, #-40]	; 0x28
  mchunkptr p;
  INTERNAL_SIZE_T csz;

  INTERNAL_SIZE_T sz = n * elem_size;
   28b44:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   28b48:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   28b4c:	e0030392 	mul	r3, r2, r3
   28b50:	e50b300c 	str	r3, [fp, #-12]
  MALLOC_LOCK;
  oldtop = top;
  oldtopsize = chunksize(top);
#endif

  mem = mALLOc (RCALL sz);
   28b54:	e51b0020 	ldr	r0, [fp, #-32]
   28b58:	e51b100c 	ldr	r1, [fp, #-12]
   28b5c:	ebffbbd4 	bl	17ab4 <_malloc_r>
   28b60:	e50b0010 	str	r0, [fp, #-16]

  if (mem == 0) 
   28b64:	e51b3010 	ldr	r3, [fp, #-16]
   28b68:	e3530000 	cmp	r3, #0
   28b6c:	1a000001 	bne	28b78 <_calloc_r+0x4c>
  {
#if MORECORE_CLEARS
    MALLOC_UNLOCK;
#endif
    return 0;
   28b70:	e3a03000 	mov	r3, #0
   28b74:	ea000048 	b	28c9c <_calloc_r+0x170>
  }
  else
  {
    p = mem2chunk(mem);
   28b78:	e51b3010 	ldr	r3, [fp, #-16]
   28b7c:	e2433008 	sub	r3, r3, #8
   28b80:	e50b3014 	str	r3, [fp, #-20]
#endif
      return mem;
    }
#endif

    csz = chunksize(p);
   28b84:	e51b3014 	ldr	r3, [fp, #-20]
   28b88:	e5933004 	ldr	r3, [r3, #4]
   28b8c:	e3c33003 	bic	r3, r3, #3
   28b90:	e50b3018 	str	r3, [fp, #-24]
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   28b94:	e51b3018 	ldr	r3, [fp, #-24]
   28b98:	e2433004 	sub	r3, r3, #4
   28b9c:	e50b301c 	str	r3, [fp, #-28]
   28ba0:	e51b301c 	ldr	r3, [fp, #-28]
   28ba4:	e3530024 	cmp	r3, #36	; 0x24
   28ba8:	8a000036 	bhi	28c88 <_calloc_r+0x15c>
   28bac:	e51b3010 	ldr	r3, [fp, #-16]
   28bb0:	e50b3008 	str	r3, [fp, #-8]
   28bb4:	e51b301c 	ldr	r3, [fp, #-28]
   28bb8:	e3530013 	cmp	r3, #19
   28bbc:	9a000023 	bls	28c50 <_calloc_r+0x124>
   28bc0:	e51b3008 	ldr	r3, [fp, #-8]
   28bc4:	e2832004 	add	r2, r3, #4
   28bc8:	e50b2008 	str	r2, [fp, #-8]
   28bcc:	e3a02000 	mov	r2, #0
   28bd0:	e5832000 	str	r2, [r3]
   28bd4:	e51b3008 	ldr	r3, [fp, #-8]
   28bd8:	e2832004 	add	r2, r3, #4
   28bdc:	e50b2008 	str	r2, [fp, #-8]
   28be0:	e3a02000 	mov	r2, #0
   28be4:	e5832000 	str	r2, [r3]
   28be8:	e51b301c 	ldr	r3, [fp, #-28]
   28bec:	e353001b 	cmp	r3, #27
   28bf0:	9a000016 	bls	28c50 <_calloc_r+0x124>
   28bf4:	e51b3008 	ldr	r3, [fp, #-8]
   28bf8:	e2832004 	add	r2, r3, #4
   28bfc:	e50b2008 	str	r2, [fp, #-8]
   28c00:	e3a02000 	mov	r2, #0
   28c04:	e5832000 	str	r2, [r3]
   28c08:	e51b3008 	ldr	r3, [fp, #-8]
   28c0c:	e2832004 	add	r2, r3, #4
   28c10:	e50b2008 	str	r2, [fp, #-8]
   28c14:	e3a02000 	mov	r2, #0
   28c18:	e5832000 	str	r2, [r3]
   28c1c:	e51b301c 	ldr	r3, [fp, #-28]
   28c20:	e3530023 	cmp	r3, #35	; 0x23
   28c24:	9a000009 	bls	28c50 <_calloc_r+0x124>
   28c28:	e51b3008 	ldr	r3, [fp, #-8]
   28c2c:	e2832004 	add	r2, r3, #4
   28c30:	e50b2008 	str	r2, [fp, #-8]
   28c34:	e3a02000 	mov	r2, #0
   28c38:	e5832000 	str	r2, [r3]
   28c3c:	e51b3008 	ldr	r3, [fp, #-8]
   28c40:	e2832004 	add	r2, r3, #4
   28c44:	e50b2008 	str	r2, [fp, #-8]
   28c48:	e3a02000 	mov	r2, #0
   28c4c:	e5832000 	str	r2, [r3]
   28c50:	e51b3008 	ldr	r3, [fp, #-8]
   28c54:	e2832004 	add	r2, r3, #4
   28c58:	e50b2008 	str	r2, [fp, #-8]
   28c5c:	e3a02000 	mov	r2, #0
   28c60:	e5832000 	str	r2, [r3]
   28c64:	e51b3008 	ldr	r3, [fp, #-8]
   28c68:	e2832004 	add	r2, r3, #4
   28c6c:	e50b2008 	str	r2, [fp, #-8]
   28c70:	e3a02000 	mov	r2, #0
   28c74:	e5832000 	str	r2, [r3]
   28c78:	e51b3008 	ldr	r3, [fp, #-8]
   28c7c:	e3a02000 	mov	r2, #0
   28c80:	e5832000 	str	r2, [r3]
   28c84:	ea000003 	b	28c98 <_calloc_r+0x16c>
   28c88:	e51b0010 	ldr	r0, [fp, #-16]
   28c8c:	e3a01000 	mov	r1, #0
   28c90:	e51b201c 	ldr	r2, [fp, #-28]
   28c94:	ebffbeb7 	bl	18778 <memset>
    return mem;
   28c98:	e51b3010 	ldr	r3, [fp, #-16]
  }
}
   28c9c:	e1a00003 	mov	r0, r3
   28ca0:	e24bd004 	sub	sp, fp, #4
   28ca4:	e8bd4800 	pop	{fp, lr}
   28ca8:	e12fff1e 	bx	lr

00028cac <__fputwc>:
static wint_t
_DEFUN(__fputwc, (ptr, wc, fp),
	struct _reent *ptr _AND
	wchar_t wc _AND
	FILE *fp)
{
   28cac:	e92d4800 	push	{fp, lr}
   28cb0:	e28db004 	add	fp, sp, #4
   28cb4:	e24dd020 	sub	sp, sp, #32
   28cb8:	e50b0018 	str	r0, [fp, #-24]
   28cbc:	e50b101c 	str	r1, [fp, #-28]
   28cc0:	e50b2020 	str	r2, [fp, #-32]
  char buf[MB_LEN_MAX];
  size_t i, len;

  if (MB_CUR_MAX == 1 && wc > 0 && wc <= UCHAR_MAX)
   28cc4:	ebffe55d 	bl	22240 <__locale_mb_cur_max>
   28cc8:	e1a03000 	mov	r3, r0
   28ccc:	e3530001 	cmp	r3, #1
   28cd0:	1a00000b 	bne	28d04 <__fputwc+0x58>
   28cd4:	e51b301c 	ldr	r3, [fp, #-28]
   28cd8:	e3530000 	cmp	r3, #0
   28cdc:	0a000008 	beq	28d04 <__fputwc+0x58>
   28ce0:	e51b301c 	ldr	r3, [fp, #-28]
   28ce4:	e35300ff 	cmp	r3, #255	; 0xff
   28ce8:	8a000005 	bhi	28d04 <__fputwc+0x58>
      /*
       * Assume single-byte locale with no special encoding.
       * A more careful test would be to check
       * _CurrentRuneLocale->encoding.
       */
      *buf = (unsigned char)wc;
   28cec:	e51b301c 	ldr	r3, [fp, #-28]
   28cf0:	e20330ff 	and	r3, r3, #255	; 0xff
   28cf4:	e54b3010 	strb	r3, [fp, #-16]
      len = 1;
   28cf8:	e3a03001 	mov	r3, #1
   28cfc:	e50b300c 	str	r3, [fp, #-12]
   28d00:	ea000013 	b	28d54 <__fputwc+0xa8>
    }
  else
    {
      if ((len = _wcrtomb_r (ptr, buf, wc, &fp->_mbstate)) == (size_t) -1)
   28d04:	e51b3020 	ldr	r3, [fp, #-32]
   28d08:	e2833064 	add	r3, r3, #100	; 0x64
   28d0c:	e24b2010 	sub	r2, fp, #16
   28d10:	e51b0018 	ldr	r0, [fp, #-24]
   28d14:	e1a01002 	mov	r1, r2
   28d18:	e51b201c 	ldr	r2, [fp, #-28]
   28d1c:	eb00019b 	bl	29390 <_wcrtomb_r>
   28d20:	e50b000c 	str	r0, [fp, #-12]
   28d24:	e51b300c 	ldr	r3, [fp, #-12]
   28d28:	e3730001 	cmn	r3, #1
   28d2c:	1a000008 	bne	28d54 <__fputwc+0xa8>
	{
	  fp->_flags |= __SERR;
   28d30:	e51b3020 	ldr	r3, [fp, #-32]
   28d34:	e1d330bc 	ldrh	r3, [r3, #12]
   28d38:	e3833040 	orr	r3, r3, #64	; 0x40
   28d3c:	e1a03803 	lsl	r3, r3, #16
   28d40:	e1a02823 	lsr	r2, r3, #16
   28d44:	e51b3020 	ldr	r3, [fp, #-32]
   28d48:	e1c320bc 	strh	r2, [r3, #12]
	  return WEOF;
   28d4c:	e3e03000 	mvn	r3, #0
   28d50:	ea000063 	b	28ee4 <__fputwc+0x238>
	}
    }

  for (i = 0; i < len; i++)
   28d54:	e3a03000 	mov	r3, #0
   28d58:	e50b3008 	str	r3, [fp, #-8]
   28d5c:	ea00005b 	b	28ed0 <__fputwc+0x224>
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
   28d60:	e51b3020 	ldr	r3, [fp, #-32]
   28d64:	e5933008 	ldr	r3, [r3, #8]
   28d68:	e2432001 	sub	r2, r3, #1
   28d6c:	e51b3020 	ldr	r3, [fp, #-32]
   28d70:	e5832008 	str	r2, [r3, #8]
   28d74:	e51b3020 	ldr	r3, [fp, #-32]
   28d78:	e5933008 	ldr	r3, [r3, #8]
   28d7c:	e3530000 	cmp	r3, #0
   28d80:	aa000038 	bge	28e68 <__fputwc+0x1bc>
   28d84:	e51b3020 	ldr	r3, [fp, #-32]
   28d88:	e5932008 	ldr	r2, [r3, #8]
   28d8c:	e51b3020 	ldr	r3, [fp, #-32]
   28d90:	e5933018 	ldr	r3, [r3, #24]
   28d94:	e1520003 	cmp	r2, r3
   28d98:	ba000022 	blt	28e28 <__fputwc+0x17c>
   28d9c:	e51b3020 	ldr	r3, [fp, #-32]
   28da0:	e5933000 	ldr	r3, [r3]
   28da4:	e3e0200b 	mvn	r2, #11
   28da8:	e51b1008 	ldr	r1, [fp, #-8]
   28dac:	e24b0004 	sub	r0, fp, #4
   28db0:	e0801001 	add	r1, r0, r1
   28db4:	e0812002 	add	r2, r1, r2
   28db8:	e5d22000 	ldrb	r2, [r2]
   28dbc:	e5c32000 	strb	r2, [r3]
   28dc0:	e51b3020 	ldr	r3, [fp, #-32]
   28dc4:	e5933000 	ldr	r3, [r3]
   28dc8:	e5d33000 	ldrb	r3, [r3]
   28dcc:	e353000a 	cmp	r3, #10
   28dd0:	0a00000a 	beq	28e00 <__fputwc+0x154>
   28dd4:	e51b3020 	ldr	r3, [fp, #-32]
   28dd8:	e5933000 	ldr	r3, [r3]
   28ddc:	e2831001 	add	r1, r3, #1
   28de0:	e51b2020 	ldr	r2, [fp, #-32]
   28de4:	e5821000 	str	r1, [r2]
   28de8:	e5d33000 	ldrb	r3, [r3]
   28dec:	e3730001 	cmn	r3, #1
   28df0:	03a03001 	moveq	r3, #1
   28df4:	13a03000 	movne	r3, #0
   28df8:	e20330ff 	and	r3, r3, #255	; 0xff
   28dfc:	ea00002c 	b	28eb4 <__fputwc+0x208>
   28e00:	e51b0018 	ldr	r0, [fp, #-24]
   28e04:	e3a0100a 	mov	r1, #10
   28e08:	e51b2020 	ldr	r2, [fp, #-32]
   28e0c:	eb0000ea 	bl	291bc <__swbuf_r>
   28e10:	e1a03000 	mov	r3, r0
   28e14:	e3730001 	cmn	r3, #1
   28e18:	03a03001 	moveq	r3, #1
   28e1c:	13a03000 	movne	r3, #0
   28e20:	e20330ff 	and	r3, r3, #255	; 0xff
   28e24:	ea000022 	b	28eb4 <__fputwc+0x208>
   28e28:	e3e0300b 	mvn	r3, #11
   28e2c:	e51b2008 	ldr	r2, [fp, #-8]
   28e30:	e24b1004 	sub	r1, fp, #4
   28e34:	e0812002 	add	r2, r1, r2
   28e38:	e0823003 	add	r3, r2, r3
   28e3c:	e5d33000 	ldrb	r3, [r3]
   28e40:	e51b0018 	ldr	r0, [fp, #-24]
   28e44:	e1a01003 	mov	r1, r3
   28e48:	e51b2020 	ldr	r2, [fp, #-32]
   28e4c:	eb0000da 	bl	291bc <__swbuf_r>
   28e50:	e1a03000 	mov	r3, r0
   28e54:	e3730001 	cmn	r3, #1
   28e58:	03a03001 	moveq	r3, #1
   28e5c:	13a03000 	movne	r3, #0
   28e60:	e20330ff 	and	r3, r3, #255	; 0xff
   28e64:	ea000012 	b	28eb4 <__fputwc+0x208>
   28e68:	e51b3020 	ldr	r3, [fp, #-32]
   28e6c:	e5933000 	ldr	r3, [r3]
   28e70:	e3e0200b 	mvn	r2, #11
   28e74:	e51b1008 	ldr	r1, [fp, #-8]
   28e78:	e24b0004 	sub	r0, fp, #4
   28e7c:	e0801001 	add	r1, r0, r1
   28e80:	e0812002 	add	r2, r1, r2
   28e84:	e5d22000 	ldrb	r2, [r2]
   28e88:	e5c32000 	strb	r2, [r3]
   28e8c:	e51b3020 	ldr	r3, [fp, #-32]
   28e90:	e5933000 	ldr	r3, [r3]
   28e94:	e2831001 	add	r1, r3, #1
   28e98:	e51b2020 	ldr	r2, [fp, #-32]
   28e9c:	e5821000 	str	r1, [r2]
   28ea0:	e5d33000 	ldrb	r3, [r3]
   28ea4:	e3730001 	cmn	r3, #1
   28ea8:	03a03001 	moveq	r3, #1
   28eac:	13a03000 	movne	r3, #0
   28eb0:	e20330ff 	and	r3, r3, #255	; 0xff
   28eb4:	e3530000 	cmp	r3, #0
   28eb8:	0a000001 	beq	28ec4 <__fputwc+0x218>
      return WEOF;
   28ebc:	e3e03000 	mvn	r3, #0
   28ec0:	ea000007 	b	28ee4 <__fputwc+0x238>
	  fp->_flags |= __SERR;
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
   28ec4:	e51b3008 	ldr	r3, [fp, #-8]
   28ec8:	e2833001 	add	r3, r3, #1
   28ecc:	e50b3008 	str	r3, [fp, #-8]
   28ed0:	e51b2008 	ldr	r2, [fp, #-8]
   28ed4:	e51b300c 	ldr	r3, [fp, #-12]
   28ed8:	e1520003 	cmp	r2, r3
   28edc:	3affff9f 	bcc	28d60 <__fputwc+0xb4>
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
      return WEOF;

  return (wint_t) wc;
   28ee0:	e51b301c 	ldr	r3, [fp, #-28]
}
   28ee4:	e1a00003 	mov	r0, r3
   28ee8:	e24bd004 	sub	sp, fp, #4
   28eec:	e8bd4800 	pop	{fp, lr}
   28ef0:	e12fff1e 	bx	lr

00028ef4 <_fputwc_r>:
wint_t
_DEFUN(_fputwc_r, (ptr, wc, fp),
	struct _reent *ptr _AND
	wchar_t wc _AND
	FILE *fp)
{
   28ef4:	e92d4800 	push	{fp, lr}
   28ef8:	e28db004 	add	fp, sp, #4
   28efc:	e24dd018 	sub	sp, sp, #24
   28f00:	e50b0010 	str	r0, [fp, #-16]
   28f04:	e50b1014 	str	r1, [fp, #-20]
   28f08:	e50b2018 	str	r2, [fp, #-24]
  wint_t r;

  _newlib_flockfile_start (fp);
   28f0c:	e51b3018 	ldr	r3, [fp, #-24]
   28f10:	e1d330bc 	ldrh	r3, [r3, #12]
   28f14:	e1a03803 	lsl	r3, r3, #16
   28f18:	e1a03823 	lsr	r3, r3, #16
   28f1c:	e2033c02 	and	r3, r3, #512	; 0x200
   28f20:	e3530000 	cmp	r3, #0
   28f24:	1a000003 	bne	28f38 <_fputwc_r+0x44>
   28f28:	e51b3018 	ldr	r3, [fp, #-24]
   28f2c:	e283305c 	add	r3, r3, #92	; 0x5c
   28f30:	e1a00003 	mov	r0, r3
   28f34:	ebffb951 	bl	17480 <_dna_lock_acquire>
  ORIENT(fp, 1);
   28f38:	e51b3018 	ldr	r3, [fp, #-24]
   28f3c:	e1d330bc 	ldrh	r3, [r3, #12]
   28f40:	e1a03803 	lsl	r3, r3, #16
   28f44:	e1a03823 	lsr	r3, r3, #16
   28f48:	e2033a02 	and	r3, r3, #8192	; 0x2000
   28f4c:	e3530000 	cmp	r3, #0
   28f50:	1a00000b 	bne	28f84 <_fputwc_r+0x90>
   28f54:	e51b3018 	ldr	r3, [fp, #-24]
   28f58:	e1d330bc 	ldrh	r3, [r3, #12]
   28f5c:	e3833a02 	orr	r3, r3, #8192	; 0x2000
   28f60:	e1a03803 	lsl	r3, r3, #16
   28f64:	e1a02823 	lsr	r2, r3, #16
   28f68:	e51b3018 	ldr	r3, [fp, #-24]
   28f6c:	e1c320bc 	strh	r2, [r3, #12]
   28f70:	e51b3018 	ldr	r3, [fp, #-24]
   28f74:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
   28f78:	e3832a02 	orr	r2, r3, #8192	; 0x2000
   28f7c:	e51b3018 	ldr	r3, [fp, #-24]
   28f80:	e583206c 	str	r2, [r3, #108]	; 0x6c
  r = __fputwc(ptr, wc, fp);
   28f84:	e51b0010 	ldr	r0, [fp, #-16]
   28f88:	e51b1014 	ldr	r1, [fp, #-20]
   28f8c:	e51b2018 	ldr	r2, [fp, #-24]
   28f90:	ebffff45 	bl	28cac <__fputwc>
   28f94:	e50b0008 	str	r0, [fp, #-8]
  _newlib_flockfile_end (fp);
   28f98:	e51b3018 	ldr	r3, [fp, #-24]
   28f9c:	e1d330bc 	ldrh	r3, [r3, #12]
   28fa0:	e1a03803 	lsl	r3, r3, #16
   28fa4:	e1a03823 	lsr	r3, r3, #16
   28fa8:	e2033c02 	and	r3, r3, #512	; 0x200
   28fac:	e3530000 	cmp	r3, #0
   28fb0:	1a000003 	bne	28fc4 <_fputwc_r+0xd0>
   28fb4:	e51b3018 	ldr	r3, [fp, #-24]
   28fb8:	e283305c 	add	r3, r3, #92	; 0x5c
   28fbc:	e1a00003 	mov	r0, r3
   28fc0:	ebffb995 	bl	1761c <_dna_lock_release>
  return r;
   28fc4:	e51b3008 	ldr	r3, [fp, #-8]
}
   28fc8:	e1a00003 	mov	r0, r3
   28fcc:	e24bd004 	sub	sp, fp, #4
   28fd0:	e8bd4800 	pop	{fp, lr}
   28fd4:	e12fff1e 	bx	lr

00028fd8 <fputwc>:

wint_t
_DEFUN(fputwc, (wc, fp),
	wchar_t wc _AND
	FILE *fp)
{
   28fd8:	e92d4800 	push	{fp, lr}
   28fdc:	e28db004 	add	fp, sp, #4
   28fe0:	e24dd010 	sub	sp, sp, #16
   28fe4:	e50b0010 	str	r0, [fp, #-16]
   28fe8:	e50b1014 	str	r1, [fp, #-20]
  struct _reent *reent = _REENT;
   28fec:	e59f3054 	ldr	r3, [pc, #84]	; 29048 <fputwc+0x70>
   28ff0:	e5933000 	ldr	r3, [r3]
   28ff4:	e50b3008 	str	r3, [fp, #-8]

  CHECK_INIT(reent, fp);
   28ff8:	e51b3008 	ldr	r3, [fp, #-8]
   28ffc:	e50b300c 	str	r3, [fp, #-12]
   29000:	e51b300c 	ldr	r3, [fp, #-12]
   29004:	e3530000 	cmp	r3, #0
   29008:	0a000005 	beq	29024 <fputwc+0x4c>
   2900c:	e51b300c 	ldr	r3, [fp, #-12]
   29010:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   29014:	e3530000 	cmp	r3, #0
   29018:	1a000001 	bne	29024 <fputwc+0x4c>
   2901c:	e51b000c 	ldr	r0, [fp, #-12]
   29020:	ebffb559 	bl	1658c <__sinit>
  return _fputwc_r (reent, wc, fp);
   29024:	e51b0008 	ldr	r0, [fp, #-8]
   29028:	e51b1010 	ldr	r1, [fp, #-16]
   2902c:	e51b2014 	ldr	r2, [fp, #-20]
   29030:	ebffffaf 	bl	28ef4 <_fputwc_r>
   29034:	e1a03000 	mov	r3, r0
}
   29038:	e1a00003 	mov	r0, r3
   2903c:	e24bd004 	sub	sp, fp, #4
   29040:	e8bd4800 	pop	{fp, lr}
   29044:	e12fff1e 	bx	lr
   29048:	0003e460 	.word	0x0003e460

0002904c <_fstat_r>:
int
_fstat_r (ptr, fd, pstat)
     struct _reent *ptr;
     int fd;
     struct stat *pstat;
{
   2904c:	e92d4800 	push	{fp, lr}
   29050:	e28db004 	add	fp, sp, #4
   29054:	e24dd018 	sub	sp, sp, #24
   29058:	e50b0010 	str	r0, [fp, #-16]
   2905c:	e50b1014 	str	r1, [fp, #-20]
   29060:	e50b2018 	str	r2, [fp, #-24]
  int ret;

  errno = 0;
   29064:	e59f3054 	ldr	r3, [pc, #84]	; 290c0 <_fstat_r+0x74>
   29068:	e3a02000 	mov	r2, #0
   2906c:	e5832000 	str	r2, [r3]
  if ((ret = _fstat (fd, pstat)) == -1 && errno != 0)
   29070:	e51b0014 	ldr	r0, [fp, #-20]
   29074:	e51b1018 	ldr	r1, [fp, #-24]
   29078:	eb00016c 	bl	29630 <fstat>
   2907c:	e50b0008 	str	r0, [fp, #-8]
   29080:	e51b3008 	ldr	r3, [fp, #-8]
   29084:	e3730001 	cmn	r3, #1
   29088:	1a000007 	bne	290ac <_fstat_r+0x60>
   2908c:	e59f302c 	ldr	r3, [pc, #44]	; 290c0 <_fstat_r+0x74>
   29090:	e5933000 	ldr	r3, [r3]
   29094:	e3530000 	cmp	r3, #0
   29098:	0a000003 	beq	290ac <_fstat_r+0x60>
    ptr->_errno = errno;
   2909c:	e59f301c 	ldr	r3, [pc, #28]	; 290c0 <_fstat_r+0x74>
   290a0:	e5932000 	ldr	r2, [r3]
   290a4:	e51b3010 	ldr	r3, [fp, #-16]
   290a8:	e5832000 	str	r2, [r3]
  return ret;
   290ac:	e51b3008 	ldr	r3, [fp, #-8]
}
   290b0:	e1a00003 	mov	r0, r3
   290b4:	e24bd004 	sub	sp, fp, #4
   290b8:	e8bd4800 	pop	{fp, lr}
   290bc:	e12fff1e 	bx	lr
   290c0:	0018b940 	.word	0x0018b940

000290c4 <_isatty_r>:

int
_isatty_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
   290c4:	e92d4800 	push	{fp, lr}
   290c8:	e28db004 	add	fp, sp, #4
   290cc:	e24dd010 	sub	sp, sp, #16
   290d0:	e50b0010 	str	r0, [fp, #-16]
   290d4:	e50b1014 	str	r1, [fp, #-20]
  int ret;

  errno = 0;
   290d8:	e59f3050 	ldr	r3, [pc, #80]	; 29130 <_isatty_r+0x6c>
   290dc:	e3a02000 	mov	r2, #0
   290e0:	e5832000 	str	r2, [r3]
  if ((ret = _isatty (fd)) == -1 && errno != 0)
   290e4:	e51b0014 	ldr	r0, [fp, #-20]
   290e8:	eb00015a 	bl	29658 <isatty>
   290ec:	e50b0008 	str	r0, [fp, #-8]
   290f0:	e51b3008 	ldr	r3, [fp, #-8]
   290f4:	e3730001 	cmn	r3, #1
   290f8:	1a000007 	bne	2911c <_isatty_r+0x58>
   290fc:	e59f302c 	ldr	r3, [pc, #44]	; 29130 <_isatty_r+0x6c>
   29100:	e5933000 	ldr	r3, [r3]
   29104:	e3530000 	cmp	r3, #0
   29108:	0a000003 	beq	2911c <_isatty_r+0x58>
    ptr->_errno = errno;
   2910c:	e59f301c 	ldr	r3, [pc, #28]	; 29130 <_isatty_r+0x6c>
   29110:	e5932000 	ldr	r2, [r3]
   29114:	e51b3010 	ldr	r3, [fp, #-16]
   29118:	e5832000 	str	r2, [r3]
  return ret;
   2911c:	e51b3008 	ldr	r3, [fp, #-8]
}
   29120:	e1a00003 	mov	r0, r3
   29124:	e24bd004 	sub	sp, fp, #4
   29128:	e8bd4800 	pop	{fp, lr}
   2912c:	e12fff1e 	bx	lr
   29130:	0018b940 	.word	0x0018b940

00029134 <lseek>:
off_t
_DEFUN (lseek, (file, off, dir),
        int   file  _AND
        off_t   off   _AND
        int   dir)
{
   29134:	e92d4810 	push	{r4, fp, lr}
   29138:	e28db008 	add	fp, sp, #8
   2913c:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   29140:	e50b0020 	str	r0, [fp, #-32]
   29144:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   29148:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	off_t res = -1;
   2914c:	e3e03000 	mvn	r3, #0
   29150:	e3e04000 	mvn	r4, #0
   29154:	e50b301c 	str	r3, [fp, #-28]
   29158:	e50b4018 	str	r4, [fp, #-24]
	status_t status = DNA_OK;
   2915c:	e3a03000 	mov	r3, #0
   29160:	e14b30be 	strh	r3, [fp, #-14]

	status = vfs_lseek (file, off, dir, & res);
   29164:	e51b3020 	ldr	r3, [fp, #-32]
   29168:	e1a03803 	lsl	r3, r3, #16
   2916c:	e1a03823 	lsr	r3, r3, #16
   29170:	e1a03803 	lsl	r3, r3, #16
   29174:	e1a03843 	asr	r3, r3, #16
   29178:	e59b2004 	ldr	r2, [fp, #4]
   2917c:	e58d2000 	str	r2, [sp]
   29180:	e24b201c 	sub	r2, fp, #28
   29184:	e58d2004 	str	r2, [sp, #4]
   29188:	e1a00003 	mov	r0, r3
   2918c:	e24b302c 	sub	r3, fp, #44	; 0x2c
   29190:	e893000c 	ldm	r3, {r2, r3}
   29194:	ebff92bf 	bl	dc98 <vfs_lseek>
   29198:	e1a03000 	mov	r3, r0
   2919c:	e14b30be 	strh	r3, [fp, #-14]
  return res;
   291a0:	e24b401c 	sub	r4, fp, #28
   291a4:	e8940018 	ldm	r4, {r3, r4}
}
   291a8:	e1a00003 	mov	r0, r3
   291ac:	e1a01004 	mov	r1, r4
   291b0:	e24bd008 	sub	sp, fp, #8
   291b4:	e8bd4810 	pop	{r4, fp, lr}
   291b8:	e12fff1e 	bx	lr

000291bc <__swbuf_r>:
int
_DEFUN(__swbuf_r, (ptr, c, fp),
       struct _reent *ptr _AND
       register int c _AND
       register FILE *fp)
{
   291bc:	e92d4870 	push	{r4, r5, r6, fp, lr}
   291c0:	e28db010 	add	fp, sp, #16
   291c4:	e24dd014 	sub	sp, sp, #20
   291c8:	e50b0020 	str	r0, [fp, #-32]
   291cc:	e1a05001 	mov	r5, r1
   291d0:	e1a04002 	mov	r4, r2
  register int n;

  /* Ensure stdio has been initialized.  */

  CHECK_INIT (ptr, fp);
   291d4:	e51b3020 	ldr	r3, [fp, #-32]
   291d8:	e50b3018 	str	r3, [fp, #-24]
   291dc:	e51b3018 	ldr	r3, [fp, #-24]
   291e0:	e3530000 	cmp	r3, #0
   291e4:	0a000005 	beq	29200 <__swbuf_r+0x44>
   291e8:	e51b3018 	ldr	r3, [fp, #-24]
   291ec:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   291f0:	e3530000 	cmp	r3, #0
   291f4:	1a000001 	bne	29200 <__swbuf_r+0x44>
   291f8:	e51b0018 	ldr	r0, [fp, #-24]
   291fc:	ebffb4e2 	bl	1658c <__sinit>
   * (if line buffered) so that we will get called again.
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
   29200:	e5943018 	ldr	r3, [r4, #24]
   29204:	e5843008 	str	r3, [r4, #8]
  if (cantwrite (ptr, fp))
   29208:	e1d430bc 	ldrh	r3, [r4, #12]
   2920c:	e1a03803 	lsl	r3, r3, #16
   29210:	e1a03823 	lsr	r3, r3, #16
   29214:	e2033008 	and	r3, r3, #8
   29218:	e3530000 	cmp	r3, #0
   2921c:	0a000002 	beq	2922c <__swbuf_r+0x70>
   29220:	e5943010 	ldr	r3, [r4, #16]
   29224:	e3530000 	cmp	r3, #0
   29228:	1a000007 	bne	2924c <__swbuf_r+0x90>
   2922c:	e51b0020 	ldr	r0, [fp, #-32]
   29230:	e1a01004 	mov	r1, r4
   29234:	ebffd888 	bl	1f45c <__swsetup_r>
   29238:	e1a03000 	mov	r3, r0
   2923c:	e3530000 	cmp	r3, #0
   29240:	0a000001 	beq	2924c <__swbuf_r+0x90>
    return EOF;
   29244:	e3e03000 	mvn	r3, #0
   29248:	ea00003c 	b	29340 <__swbuf_r+0x184>
  c = (unsigned char) c;
   2924c:	e20530ff 	and	r3, r5, #255	; 0xff
   29250:	e1a05003 	mov	r5, r3

  ORIENT (fp, -1);
   29254:	e1d430bc 	ldrh	r3, [r4, #12]
   29258:	e1a03803 	lsl	r3, r3, #16
   2925c:	e1a03823 	lsr	r3, r3, #16
   29260:	e2033a02 	and	r3, r3, #8192	; 0x2000
   29264:	e3530000 	cmp	r3, #0
   29268:	1a000007 	bne	2928c <__swbuf_r+0xd0>
   2926c:	e1d430bc 	ldrh	r3, [r4, #12]
   29270:	e3833a02 	orr	r3, r3, #8192	; 0x2000
   29274:	e1a03803 	lsl	r3, r3, #16
   29278:	e1a03823 	lsr	r3, r3, #16
   2927c:	e1c430bc 	strh	r3, [r4, #12]
   29280:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
   29284:	e3c33a02 	bic	r3, r3, #8192	; 0x2000
   29288:	e584306c 	str	r3, [r4, #108]	; 0x6c
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   2928c:	e5943000 	ldr	r3, [r4]
   29290:	e1a02003 	mov	r2, r3
   29294:	e5943010 	ldr	r3, [r4, #16]
   29298:	e0636002 	rsb	r6, r3, r2
  if (n >= fp->_bf._size)
   2929c:	e5943014 	ldr	r3, [r4, #20]
   292a0:	e1530006 	cmp	r3, r6
   292a4:	ca000008 	bgt	292cc <__swbuf_r+0x110>
    {
      if (_fflush_r (ptr, fp))
   292a8:	e51b0020 	ldr	r0, [fp, #-32]
   292ac:	e1a01004 	mov	r1, r4
   292b0:	ebffb36a 	bl	16060 <_fflush_r>
   292b4:	e1a03000 	mov	r3, r0
   292b8:	e3530000 	cmp	r3, #0
   292bc:	0a000001 	beq	292c8 <__swbuf_r+0x10c>
	return EOF;
   292c0:	e3e03000 	mvn	r3, #0
   292c4:	ea00001d 	b	29340 <__swbuf_r+0x184>
      n = 0;
   292c8:	e3a06000 	mov	r6, #0
    }
  fp->_w--;
   292cc:	e5943008 	ldr	r3, [r4, #8]
   292d0:	e2433001 	sub	r3, r3, #1
   292d4:	e5843008 	str	r3, [r4, #8]
  *fp->_p++ = c;
   292d8:	e5943000 	ldr	r3, [r4]
   292dc:	e2832001 	add	r2, r3, #1
   292e0:	e5842000 	str	r2, [r4]
   292e4:	e20520ff 	and	r2, r5, #255	; 0xff
   292e8:	e5c32000 	strb	r2, [r3]
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
   292ec:	e2866001 	add	r6, r6, #1
   292f0:	e5943014 	ldr	r3, [r4, #20]
   292f4:	e1560003 	cmp	r6, r3
   292f8:	0a000007 	beq	2931c <__swbuf_r+0x160>
   292fc:	e1d430bc 	ldrh	r3, [r4, #12]
   29300:	e1a03803 	lsl	r3, r3, #16
   29304:	e1a03823 	lsr	r3, r3, #16
   29308:	e2033001 	and	r3, r3, #1
   2930c:	e3530000 	cmp	r3, #0
   29310:	0a000009 	beq	2933c <__swbuf_r+0x180>
   29314:	e355000a 	cmp	r5, #10
   29318:	1a000007 	bne	2933c <__swbuf_r+0x180>
    if (_fflush_r (ptr, fp))
   2931c:	e51b0020 	ldr	r0, [fp, #-32]
   29320:	e1a01004 	mov	r1, r4
   29324:	ebffb34d 	bl	16060 <_fflush_r>
   29328:	e1a03000 	mov	r3, r0
   2932c:	e3530000 	cmp	r3, #0
   29330:	0a000001 	beq	2933c <__swbuf_r+0x180>
      return EOF;
   29334:	e3e03000 	mvn	r3, #0
   29338:	ea000000 	b	29340 <__swbuf_r+0x184>
  return c;
   2933c:	e1a03005 	mov	r3, r5
}
   29340:	e1a00003 	mov	r0, r3
   29344:	e24bd010 	sub	sp, fp, #16
   29348:	e8bd4870 	pop	{r4, r5, r6, fp, lr}
   2934c:	e12fff1e 	bx	lr

00029350 <__swbuf>:
   earlier dynamically built newlib libraries. */
int
_DEFUN(__swbuf, (c, fp),
       register int c _AND
       register FILE *fp)
{
   29350:	e92d4800 	push	{fp, lr}
   29354:	e28db004 	add	fp, sp, #4
   29358:	e1a02000 	mov	r2, r0
   2935c:	e1a03001 	mov	r3, r1
  return __swbuf_r (_REENT, c, fp);
   29360:	e59f1024 	ldr	r1, [pc, #36]	; 2938c <__swbuf+0x3c>
   29364:	e5911000 	ldr	r1, [r1]
   29368:	e1a00001 	mov	r0, r1
   2936c:	e1a01002 	mov	r1, r2
   29370:	e1a02003 	mov	r2, r3
   29374:	ebffff90 	bl	291bc <__swbuf_r>
   29378:	e1a03000 	mov	r3, r0
}
   2937c:	e1a00003 	mov	r0, r3
   29380:	e24bd004 	sub	sp, fp, #4
   29384:	e8bd4800 	pop	{fp, lr}
   29388:	e12fff1e 	bx	lr
   2938c:	0003e460 	.word	0x0003e460

00029390 <_wcrtomb_r>:
_DEFUN (_wcrtomb_r, (ptr, s, wc, ps),
	struct _reent *ptr _AND
	char *s _AND
	wchar_t wc _AND
	mbstate_t *ps)
{
   29390:	e92d4810 	push	{r4, fp, lr}
   29394:	e28db008 	add	fp, sp, #8
   29398:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   2939c:	e50b0020 	str	r0, [fp, #-32]
   293a0:	e50b1024 	str	r1, [fp, #-36]	; 0x24
   293a4:	e50b2028 	str	r2, [fp, #-40]	; 0x28
   293a8:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
  int retval = 0;
   293ac:	e3a03000 	mov	r3, #0
   293b0:	e50b3010 	str	r3, [fp, #-16]
      _REENT_CHECK_MISC(ptr);
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
   293b4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   293b8:	e3530000 	cmp	r3, #0
   293bc:	1a00000d 	bne	293f8 <_wcrtomb_r+0x68>
    retval = __wctomb (ptr, buf, L'\0', __locale_charset (), ps);
   293c0:	e59f30a0 	ldr	r3, [pc, #160]	; 29468 <_wcrtomb_r+0xd8>
   293c4:	e5934000 	ldr	r4, [r3]
   293c8:	ebffe394 	bl	22220 <__locale_charset>
   293cc:	e1a03000 	mov	r3, r0
   293d0:	e24b201c 	sub	r2, fp, #28
   293d4:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
   293d8:	e58d1000 	str	r1, [sp]
   293dc:	e51b0020 	ldr	r0, [fp, #-32]
   293e0:	e1a01002 	mov	r1, r2
   293e4:	e3a02000 	mov	r2, #0
   293e8:	e1a0e00f 	mov	lr, pc
   293ec:	e12fff14 	bx	r4
   293f0:	e50b0010 	str	r0, [fp, #-16]
   293f4:	ea00000b 	b	29428 <_wcrtomb_r+0x98>
  else
    retval = __wctomb (ptr, s, wc, __locale_charset (), ps);
   293f8:	e59f3068 	ldr	r3, [pc, #104]	; 29468 <_wcrtomb_r+0xd8>
   293fc:	e5934000 	ldr	r4, [r3]
   29400:	ebffe386 	bl	22220 <__locale_charset>
   29404:	e1a03000 	mov	r3, r0
   29408:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
   2940c:	e58d2000 	str	r2, [sp]
   29410:	e51b0020 	ldr	r0, [fp, #-32]
   29414:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
   29418:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   2941c:	e1a0e00f 	mov	lr, pc
   29420:	e12fff14 	bx	r4
   29424:	e50b0010 	str	r0, [fp, #-16]

  if (retval == -1)
   29428:	e51b3010 	ldr	r3, [fp, #-16]
   2942c:	e3730001 	cmn	r3, #1
   29430:	1a000007 	bne	29454 <_wcrtomb_r+0xc4>
    {
      ps->__count = 0;
   29434:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   29438:	e3a02000 	mov	r2, #0
   2943c:	e5832000 	str	r2, [r3]
      ptr->_errno = EILSEQ;
   29440:	e51b3020 	ldr	r3, [fp, #-32]
   29444:	e3a0208a 	mov	r2, #138	; 0x8a
   29448:	e5832000 	str	r2, [r3]
      return (size_t)(-1);
   2944c:	e3e03000 	mvn	r3, #0
   29450:	ea000000 	b	29458 <_wcrtomb_r+0xc8>
    }
  else
    return (size_t)retval;
   29454:	e51b3010 	ldr	r3, [fp, #-16]
}
   29458:	e1a00003 	mov	r0, r3
   2945c:	e24bd008 	sub	sp, fp, #8
   29460:	e8bd4810 	pop	{r4, fp, lr}
   29464:	e12fff1e 	bx	lr
   29468:	0003e904 	.word	0x0003e904

0002946c <wcrtomb>:
size_t
_DEFUN (wcrtomb, (s, wc, ps),
	char *s _AND
	wchar_t wc _AND
	mbstate_t *ps)
{
   2946c:	e92d4810 	push	{r4, fp, lr}
   29470:	e28db008 	add	fp, sp, #8
   29474:	e24dd034 	sub	sp, sp, #52	; 0x34
   29478:	e50b0028 	str	r0, [fp, #-40]	; 0x28
   2947c:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
   29480:	e50b2030 	str	r2, [fp, #-48]	; 0x30
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  return _wcrtomb_r (_REENT, s, wc, ps);
#else
  int retval = 0;
   29484:	e3a03000 	mov	r3, #0
   29488:	e50b3010 	str	r3, [fp, #-16]
  struct _reent *reent = _REENT;
   2948c:	e59f30b8 	ldr	r3, [pc, #184]	; 2954c <wcrtomb+0xe0>
   29490:	e5933000 	ldr	r3, [r3]
   29494:	e50b3014 	str	r3, [fp, #-20]
      _REENT_CHECK_MISC(reent);
      ps = &(_REENT_WCRTOMB_STATE(reent));
    }
#endif

  if (s == NULL)
   29498:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2949c:	e3530000 	cmp	r3, #0
   294a0:	1a00000d 	bne	294dc <wcrtomb+0x70>
    retval = __wctomb (reent, buf, L'\0', __locale_charset (), ps);
   294a4:	e59f30a4 	ldr	r3, [pc, #164]	; 29550 <wcrtomb+0xe4>
   294a8:	e5934000 	ldr	r4, [r3]
   294ac:	ebffe35b 	bl	22220 <__locale_charset>
   294b0:	e1a03000 	mov	r3, r0
   294b4:	e24b2020 	sub	r2, fp, #32
   294b8:	e51b1030 	ldr	r1, [fp, #-48]	; 0x30
   294bc:	e58d1000 	str	r1, [sp]
   294c0:	e51b0014 	ldr	r0, [fp, #-20]
   294c4:	e1a01002 	mov	r1, r2
   294c8:	e3a02000 	mov	r2, #0
   294cc:	e1a0e00f 	mov	lr, pc
   294d0:	e12fff14 	bx	r4
   294d4:	e50b0010 	str	r0, [fp, #-16]
   294d8:	ea00000b 	b	2950c <wcrtomb+0xa0>
  else
    retval = __wctomb (reent, s, wc, __locale_charset (), ps);
   294dc:	e59f306c 	ldr	r3, [pc, #108]	; 29550 <wcrtomb+0xe4>
   294e0:	e5934000 	ldr	r4, [r3]
   294e4:	ebffe34d 	bl	22220 <__locale_charset>
   294e8:	e1a03000 	mov	r3, r0
   294ec:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   294f0:	e58d2000 	str	r2, [sp]
   294f4:	e51b0014 	ldr	r0, [fp, #-20]
   294f8:	e51b1028 	ldr	r1, [fp, #-40]	; 0x28
   294fc:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
   29500:	e1a0e00f 	mov	lr, pc
   29504:	e12fff14 	bx	r4
   29508:	e50b0010 	str	r0, [fp, #-16]

  if (retval == -1)
   2950c:	e51b3010 	ldr	r3, [fp, #-16]
   29510:	e3730001 	cmn	r3, #1
   29514:	1a000007 	bne	29538 <wcrtomb+0xcc>
    {
      ps->__count = 0;
   29518:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2951c:	e3a02000 	mov	r2, #0
   29520:	e5832000 	str	r2, [r3]
      reent->_errno = EILSEQ;
   29524:	e51b3014 	ldr	r3, [fp, #-20]
   29528:	e3a0208a 	mov	r2, #138	; 0x8a
   2952c:	e5832000 	str	r2, [r3]
      return (size_t)(-1);
   29530:	e3e03000 	mvn	r3, #0
   29534:	ea000000 	b	2953c <wcrtomb+0xd0>
    }
  else
    return (size_t)retval;
   29538:	e51b3010 	ldr	r3, [fp, #-16]
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   2953c:	e1a00003 	mov	r0, r3
   29540:	e24bd008 	sub	sp, fp, #8
   29544:	e8bd4810 	pop	{r4, fp, lr}
   29548:	e12fff1e 	bx	lr
   2954c:	0003e460 	.word	0x0003e460
   29550:	0003e904 	.word	0x0003e904

00029554 <_wctomb_r>:
_DEFUN (_wctomb_r, (r, s, wchar, state),
        struct _reent *r     _AND 
        char          *s     _AND
        wchar_t        _wchar _AND
        mbstate_t     *state)
{
   29554:	e92d4810 	push	{r4, fp, lr}
   29558:	e28db008 	add	fp, sp, #8
   2955c:	e24dd01c 	sub	sp, sp, #28
   29560:	e50b0010 	str	r0, [fp, #-16]
   29564:	e50b1014 	str	r1, [fp, #-20]
   29568:	e50b2018 	str	r2, [fp, #-24]
   2956c:	e50b301c 	str	r3, [fp, #-28]
  return __wctomb (r, s, _wchar, __locale_charset (), state);
   29570:	e59f3038 	ldr	r3, [pc, #56]	; 295b0 <_wctomb_r+0x5c>
   29574:	e5934000 	ldr	r4, [r3]
   29578:	ebffe328 	bl	22220 <__locale_charset>
   2957c:	e1a03000 	mov	r3, r0
   29580:	e51b201c 	ldr	r2, [fp, #-28]
   29584:	e58d2000 	str	r2, [sp]
   29588:	e51b0010 	ldr	r0, [fp, #-16]
   2958c:	e51b1014 	ldr	r1, [fp, #-20]
   29590:	e51b2018 	ldr	r2, [fp, #-24]
   29594:	e1a0e00f 	mov	lr, pc
   29598:	e12fff14 	bx	r4
   2959c:	e1a03000 	mov	r3, r0
}
   295a0:	e1a00003 	mov	r0, r3
   295a4:	e24bd008 	sub	sp, fp, #8
   295a8:	e8bd4810 	pop	{r4, fp, lr}
   295ac:	e12fff1e 	bx	lr
   295b0:	0003e904 	.word	0x0003e904

000295b4 <__ascii_wctomb>:
        struct _reent *r       _AND 
        char          *s       _AND
        wchar_t        _wchar  _AND
	const char    *charset _AND
        mbstate_t     *state)
{
   295b4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   295b8:	e28db000 	add	fp, sp, #0
   295bc:	e24dd01c 	sub	sp, sp, #28
   295c0:	e50b0010 	str	r0, [fp, #-16]
   295c4:	e50b1014 	str	r1, [fp, #-20]
   295c8:	e50b2018 	str	r2, [fp, #-24]
   295cc:	e50b301c 	str	r3, [fp, #-28]
  /* Avoids compiler warnings about comparisons that are always false
     due to limited range when sizeof(wchar_t) is 2 but sizeof(wint_t)
     is 4, as is the case on cygwin.  */
  wint_t wchar = _wchar;
   295d0:	e51b3018 	ldr	r3, [fp, #-24]
   295d4:	e50b3008 	str	r3, [fp, #-8]

  if (s == NULL)
   295d8:	e51b3014 	ldr	r3, [fp, #-20]
   295dc:	e3530000 	cmp	r3, #0
   295e0:	1a000001 	bne	295ec <__ascii_wctomb+0x38>
    return 0;
   295e4:	e3a03000 	mov	r3, #0
   295e8:	ea00000c 	b	29620 <__ascii_wctomb+0x6c>
 
#ifdef __CYGWIN__
  if ((size_t)wchar >= 0x80)
#else
  if ((size_t)wchar >= 0x100)
   295ec:	e51b3008 	ldr	r3, [fp, #-8]
   295f0:	e35300ff 	cmp	r3, #255	; 0xff
   295f4:	9a000004 	bls	2960c <__ascii_wctomb+0x58>
#endif
    {
      r->_errno = EILSEQ;
   295f8:	e51b3010 	ldr	r3, [fp, #-16]
   295fc:	e3a0208a 	mov	r2, #138	; 0x8a
   29600:	e5832000 	str	r2, [r3]
      return -1;
   29604:	e3e03000 	mvn	r3, #0
   29608:	ea000004 	b	29620 <__ascii_wctomb+0x6c>
    }

  *s = (char) wchar;
   2960c:	e51b3008 	ldr	r3, [fp, #-8]
   29610:	e20320ff 	and	r2, r3, #255	; 0xff
   29614:	e51b3014 	ldr	r3, [fp, #-20]
   29618:	e5c32000 	strb	r2, [r3]
  return 1;
   2961c:	e3a03001 	mov	r3, #1
}
   29620:	e1a00003 	mov	r0, r3
   29624:	e24bd000 	sub	sp, fp, #0
   29628:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   2962c:	e12fff1e 	bx	lr

00029630 <fstat>:

int
_DEFUN (_fstat, (fildes, st),
        int          fildes _AND
        struct stat *st)
{
   29630:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   29634:	e28db000 	add	fp, sp, #0
   29638:	e24dd00c 	sub	sp, sp, #12
   2963c:	e50b0008 	str	r0, [fp, #-8]
   29640:	e50b100c 	str	r1, [fp, #-12]



	return 0;
   29644:	e3a03000 	mov	r3, #0
}
   29648:	e1a00003 	mov	r0, r3
   2964c:	e24bd000 	sub	sp, fp, #0
   29650:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   29654:	e12fff1e 	bx	lr

00029658 <isatty>:
#include <_syslist.h>

int
_DEFUN (_isatty, (file),
        int file)
{
   29658:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   2965c:	e28db000 	add	fp, sp, #0
   29660:	e24dd00c 	sub	sp, sp, #12
   29664:	e50b0008 	str	r0, [fp, #-8]
  return 1;
   29668:	e3a03001 	mov	r3, #1
}
   2966c:	e1a00003 	mov	r0, r3
   29670:	e24bd000 	sub	sp, fp, #0
   29674:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   29678:	e12fff1e 	bx	lr

0002967c <cos>:
	double cos(double x)
#else
	double cos(x)
	double x;
#endif
{
   2967c:	e92d4830 	push	{r4, r5, fp, lr}
   29680:	e28db00c 	add	fp, sp, #12
   29684:	e24dd038 	sub	sp, sp, #56	; 0x38
   29688:	e50b003c 	str	r0, [fp, #-60]	; 0x3c
   2968c:	e50b1038 	str	r1, [fp, #-56]	; 0x38
	double y[2],z=0.0;
   29690:	e3a02000 	mov	r2, #0
   29694:	e3a03000 	mov	r3, #0
   29698:	e50b2014 	str	r2, [fp, #-20]
   2969c:	e50b3010 	str	r3, [fp, #-16]
	__int32_t n,ix;

    /* High word of x. */
	GET_HIGH_WORD(ix,x);
   296a0:	e24b303c 	sub	r3, fp, #60	; 0x3c
   296a4:	e893000c 	ldm	r3, {r2, r3}
   296a8:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   296ac:	e50b3030 	str	r3, [fp, #-48]	; 0x30
   296b0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   296b4:	e50b3018 	str	r3, [fp, #-24]

    /* |x| ~< pi/4 */
	ix &= 0x7fffffff;
   296b8:	e51b3018 	ldr	r3, [fp, #-24]
   296bc:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   296c0:	e50b3018 	str	r3, [fp, #-24]
	if(ix <= 0x3fe921fb) return __kernel_cos(x,z);
   296c4:	e51b2018 	ldr	r2, [fp, #-24]
   296c8:	e59f316c 	ldr	r3, [pc, #364]	; 2983c <cos+0x1c0>
   296cc:	e1520003 	cmp	r2, r3
   296d0:	ca000007 	bgt	296f4 <cos+0x78>
   296d4:	e24b103c 	sub	r1, fp, #60	; 0x3c
   296d8:	e8910003 	ldm	r1, {r0, r1}
   296dc:	e24b3014 	sub	r3, fp, #20
   296e0:	e893000c 	ldm	r3, {r2, r3}
   296e4:	eb00164f 	bl	2f028 <__kernel_cos>
   296e8:	e1a04000 	mov	r4, r0
   296ec:	e1a05001 	mov	r5, r1
   296f0:	ea00004a 	b	29820 <cos+0x1a4>

    /* cos(Inf or NaN) is NaN */
	else if (ix>=0x7ff00000) return x-x;
   296f4:	e51b2018 	ldr	r2, [fp, #-24]
   296f8:	e59f3140 	ldr	r3, [pc, #320]	; 29840 <cos+0x1c4>
   296fc:	e1520003 	cmp	r2, r3
   29700:	da000009 	ble	2972c <cos+0xb0>
   29704:	e24b103c 	sub	r1, fp, #60	; 0x3c
   29708:	e8910003 	ldm	r1, {r0, r1}
   2970c:	e24b303c 	sub	r3, fp, #60	; 0x3c
   29710:	e893000c 	ldm	r3, {r2, r3}
   29714:	ebffabf4 	bl	146ec <__aeabi_dsub>
   29718:	e1a03000 	mov	r3, r0
   2971c:	e1a04001 	mov	r4, r1
   29720:	e1a05004 	mov	r5, r4
   29724:	e1a04003 	mov	r4, r3
   29728:	ea00003c 	b	29820 <cos+0x1a4>

    /* argument reduction needed */
	else {
	    n = __ieee754_rem_pio2(x,y);
   2972c:	e24b302c 	sub	r3, fp, #44	; 0x2c
   29730:	e24b103c 	sub	r1, fp, #60	; 0x3c
   29734:	e8910003 	ldm	r1, {r0, r1}
   29738:	e1a02003 	mov	r2, r3
   2973c:	eb0011bb 	bl	2de30 <__ieee754_rem_pio2>
   29740:	e50b001c 	str	r0, [fp, #-28]
	    switch(n&3) {
   29744:	e51b301c 	ldr	r3, [fp, #-28]
   29748:	e2033003 	and	r3, r3, #3
   2974c:	e3530001 	cmp	r3, #1
   29750:	0a00000f 	beq	29794 <cos+0x118>
   29754:	e3530002 	cmp	r3, #2
   29758:	0a000019 	beq	297c4 <cos+0x148>
   2975c:	e3530000 	cmp	r3, #0
   29760:	1a000021 	bne	297ec <cos+0x170>
		case 0: return  __kernel_cos(y[0],y[1]);
   29764:	e24b202c 	sub	r2, fp, #44	; 0x2c
   29768:	e8920006 	ldm	r2, {r1, r2}
   2976c:	e24b4024 	sub	r4, fp, #36	; 0x24
   29770:	e8940018 	ldm	r4, {r3, r4}
   29774:	e1a00001 	mov	r0, r1
   29778:	e1a01002 	mov	r1, r2
   2977c:	e1a02003 	mov	r2, r3
   29780:	e1a03004 	mov	r3, r4
   29784:	eb001627 	bl	2f028 <__kernel_cos>
   29788:	e1a04000 	mov	r4, r0
   2978c:	e1a05001 	mov	r5, r1
   29790:	ea000022 	b	29820 <cos+0x1a4>
		case 1: return -__kernel_sin(y[0],y[1],1);
   29794:	e24b102c 	sub	r1, fp, #44	; 0x2c
   29798:	e8910003 	ldm	r1, {r0, r1}
   2979c:	e24b3024 	sub	r3, fp, #36	; 0x24
   297a0:	e893000c 	ldm	r3, {r2, r3}
   297a4:	e3a0c001 	mov	ip, #1
   297a8:	e58dc000 	str	ip, [sp]
   297ac:	eb001c45 	bl	308c8 <__kernel_sin>
   297b0:	e1a02000 	mov	r2, r0
   297b4:	e1a03001 	mov	r3, r1
   297b8:	e1a04002 	mov	r4, r2
   297bc:	e2235102 	eor	r5, r3, #-2147483648	; 0x80000000
   297c0:	ea000016 	b	29820 <cos+0x1a4>
		case 2: return -__kernel_cos(y[0],y[1]);
   297c4:	e24b102c 	sub	r1, fp, #44	; 0x2c
   297c8:	e8910003 	ldm	r1, {r0, r1}
   297cc:	e24b3024 	sub	r3, fp, #36	; 0x24
   297d0:	e893000c 	ldm	r3, {r2, r3}
   297d4:	eb001613 	bl	2f028 <__kernel_cos>
   297d8:	e1a02000 	mov	r2, r0
   297dc:	e1a03001 	mov	r3, r1
   297e0:	e1a04002 	mov	r4, r2
   297e4:	e2235102 	eor	r5, r3, #-2147483648	; 0x80000000
   297e8:	ea00000c 	b	29820 <cos+0x1a4>
		default:
		        return  __kernel_sin(y[0],y[1],1);
   297ec:	e24b202c 	sub	r2, fp, #44	; 0x2c
   297f0:	e8920006 	ldm	r2, {r1, r2}
   297f4:	e24b4024 	sub	r4, fp, #36	; 0x24
   297f8:	e8940018 	ldm	r4, {r3, r4}
   297fc:	e3a00001 	mov	r0, #1
   29800:	e58d0000 	str	r0, [sp]
   29804:	e1a00001 	mov	r0, r1
   29808:	e1a01002 	mov	r1, r2
   2980c:	e1a02003 	mov	r2, r3
   29810:	e1a03004 	mov	r3, r4
   29814:	eb001c2b 	bl	308c8 <__kernel_sin>
   29818:	e1a04000 	mov	r4, r0
   2981c:	e1a05001 	mov	r5, r1
   29820:	e1a03004 	mov	r3, r4
   29824:	e1a04005 	mov	r4, r5
	    }
	}
}
   29828:	e1a00003 	mov	r0, r3
   2982c:	e1a01004 	mov	r1, r4
   29830:	e24bd00c 	sub	sp, fp, #12
   29834:	e8bd4830 	pop	{r4, r5, fp, lr}
   29838:	e12fff1e 	bx	lr
   2983c:	3fe921fb 	.word	0x3fe921fb
   29840:	7fefffff 	.word	0x7fefffff

00029844 <sin>:
	double sin(double x)
#else
	double sin(x)
	double x;
#endif
{
   29844:	e92d4830 	push	{r4, r5, fp, lr}
   29848:	e28db00c 	add	fp, sp, #12
   2984c:	e24dd038 	sub	sp, sp, #56	; 0x38
   29850:	e50b003c 	str	r0, [fp, #-60]	; 0x3c
   29854:	e50b1038 	str	r1, [fp, #-56]	; 0x38
	double y[2],z=0.0;
   29858:	e3a02000 	mov	r2, #0
   2985c:	e3a03000 	mov	r3, #0
   29860:	e50b2014 	str	r2, [fp, #-20]
   29864:	e50b3010 	str	r3, [fp, #-16]
	__int32_t n,ix;

    /* High word of x. */
	GET_HIGH_WORD(ix,x);
   29868:	e24b303c 	sub	r3, fp, #60	; 0x3c
   2986c:	e893000c 	ldm	r3, {r2, r3}
   29870:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   29874:	e50b3030 	str	r3, [fp, #-48]	; 0x30
   29878:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2987c:	e50b3018 	str	r3, [fp, #-24]

    /* |x| ~< pi/4 */
	ix &= 0x7fffffff;
   29880:	e51b3018 	ldr	r3, [fp, #-24]
   29884:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   29888:	e50b3018 	str	r3, [fp, #-24]
	if(ix <= 0x3fe921fb) return __kernel_sin(x,z,0);
   2988c:	e51b2018 	ldr	r2, [fp, #-24]
   29890:	e59f3174 	ldr	r3, [pc, #372]	; 29a0c <sin+0x1c8>
   29894:	e1520003 	cmp	r2, r3
   29898:	ca000009 	bgt	298c4 <sin+0x80>
   2989c:	e3a03000 	mov	r3, #0
   298a0:	e58d3000 	str	r3, [sp]
   298a4:	e24b103c 	sub	r1, fp, #60	; 0x3c
   298a8:	e8910003 	ldm	r1, {r0, r1}
   298ac:	e24b3014 	sub	r3, fp, #20
   298b0:	e893000c 	ldm	r3, {r2, r3}
   298b4:	eb001c03 	bl	308c8 <__kernel_sin>
   298b8:	e1a04000 	mov	r4, r0
   298bc:	e1a05001 	mov	r5, r1
   298c0:	ea00004a 	b	299f0 <sin+0x1ac>

    /* sin(Inf or NaN) is NaN */
	else if (ix>=0x7ff00000) return x-x;
   298c4:	e51b2018 	ldr	r2, [fp, #-24]
   298c8:	e59f3140 	ldr	r3, [pc, #320]	; 29a10 <sin+0x1cc>
   298cc:	e1520003 	cmp	r2, r3
   298d0:	da000009 	ble	298fc <sin+0xb8>
   298d4:	e24b103c 	sub	r1, fp, #60	; 0x3c
   298d8:	e8910003 	ldm	r1, {r0, r1}
   298dc:	e24b303c 	sub	r3, fp, #60	; 0x3c
   298e0:	e893000c 	ldm	r3, {r2, r3}
   298e4:	ebffab80 	bl	146ec <__aeabi_dsub>
   298e8:	e1a03000 	mov	r3, r0
   298ec:	e1a04001 	mov	r4, r1
   298f0:	e1a05004 	mov	r5, r4
   298f4:	e1a04003 	mov	r4, r3
   298f8:	ea00003c 	b	299f0 <sin+0x1ac>

    /* argument reduction needed */
	else {
	    n = __ieee754_rem_pio2(x,y);
   298fc:	e24b302c 	sub	r3, fp, #44	; 0x2c
   29900:	e24b103c 	sub	r1, fp, #60	; 0x3c
   29904:	e8910003 	ldm	r1, {r0, r1}
   29908:	e1a02003 	mov	r2, r3
   2990c:	eb001147 	bl	2de30 <__ieee754_rem_pio2>
   29910:	e50b001c 	str	r0, [fp, #-28]
	    switch(n&3) {
   29914:	e51b301c 	ldr	r3, [fp, #-28]
   29918:	e2033003 	and	r3, r3, #3
   2991c:	e3530001 	cmp	r3, #1
   29920:	0a000011 	beq	2996c <sin+0x128>
   29924:	e3530002 	cmp	r3, #2
   29928:	0a00001b 	beq	2999c <sin+0x158>
   2992c:	e3530000 	cmp	r3, #0
   29930:	1a000025 	bne	299cc <sin+0x188>
		case 0: return  __kernel_sin(y[0],y[1],1);
   29934:	e24b202c 	sub	r2, fp, #44	; 0x2c
   29938:	e8920006 	ldm	r2, {r1, r2}
   2993c:	e24b4024 	sub	r4, fp, #36	; 0x24
   29940:	e8940018 	ldm	r4, {r3, r4}
   29944:	e3a00001 	mov	r0, #1
   29948:	e58d0000 	str	r0, [sp]
   2994c:	e1a00001 	mov	r0, r1
   29950:	e1a01002 	mov	r1, r2
   29954:	e1a02003 	mov	r2, r3
   29958:	e1a03004 	mov	r3, r4
   2995c:	eb001bd9 	bl	308c8 <__kernel_sin>
   29960:	e1a04000 	mov	r4, r0
   29964:	e1a05001 	mov	r5, r1
   29968:	ea000020 	b	299f0 <sin+0x1ac>
		case 1: return  __kernel_cos(y[0],y[1]);
   2996c:	e24b202c 	sub	r2, fp, #44	; 0x2c
   29970:	e8920006 	ldm	r2, {r1, r2}
   29974:	e24b4024 	sub	r4, fp, #36	; 0x24
   29978:	e8940018 	ldm	r4, {r3, r4}
   2997c:	e1a00001 	mov	r0, r1
   29980:	e1a01002 	mov	r1, r2
   29984:	e1a02003 	mov	r2, r3
   29988:	e1a03004 	mov	r3, r4
   2998c:	eb0015a5 	bl	2f028 <__kernel_cos>
   29990:	e1a04000 	mov	r4, r0
   29994:	e1a05001 	mov	r5, r1
   29998:	ea000014 	b	299f0 <sin+0x1ac>
		case 2: return -__kernel_sin(y[0],y[1],1);
   2999c:	e24b102c 	sub	r1, fp, #44	; 0x2c
   299a0:	e8910003 	ldm	r1, {r0, r1}
   299a4:	e24b3024 	sub	r3, fp, #36	; 0x24
   299a8:	e893000c 	ldm	r3, {r2, r3}
   299ac:	e3a0c001 	mov	ip, #1
   299b0:	e58dc000 	str	ip, [sp]
   299b4:	eb001bc3 	bl	308c8 <__kernel_sin>
   299b8:	e1a02000 	mov	r2, r0
   299bc:	e1a03001 	mov	r3, r1
   299c0:	e1a04002 	mov	r4, r2
   299c4:	e2235102 	eor	r5, r3, #-2147483648	; 0x80000000
   299c8:	ea000008 	b	299f0 <sin+0x1ac>
		default:
			return -__kernel_cos(y[0],y[1]);
   299cc:	e24b102c 	sub	r1, fp, #44	; 0x2c
   299d0:	e8910003 	ldm	r1, {r0, r1}
   299d4:	e24b3024 	sub	r3, fp, #36	; 0x24
   299d8:	e893000c 	ldm	r3, {r2, r3}
   299dc:	eb001591 	bl	2f028 <__kernel_cos>
   299e0:	e1a02000 	mov	r2, r0
   299e4:	e1a03001 	mov	r3, r1
   299e8:	e1a04002 	mov	r4, r2
   299ec:	e2235102 	eor	r5, r3, #-2147483648	; 0x80000000
   299f0:	e1a03004 	mov	r3, r4
   299f4:	e1a04005 	mov	r4, r5
	    }
	}
}
   299f8:	e1a00003 	mov	r0, r3
   299fc:	e1a01004 	mov	r1, r4
   29a00:	e24bd00c 	sub	sp, fp, #12
   29a04:	e8bd4830 	pop	{r4, r5, fp, lr}
   29a08:	e12fff1e 	bx	lr
   29a0c:	3fe921fb 	.word	0x3fe921fb
   29a10:	7fefffff 	.word	0x7fefffff

00029a14 <acos>:
	double acos(double x)		/* wrapper acos */
#else
	double acos(x)			/* wrapper acos */
	double x;
#endif
{
   29a14:	e92d4810 	push	{r4, fp, lr}
   29a18:	e28db008 	add	fp, sp, #8
   29a1c:	e24dd03c 	sub	sp, sp, #60	; 0x3c
   29a20:	e50b0044 	str	r0, [fp, #-68]	; 0x44
   29a24:	e50b1040 	str	r1, [fp, #-64]	; 0x40
#ifdef _IEEE_LIBM
	return __ieee754_acos(x);
#else
	double z;
       	struct exception exc;
       	z = __ieee754_acos(x);
   29a28:	e24b1044 	sub	r1, fp, #68	; 0x44
   29a2c:	e8910003 	ldm	r1, {r0, r1}
   29a30:	eb000388 	bl	2a858 <__ieee754_acos>
   29a34:	e50b0014 	str	r0, [fp, #-20]
   29a38:	e50b1010 	str	r1, [fp, #-16]
	if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
   29a3c:	e59f3150 	ldr	r3, [pc, #336]	; 29b94 <acos+0x180>
   29a40:	e5d33000 	ldrb	r3, [r3]
   29a44:	e1a03c03 	lsl	r3, r3, #24
   29a48:	e1a03c43 	asr	r3, r3, #24
   29a4c:	e3730001 	cmn	r3, #1
   29a50:	0a000005 	beq	29a6c <acos+0x58>
   29a54:	e24b1044 	sub	r1, fp, #68	; 0x44
   29a58:	e8910003 	ldm	r1, {r0, r1}
   29a5c:	ebffee4d 	bl	25398 <__fpclassifyd>
   29a60:	e1a03000 	mov	r3, r0
   29a64:	e3530000 	cmp	r3, #0
   29a68:	1a000002 	bne	29a78 <acos+0x64>
   29a6c:	e24b4014 	sub	r4, fp, #20
   29a70:	e8940018 	ldm	r4, {r3, r4}
   29a74:	ea000041 	b	29b80 <acos+0x16c>
	if(fabs(x)>1.0) { 
   29a78:	e24b1044 	sub	r1, fp, #68	; 0x44
   29a7c:	e8910003 	ldm	r1, {r0, r1}
   29a80:	eb001c82 	bl	30c90 <fabs>
   29a84:	e1a03000 	mov	r3, r0
   29a88:	e1a04001 	mov	r4, r1
   29a8c:	e1a00003 	mov	r0, r3
   29a90:	e1a01004 	mov	r1, r4
   29a94:	e3a02000 	mov	r2, #0
   29a98:	e59f30f8 	ldr	r3, [pc, #248]	; 29b98 <acos+0x184>
   29a9c:	ebffad89 	bl	150c8 <__aeabi_dcmpgt>
   29aa0:	e1a03000 	mov	r3, r0
   29aa4:	e3530000 	cmp	r3, #0
   29aa8:	0a000032 	beq	29b78 <acos+0x164>
	    /* acos(|x|>1) */
	    exc.type = DOMAIN;
   29aac:	e3a03001 	mov	r3, #1
   29ab0:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
	    exc.name = "acos";
   29ab4:	e59f30e0 	ldr	r3, [pc, #224]	; 29b9c <acos+0x188>
   29ab8:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	    exc.err = 0;
   29abc:	e3a03000 	mov	r3, #0
   29ac0:	e50b301c 	str	r3, [fp, #-28]
	    exc.arg1 = exc.arg2 = x;
   29ac4:	e24b4044 	sub	r4, fp, #68	; 0x44
   29ac8:	e8940018 	ldm	r4, {r3, r4}
   29acc:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   29ad0:	e50b4028 	str	r4, [fp, #-40]	; 0x28
   29ad4:	e24b402c 	sub	r4, fp, #44	; 0x2c
   29ad8:	e8940018 	ldm	r4, {r3, r4}
   29adc:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   29ae0:	e50b4030 	str	r4, [fp, #-48]	; 0x30
	    exc.retval = nan("");
   29ae4:	e59f00b4 	ldr	r0, [pc, #180]	; 29ba0 <acos+0x18c>
   29ae8:	eb001d89 	bl	31114 <nan>
   29aec:	e1a03000 	mov	r3, r0
   29af0:	e1a04001 	mov	r4, r1
   29af4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   29af8:	e50b4020 	str	r4, [fp, #-32]
	    if (_LIB_VERSION == _POSIX_)
   29afc:	e59f3090 	ldr	r3, [pc, #144]	; 29b94 <acos+0x180>
   29b00:	e5d33000 	ldrb	r3, [r3]
   29b04:	e1a03c03 	lsl	r3, r3, #24
   29b08:	e1a03c43 	asr	r3, r3, #24
   29b0c:	e3530002 	cmp	r3, #2
   29b10:	1a000004 	bne	29b28 <acos+0x114>
	       errno = EDOM;
   29b14:	ebffdf6d 	bl	218d0 <__errno>
   29b18:	e1a03000 	mov	r3, r0
   29b1c:	e3a02021 	mov	r2, #33	; 0x21
   29b20:	e5832000 	str	r2, [r3]
   29b24:	ea000009 	b	29b50 <acos+0x13c>
	    else if (!matherr(&exc)) {
   29b28:	e24b303c 	sub	r3, fp, #60	; 0x3c
   29b2c:	e1a00003 	mov	r0, r3
   29b30:	eb001d5c 	bl	310a8 <matherr>
   29b34:	e1a03000 	mov	r3, r0
   29b38:	e3530000 	cmp	r3, #0
   29b3c:	1a000003 	bne	29b50 <acos+0x13c>
	       errno = EDOM;
   29b40:	ebffdf62 	bl	218d0 <__errno>
   29b44:	e1a03000 	mov	r3, r0
   29b48:	e3a02021 	mov	r2, #33	; 0x21
   29b4c:	e5832000 	str	r2, [r3]
            }
            if (exc.err != 0)
   29b50:	e51b301c 	ldr	r3, [fp, #-28]
   29b54:	e3530000 	cmp	r3, #0
   29b58:	0a000003 	beq	29b6c <acos+0x158>
	       errno = exc.err;
   29b5c:	ebffdf5b 	bl	218d0 <__errno>
   29b60:	e1a03000 	mov	r3, r0
   29b64:	e51b201c 	ldr	r2, [fp, #-28]
   29b68:	e5832000 	str	r2, [r3]
	    return exc.retval; 
   29b6c:	e24b4024 	sub	r4, fp, #36	; 0x24
   29b70:	e8940018 	ldm	r4, {r3, r4}
   29b74:	ea000001 	b	29b80 <acos+0x16c>
	} else
	    return z;
   29b78:	e24b4014 	sub	r4, fp, #20
   29b7c:	e8940018 	ldm	r4, {r3, r4}
#endif
}
   29b80:	e1a00003 	mov	r0, r3
   29b84:	e1a01004 	mov	r1, r4
   29b88:	e24bd008 	sub	sp, fp, #8
   29b8c:	e8bd4810 	pop	{r4, fp, lr}
   29b90:	e12fff1e 	bx	lr
   29b94:	0003e908 	.word	0x0003e908
   29b98:	3ff00000 	.word	0x3ff00000
   29b9c:	00033390 	.word	0x00033390
   29ba0:	00033398 	.word	0x00033398
   29ba4:	00000000 	.word	0x00000000

00029ba8 <exp>:
	double exp(double x)		/* wrapper exp */
#else
	double exp(x)			/* wrapper exp */
	double x;
#endif
{
   29ba8:	e92d4810 	push	{r4, fp, lr}
   29bac:	e28db008 	add	fp, sp, #8
   29bb0:	e24dd03c 	sub	sp, sp, #60	; 0x3c
   29bb4:	e50b0044 	str	r0, [fp, #-68]	; 0x44
   29bb8:	e50b1040 	str	r1, [fp, #-64]	; 0x40
#ifdef _IEEE_LIBM
	return __ieee754_exp(x);
#else
	double z;
	struct exception exc;
	z = __ieee754_exp(x);
   29bbc:	e24b1044 	sub	r1, fp, #68	; 0x44
   29bc0:	e8910003 	ldm	r1, {r0, r1}
   29bc4:	eb0006e5 	bl	2b760 <__ieee754_exp>
   29bc8:	e50b0014 	str	r0, [fp, #-20]
   29bcc:	e50b1010 	str	r1, [fp, #-16]
	if(_LIB_VERSION == _IEEE_) return z;
   29bd0:	e59f3260 	ldr	r3, [pc, #608]	; 29e38 <exp+0x290>
   29bd4:	e5d33000 	ldrb	r3, [r3]
   29bd8:	e1a03c03 	lsl	r3, r3, #24
   29bdc:	e1a03c43 	asr	r3, r3, #24
   29be0:	e3730001 	cmn	r3, #1
   29be4:	1a000002 	bne	29bf4 <exp+0x4c>
   29be8:	e24b4014 	sub	r4, fp, #20
   29bec:	e8940018 	ldm	r4, {r3, r4}
   29bf0:	ea000086 	b	29e10 <exp+0x268>
	if(finite(x)) {
   29bf4:	e24b1044 	sub	r1, fp, #68	; 0x44
   29bf8:	e8910003 	ldm	r1, {r0, r1}
   29bfc:	eb001c40 	bl	30d04 <finite>
   29c00:	e1a03000 	mov	r3, r0
   29c04:	e3530000 	cmp	r3, #0
   29c08:	0a00007e 	beq	29e08 <exp+0x260>
	    if(x>o_threshold) {
   29c0c:	e28f4f85 	add	r4, pc, #532	; 0x214
   29c10:	e8940018 	ldm	r4, {r3, r4}
   29c14:	e24b1044 	sub	r1, fp, #68	; 0x44
   29c18:	e8910003 	ldm	r1, {r0, r1}
   29c1c:	e1a02003 	mov	r2, r3
   29c20:	e1a03004 	mov	r3, r4
   29c24:	ebffad27 	bl	150c8 <__aeabi_dcmpgt>
   29c28:	e1a03000 	mov	r3, r0
   29c2c:	e3530000 	cmp	r3, #0
   29c30:	0a000039 	beq	29d1c <exp+0x174>
#define HUGE_VAL inf
	        double inf = 0.0;

	        SET_HIGH_WORD(inf,0x7ff00000);	/* set inf to infinite */
#endif
		exc.type = OVERFLOW;
   29c34:	e3a03003 	mov	r3, #3
   29c38:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
		exc.name = "exp";
   29c3c:	e59f31f8 	ldr	r3, [pc, #504]	; 29e3c <exp+0x294>
   29c40:	e50b3038 	str	r3, [fp, #-56]	; 0x38
		exc.err = 0;
   29c44:	e3a03000 	mov	r3, #0
   29c48:	e50b301c 	str	r3, [fp, #-28]
		exc.arg1 = exc.arg2 = x;
   29c4c:	e24b4044 	sub	r4, fp, #68	; 0x44
   29c50:	e8940018 	ldm	r4, {r3, r4}
   29c54:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   29c58:	e50b4028 	str	r4, [fp, #-40]	; 0x28
   29c5c:	e24b402c 	sub	r4, fp, #44	; 0x2c
   29c60:	e8940018 	ldm	r4, {r3, r4}
   29c64:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   29c68:	e50b4030 	str	r4, [fp, #-48]	; 0x30
		if (_LIB_VERSION == _SVID_)
   29c6c:	e59f31c4 	ldr	r3, [pc, #452]	; 29e38 <exp+0x290>
   29c70:	e5d33000 	ldrb	r3, [r3]
   29c74:	e3530000 	cmp	r3, #0
   29c78:	1a000004 	bne	29c90 <exp+0xe8>
		  exc.retval = HUGE;
   29c7c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
   29c80:	e59f41b8 	ldr	r4, [pc, #440]	; 29e40 <exp+0x298>
   29c84:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   29c88:	e50b4020 	str	r4, [fp, #-32]
   29c8c:	ea000003 	b	29ca0 <exp+0xf8>
		else
		  exc.retval = HUGE_VAL;
   29c90:	e3a03000 	mov	r3, #0
   29c94:	e59f41a8 	ldr	r4, [pc, #424]	; 29e44 <exp+0x29c>
   29c98:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   29c9c:	e50b4020 	str	r4, [fp, #-32]
		if (_LIB_VERSION == _POSIX_)
   29ca0:	e59f3190 	ldr	r3, [pc, #400]	; 29e38 <exp+0x290>
   29ca4:	e5d33000 	ldrb	r3, [r3]
   29ca8:	e1a03c03 	lsl	r3, r3, #24
   29cac:	e1a03c43 	asr	r3, r3, #24
   29cb0:	e3530002 	cmp	r3, #2
   29cb4:	1a000004 	bne	29ccc <exp+0x124>
		  errno = ERANGE;
   29cb8:	ebffdf04 	bl	218d0 <__errno>
   29cbc:	e1a03000 	mov	r3, r0
   29cc0:	e3a02022 	mov	r2, #34	; 0x22
   29cc4:	e5832000 	str	r2, [r3]
   29cc8:	ea000009 	b	29cf4 <exp+0x14c>
		else if (!matherr(&exc)) {
   29ccc:	e24b303c 	sub	r3, fp, #60	; 0x3c
   29cd0:	e1a00003 	mov	r0, r3
   29cd4:	eb001cf3 	bl	310a8 <matherr>
   29cd8:	e1a03000 	mov	r3, r0
   29cdc:	e3530000 	cmp	r3, #0
   29ce0:	1a000003 	bne	29cf4 <exp+0x14c>
			errno = ERANGE;
   29ce4:	ebffdef9 	bl	218d0 <__errno>
   29ce8:	e1a03000 	mov	r3, r0
   29cec:	e3a02022 	mov	r2, #34	; 0x22
   29cf0:	e5832000 	str	r2, [r3]
		}
	        if (exc.err != 0)
   29cf4:	e51b301c 	ldr	r3, [fp, #-28]
   29cf8:	e3530000 	cmp	r3, #0
   29cfc:	0a000003 	beq	29d10 <exp+0x168>
	           errno = exc.err;
   29d00:	ebffdef2 	bl	218d0 <__errno>
   29d04:	e1a03000 	mov	r3, r0
   29d08:	e51b201c 	ldr	r2, [fp, #-28]
   29d0c:	e5832000 	str	r2, [r3]
	        return exc.retval; 
   29d10:	e24b4024 	sub	r4, fp, #36	; 0x24
   29d14:	e8940018 	ldm	r4, {r3, r4}
   29d18:	ea00003c 	b	29e10 <exp+0x268>
	    } else if(x<u_threshold) {
   29d1c:	e28f4f43 	add	r4, pc, #268	; 0x10c
   29d20:	e8940018 	ldm	r4, {r3, r4}
   29d24:	e24b1044 	sub	r1, fp, #68	; 0x44
   29d28:	e8910003 	ldm	r1, {r0, r1}
   29d2c:	e1a02003 	mov	r2, r3
   29d30:	e1a03004 	mov	r3, r4
   29d34:	ebffacd1 	bl	15080 <__aeabi_dcmplt>
   29d38:	e1a03000 	mov	r3, r0
   29d3c:	e3530000 	cmp	r3, #0
   29d40:	0a000030 	beq	29e08 <exp+0x260>
		/* exp(finite) underflow */
		exc.type = UNDERFLOW;
   29d44:	e3a03004 	mov	r3, #4
   29d48:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
		exc.name = "exp";
   29d4c:	e59f30e8 	ldr	r3, [pc, #232]	; 29e3c <exp+0x294>
   29d50:	e50b3038 	str	r3, [fp, #-56]	; 0x38
		exc.err = 0;
   29d54:	e3a03000 	mov	r3, #0
   29d58:	e50b301c 	str	r3, [fp, #-28]
		exc.arg1 = exc.arg2 = x;
   29d5c:	e24b4044 	sub	r4, fp, #68	; 0x44
   29d60:	e8940018 	ldm	r4, {r3, r4}
   29d64:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   29d68:	e50b4028 	str	r4, [fp, #-40]	; 0x28
   29d6c:	e24b402c 	sub	r4, fp, #44	; 0x2c
   29d70:	e8940018 	ldm	r4, {r3, r4}
   29d74:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   29d78:	e50b4030 	str	r4, [fp, #-48]	; 0x30
		exc.retval = 0.0;
   29d7c:	e3a03000 	mov	r3, #0
   29d80:	e3a04000 	mov	r4, #0
   29d84:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   29d88:	e50b4020 	str	r4, [fp, #-32]
		if (_LIB_VERSION == _POSIX_)
   29d8c:	e59f30a4 	ldr	r3, [pc, #164]	; 29e38 <exp+0x290>
   29d90:	e5d33000 	ldrb	r3, [r3]
   29d94:	e1a03c03 	lsl	r3, r3, #24
   29d98:	e1a03c43 	asr	r3, r3, #24
   29d9c:	e3530002 	cmp	r3, #2
   29da0:	1a000004 	bne	29db8 <exp+0x210>
		  errno = ERANGE;
   29da4:	ebffdec9 	bl	218d0 <__errno>
   29da8:	e1a03000 	mov	r3, r0
   29dac:	e3a02022 	mov	r2, #34	; 0x22
   29db0:	e5832000 	str	r2, [r3]
   29db4:	ea000009 	b	29de0 <exp+0x238>
		else if (!matherr(&exc)) {
   29db8:	e24b303c 	sub	r3, fp, #60	; 0x3c
   29dbc:	e1a00003 	mov	r0, r3
   29dc0:	eb001cb8 	bl	310a8 <matherr>
   29dc4:	e1a03000 	mov	r3, r0
   29dc8:	e3530000 	cmp	r3, #0
   29dcc:	1a000003 	bne	29de0 <exp+0x238>
			errno = ERANGE;
   29dd0:	ebffdebe 	bl	218d0 <__errno>
   29dd4:	e1a03000 	mov	r3, r0
   29dd8:	e3a02022 	mov	r2, #34	; 0x22
   29ddc:	e5832000 	str	r2, [r3]
		}
	        if (exc.err != 0)
   29de0:	e51b301c 	ldr	r3, [fp, #-28]
   29de4:	e3530000 	cmp	r3, #0
   29de8:	0a000003 	beq	29dfc <exp+0x254>
	           errno = exc.err;
   29dec:	ebffdeb7 	bl	218d0 <__errno>
   29df0:	e1a03000 	mov	r3, r0
   29df4:	e51b201c 	ldr	r2, [fp, #-28]
   29df8:	e5832000 	str	r2, [r3]
	        return exc.retval; 
   29dfc:	e24b4024 	sub	r4, fp, #36	; 0x24
   29e00:	e8940018 	ldm	r4, {r3, r4}
   29e04:	ea000001 	b	29e10 <exp+0x268>
	    } 
	} 
	return z;
   29e08:	e24b4014 	sub	r4, fp, #20
   29e0c:	e8940018 	ldm	r4, {r3, r4}
#endif
}
   29e10:	e1a00003 	mov	r0, r3
   29e14:	e1a01004 	mov	r1, r4
   29e18:	e24bd008 	sub	sp, fp, #8
   29e1c:	e8bd4810 	pop	{r4, fp, lr}
   29e20:	e12fff1e 	bx	lr
   29e24:	e1a00000 	nop			; (mov r0, r0)
   29e28:	fefa39ef 	.word	0xfefa39ef
   29e2c:	40862e42 	.word	0x40862e42
   29e30:	d52d3051 	.word	0xd52d3051
   29e34:	c0874910 	.word	0xc0874910
   29e38:	0003e908 	.word	0x0003e908
   29e3c:	000333b0 	.word	0x000333b0
   29e40:	47efffff 	.word	0x47efffff
   29e44:	7ff00000 	.word	0x7ff00000

00029e48 <pow>:
	double pow(double x, double y)	/* wrapper pow */
#else
	double pow(x,y)			/* wrapper pow */
	double x,y;
#endif
{
   29e48:	e92d4810 	push	{r4, fp, lr}
   29e4c:	e28db008 	add	fp, sp, #8
   29e50:	e24dd044 	sub	sp, sp, #68	; 0x44
   29e54:	e50b0044 	str	r0, [fp, #-68]	; 0x44
   29e58:	e50b1040 	str	r1, [fp, #-64]	; 0x40
   29e5c:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   29e60:	e50b3048 	str	r3, [fp, #-72]	; 0x48
	double inf = 0.0;

	SET_HIGH_WORD(inf,0x7ff00000);	/* set inf to infinite */
#endif
	struct exception exc;
	z=__ieee754_pow(x,y);
   29e64:	e24b1044 	sub	r1, fp, #68	; 0x44
   29e68:	e8910003 	ldm	r1, {r0, r1}
   29e6c:	e24b304c 	sub	r3, fp, #76	; 0x4c
   29e70:	e893000c 	ldm	r3, {r2, r3}
   29e74:	eb00084f 	bl	2bfb8 <__ieee754_pow>
   29e78:	e50b0014 	str	r0, [fp, #-20]
   29e7c:	e50b1010 	str	r1, [fp, #-16]
	if(_LIB_VERSION == _IEEE_|| isnan(y)) return z;
   29e80:	e59f3808 	ldr	r3, [pc, #2056]	; 2a690 <pow+0x848>
   29e84:	e5d33000 	ldrb	r3, [r3]
   29e88:	e1a03c03 	lsl	r3, r3, #24
   29e8c:	e1a03c43 	asr	r3, r3, #24
   29e90:	e3730001 	cmn	r3, #1
   29e94:	0a000005 	beq	29eb0 <pow+0x68>
   29e98:	e24b104c 	sub	r1, fp, #76	; 0x4c
   29e9c:	e8910003 	ldm	r1, {r0, r1}
   29ea0:	ebffed3c 	bl	25398 <__fpclassifyd>
   29ea4:	e1a03000 	mov	r3, r0
   29ea8:	e3530000 	cmp	r3, #0
   29eac:	1a000002 	bne	29ebc <pow+0x74>
   29eb0:	e24b4014 	sub	r4, fp, #20
   29eb4:	e8940018 	ldm	r4, {r3, r4}
   29eb8:	ea0001ef 	b	2a67c <pow+0x834>
	if(isnan(x)) {
   29ebc:	e24b1044 	sub	r1, fp, #68	; 0x44
   29ec0:	e8910003 	ldm	r1, {r0, r1}
   29ec4:	ebffed33 	bl	25398 <__fpclassifyd>
   29ec8:	e1a03000 	mov	r3, r0
   29ecc:	e3530000 	cmp	r3, #0
   29ed0:	1a000041 	bne	29fdc <pow+0x194>
	    if(y==0.0) { 
   29ed4:	e24b104c 	sub	r1, fp, #76	; 0x4c
   29ed8:	e8910003 	ldm	r1, {r0, r1}
   29edc:	e3a02000 	mov	r2, #0
   29ee0:	e3a03000 	mov	r3, #0
   29ee4:	ebffac5f 	bl	15068 <__aeabi_dcmpeq>
   29ee8:	e1a03000 	mov	r3, r0
   29eec:	e3530000 	cmp	r3, #0
   29ef0:	0a000036 	beq	29fd0 <pow+0x188>
		/* pow(NaN,0.0) */
		/* error only if _LIB_VERSION == _SVID_ & _XOPEN_ */
		exc.type = DOMAIN;
   29ef4:	e3a03001 	mov	r3, #1
   29ef8:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
		exc.name = "pow";
   29efc:	e59f3790 	ldr	r3, [pc, #1936]	; 2a694 <pow+0x84c>
   29f00:	e50b3038 	str	r3, [fp, #-56]	; 0x38
		exc.err = 0;
   29f04:	e3a03000 	mov	r3, #0
   29f08:	e50b301c 	str	r3, [fp, #-28]
		exc.arg1 = x;
   29f0c:	e24b4044 	sub	r4, fp, #68	; 0x44
   29f10:	e8940018 	ldm	r4, {r3, r4}
   29f14:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   29f18:	e50b4030 	str	r4, [fp, #-48]	; 0x30
		exc.arg2 = y;
   29f1c:	e24b404c 	sub	r4, fp, #76	; 0x4c
   29f20:	e8940018 	ldm	r4, {r3, r4}
   29f24:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   29f28:	e50b4028 	str	r4, [fp, #-40]	; 0x28
		exc.retval = 1.0;
   29f2c:	e3a03000 	mov	r3, #0
   29f30:	e59f4760 	ldr	r4, [pc, #1888]	; 2a698 <pow+0x850>
   29f34:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   29f38:	e50b4020 	str	r4, [fp, #-32]
		if (_LIB_VERSION == _IEEE_ ||
   29f3c:	e59f374c 	ldr	r3, [pc, #1868]	; 2a690 <pow+0x848>
   29f40:	e5d33000 	ldrb	r3, [r3]
   29f44:	e1a03c03 	lsl	r3, r3, #24
   29f48:	e1a03c43 	asr	r3, r3, #24
   29f4c:	e3730001 	cmn	r3, #1
   29f50:	0a000005 	beq	29f6c <pow+0x124>
		    _LIB_VERSION == _POSIX_) exc.retval = 1.0;
   29f54:	e59f3734 	ldr	r3, [pc, #1844]	; 2a690 <pow+0x848>
   29f58:	e5d33000 	ldrb	r3, [r3]
		exc.name = "pow";
		exc.err = 0;
		exc.arg1 = x;
		exc.arg2 = y;
		exc.retval = 1.0;
		if (_LIB_VERSION == _IEEE_ ||
   29f5c:	e1a03c03 	lsl	r3, r3, #24
   29f60:	e1a03c43 	asr	r3, r3, #24
   29f64:	e3530002 	cmp	r3, #2
   29f68:	1a000004 	bne	29f80 <pow+0x138>
		    _LIB_VERSION == _POSIX_) exc.retval = 1.0;
   29f6c:	e3a03000 	mov	r3, #0
   29f70:	e59f4720 	ldr	r4, [pc, #1824]	; 2a698 <pow+0x850>
   29f74:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   29f78:	e50b4020 	str	r4, [fp, #-32]
   29f7c:	ea000009 	b	29fa8 <pow+0x160>
		else if (!matherr(&exc)) {
   29f80:	e24b303c 	sub	r3, fp, #60	; 0x3c
   29f84:	e1a00003 	mov	r0, r3
   29f88:	eb001c46 	bl	310a8 <matherr>
   29f8c:	e1a03000 	mov	r3, r0
   29f90:	e3530000 	cmp	r3, #0
   29f94:	1a000003 	bne	29fa8 <pow+0x160>
			errno = EDOM;
   29f98:	ebffde4c 	bl	218d0 <__errno>
   29f9c:	e1a03000 	mov	r3, r0
   29fa0:	e3a02021 	mov	r2, #33	; 0x21
   29fa4:	e5832000 	str	r2, [r3]
		}
	        if (exc.err != 0)
   29fa8:	e51b301c 	ldr	r3, [fp, #-28]
   29fac:	e3530000 	cmp	r3, #0
   29fb0:	0a000003 	beq	29fc4 <pow+0x17c>
	           errno = exc.err;
   29fb4:	ebffde45 	bl	218d0 <__errno>
   29fb8:	e1a03000 	mov	r3, r0
   29fbc:	e51b201c 	ldr	r2, [fp, #-28]
   29fc0:	e5832000 	str	r2, [r3]
                return exc.retval; 
   29fc4:	e24b4024 	sub	r4, fp, #36	; 0x24
   29fc8:	e8940018 	ldm	r4, {r3, r4}
   29fcc:	ea0001aa 	b	2a67c <pow+0x834>
	    } else 
		return z;
   29fd0:	e24b4014 	sub	r4, fp, #20
   29fd4:	e8940018 	ldm	r4, {r3, r4}
   29fd8:	ea0001a7 	b	2a67c <pow+0x834>
	}
	if(x==0.0){ 
   29fdc:	e24b1044 	sub	r1, fp, #68	; 0x44
   29fe0:	e8910003 	ldm	r1, {r0, r1}
   29fe4:	e3a02000 	mov	r2, #0
   29fe8:	e3a03000 	mov	r3, #0
   29fec:	ebffac1d 	bl	15068 <__aeabi_dcmpeq>
   29ff0:	e1a03000 	mov	r3, r0
   29ff4:	e3530000 	cmp	r3, #0
   29ff8:	0a000081 	beq	2a204 <pow+0x3bc>
	    if(y==0.0) {
   29ffc:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2a000:	e8910003 	ldm	r1, {r0, r1}
   2a004:	e3a02000 	mov	r2, #0
   2a008:	e3a03000 	mov	r3, #0
   2a00c:	ebffac15 	bl	15068 <__aeabi_dcmpeq>
   2a010:	e1a03000 	mov	r3, r0
   2a014:	e3530000 	cmp	r3, #0
   2a018:	0a00002e 	beq	2a0d8 <pow+0x290>
		/* pow(0.0,0.0) */
		/* error only if _LIB_VERSION == _SVID_ */
		exc.type = DOMAIN;
   2a01c:	e3a03001 	mov	r3, #1
   2a020:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
		exc.name = "pow";
   2a024:	e59f3668 	ldr	r3, [pc, #1640]	; 2a694 <pow+0x84c>
   2a028:	e50b3038 	str	r3, [fp, #-56]	; 0x38
		exc.err = 0;
   2a02c:	e3a03000 	mov	r3, #0
   2a030:	e50b301c 	str	r3, [fp, #-28]
		exc.arg1 = x;
   2a034:	e24b4044 	sub	r4, fp, #68	; 0x44
   2a038:	e8940018 	ldm	r4, {r3, r4}
   2a03c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2a040:	e50b4030 	str	r4, [fp, #-48]	; 0x30
		exc.arg2 = y;
   2a044:	e24b404c 	sub	r4, fp, #76	; 0x4c
   2a048:	e8940018 	ldm	r4, {r3, r4}
   2a04c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2a050:	e50b4028 	str	r4, [fp, #-40]	; 0x28
		exc.retval = 0.0;
   2a054:	e3a03000 	mov	r3, #0
   2a058:	e3a04000 	mov	r4, #0
   2a05c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2a060:	e50b4020 	str	r4, [fp, #-32]
		if (_LIB_VERSION != _SVID_) exc.retval = 1.0;
   2a064:	e59f3624 	ldr	r3, [pc, #1572]	; 2a690 <pow+0x848>
   2a068:	e5d33000 	ldrb	r3, [r3]
   2a06c:	e3530000 	cmp	r3, #0
   2a070:	0a000004 	beq	2a088 <pow+0x240>
   2a074:	e3a03000 	mov	r3, #0
   2a078:	e59f4618 	ldr	r4, [pc, #1560]	; 2a698 <pow+0x850>
   2a07c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2a080:	e50b4020 	str	r4, [fp, #-32]
   2a084:	ea000009 	b	2a0b0 <pow+0x268>
		else if (!matherr(&exc)) {
   2a088:	e24b303c 	sub	r3, fp, #60	; 0x3c
   2a08c:	e1a00003 	mov	r0, r3
   2a090:	eb001c04 	bl	310a8 <matherr>
   2a094:	e1a03000 	mov	r3, r0
   2a098:	e3530000 	cmp	r3, #0
   2a09c:	1a000003 	bne	2a0b0 <pow+0x268>
			errno = EDOM;
   2a0a0:	ebffde0a 	bl	218d0 <__errno>
   2a0a4:	e1a03000 	mov	r3, r0
   2a0a8:	e3a02021 	mov	r2, #33	; 0x21
   2a0ac:	e5832000 	str	r2, [r3]
		}
	        if (exc.err != 0)
   2a0b0:	e51b301c 	ldr	r3, [fp, #-28]
   2a0b4:	e3530000 	cmp	r3, #0
   2a0b8:	0a000003 	beq	2a0cc <pow+0x284>
	           errno = exc.err;
   2a0bc:	ebffde03 	bl	218d0 <__errno>
   2a0c0:	e1a03000 	mov	r3, r0
   2a0c4:	e51b201c 	ldr	r2, [fp, #-28]
   2a0c8:	e5832000 	str	r2, [r3]
                return exc.retval; 
   2a0cc:	e24b4024 	sub	r4, fp, #36	; 0x24
   2a0d0:	e8940018 	ldm	r4, {r3, r4}
   2a0d4:	ea000168 	b	2a67c <pow+0x834>
	    }
            if(finite(y)&&y<0.0) {
   2a0d8:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2a0dc:	e8910003 	ldm	r1, {r0, r1}
   2a0e0:	eb001b07 	bl	30d04 <finite>
   2a0e4:	e1a03000 	mov	r3, r0
   2a0e8:	e3530000 	cmp	r3, #0
   2a0ec:	0a000041 	beq	2a1f8 <pow+0x3b0>
   2a0f0:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2a0f4:	e8910003 	ldm	r1, {r0, r1}
   2a0f8:	e3a02000 	mov	r2, #0
   2a0fc:	e3a03000 	mov	r3, #0
   2a100:	ebffabde 	bl	15080 <__aeabi_dcmplt>
   2a104:	e1a03000 	mov	r3, r0
   2a108:	e3530000 	cmp	r3, #0
   2a10c:	0a000039 	beq	2a1f8 <pow+0x3b0>
		/* 0**neg */
		exc.type = DOMAIN;
   2a110:	e3a03001 	mov	r3, #1
   2a114:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
		exc.name = "pow";
   2a118:	e59f3574 	ldr	r3, [pc, #1396]	; 2a694 <pow+0x84c>
   2a11c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
		exc.err = 0;
   2a120:	e3a03000 	mov	r3, #0
   2a124:	e50b301c 	str	r3, [fp, #-28]
		exc.arg1 = x;
   2a128:	e24b4044 	sub	r4, fp, #68	; 0x44
   2a12c:	e8940018 	ldm	r4, {r3, r4}
   2a130:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2a134:	e50b4030 	str	r4, [fp, #-48]	; 0x30
		exc.arg2 = y;
   2a138:	e24b404c 	sub	r4, fp, #76	; 0x4c
   2a13c:	e8940018 	ldm	r4, {r3, r4}
   2a140:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2a144:	e50b4028 	str	r4, [fp, #-40]	; 0x28
		if (_LIB_VERSION == _SVID_) 
   2a148:	e59f3540 	ldr	r3, [pc, #1344]	; 2a690 <pow+0x848>
   2a14c:	e5d33000 	ldrb	r3, [r3]
   2a150:	e3530000 	cmp	r3, #0
   2a154:	1a000004 	bne	2a16c <pow+0x324>
		  exc.retval = 0.0;
   2a158:	e3a03000 	mov	r3, #0
   2a15c:	e3a04000 	mov	r4, #0
   2a160:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2a164:	e50b4020 	str	r4, [fp, #-32]
   2a168:	ea000003 	b	2a17c <pow+0x334>
		else
		  exc.retval = -HUGE_VAL;
   2a16c:	e3a03000 	mov	r3, #0
   2a170:	e59f4524 	ldr	r4, [pc, #1316]	; 2a69c <pow+0x854>
   2a174:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2a178:	e50b4020 	str	r4, [fp, #-32]
		if (_LIB_VERSION == _POSIX_)
   2a17c:	e59f350c 	ldr	r3, [pc, #1292]	; 2a690 <pow+0x848>
   2a180:	e5d33000 	ldrb	r3, [r3]
   2a184:	e1a03c03 	lsl	r3, r3, #24
   2a188:	e1a03c43 	asr	r3, r3, #24
   2a18c:	e3530002 	cmp	r3, #2
   2a190:	1a000004 	bne	2a1a8 <pow+0x360>
		  errno = EDOM;
   2a194:	ebffddcd 	bl	218d0 <__errno>
   2a198:	e1a03000 	mov	r3, r0
   2a19c:	e3a02021 	mov	r2, #33	; 0x21
   2a1a0:	e5832000 	str	r2, [r3]
   2a1a4:	ea000009 	b	2a1d0 <pow+0x388>
		else if (!matherr(&exc)) {
   2a1a8:	e24b303c 	sub	r3, fp, #60	; 0x3c
   2a1ac:	e1a00003 	mov	r0, r3
   2a1b0:	eb001bbc 	bl	310a8 <matherr>
   2a1b4:	e1a03000 	mov	r3, r0
   2a1b8:	e3530000 	cmp	r3, #0
   2a1bc:	1a000003 	bne	2a1d0 <pow+0x388>
		  errno = EDOM;
   2a1c0:	ebffddc2 	bl	218d0 <__errno>
   2a1c4:	e1a03000 	mov	r3, r0
   2a1c8:	e3a02021 	mov	r2, #33	; 0x21
   2a1cc:	e5832000 	str	r2, [r3]
		}
	        if (exc.err != 0)
   2a1d0:	e51b301c 	ldr	r3, [fp, #-28]
   2a1d4:	e3530000 	cmp	r3, #0
   2a1d8:	0a000003 	beq	2a1ec <pow+0x3a4>
	           errno = exc.err;
   2a1dc:	ebffddbb 	bl	218d0 <__errno>
   2a1e0:	e1a03000 	mov	r3, r0
   2a1e4:	e51b201c 	ldr	r2, [fp, #-28]
   2a1e8:	e5832000 	str	r2, [r3]
                return exc.retval; 
   2a1ec:	e24b4024 	sub	r4, fp, #36	; 0x24
   2a1f0:	e8940018 	ldm	r4, {r3, r4}
   2a1f4:	ea000120 	b	2a67c <pow+0x834>
            } 
	    return z;
   2a1f8:	e24b4014 	sub	r4, fp, #20
   2a1fc:	e8940018 	ldm	r4, {r3, r4}
   2a200:	ea00011d 	b	2a67c <pow+0x834>
	}
	if(!finite(z)) {
   2a204:	e24b1014 	sub	r1, fp, #20
   2a208:	e8910003 	ldm	r1, {r0, r1}
   2a20c:	eb001abc 	bl	30d04 <finite>
   2a210:	e1a03000 	mov	r3, r0
   2a214:	e3530000 	cmp	r3, #0
   2a218:	1a0000d0 	bne	2a560 <pow+0x718>
	    if(finite(x)&&finite(y)) {
   2a21c:	e24b1044 	sub	r1, fp, #68	; 0x44
   2a220:	e8910003 	ldm	r1, {r0, r1}
   2a224:	eb001ab6 	bl	30d04 <finite>
   2a228:	e1a03000 	mov	r3, r0
   2a22c:	e3530000 	cmp	r3, #0
   2a230:	0a0000ca 	beq	2a560 <pow+0x718>
   2a234:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2a238:	e8910003 	ldm	r1, {r0, r1}
   2a23c:	eb001ab0 	bl	30d04 <finite>
   2a240:	e1a03000 	mov	r3, r0
   2a244:	e3530000 	cmp	r3, #0
   2a248:	0a0000c4 	beq	2a560 <pow+0x718>
	        if(isnan(z)) {
   2a24c:	e24b1014 	sub	r1, fp, #20
   2a250:	e8910003 	ldm	r1, {r0, r1}
   2a254:	ebffec4f 	bl	25398 <__fpclassifyd>
   2a258:	e1a03000 	mov	r3, r0
   2a25c:	e3530000 	cmp	r3, #0
   2a260:	1a00003e 	bne	2a360 <pow+0x518>
		    /* neg**non-integral */
		    exc.type = DOMAIN;
   2a264:	e3a03001 	mov	r3, #1
   2a268:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
		    exc.name = "pow";
   2a26c:	e59f3420 	ldr	r3, [pc, #1056]	; 2a694 <pow+0x84c>
   2a270:	e50b3038 	str	r3, [fp, #-56]	; 0x38
		    exc.err = 0;
   2a274:	e3a03000 	mov	r3, #0
   2a278:	e50b301c 	str	r3, [fp, #-28]
		    exc.arg1 = x;
   2a27c:	e24b4044 	sub	r4, fp, #68	; 0x44
   2a280:	e8940018 	ldm	r4, {r3, r4}
   2a284:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2a288:	e50b4030 	str	r4, [fp, #-48]	; 0x30
		    exc.arg2 = y;
   2a28c:	e24b404c 	sub	r4, fp, #76	; 0x4c
   2a290:	e8940018 	ldm	r4, {r3, r4}
   2a294:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2a298:	e50b4028 	str	r4, [fp, #-40]	; 0x28
		    if (_LIB_VERSION == _SVID_) 
   2a29c:	e59f33ec 	ldr	r3, [pc, #1004]	; 2a690 <pow+0x848>
   2a2a0:	e5d33000 	ldrb	r3, [r3]
   2a2a4:	e3530000 	cmp	r3, #0
   2a2a8:	1a000004 	bne	2a2c0 <pow+0x478>
		        exc.retval = 0.0;
   2a2ac:	e3a03000 	mov	r3, #0
   2a2b0:	e3a04000 	mov	r4, #0
   2a2b4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2a2b8:	e50b4020 	str	r4, [fp, #-32]
   2a2bc:	ea000008 	b	2a2e4 <pow+0x49c>
		    else 
		        exc.retval = 0.0/0.0;	/* X/Open allow NaN */
   2a2c0:	e3a00000 	mov	r0, #0
   2a2c4:	e3a01000 	mov	r1, #0
   2a2c8:	e3a02000 	mov	r2, #0
   2a2cc:	e3a03000 	mov	r3, #0
   2a2d0:	ebffaaae 	bl	14d90 <__aeabi_ddiv>
   2a2d4:	e1a03000 	mov	r3, r0
   2a2d8:	e1a04001 	mov	r4, r1
   2a2dc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2a2e0:	e50b4020 	str	r4, [fp, #-32]
		    if (_LIB_VERSION == _POSIX_) 
   2a2e4:	e59f33a4 	ldr	r3, [pc, #932]	; 2a690 <pow+0x848>
   2a2e8:	e5d33000 	ldrb	r3, [r3]
   2a2ec:	e1a03c03 	lsl	r3, r3, #24
   2a2f0:	e1a03c43 	asr	r3, r3, #24
   2a2f4:	e3530002 	cmp	r3, #2
   2a2f8:	1a000004 	bne	2a310 <pow+0x4c8>
		        errno = EDOM;
   2a2fc:	ebffdd73 	bl	218d0 <__errno>
   2a300:	e1a03000 	mov	r3, r0
   2a304:	e3a02021 	mov	r2, #33	; 0x21
   2a308:	e5832000 	str	r2, [r3]
   2a30c:	ea000009 	b	2a338 <pow+0x4f0>
		    else if (!matherr(&exc)) {
   2a310:	e24b303c 	sub	r3, fp, #60	; 0x3c
   2a314:	e1a00003 	mov	r0, r3
   2a318:	eb001b62 	bl	310a8 <matherr>
   2a31c:	e1a03000 	mov	r3, r0
   2a320:	e3530000 	cmp	r3, #0
   2a324:	1a000003 	bne	2a338 <pow+0x4f0>
		        errno = EDOM;
   2a328:	ebffdd68 	bl	218d0 <__errno>
   2a32c:	e1a03000 	mov	r3, r0
   2a330:	e3a02021 	mov	r2, #33	; 0x21
   2a334:	e5832000 	str	r2, [r3]
		    }
	            if (exc.err != 0)
   2a338:	e51b301c 	ldr	r3, [fp, #-28]
   2a33c:	e3530000 	cmp	r3, #0
   2a340:	0a000003 	beq	2a354 <pow+0x50c>
	                errno = exc.err;
   2a344:	ebffdd61 	bl	218d0 <__errno>
   2a348:	e1a03000 	mov	r3, r0
   2a34c:	e51b201c 	ldr	r2, [fp, #-28]
   2a350:	e5832000 	str	r2, [r3]
                    return exc.retval; 
   2a354:	e24b4024 	sub	r4, fp, #36	; 0x24
   2a358:	e8940018 	ldm	r4, {r3, r4}
   2a35c:	ea0000c6 	b	2a67c <pow+0x834>
	        } else {
		    /* pow(x,y) overflow */
		    exc.type = OVERFLOW;
   2a360:	e3a03003 	mov	r3, #3
   2a364:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
		    exc.name = "pow";
   2a368:	e59f3324 	ldr	r3, [pc, #804]	; 2a694 <pow+0x84c>
   2a36c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
		    exc.err = 0;
   2a370:	e3a03000 	mov	r3, #0
   2a374:	e50b301c 	str	r3, [fp, #-28]
		    exc.arg1 = x;
   2a378:	e24b4044 	sub	r4, fp, #68	; 0x44
   2a37c:	e8940018 	ldm	r4, {r3, r4}
   2a380:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2a384:	e50b4030 	str	r4, [fp, #-48]	; 0x30
		    exc.arg2 = y;
   2a388:	e24b404c 	sub	r4, fp, #76	; 0x4c
   2a38c:	e8940018 	ldm	r4, {r3, r4}
   2a390:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2a394:	e50b4028 	str	r4, [fp, #-40]	; 0x28
		    if (_LIB_VERSION == _SVID_) {
   2a398:	e59f32f0 	ldr	r3, [pc, #752]	; 2a690 <pow+0x848>
   2a39c:	e5d33000 	ldrb	r3, [r3]
   2a3a0:	e3530000 	cmp	r3, #0
   2a3a4:	1a000028 	bne	2a44c <pow+0x604>
		       exc.retval = HUGE;
   2a3a8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
   2a3ac:	e59f42ec 	ldr	r4, [pc, #748]	; 2a6a0 <pow+0x858>
   2a3b0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2a3b4:	e50b4020 	str	r4, [fp, #-32]
		       y *= 0.5;
   2a3b8:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2a3bc:	e8910003 	ldm	r1, {r0, r1}
   2a3c0:	e3a02000 	mov	r2, #0
   2a3c4:	e59f32d8 	ldr	r3, [pc, #728]	; 2a6a4 <pow+0x85c>
   2a3c8:	ebffa9cc 	bl	14b00 <__aeabi_dmul>
   2a3cc:	e1a03000 	mov	r3, r0
   2a3d0:	e1a04001 	mov	r4, r1
   2a3d4:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   2a3d8:	e50b4048 	str	r4, [fp, #-72]	; 0x48
		       if(x<0.0&&rint(y)!=y) exc.retval = -HUGE;
   2a3dc:	e24b1044 	sub	r1, fp, #68	; 0x44
   2a3e0:	e8910003 	ldm	r1, {r0, r1}
   2a3e4:	e3a02000 	mov	r2, #0
   2a3e8:	e3a03000 	mov	r3, #0
   2a3ec:	ebffab23 	bl	15080 <__aeabi_dcmplt>
   2a3f0:	e1a03000 	mov	r3, r0
   2a3f4:	e3530000 	cmp	r3, #0
   2a3f8:	1a000000 	bne	2a400 <pow+0x5b8>
   2a3fc:	ea000038 	b	2a4e4 <pow+0x69c>
   2a400:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2a404:	e8910003 	ldm	r1, {r0, r1}
   2a408:	eb001b55 	bl	31164 <rint>
   2a40c:	e1a03000 	mov	r3, r0
   2a410:	e1a04001 	mov	r4, r1
   2a414:	e1a00003 	mov	r0, r3
   2a418:	e1a01004 	mov	r1, r4
   2a41c:	e24b304c 	sub	r3, fp, #76	; 0x4c
   2a420:	e893000c 	ldm	r3, {r2, r3}
   2a424:	ebffab0f 	bl	15068 <__aeabi_dcmpeq>
   2a428:	e1a03000 	mov	r3, r0
   2a42c:	e3530000 	cmp	r3, #0
   2a430:	0a000000 	beq	2a438 <pow+0x5f0>
   2a434:	ea00002a 	b	2a4e4 <pow+0x69c>
   2a438:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
   2a43c:	e59f4264 	ldr	r4, [pc, #612]	; 2a6a8 <pow+0x860>
   2a440:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2a444:	e50b4020 	str	r4, [fp, #-32]
   2a448:	ea000025 	b	2a4e4 <pow+0x69c>
		    } else {
		       exc.retval = HUGE_VAL;
   2a44c:	e3a03000 	mov	r3, #0
   2a450:	e59f4254 	ldr	r4, [pc, #596]	; 2a6ac <pow+0x864>
   2a454:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2a458:	e50b4020 	str	r4, [fp, #-32]
                       y *= 0.5;
   2a45c:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2a460:	e8910003 	ldm	r1, {r0, r1}
   2a464:	e3a02000 	mov	r2, #0
   2a468:	e59f3234 	ldr	r3, [pc, #564]	; 2a6a4 <pow+0x85c>
   2a46c:	ebffa9a3 	bl	14b00 <__aeabi_dmul>
   2a470:	e1a03000 	mov	r3, r0
   2a474:	e1a04001 	mov	r4, r1
   2a478:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   2a47c:	e50b4048 	str	r4, [fp, #-72]	; 0x48
		       if(x<0.0&&rint(y)!=y) exc.retval = -HUGE_VAL;
   2a480:	e24b1044 	sub	r1, fp, #68	; 0x44
   2a484:	e8910003 	ldm	r1, {r0, r1}
   2a488:	e3a02000 	mov	r2, #0
   2a48c:	e3a03000 	mov	r3, #0
   2a490:	ebffaafa 	bl	15080 <__aeabi_dcmplt>
   2a494:	e1a03000 	mov	r3, r0
   2a498:	e3530000 	cmp	r3, #0
   2a49c:	0a000010 	beq	2a4e4 <pow+0x69c>
   2a4a0:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2a4a4:	e8910003 	ldm	r1, {r0, r1}
   2a4a8:	eb001b2d 	bl	31164 <rint>
   2a4ac:	e1a03000 	mov	r3, r0
   2a4b0:	e1a04001 	mov	r4, r1
   2a4b4:	e1a00003 	mov	r0, r3
   2a4b8:	e1a01004 	mov	r1, r4
   2a4bc:	e24b304c 	sub	r3, fp, #76	; 0x4c
   2a4c0:	e893000c 	ldm	r3, {r2, r3}
   2a4c4:	ebffaae7 	bl	15068 <__aeabi_dcmpeq>
   2a4c8:	e1a03000 	mov	r3, r0
   2a4cc:	e3530000 	cmp	r3, #0
   2a4d0:	1a000003 	bne	2a4e4 <pow+0x69c>
   2a4d4:	e3a03000 	mov	r3, #0
   2a4d8:	e59f41bc 	ldr	r4, [pc, #444]	; 2a69c <pow+0x854>
   2a4dc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2a4e0:	e50b4020 	str	r4, [fp, #-32]
		    }
		    if (_LIB_VERSION == _POSIX_)
   2a4e4:	e59f31a4 	ldr	r3, [pc, #420]	; 2a690 <pow+0x848>
   2a4e8:	e5d33000 	ldrb	r3, [r3]
   2a4ec:	e1a03c03 	lsl	r3, r3, #24
   2a4f0:	e1a03c43 	asr	r3, r3, #24
   2a4f4:	e3530002 	cmp	r3, #2
   2a4f8:	1a000004 	bne	2a510 <pow+0x6c8>
		        errno = ERANGE;
   2a4fc:	ebffdcf3 	bl	218d0 <__errno>
   2a500:	e1a03000 	mov	r3, r0
   2a504:	e3a02022 	mov	r2, #34	; 0x22
   2a508:	e5832000 	str	r2, [r3]
   2a50c:	ea000009 	b	2a538 <pow+0x6f0>
		    else if (!matherr(&exc)) {
   2a510:	e24b303c 	sub	r3, fp, #60	; 0x3c
   2a514:	e1a00003 	mov	r0, r3
   2a518:	eb001ae2 	bl	310a8 <matherr>
   2a51c:	e1a03000 	mov	r3, r0
   2a520:	e3530000 	cmp	r3, #0
   2a524:	1a000003 	bne	2a538 <pow+0x6f0>
			errno = ERANGE;
   2a528:	ebffdce8 	bl	218d0 <__errno>
   2a52c:	e1a03000 	mov	r3, r0
   2a530:	e3a02022 	mov	r2, #34	; 0x22
   2a534:	e5832000 	str	r2, [r3]
		    }
	            if (exc.err != 0)
   2a538:	e51b301c 	ldr	r3, [fp, #-28]
   2a53c:	e3530000 	cmp	r3, #0
   2a540:	0a000003 	beq	2a554 <pow+0x70c>
	                errno = exc.err;
   2a544:	ebffdce1 	bl	218d0 <__errno>
   2a548:	e1a03000 	mov	r3, r0
   2a54c:	e51b201c 	ldr	r2, [fp, #-28]
   2a550:	e5832000 	str	r2, [r3]
                    return exc.retval; 
   2a554:	e24b4024 	sub	r4, fp, #36	; 0x24
   2a558:	e8940018 	ldm	r4, {r3, r4}
   2a55c:	ea000046 	b	2a67c <pow+0x834>
                }
	    }
	} 
	if(z==0.0&&finite(x)&&finite(y)) {
   2a560:	e24b1014 	sub	r1, fp, #20
   2a564:	e8910003 	ldm	r1, {r0, r1}
   2a568:	e3a02000 	mov	r2, #0
   2a56c:	e3a03000 	mov	r3, #0
   2a570:	ebffaabc 	bl	15068 <__aeabi_dcmpeq>
   2a574:	e1a03000 	mov	r3, r0
   2a578:	e3530000 	cmp	r3, #0
   2a57c:	0a00003c 	beq	2a674 <pow+0x82c>
   2a580:	e24b1044 	sub	r1, fp, #68	; 0x44
   2a584:	e8910003 	ldm	r1, {r0, r1}
   2a588:	eb0019dd 	bl	30d04 <finite>
   2a58c:	e1a03000 	mov	r3, r0
   2a590:	e3530000 	cmp	r3, #0
   2a594:	0a000036 	beq	2a674 <pow+0x82c>
   2a598:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2a59c:	e8910003 	ldm	r1, {r0, r1}
   2a5a0:	eb0019d7 	bl	30d04 <finite>
   2a5a4:	e1a03000 	mov	r3, r0
   2a5a8:	e3530000 	cmp	r3, #0
   2a5ac:	0a000030 	beq	2a674 <pow+0x82c>
	    /* pow(x,y) underflow */
	    exc.type = UNDERFLOW;
   2a5b0:	e3a03004 	mov	r3, #4
   2a5b4:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
	    exc.name = "pow";
   2a5b8:	e59f30d4 	ldr	r3, [pc, #212]	; 2a694 <pow+0x84c>
   2a5bc:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	    exc.err = 0;
   2a5c0:	e3a03000 	mov	r3, #0
   2a5c4:	e50b301c 	str	r3, [fp, #-28]
	    exc.arg1 = x;
   2a5c8:	e24b4044 	sub	r4, fp, #68	; 0x44
   2a5cc:	e8940018 	ldm	r4, {r3, r4}
   2a5d0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2a5d4:	e50b4030 	str	r4, [fp, #-48]	; 0x30
	    exc.arg2 = y;
   2a5d8:	e24b404c 	sub	r4, fp, #76	; 0x4c
   2a5dc:	e8940018 	ldm	r4, {r3, r4}
   2a5e0:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2a5e4:	e50b4028 	str	r4, [fp, #-40]	; 0x28
	    exc.retval =  0.0;
   2a5e8:	e3a03000 	mov	r3, #0
   2a5ec:	e3a04000 	mov	r4, #0
   2a5f0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2a5f4:	e50b4020 	str	r4, [fp, #-32]
	    if (_LIB_VERSION == _POSIX_)
   2a5f8:	e59f3090 	ldr	r3, [pc, #144]	; 2a690 <pow+0x848>
   2a5fc:	e5d33000 	ldrb	r3, [r3]
   2a600:	e1a03c03 	lsl	r3, r3, #24
   2a604:	e1a03c43 	asr	r3, r3, #24
   2a608:	e3530002 	cmp	r3, #2
   2a60c:	1a000004 	bne	2a624 <pow+0x7dc>
	        errno = ERANGE;
   2a610:	ebffdcae 	bl	218d0 <__errno>
   2a614:	e1a03000 	mov	r3, r0
   2a618:	e3a02022 	mov	r2, #34	; 0x22
   2a61c:	e5832000 	str	r2, [r3]
   2a620:	ea000009 	b	2a64c <pow+0x804>
	    else if (!matherr(&exc)) {
   2a624:	e24b303c 	sub	r3, fp, #60	; 0x3c
   2a628:	e1a00003 	mov	r0, r3
   2a62c:	eb001a9d 	bl	310a8 <matherr>
   2a630:	e1a03000 	mov	r3, r0
   2a634:	e3530000 	cmp	r3, #0
   2a638:	1a000003 	bne	2a64c <pow+0x804>
	     	errno = ERANGE;
   2a63c:	ebffdca3 	bl	218d0 <__errno>
   2a640:	e1a03000 	mov	r3, r0
   2a644:	e3a02022 	mov	r2, #34	; 0x22
   2a648:	e5832000 	str	r2, [r3]
	    }
	    if (exc.err != 0)
   2a64c:	e51b301c 	ldr	r3, [fp, #-28]
   2a650:	e3530000 	cmp	r3, #0
   2a654:	0a000003 	beq	2a668 <pow+0x820>
	        errno = exc.err;
   2a658:	ebffdc9c 	bl	218d0 <__errno>
   2a65c:	e1a03000 	mov	r3, r0
   2a660:	e51b201c 	ldr	r2, [fp, #-28]
   2a664:	e5832000 	str	r2, [r3]
            return exc.retval; 
   2a668:	e24b4024 	sub	r4, fp, #36	; 0x24
   2a66c:	e8940018 	ldm	r4, {r3, r4}
   2a670:	ea000001 	b	2a67c <pow+0x834>
        } 
	return z;
   2a674:	e24b4014 	sub	r4, fp, #20
   2a678:	e8940018 	ldm	r4, {r3, r4}
#endif
}
   2a67c:	e1a00003 	mov	r0, r3
   2a680:	e1a01004 	mov	r1, r4
   2a684:	e24bd008 	sub	sp, fp, #8
   2a688:	e8bd4810 	pop	{r4, fp, lr}
   2a68c:	e12fff1e 	bx	lr
   2a690:	0003e908 	.word	0x0003e908
   2a694:	000333b4 	.word	0x000333b4
   2a698:	3ff00000 	.word	0x3ff00000
   2a69c:	fff00000 	.word	0xfff00000
   2a6a0:	47efffff 	.word	0x47efffff
   2a6a4:	3fe00000 	.word	0x3fe00000
   2a6a8:	c7efffff 	.word	0xc7efffff
   2a6ac:	7ff00000 	.word	0x7ff00000

0002a6b0 <sqrt>:
	double sqrt(double x)		/* wrapper sqrt */
#else
	double sqrt(x)			/* wrapper sqrt */
	double x;
#endif
{
   2a6b0:	e92d4810 	push	{r4, fp, lr}
   2a6b4:	e28db008 	add	fp, sp, #8
   2a6b8:	e24dd03c 	sub	sp, sp, #60	; 0x3c
   2a6bc:	e50b0044 	str	r0, [fp, #-68]	; 0x44
   2a6c0:	e50b1040 	str	r1, [fp, #-64]	; 0x40
#ifdef _IEEE_LIBM
	return __ieee754_sqrt(x);
#else
	struct exception exc;
	double z;
	z = __ieee754_sqrt(x);
   2a6c4:	e24b1044 	sub	r1, fp, #68	; 0x44
   2a6c8:	e8910003 	ldm	r1, {r0, r1}
   2a6cc:	eb0010b9 	bl	2e9b8 <__ieee754_sqrt>
   2a6d0:	e50b0014 	str	r0, [fp, #-20]
   2a6d4:	e50b1010 	str	r1, [fp, #-16]
	if(_LIB_VERSION == _IEEE_ || isnan(x)) return z;
   2a6d8:	e59f316c 	ldr	r3, [pc, #364]	; 2a84c <sqrt+0x19c>
   2a6dc:	e5d33000 	ldrb	r3, [r3]
   2a6e0:	e1a03c03 	lsl	r3, r3, #24
   2a6e4:	e1a03c43 	asr	r3, r3, #24
   2a6e8:	e3730001 	cmn	r3, #1
   2a6ec:	0a000005 	beq	2a708 <sqrt+0x58>
   2a6f0:	e24b1044 	sub	r1, fp, #68	; 0x44
   2a6f4:	e8910003 	ldm	r1, {r0, r1}
   2a6f8:	ebffeb26 	bl	25398 <__fpclassifyd>
   2a6fc:	e1a03000 	mov	r3, r0
   2a700:	e3530000 	cmp	r3, #0
   2a704:	1a000002 	bne	2a714 <sqrt+0x64>
   2a708:	e24b4014 	sub	r4, fp, #20
   2a70c:	e8940018 	ldm	r4, {r3, r4}
   2a710:	ea000048 	b	2a838 <sqrt+0x188>
	if(x<0.0) {
   2a714:	e24b1044 	sub	r1, fp, #68	; 0x44
   2a718:	e8910003 	ldm	r1, {r0, r1}
   2a71c:	e3a02000 	mov	r2, #0
   2a720:	e3a03000 	mov	r3, #0
   2a724:	ebffaa55 	bl	15080 <__aeabi_dcmplt>
   2a728:	e1a03000 	mov	r3, r0
   2a72c:	e3530000 	cmp	r3, #0
   2a730:	0a00003e 	beq	2a830 <sqrt+0x180>
	  exc.type = DOMAIN;
   2a734:	e3a03001 	mov	r3, #1
   2a738:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
	  exc.name = "sqrt";
   2a73c:	e59f310c 	ldr	r3, [pc, #268]	; 2a850 <sqrt+0x1a0>
   2a740:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	  exc.err = 0;
   2a744:	e3a03000 	mov	r3, #0
   2a748:	e50b301c 	str	r3, [fp, #-28]
	  exc.arg1 = exc.arg2 = x;
   2a74c:	e24b4044 	sub	r4, fp, #68	; 0x44
   2a750:	e8940018 	ldm	r4, {r3, r4}
   2a754:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2a758:	e50b4028 	str	r4, [fp, #-40]	; 0x28
   2a75c:	e24b402c 	sub	r4, fp, #44	; 0x2c
   2a760:	e8940018 	ldm	r4, {r3, r4}
   2a764:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2a768:	e50b4030 	str	r4, [fp, #-48]	; 0x30
	  if (_LIB_VERSION == _SVID_)
   2a76c:	e59f30d8 	ldr	r3, [pc, #216]	; 2a84c <sqrt+0x19c>
   2a770:	e5d33000 	ldrb	r3, [r3]
   2a774:	e3530000 	cmp	r3, #0
   2a778:	1a000004 	bne	2a790 <sqrt+0xe0>
	    exc.retval = 0.0;
   2a77c:	e3a03000 	mov	r3, #0
   2a780:	e3a04000 	mov	r4, #0
   2a784:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2a788:	e50b4020 	str	r4, [fp, #-32]
   2a78c:	ea000008 	b	2a7b4 <sqrt+0x104>
          else
            exc.retval = 0.0/0.0;
   2a790:	e3a00000 	mov	r0, #0
   2a794:	e3a01000 	mov	r1, #0
   2a798:	e3a02000 	mov	r2, #0
   2a79c:	e3a03000 	mov	r3, #0
   2a7a0:	ebffa97a 	bl	14d90 <__aeabi_ddiv>
   2a7a4:	e1a03000 	mov	r3, r0
   2a7a8:	e1a04001 	mov	r4, r1
   2a7ac:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2a7b0:	e50b4020 	str	r4, [fp, #-32]
          if (_LIB_VERSION == _POSIX_)
   2a7b4:	e59f3090 	ldr	r3, [pc, #144]	; 2a84c <sqrt+0x19c>
   2a7b8:	e5d33000 	ldrb	r3, [r3]
   2a7bc:	e1a03c03 	lsl	r3, r3, #24
   2a7c0:	e1a03c43 	asr	r3, r3, #24
   2a7c4:	e3530002 	cmp	r3, #2
   2a7c8:	1a000004 	bne	2a7e0 <sqrt+0x130>
            errno = EDOM;
   2a7cc:	ebffdc3f 	bl	218d0 <__errno>
   2a7d0:	e1a03000 	mov	r3, r0
   2a7d4:	e3a02021 	mov	r2, #33	; 0x21
   2a7d8:	e5832000 	str	r2, [r3]
   2a7dc:	ea000009 	b	2a808 <sqrt+0x158>
          else if (!matherr(&exc)) {
   2a7e0:	e24b303c 	sub	r3, fp, #60	; 0x3c
   2a7e4:	e1a00003 	mov	r0, r3
   2a7e8:	eb001a2e 	bl	310a8 <matherr>
   2a7ec:	e1a03000 	mov	r3, r0
   2a7f0:	e3530000 	cmp	r3, #0
   2a7f4:	1a000003 	bne	2a808 <sqrt+0x158>
            errno = EDOM;
   2a7f8:	ebffdc34 	bl	218d0 <__errno>
   2a7fc:	e1a03000 	mov	r3, r0
   2a800:	e3a02021 	mov	r2, #33	; 0x21
   2a804:	e5832000 	str	r2, [r3]
          }
          if (exc.err != 0)
   2a808:	e51b301c 	ldr	r3, [fp, #-28]
   2a80c:	e3530000 	cmp	r3, #0
   2a810:	0a000003 	beq	2a824 <sqrt+0x174>
	    errno = exc.err;
   2a814:	ebffdc2d 	bl	218d0 <__errno>
   2a818:	e1a03000 	mov	r3, r0
   2a81c:	e51b201c 	ldr	r2, [fp, #-28]
   2a820:	e5832000 	str	r2, [r3]
	  return exc.retval; 
   2a824:	e24b4024 	sub	r4, fp, #36	; 0x24
   2a828:	e8940018 	ldm	r4, {r3, r4}
   2a82c:	ea000001 	b	2a838 <sqrt+0x188>
	} else
	    return z;
   2a830:	e24b4014 	sub	r4, fp, #20
   2a834:	e8940018 	ldm	r4, {r3, r4}
#endif
}
   2a838:	e1a00003 	mov	r0, r3
   2a83c:	e1a01004 	mov	r1, r4
   2a840:	e24bd008 	sub	sp, fp, #8
   2a844:	e8bd4810 	pop	{r4, fp, lr}
   2a848:	e12fff1e 	bx	lr
   2a84c:	0003e908 	.word	0x0003e908
   2a850:	000333b8 	.word	0x000333b8
   2a854:	00000000 	.word	0x00000000

0002a858 <__ieee754_acos>:
	double __ieee754_acos(double x)
#else
	double __ieee754_acos(x)
	double x;
#endif
{
   2a858:	e92d49f0 	push	{r4, r5, r6, r7, r8, fp, lr}
   2a85c:	e28db018 	add	fp, sp, #24
   2a860:	e24dd074 	sub	sp, sp, #116	; 0x74
   2a864:	e50b008c 	str	r0, [fp, #-140]	; 0x8c
   2a868:	e50b1088 	str	r1, [fp, #-136]	; 0x88
	double z,p,q,r,w,s,c,df;
	__int32_t hx,ix;
	GET_HIGH_WORD(hx,x);
   2a86c:	e24b408c 	sub	r4, fp, #140	; 0x8c
   2a870:	e8940018 	ldm	r4, {r3, r4}
   2a874:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   2a878:	e50b4070 	str	r4, [fp, #-112]	; 0x70
   2a87c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   2a880:	e50b3020 	str	r3, [fp, #-32]
	ix = hx&0x7fffffff;
   2a884:	e51b3020 	ldr	r3, [fp, #-32]
   2a888:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   2a88c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	if(ix>=0x3ff00000) {	/* |x| >= 1 */
   2a890:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   2a894:	e59f3174 	ldr	r3, [pc, #372]	; 2aa10 <__ieee754_acos+0x1b8>
   2a898:	e1520003 	cmp	r2, r3
   2a89c:	da000040 	ble	2a9a4 <__ieee754_acos+0x14c>
	    __uint32_t lx;
	    GET_LOW_WORD(lx,x);
   2a8a0:	e24b408c 	sub	r4, fp, #140	; 0x8c
   2a8a4:	e8940018 	ldm	r4, {r3, r4}
   2a8a8:	e50b307c 	str	r3, [fp, #-124]	; 0x7c
   2a8ac:	e50b4078 	str	r4, [fp, #-120]	; 0x78
   2a8b0:	e51b307c 	ldr	r3, [fp, #-124]	; 0x7c
   2a8b4:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	    if(((ix-0x3ff00000)|lx)==0) {	/* |x|==1 */
   2a8b8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   2a8bc:	e2833103 	add	r3, r3, #-1073741824	; 0xc0000000
   2a8c0:	e2833601 	add	r3, r3, #1048576	; 0x100000
   2a8c4:	e1a02003 	mov	r2, r3
   2a8c8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2a8cc:	e1823003 	orr	r3, r2, r3
   2a8d0:	e3530000 	cmp	r3, #0
   2a8d4:	1a00001a 	bne	2a944 <__ieee754_acos+0xec>
		if(hx>0) return 0.0;		/* acos(1) = 0  */
   2a8d8:	e51b3020 	ldr	r3, [fp, #-32]
   2a8dc:	e3530000 	cmp	r3, #0
   2a8e0:	da000002 	ble	2a8f0 <__ieee754_acos+0x98>
   2a8e4:	e3a03000 	mov	r3, #0
   2a8e8:	e3a04000 	mov	r4, #0
   2a8ec:	ea000380 	b	2b6f4 <__ieee754_acos+0xe9c>
		else return pi+2.0*pio2_lo;	/* acos(-1)= pi */
   2a8f0:	e28f4c01 	add	r4, pc, #256	; 0x100
   2a8f4:	e8940018 	ldm	r4, {r3, r4}
   2a8f8:	e1a00003 	mov	r0, r3
   2a8fc:	e1a01004 	mov	r1, r4
   2a900:	e1a02003 	mov	r2, r3
   2a904:	e1a03004 	mov	r3, r4
   2a908:	ebffa778 	bl	146f0 <__adddf3>
   2a90c:	e1a03000 	mov	r3, r0
   2a910:	e1a04001 	mov	r4, r1
   2a914:	e1a01003 	mov	r1, r3
   2a918:	e1a02004 	mov	r2, r4
   2a91c:	e28f40dc 	add	r4, pc, #220	; 0xdc
   2a920:	e8940018 	ldm	r4, {r3, r4}
   2a924:	e1a00001 	mov	r0, r1
   2a928:	e1a01002 	mov	r1, r2
   2a92c:	e1a02003 	mov	r2, r3
   2a930:	e1a03004 	mov	r3, r4
   2a934:	ebffa76d 	bl	146f0 <__adddf3>
   2a938:	e1a03000 	mov	r3, r0
   2a93c:	e1a04001 	mov	r4, r1
   2a940:	ea00036b 	b	2b6f4 <__ieee754_acos+0xe9c>
	    }
	    return (x-x)/(x-x);		/* acos(|x|>1) is NaN */
   2a944:	e24b108c 	sub	r1, fp, #140	; 0x8c
   2a948:	e8910003 	ldm	r1, {r0, r1}
   2a94c:	e24b308c 	sub	r3, fp, #140	; 0x8c
   2a950:	e893000c 	ldm	r3, {r2, r3}
   2a954:	ebffa764 	bl	146ec <__aeabi_dsub>
   2a958:	e1a03000 	mov	r3, r0
   2a95c:	e1a04001 	mov	r4, r1
   2a960:	e1a05003 	mov	r5, r3
   2a964:	e1a06004 	mov	r6, r4
   2a968:	e24b108c 	sub	r1, fp, #140	; 0x8c
   2a96c:	e8910003 	ldm	r1, {r0, r1}
   2a970:	e24b308c 	sub	r3, fp, #140	; 0x8c
   2a974:	e893000c 	ldm	r3, {r2, r3}
   2a978:	ebffa75b 	bl	146ec <__aeabi_dsub>
   2a97c:	e1a03000 	mov	r3, r0
   2a980:	e1a04001 	mov	r4, r1
   2a984:	e1a00005 	mov	r0, r5
   2a988:	e1a01006 	mov	r1, r6
   2a98c:	e1a02003 	mov	r2, r3
   2a990:	e1a03004 	mov	r3, r4
   2a994:	ebffa8fd 	bl	14d90 <__aeabi_ddiv>
   2a998:	e1a03000 	mov	r3, r0
   2a99c:	e1a04001 	mov	r4, r1
   2a9a0:	ea000353 	b	2b6f4 <__ieee754_acos+0xe9c>
	}
	if(ix<0x3fe00000) {	/* |x| < 0.5 */
   2a9a4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   2a9a8:	e59f3064 	ldr	r3, [pc, #100]	; 2aa14 <__ieee754_acos+0x1bc>
   2a9ac:	e1520003 	cmp	r2, r3
   2a9b0:	ca000118 	bgt	2ae18 <__ieee754_acos+0x5c0>
	    if(ix<=0x3c600000) return pio2_hi+pio2_lo;/*if|x|<2**-57*/
   2a9b4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   2a9b8:	e59f3058 	ldr	r3, [pc, #88]	; 2aa18 <__ieee754_acos+0x1c0>
   2a9bc:	e1520003 	cmp	r2, r3
   2a9c0:	ca000015 	bgt	2aa1c <__ieee754_acos+0x1c4>
   2a9c4:	e28f203c 	add	r2, pc, #60	; 0x3c
   2a9c8:	e8920006 	ldm	r2, {r1, r2}
   2a9cc:	e28f4024 	add	r4, pc, #36	; 0x24
   2a9d0:	e8940018 	ldm	r4, {r3, r4}
   2a9d4:	e1a00001 	mov	r0, r1
   2a9d8:	e1a01002 	mov	r1, r2
   2a9dc:	e1a02003 	mov	r2, r3
   2a9e0:	e1a03004 	mov	r3, r4
   2a9e4:	ebffa741 	bl	146f0 <__adddf3>
   2a9e8:	e1a03000 	mov	r3, r0
   2a9ec:	e1a04001 	mov	r4, r1
   2a9f0:	ea00033f 	b	2b6f4 <__ieee754_acos+0xe9c>
   2a9f4:	e1a00000 	nop			; (mov r0, r0)
   2a9f8:	33145c07 	.word	0x33145c07
   2a9fc:	3c91a626 	.word	0x3c91a626
   2aa00:	54442d18 	.word	0x54442d18
   2aa04:	400921fb 	.word	0x400921fb
   2aa08:	54442d18 	.word	0x54442d18
   2aa0c:	3ff921fb 	.word	0x3ff921fb
   2aa10:	3fefffff 	.word	0x3fefffff
   2aa14:	3fdfffff 	.word	0x3fdfffff
   2aa18:	3c600000 	.word	0x3c600000
	    z = x*x;
   2aa1c:	e24b108c 	sub	r1, fp, #140	; 0x8c
   2aa20:	e8910003 	ldm	r1, {r0, r1}
   2aa24:	e24b308c 	sub	r3, fp, #140	; 0x8c
   2aa28:	e893000c 	ldm	r3, {r2, r3}
   2aa2c:	ebffa833 	bl	14b00 <__aeabi_dmul>
   2aa30:	e1a03000 	mov	r3, r0
   2aa34:	e1a04001 	mov	r4, r1
   2aa38:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2aa3c:	e50b4030 	str	r4, [fp, #-48]	; 0x30
	    p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
   2aa40:	e28f4fda 	add	r4, pc, #872	; 0x368
   2aa44:	e8940018 	ldm	r4, {r3, r4}
   2aa48:	e1a00003 	mov	r0, r3
   2aa4c:	e1a01004 	mov	r1, r4
   2aa50:	e24b3034 	sub	r3, fp, #52	; 0x34
   2aa54:	e893000c 	ldm	r3, {r2, r3}
   2aa58:	ebffa828 	bl	14b00 <__aeabi_dmul>
   2aa5c:	e1a03000 	mov	r3, r0
   2aa60:	e1a04001 	mov	r4, r1
   2aa64:	e1a01003 	mov	r1, r3
   2aa68:	e1a02004 	mov	r2, r4
   2aa6c:	e28f4fd1 	add	r4, pc, #836	; 0x344
   2aa70:	e8940018 	ldm	r4, {r3, r4}
   2aa74:	e1a00001 	mov	r0, r1
   2aa78:	e1a01002 	mov	r1, r2
   2aa7c:	e1a02003 	mov	r2, r3
   2aa80:	e1a03004 	mov	r3, r4
   2aa84:	ebffa719 	bl	146f0 <__adddf3>
   2aa88:	e1a03000 	mov	r3, r0
   2aa8c:	e1a04001 	mov	r4, r1
   2aa90:	e1a00003 	mov	r0, r3
   2aa94:	e1a01004 	mov	r1, r4
   2aa98:	e24b3034 	sub	r3, fp, #52	; 0x34
   2aa9c:	e893000c 	ldm	r3, {r2, r3}
   2aaa0:	ebffa816 	bl	14b00 <__aeabi_dmul>
   2aaa4:	e1a03000 	mov	r3, r0
   2aaa8:	e1a04001 	mov	r4, r1
   2aaac:	e1a01003 	mov	r1, r3
   2aab0:	e1a02004 	mov	r2, r4
   2aab4:	e28f4fc1 	add	r4, pc, #772	; 0x304
   2aab8:	e8940018 	ldm	r4, {r3, r4}
   2aabc:	e1a00001 	mov	r0, r1
   2aac0:	e1a01002 	mov	r1, r2
   2aac4:	e1a02003 	mov	r2, r3
   2aac8:	e1a03004 	mov	r3, r4
   2aacc:	ebffa707 	bl	146f0 <__adddf3>
   2aad0:	e1a03000 	mov	r3, r0
   2aad4:	e1a04001 	mov	r4, r1
   2aad8:	e1a00003 	mov	r0, r3
   2aadc:	e1a01004 	mov	r1, r4
   2aae0:	e24b3034 	sub	r3, fp, #52	; 0x34
   2aae4:	e893000c 	ldm	r3, {r2, r3}
   2aae8:	ebffa804 	bl	14b00 <__aeabi_dmul>
   2aaec:	e1a03000 	mov	r3, r0
   2aaf0:	e1a04001 	mov	r4, r1
   2aaf4:	e1a01003 	mov	r1, r3
   2aaf8:	e1a02004 	mov	r2, r4
   2aafc:	e28f4fb1 	add	r4, pc, #708	; 0x2c4
   2ab00:	e8940018 	ldm	r4, {r3, r4}
   2ab04:	e1a00001 	mov	r0, r1
   2ab08:	e1a01002 	mov	r1, r2
   2ab0c:	e1a02003 	mov	r2, r3
   2ab10:	e1a03004 	mov	r3, r4
   2ab14:	ebffa6f5 	bl	146f0 <__adddf3>
   2ab18:	e1a03000 	mov	r3, r0
   2ab1c:	e1a04001 	mov	r4, r1
   2ab20:	e1a00003 	mov	r0, r3
   2ab24:	e1a01004 	mov	r1, r4
   2ab28:	e24b3034 	sub	r3, fp, #52	; 0x34
   2ab2c:	e893000c 	ldm	r3, {r2, r3}
   2ab30:	ebffa7f2 	bl	14b00 <__aeabi_dmul>
   2ab34:	e1a03000 	mov	r3, r0
   2ab38:	e1a04001 	mov	r4, r1
   2ab3c:	e1a01003 	mov	r1, r3
   2ab40:	e1a02004 	mov	r2, r4
   2ab44:	e28f4fa1 	add	r4, pc, #644	; 0x284
   2ab48:	e8940018 	ldm	r4, {r3, r4}
   2ab4c:	e1a00001 	mov	r0, r1
   2ab50:	e1a01002 	mov	r1, r2
   2ab54:	e1a02003 	mov	r2, r3
   2ab58:	e1a03004 	mov	r3, r4
   2ab5c:	ebffa6e3 	bl	146f0 <__adddf3>
   2ab60:	e1a03000 	mov	r3, r0
   2ab64:	e1a04001 	mov	r4, r1
   2ab68:	e1a00003 	mov	r0, r3
   2ab6c:	e1a01004 	mov	r1, r4
   2ab70:	e24b3034 	sub	r3, fp, #52	; 0x34
   2ab74:	e893000c 	ldm	r3, {r2, r3}
   2ab78:	ebffa7e0 	bl	14b00 <__aeabi_dmul>
   2ab7c:	e1a03000 	mov	r3, r0
   2ab80:	e1a04001 	mov	r4, r1
   2ab84:	e1a01003 	mov	r1, r3
   2ab88:	e1a02004 	mov	r2, r4
   2ab8c:	e28f4f91 	add	r4, pc, #580	; 0x244
   2ab90:	e8940018 	ldm	r4, {r3, r4}
   2ab94:	e1a00001 	mov	r0, r1
   2ab98:	e1a01002 	mov	r1, r2
   2ab9c:	e1a02003 	mov	r2, r3
   2aba0:	e1a03004 	mov	r3, r4
   2aba4:	ebffa6d1 	bl	146f0 <__adddf3>
   2aba8:	e1a03000 	mov	r3, r0
   2abac:	e1a04001 	mov	r4, r1
   2abb0:	e1a00003 	mov	r0, r3
   2abb4:	e1a01004 	mov	r1, r4
   2abb8:	e24b3034 	sub	r3, fp, #52	; 0x34
   2abbc:	e893000c 	ldm	r3, {r2, r3}
   2abc0:	ebffa7ce 	bl	14b00 <__aeabi_dmul>
   2abc4:	e1a03000 	mov	r3, r0
   2abc8:	e1a04001 	mov	r4, r1
   2abcc:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2abd0:	e50b4038 	str	r4, [fp, #-56]	; 0x38
	    q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
   2abd4:	e28f4f81 	add	r4, pc, #516	; 0x204
   2abd8:	e8940018 	ldm	r4, {r3, r4}
   2abdc:	e1a00003 	mov	r0, r3
   2abe0:	e1a01004 	mov	r1, r4
   2abe4:	e24b3034 	sub	r3, fp, #52	; 0x34
   2abe8:	e893000c 	ldm	r3, {r2, r3}
   2abec:	ebffa7c3 	bl	14b00 <__aeabi_dmul>
   2abf0:	e1a03000 	mov	r3, r0
   2abf4:	e1a04001 	mov	r4, r1
   2abf8:	e1a01003 	mov	r1, r3
   2abfc:	e1a02004 	mov	r2, r4
   2ac00:	e28f4e1e 	add	r4, pc, #480	; 0x1e0
   2ac04:	e8940018 	ldm	r4, {r3, r4}
   2ac08:	e1a00001 	mov	r0, r1
   2ac0c:	e1a01002 	mov	r1, r2
   2ac10:	e1a02003 	mov	r2, r3
   2ac14:	e1a03004 	mov	r3, r4
   2ac18:	ebffa6b4 	bl	146f0 <__adddf3>
   2ac1c:	e1a03000 	mov	r3, r0
   2ac20:	e1a04001 	mov	r4, r1
   2ac24:	e1a00003 	mov	r0, r3
   2ac28:	e1a01004 	mov	r1, r4
   2ac2c:	e24b3034 	sub	r3, fp, #52	; 0x34
   2ac30:	e893000c 	ldm	r3, {r2, r3}
   2ac34:	ebffa7b1 	bl	14b00 <__aeabi_dmul>
   2ac38:	e1a03000 	mov	r3, r0
   2ac3c:	e1a04001 	mov	r4, r1
   2ac40:	e1a01003 	mov	r1, r3
   2ac44:	e1a02004 	mov	r2, r4
   2ac48:	e28f4e1a 	add	r4, pc, #416	; 0x1a0
   2ac4c:	e8940018 	ldm	r4, {r3, r4}
   2ac50:	e1a00001 	mov	r0, r1
   2ac54:	e1a01002 	mov	r1, r2
   2ac58:	e1a02003 	mov	r2, r3
   2ac5c:	e1a03004 	mov	r3, r4
   2ac60:	ebffa6a2 	bl	146f0 <__adddf3>
   2ac64:	e1a03000 	mov	r3, r0
   2ac68:	e1a04001 	mov	r4, r1
   2ac6c:	e1a00003 	mov	r0, r3
   2ac70:	e1a01004 	mov	r1, r4
   2ac74:	e24b3034 	sub	r3, fp, #52	; 0x34
   2ac78:	e893000c 	ldm	r3, {r2, r3}
   2ac7c:	ebffa79f 	bl	14b00 <__aeabi_dmul>
   2ac80:	e1a03000 	mov	r3, r0
   2ac84:	e1a04001 	mov	r4, r1
   2ac88:	e1a01003 	mov	r1, r3
   2ac8c:	e1a02004 	mov	r2, r4
   2ac90:	e28f4e16 	add	r4, pc, #352	; 0x160
   2ac94:	e8940018 	ldm	r4, {r3, r4}
   2ac98:	e1a00001 	mov	r0, r1
   2ac9c:	e1a01002 	mov	r1, r2
   2aca0:	e1a02003 	mov	r2, r3
   2aca4:	e1a03004 	mov	r3, r4
   2aca8:	ebffa690 	bl	146f0 <__adddf3>
   2acac:	e1a03000 	mov	r3, r0
   2acb0:	e1a04001 	mov	r4, r1
   2acb4:	e1a00003 	mov	r0, r3
   2acb8:	e1a01004 	mov	r1, r4
   2acbc:	e24b3034 	sub	r3, fp, #52	; 0x34
   2acc0:	e893000c 	ldm	r3, {r2, r3}
   2acc4:	ebffa78d 	bl	14b00 <__aeabi_dmul>
   2acc8:	e1a03000 	mov	r3, r0
   2accc:	e1a04001 	mov	r4, r1
   2acd0:	e1a01003 	mov	r1, r3
   2acd4:	e1a02004 	mov	r2, r4
   2acd8:	e3a03000 	mov	r3, #0
   2acdc:	e59f412c 	ldr	r4, [pc, #300]	; 2ae10 <__ieee754_acos+0x5b8>
   2ace0:	e1a00001 	mov	r0, r1
   2ace4:	e1a01002 	mov	r1, r2
   2ace8:	e1a02003 	mov	r2, r3
   2acec:	e1a03004 	mov	r3, r4
   2acf0:	ebffa67e 	bl	146f0 <__adddf3>
   2acf4:	e1a03000 	mov	r3, r0
   2acf8:	e1a04001 	mov	r4, r1
   2acfc:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   2ad00:	e50b4040 	str	r4, [fp, #-64]	; 0x40
	    r = p/q;
   2ad04:	e24b103c 	sub	r1, fp, #60	; 0x3c
   2ad08:	e8910003 	ldm	r1, {r0, r1}
   2ad0c:	e24b3044 	sub	r3, fp, #68	; 0x44
   2ad10:	e893000c 	ldm	r3, {r2, r3}
   2ad14:	ebffa81d 	bl	14d90 <__aeabi_ddiv>
   2ad18:	e1a03000 	mov	r3, r0
   2ad1c:	e1a04001 	mov	r4, r1
   2ad20:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   2ad24:	e50b4048 	str	r4, [fp, #-72]	; 0x48
	    return pio2_hi - (x - (pio2_lo-x*r));
   2ad28:	e28f60d0 	add	r6, pc, #208	; 0xd0
   2ad2c:	e8960060 	ldm	r6, {r5, r6}
   2ad30:	e28f80d0 	add	r8, pc, #208	; 0xd0
   2ad34:	e8980180 	ldm	r8, {r7, r8}
   2ad38:	e24b108c 	sub	r1, fp, #140	; 0x8c
   2ad3c:	e8910003 	ldm	r1, {r0, r1}
   2ad40:	e24b304c 	sub	r3, fp, #76	; 0x4c
   2ad44:	e893000c 	ldm	r3, {r2, r3}
   2ad48:	ebffa76c 	bl	14b00 <__aeabi_dmul>
   2ad4c:	e1a03000 	mov	r3, r0
   2ad50:	e1a04001 	mov	r4, r1
   2ad54:	e1a00007 	mov	r0, r7
   2ad58:	e1a01008 	mov	r1, r8
   2ad5c:	e1a02003 	mov	r2, r3
   2ad60:	e1a03004 	mov	r3, r4
   2ad64:	ebffa660 	bl	146ec <__aeabi_dsub>
   2ad68:	e1a03000 	mov	r3, r0
   2ad6c:	e1a04001 	mov	r4, r1
   2ad70:	e24b108c 	sub	r1, fp, #140	; 0x8c
   2ad74:	e8910003 	ldm	r1, {r0, r1}
   2ad78:	e1a02003 	mov	r2, r3
   2ad7c:	e1a03004 	mov	r3, r4
   2ad80:	ebffa659 	bl	146ec <__aeabi_dsub>
   2ad84:	e1a03000 	mov	r3, r0
   2ad88:	e1a04001 	mov	r4, r1
   2ad8c:	e1a00005 	mov	r0, r5
   2ad90:	e1a01006 	mov	r1, r6
   2ad94:	e1a02003 	mov	r2, r3
   2ad98:	e1a03004 	mov	r3, r4
   2ad9c:	ebffa652 	bl	146ec <__aeabi_dsub>
   2ada0:	e1a03000 	mov	r3, r0
   2ada4:	e1a04001 	mov	r4, r1
   2ada8:	ea000251 	b	2b6f4 <__ieee754_acos+0xe9c>
   2adac:	e1a00000 	nop			; (mov r0, r0)
   2adb0:	0dfdf709 	.word	0x0dfdf709
   2adb4:	3f023de1 	.word	0x3f023de1
   2adb8:	7501b288 	.word	0x7501b288
   2adbc:	3f49efe0 	.word	0x3f49efe0
   2adc0:	b5688f3b 	.word	0xb5688f3b
   2adc4:	bfa48228 	.word	0xbfa48228
   2adc8:	0e884455 	.word	0x0e884455
   2adcc:	3fc9c155 	.word	0x3fc9c155
   2add0:	03eb6f7d 	.word	0x03eb6f7d
   2add4:	bfd4d612 	.word	0xbfd4d612
   2add8:	55555555 	.word	0x55555555
   2addc:	3fc55555 	.word	0x3fc55555
   2ade0:	b12e9282 	.word	0xb12e9282
   2ade4:	3fb3b8c5 	.word	0x3fb3b8c5
   2ade8:	1b8d0159 	.word	0x1b8d0159
   2adec:	bfe6066c 	.word	0xbfe6066c
   2adf0:	9c598ac8 	.word	0x9c598ac8
   2adf4:	40002ae5 	.word	0x40002ae5
   2adf8:	1c8a2d4b 	.word	0x1c8a2d4b
   2adfc:	c0033a27 	.word	0xc0033a27
   2ae00:	54442d18 	.word	0x54442d18
   2ae04:	3ff921fb 	.word	0x3ff921fb
   2ae08:	33145c07 	.word	0x33145c07
   2ae0c:	3c91a626 	.word	0x3c91a626
   2ae10:	3ff00000 	.word	0x3ff00000
   2ae14:	3fe00000 	.word	0x3fe00000
	} else  if (hx<0) {		/* x < -0.5 */
   2ae18:	e51b3020 	ldr	r3, [fp, #-32]
   2ae1c:	e3530000 	cmp	r3, #0
   2ae20:	aa000116 	bge	2b280 <__ieee754_acos+0xa28>
	    z = (one+x)*0.5;
   2ae24:	e3a03000 	mov	r3, #0
   2ae28:	e51f4020 	ldr	r4, [pc, #-32]	; 2ae10 <__ieee754_acos+0x5b8>
   2ae2c:	e1a00003 	mov	r0, r3
   2ae30:	e1a01004 	mov	r1, r4
   2ae34:	e24b308c 	sub	r3, fp, #140	; 0x8c
   2ae38:	e893000c 	ldm	r3, {r2, r3}
   2ae3c:	ebffa62b 	bl	146f0 <__adddf3>
   2ae40:	e1a03000 	mov	r3, r0
   2ae44:	e1a04001 	mov	r4, r1
   2ae48:	e1a00003 	mov	r0, r3
   2ae4c:	e1a01004 	mov	r1, r4
   2ae50:	e3a02000 	mov	r2, #0
   2ae54:	e51f3048 	ldr	r3, [pc, #-72]	; 2ae14 <__ieee754_acos+0x5bc>
   2ae58:	ebffa728 	bl	14b00 <__aeabi_dmul>
   2ae5c:	e1a03000 	mov	r3, r0
   2ae60:	e1a04001 	mov	r4, r1
   2ae64:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2ae68:	e50b4030 	str	r4, [fp, #-48]	; 0x30
	    p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
   2ae6c:	e28f4fe9 	add	r4, pc, #932	; 0x3a4
   2ae70:	e8940018 	ldm	r4, {r3, r4}
   2ae74:	e1a00003 	mov	r0, r3
   2ae78:	e1a01004 	mov	r1, r4
   2ae7c:	e24b3034 	sub	r3, fp, #52	; 0x34
   2ae80:	e893000c 	ldm	r3, {r2, r3}
   2ae84:	ebffa71d 	bl	14b00 <__aeabi_dmul>
   2ae88:	e1a03000 	mov	r3, r0
   2ae8c:	e1a04001 	mov	r4, r1
   2ae90:	e1a01003 	mov	r1, r3
   2ae94:	e1a02004 	mov	r2, r4
   2ae98:	e28f4d0e 	add	r4, pc, #896	; 0x380
   2ae9c:	e8940018 	ldm	r4, {r3, r4}
   2aea0:	e1a00001 	mov	r0, r1
   2aea4:	e1a01002 	mov	r1, r2
   2aea8:	e1a02003 	mov	r2, r3
   2aeac:	e1a03004 	mov	r3, r4
   2aeb0:	ebffa60e 	bl	146f0 <__adddf3>
   2aeb4:	e1a03000 	mov	r3, r0
   2aeb8:	e1a04001 	mov	r4, r1
   2aebc:	e1a00003 	mov	r0, r3
   2aec0:	e1a01004 	mov	r1, r4
   2aec4:	e24b3034 	sub	r3, fp, #52	; 0x34
   2aec8:	e893000c 	ldm	r3, {r2, r3}
   2aecc:	ebffa70b 	bl	14b00 <__aeabi_dmul>
   2aed0:	e1a03000 	mov	r3, r0
   2aed4:	e1a04001 	mov	r4, r1
   2aed8:	e1a01003 	mov	r1, r3
   2aedc:	e1a02004 	mov	r2, r4
   2aee0:	e28f4d0d 	add	r4, pc, #832	; 0x340
   2aee4:	e8940018 	ldm	r4, {r3, r4}
   2aee8:	e1a00001 	mov	r0, r1
   2aeec:	e1a01002 	mov	r1, r2
   2aef0:	e1a02003 	mov	r2, r3
   2aef4:	e1a03004 	mov	r3, r4
   2aef8:	ebffa5fc 	bl	146f0 <__adddf3>
   2aefc:	e1a03000 	mov	r3, r0
   2af00:	e1a04001 	mov	r4, r1
   2af04:	e1a00003 	mov	r0, r3
   2af08:	e1a01004 	mov	r1, r4
   2af0c:	e24b3034 	sub	r3, fp, #52	; 0x34
   2af10:	e893000c 	ldm	r3, {r2, r3}
   2af14:	ebffa6f9 	bl	14b00 <__aeabi_dmul>
   2af18:	e1a03000 	mov	r3, r0
   2af1c:	e1a04001 	mov	r4, r1
   2af20:	e1a01003 	mov	r1, r3
   2af24:	e1a02004 	mov	r2, r4
   2af28:	e28f4c03 	add	r4, pc, #768	; 0x300
   2af2c:	e8940018 	ldm	r4, {r3, r4}
   2af30:	e1a00001 	mov	r0, r1
   2af34:	e1a01002 	mov	r1, r2
   2af38:	e1a02003 	mov	r2, r3
   2af3c:	e1a03004 	mov	r3, r4
   2af40:	ebffa5ea 	bl	146f0 <__adddf3>
   2af44:	e1a03000 	mov	r3, r0
   2af48:	e1a04001 	mov	r4, r1
   2af4c:	e1a00003 	mov	r0, r3
   2af50:	e1a01004 	mov	r1, r4
   2af54:	e24b3034 	sub	r3, fp, #52	; 0x34
   2af58:	e893000c 	ldm	r3, {r2, r3}
   2af5c:	ebffa6e7 	bl	14b00 <__aeabi_dmul>
   2af60:	e1a03000 	mov	r3, r0
   2af64:	e1a04001 	mov	r4, r1
   2af68:	e1a01003 	mov	r1, r3
   2af6c:	e1a02004 	mov	r2, r4
   2af70:	e28f4d0b 	add	r4, pc, #704	; 0x2c0
   2af74:	e8940018 	ldm	r4, {r3, r4}
   2af78:	e1a00001 	mov	r0, r1
   2af7c:	e1a01002 	mov	r1, r2
   2af80:	e1a02003 	mov	r2, r3
   2af84:	e1a03004 	mov	r3, r4
   2af88:	ebffa5d8 	bl	146f0 <__adddf3>
   2af8c:	e1a03000 	mov	r3, r0
   2af90:	e1a04001 	mov	r4, r1
   2af94:	e1a00003 	mov	r0, r3
   2af98:	e1a01004 	mov	r1, r4
   2af9c:	e24b3034 	sub	r3, fp, #52	; 0x34
   2afa0:	e893000c 	ldm	r3, {r2, r3}
   2afa4:	ebffa6d5 	bl	14b00 <__aeabi_dmul>
   2afa8:	e1a03000 	mov	r3, r0
   2afac:	e1a04001 	mov	r4, r1
   2afb0:	e1a01003 	mov	r1, r3
   2afb4:	e1a02004 	mov	r2, r4
   2afb8:	e28f4d0a 	add	r4, pc, #640	; 0x280
   2afbc:	e8940018 	ldm	r4, {r3, r4}
   2afc0:	e1a00001 	mov	r0, r1
   2afc4:	e1a01002 	mov	r1, r2
   2afc8:	e1a02003 	mov	r2, r3
   2afcc:	e1a03004 	mov	r3, r4
   2afd0:	ebffa5c6 	bl	146f0 <__adddf3>
   2afd4:	e1a03000 	mov	r3, r0
   2afd8:	e1a04001 	mov	r4, r1
   2afdc:	e1a00003 	mov	r0, r3
   2afe0:	e1a01004 	mov	r1, r4
   2afe4:	e24b3034 	sub	r3, fp, #52	; 0x34
   2afe8:	e893000c 	ldm	r3, {r2, r3}
   2afec:	ebffa6c3 	bl	14b00 <__aeabi_dmul>
   2aff0:	e1a03000 	mov	r3, r0
   2aff4:	e1a04001 	mov	r4, r1
   2aff8:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2affc:	e50b4038 	str	r4, [fp, #-56]	; 0x38
	    q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
   2b000:	e28f4d09 	add	r4, pc, #576	; 0x240
   2b004:	e8940018 	ldm	r4, {r3, r4}
   2b008:	e1a00003 	mov	r0, r3
   2b00c:	e1a01004 	mov	r1, r4
   2b010:	e24b3034 	sub	r3, fp, #52	; 0x34
   2b014:	e893000c 	ldm	r3, {r2, r3}
   2b018:	ebffa6b8 	bl	14b00 <__aeabi_dmul>
   2b01c:	e1a03000 	mov	r3, r0
   2b020:	e1a04001 	mov	r4, r1
   2b024:	e1a01003 	mov	r1, r3
   2b028:	e1a02004 	mov	r2, r4
   2b02c:	e28f4f87 	add	r4, pc, #540	; 0x21c
   2b030:	e8940018 	ldm	r4, {r3, r4}
   2b034:	e1a00001 	mov	r0, r1
   2b038:	e1a01002 	mov	r1, r2
   2b03c:	e1a02003 	mov	r2, r3
   2b040:	e1a03004 	mov	r3, r4
   2b044:	ebffa5a9 	bl	146f0 <__adddf3>
   2b048:	e1a03000 	mov	r3, r0
   2b04c:	e1a04001 	mov	r4, r1
   2b050:	e1a00003 	mov	r0, r3
   2b054:	e1a01004 	mov	r1, r4
   2b058:	e24b3034 	sub	r3, fp, #52	; 0x34
   2b05c:	e893000c 	ldm	r3, {r2, r3}
   2b060:	ebffa6a6 	bl	14b00 <__aeabi_dmul>
   2b064:	e1a03000 	mov	r3, r0
   2b068:	e1a04001 	mov	r4, r1
   2b06c:	e1a01003 	mov	r1, r3
   2b070:	e1a02004 	mov	r2, r4
   2b074:	e28f4f77 	add	r4, pc, #476	; 0x1dc
   2b078:	e8940018 	ldm	r4, {r3, r4}
   2b07c:	e1a00001 	mov	r0, r1
   2b080:	e1a01002 	mov	r1, r2
   2b084:	e1a02003 	mov	r2, r3
   2b088:	e1a03004 	mov	r3, r4
   2b08c:	ebffa597 	bl	146f0 <__adddf3>
   2b090:	e1a03000 	mov	r3, r0
   2b094:	e1a04001 	mov	r4, r1
   2b098:	e1a00003 	mov	r0, r3
   2b09c:	e1a01004 	mov	r1, r4
   2b0a0:	e24b3034 	sub	r3, fp, #52	; 0x34
   2b0a4:	e893000c 	ldm	r3, {r2, r3}
   2b0a8:	ebffa694 	bl	14b00 <__aeabi_dmul>
   2b0ac:	e1a03000 	mov	r3, r0
   2b0b0:	e1a04001 	mov	r4, r1
   2b0b4:	e1a01003 	mov	r1, r3
   2b0b8:	e1a02004 	mov	r2, r4
   2b0bc:	e28f4f67 	add	r4, pc, #412	; 0x19c
   2b0c0:	e8940018 	ldm	r4, {r3, r4}
   2b0c4:	e1a00001 	mov	r0, r1
   2b0c8:	e1a01002 	mov	r1, r2
   2b0cc:	e1a02003 	mov	r2, r3
   2b0d0:	e1a03004 	mov	r3, r4
   2b0d4:	ebffa585 	bl	146f0 <__adddf3>
   2b0d8:	e1a03000 	mov	r3, r0
   2b0dc:	e1a04001 	mov	r4, r1
   2b0e0:	e1a00003 	mov	r0, r3
   2b0e4:	e1a01004 	mov	r1, r4
   2b0e8:	e24b3034 	sub	r3, fp, #52	; 0x34
   2b0ec:	e893000c 	ldm	r3, {r2, r3}
   2b0f0:	ebffa682 	bl	14b00 <__aeabi_dmul>
   2b0f4:	e1a03000 	mov	r3, r0
   2b0f8:	e1a04001 	mov	r4, r1
   2b0fc:	e1a01003 	mov	r1, r3
   2b100:	e1a02004 	mov	r2, r4
   2b104:	e3a03000 	mov	r3, #0
   2b108:	e59f4168 	ldr	r4, [pc, #360]	; 2b278 <__ieee754_acos+0xa20>
   2b10c:	e1a00001 	mov	r0, r1
   2b110:	e1a01002 	mov	r1, r2
   2b114:	e1a02003 	mov	r2, r3
   2b118:	e1a03004 	mov	r3, r4
   2b11c:	ebffa573 	bl	146f0 <__adddf3>
   2b120:	e1a03000 	mov	r3, r0
   2b124:	e1a04001 	mov	r4, r1
   2b128:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   2b12c:	e50b4040 	str	r4, [fp, #-64]	; 0x40
	    s = __ieee754_sqrt(z);
   2b130:	e24b1034 	sub	r1, fp, #52	; 0x34
   2b134:	e8910003 	ldm	r1, {r0, r1}
   2b138:	eb000e1e 	bl	2e9b8 <__ieee754_sqrt>
   2b13c:	e50b0054 	str	r0, [fp, #-84]	; 0x54
   2b140:	e50b1050 	str	r1, [fp, #-80]	; 0x50
	    r = p/q;
   2b144:	e24b103c 	sub	r1, fp, #60	; 0x3c
   2b148:	e8910003 	ldm	r1, {r0, r1}
   2b14c:	e24b3044 	sub	r3, fp, #68	; 0x44
   2b150:	e893000c 	ldm	r3, {r2, r3}
   2b154:	ebffa70d 	bl	14d90 <__aeabi_ddiv>
   2b158:	e1a03000 	mov	r3, r0
   2b15c:	e1a04001 	mov	r4, r1
   2b160:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   2b164:	e50b4048 	str	r4, [fp, #-72]	; 0x48
	    w = r*s-pio2_lo;
   2b168:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2b16c:	e8910003 	ldm	r1, {r0, r1}
   2b170:	e24b3054 	sub	r3, fp, #84	; 0x54
   2b174:	e893000c 	ldm	r3, {r2, r3}
   2b178:	ebffa660 	bl	14b00 <__aeabi_dmul>
   2b17c:	e1a03000 	mov	r3, r0
   2b180:	e1a04001 	mov	r4, r1
   2b184:	e1a01003 	mov	r1, r3
   2b188:	e1a02004 	mov	r2, r4
   2b18c:	e28f40d4 	add	r4, pc, #212	; 0xd4
   2b190:	e8940018 	ldm	r4, {r3, r4}
   2b194:	e1a00001 	mov	r0, r1
   2b198:	e1a01002 	mov	r1, r2
   2b19c:	e1a02003 	mov	r2, r3
   2b1a0:	e1a03004 	mov	r3, r4
   2b1a4:	ebffa550 	bl	146ec <__aeabi_dsub>
   2b1a8:	e1a03000 	mov	r3, r0
   2b1ac:	e1a04001 	mov	r4, r1
   2b1b0:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   2b1b4:	e50b4058 	str	r4, [fp, #-88]	; 0x58
	    return pi - 2.0*(s+w);
   2b1b8:	e28f60b0 	add	r6, pc, #176	; 0xb0
   2b1bc:	e8960060 	ldm	r6, {r5, r6}
   2b1c0:	e24b1054 	sub	r1, fp, #84	; 0x54
   2b1c4:	e8910003 	ldm	r1, {r0, r1}
   2b1c8:	e24b305c 	sub	r3, fp, #92	; 0x5c
   2b1cc:	e893000c 	ldm	r3, {r2, r3}
   2b1d0:	ebffa546 	bl	146f0 <__adddf3>
   2b1d4:	e1a03000 	mov	r3, r0
   2b1d8:	e1a04001 	mov	r4, r1
   2b1dc:	e1a00003 	mov	r0, r3
   2b1e0:	e1a01004 	mov	r1, r4
   2b1e4:	e1a02003 	mov	r2, r3
   2b1e8:	e1a03004 	mov	r3, r4
   2b1ec:	ebffa53f 	bl	146f0 <__adddf3>
   2b1f0:	e1a03000 	mov	r3, r0
   2b1f4:	e1a04001 	mov	r4, r1
   2b1f8:	e1a00005 	mov	r0, r5
   2b1fc:	e1a01006 	mov	r1, r6
   2b200:	e1a02003 	mov	r2, r3
   2b204:	e1a03004 	mov	r3, r4
   2b208:	ebffa537 	bl	146ec <__aeabi_dsub>
   2b20c:	e1a03000 	mov	r3, r0
   2b210:	e1a04001 	mov	r4, r1
   2b214:	ea000136 	b	2b6f4 <__ieee754_acos+0xe9c>
   2b218:	0dfdf709 	.word	0x0dfdf709
   2b21c:	3f023de1 	.word	0x3f023de1
   2b220:	7501b288 	.word	0x7501b288
   2b224:	3f49efe0 	.word	0x3f49efe0
   2b228:	b5688f3b 	.word	0xb5688f3b
   2b22c:	bfa48228 	.word	0xbfa48228
   2b230:	0e884455 	.word	0x0e884455
   2b234:	3fc9c155 	.word	0x3fc9c155
   2b238:	03eb6f7d 	.word	0x03eb6f7d
   2b23c:	bfd4d612 	.word	0xbfd4d612
   2b240:	55555555 	.word	0x55555555
   2b244:	3fc55555 	.word	0x3fc55555
   2b248:	b12e9282 	.word	0xb12e9282
   2b24c:	3fb3b8c5 	.word	0x3fb3b8c5
   2b250:	1b8d0159 	.word	0x1b8d0159
   2b254:	bfe6066c 	.word	0xbfe6066c
   2b258:	9c598ac8 	.word	0x9c598ac8
   2b25c:	40002ae5 	.word	0x40002ae5
   2b260:	1c8a2d4b 	.word	0x1c8a2d4b
   2b264:	c0033a27 	.word	0xc0033a27
   2b268:	33145c07 	.word	0x33145c07
   2b26c:	3c91a626 	.word	0x3c91a626
   2b270:	54442d18 	.word	0x54442d18
   2b274:	400921fb 	.word	0x400921fb
   2b278:	3ff00000 	.word	0x3ff00000
   2b27c:	3fe00000 	.word	0x3fe00000
	} else {			/* x > 0.5 */
	    z = (one-x)*0.5;
   2b280:	e3a03000 	mov	r3, #0
   2b284:	e51f4014 	ldr	r4, [pc, #-20]	; 2b278 <__ieee754_acos+0xa20>
   2b288:	e1a00003 	mov	r0, r3
   2b28c:	e1a01004 	mov	r1, r4
   2b290:	e24b308c 	sub	r3, fp, #140	; 0x8c
   2b294:	e893000c 	ldm	r3, {r2, r3}
   2b298:	ebffa513 	bl	146ec <__aeabi_dsub>
   2b29c:	e1a03000 	mov	r3, r0
   2b2a0:	e1a04001 	mov	r4, r1
   2b2a4:	e1a00003 	mov	r0, r3
   2b2a8:	e1a01004 	mov	r1, r4
   2b2ac:	e3a02000 	mov	r2, #0
   2b2b0:	e51f303c 	ldr	r3, [pc, #-60]	; 2b27c <__ieee754_acos+0xa24>
   2b2b4:	ebffa611 	bl	14b00 <__aeabi_dmul>
   2b2b8:	e1a03000 	mov	r3, r0
   2b2bc:	e1a04001 	mov	r4, r1
   2b2c0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2b2c4:	e50b4030 	str	r4, [fp, #-48]	; 0x30
	    s = __ieee754_sqrt(z);
   2b2c8:	e24b1034 	sub	r1, fp, #52	; 0x34
   2b2cc:	e8910003 	ldm	r1, {r0, r1}
   2b2d0:	eb000db8 	bl	2e9b8 <__ieee754_sqrt>
   2b2d4:	e50b0054 	str	r0, [fp, #-84]	; 0x54
   2b2d8:	e50b1050 	str	r1, [fp, #-80]	; 0x50
	    df = s;
   2b2dc:	e24b4054 	sub	r4, fp, #84	; 0x54
   2b2e0:	e8940018 	ldm	r4, {r3, r4}
   2b2e4:	e50b3064 	str	r3, [fp, #-100]	; 0x64
   2b2e8:	e50b4060 	str	r4, [fp, #-96]	; 0x60
	    SET_LOW_WORD(df,0);
   2b2ec:	e24b4064 	sub	r4, fp, #100	; 0x64
   2b2f0:	e8940018 	ldm	r4, {r3, r4}
   2b2f4:	e50b3084 	str	r3, [fp, #-132]	; 0x84
   2b2f8:	e50b4080 	str	r4, [fp, #-128]	; 0x80
   2b2fc:	e3a03000 	mov	r3, #0
   2b300:	e50b3084 	str	r3, [fp, #-132]	; 0x84
   2b304:	e24b4084 	sub	r4, fp, #132	; 0x84
   2b308:	e8940018 	ldm	r4, {r3, r4}
   2b30c:	e50b3064 	str	r3, [fp, #-100]	; 0x64
   2b310:	e50b4060 	str	r4, [fp, #-96]	; 0x60
	    c  = (z-df*df)/(s+df);
   2b314:	e24b1064 	sub	r1, fp, #100	; 0x64
   2b318:	e8910003 	ldm	r1, {r0, r1}
   2b31c:	e24b3064 	sub	r3, fp, #100	; 0x64
   2b320:	e893000c 	ldm	r3, {r2, r3}
   2b324:	ebffa5f5 	bl	14b00 <__aeabi_dmul>
   2b328:	e1a03000 	mov	r3, r0
   2b32c:	e1a04001 	mov	r4, r1
   2b330:	e24b1034 	sub	r1, fp, #52	; 0x34
   2b334:	e8910003 	ldm	r1, {r0, r1}
   2b338:	e1a02003 	mov	r2, r3
   2b33c:	e1a03004 	mov	r3, r4
   2b340:	ebffa4e9 	bl	146ec <__aeabi_dsub>
   2b344:	e1a03000 	mov	r3, r0
   2b348:	e1a04001 	mov	r4, r1
   2b34c:	e1a05003 	mov	r5, r3
   2b350:	e1a06004 	mov	r6, r4
   2b354:	e24b1054 	sub	r1, fp, #84	; 0x54
   2b358:	e8910003 	ldm	r1, {r0, r1}
   2b35c:	e24b3064 	sub	r3, fp, #100	; 0x64
   2b360:	e893000c 	ldm	r3, {r2, r3}
   2b364:	ebffa4e1 	bl	146f0 <__adddf3>
   2b368:	e1a03000 	mov	r3, r0
   2b36c:	e1a04001 	mov	r4, r1
   2b370:	e1a00005 	mov	r0, r5
   2b374:	e1a01006 	mov	r1, r6
   2b378:	e1a02003 	mov	r2, r3
   2b37c:	e1a03004 	mov	r3, r4
   2b380:	ebffa682 	bl	14d90 <__aeabi_ddiv>
   2b384:	e1a03000 	mov	r3, r0
   2b388:	e1a04001 	mov	r4, r1
   2b38c:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   2b390:	e50b4068 	str	r4, [fp, #-104]	; 0x68
	    p = z*(pS0+z*(pS1+z*(pS2+z*(pS3+z*(pS4+z*pS5)))));
   2b394:	e28f4fdb 	add	r4, pc, #876	; 0x36c
   2b398:	e8940018 	ldm	r4, {r3, r4}
   2b39c:	e1a00003 	mov	r0, r3
   2b3a0:	e1a01004 	mov	r1, r4
   2b3a4:	e24b3034 	sub	r3, fp, #52	; 0x34
   2b3a8:	e893000c 	ldm	r3, {r2, r3}
   2b3ac:	ebffa5d3 	bl	14b00 <__aeabi_dmul>
   2b3b0:	e1a03000 	mov	r3, r0
   2b3b4:	e1a04001 	mov	r4, r1
   2b3b8:	e1a01003 	mov	r1, r3
   2b3bc:	e1a02004 	mov	r2, r4
   2b3c0:	e28f4fd2 	add	r4, pc, #840	; 0x348
   2b3c4:	e8940018 	ldm	r4, {r3, r4}
   2b3c8:	e1a00001 	mov	r0, r1
   2b3cc:	e1a01002 	mov	r1, r2
   2b3d0:	e1a02003 	mov	r2, r3
   2b3d4:	e1a03004 	mov	r3, r4
   2b3d8:	ebffa4c4 	bl	146f0 <__adddf3>
   2b3dc:	e1a03000 	mov	r3, r0
   2b3e0:	e1a04001 	mov	r4, r1
   2b3e4:	e1a00003 	mov	r0, r3
   2b3e8:	e1a01004 	mov	r1, r4
   2b3ec:	e24b3034 	sub	r3, fp, #52	; 0x34
   2b3f0:	e893000c 	ldm	r3, {r2, r3}
   2b3f4:	ebffa5c1 	bl	14b00 <__aeabi_dmul>
   2b3f8:	e1a03000 	mov	r3, r0
   2b3fc:	e1a04001 	mov	r4, r1
   2b400:	e1a01003 	mov	r1, r3
   2b404:	e1a02004 	mov	r2, r4
   2b408:	e28f4fc2 	add	r4, pc, #776	; 0x308
   2b40c:	e8940018 	ldm	r4, {r3, r4}
   2b410:	e1a00001 	mov	r0, r1
   2b414:	e1a01002 	mov	r1, r2
   2b418:	e1a02003 	mov	r2, r3
   2b41c:	e1a03004 	mov	r3, r4
   2b420:	ebffa4b2 	bl	146f0 <__adddf3>
   2b424:	e1a03000 	mov	r3, r0
   2b428:	e1a04001 	mov	r4, r1
   2b42c:	e1a00003 	mov	r0, r3
   2b430:	e1a01004 	mov	r1, r4
   2b434:	e24b3034 	sub	r3, fp, #52	; 0x34
   2b438:	e893000c 	ldm	r3, {r2, r3}
   2b43c:	ebffa5af 	bl	14b00 <__aeabi_dmul>
   2b440:	e1a03000 	mov	r3, r0
   2b444:	e1a04001 	mov	r4, r1
   2b448:	e1a01003 	mov	r1, r3
   2b44c:	e1a02004 	mov	r2, r4
   2b450:	e28f4fb2 	add	r4, pc, #712	; 0x2c8
   2b454:	e8940018 	ldm	r4, {r3, r4}
   2b458:	e1a00001 	mov	r0, r1
   2b45c:	e1a01002 	mov	r1, r2
   2b460:	e1a02003 	mov	r2, r3
   2b464:	e1a03004 	mov	r3, r4
   2b468:	ebffa4a0 	bl	146f0 <__adddf3>
   2b46c:	e1a03000 	mov	r3, r0
   2b470:	e1a04001 	mov	r4, r1
   2b474:	e1a00003 	mov	r0, r3
   2b478:	e1a01004 	mov	r1, r4
   2b47c:	e24b3034 	sub	r3, fp, #52	; 0x34
   2b480:	e893000c 	ldm	r3, {r2, r3}
   2b484:	ebffa59d 	bl	14b00 <__aeabi_dmul>
   2b488:	e1a03000 	mov	r3, r0
   2b48c:	e1a04001 	mov	r4, r1
   2b490:	e1a01003 	mov	r1, r3
   2b494:	e1a02004 	mov	r2, r4
   2b498:	e28f4fa2 	add	r4, pc, #648	; 0x288
   2b49c:	e8940018 	ldm	r4, {r3, r4}
   2b4a0:	e1a00001 	mov	r0, r1
   2b4a4:	e1a01002 	mov	r1, r2
   2b4a8:	e1a02003 	mov	r2, r3
   2b4ac:	e1a03004 	mov	r3, r4
   2b4b0:	ebffa48e 	bl	146f0 <__adddf3>
   2b4b4:	e1a03000 	mov	r3, r0
   2b4b8:	e1a04001 	mov	r4, r1
   2b4bc:	e1a00003 	mov	r0, r3
   2b4c0:	e1a01004 	mov	r1, r4
   2b4c4:	e24b3034 	sub	r3, fp, #52	; 0x34
   2b4c8:	e893000c 	ldm	r3, {r2, r3}
   2b4cc:	ebffa58b 	bl	14b00 <__aeabi_dmul>
   2b4d0:	e1a03000 	mov	r3, r0
   2b4d4:	e1a04001 	mov	r4, r1
   2b4d8:	e1a01003 	mov	r1, r3
   2b4dc:	e1a02004 	mov	r2, r4
   2b4e0:	e28f4f92 	add	r4, pc, #584	; 0x248
   2b4e4:	e8940018 	ldm	r4, {r3, r4}
   2b4e8:	e1a00001 	mov	r0, r1
   2b4ec:	e1a01002 	mov	r1, r2
   2b4f0:	e1a02003 	mov	r2, r3
   2b4f4:	e1a03004 	mov	r3, r4
   2b4f8:	ebffa47c 	bl	146f0 <__adddf3>
   2b4fc:	e1a03000 	mov	r3, r0
   2b500:	e1a04001 	mov	r4, r1
   2b504:	e1a00003 	mov	r0, r3
   2b508:	e1a01004 	mov	r1, r4
   2b50c:	e24b3034 	sub	r3, fp, #52	; 0x34
   2b510:	e893000c 	ldm	r3, {r2, r3}
   2b514:	ebffa579 	bl	14b00 <__aeabi_dmul>
   2b518:	e1a03000 	mov	r3, r0
   2b51c:	e1a04001 	mov	r4, r1
   2b520:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2b524:	e50b4038 	str	r4, [fp, #-56]	; 0x38
	    q = one+z*(qS1+z*(qS2+z*(qS3+z*qS4)));
   2b528:	e28f4f82 	add	r4, pc, #520	; 0x208
   2b52c:	e8940018 	ldm	r4, {r3, r4}
   2b530:	e1a00003 	mov	r0, r3
   2b534:	e1a01004 	mov	r1, r4
   2b538:	e24b3034 	sub	r3, fp, #52	; 0x34
   2b53c:	e893000c 	ldm	r3, {r2, r3}
   2b540:	ebffa56e 	bl	14b00 <__aeabi_dmul>
   2b544:	e1a03000 	mov	r3, r0
   2b548:	e1a04001 	mov	r4, r1
   2b54c:	e1a01003 	mov	r1, r3
   2b550:	e1a02004 	mov	r2, r4
   2b554:	e28f4f79 	add	r4, pc, #484	; 0x1e4
   2b558:	e8940018 	ldm	r4, {r3, r4}
   2b55c:	e1a00001 	mov	r0, r1
   2b560:	e1a01002 	mov	r1, r2
   2b564:	e1a02003 	mov	r2, r3
   2b568:	e1a03004 	mov	r3, r4
   2b56c:	ebffa45f 	bl	146f0 <__adddf3>
   2b570:	e1a03000 	mov	r3, r0
   2b574:	e1a04001 	mov	r4, r1
   2b578:	e1a00003 	mov	r0, r3
   2b57c:	e1a01004 	mov	r1, r4
   2b580:	e24b3034 	sub	r3, fp, #52	; 0x34
   2b584:	e893000c 	ldm	r3, {r2, r3}
   2b588:	ebffa55c 	bl	14b00 <__aeabi_dmul>
   2b58c:	e1a03000 	mov	r3, r0
   2b590:	e1a04001 	mov	r4, r1
   2b594:	e1a01003 	mov	r1, r3
   2b598:	e1a02004 	mov	r2, r4
   2b59c:	e28f4f69 	add	r4, pc, #420	; 0x1a4
   2b5a0:	e8940018 	ldm	r4, {r3, r4}
   2b5a4:	e1a00001 	mov	r0, r1
   2b5a8:	e1a01002 	mov	r1, r2
   2b5ac:	e1a02003 	mov	r2, r3
   2b5b0:	e1a03004 	mov	r3, r4
   2b5b4:	ebffa44d 	bl	146f0 <__adddf3>
   2b5b8:	e1a03000 	mov	r3, r0
   2b5bc:	e1a04001 	mov	r4, r1
   2b5c0:	e1a00003 	mov	r0, r3
   2b5c4:	e1a01004 	mov	r1, r4
   2b5c8:	e24b3034 	sub	r3, fp, #52	; 0x34
   2b5cc:	e893000c 	ldm	r3, {r2, r3}
   2b5d0:	ebffa54a 	bl	14b00 <__aeabi_dmul>
   2b5d4:	e1a03000 	mov	r3, r0
   2b5d8:	e1a04001 	mov	r4, r1
   2b5dc:	e1a01003 	mov	r1, r3
   2b5e0:	e1a02004 	mov	r2, r4
   2b5e4:	e28f4f59 	add	r4, pc, #356	; 0x164
   2b5e8:	e8940018 	ldm	r4, {r3, r4}
   2b5ec:	e1a00001 	mov	r0, r1
   2b5f0:	e1a01002 	mov	r1, r2
   2b5f4:	e1a02003 	mov	r2, r3
   2b5f8:	e1a03004 	mov	r3, r4
   2b5fc:	ebffa43b 	bl	146f0 <__adddf3>
   2b600:	e1a03000 	mov	r3, r0
   2b604:	e1a04001 	mov	r4, r1
   2b608:	e1a00003 	mov	r0, r3
   2b60c:	e1a01004 	mov	r1, r4
   2b610:	e24b3034 	sub	r3, fp, #52	; 0x34
   2b614:	e893000c 	ldm	r3, {r2, r3}
   2b618:	ebffa538 	bl	14b00 <__aeabi_dmul>
   2b61c:	e1a03000 	mov	r3, r0
   2b620:	e1a04001 	mov	r4, r1
   2b624:	e1a01003 	mov	r1, r3
   2b628:	e1a02004 	mov	r2, r4
   2b62c:	e3a03000 	mov	r3, #0
   2b630:	e59f4120 	ldr	r4, [pc, #288]	; 2b758 <__ieee754_acos+0xf00>
   2b634:	e1a00001 	mov	r0, r1
   2b638:	e1a01002 	mov	r1, r2
   2b63c:	e1a02003 	mov	r2, r3
   2b640:	e1a03004 	mov	r3, r4
   2b644:	ebffa429 	bl	146f0 <__adddf3>
   2b648:	e1a03000 	mov	r3, r0
   2b64c:	e1a04001 	mov	r4, r1
   2b650:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   2b654:	e50b4040 	str	r4, [fp, #-64]	; 0x40
	    r = p/q;
   2b658:	e24b103c 	sub	r1, fp, #60	; 0x3c
   2b65c:	e8910003 	ldm	r1, {r0, r1}
   2b660:	e24b3044 	sub	r3, fp, #68	; 0x44
   2b664:	e893000c 	ldm	r3, {r2, r3}
   2b668:	ebffa5c8 	bl	14d90 <__aeabi_ddiv>
   2b66c:	e1a03000 	mov	r3, r0
   2b670:	e1a04001 	mov	r4, r1
   2b674:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   2b678:	e50b4048 	str	r4, [fp, #-72]	; 0x48
	    w = r*s+c;
   2b67c:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2b680:	e8910003 	ldm	r1, {r0, r1}
   2b684:	e24b3054 	sub	r3, fp, #84	; 0x54
   2b688:	e893000c 	ldm	r3, {r2, r3}
   2b68c:	ebffa51b 	bl	14b00 <__aeabi_dmul>
   2b690:	e1a03000 	mov	r3, r0
   2b694:	e1a04001 	mov	r4, r1
   2b698:	e1a00003 	mov	r0, r3
   2b69c:	e1a01004 	mov	r1, r4
   2b6a0:	e24b306c 	sub	r3, fp, #108	; 0x6c
   2b6a4:	e893000c 	ldm	r3, {r2, r3}
   2b6a8:	ebffa410 	bl	146f0 <__adddf3>
   2b6ac:	e1a03000 	mov	r3, r0
   2b6b0:	e1a04001 	mov	r4, r1
   2b6b4:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   2b6b8:	e50b4058 	str	r4, [fp, #-88]	; 0x58
	    return 2.0*(df+w);
   2b6bc:	e24b1064 	sub	r1, fp, #100	; 0x64
   2b6c0:	e8910003 	ldm	r1, {r0, r1}
   2b6c4:	e24b305c 	sub	r3, fp, #92	; 0x5c
   2b6c8:	e893000c 	ldm	r3, {r2, r3}
   2b6cc:	ebffa407 	bl	146f0 <__adddf3>
   2b6d0:	e1a03000 	mov	r3, r0
   2b6d4:	e1a04001 	mov	r4, r1
   2b6d8:	e1a00003 	mov	r0, r3
   2b6dc:	e1a01004 	mov	r1, r4
   2b6e0:	e1a02003 	mov	r2, r3
   2b6e4:	e1a03004 	mov	r3, r4
   2b6e8:	ebffa400 	bl	146f0 <__adddf3>
   2b6ec:	e1a03000 	mov	r3, r0
   2b6f0:	e1a04001 	mov	r4, r1
	}
}
   2b6f4:	e1a00003 	mov	r0, r3
   2b6f8:	e1a01004 	mov	r1, r4
   2b6fc:	e24bd018 	sub	sp, fp, #24
   2b700:	e8bd49f0 	pop	{r4, r5, r6, r7, r8, fp, lr}
   2b704:	e12fff1e 	bx	lr
   2b708:	0dfdf709 	.word	0x0dfdf709
   2b70c:	3f023de1 	.word	0x3f023de1
   2b710:	7501b288 	.word	0x7501b288
   2b714:	3f49efe0 	.word	0x3f49efe0
   2b718:	b5688f3b 	.word	0xb5688f3b
   2b71c:	bfa48228 	.word	0xbfa48228
   2b720:	0e884455 	.word	0x0e884455
   2b724:	3fc9c155 	.word	0x3fc9c155
   2b728:	03eb6f7d 	.word	0x03eb6f7d
   2b72c:	bfd4d612 	.word	0xbfd4d612
   2b730:	55555555 	.word	0x55555555
   2b734:	3fc55555 	.word	0x3fc55555
   2b738:	b12e9282 	.word	0xb12e9282
   2b73c:	3fb3b8c5 	.word	0x3fb3b8c5
   2b740:	1b8d0159 	.word	0x1b8d0159
   2b744:	bfe6066c 	.word	0xbfe6066c
   2b748:	9c598ac8 	.word	0x9c598ac8
   2b74c:	40002ae5 	.word	0x40002ae5
   2b750:	1c8a2d4b 	.word	0x1c8a2d4b
   2b754:	c0033a27 	.word	0xc0033a27
   2b758:	3ff00000 	.word	0x3ff00000
   2b75c:	e1a00000 	nop			; (mov r0, r0)

0002b760 <__ieee754_exp>:
	double __ieee754_exp(double x)	/* default IEEE double exp */
#else
	double __ieee754_exp(x)	/* default IEEE double exp */
	double x;
#endif
{
   2b760:	e92d49f0 	push	{r4, r5, r6, r7, r8, fp, lr}
   2b764:	e28db018 	add	fp, sp, #24
   2b768:	e24dd07c 	sub	sp, sp, #124	; 0x7c
   2b76c:	e50b0094 	str	r0, [fp, #-148]	; 0x94
   2b770:	e50b1090 	str	r1, [fp, #-144]	; 0x90
	double y,hi,lo,c,t;
	__int32_t k = 0,xsb;
   2b774:	e3a03000 	mov	r3, #0
   2b778:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	__uint32_t hx;

	GET_HIGH_WORD(hx,x);
   2b77c:	e24b4094 	sub	r4, fp, #148	; 0x94
   2b780:	e8940018 	ldm	r4, {r3, r4}
   2b784:	e50b3064 	str	r3, [fp, #-100]	; 0x64
   2b788:	e50b4060 	str	r4, [fp, #-96]	; 0x60
   2b78c:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   2b790:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	xsb = (hx>>31)&1;		/* sign bit of x */
   2b794:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2b798:	e1a03fa3 	lsr	r3, r3, #31
   2b79c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	hx &= 0x7fffffff;		/* high word of |x| */
   2b7a0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2b7a4:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   2b7a8:	e50b3034 	str	r3, [fp, #-52]	; 0x34

    /* filter out non-finite argument */
	if(hx >= 0x40862E42) {			/* if |x|>=709.78... */
   2b7ac:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   2b7b0:	e59f33b8 	ldr	r3, [pc, #952]	; 2bb70 <__ieee754_exp+0x410>
   2b7b4:	e1520003 	cmp	r2, r3
   2b7b8:	9a00004f 	bls	2b8fc <__ieee754_exp+0x19c>
            if(hx>=0x7ff00000) {
   2b7bc:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   2b7c0:	e59f33ac 	ldr	r3, [pc, #940]	; 2bb74 <__ieee754_exp+0x414>
   2b7c4:	e1520003 	cmp	r2, r3
   2b7c8:	9a00001f 	bls	2b84c <__ieee754_exp+0xec>
	        __uint32_t lx;
		GET_LOW_WORD(lx,x);
   2b7cc:	e24b4094 	sub	r4, fp, #148	; 0x94
   2b7d0:	e8940018 	ldm	r4, {r3, r4}
   2b7d4:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   2b7d8:	e50b4068 	str	r4, [fp, #-104]	; 0x68
   2b7dc:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   2b7e0:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
		if(((hx&0xfffff)|lx)!=0) 
   2b7e4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2b7e8:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
   2b7ec:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   2b7f0:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   2b7f4:	e1833002 	orr	r3, r3, r2
   2b7f8:	e3530000 	cmp	r3, #0
   2b7fc:	0a000009 	beq	2b828 <__ieee754_exp+0xc8>
		     return x+x; 		/* NaN */
   2b800:	e24b4094 	sub	r4, fp, #148	; 0x94
   2b804:	e8940018 	ldm	r4, {r3, r4}
   2b808:	e1a00003 	mov	r0, r3
   2b80c:	e1a01004 	mov	r1, r4
   2b810:	e1a02003 	mov	r2, r3
   2b814:	e1a03004 	mov	r3, r4
   2b818:	ebffa3b4 	bl	146f0 <__adddf3>
   2b81c:	e1a03000 	mov	r3, r0
   2b820:	e1a04001 	mov	r4, r1
   2b824:	ea0001d1 	b	2bf70 <__ieee754_exp+0x810>
		else return (xsb==0)? x:0.0;	/* exp(+-inf)={inf,0} */
   2b828:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2b82c:	e3530000 	cmp	r3, #0
   2b830:	1a000002 	bne	2b840 <__ieee754_exp+0xe0>
   2b834:	e24b4094 	sub	r4, fp, #148	; 0x94
   2b838:	e8940018 	ldm	r4, {r3, r4}
   2b83c:	ea0001cb 	b	2bf70 <__ieee754_exp+0x810>
   2b840:	e3a03000 	mov	r3, #0
   2b844:	e3a04000 	mov	r4, #0
   2b848:	ea0001c8 	b	2bf70 <__ieee754_exp+0x810>
	    }
	    if(x > o_threshold) return huge*huge; /* overflow */
   2b84c:	e28f4fbb 	add	r4, pc, #748	; 0x2ec
   2b850:	e8940018 	ldm	r4, {r3, r4}
   2b854:	e24b1094 	sub	r1, fp, #148	; 0x94
   2b858:	e8910003 	ldm	r1, {r0, r1}
   2b85c:	e1a02003 	mov	r2, r3
   2b860:	e1a03004 	mov	r3, r4
   2b864:	ebffa617 	bl	150c8 <__aeabi_dcmpgt>
   2b868:	e1a03000 	mov	r3, r0
   2b86c:	e3530000 	cmp	r3, #0
   2b870:	0a00000b 	beq	2b8a4 <__ieee754_exp+0x144>
   2b874:	e28f2fb3 	add	r2, pc, #716	; 0x2cc
   2b878:	e8920006 	ldm	r2, {r1, r2}
   2b87c:	e28f4fb1 	add	r4, pc, #708	; 0x2c4
   2b880:	e8940018 	ldm	r4, {r3, r4}
   2b884:	e1a00001 	mov	r0, r1
   2b888:	e1a01002 	mov	r1, r2
   2b88c:	e1a02003 	mov	r2, r3
   2b890:	e1a03004 	mov	r3, r4
   2b894:	ebffa499 	bl	14b00 <__aeabi_dmul>
   2b898:	e1a03000 	mov	r3, r0
   2b89c:	e1a04001 	mov	r4, r1
   2b8a0:	ea0001b2 	b	2bf70 <__ieee754_exp+0x810>
	    if(x < u_threshold) return twom1000*twom1000; /* underflow */
   2b8a4:	e28f4fa9 	add	r4, pc, #676	; 0x2a4
   2b8a8:	e8940018 	ldm	r4, {r3, r4}
   2b8ac:	e24b1094 	sub	r1, fp, #148	; 0x94
   2b8b0:	e8910003 	ldm	r1, {r0, r1}
   2b8b4:	e1a02003 	mov	r2, r3
   2b8b8:	e1a03004 	mov	r3, r4
   2b8bc:	ebffa5ef 	bl	15080 <__aeabi_dcmplt>
   2b8c0:	e1a03000 	mov	r3, r0
   2b8c4:	e3530000 	cmp	r3, #0
   2b8c8:	0a00000b 	beq	2b8fc <__ieee754_exp+0x19c>
   2b8cc:	e3a01000 	mov	r1, #0
   2b8d0:	e3a02617 	mov	r2, #24117248	; 0x1700000
   2b8d4:	e3a03000 	mov	r3, #0
   2b8d8:	e3a04617 	mov	r4, #24117248	; 0x1700000
   2b8dc:	e1a00001 	mov	r0, r1
   2b8e0:	e1a01002 	mov	r1, r2
   2b8e4:	e1a02003 	mov	r2, r3
   2b8e8:	e1a03004 	mov	r3, r4
   2b8ec:	ebffa483 	bl	14b00 <__aeabi_dmul>
   2b8f0:	e1a03000 	mov	r3, r0
   2b8f4:	e1a04001 	mov	r4, r1
   2b8f8:	ea00019c 	b	2bf70 <__ieee754_exp+0x810>
	}

    /* argument reduction */
	if(hx > 0x3fd62e42) {		/* if  |x| > 0.5 ln2 */ 
   2b8fc:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   2b900:	e59f3270 	ldr	r3, [pc, #624]	; 2bb78 <__ieee754_exp+0x418>
   2b904:	e1520003 	cmp	r2, r3
   2b908:	9a000068 	bls	2bab0 <__ieee754_exp+0x350>
	    if(hx < 0x3FF0A2B2) {	/* and |x| < 1.5 ln2 */
   2b90c:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   2b910:	e59f3264 	ldr	r3, [pc, #612]	; 2bb7c <__ieee754_exp+0x41c>
   2b914:	e1520003 	cmp	r2, r3
   2b918:	8a00001b 	bhi	2b98c <__ieee754_exp+0x22c>
		hi = x-ln2HI[xsb]; lo=ln2LO[xsb]; k = 1-xsb-xsb;
   2b91c:	e59f225c 	ldr	r2, [pc, #604]	; 2bb80 <__ieee754_exp+0x420>
   2b920:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2b924:	e1a03183 	lsl	r3, r3, #3
   2b928:	e0823003 	add	r3, r2, r3
   2b92c:	e8930018 	ldm	r3, {r3, r4}
   2b930:	e24b1094 	sub	r1, fp, #148	; 0x94
   2b934:	e8910003 	ldm	r1, {r0, r1}
   2b938:	e1a02003 	mov	r2, r3
   2b93c:	e1a03004 	mov	r3, r4
   2b940:	ebffa369 	bl	146ec <__aeabi_dsub>
   2b944:	e1a03000 	mov	r3, r0
   2b948:	e1a04001 	mov	r4, r1
   2b94c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2b950:	e50b4020 	str	r4, [fp, #-32]
   2b954:	e59f2228 	ldr	r2, [pc, #552]	; 2bb84 <__ieee754_exp+0x424>
   2b958:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2b95c:	e1a03183 	lsl	r3, r3, #3
   2b960:	e0823003 	add	r3, r2, r3
   2b964:	e8930018 	ldm	r3, {r3, r4}
   2b968:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2b96c:	e50b4028 	str	r4, [fp, #-40]	; 0x28
   2b970:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2b974:	e2632000 	rsb	r2, r3, #0
   2b978:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2b97c:	e0633002 	rsb	r3, r3, r2
   2b980:	e2833001 	add	r3, r3, #1
   2b984:	e50b3030 	str	r3, [fp, #-48]	; 0x30
   2b988:	ea00003e 	b	2ba88 <__ieee754_exp+0x328>
	    } else {
		k  = invln2*x+halF[xsb];
   2b98c:	e28f4f71 	add	r4, pc, #452	; 0x1c4
   2b990:	e8940018 	ldm	r4, {r3, r4}
   2b994:	e1a00003 	mov	r0, r3
   2b998:	e1a01004 	mov	r1, r4
   2b99c:	e24b3094 	sub	r3, fp, #148	; 0x94
   2b9a0:	e893000c 	ldm	r3, {r2, r3}
   2b9a4:	ebffa455 	bl	14b00 <__aeabi_dmul>
   2b9a8:	e1a03000 	mov	r3, r0
   2b9ac:	e1a04001 	mov	r4, r1
   2b9b0:	e1a01003 	mov	r1, r3
   2b9b4:	e1a02004 	mov	r2, r4
   2b9b8:	e59f01c8 	ldr	r0, [pc, #456]	; 2bb88 <__ieee754_exp+0x428>
   2b9bc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2b9c0:	e1a03183 	lsl	r3, r3, #3
   2b9c4:	e0803003 	add	r3, r0, r3
   2b9c8:	e8930018 	ldm	r3, {r3, r4}
   2b9cc:	e1a00001 	mov	r0, r1
   2b9d0:	e1a01002 	mov	r1, r2
   2b9d4:	e1a02003 	mov	r2, r3
   2b9d8:	e1a03004 	mov	r3, r4
   2b9dc:	ebffa343 	bl	146f0 <__adddf3>
   2b9e0:	e1a03000 	mov	r3, r0
   2b9e4:	e1a04001 	mov	r4, r1
   2b9e8:	e1a00003 	mov	r0, r3
   2b9ec:	e1a01004 	mov	r1, r4
   2b9f0:	ebffa5ba 	bl	150e0 <__aeabi_d2iz>
   2b9f4:	e1a03000 	mov	r3, r0
   2b9f8:	e50b3030 	str	r3, [fp, #-48]	; 0x30
		t  = k;
   2b9fc:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   2ba00:	ebffa407 	bl	14a24 <__aeabi_i2d>
   2ba04:	e1a03000 	mov	r3, r0
   2ba08:	e1a04001 	mov	r4, r1
   2ba0c:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   2ba10:	e50b4040 	str	r4, [fp, #-64]	; 0x40
		hi = x - t*ln2HI[0];	/* t*ln2HI is exact here */
   2ba14:	e28f4f51 	add	r4, pc, #324	; 0x144
   2ba18:	e8940018 	ldm	r4, {r3, r4}
   2ba1c:	e1a00003 	mov	r0, r3
   2ba20:	e1a01004 	mov	r1, r4
   2ba24:	e24b3044 	sub	r3, fp, #68	; 0x44
   2ba28:	e893000c 	ldm	r3, {r2, r3}
   2ba2c:	ebffa433 	bl	14b00 <__aeabi_dmul>
   2ba30:	e1a03000 	mov	r3, r0
   2ba34:	e1a04001 	mov	r4, r1
   2ba38:	e24b1094 	sub	r1, fp, #148	; 0x94
   2ba3c:	e8910003 	ldm	r1, {r0, r1}
   2ba40:	e1a02003 	mov	r2, r3
   2ba44:	e1a03004 	mov	r3, r4
   2ba48:	ebffa327 	bl	146ec <__aeabi_dsub>
   2ba4c:	e1a03000 	mov	r3, r0
   2ba50:	e1a04001 	mov	r4, r1
   2ba54:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2ba58:	e50b4020 	str	r4, [fp, #-32]
		lo = t*ln2LO[0];
   2ba5c:	e28f4f41 	add	r4, pc, #260	; 0x104
   2ba60:	e8940018 	ldm	r4, {r3, r4}
   2ba64:	e1a00003 	mov	r0, r3
   2ba68:	e1a01004 	mov	r1, r4
   2ba6c:	e24b3044 	sub	r3, fp, #68	; 0x44
   2ba70:	e893000c 	ldm	r3, {r2, r3}
   2ba74:	ebffa421 	bl	14b00 <__aeabi_dmul>
   2ba78:	e1a03000 	mov	r3, r0
   2ba7c:	e1a04001 	mov	r4, r1
   2ba80:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2ba84:	e50b4028 	str	r4, [fp, #-40]	; 0x28
	    }
	    x  = hi - lo;
   2ba88:	e24b1024 	sub	r1, fp, #36	; 0x24
   2ba8c:	e8910003 	ldm	r1, {r0, r1}
   2ba90:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2ba94:	e893000c 	ldm	r3, {r2, r3}
   2ba98:	ebffa313 	bl	146ec <__aeabi_dsub>
   2ba9c:	e1a03000 	mov	r3, r0
   2baa0:	e1a04001 	mov	r4, r1
   2baa4:	e50b3094 	str	r3, [fp, #-148]	; 0x94
   2baa8:	e50b4090 	str	r4, [fp, #-144]	; 0x90
   2baac:	ea000038 	b	2bb94 <__ieee754_exp+0x434>
	} 
	else if(hx < 0x3e300000)  {	/* when |x|<2**-28 */
   2bab0:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   2bab4:	e59f30d0 	ldr	r3, [pc, #208]	; 2bb8c <__ieee754_exp+0x42c>
   2bab8:	e1520003 	cmp	r2, r3
   2babc:	8a000034 	bhi	2bb94 <__ieee754_exp+0x434>
	    if(huge+x>one) return one+x;/* trigger inexact */
   2bac0:	e28f4080 	add	r4, pc, #128	; 0x80
   2bac4:	e8940018 	ldm	r4, {r3, r4}
   2bac8:	e1a00003 	mov	r0, r3
   2bacc:	e1a01004 	mov	r1, r4
   2bad0:	e24b3094 	sub	r3, fp, #148	; 0x94
   2bad4:	e893000c 	ldm	r3, {r2, r3}
   2bad8:	ebffa304 	bl	146f0 <__adddf3>
   2badc:	e1a03000 	mov	r3, r0
   2bae0:	e1a04001 	mov	r4, r1
   2bae4:	e1a01003 	mov	r1, r3
   2bae8:	e1a02004 	mov	r2, r4
   2baec:	e3a03000 	mov	r3, #0
   2baf0:	e59f4098 	ldr	r4, [pc, #152]	; 2bb90 <__ieee754_exp+0x430>
   2baf4:	e1a00001 	mov	r0, r1
   2baf8:	e1a01002 	mov	r1, r2
   2bafc:	e1a02003 	mov	r2, r3
   2bb00:	e1a03004 	mov	r3, r4
   2bb04:	ebffa56f 	bl	150c8 <__aeabi_dcmpgt>
   2bb08:	e1a03000 	mov	r3, r0
   2bb0c:	e3530000 	cmp	r3, #0
   2bb10:	0a00001f 	beq	2bb94 <__ieee754_exp+0x434>
   2bb14:	e3a03000 	mov	r3, #0
   2bb18:	e59f4070 	ldr	r4, [pc, #112]	; 2bb90 <__ieee754_exp+0x430>
   2bb1c:	e1a00003 	mov	r0, r3
   2bb20:	e1a01004 	mov	r1, r4
   2bb24:	e24b3094 	sub	r3, fp, #148	; 0x94
   2bb28:	e893000c 	ldm	r3, {r2, r3}
   2bb2c:	ebffa2ef 	bl	146f0 <__adddf3>
   2bb30:	e1a03000 	mov	r3, r0
   2bb34:	e1a04001 	mov	r4, r1
   2bb38:	ea00010c 	b	2bf70 <__ieee754_exp+0x810>
   2bb3c:	e1a00000 	nop			; (mov r0, r0)
   2bb40:	fefa39ef 	.word	0xfefa39ef
   2bb44:	40862e42 	.word	0x40862e42
   2bb48:	8800759c 	.word	0x8800759c
   2bb4c:	7e37e43c 	.word	0x7e37e43c
   2bb50:	d52d3051 	.word	0xd52d3051
   2bb54:	c0874910 	.word	0xc0874910
   2bb58:	652b82fe 	.word	0x652b82fe
   2bb5c:	3ff71547 	.word	0x3ff71547
   2bb60:	fee00000 	.word	0xfee00000
   2bb64:	3fe62e42 	.word	0x3fe62e42
   2bb68:	35793c76 	.word	0x35793c76
   2bb6c:	3dea39ef 	.word	0x3dea39ef
   2bb70:	40862e41 	.word	0x40862e41
   2bb74:	7fefffff 	.word	0x7fefffff
   2bb78:	3fd62e42 	.word	0x3fd62e42
   2bb7c:	3ff0a2b1 	.word	0x3ff0a2b1
   2bb80:	00033468 	.word	0x00033468
   2bb84:	00033478 	.word	0x00033478
   2bb88:	00033438 	.word	0x00033438
   2bb8c:	3e2fffff 	.word	0x3e2fffff
   2bb90:	3ff00000 	.word	0x3ff00000
	}

    /* x is now in primary range */
	t  = x*x;
   2bb94:	e24b1094 	sub	r1, fp, #148	; 0x94
   2bb98:	e8910003 	ldm	r1, {r0, r1}
   2bb9c:	e24b3094 	sub	r3, fp, #148	; 0x94
   2bba0:	e893000c 	ldm	r3, {r2, r3}
   2bba4:	ebffa3d5 	bl	14b00 <__aeabi_dmul>
   2bba8:	e1a03000 	mov	r3, r0
   2bbac:	e1a04001 	mov	r4, r1
   2bbb0:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   2bbb4:	e50b4040 	str	r4, [fp, #-64]	; 0x40
	c  = x - t*(P1+t*(P2+t*(P3+t*(P4+t*P5))));
   2bbb8:	e28f4ff2 	add	r4, pc, #968	; 0x3c8
   2bbbc:	e8940018 	ldm	r4, {r3, r4}
   2bbc0:	e1a00003 	mov	r0, r3
   2bbc4:	e1a01004 	mov	r1, r4
   2bbc8:	e24b3044 	sub	r3, fp, #68	; 0x44
   2bbcc:	e893000c 	ldm	r3, {r2, r3}
   2bbd0:	ebffa3ca 	bl	14b00 <__aeabi_dmul>
   2bbd4:	e1a03000 	mov	r3, r0
   2bbd8:	e1a04001 	mov	r4, r1
   2bbdc:	e1a01003 	mov	r1, r3
   2bbe0:	e1a02004 	mov	r2, r4
   2bbe4:	e28f4fe9 	add	r4, pc, #932	; 0x3a4
   2bbe8:	e8940018 	ldm	r4, {r3, r4}
   2bbec:	e1a00001 	mov	r0, r1
   2bbf0:	e1a01002 	mov	r1, r2
   2bbf4:	e1a02003 	mov	r2, r3
   2bbf8:	e1a03004 	mov	r3, r4
   2bbfc:	ebffa2bb 	bl	146f0 <__adddf3>
   2bc00:	e1a03000 	mov	r3, r0
   2bc04:	e1a04001 	mov	r4, r1
   2bc08:	e1a00003 	mov	r0, r3
   2bc0c:	e1a01004 	mov	r1, r4
   2bc10:	e24b3044 	sub	r3, fp, #68	; 0x44
   2bc14:	e893000c 	ldm	r3, {r2, r3}
   2bc18:	ebffa3b8 	bl	14b00 <__aeabi_dmul>
   2bc1c:	e1a03000 	mov	r3, r0
   2bc20:	e1a04001 	mov	r4, r1
   2bc24:	e1a01003 	mov	r1, r3
   2bc28:	e1a02004 	mov	r2, r4
   2bc2c:	e28f4fd9 	add	r4, pc, #868	; 0x364
   2bc30:	e8940018 	ldm	r4, {r3, r4}
   2bc34:	e1a00001 	mov	r0, r1
   2bc38:	e1a01002 	mov	r1, r2
   2bc3c:	e1a02003 	mov	r2, r3
   2bc40:	e1a03004 	mov	r3, r4
   2bc44:	ebffa2a9 	bl	146f0 <__adddf3>
   2bc48:	e1a03000 	mov	r3, r0
   2bc4c:	e1a04001 	mov	r4, r1
   2bc50:	e1a00003 	mov	r0, r3
   2bc54:	e1a01004 	mov	r1, r4
   2bc58:	e24b3044 	sub	r3, fp, #68	; 0x44
   2bc5c:	e893000c 	ldm	r3, {r2, r3}
   2bc60:	ebffa3a6 	bl	14b00 <__aeabi_dmul>
   2bc64:	e1a03000 	mov	r3, r0
   2bc68:	e1a04001 	mov	r4, r1
   2bc6c:	e1a01003 	mov	r1, r3
   2bc70:	e1a02004 	mov	r2, r4
   2bc74:	e28f4fc9 	add	r4, pc, #804	; 0x324
   2bc78:	e8940018 	ldm	r4, {r3, r4}
   2bc7c:	e1a00001 	mov	r0, r1
   2bc80:	e1a01002 	mov	r1, r2
   2bc84:	e1a02003 	mov	r2, r3
   2bc88:	e1a03004 	mov	r3, r4
   2bc8c:	ebffa297 	bl	146f0 <__adddf3>
   2bc90:	e1a03000 	mov	r3, r0
   2bc94:	e1a04001 	mov	r4, r1
   2bc98:	e1a00003 	mov	r0, r3
   2bc9c:	e1a01004 	mov	r1, r4
   2bca0:	e24b3044 	sub	r3, fp, #68	; 0x44
   2bca4:	e893000c 	ldm	r3, {r2, r3}
   2bca8:	ebffa394 	bl	14b00 <__aeabi_dmul>
   2bcac:	e1a03000 	mov	r3, r0
   2bcb0:	e1a04001 	mov	r4, r1
   2bcb4:	e1a01003 	mov	r1, r3
   2bcb8:	e1a02004 	mov	r2, r4
   2bcbc:	e28f4fb9 	add	r4, pc, #740	; 0x2e4
   2bcc0:	e8940018 	ldm	r4, {r3, r4}
   2bcc4:	e1a00001 	mov	r0, r1
   2bcc8:	e1a01002 	mov	r1, r2
   2bccc:	e1a02003 	mov	r2, r3
   2bcd0:	e1a03004 	mov	r3, r4
   2bcd4:	ebffa285 	bl	146f0 <__adddf3>
   2bcd8:	e1a03000 	mov	r3, r0
   2bcdc:	e1a04001 	mov	r4, r1
   2bce0:	e1a00003 	mov	r0, r3
   2bce4:	e1a01004 	mov	r1, r4
   2bce8:	e24b3044 	sub	r3, fp, #68	; 0x44
   2bcec:	e893000c 	ldm	r3, {r2, r3}
   2bcf0:	ebffa382 	bl	14b00 <__aeabi_dmul>
   2bcf4:	e1a03000 	mov	r3, r0
   2bcf8:	e1a04001 	mov	r4, r1
   2bcfc:	e24b1094 	sub	r1, fp, #148	; 0x94
   2bd00:	e8910003 	ldm	r1, {r0, r1}
   2bd04:	e1a02003 	mov	r2, r3
   2bd08:	e1a03004 	mov	r3, r4
   2bd0c:	ebffa276 	bl	146ec <__aeabi_dsub>
   2bd10:	e1a03000 	mov	r3, r0
   2bd14:	e1a04001 	mov	r4, r1
   2bd18:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   2bd1c:	e50b4048 	str	r4, [fp, #-72]	; 0x48
	if(k==0) 	return one-((x*c)/(c-2.0)-x); 
   2bd20:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2bd24:	e3530000 	cmp	r3, #0
   2bd28:	1a000027 	bne	2bdcc <__ieee754_exp+0x66c>
   2bd2c:	e3a05000 	mov	r5, #0
   2bd30:	e59f6278 	ldr	r6, [pc, #632]	; 2bfb0 <__ieee754_exp+0x850>
   2bd34:	e24b1094 	sub	r1, fp, #148	; 0x94
   2bd38:	e8910003 	ldm	r1, {r0, r1}
   2bd3c:	e24b304c 	sub	r3, fp, #76	; 0x4c
   2bd40:	e893000c 	ldm	r3, {r2, r3}
   2bd44:	ebffa36d 	bl	14b00 <__aeabi_dmul>
   2bd48:	e1a03000 	mov	r3, r0
   2bd4c:	e1a04001 	mov	r4, r1
   2bd50:	e1a07003 	mov	r7, r3
   2bd54:	e1a08004 	mov	r8, r4
   2bd58:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2bd5c:	e8910003 	ldm	r1, {r0, r1}
   2bd60:	e3a02000 	mov	r2, #0
   2bd64:	e3a03101 	mov	r3, #1073741824	; 0x40000000
   2bd68:	ebffa25f 	bl	146ec <__aeabi_dsub>
   2bd6c:	e1a03000 	mov	r3, r0
   2bd70:	e1a04001 	mov	r4, r1
   2bd74:	e1a00007 	mov	r0, r7
   2bd78:	e1a01008 	mov	r1, r8
   2bd7c:	e1a02003 	mov	r2, r3
   2bd80:	e1a03004 	mov	r3, r4
   2bd84:	ebffa401 	bl	14d90 <__aeabi_ddiv>
   2bd88:	e1a03000 	mov	r3, r0
   2bd8c:	e1a04001 	mov	r4, r1
   2bd90:	e1a00003 	mov	r0, r3
   2bd94:	e1a01004 	mov	r1, r4
   2bd98:	e24b3094 	sub	r3, fp, #148	; 0x94
   2bd9c:	e893000c 	ldm	r3, {r2, r3}
   2bda0:	ebffa251 	bl	146ec <__aeabi_dsub>
   2bda4:	e1a03000 	mov	r3, r0
   2bda8:	e1a04001 	mov	r4, r1
   2bdac:	e1a00005 	mov	r0, r5
   2bdb0:	e1a01006 	mov	r1, r6
   2bdb4:	e1a02003 	mov	r2, r3
   2bdb8:	e1a03004 	mov	r3, r4
   2bdbc:	ebffa24a 	bl	146ec <__aeabi_dsub>
   2bdc0:	e1a03000 	mov	r3, r0
   2bdc4:	e1a04001 	mov	r4, r1
   2bdc8:	ea000068 	b	2bf70 <__ieee754_exp+0x810>
	else 		y = one-((lo-(x*c)/(2.0-c))-hi);
   2bdcc:	e3a05000 	mov	r5, #0
   2bdd0:	e59f61d8 	ldr	r6, [pc, #472]	; 2bfb0 <__ieee754_exp+0x850>
   2bdd4:	e24b1094 	sub	r1, fp, #148	; 0x94
   2bdd8:	e8910003 	ldm	r1, {r0, r1}
   2bddc:	e24b304c 	sub	r3, fp, #76	; 0x4c
   2bde0:	e893000c 	ldm	r3, {r2, r3}
   2bde4:	ebffa345 	bl	14b00 <__aeabi_dmul>
   2bde8:	e1a03000 	mov	r3, r0
   2bdec:	e1a04001 	mov	r4, r1
   2bdf0:	e1a07003 	mov	r7, r3
   2bdf4:	e1a08004 	mov	r8, r4
   2bdf8:	e3a00000 	mov	r0, #0
   2bdfc:	e3a01101 	mov	r1, #1073741824	; 0x40000000
   2be00:	e24b304c 	sub	r3, fp, #76	; 0x4c
   2be04:	e893000c 	ldm	r3, {r2, r3}
   2be08:	ebffa237 	bl	146ec <__aeabi_dsub>
   2be0c:	e1a03000 	mov	r3, r0
   2be10:	e1a04001 	mov	r4, r1
   2be14:	e1a00007 	mov	r0, r7
   2be18:	e1a01008 	mov	r1, r8
   2be1c:	e1a02003 	mov	r2, r3
   2be20:	e1a03004 	mov	r3, r4
   2be24:	ebffa3d9 	bl	14d90 <__aeabi_ddiv>
   2be28:	e1a03000 	mov	r3, r0
   2be2c:	e1a04001 	mov	r4, r1
   2be30:	e24b102c 	sub	r1, fp, #44	; 0x2c
   2be34:	e8910003 	ldm	r1, {r0, r1}
   2be38:	e1a02003 	mov	r2, r3
   2be3c:	e1a03004 	mov	r3, r4
   2be40:	ebffa229 	bl	146ec <__aeabi_dsub>
   2be44:	e1a03000 	mov	r3, r0
   2be48:	e1a04001 	mov	r4, r1
   2be4c:	e1a00003 	mov	r0, r3
   2be50:	e1a01004 	mov	r1, r4
   2be54:	e24b3024 	sub	r3, fp, #36	; 0x24
   2be58:	e893000c 	ldm	r3, {r2, r3}
   2be5c:	ebffa222 	bl	146ec <__aeabi_dsub>
   2be60:	e1a03000 	mov	r3, r0
   2be64:	e1a04001 	mov	r4, r1
   2be68:	e1a00005 	mov	r0, r5
   2be6c:	e1a01006 	mov	r1, r6
   2be70:	e1a02003 	mov	r2, r3
   2be74:	e1a03004 	mov	r3, r4
   2be78:	ebffa21b 	bl	146ec <__aeabi_dsub>
   2be7c:	e1a03000 	mov	r3, r0
   2be80:	e1a04001 	mov	r4, r1
   2be84:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   2be88:	e50b4050 	str	r4, [fp, #-80]	; 0x50
	if(k >= -1021) {
   2be8c:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   2be90:	e3e03fff 	mvn	r3, #1020	; 0x3fc
   2be94:	e1520003 	cmp	r2, r3
   2be98:	ba000016 	blt	2bef8 <__ieee754_exp+0x798>
	    __uint32_t hy;
	    GET_HIGH_WORD(hy,y);
   2be9c:	e24b4054 	sub	r4, fp, #84	; 0x54
   2bea0:	e8940018 	ldm	r4, {r3, r4}
   2bea4:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   2bea8:	e50b4070 	str	r4, [fp, #-112]	; 0x70
   2beac:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   2beb0:	e50b3058 	str	r3, [fp, #-88]	; 0x58
	    SET_HIGH_WORD(y,hy+(k<<20));	/* add k to y's exponent */
   2beb4:	e24b4054 	sub	r4, fp, #84	; 0x54
   2beb8:	e8940018 	ldm	r4, {r3, r4}
   2bebc:	e50b307c 	str	r3, [fp, #-124]	; 0x7c
   2bec0:	e50b4078 	str	r4, [fp, #-120]	; 0x78
   2bec4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2bec8:	e1a03a03 	lsl	r3, r3, #20
   2becc:	e1a02003 	mov	r2, r3
   2bed0:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   2bed4:	e0823003 	add	r3, r2, r3
   2bed8:	e50b3078 	str	r3, [fp, #-120]	; 0x78
   2bedc:	e24b407c 	sub	r4, fp, #124	; 0x7c
   2bee0:	e8940018 	ldm	r4, {r3, r4}
   2bee4:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   2bee8:	e50b4050 	str	r4, [fp, #-80]	; 0x50
	    return y;
   2beec:	e24b4054 	sub	r4, fp, #84	; 0x54
   2bef0:	e8940018 	ldm	r4, {r3, r4}
   2bef4:	ea00001d 	b	2bf70 <__ieee754_exp+0x810>
	} else {
	    __uint32_t hy;
	    GET_HIGH_WORD(hy,y);
   2bef8:	e24b4054 	sub	r4, fp, #84	; 0x54
   2befc:	e8940018 	ldm	r4, {r3, r4}
   2bf00:	e50b3084 	str	r3, [fp, #-132]	; 0x84
   2bf04:	e50b4080 	str	r4, [fp, #-128]	; 0x80
   2bf08:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
   2bf0c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
	    SET_HIGH_WORD(y,hy+((k+1000)<<20));	/* add k to y's exponent */
   2bf10:	e24b4054 	sub	r4, fp, #84	; 0x54
   2bf14:	e8940018 	ldm	r4, {r3, r4}
   2bf18:	e50b308c 	str	r3, [fp, #-140]	; 0x8c
   2bf1c:	e50b4088 	str	r4, [fp, #-136]	; 0x88
   2bf20:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2bf24:	e2833ffa 	add	r3, r3, #1000	; 0x3e8
   2bf28:	e1a03a03 	lsl	r3, r3, #20
   2bf2c:	e1a02003 	mov	r2, r3
   2bf30:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   2bf34:	e0823003 	add	r3, r2, r3
   2bf38:	e50b3088 	str	r3, [fp, #-136]	; 0x88
   2bf3c:	e24b408c 	sub	r4, fp, #140	; 0x8c
   2bf40:	e8940018 	ldm	r4, {r3, r4}
   2bf44:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   2bf48:	e50b4050 	str	r4, [fp, #-80]	; 0x50
	    return y*twom1000;
   2bf4c:	e3a03000 	mov	r3, #0
   2bf50:	e3a04617 	mov	r4, #24117248	; 0x1700000
   2bf54:	e1a00003 	mov	r0, r3
   2bf58:	e1a01004 	mov	r1, r4
   2bf5c:	e24b3054 	sub	r3, fp, #84	; 0x54
   2bf60:	e893000c 	ldm	r3, {r2, r3}
   2bf64:	ebffa2e5 	bl	14b00 <__aeabi_dmul>
   2bf68:	e1a03000 	mov	r3, r0
   2bf6c:	e1a04001 	mov	r4, r1
	}
}
   2bf70:	e1a00003 	mov	r0, r3
   2bf74:	e1a01004 	mov	r1, r4
   2bf78:	e24bd018 	sub	sp, fp, #24
   2bf7c:	e8bd49f0 	pop	{r4, r5, r6, r7, r8, fp, lr}
   2bf80:	e12fff1e 	bx	lr
   2bf84:	e1a00000 	nop			; (mov r0, r0)
   2bf88:	72bea4d0 	.word	0x72bea4d0
   2bf8c:	3e663769 	.word	0x3e663769
   2bf90:	c5d26bf1 	.word	0xc5d26bf1
   2bf94:	bebbbd41 	.word	0xbebbbd41
   2bf98:	af25de2c 	.word	0xaf25de2c
   2bf9c:	3f11566a 	.word	0x3f11566a
   2bfa0:	16bebd93 	.word	0x16bebd93
   2bfa4:	bf66c16c 	.word	0xbf66c16c
   2bfa8:	5555553e 	.word	0x5555553e
   2bfac:	3fc55555 	.word	0x3fc55555
   2bfb0:	3ff00000 	.word	0x3ff00000
   2bfb4:	e1a00000 	nop			; (mov r0, r0)

0002bfb8 <__ieee754_pow>:
	double __ieee754_pow(double x, double y)
#else
	double __ieee754_pow(x,y)
	double x, y;
#endif
{
   2bfb8:	e92d4870 	push	{r4, r5, r6, fp, lr}
   2bfbc:	e28db010 	add	fp, sp, #16
   2bfc0:	e24ddf59 	sub	sp, sp, #356	; 0x164
   2bfc4:	e50b016c 	str	r0, [fp, #-364]	; 0x16c
   2bfc8:	e50b1168 	str	r1, [fp, #-360]	; 0x168
   2bfcc:	e50b2174 	str	r2, [fp, #-372]	; 0x174
   2bfd0:	e50b3170 	str	r3, [fp, #-368]	; 0x170
	double y1,t1,t2,r,s,t,u,v,w;
	__int32_t i,j,k,yisint,n;
	__int32_t hx,hy,ix,iy;
	__uint32_t lx,ly;

	EXTRACT_WORDS(hx,lx,x);
   2bfd4:	e24b3f5b 	sub	r3, fp, #364	; 0x16c
   2bfd8:	e893000c 	ldm	r3, {r2, r3}
   2bfdc:	e50b20ec 	str	r2, [fp, #-236]	; 0xec
   2bfe0:	e50b30e8 	str	r3, [fp, #-232]	; 0xe8
   2bfe4:	e51b30e8 	ldr	r3, [fp, #-232]	; 0xe8
   2bfe8:	e50b3058 	str	r3, [fp, #-88]	; 0x58
   2bfec:	e51b30ec 	ldr	r3, [fp, #-236]	; 0xec
   2bff0:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
	EXTRACT_WORDS(hy,ly,y);
   2bff4:	e24b3f5d 	sub	r3, fp, #372	; 0x174
   2bff8:	e893000c 	ldm	r3, {r2, r3}
   2bffc:	e50b20f4 	str	r2, [fp, #-244]	; 0xf4
   2c000:	e50b30f0 	str	r3, [fp, #-240]	; 0xf0
   2c004:	e51b30f0 	ldr	r3, [fp, #-240]	; 0xf0
   2c008:	e50b3060 	str	r3, [fp, #-96]	; 0x60
   2c00c:	e51b30f4 	ldr	r3, [fp, #-244]	; 0xf4
   2c010:	e50b3064 	str	r3, [fp, #-100]	; 0x64
	ix = hx&0x7fffffff;  iy = hy&0x7fffffff;
   2c014:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   2c018:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   2c01c:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   2c020:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   2c024:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   2c028:	e50b3068 	str	r3, [fp, #-104]	; 0x68

    /* y==zero: x**0 = 1 */
	if((iy|ly)==0) return one; 	
   2c02c:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   2c030:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   2c034:	e1823003 	orr	r3, r2, r3
   2c038:	e3530000 	cmp	r3, #0
   2c03c:	1a000002 	bne	2c04c <__ieee754_pow+0x94>
   2c040:	e3a04000 	mov	r4, #0
   2c044:	e59f5744 	ldr	r5, [pc, #1860]	; 2c790 <__ieee754_pow+0x7d8>
   2c048:	ea000770 	b	2de10 <__ieee754_pow+0x1e58>

    /* x|y==NaN return NaN unless x==1 then return 1 */
	if(ix > 0x7ff00000 || ((ix==0x7ff00000)&&(lx!=0)) ||
   2c04c:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   2c050:	e59f3718 	ldr	r3, [pc, #1816]	; 2c770 <__ieee754_pow+0x7b8>
   2c054:	e1520003 	cmp	r2, r3
   2c058:	ca000011 	bgt	2c0a4 <__ieee754_pow+0xec>
   2c05c:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   2c060:	e59f3708 	ldr	r3, [pc, #1800]	; 2c770 <__ieee754_pow+0x7b8>
   2c064:	e1520003 	cmp	r2, r3
   2c068:	1a000002 	bne	2c078 <__ieee754_pow+0xc0>
   2c06c:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   2c070:	e3530000 	cmp	r3, #0
   2c074:	1a00000a 	bne	2c0a4 <__ieee754_pow+0xec>
   2c078:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   2c07c:	e59f36ec 	ldr	r3, [pc, #1772]	; 2c770 <__ieee754_pow+0x7b8>
   2c080:	e1520003 	cmp	r2, r3
   2c084:	ca000006 	bgt	2c0a4 <__ieee754_pow+0xec>
	   iy > 0x7ff00000 || ((iy==0x7ff00000)&&(ly!=0))) {
   2c088:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   2c08c:	e59f36dc 	ldr	r3, [pc, #1756]	; 2c770 <__ieee754_pow+0x7b8>
   2c090:	e1520003 	cmp	r2, r3
   2c094:	1a000012 	bne	2c0e4 <__ieee754_pow+0x12c>
   2c098:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   2c09c:	e3530000 	cmp	r3, #0
   2c0a0:	0a00000f 	beq	2c0e4 <__ieee754_pow+0x12c>
	    if(((ix-0x3ff00000)|lx)==0) return one;
   2c0a4:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   2c0a8:	e2833103 	add	r3, r3, #-1073741824	; 0xc0000000
   2c0ac:	e2833601 	add	r3, r3, #1048576	; 0x100000
   2c0b0:	e1a02003 	mov	r2, r3
   2c0b4:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   2c0b8:	e1823003 	orr	r3, r2, r3
   2c0bc:	e3530000 	cmp	r3, #0
   2c0c0:	1a000002 	bne	2c0d0 <__ieee754_pow+0x118>
   2c0c4:	e3a04000 	mov	r4, #0
   2c0c8:	e59f56c0 	ldr	r5, [pc, #1728]	; 2c790 <__ieee754_pow+0x7d8>
   2c0cc:	ea00074f 	b	2de10 <__ieee754_pow+0x1e58>
	    else return nan("");	
   2c0d0:	e59f069c 	ldr	r0, [pc, #1692]	; 2c774 <__ieee754_pow+0x7bc>
   2c0d4:	eb00140e 	bl	31114 <nan>
   2c0d8:	e1a04000 	mov	r4, r0
   2c0dc:	e1a05001 	mov	r5, r1
   2c0e0:	ea00074a 	b	2de10 <__ieee754_pow+0x1e58>
    /* determine if y is an odd int when x < 0
     * yisint = 0	... y is not an integer
     * yisint = 1	... y is an odd int
     * yisint = 2	... y is an even int
     */
	yisint  = 0;
   2c0e4:	e3a03000 	mov	r3, #0
   2c0e8:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
	if(hx<0) {	
   2c0ec:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   2c0f0:	e3530000 	cmp	r3, #0
   2c0f4:	aa000037 	bge	2c1d8 <__ieee754_pow+0x220>
	    if(iy>=0x43400000) yisint = 2; /* even integer y */
   2c0f8:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   2c0fc:	e59f3674 	ldr	r3, [pc, #1652]	; 2c778 <__ieee754_pow+0x7c0>
   2c100:	e1520003 	cmp	r2, r3
   2c104:	da000002 	ble	2c114 <__ieee754_pow+0x15c>
   2c108:	e3a03002 	mov	r3, #2
   2c10c:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   2c110:	ea000030 	b	2c1d8 <__ieee754_pow+0x220>
	    else if(iy>=0x3ff00000) {
   2c114:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   2c118:	e59f365c 	ldr	r3, [pc, #1628]	; 2c77c <__ieee754_pow+0x7c4>
   2c11c:	e1520003 	cmp	r2, r3
   2c120:	da00002c 	ble	2c1d8 <__ieee754_pow+0x220>
		k = (iy>>20)-0x3ff;	   /* exponent */
   2c124:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   2c128:	e1a03a43 	asr	r3, r3, #20
   2c12c:	e2433fff 	sub	r3, r3, #1020	; 0x3fc
   2c130:	e2433003 	sub	r3, r3, #3
   2c134:	e50b3048 	str	r3, [fp, #-72]	; 0x48
		if(k>20) {
   2c138:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2c13c:	e3530014 	cmp	r3, #20
   2c140:	da000011 	ble	2c18c <__ieee754_pow+0x1d4>
		    j = ly>>(52-k);
   2c144:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2c148:	e2633034 	rsb	r3, r3, #52	; 0x34
   2c14c:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
   2c150:	e1a03332 	lsr	r3, r2, r3
   2c154:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
		    if((j<<(52-k))==ly) yisint = 2-(j&1);
   2c158:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2c15c:	e2633034 	rsb	r3, r3, #52	; 0x34
   2c160:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
   2c164:	e1a03312 	lsl	r3, r2, r3
   2c168:	e1a02003 	mov	r2, r3
   2c16c:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   2c170:	e1520003 	cmp	r2, r3
   2c174:	1a000017 	bne	2c1d8 <__ieee754_pow+0x220>
   2c178:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   2c17c:	e2033001 	and	r3, r3, #1
   2c180:	e2633002 	rsb	r3, r3, #2
   2c184:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   2c188:	ea000012 	b	2c1d8 <__ieee754_pow+0x220>
		} else if(ly==0) {
   2c18c:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   2c190:	e3530000 	cmp	r3, #0
   2c194:	1a00000f 	bne	2c1d8 <__ieee754_pow+0x220>
		    j = iy>>(20-k);
   2c198:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2c19c:	e2633014 	rsb	r3, r3, #20
   2c1a0:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   2c1a4:	e1a03352 	asr	r3, r2, r3
   2c1a8:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
		    if((j<<(20-k))==iy) yisint = 2-(j&1);
   2c1ac:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2c1b0:	e2633014 	rsb	r3, r3, #20
   2c1b4:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
   2c1b8:	e1a02312 	lsl	r2, r2, r3
   2c1bc:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   2c1c0:	e1520003 	cmp	r2, r3
   2c1c4:	1a000003 	bne	2c1d8 <__ieee754_pow+0x220>
   2c1c8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   2c1cc:	e2033001 	and	r3, r3, #1
   2c1d0:	e2633002 	rsb	r3, r3, #2
   2c1d4:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
		}
	    }		
	} 

    /* special value of y */
	if(ly==0) { 	
   2c1d8:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   2c1dc:	e3530000 	cmp	r3, #0
   2c1e0:	1a000055 	bne	2c33c <__ieee754_pow+0x384>
	    if (iy==0x7ff00000) {	/* y is +-inf */
   2c1e4:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   2c1e8:	e59f3580 	ldr	r3, [pc, #1408]	; 2c770 <__ieee754_pow+0x7b8>
   2c1ec:	e1520003 	cmp	r2, r3
   2c1f0:	1a000021 	bne	2c27c <__ieee754_pow+0x2c4>
	        if(((ix-0x3ff00000)|lx)==0)
   2c1f4:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   2c1f8:	e2833103 	add	r3, r3, #-1073741824	; 0xc0000000
   2c1fc:	e2833601 	add	r3, r3, #1048576	; 0x100000
   2c200:	e1a02003 	mov	r2, r3
   2c204:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   2c208:	e1823003 	orr	r3, r2, r3
   2c20c:	e3530000 	cmp	r3, #0
   2c210:	1a000002 	bne	2c220 <__ieee754_pow+0x268>
		    return one;		/* +-1**+-inf = 1 */
   2c214:	e3a04000 	mov	r4, #0
   2c218:	e59f5570 	ldr	r5, [pc, #1392]	; 2c790 <__ieee754_pow+0x7d8>
   2c21c:	ea0006fb 	b	2de10 <__ieee754_pow+0x1e58>
	        else if (ix >= 0x3ff00000)/* (|x|>1)**+-inf = inf,0 */
   2c220:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   2c224:	e59f3550 	ldr	r3, [pc, #1360]	; 2c77c <__ieee754_pow+0x7c4>
   2c228:	e1520003 	cmp	r2, r3
   2c22c:	da000008 	ble	2c254 <__ieee754_pow+0x29c>
		    return (hy>=0)? y: zero;
   2c230:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   2c234:	e3530000 	cmp	r3, #0
   2c238:	ba000002 	blt	2c248 <__ieee754_pow+0x290>
   2c23c:	e24b5f5d 	sub	r5, fp, #372	; 0x174
   2c240:	e8950030 	ldm	r5, {r4, r5}
   2c244:	ea0006f1 	b	2de10 <__ieee754_pow+0x1e58>
   2c248:	e3a04000 	mov	r4, #0
   2c24c:	e3a05000 	mov	r5, #0
   2c250:	ea0006ee 	b	2de10 <__ieee754_pow+0x1e58>
	        else			/* (|x|<1)**-,+inf = inf,0 */
		    return (hy<0)?-y: zero;
   2c254:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   2c258:	e3530000 	cmp	r3, #0
   2c25c:	aa000003 	bge	2c270 <__ieee754_pow+0x2b8>
   2c260:	e51b4174 	ldr	r4, [fp, #-372]	; 0x174
   2c264:	e51b3170 	ldr	r3, [fp, #-368]	; 0x170
   2c268:	e2235102 	eor	r5, r3, #-2147483648	; 0x80000000
   2c26c:	ea0006e7 	b	2de10 <__ieee754_pow+0x1e58>
   2c270:	e3a04000 	mov	r4, #0
   2c274:	e3a05000 	mov	r5, #0
   2c278:	ea0006e4 	b	2de10 <__ieee754_pow+0x1e58>
	    } 
	    if(iy==0x3ff00000) {	/* y is  +-1 */
   2c27c:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   2c280:	e59f3508 	ldr	r3, [pc, #1288]	; 2c790 <__ieee754_pow+0x7d8>
   2c284:	e1520003 	cmp	r2, r3
   2c288:	1a000011 	bne	2c2d4 <__ieee754_pow+0x31c>
		if(hy<0) return one/x; else return x;
   2c28c:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   2c290:	e3530000 	cmp	r3, #0
   2c294:	aa00000b 	bge	2c2c8 <__ieee754_pow+0x310>
   2c298:	e3a03000 	mov	r3, #0
   2c29c:	e59f44ec 	ldr	r4, [pc, #1260]	; 2c790 <__ieee754_pow+0x7d8>
   2c2a0:	e1a00003 	mov	r0, r3
   2c2a4:	e1a01004 	mov	r1, r4
   2c2a8:	e24b3f5b 	sub	r3, fp, #364	; 0x16c
   2c2ac:	e893000c 	ldm	r3, {r2, r3}
   2c2b0:	ebffa2b6 	bl	14d90 <__aeabi_ddiv>
   2c2b4:	e1a03000 	mov	r3, r0
   2c2b8:	e1a04001 	mov	r4, r1
   2c2bc:	e1a05004 	mov	r5, r4
   2c2c0:	e1a04003 	mov	r4, r3
   2c2c4:	ea0006d1 	b	2de10 <__ieee754_pow+0x1e58>
   2c2c8:	e24b5f5b 	sub	r5, fp, #364	; 0x16c
   2c2cc:	e8950030 	ldm	r5, {r4, r5}
   2c2d0:	ea0006ce 	b	2de10 <__ieee754_pow+0x1e58>
	    }
	    if(hy==0x40000000) return x*x; /* y is  2 */
   2c2d4:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   2c2d8:	e3530101 	cmp	r3, #1073741824	; 0x40000000
   2c2dc:	1a000009 	bne	2c308 <__ieee754_pow+0x350>
   2c2e0:	e24b1f5b 	sub	r1, fp, #364	; 0x16c
   2c2e4:	e8910003 	ldm	r1, {r0, r1}
   2c2e8:	e24b3f5b 	sub	r3, fp, #364	; 0x16c
   2c2ec:	e893000c 	ldm	r3, {r2, r3}
   2c2f0:	ebffa202 	bl	14b00 <__aeabi_dmul>
   2c2f4:	e1a03000 	mov	r3, r0
   2c2f8:	e1a04001 	mov	r4, r1
   2c2fc:	e1a05004 	mov	r5, r4
   2c300:	e1a04003 	mov	r4, r3
   2c304:	ea0006c1 	b	2de10 <__ieee754_pow+0x1e58>
	    if(hy==0x3fe00000) {	/* y is  0.5 */
   2c308:	e51b2060 	ldr	r2, [fp, #-96]	; 0x60
   2c30c:	e59f346c 	ldr	r3, [pc, #1132]	; 2c780 <__ieee754_pow+0x7c8>
   2c310:	e1520003 	cmp	r2, r3
   2c314:	1a000008 	bne	2c33c <__ieee754_pow+0x384>
		if(hx>=0)	/* x >= +0 */
   2c318:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   2c31c:	e3530000 	cmp	r3, #0
   2c320:	ba000005 	blt	2c33c <__ieee754_pow+0x384>
		return __ieee754_sqrt(x);	
   2c324:	e24b1f5b 	sub	r1, fp, #364	; 0x16c
   2c328:	e8910003 	ldm	r1, {r0, r1}
   2c32c:	eb0009a1 	bl	2e9b8 <__ieee754_sqrt>
   2c330:	e1a04000 	mov	r4, r0
   2c334:	e1a05001 	mov	r5, r1
   2c338:	ea0006b4 	b	2de10 <__ieee754_pow+0x1e58>
	    }
	}

	ax   = fabs(x);
   2c33c:	e24b1f5b 	sub	r1, fp, #364	; 0x16c
   2c340:	e8910003 	ldm	r1, {r0, r1}
   2c344:	eb001251 	bl	30c90 <fabs>
   2c348:	e50b0024 	str	r0, [fp, #-36]	; 0x24
   2c34c:	e50b1020 	str	r1, [fp, #-32]
    /* special value of x */
	if(lx==0) {
   2c350:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   2c354:	e3530000 	cmp	r3, #0
   2c358:	1a00004b 	bne	2c48c <__ieee754_pow+0x4d4>
	    if(ix==0x7ff00000||ix==0||ix==0x3ff00000){
   2c35c:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   2c360:	e59f3408 	ldr	r3, [pc, #1032]	; 2c770 <__ieee754_pow+0x7b8>
   2c364:	e1520003 	cmp	r2, r3
   2c368:	0a000006 	beq	2c388 <__ieee754_pow+0x3d0>
   2c36c:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   2c370:	e3530000 	cmp	r3, #0
   2c374:	0a000003 	beq	2c388 <__ieee754_pow+0x3d0>
   2c378:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   2c37c:	e59f340c 	ldr	r3, [pc, #1036]	; 2c790 <__ieee754_pow+0x7d8>
   2c380:	e1520003 	cmp	r2, r3
   2c384:	1a000040 	bne	2c48c <__ieee754_pow+0x4d4>
		z = ax;			/*x is +-0,+-inf,+-1*/
   2c388:	e24b4024 	sub	r4, fp, #36	; 0x24
   2c38c:	e8940018 	ldm	r4, {r3, r4}
   2c390:	e50b301c 	str	r3, [fp, #-28]
   2c394:	e50b4018 	str	r4, [fp, #-24]
		if(hy<0) z = one/z;	/* z = (1/|x|) */
   2c398:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   2c39c:	e3530000 	cmp	r3, #0
   2c3a0:	aa00000a 	bge	2c3d0 <__ieee754_pow+0x418>
   2c3a4:	e3a03000 	mov	r3, #0
   2c3a8:	e59f43e0 	ldr	r4, [pc, #992]	; 2c790 <__ieee754_pow+0x7d8>
   2c3ac:	e1a00003 	mov	r0, r3
   2c3b0:	e1a01004 	mov	r1, r4
   2c3b4:	e24b301c 	sub	r3, fp, #28
   2c3b8:	e893000c 	ldm	r3, {r2, r3}
   2c3bc:	ebffa273 	bl	14d90 <__aeabi_ddiv>
   2c3c0:	e1a03000 	mov	r3, r0
   2c3c4:	e1a04001 	mov	r4, r1
   2c3c8:	e50b301c 	str	r3, [fp, #-28]
   2c3cc:	e50b4018 	str	r4, [fp, #-24]
		if(hx<0) {
   2c3d0:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   2c3d4:	e3530000 	cmp	r3, #0
   2c3d8:	aa000028 	bge	2c480 <__ieee754_pow+0x4c8>
		    if(((ix-0x3ff00000)|yisint)==0) {
   2c3dc:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   2c3e0:	e2833103 	add	r3, r3, #-1073741824	; 0xc0000000
   2c3e4:	e2833601 	add	r3, r3, #1048576	; 0x100000
   2c3e8:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   2c3ec:	e1833002 	orr	r3, r3, r2
   2c3f0:	e3530000 	cmp	r3, #0
   2c3f4:	1a000019 	bne	2c460 <__ieee754_pow+0x4a8>
			z = (z-z)/(z-z); /* (-1)**non-int is NaN */
   2c3f8:	e24b101c 	sub	r1, fp, #28
   2c3fc:	e8910003 	ldm	r1, {r0, r1}
   2c400:	e24b301c 	sub	r3, fp, #28
   2c404:	e893000c 	ldm	r3, {r2, r3}
   2c408:	ebffa0b7 	bl	146ec <__aeabi_dsub>
   2c40c:	e1a03000 	mov	r3, r0
   2c410:	e1a04001 	mov	r4, r1
   2c414:	e1a05003 	mov	r5, r3
   2c418:	e1a06004 	mov	r6, r4
   2c41c:	e24b101c 	sub	r1, fp, #28
   2c420:	e8910003 	ldm	r1, {r0, r1}
   2c424:	e24b301c 	sub	r3, fp, #28
   2c428:	e893000c 	ldm	r3, {r2, r3}
   2c42c:	ebffa0ae 	bl	146ec <__aeabi_dsub>
   2c430:	e1a03000 	mov	r3, r0
   2c434:	e1a04001 	mov	r4, r1
   2c438:	e1a00005 	mov	r0, r5
   2c43c:	e1a01006 	mov	r1, r6
   2c440:	e1a02003 	mov	r2, r3
   2c444:	e1a03004 	mov	r3, r4
   2c448:	ebffa250 	bl	14d90 <__aeabi_ddiv>
   2c44c:	e1a03000 	mov	r3, r0
   2c450:	e1a04001 	mov	r4, r1
   2c454:	e50b301c 	str	r3, [fp, #-28]
   2c458:	e50b4018 	str	r4, [fp, #-24]
   2c45c:	ea000007 	b	2c480 <__ieee754_pow+0x4c8>
		    } else if(yisint==1) 
   2c460:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   2c464:	e3530001 	cmp	r3, #1
   2c468:	1a000004 	bne	2c480 <__ieee754_pow+0x4c8>
			z = -z;		/* (x<0)**odd = -(|x|**odd) */
   2c46c:	e51b301c 	ldr	r3, [fp, #-28]
   2c470:	e50b301c 	str	r3, [fp, #-28]
   2c474:	e51b3018 	ldr	r3, [fp, #-24]
   2c478:	e2233102 	eor	r3, r3, #-2147483648	; 0x80000000
   2c47c:	e50b3018 	str	r3, [fp, #-24]
		}
		return z;
   2c480:	e24b501c 	sub	r5, fp, #28
   2c484:	e8950030 	ldm	r5, {r4, r5}
   2c488:	ea000660 	b	2de10 <__ieee754_pow+0x1e58>
    /* (x<0)**(non-int) is NaN */
    /* REDHAT LOCAL: This used to be
	if((((hx>>31)+1)|yisint)==0) return (x-x)/(x-x);
       but ANSI C says a right shift of a signed negative quantity is
       implementation defined.  */
	if(((((__uint32_t)hx>>31)-1)|yisint)==0) return (x-x)/(x-x);
   2c48c:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   2c490:	e1a03fa3 	lsr	r3, r3, #31
   2c494:	e2432001 	sub	r2, r3, #1
   2c498:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   2c49c:	e1823003 	orr	r3, r2, r3
   2c4a0:	e3530000 	cmp	r3, #0
   2c4a4:	1a000019 	bne	2c510 <__ieee754_pow+0x558>
   2c4a8:	e24b1f5b 	sub	r1, fp, #364	; 0x16c
   2c4ac:	e8910003 	ldm	r1, {r0, r1}
   2c4b0:	e24b3f5b 	sub	r3, fp, #364	; 0x16c
   2c4b4:	e893000c 	ldm	r3, {r2, r3}
   2c4b8:	ebffa08b 	bl	146ec <__aeabi_dsub>
   2c4bc:	e1a03000 	mov	r3, r0
   2c4c0:	e1a04001 	mov	r4, r1
   2c4c4:	e1a05003 	mov	r5, r3
   2c4c8:	e1a06004 	mov	r6, r4
   2c4cc:	e24b1f5b 	sub	r1, fp, #364	; 0x16c
   2c4d0:	e8910003 	ldm	r1, {r0, r1}
   2c4d4:	e24b3f5b 	sub	r3, fp, #364	; 0x16c
   2c4d8:	e893000c 	ldm	r3, {r2, r3}
   2c4dc:	ebffa082 	bl	146ec <__aeabi_dsub>
   2c4e0:	e1a03000 	mov	r3, r0
   2c4e4:	e1a04001 	mov	r4, r1
   2c4e8:	e1a00005 	mov	r0, r5
   2c4ec:	e1a01006 	mov	r1, r6
   2c4f0:	e1a02003 	mov	r2, r3
   2c4f4:	e1a03004 	mov	r3, r4
   2c4f8:	ebffa224 	bl	14d90 <__aeabi_ddiv>
   2c4fc:	e1a03000 	mov	r3, r0
   2c500:	e1a04001 	mov	r4, r1
   2c504:	e1a05004 	mov	r5, r4
   2c508:	e1a04003 	mov	r4, r3
   2c50c:	ea00063f 	b	2de10 <__ieee754_pow+0x1e58>

    /* |y| is huge */
	if(iy>0x41e00000) { /* if |y| > 2**31 */
   2c510:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   2c514:	e59f3268 	ldr	r3, [pc, #616]	; 2c784 <__ieee754_pow+0x7cc>
   2c518:	e1520003 	cmp	r2, r3
   2c51c:	da000120 	ble	2c9a4 <__ieee754_pow+0x9ec>
	    if(iy>0x43f00000){	/* if |y| > 2**64, must o/uflow */
   2c520:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   2c524:	e59f325c 	ldr	r3, [pc, #604]	; 2c788 <__ieee754_pow+0x7d0>
   2c528:	e1520003 	cmp	r2, r3
   2c52c:	da000045 	ble	2c648 <__ieee754_pow+0x690>
		if(ix<=0x3fefffff) return (hy<0)? huge*huge:tiny*tiny;
   2c530:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   2c534:	e59f3240 	ldr	r3, [pc, #576]	; 2c77c <__ieee754_pow+0x7c4>
   2c538:	e1520003 	cmp	r2, r3
   2c53c:	ca00001e 	bgt	2c5bc <__ieee754_pow+0x604>
   2c540:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   2c544:	e3530000 	cmp	r3, #0
   2c548:	aa00000d 	bge	2c584 <__ieee754_pow+0x5cc>
   2c54c:	e28f2f83 	add	r2, pc, #524	; 0x20c
   2c550:	e8920006 	ldm	r2, {r1, r2}
   2c554:	e28f4f81 	add	r4, pc, #516	; 0x204
   2c558:	e8940018 	ldm	r4, {r3, r4}
   2c55c:	e1a00001 	mov	r0, r1
   2c560:	e1a01002 	mov	r1, r2
   2c564:	e1a02003 	mov	r2, r3
   2c568:	e1a03004 	mov	r3, r4
   2c56c:	ebffa163 	bl	14b00 <__aeabi_dmul>
   2c570:	e1a03000 	mov	r3, r0
   2c574:	e1a04001 	mov	r4, r1
   2c578:	e1a05004 	mov	r5, r4
   2c57c:	e1a04003 	mov	r4, r3
   2c580:	ea000622 	b	2de10 <__ieee754_pow+0x1e58>
   2c584:	e28f2f77 	add	r2, pc, #476	; 0x1dc
   2c588:	e8920006 	ldm	r2, {r1, r2}
   2c58c:	e28f4f75 	add	r4, pc, #468	; 0x1d4
   2c590:	e8940018 	ldm	r4, {r3, r4}
   2c594:	e1a00001 	mov	r0, r1
   2c598:	e1a01002 	mov	r1, r2
   2c59c:	e1a02003 	mov	r2, r3
   2c5a0:	e1a03004 	mov	r3, r4
   2c5a4:	ebffa155 	bl	14b00 <__aeabi_dmul>
   2c5a8:	e1a03000 	mov	r3, r0
   2c5ac:	e1a04001 	mov	r4, r1
   2c5b0:	e1a05004 	mov	r5, r4
   2c5b4:	e1a04003 	mov	r4, r3
   2c5b8:	ea000614 	b	2de10 <__ieee754_pow+0x1e58>
		if(ix>=0x3ff00000) return (hy>0)? huge*huge:tiny*tiny;
   2c5bc:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   2c5c0:	e59f31b4 	ldr	r3, [pc, #436]	; 2c77c <__ieee754_pow+0x7c4>
   2c5c4:	e1520003 	cmp	r2, r3
   2c5c8:	da00001e 	ble	2c648 <__ieee754_pow+0x690>
   2c5cc:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   2c5d0:	e3530000 	cmp	r3, #0
   2c5d4:	da00000d 	ble	2c610 <__ieee754_pow+0x658>
   2c5d8:	e28f2d06 	add	r2, pc, #384	; 0x180
   2c5dc:	e8920006 	ldm	r2, {r1, r2}
   2c5e0:	e28f4f5e 	add	r4, pc, #376	; 0x178
   2c5e4:	e8940018 	ldm	r4, {r3, r4}
   2c5e8:	e1a00001 	mov	r0, r1
   2c5ec:	e1a01002 	mov	r1, r2
   2c5f0:	e1a02003 	mov	r2, r3
   2c5f4:	e1a03004 	mov	r3, r4
   2c5f8:	ebffa140 	bl	14b00 <__aeabi_dmul>
   2c5fc:	e1a03000 	mov	r3, r0
   2c600:	e1a04001 	mov	r4, r1
   2c604:	e1a05004 	mov	r5, r4
   2c608:	e1a04003 	mov	r4, r3
   2c60c:	ea0005ff 	b	2de10 <__ieee754_pow+0x1e58>
   2c610:	e28f2e15 	add	r2, pc, #336	; 0x150
   2c614:	e8920006 	ldm	r2, {r1, r2}
   2c618:	e28f4f52 	add	r4, pc, #328	; 0x148
   2c61c:	e8940018 	ldm	r4, {r3, r4}
   2c620:	e1a00001 	mov	r0, r1
   2c624:	e1a01002 	mov	r1, r2
   2c628:	e1a02003 	mov	r2, r3
   2c62c:	e1a03004 	mov	r3, r4
   2c630:	ebffa132 	bl	14b00 <__aeabi_dmul>
   2c634:	e1a03000 	mov	r3, r0
   2c638:	e1a04001 	mov	r4, r1
   2c63c:	e1a05004 	mov	r5, r4
   2c640:	e1a04003 	mov	r4, r3
   2c644:	ea0005f1 	b	2de10 <__ieee754_pow+0x1e58>
	    }
	/* over/underflow if x is not close to one */
	    if(ix<0x3fefffff) return (hy<0)? huge*huge:tiny*tiny;
   2c648:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   2c64c:	e59f3138 	ldr	r3, [pc, #312]	; 2c78c <__ieee754_pow+0x7d4>
   2c650:	e1520003 	cmp	r2, r3
   2c654:	ca00001e 	bgt	2c6d4 <__ieee754_pow+0x71c>
   2c658:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   2c65c:	e3530000 	cmp	r3, #0
   2c660:	aa00000d 	bge	2c69c <__ieee754_pow+0x6e4>
   2c664:	e28f20f4 	add	r2, pc, #244	; 0xf4
   2c668:	e8920006 	ldm	r2, {r1, r2}
   2c66c:	e28f40ec 	add	r4, pc, #236	; 0xec
   2c670:	e8940018 	ldm	r4, {r3, r4}
   2c674:	e1a00001 	mov	r0, r1
   2c678:	e1a01002 	mov	r1, r2
   2c67c:	e1a02003 	mov	r2, r3
   2c680:	e1a03004 	mov	r3, r4
   2c684:	ebffa11d 	bl	14b00 <__aeabi_dmul>
   2c688:	e1a03000 	mov	r3, r0
   2c68c:	e1a04001 	mov	r4, r1
   2c690:	e1a05004 	mov	r5, r4
   2c694:	e1a04003 	mov	r4, r3
   2c698:	ea0005dc 	b	2de10 <__ieee754_pow+0x1e58>
   2c69c:	e28f20c4 	add	r2, pc, #196	; 0xc4
   2c6a0:	e8920006 	ldm	r2, {r1, r2}
   2c6a4:	e28f40bc 	add	r4, pc, #188	; 0xbc
   2c6a8:	e8940018 	ldm	r4, {r3, r4}
   2c6ac:	e1a00001 	mov	r0, r1
   2c6b0:	e1a01002 	mov	r1, r2
   2c6b4:	e1a02003 	mov	r2, r3
   2c6b8:	e1a03004 	mov	r3, r4
   2c6bc:	ebffa10f 	bl	14b00 <__aeabi_dmul>
   2c6c0:	e1a03000 	mov	r3, r0
   2c6c4:	e1a04001 	mov	r4, r1
   2c6c8:	e1a05004 	mov	r5, r4
   2c6cc:	e1a04003 	mov	r4, r3
   2c6d0:	ea0005ce 	b	2de10 <__ieee754_pow+0x1e58>
	    if(ix>0x3ff00000) return (hy>0)? huge*huge:tiny*tiny;
   2c6d4:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   2c6d8:	e59f30b0 	ldr	r3, [pc, #176]	; 2c790 <__ieee754_pow+0x7d8>
   2c6dc:	e1520003 	cmp	r2, r3
   2c6e0:	da00002c 	ble	2c798 <__ieee754_pow+0x7e0>
   2c6e4:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   2c6e8:	e3530000 	cmp	r3, #0
   2c6ec:	da00000d 	ble	2c728 <__ieee754_pow+0x770>
   2c6f0:	e28f2068 	add	r2, pc, #104	; 0x68
   2c6f4:	e8920006 	ldm	r2, {r1, r2}
   2c6f8:	e28f4060 	add	r4, pc, #96	; 0x60
   2c6fc:	e8940018 	ldm	r4, {r3, r4}
   2c700:	e1a00001 	mov	r0, r1
   2c704:	e1a01002 	mov	r1, r2
   2c708:	e1a02003 	mov	r2, r3
   2c70c:	e1a03004 	mov	r3, r4
   2c710:	ebffa0fa 	bl	14b00 <__aeabi_dmul>
   2c714:	e1a03000 	mov	r3, r0
   2c718:	e1a04001 	mov	r4, r1
   2c71c:	e1a05004 	mov	r5, r4
   2c720:	e1a04003 	mov	r4, r3
   2c724:	ea0005b9 	b	2de10 <__ieee754_pow+0x1e58>
   2c728:	e28f2038 	add	r2, pc, #56	; 0x38
   2c72c:	e8920006 	ldm	r2, {r1, r2}
   2c730:	e28f4030 	add	r4, pc, #48	; 0x30
   2c734:	e8940018 	ldm	r4, {r3, r4}
   2c738:	e1a00001 	mov	r0, r1
   2c73c:	e1a01002 	mov	r1, r2
   2c740:	e1a02003 	mov	r2, r3
   2c744:	e1a03004 	mov	r3, r4
   2c748:	ebffa0ec 	bl	14b00 <__aeabi_dmul>
   2c74c:	e1a03000 	mov	r3, r0
   2c750:	e1a04001 	mov	r4, r1
   2c754:	e1a05004 	mov	r5, r4
   2c758:	e1a04003 	mov	r4, r3
   2c75c:	ea0005ab 	b	2de10 <__ieee754_pow+0x1e58>
   2c760:	8800759c 	.word	0x8800759c
   2c764:	7e37e43c 	.word	0x7e37e43c
   2c768:	c2f8f359 	.word	0xc2f8f359
   2c76c:	01a56e1f 	.word	0x01a56e1f
   2c770:	7ff00000 	.word	0x7ff00000
   2c774:	000335c0 	.word	0x000335c0
   2c778:	433fffff 	.word	0x433fffff
   2c77c:	3fefffff 	.word	0x3fefffff
   2c780:	3fe00000 	.word	0x3fe00000
   2c784:	41e00000 	.word	0x41e00000
   2c788:	43f00000 	.word	0x43f00000
   2c78c:	3feffffe 	.word	0x3feffffe
   2c790:	3ff00000 	.word	0x3ff00000
   2c794:	3fd00000 	.word	0x3fd00000
	/* now |1-x| is tiny <= 2**-20, suffice to compute 
	   log(x) by x-x^2/2+x^3/3-x^4/4 */
	    t = ax-1;		/* t has 20 trailing zeros */
   2c798:	e24b1024 	sub	r1, fp, #36	; 0x24
   2c79c:	e8910003 	ldm	r1, {r0, r1}
   2c7a0:	e3a02000 	mov	r2, #0
   2c7a4:	e51f301c 	ldr	r3, [pc, #-28]	; 2c790 <__ieee754_pow+0x7d8>
   2c7a8:	ebff9fcf 	bl	146ec <__aeabi_dsub>
   2c7ac:	e1a03000 	mov	r3, r0
   2c7b0:	e1a04001 	mov	r4, r1
   2c7b4:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   2c7b8:	e50b4070 	str	r4, [fp, #-112]	; 0x70
	    w = (t*t)*(0.5-t*(0.3333333333333333333333-t*0.25));
   2c7bc:	e24b1074 	sub	r1, fp, #116	; 0x74
   2c7c0:	e8910003 	ldm	r1, {r0, r1}
   2c7c4:	e24b3074 	sub	r3, fp, #116	; 0x74
   2c7c8:	e893000c 	ldm	r3, {r2, r3}
   2c7cc:	ebffa0cb 	bl	14b00 <__aeabi_dmul>
   2c7d0:	e1a03000 	mov	r3, r0
   2c7d4:	e1a04001 	mov	r4, r1
   2c7d8:	e1a05003 	mov	r5, r3
   2c7dc:	e1a06004 	mov	r6, r4
   2c7e0:	e24b1074 	sub	r1, fp, #116	; 0x74
   2c7e4:	e8910003 	ldm	r1, {r0, r1}
   2c7e8:	e3a02000 	mov	r2, #0
   2c7ec:	e51f3060 	ldr	r3, [pc, #-96]	; 2c794 <__ieee754_pow+0x7dc>
   2c7f0:	ebffa0c2 	bl	14b00 <__aeabi_dmul>
   2c7f4:	e1a03000 	mov	r3, r0
   2c7f8:	e1a04001 	mov	r4, r1
   2c7fc:	e28f1f9f 	add	r1, pc, #636	; 0x27c
   2c800:	e8910003 	ldm	r1, {r0, r1}
   2c804:	e1a02003 	mov	r2, r3
   2c808:	e1a03004 	mov	r3, r4
   2c80c:	ebff9fb6 	bl	146ec <__aeabi_dsub>
   2c810:	e1a03000 	mov	r3, r0
   2c814:	e1a04001 	mov	r4, r1
   2c818:	e1a00003 	mov	r0, r3
   2c81c:	e1a01004 	mov	r1, r4
   2c820:	e24b3074 	sub	r3, fp, #116	; 0x74
   2c824:	e893000c 	ldm	r3, {r2, r3}
   2c828:	ebffa0b4 	bl	14b00 <__aeabi_dmul>
   2c82c:	e1a03000 	mov	r3, r0
   2c830:	e1a04001 	mov	r4, r1
   2c834:	e3a00000 	mov	r0, #0
   2c838:	e59f1258 	ldr	r1, [pc, #600]	; 2ca98 <__ieee754_pow+0xae0>
   2c83c:	e1a02003 	mov	r2, r3
   2c840:	e1a03004 	mov	r3, r4
   2c844:	ebff9fa8 	bl	146ec <__aeabi_dsub>
   2c848:	e1a03000 	mov	r3, r0
   2c84c:	e1a04001 	mov	r4, r1
   2c850:	e1a00005 	mov	r0, r5
   2c854:	e1a01006 	mov	r1, r6
   2c858:	e1a02003 	mov	r2, r3
   2c85c:	e1a03004 	mov	r3, r4
   2c860:	ebffa0a6 	bl	14b00 <__aeabi_dmul>
   2c864:	e1a03000 	mov	r3, r0
   2c868:	e1a04001 	mov	r4, r1
   2c86c:	e50b307c 	str	r3, [fp, #-124]	; 0x7c
   2c870:	e50b4078 	str	r4, [fp, #-120]	; 0x78
	    u = ivln2_h*t;	/* ivln2_h has 21 sig. bits */
   2c874:	e3a03206 	mov	r3, #1610612736	; 0x60000000
   2c878:	e59f421c 	ldr	r4, [pc, #540]	; 2ca9c <__ieee754_pow+0xae4>
   2c87c:	e1a00003 	mov	r0, r3
   2c880:	e1a01004 	mov	r1, r4
   2c884:	e24b3074 	sub	r3, fp, #116	; 0x74
   2c888:	e893000c 	ldm	r3, {r2, r3}
   2c88c:	ebffa09b 	bl	14b00 <__aeabi_dmul>
   2c890:	e1a03000 	mov	r3, r0
   2c894:	e1a04001 	mov	r4, r1
   2c898:	e50b3084 	str	r3, [fp, #-132]	; 0x84
   2c89c:	e50b4080 	str	r4, [fp, #-128]	; 0x80
	    v = t*ivln2_l-w*ivln2;
   2c8a0:	e28f4e1e 	add	r4, pc, #480	; 0x1e0
   2c8a4:	e8940018 	ldm	r4, {r3, r4}
   2c8a8:	e1a00003 	mov	r0, r3
   2c8ac:	e1a01004 	mov	r1, r4
   2c8b0:	e24b3074 	sub	r3, fp, #116	; 0x74
   2c8b4:	e893000c 	ldm	r3, {r2, r3}
   2c8b8:	ebffa090 	bl	14b00 <__aeabi_dmul>
   2c8bc:	e1a03000 	mov	r3, r0
   2c8c0:	e1a04001 	mov	r4, r1
   2c8c4:	e1a05003 	mov	r5, r3
   2c8c8:	e1a06004 	mov	r6, r4
   2c8cc:	e28f4f6f 	add	r4, pc, #444	; 0x1bc
   2c8d0:	e8940018 	ldm	r4, {r3, r4}
   2c8d4:	e1a00003 	mov	r0, r3
   2c8d8:	e1a01004 	mov	r1, r4
   2c8dc:	e24b307c 	sub	r3, fp, #124	; 0x7c
   2c8e0:	e893000c 	ldm	r3, {r2, r3}
   2c8e4:	ebffa085 	bl	14b00 <__aeabi_dmul>
   2c8e8:	e1a03000 	mov	r3, r0
   2c8ec:	e1a04001 	mov	r4, r1
   2c8f0:	e1a00005 	mov	r0, r5
   2c8f4:	e1a01006 	mov	r1, r6
   2c8f8:	e1a02003 	mov	r2, r3
   2c8fc:	e1a03004 	mov	r3, r4
   2c900:	ebff9f79 	bl	146ec <__aeabi_dsub>
   2c904:	e1a03000 	mov	r3, r0
   2c908:	e1a04001 	mov	r4, r1
   2c90c:	e50b308c 	str	r3, [fp, #-140]	; 0x8c
   2c910:	e50b4088 	str	r4, [fp, #-136]	; 0x88
	    t1 = u+v;
   2c914:	e24b1084 	sub	r1, fp, #132	; 0x84
   2c918:	e8910003 	ldm	r1, {r0, r1}
   2c91c:	e24b308c 	sub	r3, fp, #140	; 0x8c
   2c920:	e893000c 	ldm	r3, {r2, r3}
   2c924:	ebff9f71 	bl	146f0 <__adddf3>
   2c928:	e1a03000 	mov	r3, r0
   2c92c:	e1a04001 	mov	r4, r1
   2c930:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2c934:	e50b4030 	str	r4, [fp, #-48]	; 0x30
	    SET_LOW_WORD(t1,0);
   2c938:	e24b4034 	sub	r4, fp, #52	; 0x34
   2c93c:	e8940018 	ldm	r4, {r3, r4}
   2c940:	e50b30fc 	str	r3, [fp, #-252]	; 0xfc
   2c944:	e50b40f8 	str	r4, [fp, #-248]	; 0xf8
   2c948:	e3a03000 	mov	r3, #0
   2c94c:	e50b30fc 	str	r3, [fp, #-252]	; 0xfc
   2c950:	e24b40fc 	sub	r4, fp, #252	; 0xfc
   2c954:	e8940018 	ldm	r4, {r3, r4}
   2c958:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2c95c:	e50b4030 	str	r4, [fp, #-48]	; 0x30
	    t2 = v-(t1-u);
   2c960:	e24b1034 	sub	r1, fp, #52	; 0x34
   2c964:	e8910003 	ldm	r1, {r0, r1}
   2c968:	e24b3084 	sub	r3, fp, #132	; 0x84
   2c96c:	e893000c 	ldm	r3, {r2, r3}
   2c970:	ebff9f5d 	bl	146ec <__aeabi_dsub>
   2c974:	e1a03000 	mov	r3, r0
   2c978:	e1a04001 	mov	r4, r1
   2c97c:	e24b108c 	sub	r1, fp, #140	; 0x8c
   2c980:	e8910003 	ldm	r1, {r0, r1}
   2c984:	e1a02003 	mov	r2, r3
   2c988:	e1a03004 	mov	r3, r4
   2c98c:	ebff9f56 	bl	146ec <__aeabi_dsub>
   2c990:	e1a03000 	mov	r3, r0
   2c994:	e1a04001 	mov	r4, r1
   2c998:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2c99c:	e50b4038 	str	r4, [fp, #-56]	; 0x38
   2c9a0:	ea000286 	b	2d3c0 <__ieee754_pow+0x1408>
	} else {
	    double s2,s_h,s_l,t_h,t_l;
	    n = 0;
   2c9a4:	e3a03000 	mov	r3, #0
   2c9a8:	e50b3050 	str	r3, [fp, #-80]	; 0x50
	/* take care subnormal number */
	    if(ix<0x00100000)
   2c9ac:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   2c9b0:	e3530601 	cmp	r3, #1048576	; 0x100000
   2c9b4:	aa000013 	bge	2ca08 <__ieee754_pow+0xa50>
		{ax *= two53; n -= 53; GET_HIGH_WORD(ix,ax); }
   2c9b8:	e3a03000 	mov	r3, #0
   2c9bc:	e59f40dc 	ldr	r4, [pc, #220]	; 2caa0 <__ieee754_pow+0xae8>
   2c9c0:	e24b1024 	sub	r1, fp, #36	; 0x24
   2c9c4:	e8910003 	ldm	r1, {r0, r1}
   2c9c8:	e1a02003 	mov	r2, r3
   2c9cc:	e1a03004 	mov	r3, r4
   2c9d0:	ebffa04a 	bl	14b00 <__aeabi_dmul>
   2c9d4:	e1a03000 	mov	r3, r0
   2c9d8:	e1a04001 	mov	r4, r1
   2c9dc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2c9e0:	e50b4020 	str	r4, [fp, #-32]
   2c9e4:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   2c9e8:	e2433035 	sub	r3, r3, #53	; 0x35
   2c9ec:	e50b3050 	str	r3, [fp, #-80]	; 0x50
   2c9f0:	e24b4024 	sub	r4, fp, #36	; 0x24
   2c9f4:	e8940018 	ldm	r4, {r3, r4}
   2c9f8:	e50b3104 	str	r3, [fp, #-260]	; 0x104
   2c9fc:	e50b4100 	str	r4, [fp, #-256]	; 0x100
   2ca00:	e51b3100 	ldr	r3, [fp, #-256]	; 0x100
   2ca04:	e50b3054 	str	r3, [fp, #-84]	; 0x54
	    n  += ((ix)>>20)-0x3ff;
   2ca08:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   2ca0c:	e1a03a43 	asr	r3, r3, #20
   2ca10:	e2433fff 	sub	r3, r3, #1020	; 0x3fc
   2ca14:	e2433003 	sub	r3, r3, #3
   2ca18:	e51b2050 	ldr	r2, [fp, #-80]	; 0x50
   2ca1c:	e0823003 	add	r3, r2, r3
   2ca20:	e50b3050 	str	r3, [fp, #-80]	; 0x50
	    j  = ix&0x000fffff;
   2ca24:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   2ca28:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
   2ca2c:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   2ca30:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
	/* determine interval */
	    ix = j|0x3ff00000;		/* normalize ix */
   2ca34:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   2ca38:	e38335ff 	orr	r3, r3, #1069547520	; 0x3fc00000
   2ca3c:	e3833603 	orr	r3, r3, #3145728	; 0x300000
   2ca40:	e50b3054 	str	r3, [fp, #-84]	; 0x54
	    if(j<=0x3988E) k=0;		/* |x|<sqrt(3/2) */
   2ca44:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
   2ca48:	e59f3054 	ldr	r3, [pc, #84]	; 2caa4 <__ieee754_pow+0xaec>
   2ca4c:	e1520003 	cmp	r2, r3
   2ca50:	ca000002 	bgt	2ca60 <__ieee754_pow+0xaa8>
   2ca54:	e3a03000 	mov	r3, #0
   2ca58:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   2ca5c:	ea00001c 	b	2cad4 <__ieee754_pow+0xb1c>
	    else if(j<0xBB67A) k=1;	/* |x|<sqrt(3)   */
   2ca60:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
   2ca64:	e59f303c 	ldr	r3, [pc, #60]	; 2caa8 <__ieee754_pow+0xaf0>
   2ca68:	e1520003 	cmp	r2, r3
   2ca6c:	ca000010 	bgt	2cab4 <__ieee754_pow+0xafc>
   2ca70:	e3a03001 	mov	r3, #1
   2ca74:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   2ca78:	ea000015 	b	2cad4 <__ieee754_pow+0xb1c>
   2ca7c:	e1a00000 	nop			; (mov r0, r0)
   2ca80:	55555555 	.word	0x55555555
   2ca84:	3fd55555 	.word	0x3fd55555
   2ca88:	f85ddf44 	.word	0xf85ddf44
   2ca8c:	3e54ae0b 	.word	0x3e54ae0b
   2ca90:	652b82fe 	.word	0x652b82fe
   2ca94:	3ff71547 	.word	0x3ff71547
   2ca98:	3fe00000 	.word	0x3fe00000
   2ca9c:	3ff71547 	.word	0x3ff71547
   2caa0:	43400000 	.word	0x43400000
   2caa4:	0003988e 	.word	0x0003988e
   2caa8:	000bb679 	.word	0x000bb679
   2caac:	3ff00000 	.word	0x3ff00000
   2cab0:	000334b8 	.word	0x000334b8
	    else {k=0;n+=1;ix -= 0x00100000;}
   2cab4:	e3a03000 	mov	r3, #0
   2cab8:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   2cabc:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   2cac0:	e2833001 	add	r3, r3, #1
   2cac4:	e50b3050 	str	r3, [fp, #-80]	; 0x50
   2cac8:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   2cacc:	e2433601 	sub	r3, r3, #1048576	; 0x100000
   2cad0:	e50b3054 	str	r3, [fp, #-84]	; 0x54
	    SET_HIGH_WORD(ax,ix);
   2cad4:	e24b4024 	sub	r4, fp, #36	; 0x24
   2cad8:	e8940018 	ldm	r4, {r3, r4}
   2cadc:	e50b310c 	str	r3, [fp, #-268]	; 0x10c
   2cae0:	e50b4108 	str	r4, [fp, #-264]	; 0x108
   2cae4:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   2cae8:	e50b3108 	str	r3, [fp, #-264]	; 0x108
   2caec:	e24b4f43 	sub	r4, fp, #268	; 0x10c
   2caf0:	e8940018 	ldm	r4, {r3, r4}
   2caf4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2caf8:	e50b4020 	str	r4, [fp, #-32]

	/* compute s = s_h+s_l = (x-1)/(x+1) or (x-1.5)/(x+1.5) */
	    u = ax-bp[k];		/* bp[0]=1.0, bp[1]=1.5 */
   2cafc:	e51f2054 	ldr	r2, [pc, #-84]	; 2cab0 <__ieee754_pow+0xaf8>
   2cb00:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2cb04:	e1a03183 	lsl	r3, r3, #3
   2cb08:	e0823003 	add	r3, r2, r3
   2cb0c:	e8930018 	ldm	r3, {r3, r4}
   2cb10:	e24b1024 	sub	r1, fp, #36	; 0x24
   2cb14:	e8910003 	ldm	r1, {r0, r1}
   2cb18:	e1a02003 	mov	r2, r3
   2cb1c:	e1a03004 	mov	r3, r4
   2cb20:	ebff9ef1 	bl	146ec <__aeabi_dsub>
   2cb24:	e1a03000 	mov	r3, r0
   2cb28:	e1a04001 	mov	r4, r1
   2cb2c:	e50b3084 	str	r3, [fp, #-132]	; 0x84
   2cb30:	e50b4080 	str	r4, [fp, #-128]	; 0x80
	    v = one/(ax+bp[k]);
   2cb34:	e3a05000 	mov	r5, #0
   2cb38:	e51f6094 	ldr	r6, [pc, #-148]	; 2caac <__ieee754_pow+0xaf4>
   2cb3c:	e51f2094 	ldr	r2, [pc, #-148]	; 2cab0 <__ieee754_pow+0xaf8>
   2cb40:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2cb44:	e1a03183 	lsl	r3, r3, #3
   2cb48:	e0823003 	add	r3, r2, r3
   2cb4c:	e8930018 	ldm	r3, {r3, r4}
   2cb50:	e1a00003 	mov	r0, r3
   2cb54:	e1a01004 	mov	r1, r4
   2cb58:	e24b3024 	sub	r3, fp, #36	; 0x24
   2cb5c:	e893000c 	ldm	r3, {r2, r3}
   2cb60:	ebff9ee2 	bl	146f0 <__adddf3>
   2cb64:	e1a03000 	mov	r3, r0
   2cb68:	e1a04001 	mov	r4, r1
   2cb6c:	e1a00005 	mov	r0, r5
   2cb70:	e1a01006 	mov	r1, r6
   2cb74:	e1a02003 	mov	r2, r3
   2cb78:	e1a03004 	mov	r3, r4
   2cb7c:	ebffa083 	bl	14d90 <__aeabi_ddiv>
   2cb80:	e1a03000 	mov	r3, r0
   2cb84:	e1a04001 	mov	r4, r1
   2cb88:	e50b308c 	str	r3, [fp, #-140]	; 0x8c
   2cb8c:	e50b4088 	str	r4, [fp, #-136]	; 0x88
	    s = u*v;
   2cb90:	e24b1084 	sub	r1, fp, #132	; 0x84
   2cb94:	e8910003 	ldm	r1, {r0, r1}
   2cb98:	e24b308c 	sub	r3, fp, #140	; 0x8c
   2cb9c:	e893000c 	ldm	r3, {r2, r3}
   2cba0:	ebff9fd6 	bl	14b00 <__aeabi_dmul>
   2cba4:	e1a03000 	mov	r3, r0
   2cba8:	e1a04001 	mov	r4, r1
   2cbac:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   2cbb0:	e50b4040 	str	r4, [fp, #-64]	; 0x40
	    s_h = s;
   2cbb4:	e24b4044 	sub	r4, fp, #68	; 0x44
   2cbb8:	e8940018 	ldm	r4, {r3, r4}
   2cbbc:	e50b3094 	str	r3, [fp, #-148]	; 0x94
   2cbc0:	e50b4090 	str	r4, [fp, #-144]	; 0x90
	    SET_LOW_WORD(s_h,0);
   2cbc4:	e24b4094 	sub	r4, fp, #148	; 0x94
   2cbc8:	e8940018 	ldm	r4, {r3, r4}
   2cbcc:	e50b3114 	str	r3, [fp, #-276]	; 0x114
   2cbd0:	e50b4110 	str	r4, [fp, #-272]	; 0x110
   2cbd4:	e3a03000 	mov	r3, #0
   2cbd8:	e50b3114 	str	r3, [fp, #-276]	; 0x114
   2cbdc:	e24b4f45 	sub	r4, fp, #276	; 0x114
   2cbe0:	e8940018 	ldm	r4, {r3, r4}
   2cbe4:	e50b3094 	str	r3, [fp, #-148]	; 0x94
   2cbe8:	e50b4090 	str	r4, [fp, #-144]	; 0x90
	/* t_h=ax+bp[k] High */
	    t_h = zero;
   2cbec:	e3a03000 	mov	r3, #0
   2cbf0:	e3a04000 	mov	r4, #0
   2cbf4:	e50b309c 	str	r3, [fp, #-156]	; 0x9c
   2cbf8:	e50b4098 	str	r4, [fp, #-152]	; 0x98
	    SET_HIGH_WORD(t_h,((ix>>1)|0x20000000)+0x00080000+(k<<18));
   2cbfc:	e24b409c 	sub	r4, fp, #156	; 0x9c
   2cc00:	e8940018 	ldm	r4, {r3, r4}
   2cc04:	e50b311c 	str	r3, [fp, #-284]	; 0x11c
   2cc08:	e50b4118 	str	r4, [fp, #-280]	; 0x118
   2cc0c:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   2cc10:	e1a030c3 	asr	r3, r3, #1
   2cc14:	e3833202 	orr	r3, r3, #536870912	; 0x20000000
   2cc18:	e2832702 	add	r2, r3, #524288	; 0x80000
   2cc1c:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2cc20:	e1a03903 	lsl	r3, r3, #18
   2cc24:	e0823003 	add	r3, r2, r3
   2cc28:	e50b3118 	str	r3, [fp, #-280]	; 0x118
   2cc2c:	e24b4f47 	sub	r4, fp, #284	; 0x11c
   2cc30:	e8940018 	ldm	r4, {r3, r4}
   2cc34:	e50b309c 	str	r3, [fp, #-156]	; 0x9c
   2cc38:	e50b4098 	str	r4, [fp, #-152]	; 0x98
	    t_l = ax - (t_h-bp[k]);
   2cc3c:	e51f2194 	ldr	r2, [pc, #-404]	; 2cab0 <__ieee754_pow+0xaf8>
   2cc40:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2cc44:	e1a03183 	lsl	r3, r3, #3
   2cc48:	e0823003 	add	r3, r2, r3
   2cc4c:	e8930018 	ldm	r3, {r3, r4}
   2cc50:	e24b109c 	sub	r1, fp, #156	; 0x9c
   2cc54:	e8910003 	ldm	r1, {r0, r1}
   2cc58:	e1a02003 	mov	r2, r3
   2cc5c:	e1a03004 	mov	r3, r4
   2cc60:	ebff9ea1 	bl	146ec <__aeabi_dsub>
   2cc64:	e1a03000 	mov	r3, r0
   2cc68:	e1a04001 	mov	r4, r1
   2cc6c:	e24b1024 	sub	r1, fp, #36	; 0x24
   2cc70:	e8910003 	ldm	r1, {r0, r1}
   2cc74:	e1a02003 	mov	r2, r3
   2cc78:	e1a03004 	mov	r3, r4
   2cc7c:	ebff9e9a 	bl	146ec <__aeabi_dsub>
   2cc80:	e1a03000 	mov	r3, r0
   2cc84:	e1a04001 	mov	r4, r1
   2cc88:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
   2cc8c:	e50b40a0 	str	r4, [fp, #-160]	; 0xa0
	    s_l = v*((u-s_h*t_h)-s_h*t_l);
   2cc90:	e24b1094 	sub	r1, fp, #148	; 0x94
   2cc94:	e8910003 	ldm	r1, {r0, r1}
   2cc98:	e24b309c 	sub	r3, fp, #156	; 0x9c
   2cc9c:	e893000c 	ldm	r3, {r2, r3}
   2cca0:	ebff9f96 	bl	14b00 <__aeabi_dmul>
   2cca4:	e1a03000 	mov	r3, r0
   2cca8:	e1a04001 	mov	r4, r1
   2ccac:	e24b1084 	sub	r1, fp, #132	; 0x84
   2ccb0:	e8910003 	ldm	r1, {r0, r1}
   2ccb4:	e1a02003 	mov	r2, r3
   2ccb8:	e1a03004 	mov	r3, r4
   2ccbc:	ebff9e8a 	bl	146ec <__aeabi_dsub>
   2ccc0:	e1a03000 	mov	r3, r0
   2ccc4:	e1a04001 	mov	r4, r1
   2ccc8:	e1a05003 	mov	r5, r3
   2cccc:	e1a06004 	mov	r6, r4
   2ccd0:	e24b1094 	sub	r1, fp, #148	; 0x94
   2ccd4:	e8910003 	ldm	r1, {r0, r1}
   2ccd8:	e24b30a4 	sub	r3, fp, #164	; 0xa4
   2ccdc:	e893000c 	ldm	r3, {r2, r3}
   2cce0:	ebff9f86 	bl	14b00 <__aeabi_dmul>
   2cce4:	e1a03000 	mov	r3, r0
   2cce8:	e1a04001 	mov	r4, r1
   2ccec:	e1a00005 	mov	r0, r5
   2ccf0:	e1a01006 	mov	r1, r6
   2ccf4:	e1a02003 	mov	r2, r3
   2ccf8:	e1a03004 	mov	r3, r4
   2ccfc:	ebff9e7a 	bl	146ec <__aeabi_dsub>
   2cd00:	e1a03000 	mov	r3, r0
   2cd04:	e1a04001 	mov	r4, r1
   2cd08:	e1a00003 	mov	r0, r3
   2cd0c:	e1a01004 	mov	r1, r4
   2cd10:	e24b308c 	sub	r3, fp, #140	; 0x8c
   2cd14:	e893000c 	ldm	r3, {r2, r3}
   2cd18:	ebff9f78 	bl	14b00 <__aeabi_dmul>
   2cd1c:	e1a03000 	mov	r3, r0
   2cd20:	e1a04001 	mov	r4, r1
   2cd24:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   2cd28:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
	/* compute log(ax) */
	    s2 = s*s;
   2cd2c:	e24b1044 	sub	r1, fp, #68	; 0x44
   2cd30:	e8910003 	ldm	r1, {r0, r1}
   2cd34:	e24b3044 	sub	r3, fp, #68	; 0x44
   2cd38:	e893000c 	ldm	r3, {r2, r3}
   2cd3c:	ebff9f6f 	bl	14b00 <__aeabi_dmul>
   2cd40:	e1a03000 	mov	r3, r0
   2cd44:	e1a04001 	mov	r4, r1
   2cd48:	e50b30b4 	str	r3, [fp, #-180]	; 0xb4
   2cd4c:	e50b40b0 	str	r4, [fp, #-176]	; 0xb0
	    r = s2*s2*(L1+s2*(L2+s2*(L3+s2*(L4+s2*(L5+s2*L6)))));
   2cd50:	e24b10b4 	sub	r1, fp, #180	; 0xb4
   2cd54:	e8910003 	ldm	r1, {r0, r1}
   2cd58:	e24b30b4 	sub	r3, fp, #180	; 0xb4
   2cd5c:	e893000c 	ldm	r3, {r2, r3}
   2cd60:	ebff9f66 	bl	14b00 <__aeabi_dmul>
   2cd64:	e1a03000 	mov	r3, r0
   2cd68:	e1a04001 	mov	r4, r1
   2cd6c:	e1a05003 	mov	r5, r3
   2cd70:	e1a06004 	mov	r6, r4
   2cd74:	e28f4ffb 	add	r4, pc, #1004	; 0x3ec
   2cd78:	e8940018 	ldm	r4, {r3, r4}
   2cd7c:	e1a00003 	mov	r0, r3
   2cd80:	e1a01004 	mov	r1, r4
   2cd84:	e24b30b4 	sub	r3, fp, #180	; 0xb4
   2cd88:	e893000c 	ldm	r3, {r2, r3}
   2cd8c:	ebff9f5b 	bl	14b00 <__aeabi_dmul>
   2cd90:	e1a03000 	mov	r3, r0
   2cd94:	e1a04001 	mov	r4, r1
   2cd98:	e1a01003 	mov	r1, r3
   2cd9c:	e1a02004 	mov	r2, r4
   2cda0:	e28f4ff2 	add	r4, pc, #968	; 0x3c8
   2cda4:	e8940018 	ldm	r4, {r3, r4}
   2cda8:	e1a00001 	mov	r0, r1
   2cdac:	e1a01002 	mov	r1, r2
   2cdb0:	e1a02003 	mov	r2, r3
   2cdb4:	e1a03004 	mov	r3, r4
   2cdb8:	ebff9e4c 	bl	146f0 <__adddf3>
   2cdbc:	e1a03000 	mov	r3, r0
   2cdc0:	e1a04001 	mov	r4, r1
   2cdc4:	e1a00003 	mov	r0, r3
   2cdc8:	e1a01004 	mov	r1, r4
   2cdcc:	e24b30b4 	sub	r3, fp, #180	; 0xb4
   2cdd0:	e893000c 	ldm	r3, {r2, r3}
   2cdd4:	ebff9f49 	bl	14b00 <__aeabi_dmul>
   2cdd8:	e1a03000 	mov	r3, r0
   2cddc:	e1a04001 	mov	r4, r1
   2cde0:	e1a01003 	mov	r1, r3
   2cde4:	e1a02004 	mov	r2, r4
   2cde8:	e28f4fe2 	add	r4, pc, #904	; 0x388
   2cdec:	e8940018 	ldm	r4, {r3, r4}
   2cdf0:	e1a00001 	mov	r0, r1
   2cdf4:	e1a01002 	mov	r1, r2
   2cdf8:	e1a02003 	mov	r2, r3
   2cdfc:	e1a03004 	mov	r3, r4
   2ce00:	ebff9e3a 	bl	146f0 <__adddf3>
   2ce04:	e1a03000 	mov	r3, r0
   2ce08:	e1a04001 	mov	r4, r1
   2ce0c:	e1a00003 	mov	r0, r3
   2ce10:	e1a01004 	mov	r1, r4
   2ce14:	e24b30b4 	sub	r3, fp, #180	; 0xb4
   2ce18:	e893000c 	ldm	r3, {r2, r3}
   2ce1c:	ebff9f37 	bl	14b00 <__aeabi_dmul>
   2ce20:	e1a03000 	mov	r3, r0
   2ce24:	e1a04001 	mov	r4, r1
   2ce28:	e1a01003 	mov	r1, r3
   2ce2c:	e1a02004 	mov	r2, r4
   2ce30:	e28f4fd2 	add	r4, pc, #840	; 0x348
   2ce34:	e8940018 	ldm	r4, {r3, r4}
   2ce38:	e1a00001 	mov	r0, r1
   2ce3c:	e1a01002 	mov	r1, r2
   2ce40:	e1a02003 	mov	r2, r3
   2ce44:	e1a03004 	mov	r3, r4
   2ce48:	ebff9e28 	bl	146f0 <__adddf3>
   2ce4c:	e1a03000 	mov	r3, r0
   2ce50:	e1a04001 	mov	r4, r1
   2ce54:	e1a00003 	mov	r0, r3
   2ce58:	e1a01004 	mov	r1, r4
   2ce5c:	e24b30b4 	sub	r3, fp, #180	; 0xb4
   2ce60:	e893000c 	ldm	r3, {r2, r3}
   2ce64:	ebff9f25 	bl	14b00 <__aeabi_dmul>
   2ce68:	e1a03000 	mov	r3, r0
   2ce6c:	e1a04001 	mov	r4, r1
   2ce70:	e1a01003 	mov	r1, r3
   2ce74:	e1a02004 	mov	r2, r4
   2ce78:	e28f4fc2 	add	r4, pc, #776	; 0x308
   2ce7c:	e8940018 	ldm	r4, {r3, r4}
   2ce80:	e1a00001 	mov	r0, r1
   2ce84:	e1a01002 	mov	r1, r2
   2ce88:	e1a02003 	mov	r2, r3
   2ce8c:	e1a03004 	mov	r3, r4
   2ce90:	ebff9e16 	bl	146f0 <__adddf3>
   2ce94:	e1a03000 	mov	r3, r0
   2ce98:	e1a04001 	mov	r4, r1
   2ce9c:	e1a00003 	mov	r0, r3
   2cea0:	e1a01004 	mov	r1, r4
   2cea4:	e24b30b4 	sub	r3, fp, #180	; 0xb4
   2cea8:	e893000c 	ldm	r3, {r2, r3}
   2ceac:	ebff9f13 	bl	14b00 <__aeabi_dmul>
   2ceb0:	e1a03000 	mov	r3, r0
   2ceb4:	e1a04001 	mov	r4, r1
   2ceb8:	e1a01003 	mov	r1, r3
   2cebc:	e1a02004 	mov	r2, r4
   2cec0:	e28f4fb2 	add	r4, pc, #712	; 0x2c8
   2cec4:	e8940018 	ldm	r4, {r3, r4}
   2cec8:	e1a00001 	mov	r0, r1
   2cecc:	e1a01002 	mov	r1, r2
   2ced0:	e1a02003 	mov	r2, r3
   2ced4:	e1a03004 	mov	r3, r4
   2ced8:	ebff9e04 	bl	146f0 <__adddf3>
   2cedc:	e1a03000 	mov	r3, r0
   2cee0:	e1a04001 	mov	r4, r1
   2cee4:	e1a00005 	mov	r0, r5
   2cee8:	e1a01006 	mov	r1, r6
   2ceec:	e1a02003 	mov	r2, r3
   2cef0:	e1a03004 	mov	r3, r4
   2cef4:	ebff9f01 	bl	14b00 <__aeabi_dmul>
   2cef8:	e1a03000 	mov	r3, r0
   2cefc:	e1a04001 	mov	r4, r1
   2cf00:	e50b30bc 	str	r3, [fp, #-188]	; 0xbc
   2cf04:	e50b40b8 	str	r4, [fp, #-184]	; 0xb8
	    r += s_l*(s_h+s);
   2cf08:	e24b1094 	sub	r1, fp, #148	; 0x94
   2cf0c:	e8910003 	ldm	r1, {r0, r1}
   2cf10:	e24b3044 	sub	r3, fp, #68	; 0x44
   2cf14:	e893000c 	ldm	r3, {r2, r3}
   2cf18:	ebff9df4 	bl	146f0 <__adddf3>
   2cf1c:	e1a03000 	mov	r3, r0
   2cf20:	e1a04001 	mov	r4, r1
   2cf24:	e1a00003 	mov	r0, r3
   2cf28:	e1a01004 	mov	r1, r4
   2cf2c:	e24b30ac 	sub	r3, fp, #172	; 0xac
   2cf30:	e893000c 	ldm	r3, {r2, r3}
   2cf34:	ebff9ef1 	bl	14b00 <__aeabi_dmul>
   2cf38:	e1a03000 	mov	r3, r0
   2cf3c:	e1a04001 	mov	r4, r1
   2cf40:	e24b10bc 	sub	r1, fp, #188	; 0xbc
   2cf44:	e8910003 	ldm	r1, {r0, r1}
   2cf48:	e1a02003 	mov	r2, r3
   2cf4c:	e1a03004 	mov	r3, r4
   2cf50:	ebff9de6 	bl	146f0 <__adddf3>
   2cf54:	e1a03000 	mov	r3, r0
   2cf58:	e1a04001 	mov	r4, r1
   2cf5c:	e50b30bc 	str	r3, [fp, #-188]	; 0xbc
   2cf60:	e50b40b8 	str	r4, [fp, #-184]	; 0xb8
	    s2  = s_h*s_h;
   2cf64:	e24b1094 	sub	r1, fp, #148	; 0x94
   2cf68:	e8910003 	ldm	r1, {r0, r1}
   2cf6c:	e24b3094 	sub	r3, fp, #148	; 0x94
   2cf70:	e893000c 	ldm	r3, {r2, r3}
   2cf74:	ebff9ee1 	bl	14b00 <__aeabi_dmul>
   2cf78:	e1a03000 	mov	r3, r0
   2cf7c:	e1a04001 	mov	r4, r1
   2cf80:	e50b30b4 	str	r3, [fp, #-180]	; 0xb4
   2cf84:	e50b40b0 	str	r4, [fp, #-176]	; 0xb0
	    t_h = 3.0+s2+r;
   2cf88:	e24b10b4 	sub	r1, fp, #180	; 0xb4
   2cf8c:	e8910003 	ldm	r1, {r0, r1}
   2cf90:	e3a02000 	mov	r2, #0
   2cf94:	e59f31fc 	ldr	r3, [pc, #508]	; 2d198 <__ieee754_pow+0x11e0>
   2cf98:	ebff9dd4 	bl	146f0 <__adddf3>
   2cf9c:	e1a03000 	mov	r3, r0
   2cfa0:	e1a04001 	mov	r4, r1
   2cfa4:	e1a00003 	mov	r0, r3
   2cfa8:	e1a01004 	mov	r1, r4
   2cfac:	e24b30bc 	sub	r3, fp, #188	; 0xbc
   2cfb0:	e893000c 	ldm	r3, {r2, r3}
   2cfb4:	ebff9dcd 	bl	146f0 <__adddf3>
   2cfb8:	e1a03000 	mov	r3, r0
   2cfbc:	e1a04001 	mov	r4, r1
   2cfc0:	e50b309c 	str	r3, [fp, #-156]	; 0x9c
   2cfc4:	e50b4098 	str	r4, [fp, #-152]	; 0x98
	    SET_LOW_WORD(t_h,0);
   2cfc8:	e24b409c 	sub	r4, fp, #156	; 0x9c
   2cfcc:	e8940018 	ldm	r4, {r3, r4}
   2cfd0:	e50b3124 	str	r3, [fp, #-292]	; 0x124
   2cfd4:	e50b4120 	str	r4, [fp, #-288]	; 0x120
   2cfd8:	e3a03000 	mov	r3, #0
   2cfdc:	e50b3124 	str	r3, [fp, #-292]	; 0x124
   2cfe0:	e24b4f49 	sub	r4, fp, #292	; 0x124
   2cfe4:	e8940018 	ldm	r4, {r3, r4}
   2cfe8:	e50b309c 	str	r3, [fp, #-156]	; 0x9c
   2cfec:	e50b4098 	str	r4, [fp, #-152]	; 0x98
	    t_l = r-((t_h-3.0)-s2);
   2cff0:	e24b109c 	sub	r1, fp, #156	; 0x9c
   2cff4:	e8910003 	ldm	r1, {r0, r1}
   2cff8:	e3a02000 	mov	r2, #0
   2cffc:	e59f3194 	ldr	r3, [pc, #404]	; 2d198 <__ieee754_pow+0x11e0>
   2d000:	ebff9db9 	bl	146ec <__aeabi_dsub>
   2d004:	e1a03000 	mov	r3, r0
   2d008:	e1a04001 	mov	r4, r1
   2d00c:	e1a00003 	mov	r0, r3
   2d010:	e1a01004 	mov	r1, r4
   2d014:	e24b30b4 	sub	r3, fp, #180	; 0xb4
   2d018:	e893000c 	ldm	r3, {r2, r3}
   2d01c:	ebff9db2 	bl	146ec <__aeabi_dsub>
   2d020:	e1a03000 	mov	r3, r0
   2d024:	e1a04001 	mov	r4, r1
   2d028:	e24b10bc 	sub	r1, fp, #188	; 0xbc
   2d02c:	e8910003 	ldm	r1, {r0, r1}
   2d030:	e1a02003 	mov	r2, r3
   2d034:	e1a03004 	mov	r3, r4
   2d038:	ebff9dab 	bl	146ec <__aeabi_dsub>
   2d03c:	e1a03000 	mov	r3, r0
   2d040:	e1a04001 	mov	r4, r1
   2d044:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
   2d048:	e50b40a0 	str	r4, [fp, #-160]	; 0xa0
	/* u+v = s*(1+...) */
	    u = s_h*t_h;
   2d04c:	e24b1094 	sub	r1, fp, #148	; 0x94
   2d050:	e8910003 	ldm	r1, {r0, r1}
   2d054:	e24b309c 	sub	r3, fp, #156	; 0x9c
   2d058:	e893000c 	ldm	r3, {r2, r3}
   2d05c:	ebff9ea7 	bl	14b00 <__aeabi_dmul>
   2d060:	e1a03000 	mov	r3, r0
   2d064:	e1a04001 	mov	r4, r1
   2d068:	e50b3084 	str	r3, [fp, #-132]	; 0x84
   2d06c:	e50b4080 	str	r4, [fp, #-128]	; 0x80
	    v = s_l*t_h+t_l*s;
   2d070:	e24b10ac 	sub	r1, fp, #172	; 0xac
   2d074:	e8910003 	ldm	r1, {r0, r1}
   2d078:	e24b309c 	sub	r3, fp, #156	; 0x9c
   2d07c:	e893000c 	ldm	r3, {r2, r3}
   2d080:	ebff9e9e 	bl	14b00 <__aeabi_dmul>
   2d084:	e1a03000 	mov	r3, r0
   2d088:	e1a04001 	mov	r4, r1
   2d08c:	e1a05003 	mov	r5, r3
   2d090:	e1a06004 	mov	r6, r4
   2d094:	e24b10a4 	sub	r1, fp, #164	; 0xa4
   2d098:	e8910003 	ldm	r1, {r0, r1}
   2d09c:	e24b3044 	sub	r3, fp, #68	; 0x44
   2d0a0:	e893000c 	ldm	r3, {r2, r3}
   2d0a4:	ebff9e95 	bl	14b00 <__aeabi_dmul>
   2d0a8:	e1a03000 	mov	r3, r0
   2d0ac:	e1a04001 	mov	r4, r1
   2d0b0:	e1a00005 	mov	r0, r5
   2d0b4:	e1a01006 	mov	r1, r6
   2d0b8:	e1a02003 	mov	r2, r3
   2d0bc:	e1a03004 	mov	r3, r4
   2d0c0:	ebff9d8a 	bl	146f0 <__adddf3>
   2d0c4:	e1a03000 	mov	r3, r0
   2d0c8:	e1a04001 	mov	r4, r1
   2d0cc:	e50b308c 	str	r3, [fp, #-140]	; 0x8c
   2d0d0:	e50b4088 	str	r4, [fp, #-136]	; 0x88
	/* 2/(3log2)*(s+...) */
	    p_h = u+v;
   2d0d4:	e24b1084 	sub	r1, fp, #132	; 0x84
   2d0d8:	e8910003 	ldm	r1, {r0, r1}
   2d0dc:	e24b308c 	sub	r3, fp, #140	; 0x8c
   2d0e0:	e893000c 	ldm	r3, {r2, r3}
   2d0e4:	ebff9d81 	bl	146f0 <__adddf3>
   2d0e8:	e1a03000 	mov	r3, r0
   2d0ec:	e1a04001 	mov	r4, r1
   2d0f0:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2d0f4:	e50b4028 	str	r4, [fp, #-40]	; 0x28
	    SET_LOW_WORD(p_h,0);
   2d0f8:	e24b402c 	sub	r4, fp, #44	; 0x2c
   2d0fc:	e8940018 	ldm	r4, {r3, r4}
   2d100:	e50b312c 	str	r3, [fp, #-300]	; 0x12c
   2d104:	e50b4128 	str	r4, [fp, #-296]	; 0x128
   2d108:	e3a03000 	mov	r3, #0
   2d10c:	e50b312c 	str	r3, [fp, #-300]	; 0x12c
   2d110:	e24b4f4b 	sub	r4, fp, #300	; 0x12c
   2d114:	e8940018 	ldm	r4, {r3, r4}
   2d118:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2d11c:	e50b4028 	str	r4, [fp, #-40]	; 0x28
	    p_l = v-(p_h-u);
   2d120:	e24b102c 	sub	r1, fp, #44	; 0x2c
   2d124:	e8910003 	ldm	r1, {r0, r1}
   2d128:	e24b3084 	sub	r3, fp, #132	; 0x84
   2d12c:	e893000c 	ldm	r3, {r2, r3}
   2d130:	ebff9d6d 	bl	146ec <__aeabi_dsub>
   2d134:	e1a03000 	mov	r3, r0
   2d138:	e1a04001 	mov	r4, r1
   2d13c:	e24b108c 	sub	r1, fp, #140	; 0x8c
   2d140:	e8910003 	ldm	r1, {r0, r1}
   2d144:	e1a02003 	mov	r2, r3
   2d148:	e1a03004 	mov	r3, r4
   2d14c:	ebff9d66 	bl	146ec <__aeabi_dsub>
   2d150:	e1a03000 	mov	r3, r0
   2d154:	e1a04001 	mov	r4, r1
   2d158:	e50b30c4 	str	r3, [fp, #-196]	; 0xc4
   2d15c:	e50b40c0 	str	r4, [fp, #-192]	; 0xc0
	    z_h = cp_h*p_h;		/* cp_h+cp_l = 2/(3*log2) */
   2d160:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
   2d164:	ea00000d 	b	2d1a0 <__ieee754_pow+0x11e8>
   2d168:	4a454eef 	.word	0x4a454eef
   2d16c:	3fca7e28 	.word	0x3fca7e28
   2d170:	93c9db65 	.word	0x93c9db65
   2d174:	3fcd864a 	.word	0x3fcd864a
   2d178:	a91d4101 	.word	0xa91d4101
   2d17c:	3fd17460 	.word	0x3fd17460
   2d180:	518f264d 	.word	0x518f264d
   2d184:	3fd55555 	.word	0x3fd55555
   2d188:	db6fabff 	.word	0xdb6fabff
   2d18c:	3fdb6db6 	.word	0x3fdb6db6
   2d190:	33333303 	.word	0x33333303
   2d194:	3fe33333 	.word	0x3fe33333
   2d198:	40080000 	.word	0x40080000
   2d19c:	3feec709 	.word	0x3feec709
   2d1a0:	e51f400c 	ldr	r4, [pc, #-12]	; 2d19c <__ieee754_pow+0x11e4>
   2d1a4:	e1a00003 	mov	r0, r3
   2d1a8:	e1a01004 	mov	r1, r4
   2d1ac:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2d1b0:	e893000c 	ldm	r3, {r2, r3}
   2d1b4:	ebff9e51 	bl	14b00 <__aeabi_dmul>
   2d1b8:	e1a03000 	mov	r3, r0
   2d1bc:	e1a04001 	mov	r4, r1
   2d1c0:	e50b30cc 	str	r3, [fp, #-204]	; 0xcc
   2d1c4:	e50b40c8 	str	r4, [fp, #-200]	; 0xc8
	    z_l = cp_l*p_h+p_l*cp+dp_l[k];
   2d1c8:	e28f4e3e 	add	r4, pc, #992	; 0x3e0
   2d1cc:	e8940018 	ldm	r4, {r3, r4}
   2d1d0:	e1a00003 	mov	r0, r3
   2d1d4:	e1a01004 	mov	r1, r4
   2d1d8:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2d1dc:	e893000c 	ldm	r3, {r2, r3}
   2d1e0:	ebff9e46 	bl	14b00 <__aeabi_dmul>
   2d1e4:	e1a03000 	mov	r3, r0
   2d1e8:	e1a04001 	mov	r4, r1
   2d1ec:	e1a05003 	mov	r5, r3
   2d1f0:	e1a06004 	mov	r6, r4
   2d1f4:	e28f4fef 	add	r4, pc, #956	; 0x3bc
   2d1f8:	e8940018 	ldm	r4, {r3, r4}
   2d1fc:	e1a00003 	mov	r0, r3
   2d200:	e1a01004 	mov	r1, r4
   2d204:	e24b30c4 	sub	r3, fp, #196	; 0xc4
   2d208:	e893000c 	ldm	r3, {r2, r3}
   2d20c:	ebff9e3b 	bl	14b00 <__aeabi_dmul>
   2d210:	e1a03000 	mov	r3, r0
   2d214:	e1a04001 	mov	r4, r1
   2d218:	e1a00005 	mov	r0, r5
   2d21c:	e1a01006 	mov	r1, r6
   2d220:	e1a02003 	mov	r2, r3
   2d224:	e1a03004 	mov	r3, r4
   2d228:	ebff9d30 	bl	146f0 <__adddf3>
   2d22c:	e1a03000 	mov	r3, r0
   2d230:	e1a04001 	mov	r4, r1
   2d234:	e1a01003 	mov	r1, r3
   2d238:	e1a02004 	mov	r2, r4
   2d23c:	e59f0384 	ldr	r0, [pc, #900]	; 2d5c8 <__ieee754_pow+0x1610>
   2d240:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2d244:	e1a03183 	lsl	r3, r3, #3
   2d248:	e0803003 	add	r3, r0, r3
   2d24c:	e8930018 	ldm	r3, {r3, r4}
   2d250:	e1a00001 	mov	r0, r1
   2d254:	e1a01002 	mov	r1, r2
   2d258:	e1a02003 	mov	r2, r3
   2d25c:	e1a03004 	mov	r3, r4
   2d260:	ebff9d22 	bl	146f0 <__adddf3>
   2d264:	e1a03000 	mov	r3, r0
   2d268:	e1a04001 	mov	r4, r1
   2d26c:	e50b30d4 	str	r3, [fp, #-212]	; 0xd4
   2d270:	e50b40d0 	str	r4, [fp, #-208]	; 0xd0
	/* log2(ax) = (s+..)*2/(3*log2) = n + dp_h + z_h + z_l */
	    t = (double)n;
   2d274:	e51b0050 	ldr	r0, [fp, #-80]	; 0x50
   2d278:	ebff9de9 	bl	14a24 <__aeabi_i2d>
   2d27c:	e1a03000 	mov	r3, r0
   2d280:	e1a04001 	mov	r4, r1
   2d284:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   2d288:	e50b4070 	str	r4, [fp, #-112]	; 0x70
	    t1 = (((z_h+z_l)+dp_h[k])+t);
   2d28c:	e24b10cc 	sub	r1, fp, #204	; 0xcc
   2d290:	e8910003 	ldm	r1, {r0, r1}
   2d294:	e24b30d4 	sub	r3, fp, #212	; 0xd4
   2d298:	e893000c 	ldm	r3, {r2, r3}
   2d29c:	ebff9d13 	bl	146f0 <__adddf3>
   2d2a0:	e1a03000 	mov	r3, r0
   2d2a4:	e1a04001 	mov	r4, r1
   2d2a8:	e1a01003 	mov	r1, r3
   2d2ac:	e1a02004 	mov	r2, r4
   2d2b0:	e59f0314 	ldr	r0, [pc, #788]	; 2d5cc <__ieee754_pow+0x1614>
   2d2b4:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2d2b8:	e1a03183 	lsl	r3, r3, #3
   2d2bc:	e0803003 	add	r3, r0, r3
   2d2c0:	e8930018 	ldm	r3, {r3, r4}
   2d2c4:	e1a00001 	mov	r0, r1
   2d2c8:	e1a01002 	mov	r1, r2
   2d2cc:	e1a02003 	mov	r2, r3
   2d2d0:	e1a03004 	mov	r3, r4
   2d2d4:	ebff9d05 	bl	146f0 <__adddf3>
   2d2d8:	e1a03000 	mov	r3, r0
   2d2dc:	e1a04001 	mov	r4, r1
   2d2e0:	e1a00003 	mov	r0, r3
   2d2e4:	e1a01004 	mov	r1, r4
   2d2e8:	e24b3074 	sub	r3, fp, #116	; 0x74
   2d2ec:	e893000c 	ldm	r3, {r2, r3}
   2d2f0:	ebff9cfe 	bl	146f0 <__adddf3>
   2d2f4:	e1a03000 	mov	r3, r0
   2d2f8:	e1a04001 	mov	r4, r1
   2d2fc:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2d300:	e50b4030 	str	r4, [fp, #-48]	; 0x30
	    SET_LOW_WORD(t1,0);
   2d304:	e24b4034 	sub	r4, fp, #52	; 0x34
   2d308:	e8940018 	ldm	r4, {r3, r4}
   2d30c:	e50b3134 	str	r3, [fp, #-308]	; 0x134
   2d310:	e50b4130 	str	r4, [fp, #-304]	; 0x130
   2d314:	e3a03000 	mov	r3, #0
   2d318:	e50b3134 	str	r3, [fp, #-308]	; 0x134
   2d31c:	e24b4f4d 	sub	r4, fp, #308	; 0x134
   2d320:	e8940018 	ldm	r4, {r3, r4}
   2d324:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2d328:	e50b4030 	str	r4, [fp, #-48]	; 0x30
	    t2 = z_l-(((t1-t)-dp_h[k])-z_h);
   2d32c:	e24b1034 	sub	r1, fp, #52	; 0x34
   2d330:	e8910003 	ldm	r1, {r0, r1}
   2d334:	e24b3074 	sub	r3, fp, #116	; 0x74
   2d338:	e893000c 	ldm	r3, {r2, r3}
   2d33c:	ebff9cea 	bl	146ec <__aeabi_dsub>
   2d340:	e1a03000 	mov	r3, r0
   2d344:	e1a04001 	mov	r4, r1
   2d348:	e1a01003 	mov	r1, r3
   2d34c:	e1a02004 	mov	r2, r4
   2d350:	e59f0274 	ldr	r0, [pc, #628]	; 2d5cc <__ieee754_pow+0x1614>
   2d354:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2d358:	e1a03183 	lsl	r3, r3, #3
   2d35c:	e0803003 	add	r3, r0, r3
   2d360:	e8930018 	ldm	r3, {r3, r4}
   2d364:	e1a00001 	mov	r0, r1
   2d368:	e1a01002 	mov	r1, r2
   2d36c:	e1a02003 	mov	r2, r3
   2d370:	e1a03004 	mov	r3, r4
   2d374:	ebff9cdc 	bl	146ec <__aeabi_dsub>
   2d378:	e1a03000 	mov	r3, r0
   2d37c:	e1a04001 	mov	r4, r1
   2d380:	e1a00003 	mov	r0, r3
   2d384:	e1a01004 	mov	r1, r4
   2d388:	e24b30cc 	sub	r3, fp, #204	; 0xcc
   2d38c:	e893000c 	ldm	r3, {r2, r3}
   2d390:	ebff9cd5 	bl	146ec <__aeabi_dsub>
   2d394:	e1a03000 	mov	r3, r0
   2d398:	e1a04001 	mov	r4, r1
   2d39c:	e24b10d4 	sub	r1, fp, #212	; 0xd4
   2d3a0:	e8910003 	ldm	r1, {r0, r1}
   2d3a4:	e1a02003 	mov	r2, r3
   2d3a8:	e1a03004 	mov	r3, r4
   2d3ac:	ebff9cce 	bl	146ec <__aeabi_dsub>
   2d3b0:	e1a03000 	mov	r3, r0
   2d3b4:	e1a04001 	mov	r4, r1
   2d3b8:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2d3bc:	e50b4038 	str	r4, [fp, #-56]	; 0x38
	}

	s = one; /* s (sign of result -ve**odd) = -1 else = 1 */
   2d3c0:	e3a03000 	mov	r3, #0
   2d3c4:	e59f4204 	ldr	r4, [pc, #516]	; 2d5d0 <__ieee754_pow+0x1618>
   2d3c8:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   2d3cc:	e50b4040 	str	r4, [fp, #-64]	; 0x40
	if(((((__uint32_t)hx>>31)-1)|(yisint-1))==0)
   2d3d0:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   2d3d4:	e1a03fa3 	lsr	r3, r3, #31
   2d3d8:	e2432001 	sub	r2, r3, #1
   2d3dc:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   2d3e0:	e2433001 	sub	r3, r3, #1
   2d3e4:	e1823003 	orr	r3, r2, r3
   2d3e8:	e3530000 	cmp	r3, #0
   2d3ec:	1a000005 	bne	2d408 <__ieee754_pow+0x1450>
	    s = -one;/* (-ve)**(odd int) */
   2d3f0:	e3a03000 	mov	r3, #0
   2d3f4:	e59f41d4 	ldr	r4, [pc, #468]	; 2d5d0 <__ieee754_pow+0x1618>
   2d3f8:	e1a02003 	mov	r2, r3
   2d3fc:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   2d400:	e2243102 	eor	r3, r4, #-2147483648	; 0x80000000
   2d404:	e50b3040 	str	r3, [fp, #-64]	; 0x40

    /* split up y into y1+y2 and compute (y1+y2)*(t1+t2) */
	y1  = y;
   2d408:	e24b4f5d 	sub	r4, fp, #372	; 0x174
   2d40c:	e8940018 	ldm	r4, {r3, r4}
   2d410:	e50b30dc 	str	r3, [fp, #-220]	; 0xdc
   2d414:	e50b40d8 	str	r4, [fp, #-216]	; 0xd8
	SET_LOW_WORD(y1,0);
   2d418:	e24b40dc 	sub	r4, fp, #220	; 0xdc
   2d41c:	e8940018 	ldm	r4, {r3, r4}
   2d420:	e50b313c 	str	r3, [fp, #-316]	; 0x13c
   2d424:	e50b4138 	str	r4, [fp, #-312]	; 0x138
   2d428:	e3a03000 	mov	r3, #0
   2d42c:	e50b313c 	str	r3, [fp, #-316]	; 0x13c
   2d430:	e24b4f4f 	sub	r4, fp, #316	; 0x13c
   2d434:	e8940018 	ldm	r4, {r3, r4}
   2d438:	e50b30dc 	str	r3, [fp, #-220]	; 0xdc
   2d43c:	e50b40d8 	str	r4, [fp, #-216]	; 0xd8
	p_l = (y-y1)*t1+y*t2;
   2d440:	e24b1f5d 	sub	r1, fp, #372	; 0x174
   2d444:	e8910003 	ldm	r1, {r0, r1}
   2d448:	e24b30dc 	sub	r3, fp, #220	; 0xdc
   2d44c:	e893000c 	ldm	r3, {r2, r3}
   2d450:	ebff9ca5 	bl	146ec <__aeabi_dsub>
   2d454:	e1a03000 	mov	r3, r0
   2d458:	e1a04001 	mov	r4, r1
   2d45c:	e1a00003 	mov	r0, r3
   2d460:	e1a01004 	mov	r1, r4
   2d464:	e24b3034 	sub	r3, fp, #52	; 0x34
   2d468:	e893000c 	ldm	r3, {r2, r3}
   2d46c:	ebff9da3 	bl	14b00 <__aeabi_dmul>
   2d470:	e1a03000 	mov	r3, r0
   2d474:	e1a04001 	mov	r4, r1
   2d478:	e1a05003 	mov	r5, r3
   2d47c:	e1a06004 	mov	r6, r4
   2d480:	e24b1f5d 	sub	r1, fp, #372	; 0x174
   2d484:	e8910003 	ldm	r1, {r0, r1}
   2d488:	e24b303c 	sub	r3, fp, #60	; 0x3c
   2d48c:	e893000c 	ldm	r3, {r2, r3}
   2d490:	ebff9d9a 	bl	14b00 <__aeabi_dmul>
   2d494:	e1a03000 	mov	r3, r0
   2d498:	e1a04001 	mov	r4, r1
   2d49c:	e1a00005 	mov	r0, r5
   2d4a0:	e1a01006 	mov	r1, r6
   2d4a4:	e1a02003 	mov	r2, r3
   2d4a8:	e1a03004 	mov	r3, r4
   2d4ac:	ebff9c8f 	bl	146f0 <__adddf3>
   2d4b0:	e1a03000 	mov	r3, r0
   2d4b4:	e1a04001 	mov	r4, r1
   2d4b8:	e50b30c4 	str	r3, [fp, #-196]	; 0xc4
   2d4bc:	e50b40c0 	str	r4, [fp, #-192]	; 0xc0
	p_h = y1*t1;
   2d4c0:	e24b10dc 	sub	r1, fp, #220	; 0xdc
   2d4c4:	e8910003 	ldm	r1, {r0, r1}
   2d4c8:	e24b3034 	sub	r3, fp, #52	; 0x34
   2d4cc:	e893000c 	ldm	r3, {r2, r3}
   2d4d0:	ebff9d8a 	bl	14b00 <__aeabi_dmul>
   2d4d4:	e1a03000 	mov	r3, r0
   2d4d8:	e1a04001 	mov	r4, r1
   2d4dc:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2d4e0:	e50b4028 	str	r4, [fp, #-40]	; 0x28
	z = p_l+p_h;
   2d4e4:	e24b10c4 	sub	r1, fp, #196	; 0xc4
   2d4e8:	e8910003 	ldm	r1, {r0, r1}
   2d4ec:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2d4f0:	e893000c 	ldm	r3, {r2, r3}
   2d4f4:	ebff9c7d 	bl	146f0 <__adddf3>
   2d4f8:	e1a03000 	mov	r3, r0
   2d4fc:	e1a04001 	mov	r4, r1
   2d500:	e50b301c 	str	r3, [fp, #-28]
   2d504:	e50b4018 	str	r4, [fp, #-24]
	EXTRACT_WORDS(j,i,z);
   2d508:	e24b401c 	sub	r4, fp, #28
   2d50c:	e8940018 	ldm	r4, {r3, r4}
   2d510:	e50b3144 	str	r3, [fp, #-324]	; 0x144
   2d514:	e50b4140 	str	r4, [fp, #-320]	; 0x140
   2d518:	e51b3140 	ldr	r3, [fp, #-320]	; 0x140
   2d51c:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   2d520:	e51b3144 	ldr	r3, [fp, #-324]	; 0x144
   2d524:	e50b30e0 	str	r3, [fp, #-224]	; 0xe0
	if (j>=0x40900000) {				/* z >= 1024 */
   2d528:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
   2d52c:	e59f30a0 	ldr	r3, [pc, #160]	; 2d5d4 <__ieee754_pow+0x161c>
   2d530:	e1520003 	cmp	r2, r3
   2d534:	da000058 	ble	2d69c <__ieee754_pow+0x16e4>
	    if(((j-0x40900000)|i)!=0)			/* if z > 1024 */
   2d538:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   2d53c:	e28334bf 	add	r3, r3, #-1090519040	; 0xbf000000
   2d540:	e2833607 	add	r3, r3, #7340032	; 0x700000
   2d544:	e51b20e0 	ldr	r2, [fp, #-224]	; 0xe0
   2d548:	e1833002 	orr	r3, r3, r2
   2d54c:	e3530000 	cmp	r3, #0
   2d550:	0a000020 	beq	2d5d8 <__ieee754_pow+0x1620>
		return s*huge*huge;			/* overflow */
   2d554:	e28f4064 	add	r4, pc, #100	; 0x64
   2d558:	e8940018 	ldm	r4, {r3, r4}
   2d55c:	e1a00003 	mov	r0, r3
   2d560:	e1a01004 	mov	r1, r4
   2d564:	e24b3044 	sub	r3, fp, #68	; 0x44
   2d568:	e893000c 	ldm	r3, {r2, r3}
   2d56c:	ebff9d63 	bl	14b00 <__aeabi_dmul>
   2d570:	e1a03000 	mov	r3, r0
   2d574:	e1a04001 	mov	r4, r1
   2d578:	e1a01003 	mov	r1, r3
   2d57c:	e1a02004 	mov	r2, r4
   2d580:	e28f4038 	add	r4, pc, #56	; 0x38
   2d584:	e8940018 	ldm	r4, {r3, r4}
   2d588:	e1a00001 	mov	r0, r1
   2d58c:	e1a01002 	mov	r1, r2
   2d590:	e1a02003 	mov	r2, r3
   2d594:	e1a03004 	mov	r3, r4
   2d598:	ebff9d58 	bl	14b00 <__aeabi_dmul>
   2d59c:	e1a03000 	mov	r3, r0
   2d5a0:	e1a04001 	mov	r4, r1
   2d5a4:	e1a05004 	mov	r5, r4
   2d5a8:	e1a04003 	mov	r4, r3
   2d5ac:	ea000217 	b	2de10 <__ieee754_pow+0x1e58>
   2d5b0:	145b01f5 	.word	0x145b01f5
   2d5b4:	be3e2fe0 	.word	0xbe3e2fe0
   2d5b8:	dc3a03fd 	.word	0xdc3a03fd
   2d5bc:	3feec709 	.word	0x3feec709
   2d5c0:	8800759c 	.word	0x8800759c
   2d5c4:	7e37e43c 	.word	0x7e37e43c
   2d5c8:	000334d8 	.word	0x000334d8
   2d5cc:	000334c8 	.word	0x000334c8
   2d5d0:	3ff00000 	.word	0x3ff00000
   2d5d4:	408fffff 	.word	0x408fffff
	    else {
		if(p_l+ovt>z-p_h) return s*huge*huge;	/* overflow */
   2d5d8:	e28f4e1e 	add	r4, pc, #480	; 0x1e0
   2d5dc:	e8940018 	ldm	r4, {r3, r4}
   2d5e0:	e1a00003 	mov	r0, r3
   2d5e4:	e1a01004 	mov	r1, r4
   2d5e8:	e24b30c4 	sub	r3, fp, #196	; 0xc4
   2d5ec:	e893000c 	ldm	r3, {r2, r3}
   2d5f0:	ebff9c3e 	bl	146f0 <__adddf3>
   2d5f4:	e1a03000 	mov	r3, r0
   2d5f8:	e1a04001 	mov	r4, r1
   2d5fc:	e1a05003 	mov	r5, r3
   2d600:	e1a06004 	mov	r6, r4
   2d604:	e24b101c 	sub	r1, fp, #28
   2d608:	e8910003 	ldm	r1, {r0, r1}
   2d60c:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2d610:	e893000c 	ldm	r3, {r2, r3}
   2d614:	ebff9c34 	bl	146ec <__aeabi_dsub>
   2d618:	e1a03000 	mov	r3, r0
   2d61c:	e1a04001 	mov	r4, r1
   2d620:	e1a00005 	mov	r0, r5
   2d624:	e1a01006 	mov	r1, r6
   2d628:	e1a02003 	mov	r2, r3
   2d62c:	e1a03004 	mov	r3, r4
   2d630:	ebff9ea4 	bl	150c8 <__aeabi_dcmpgt>
   2d634:	e1a03000 	mov	r3, r0
   2d638:	e3530000 	cmp	r3, #0
   2d63c:	0a00006a 	beq	2d7ec <__ieee754_pow+0x1834>
   2d640:	e28f4d06 	add	r4, pc, #384	; 0x180
   2d644:	e8940018 	ldm	r4, {r3, r4}
   2d648:	e1a00003 	mov	r0, r3
   2d64c:	e1a01004 	mov	r1, r4
   2d650:	e24b3044 	sub	r3, fp, #68	; 0x44
   2d654:	e893000c 	ldm	r3, {r2, r3}
   2d658:	ebff9d28 	bl	14b00 <__aeabi_dmul>
   2d65c:	e1a03000 	mov	r3, r0
   2d660:	e1a04001 	mov	r4, r1
   2d664:	e1a01003 	mov	r1, r3
   2d668:	e1a02004 	mov	r2, r4
   2d66c:	e28f4f55 	add	r4, pc, #340	; 0x154
   2d670:	e8940018 	ldm	r4, {r3, r4}
   2d674:	e1a00001 	mov	r0, r1
   2d678:	e1a01002 	mov	r1, r2
   2d67c:	e1a02003 	mov	r2, r3
   2d680:	e1a03004 	mov	r3, r4
   2d684:	ebff9d1d 	bl	14b00 <__aeabi_dmul>
   2d688:	e1a03000 	mov	r3, r0
   2d68c:	e1a04001 	mov	r4, r1
   2d690:	e1a05004 	mov	r5, r4
   2d694:	e1a04003 	mov	r4, r3
   2d698:	ea0001dc 	b	2de10 <__ieee754_pow+0x1e58>
	    }
	} else if((j&0x7fffffff)>=0x4090cc00 ) {	/* z <= -1075 */
   2d69c:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   2d6a0:	e3c32102 	bic	r2, r3, #-2147483648	; 0x80000000
   2d6a4:	e59f312c 	ldr	r3, [pc, #300]	; 2d7d8 <__ieee754_pow+0x1820>
   2d6a8:	e1520003 	cmp	r2, r3
   2d6ac:	da00004e 	ble	2d7ec <__ieee754_pow+0x1834>
	    if(((j-0xc090cc00)|i)!=0) 		/* z < -1075 */
   2d6b0:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
   2d6b4:	e59f3120 	ldr	r3, [pc, #288]	; 2d7dc <__ieee754_pow+0x1824>
   2d6b8:	e0823003 	add	r3, r2, r3
   2d6bc:	e51b20e0 	ldr	r2, [fp, #-224]	; 0xe0
   2d6c0:	e1833002 	orr	r3, r3, r2
   2d6c4:	e3530000 	cmp	r3, #0
   2d6c8:	0a000016 	beq	2d728 <__ieee754_pow+0x1770>
		return s*tiny*tiny;		/* underflow */
   2d6cc:	e28f40fc 	add	r4, pc, #252	; 0xfc
   2d6d0:	e8940018 	ldm	r4, {r3, r4}
   2d6d4:	e1a00003 	mov	r0, r3
   2d6d8:	e1a01004 	mov	r1, r4
   2d6dc:	e24b3044 	sub	r3, fp, #68	; 0x44
   2d6e0:	e893000c 	ldm	r3, {r2, r3}
   2d6e4:	ebff9d05 	bl	14b00 <__aeabi_dmul>
   2d6e8:	e1a03000 	mov	r3, r0
   2d6ec:	e1a04001 	mov	r4, r1
   2d6f0:	e1a01003 	mov	r1, r3
   2d6f4:	e1a02004 	mov	r2, r4
   2d6f8:	e28f40d0 	add	r4, pc, #208	; 0xd0
   2d6fc:	e8940018 	ldm	r4, {r3, r4}
   2d700:	e1a00001 	mov	r0, r1
   2d704:	e1a01002 	mov	r1, r2
   2d708:	e1a02003 	mov	r2, r3
   2d70c:	e1a03004 	mov	r3, r4
   2d710:	ebff9cfa 	bl	14b00 <__aeabi_dmul>
   2d714:	e1a03000 	mov	r3, r0
   2d718:	e1a04001 	mov	r4, r1
   2d71c:	e1a05004 	mov	r5, r4
   2d720:	e1a04003 	mov	r4, r3
   2d724:	ea0001b9 	b	2de10 <__ieee754_pow+0x1e58>
	    else {
		if(p_l<=z-p_h) return s*tiny*tiny;	/* underflow */
   2d728:	e24b101c 	sub	r1, fp, #28
   2d72c:	e8910003 	ldm	r1, {r0, r1}
   2d730:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2d734:	e893000c 	ldm	r3, {r2, r3}
   2d738:	ebff9beb 	bl	146ec <__aeabi_dsub>
   2d73c:	e1a03000 	mov	r3, r0
   2d740:	e1a04001 	mov	r4, r1
   2d744:	e1a00003 	mov	r0, r3
   2d748:	e1a01004 	mov	r1, r4
   2d74c:	e24b30c4 	sub	r3, fp, #196	; 0xc4
   2d750:	e893000c 	ldm	r3, {r2, r3}
   2d754:	ebff9e55 	bl	150b0 <__aeabi_dcmpge>
   2d758:	e1a03000 	mov	r3, r0
   2d75c:	e3530000 	cmp	r3, #0
   2d760:	0a000021 	beq	2d7ec <__ieee754_pow+0x1834>
   2d764:	e28f4064 	add	r4, pc, #100	; 0x64
   2d768:	e8940018 	ldm	r4, {r3, r4}
   2d76c:	e1a00003 	mov	r0, r3
   2d770:	e1a01004 	mov	r1, r4
   2d774:	e24b3044 	sub	r3, fp, #68	; 0x44
   2d778:	e893000c 	ldm	r3, {r2, r3}
   2d77c:	ebff9cdf 	bl	14b00 <__aeabi_dmul>
   2d780:	e1a03000 	mov	r3, r0
   2d784:	e1a04001 	mov	r4, r1
   2d788:	e1a01003 	mov	r1, r3
   2d78c:	e1a02004 	mov	r2, r4
   2d790:	e28f4038 	add	r4, pc, #56	; 0x38
   2d794:	e8940018 	ldm	r4, {r3, r4}
   2d798:	e1a00001 	mov	r0, r1
   2d79c:	e1a01002 	mov	r1, r2
   2d7a0:	e1a02003 	mov	r2, r3
   2d7a4:	e1a03004 	mov	r3, r4
   2d7a8:	ebff9cd4 	bl	14b00 <__aeabi_dmul>
   2d7ac:	e1a03000 	mov	r3, r0
   2d7b0:	e1a04001 	mov	r4, r1
   2d7b4:	e1a05004 	mov	r5, r4
   2d7b8:	e1a04003 	mov	r4, r3
   2d7bc:	ea000193 	b	2de10 <__ieee754_pow+0x1e58>
   2d7c0:	652b82fe 	.word	0x652b82fe
   2d7c4:	3c971547 	.word	0x3c971547
   2d7c8:	8800759c 	.word	0x8800759c
   2d7cc:	7e37e43c 	.word	0x7e37e43c
   2d7d0:	c2f8f359 	.word	0xc2f8f359
   2d7d4:	01a56e1f 	.word	0x01a56e1f
   2d7d8:	4090cbff 	.word	0x4090cbff
   2d7dc:	3f6f3400 	.word	0x3f6f3400
   2d7e0:	3fe00000 	.word	0x3fe00000
   2d7e4:	000fffff 	.word	0x000fffff
   2d7e8:	3fe62e43 	.word	0x3fe62e43
	    }
	}
    /*
     * compute 2**(p_h+p_l)
     */
	i = j&0x7fffffff;
   2d7ec:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   2d7f0:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   2d7f4:	e50b30e0 	str	r3, [fp, #-224]	; 0xe0
	k = (i>>20)-0x3ff;
   2d7f8:	e51b30e0 	ldr	r3, [fp, #-224]	; 0xe0
   2d7fc:	e1a03a43 	asr	r3, r3, #20
   2d800:	e2433fff 	sub	r3, r3, #1020	; 0x3fc
   2d804:	e2433003 	sub	r3, r3, #3
   2d808:	e50b3048 	str	r3, [fp, #-72]	; 0x48
	n = 0;
   2d80c:	e3a03000 	mov	r3, #0
   2d810:	e50b3050 	str	r3, [fp, #-80]	; 0x50
	if(i>0x3fe00000) {		/* if |z| > 0.5, set n = [z+0.5] */
   2d814:	e51b20e0 	ldr	r2, [fp, #-224]	; 0xe0
   2d818:	e51f3040 	ldr	r3, [pc, #-64]	; 2d7e0 <__ieee754_pow+0x1828>
   2d81c:	e1520003 	cmp	r2, r3
   2d820:	da000036 	ble	2d900 <__ieee754_pow+0x1948>
	    n = j+(0x00100000>>(k+1));
   2d824:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2d828:	e2833001 	add	r3, r3, #1
   2d82c:	e3a02601 	mov	r2, #1048576	; 0x100000
   2d830:	e1a02352 	asr	r2, r2, r3
   2d834:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   2d838:	e0823003 	add	r3, r2, r3
   2d83c:	e50b3050 	str	r3, [fp, #-80]	; 0x50
	    k = ((n&0x7fffffff)>>20)-0x3ff;	/* new k for n */
   2d840:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   2d844:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   2d848:	e1a03a43 	asr	r3, r3, #20
   2d84c:	e2433fff 	sub	r3, r3, #1020	; 0x3fc
   2d850:	e2433003 	sub	r3, r3, #3
   2d854:	e50b3048 	str	r3, [fp, #-72]	; 0x48
	    t = zero;
   2d858:	e3a03000 	mov	r3, #0
   2d85c:	e3a04000 	mov	r4, #0
   2d860:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   2d864:	e50b4070 	str	r4, [fp, #-112]	; 0x70
	    SET_HIGH_WORD(t,n&~(0x000fffff>>k));
   2d868:	e24b4074 	sub	r4, fp, #116	; 0x74
   2d86c:	e8940018 	ldm	r4, {r3, r4}
   2d870:	e50b314c 	str	r3, [fp, #-332]	; 0x14c
   2d874:	e50b4148 	str	r4, [fp, #-328]	; 0x148
   2d878:	e51f209c 	ldr	r2, [pc, #-156]	; 2d7e4 <__ieee754_pow+0x182c>
   2d87c:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2d880:	e1a03352 	asr	r3, r2, r3
   2d884:	e1e02003 	mvn	r2, r3
   2d888:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   2d88c:	e0033002 	and	r3, r3, r2
   2d890:	e50b3148 	str	r3, [fp, #-328]	; 0x148
   2d894:	e24b4f53 	sub	r4, fp, #332	; 0x14c
   2d898:	e8940018 	ldm	r4, {r3, r4}
   2d89c:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   2d8a0:	e50b4070 	str	r4, [fp, #-112]	; 0x70
	    n = ((n&0x000fffff)|0x00100000)>>(20-k);
   2d8a4:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   2d8a8:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
   2d8ac:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   2d8b0:	e3832601 	orr	r2, r3, #1048576	; 0x100000
   2d8b4:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2d8b8:	e2633014 	rsb	r3, r3, #20
   2d8bc:	e1a03352 	asr	r3, r2, r3
   2d8c0:	e50b3050 	str	r3, [fp, #-80]	; 0x50
	    if(j<0) n = -n;
   2d8c4:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   2d8c8:	e3530000 	cmp	r3, #0
   2d8cc:	aa000002 	bge	2d8dc <__ieee754_pow+0x1924>
   2d8d0:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   2d8d4:	e2633000 	rsb	r3, r3, #0
   2d8d8:	e50b3050 	str	r3, [fp, #-80]	; 0x50
	    p_h -= t;
   2d8dc:	e24b102c 	sub	r1, fp, #44	; 0x2c
   2d8e0:	e8910003 	ldm	r1, {r0, r1}
   2d8e4:	e24b3074 	sub	r3, fp, #116	; 0x74
   2d8e8:	e893000c 	ldm	r3, {r2, r3}
   2d8ec:	ebff9b7e 	bl	146ec <__aeabi_dsub>
   2d8f0:	e1a03000 	mov	r3, r0
   2d8f4:	e1a04001 	mov	r4, r1
   2d8f8:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2d8fc:	e50b4028 	str	r4, [fp, #-40]	; 0x28
	} 
	t = p_l+p_h;
   2d900:	e24b10c4 	sub	r1, fp, #196	; 0xc4
   2d904:	e8910003 	ldm	r1, {r0, r1}
   2d908:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2d90c:	e893000c 	ldm	r3, {r2, r3}
   2d910:	ebff9b76 	bl	146f0 <__adddf3>
   2d914:	e1a03000 	mov	r3, r0
   2d918:	e1a04001 	mov	r4, r1
   2d91c:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   2d920:	e50b4070 	str	r4, [fp, #-112]	; 0x70
	SET_LOW_WORD(t,0);
   2d924:	e24b4074 	sub	r4, fp, #116	; 0x74
   2d928:	e8940018 	ldm	r4, {r3, r4}
   2d92c:	e50b3154 	str	r3, [fp, #-340]	; 0x154
   2d930:	e50b4150 	str	r4, [fp, #-336]	; 0x150
   2d934:	e3a03000 	mov	r3, #0
   2d938:	e50b3154 	str	r3, [fp, #-340]	; 0x154
   2d93c:	e24b4f55 	sub	r4, fp, #340	; 0x154
   2d940:	e8940018 	ldm	r4, {r3, r4}
   2d944:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   2d948:	e50b4070 	str	r4, [fp, #-112]	; 0x70
	u = t*lg2_h;
   2d94c:	e3a03000 	mov	r3, #0
   2d950:	e51f4170 	ldr	r4, [pc, #-368]	; 2d7e8 <__ieee754_pow+0x1830>
   2d954:	e24b1074 	sub	r1, fp, #116	; 0x74
   2d958:	e8910003 	ldm	r1, {r0, r1}
   2d95c:	e1a02003 	mov	r2, r3
   2d960:	e1a03004 	mov	r3, r4
   2d964:	ebff9c65 	bl	14b00 <__aeabi_dmul>
   2d968:	e1a03000 	mov	r3, r0
   2d96c:	e1a04001 	mov	r4, r1
   2d970:	e50b3084 	str	r3, [fp, #-132]	; 0x84
   2d974:	e50b4080 	str	r4, [fp, #-128]	; 0x80
	v = (p_l-(t-p_h))*lg2+t*lg2_l;
   2d978:	e24b1074 	sub	r1, fp, #116	; 0x74
   2d97c:	e8910003 	ldm	r1, {r0, r1}
   2d980:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2d984:	e893000c 	ldm	r3, {r2, r3}
   2d988:	ebff9b57 	bl	146ec <__aeabi_dsub>
   2d98c:	e1a03000 	mov	r3, r0
   2d990:	e1a04001 	mov	r4, r1
   2d994:	e24b10c4 	sub	r1, fp, #196	; 0xc4
   2d998:	e8910003 	ldm	r1, {r0, r1}
   2d99c:	e1a02003 	mov	r2, r3
   2d9a0:	e1a03004 	mov	r3, r4
   2d9a4:	ebff9b50 	bl	146ec <__aeabi_dsub>
   2d9a8:	e1a03000 	mov	r3, r0
   2d9ac:	e1a04001 	mov	r4, r1
   2d9b0:	e1a01003 	mov	r1, r3
   2d9b4:	e1a02004 	mov	r2, r4
   2d9b8:	e28f4ff2 	add	r4, pc, #968	; 0x3c8
   2d9bc:	e8940018 	ldm	r4, {r3, r4}
   2d9c0:	e1a00001 	mov	r0, r1
   2d9c4:	e1a01002 	mov	r1, r2
   2d9c8:	e1a02003 	mov	r2, r3
   2d9cc:	e1a03004 	mov	r3, r4
   2d9d0:	ebff9c4a 	bl	14b00 <__aeabi_dmul>
   2d9d4:	e1a03000 	mov	r3, r0
   2d9d8:	e1a04001 	mov	r4, r1
   2d9dc:	e1a05003 	mov	r5, r3
   2d9e0:	e1a06004 	mov	r6, r4
   2d9e4:	e28f4fe9 	add	r4, pc, #932	; 0x3a4
   2d9e8:	e8940018 	ldm	r4, {r3, r4}
   2d9ec:	e1a00003 	mov	r0, r3
   2d9f0:	e1a01004 	mov	r1, r4
   2d9f4:	e24b3074 	sub	r3, fp, #116	; 0x74
   2d9f8:	e893000c 	ldm	r3, {r2, r3}
   2d9fc:	ebff9c3f 	bl	14b00 <__aeabi_dmul>
   2da00:	e1a03000 	mov	r3, r0
   2da04:	e1a04001 	mov	r4, r1
   2da08:	e1a00005 	mov	r0, r5
   2da0c:	e1a01006 	mov	r1, r6
   2da10:	e1a02003 	mov	r2, r3
   2da14:	e1a03004 	mov	r3, r4
   2da18:	ebff9b34 	bl	146f0 <__adddf3>
   2da1c:	e1a03000 	mov	r3, r0
   2da20:	e1a04001 	mov	r4, r1
   2da24:	e50b308c 	str	r3, [fp, #-140]	; 0x8c
   2da28:	e50b4088 	str	r4, [fp, #-136]	; 0x88
	z = u+v;
   2da2c:	e24b1084 	sub	r1, fp, #132	; 0x84
   2da30:	e8910003 	ldm	r1, {r0, r1}
   2da34:	e24b308c 	sub	r3, fp, #140	; 0x8c
   2da38:	e893000c 	ldm	r3, {r2, r3}
   2da3c:	ebff9b2b 	bl	146f0 <__adddf3>
   2da40:	e1a03000 	mov	r3, r0
   2da44:	e1a04001 	mov	r4, r1
   2da48:	e50b301c 	str	r3, [fp, #-28]
   2da4c:	e50b4018 	str	r4, [fp, #-24]
	w = v-(z-u);
   2da50:	e24b101c 	sub	r1, fp, #28
   2da54:	e8910003 	ldm	r1, {r0, r1}
   2da58:	e24b3084 	sub	r3, fp, #132	; 0x84
   2da5c:	e893000c 	ldm	r3, {r2, r3}
   2da60:	ebff9b21 	bl	146ec <__aeabi_dsub>
   2da64:	e1a03000 	mov	r3, r0
   2da68:	e1a04001 	mov	r4, r1
   2da6c:	e24b108c 	sub	r1, fp, #140	; 0x8c
   2da70:	e8910003 	ldm	r1, {r0, r1}
   2da74:	e1a02003 	mov	r2, r3
   2da78:	e1a03004 	mov	r3, r4
   2da7c:	ebff9b1a 	bl	146ec <__aeabi_dsub>
   2da80:	e1a03000 	mov	r3, r0
   2da84:	e1a04001 	mov	r4, r1
   2da88:	e50b307c 	str	r3, [fp, #-124]	; 0x7c
   2da8c:	e50b4078 	str	r4, [fp, #-120]	; 0x78
	t  = z*z;
   2da90:	e24b101c 	sub	r1, fp, #28
   2da94:	e8910003 	ldm	r1, {r0, r1}
   2da98:	e24b301c 	sub	r3, fp, #28
   2da9c:	e893000c 	ldm	r3, {r2, r3}
   2daa0:	ebff9c16 	bl	14b00 <__aeabi_dmul>
   2daa4:	e1a03000 	mov	r3, r0
   2daa8:	e1a04001 	mov	r4, r1
   2daac:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   2dab0:	e50b4070 	str	r4, [fp, #-112]	; 0x70
	t1  = z - t*(P1+t*(P2+t*(P3+t*(P4+t*P5))));
   2dab4:	e28f4fb7 	add	r4, pc, #732	; 0x2dc
   2dab8:	e8940018 	ldm	r4, {r3, r4}
   2dabc:	e1a00003 	mov	r0, r3
   2dac0:	e1a01004 	mov	r1, r4
   2dac4:	e24b3074 	sub	r3, fp, #116	; 0x74
   2dac8:	e893000c 	ldm	r3, {r2, r3}
   2dacc:	ebff9c0b 	bl	14b00 <__aeabi_dmul>
   2dad0:	e1a03000 	mov	r3, r0
   2dad4:	e1a04001 	mov	r4, r1
   2dad8:	e1a01003 	mov	r1, r3
   2dadc:	e1a02004 	mov	r2, r4
   2dae0:	e28f4fae 	add	r4, pc, #696	; 0x2b8
   2dae4:	e8940018 	ldm	r4, {r3, r4}
   2dae8:	e1a00001 	mov	r0, r1
   2daec:	e1a01002 	mov	r1, r2
   2daf0:	e1a02003 	mov	r2, r3
   2daf4:	e1a03004 	mov	r3, r4
   2daf8:	ebff9afc 	bl	146f0 <__adddf3>
   2dafc:	e1a03000 	mov	r3, r0
   2db00:	e1a04001 	mov	r4, r1
   2db04:	e1a00003 	mov	r0, r3
   2db08:	e1a01004 	mov	r1, r4
   2db0c:	e24b3074 	sub	r3, fp, #116	; 0x74
   2db10:	e893000c 	ldm	r3, {r2, r3}
   2db14:	ebff9bf9 	bl	14b00 <__aeabi_dmul>
   2db18:	e1a03000 	mov	r3, r0
   2db1c:	e1a04001 	mov	r4, r1
   2db20:	e1a01003 	mov	r1, r3
   2db24:	e1a02004 	mov	r2, r4
   2db28:	e28f4f9e 	add	r4, pc, #632	; 0x278
   2db2c:	e8940018 	ldm	r4, {r3, r4}
   2db30:	e1a00001 	mov	r0, r1
   2db34:	e1a01002 	mov	r1, r2
   2db38:	e1a02003 	mov	r2, r3
   2db3c:	e1a03004 	mov	r3, r4
   2db40:	ebff9aea 	bl	146f0 <__adddf3>
   2db44:	e1a03000 	mov	r3, r0
   2db48:	e1a04001 	mov	r4, r1
   2db4c:	e1a00003 	mov	r0, r3
   2db50:	e1a01004 	mov	r1, r4
   2db54:	e24b3074 	sub	r3, fp, #116	; 0x74
   2db58:	e893000c 	ldm	r3, {r2, r3}
   2db5c:	ebff9be7 	bl	14b00 <__aeabi_dmul>
   2db60:	e1a03000 	mov	r3, r0
   2db64:	e1a04001 	mov	r4, r1
   2db68:	e1a01003 	mov	r1, r3
   2db6c:	e1a02004 	mov	r2, r4
   2db70:	e28f4f8e 	add	r4, pc, #568	; 0x238
   2db74:	e8940018 	ldm	r4, {r3, r4}
   2db78:	e1a00001 	mov	r0, r1
   2db7c:	e1a01002 	mov	r1, r2
   2db80:	e1a02003 	mov	r2, r3
   2db84:	e1a03004 	mov	r3, r4
   2db88:	ebff9ad8 	bl	146f0 <__adddf3>
   2db8c:	e1a03000 	mov	r3, r0
   2db90:	e1a04001 	mov	r4, r1
   2db94:	e1a00003 	mov	r0, r3
   2db98:	e1a01004 	mov	r1, r4
   2db9c:	e24b3074 	sub	r3, fp, #116	; 0x74
   2dba0:	e893000c 	ldm	r3, {r2, r3}
   2dba4:	ebff9bd5 	bl	14b00 <__aeabi_dmul>
   2dba8:	e1a03000 	mov	r3, r0
   2dbac:	e1a04001 	mov	r4, r1
   2dbb0:	e1a01003 	mov	r1, r3
   2dbb4:	e1a02004 	mov	r2, r4
   2dbb8:	e28f4f7e 	add	r4, pc, #504	; 0x1f8
   2dbbc:	e8940018 	ldm	r4, {r3, r4}
   2dbc0:	e1a00001 	mov	r0, r1
   2dbc4:	e1a01002 	mov	r1, r2
   2dbc8:	e1a02003 	mov	r2, r3
   2dbcc:	e1a03004 	mov	r3, r4
   2dbd0:	ebff9ac6 	bl	146f0 <__adddf3>
   2dbd4:	e1a03000 	mov	r3, r0
   2dbd8:	e1a04001 	mov	r4, r1
   2dbdc:	e1a00003 	mov	r0, r3
   2dbe0:	e1a01004 	mov	r1, r4
   2dbe4:	e24b3074 	sub	r3, fp, #116	; 0x74
   2dbe8:	e893000c 	ldm	r3, {r2, r3}
   2dbec:	ebff9bc3 	bl	14b00 <__aeabi_dmul>
   2dbf0:	e1a03000 	mov	r3, r0
   2dbf4:	e1a04001 	mov	r4, r1
   2dbf8:	e24b101c 	sub	r1, fp, #28
   2dbfc:	e8910003 	ldm	r1, {r0, r1}
   2dc00:	e1a02003 	mov	r2, r3
   2dc04:	e1a03004 	mov	r3, r4
   2dc08:	ebff9ab7 	bl	146ec <__aeabi_dsub>
   2dc0c:	e1a03000 	mov	r3, r0
   2dc10:	e1a04001 	mov	r4, r1
   2dc14:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2dc18:	e50b4030 	str	r4, [fp, #-48]	; 0x30
	r  = (z*t1)/(t1-two)-(w+z*w);
   2dc1c:	e24b101c 	sub	r1, fp, #28
   2dc20:	e8910003 	ldm	r1, {r0, r1}
   2dc24:	e24b3034 	sub	r3, fp, #52	; 0x34
   2dc28:	e893000c 	ldm	r3, {r2, r3}
   2dc2c:	ebff9bb3 	bl	14b00 <__aeabi_dmul>
   2dc30:	e1a03000 	mov	r3, r0
   2dc34:	e1a04001 	mov	r4, r1
   2dc38:	e1a05003 	mov	r5, r3
   2dc3c:	e1a06004 	mov	r6, r4
   2dc40:	e3a03000 	mov	r3, #0
   2dc44:	e3a04101 	mov	r4, #1073741824	; 0x40000000
   2dc48:	e24b1034 	sub	r1, fp, #52	; 0x34
   2dc4c:	e8910003 	ldm	r1, {r0, r1}
   2dc50:	e1a02003 	mov	r2, r3
   2dc54:	e1a03004 	mov	r3, r4
   2dc58:	ebff9aa3 	bl	146ec <__aeabi_dsub>
   2dc5c:	e1a03000 	mov	r3, r0
   2dc60:	e1a04001 	mov	r4, r1
   2dc64:	e1a00005 	mov	r0, r5
   2dc68:	e1a01006 	mov	r1, r6
   2dc6c:	e1a02003 	mov	r2, r3
   2dc70:	e1a03004 	mov	r3, r4
   2dc74:	ebff9c45 	bl	14d90 <__aeabi_ddiv>
   2dc78:	e1a03000 	mov	r3, r0
   2dc7c:	e1a04001 	mov	r4, r1
   2dc80:	e1a05003 	mov	r5, r3
   2dc84:	e1a06004 	mov	r6, r4
   2dc88:	e24b101c 	sub	r1, fp, #28
   2dc8c:	e8910003 	ldm	r1, {r0, r1}
   2dc90:	e24b307c 	sub	r3, fp, #124	; 0x7c
   2dc94:	e893000c 	ldm	r3, {r2, r3}
   2dc98:	ebff9b98 	bl	14b00 <__aeabi_dmul>
   2dc9c:	e1a03000 	mov	r3, r0
   2dca0:	e1a04001 	mov	r4, r1
   2dca4:	e1a00003 	mov	r0, r3
   2dca8:	e1a01004 	mov	r1, r4
   2dcac:	e24b307c 	sub	r3, fp, #124	; 0x7c
   2dcb0:	e893000c 	ldm	r3, {r2, r3}
   2dcb4:	ebff9a8d 	bl	146f0 <__adddf3>
   2dcb8:	e1a03000 	mov	r3, r0
   2dcbc:	e1a04001 	mov	r4, r1
   2dcc0:	e1a00005 	mov	r0, r5
   2dcc4:	e1a01006 	mov	r1, r6
   2dcc8:	e1a02003 	mov	r2, r3
   2dccc:	e1a03004 	mov	r3, r4
   2dcd0:	ebff9a85 	bl	146ec <__aeabi_dsub>
   2dcd4:	e1a03000 	mov	r3, r0
   2dcd8:	e1a04001 	mov	r4, r1
   2dcdc:	e50b30bc 	str	r3, [fp, #-188]	; 0xbc
   2dce0:	e50b40b8 	str	r4, [fp, #-184]	; 0xb8
	z  = one-(r-z);
   2dce4:	e3a05000 	mov	r5, #0
   2dce8:	e59f60d0 	ldr	r6, [pc, #208]	; 2ddc0 <__ieee754_pow+0x1e08>
   2dcec:	e24b10bc 	sub	r1, fp, #188	; 0xbc
   2dcf0:	e8910003 	ldm	r1, {r0, r1}
   2dcf4:	e24b301c 	sub	r3, fp, #28
   2dcf8:	e893000c 	ldm	r3, {r2, r3}
   2dcfc:	ebff9a7a 	bl	146ec <__aeabi_dsub>
   2dd00:	e1a03000 	mov	r3, r0
   2dd04:	e1a04001 	mov	r4, r1
   2dd08:	e1a00005 	mov	r0, r5
   2dd0c:	e1a01006 	mov	r1, r6
   2dd10:	e1a02003 	mov	r2, r3
   2dd14:	e1a03004 	mov	r3, r4
   2dd18:	ebff9a73 	bl	146ec <__aeabi_dsub>
   2dd1c:	e1a03000 	mov	r3, r0
   2dd20:	e1a04001 	mov	r4, r1
   2dd24:	e50b301c 	str	r3, [fp, #-28]
   2dd28:	e50b4018 	str	r4, [fp, #-24]
	GET_HIGH_WORD(j,z);
   2dd2c:	e24b401c 	sub	r4, fp, #28
   2dd30:	e8940018 	ldm	r4, {r3, r4}
   2dd34:	e50b315c 	str	r3, [fp, #-348]	; 0x15c
   2dd38:	e50b4158 	str	r4, [fp, #-344]	; 0x158
   2dd3c:	e51b3158 	ldr	r3, [fp, #-344]	; 0x158
   2dd40:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
	j += (n<<20);
   2dd44:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   2dd48:	e1a03a03 	lsl	r3, r3, #20
   2dd4c:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
   2dd50:	e0823003 	add	r3, r2, r3
   2dd54:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
	if((j>>20)<=0) z = scalbn(z,(int)n);	/* subnormal output */
   2dd58:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   2dd5c:	e1a03a43 	asr	r3, r3, #20
   2dd60:	e3530000 	cmp	r3, #0
   2dd64:	ca000016 	bgt	2ddc4 <__ieee754_pow+0x1e0c>
   2dd68:	e24b101c 	sub	r1, fp, #28
   2dd6c:	e8910003 	ldm	r1, {r0, r1}
   2dd70:	e51b2050 	ldr	r2, [fp, #-80]	; 0x50
   2dd74:	eb000df9 	bl	31560 <scalbn>
   2dd78:	e50b001c 	str	r0, [fp, #-28]
   2dd7c:	e50b1018 	str	r1, [fp, #-24]
   2dd80:	ea000019 	b	2ddec <__ieee754_pow+0x1e34>
   2dd84:	e1a00000 	nop			; (mov r0, r0)
   2dd88:	fefa39ef 	.word	0xfefa39ef
   2dd8c:	3fe62e42 	.word	0x3fe62e42
   2dd90:	0ca86c39 	.word	0x0ca86c39
   2dd94:	be205c61 	.word	0xbe205c61
   2dd98:	72bea4d0 	.word	0x72bea4d0
   2dd9c:	3e663769 	.word	0x3e663769
   2dda0:	c5d26bf1 	.word	0xc5d26bf1
   2dda4:	bebbbd41 	.word	0xbebbbd41
   2dda8:	af25de2c 	.word	0xaf25de2c
   2ddac:	3f11566a 	.word	0x3f11566a
   2ddb0:	16bebd93 	.word	0x16bebd93
   2ddb4:	bf66c16c 	.word	0xbf66c16c
   2ddb8:	5555553e 	.word	0x5555553e
   2ddbc:	3fc55555 	.word	0x3fc55555
   2ddc0:	3ff00000 	.word	0x3ff00000
	else SET_HIGH_WORD(z,j);
   2ddc4:	e24b401c 	sub	r4, fp, #28
   2ddc8:	e8940018 	ldm	r4, {r3, r4}
   2ddcc:	e50b3164 	str	r3, [fp, #-356]	; 0x164
   2ddd0:	e50b4160 	str	r4, [fp, #-352]	; 0x160
   2ddd4:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   2ddd8:	e50b3160 	str	r3, [fp, #-352]	; 0x160
   2dddc:	e24b4f59 	sub	r4, fp, #356	; 0x164
   2dde0:	e8940018 	ldm	r4, {r3, r4}
   2dde4:	e50b301c 	str	r3, [fp, #-28]
   2dde8:	e50b4018 	str	r4, [fp, #-24]
	return s*z;
   2ddec:	e24b1044 	sub	r1, fp, #68	; 0x44
   2ddf0:	e8910003 	ldm	r1, {r0, r1}
   2ddf4:	e24b301c 	sub	r3, fp, #28
   2ddf8:	e893000c 	ldm	r3, {r2, r3}
   2ddfc:	ebff9b3f 	bl	14b00 <__aeabi_dmul>
   2de00:	e1a03000 	mov	r3, r0
   2de04:	e1a04001 	mov	r4, r1
   2de08:	e1a05004 	mov	r5, r4
   2de0c:	e1a04003 	mov	r4, r3
   2de10:	e1a03004 	mov	r3, r4
   2de14:	e1a04005 	mov	r4, r5
}
   2de18:	e1a00003 	mov	r0, r3
   2de1c:	e1a01004 	mov	r1, r4
   2de20:	e24bd010 	sub	sp, fp, #16
   2de24:	e8bd4870 	pop	{r4, r5, r6, fp, lr}
   2de28:	e12fff1e 	bx	lr
   2de2c:	e1a00000 	nop			; (mov r0, r0)

0002de30 <__ieee754_rem_pio2>:
	__int32_t __ieee754_rem_pio2(double x, double *y)
#else
	__int32_t __ieee754_rem_pio2(x,y)
	double x,y[];
#endif
{
   2de30:	e92d4bf0 	push	{r4, r5, r6, r7, r8, r9, fp, lr}
   2de34:	e28db01c 	add	fp, sp, #28
   2de38:	e24dd0b8 	sub	sp, sp, #184	; 0xb8
   2de3c:	e50b00bc 	str	r0, [fp, #-188]	; 0xbc
   2de40:	e50b10b8 	str	r1, [fp, #-184]	; 0xb8
   2de44:	e50b20c0 	str	r2, [fp, #-192]	; 0xc0
	double z = 0.0,w,t,r,fn;
   2de48:	e3a02000 	mov	r2, #0
   2de4c:	e3a03000 	mov	r3, #0
   2de50:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   2de54:	e50b3020 	str	r3, [fp, #-32]
	double tx[3];
	__int32_t i,j,n,ix,hx;
	int e0,nx;
	__uint32_t low;

	GET_HIGH_WORD(hx,x);		/* high word of x */
   2de58:	e24b30bc 	sub	r3, fp, #188	; 0xbc
   2de5c:	e893000c 	ldm	r3, {r2, r3}
   2de60:	e50b208c 	str	r2, [fp, #-140]	; 0x8c
   2de64:	e50b3088 	str	r3, [fp, #-136]	; 0x88
   2de68:	e51b3088 	ldr	r3, [fp, #-136]	; 0x88
   2de6c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
	ix = hx&0x7fffffff;
   2de70:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   2de74:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   2de78:	e50b3044 	str	r3, [fp, #-68]	; 0x44
	if(ix<=0x3fe921fb)   /* |x| ~<= pi/4 , no need for reduction */
   2de7c:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   2de80:	e59f3378 	ldr	r3, [pc, #888]	; 2e200 <__ieee754_rem_pio2+0x3d0>
   2de84:	e1520003 	cmp	r2, r3
   2de88:	ca00000a 	bgt	2deb8 <__ieee754_rem_pio2+0x88>
	    {y[0] = x; y[1] = 0; return 0;}
   2de8c:	e51b20c0 	ldr	r2, [fp, #-192]	; 0xc0
   2de90:	e24b40bc 	sub	r4, fp, #188	; 0xbc
   2de94:	e8940018 	ldm	r4, {r3, r4}
   2de98:	e8820018 	stm	r2, {r3, r4}
   2de9c:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2dea0:	e2832008 	add	r2, r3, #8
   2dea4:	e3a03000 	mov	r3, #0
   2dea8:	e3a04000 	mov	r4, #0
   2deac:	e8820018 	stm	r2, {r3, r4}
   2deb0:	e3a03000 	mov	r3, #0
   2deb4:	ea0002ba 	b	2e9a4 <__ieee754_rem_pio2+0xb74>
	if(ix<0x4002d97c) {  /* |x| < 3pi/4, special case with n=+-1 */
   2deb8:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   2debc:	e59f3340 	ldr	r3, [pc, #832]	; 2e204 <__ieee754_rem_pio2+0x3d4>
   2dec0:	e1520003 	cmp	r2, r3
   2dec4:	ca0000d1 	bgt	2e210 <__ieee754_rem_pio2+0x3e0>
	    if(hx>0) { 
   2dec8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   2decc:	e3530000 	cmp	r3, #0
   2ded0:	da000060 	ble	2e058 <__ieee754_rem_pio2+0x228>
		z = x - pio2_1;
   2ded4:	e28f4fc1 	add	r4, pc, #772	; 0x304
   2ded8:	e8940018 	ldm	r4, {r3, r4}
   2dedc:	e24b10bc 	sub	r1, fp, #188	; 0xbc
   2dee0:	e8910003 	ldm	r1, {r0, r1}
   2dee4:	e1a02003 	mov	r2, r3
   2dee8:	e1a03004 	mov	r3, r4
   2deec:	ebff99fe 	bl	146ec <__aeabi_dsub>
   2def0:	e1a03000 	mov	r3, r0
   2def4:	e1a04001 	mov	r4, r1
   2def8:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2defc:	e50b4020 	str	r4, [fp, #-32]
		if(ix!=0x3ff921fb) { 	/* 33+53 bit pi is good enough */
   2df00:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   2df04:	e59f32fc 	ldr	r3, [pc, #764]	; 2e208 <__ieee754_rem_pio2+0x3d8>
   2df08:	e1520003 	cmp	r2, r3
   2df0c:	0a000022 	beq	2df9c <__ieee754_rem_pio2+0x16c>
		    y[0] = z - pio2_1t;
   2df10:	e28f4e2d 	add	r4, pc, #720	; 0x2d0
   2df14:	e8940018 	ldm	r4, {r3, r4}
   2df18:	e24b1024 	sub	r1, fp, #36	; 0x24
   2df1c:	e8910003 	ldm	r1, {r0, r1}
   2df20:	e1a02003 	mov	r2, r3
   2df24:	e1a03004 	mov	r3, r4
   2df28:	ebff99ef 	bl	146ec <__aeabi_dsub>
   2df2c:	e1a03000 	mov	r3, r0
   2df30:	e1a04001 	mov	r4, r1
   2df34:	e51b20c0 	ldr	r2, [fp, #-192]	; 0xc0
   2df38:	e8820018 	stm	r2, {r3, r4}
		    y[1] = (z-y[0])-pio2_1t;
   2df3c:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2df40:	e2835008 	add	r5, r3, #8
   2df44:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2df48:	e8930018 	ldm	r3, {r3, r4}
   2df4c:	e24b1024 	sub	r1, fp, #36	; 0x24
   2df50:	e8910003 	ldm	r1, {r0, r1}
   2df54:	e1a02003 	mov	r2, r3
   2df58:	e1a03004 	mov	r3, r4
   2df5c:	ebff99e2 	bl	146ec <__aeabi_dsub>
   2df60:	e1a03000 	mov	r3, r0
   2df64:	e1a04001 	mov	r4, r1
   2df68:	e1a01003 	mov	r1, r3
   2df6c:	e1a02004 	mov	r2, r4
   2df70:	e28f4e27 	add	r4, pc, #624	; 0x270
   2df74:	e8940018 	ldm	r4, {r3, r4}
   2df78:	e1a00001 	mov	r0, r1
   2df7c:	e1a01002 	mov	r1, r2
   2df80:	e1a02003 	mov	r2, r3
   2df84:	e1a03004 	mov	r3, r4
   2df88:	ebff99d7 	bl	146ec <__aeabi_dsub>
   2df8c:	e1a03000 	mov	r3, r0
   2df90:	e1a04001 	mov	r4, r1
   2df94:	e8850018 	stm	r5, {r3, r4}
   2df98:	ea00002c 	b	2e050 <__ieee754_rem_pio2+0x220>
		} else {		/* near pi/2, use 33+33+53 bit pi */
		    z -= pio2_2;
   2df9c:	e28f4f93 	add	r4, pc, #588	; 0x24c
   2dfa0:	e8940018 	ldm	r4, {r3, r4}
   2dfa4:	e24b1024 	sub	r1, fp, #36	; 0x24
   2dfa8:	e8910003 	ldm	r1, {r0, r1}
   2dfac:	e1a02003 	mov	r2, r3
   2dfb0:	e1a03004 	mov	r3, r4
   2dfb4:	ebff99cc 	bl	146ec <__aeabi_dsub>
   2dfb8:	e1a03000 	mov	r3, r0
   2dfbc:	e1a04001 	mov	r4, r1
   2dfc0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2dfc4:	e50b4020 	str	r4, [fp, #-32]
		    y[0] = z - pio2_2t;
   2dfc8:	e28f4f8a 	add	r4, pc, #552	; 0x228
   2dfcc:	e8940018 	ldm	r4, {r3, r4}
   2dfd0:	e24b1024 	sub	r1, fp, #36	; 0x24
   2dfd4:	e8910003 	ldm	r1, {r0, r1}
   2dfd8:	e1a02003 	mov	r2, r3
   2dfdc:	e1a03004 	mov	r3, r4
   2dfe0:	ebff99c1 	bl	146ec <__aeabi_dsub>
   2dfe4:	e1a03000 	mov	r3, r0
   2dfe8:	e1a04001 	mov	r4, r1
   2dfec:	e51b20c0 	ldr	r2, [fp, #-192]	; 0xc0
   2dff0:	e8820018 	stm	r2, {r3, r4}
		    y[1] = (z-y[0])-pio2_2t;
   2dff4:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2dff8:	e2835008 	add	r5, r3, #8
   2dffc:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e000:	e8930018 	ldm	r3, {r3, r4}
   2e004:	e24b1024 	sub	r1, fp, #36	; 0x24
   2e008:	e8910003 	ldm	r1, {r0, r1}
   2e00c:	e1a02003 	mov	r2, r3
   2e010:	e1a03004 	mov	r3, r4
   2e014:	ebff99b4 	bl	146ec <__aeabi_dsub>
   2e018:	e1a03000 	mov	r3, r0
   2e01c:	e1a04001 	mov	r4, r1
   2e020:	e1a01003 	mov	r1, r3
   2e024:	e1a02004 	mov	r2, r4
   2e028:	e28f4f72 	add	r4, pc, #456	; 0x1c8
   2e02c:	e8940018 	ldm	r4, {r3, r4}
   2e030:	e1a00001 	mov	r0, r1
   2e034:	e1a01002 	mov	r1, r2
   2e038:	e1a02003 	mov	r2, r3
   2e03c:	e1a03004 	mov	r3, r4
   2e040:	ebff99a9 	bl	146ec <__aeabi_dsub>
   2e044:	e1a03000 	mov	r3, r0
   2e048:	e1a04001 	mov	r4, r1
   2e04c:	e8850018 	stm	r5, {r3, r4}
		}
		return 1;
   2e050:	e3a03001 	mov	r3, #1
   2e054:	ea000252 	b	2e9a4 <__ieee754_rem_pio2+0xb74>
	    } else {	/* negative x */
		z = x + pio2_1;
   2e058:	e28f4d06 	add	r4, pc, #384	; 0x180
   2e05c:	e8940018 	ldm	r4, {r3, r4}
   2e060:	e24b10bc 	sub	r1, fp, #188	; 0xbc
   2e064:	e8910003 	ldm	r1, {r0, r1}
   2e068:	e1a02003 	mov	r2, r3
   2e06c:	e1a03004 	mov	r3, r4
   2e070:	ebff999e 	bl	146f0 <__adddf3>
   2e074:	e1a03000 	mov	r3, r0
   2e078:	e1a04001 	mov	r4, r1
   2e07c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2e080:	e50b4020 	str	r4, [fp, #-32]
		if(ix!=0x3ff921fb) { 	/* 33+53 bit pi is good enough */
   2e084:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   2e088:	e59f3178 	ldr	r3, [pc, #376]	; 2e208 <__ieee754_rem_pio2+0x3d8>
   2e08c:	e1520003 	cmp	r2, r3
   2e090:	0a000022 	beq	2e120 <__ieee754_rem_pio2+0x2f0>
		    y[0] = z + pio2_1t;
   2e094:	e28f4f53 	add	r4, pc, #332	; 0x14c
   2e098:	e8940018 	ldm	r4, {r3, r4}
   2e09c:	e1a00003 	mov	r0, r3
   2e0a0:	e1a01004 	mov	r1, r4
   2e0a4:	e24b3024 	sub	r3, fp, #36	; 0x24
   2e0a8:	e893000c 	ldm	r3, {r2, r3}
   2e0ac:	ebff998f 	bl	146f0 <__adddf3>
   2e0b0:	e1a03000 	mov	r3, r0
   2e0b4:	e1a04001 	mov	r4, r1
   2e0b8:	e51b20c0 	ldr	r2, [fp, #-192]	; 0xc0
   2e0bc:	e8820018 	stm	r2, {r3, r4}
		    y[1] = (z-y[0])+pio2_1t;
   2e0c0:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e0c4:	e2835008 	add	r5, r3, #8
   2e0c8:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e0cc:	e8930018 	ldm	r3, {r3, r4}
   2e0d0:	e24b1024 	sub	r1, fp, #36	; 0x24
   2e0d4:	e8910003 	ldm	r1, {r0, r1}
   2e0d8:	e1a02003 	mov	r2, r3
   2e0dc:	e1a03004 	mov	r3, r4
   2e0e0:	ebff9981 	bl	146ec <__aeabi_dsub>
   2e0e4:	e1a03000 	mov	r3, r0
   2e0e8:	e1a04001 	mov	r4, r1
   2e0ec:	e1a01003 	mov	r1, r3
   2e0f0:	e1a02004 	mov	r2, r4
   2e0f4:	e28f40ec 	add	r4, pc, #236	; 0xec
   2e0f8:	e8940018 	ldm	r4, {r3, r4}
   2e0fc:	e1a00001 	mov	r0, r1
   2e100:	e1a01002 	mov	r1, r2
   2e104:	e1a02003 	mov	r2, r3
   2e108:	e1a03004 	mov	r3, r4
   2e10c:	ebff9977 	bl	146f0 <__adddf3>
   2e110:	e1a03000 	mov	r3, r0
   2e114:	e1a04001 	mov	r4, r1
   2e118:	e8850018 	stm	r5, {r3, r4}
   2e11c:	ea00002c 	b	2e1d4 <__ieee754_rem_pio2+0x3a4>
		} else {		/* near pi/2, use 33+33+53 bit pi */
		    z += pio2_2;
   2e120:	e28f40c8 	add	r4, pc, #200	; 0xc8
   2e124:	e8940018 	ldm	r4, {r3, r4}
   2e128:	e24b1024 	sub	r1, fp, #36	; 0x24
   2e12c:	e8910003 	ldm	r1, {r0, r1}
   2e130:	e1a02003 	mov	r2, r3
   2e134:	e1a03004 	mov	r3, r4
   2e138:	ebff996c 	bl	146f0 <__adddf3>
   2e13c:	e1a03000 	mov	r3, r0
   2e140:	e1a04001 	mov	r4, r1
   2e144:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2e148:	e50b4020 	str	r4, [fp, #-32]
		    y[0] = z + pio2_2t;
   2e14c:	e28f40a4 	add	r4, pc, #164	; 0xa4
   2e150:	e8940018 	ldm	r4, {r3, r4}
   2e154:	e1a00003 	mov	r0, r3
   2e158:	e1a01004 	mov	r1, r4
   2e15c:	e24b3024 	sub	r3, fp, #36	; 0x24
   2e160:	e893000c 	ldm	r3, {r2, r3}
   2e164:	ebff9961 	bl	146f0 <__adddf3>
   2e168:	e1a03000 	mov	r3, r0
   2e16c:	e1a04001 	mov	r4, r1
   2e170:	e51b20c0 	ldr	r2, [fp, #-192]	; 0xc0
   2e174:	e8820018 	stm	r2, {r3, r4}
		    y[1] = (z-y[0])+pio2_2t;
   2e178:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e17c:	e2835008 	add	r5, r3, #8
   2e180:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e184:	e8930018 	ldm	r3, {r3, r4}
   2e188:	e24b1024 	sub	r1, fp, #36	; 0x24
   2e18c:	e8910003 	ldm	r1, {r0, r1}
   2e190:	e1a02003 	mov	r2, r3
   2e194:	e1a03004 	mov	r3, r4
   2e198:	ebff9953 	bl	146ec <__aeabi_dsub>
   2e19c:	e1a03000 	mov	r3, r0
   2e1a0:	e1a04001 	mov	r4, r1
   2e1a4:	e1a01003 	mov	r1, r3
   2e1a8:	e1a02004 	mov	r2, r4
   2e1ac:	e28f4044 	add	r4, pc, #68	; 0x44
   2e1b0:	e8940018 	ldm	r4, {r3, r4}
   2e1b4:	e1a00001 	mov	r0, r1
   2e1b8:	e1a01002 	mov	r1, r2
   2e1bc:	e1a02003 	mov	r2, r3
   2e1c0:	e1a03004 	mov	r3, r4
   2e1c4:	ebff9949 	bl	146f0 <__adddf3>
   2e1c8:	e1a03000 	mov	r3, r0
   2e1cc:	e1a04001 	mov	r4, r1
   2e1d0:	e8850018 	stm	r5, {r3, r4}
		}
		return -1;
   2e1d4:	e3e03000 	mvn	r3, #0
   2e1d8:	ea0001f1 	b	2e9a4 <__ieee754_rem_pio2+0xb74>
   2e1dc:	e1a00000 	nop			; (mov r0, r0)
   2e1e0:	54400000 	.word	0x54400000
   2e1e4:	3ff921fb 	.word	0x3ff921fb
   2e1e8:	1a626331 	.word	0x1a626331
   2e1ec:	3dd0b461 	.word	0x3dd0b461
   2e1f0:	1a600000 	.word	0x1a600000
   2e1f4:	3dd0b461 	.word	0x3dd0b461
   2e1f8:	2e037073 	.word	0x2e037073
   2e1fc:	3ba3198a 	.word	0x3ba3198a
   2e200:	3fe921fb 	.word	0x3fe921fb
   2e204:	4002d97b 	.word	0x4002d97b
   2e208:	3ff921fb 	.word	0x3ff921fb
   2e20c:	413921fb 	.word	0x413921fb
	    }
	}
	if(ix<=0x413921fb) { /* |x| ~<= 2^19*(pi/2), medium size */
   2e210:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   2e214:	e51f3010 	ldr	r3, [pc, #-16]	; 2e20c <__ieee754_rem_pio2+0x3dc>
   2e218:	e1520003 	cmp	r2, r3
   2e21c:	ca00013b 	bgt	2e710 <__ieee754_rem_pio2+0x8e0>
	    t  = fabs(x);
   2e220:	e24b10bc 	sub	r1, fp, #188	; 0xbc
   2e224:	e8910003 	ldm	r1, {r0, r1}
   2e228:	eb000a98 	bl	30c90 <fabs>
   2e22c:	e50b004c 	str	r0, [fp, #-76]	; 0x4c
   2e230:	e50b1048 	str	r1, [fp, #-72]	; 0x48
	    n  = (__int32_t) (t*invpio2+half);
   2e234:	e28f4f4f 	add	r4, pc, #316	; 0x13c
   2e238:	e8940018 	ldm	r4, {r3, r4}
   2e23c:	e1a00003 	mov	r0, r3
   2e240:	e1a01004 	mov	r1, r4
   2e244:	e24b304c 	sub	r3, fp, #76	; 0x4c
   2e248:	e893000c 	ldm	r3, {r2, r3}
   2e24c:	ebff9a2b 	bl	14b00 <__aeabi_dmul>
   2e250:	e1a03000 	mov	r3, r0
   2e254:	e1a04001 	mov	r4, r1
   2e258:	e1a01003 	mov	r1, r3
   2e25c:	e1a02004 	mov	r2, r4
   2e260:	e3a03000 	mov	r3, #0
   2e264:	e59f4124 	ldr	r4, [pc, #292]	; 2e390 <__ieee754_rem_pio2+0x560>
   2e268:	e1a00001 	mov	r0, r1
   2e26c:	e1a01002 	mov	r1, r2
   2e270:	e1a02003 	mov	r2, r3
   2e274:	e1a03004 	mov	r3, r4
   2e278:	ebff991c 	bl	146f0 <__adddf3>
   2e27c:	e1a03000 	mov	r3, r0
   2e280:	e1a04001 	mov	r4, r1
   2e284:	e1a00003 	mov	r0, r3
   2e288:	e1a01004 	mov	r1, r4
   2e28c:	ebff9b93 	bl	150e0 <__aeabi_d2iz>
   2e290:	e1a03000 	mov	r3, r0
   2e294:	e50b3050 	str	r3, [fp, #-80]	; 0x50
	    fn = (double)n;
   2e298:	e51b0050 	ldr	r0, [fp, #-80]	; 0x50
   2e29c:	ebff99e0 	bl	14a24 <__aeabi_i2d>
   2e2a0:	e1a03000 	mov	r3, r0
   2e2a4:	e1a04001 	mov	r4, r1
   2e2a8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   2e2ac:	e50b4058 	str	r4, [fp, #-88]	; 0x58
	    r  = t-fn*pio2_1;
   2e2b0:	e28f40c8 	add	r4, pc, #200	; 0xc8
   2e2b4:	e8940018 	ldm	r4, {r3, r4}
   2e2b8:	e1a00003 	mov	r0, r3
   2e2bc:	e1a01004 	mov	r1, r4
   2e2c0:	e24b305c 	sub	r3, fp, #92	; 0x5c
   2e2c4:	e893000c 	ldm	r3, {r2, r3}
   2e2c8:	ebff9a0c 	bl	14b00 <__aeabi_dmul>
   2e2cc:	e1a03000 	mov	r3, r0
   2e2d0:	e1a04001 	mov	r4, r1
   2e2d4:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2e2d8:	e8910003 	ldm	r1, {r0, r1}
   2e2dc:	e1a02003 	mov	r2, r3
   2e2e0:	e1a03004 	mov	r3, r4
   2e2e4:	ebff9900 	bl	146ec <__aeabi_dsub>
   2e2e8:	e1a03000 	mov	r3, r0
   2e2ec:	e1a04001 	mov	r4, r1
   2e2f0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2e2f4:	e50b4030 	str	r4, [fp, #-48]	; 0x30
	    w  = fn*pio2_1t;	/* 1st round good to 85 bit */
   2e2f8:	e28f4088 	add	r4, pc, #136	; 0x88
   2e2fc:	e8940018 	ldm	r4, {r3, r4}
   2e300:	e24b105c 	sub	r1, fp, #92	; 0x5c
   2e304:	e8910003 	ldm	r1, {r0, r1}
   2e308:	e1a02003 	mov	r2, r3
   2e30c:	e1a03004 	mov	r3, r4
   2e310:	ebff99fa 	bl	14b00 <__aeabi_dmul>
   2e314:	e1a03000 	mov	r3, r0
   2e318:	e1a04001 	mov	r4, r1
   2e31c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2e320:	e50b4028 	str	r4, [fp, #-40]	; 0x28
	    if(n<32&&ix!=npio2_hw[n-1]) {	
   2e324:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   2e328:	e353001f 	cmp	r3, #31
   2e32c:	ca000019 	bgt	2e398 <__ieee754_rem_pio2+0x568>
   2e330:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   2e334:	e2432001 	sub	r2, r3, #1
   2e338:	e59f3054 	ldr	r3, [pc, #84]	; 2e394 <__ieee754_rem_pio2+0x564>
   2e33c:	e7932102 	ldr	r2, [r3, r2, lsl #2]
   2e340:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2e344:	e1520003 	cmp	r2, r3
   2e348:	0a000012 	beq	2e398 <__ieee754_rem_pio2+0x568>
		y[0] = r-w;	/* quick check no cancellation */
   2e34c:	e24b1034 	sub	r1, fp, #52	; 0x34
   2e350:	e8910003 	ldm	r1, {r0, r1}
   2e354:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2e358:	e893000c 	ldm	r3, {r2, r3}
   2e35c:	ebff98e2 	bl	146ec <__aeabi_dsub>
   2e360:	e1a03000 	mov	r3, r0
   2e364:	e1a04001 	mov	r4, r1
   2e368:	e51b20c0 	ldr	r2, [fp, #-192]	; 0xc0
   2e36c:	e8820018 	stm	r2, {r3, r4}
   2e370:	ea0000ba 	b	2e660 <__ieee754_rem_pio2+0x830>
   2e374:	e1a00000 	nop			; (mov r0, r0)
   2e378:	6dc9c883 	.word	0x6dc9c883
   2e37c:	3fe45f30 	.word	0x3fe45f30
   2e380:	54400000 	.word	0x54400000
   2e384:	3ff921fb 	.word	0x3ff921fb
   2e388:	1a626331 	.word	0x1a626331
   2e38c:	3dd0b461 	.word	0x3dd0b461
   2e390:	3fe00000 	.word	0x3fe00000
   2e394:	000336cc 	.word	0x000336cc
	    } else {
	        __uint32_t high;
	        j  = ix>>20;
   2e398:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2e39c:	e1a03a43 	asr	r3, r3, #20
   2e3a0:	e50b3060 	str	r3, [fp, #-96]	; 0x60
	        y[0] = r-w; 
   2e3a4:	e24b1034 	sub	r1, fp, #52	; 0x34
   2e3a8:	e8910003 	ldm	r1, {r0, r1}
   2e3ac:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2e3b0:	e893000c 	ldm	r3, {r2, r3}
   2e3b4:	ebff98cc 	bl	146ec <__aeabi_dsub>
   2e3b8:	e1a03000 	mov	r3, r0
   2e3bc:	e1a04001 	mov	r4, r1
   2e3c0:	e51b20c0 	ldr	r2, [fp, #-192]	; 0xc0
   2e3c4:	e8820018 	stm	r2, {r3, r4}
		GET_HIGH_WORD(high,y[0]);
   2e3c8:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e3cc:	e8930018 	ldm	r3, {r3, r4}
   2e3d0:	e50b3094 	str	r3, [fp, #-148]	; 0x94
   2e3d4:	e50b4090 	str	r4, [fp, #-144]	; 0x90
   2e3d8:	e51b3090 	ldr	r3, [fp, #-144]	; 0x90
   2e3dc:	e50b3064 	str	r3, [fp, #-100]	; 0x64
	        i = j-((high>>20)&0x7ff);
   2e3e0:	e51b2060 	ldr	r2, [fp, #-96]	; 0x60
   2e3e4:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   2e3e8:	e1a03a23 	lsr	r3, r3, #20
   2e3ec:	e1a03a83 	lsl	r3, r3, #21
   2e3f0:	e1a03aa3 	lsr	r3, r3, #21
   2e3f4:	e0633002 	rsb	r3, r3, r2
   2e3f8:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	        if(i>16) {  /* 2nd iteration needed, good to 118 */
   2e3fc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2e400:	e3530010 	cmp	r3, #16
   2e404:	da000095 	ble	2e660 <__ieee754_rem_pio2+0x830>
		    t  = r;
   2e408:	e24b4034 	sub	r4, fp, #52	; 0x34
   2e40c:	e8940018 	ldm	r4, {r3, r4}
   2e410:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   2e414:	e50b4048 	str	r4, [fp, #-72]	; 0x48
		    w  = fn*pio2_2;	
   2e418:	e28f4d0d 	add	r4, pc, #832	; 0x340
   2e41c:	e8940018 	ldm	r4, {r3, r4}
   2e420:	e24b105c 	sub	r1, fp, #92	; 0x5c
   2e424:	e8910003 	ldm	r1, {r0, r1}
   2e428:	e1a02003 	mov	r2, r3
   2e42c:	e1a03004 	mov	r3, r4
   2e430:	ebff99b2 	bl	14b00 <__aeabi_dmul>
   2e434:	e1a03000 	mov	r3, r0
   2e438:	e1a04001 	mov	r4, r1
   2e43c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2e440:	e50b4028 	str	r4, [fp, #-40]	; 0x28
		    r  = t-w;
   2e444:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2e448:	e8910003 	ldm	r1, {r0, r1}
   2e44c:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2e450:	e893000c 	ldm	r3, {r2, r3}
   2e454:	ebff98a4 	bl	146ec <__aeabi_dsub>
   2e458:	e1a03000 	mov	r3, r0
   2e45c:	e1a04001 	mov	r4, r1
   2e460:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2e464:	e50b4030 	str	r4, [fp, #-48]	; 0x30
		    w  = fn*pio2_2t-((t-r)-w);	
   2e468:	e28f4fbe 	add	r4, pc, #760	; 0x2f8
   2e46c:	e8940018 	ldm	r4, {r3, r4}
   2e470:	e1a00003 	mov	r0, r3
   2e474:	e1a01004 	mov	r1, r4
   2e478:	e24b305c 	sub	r3, fp, #92	; 0x5c
   2e47c:	e893000c 	ldm	r3, {r2, r3}
   2e480:	ebff999e 	bl	14b00 <__aeabi_dmul>
   2e484:	e1a03000 	mov	r3, r0
   2e488:	e1a04001 	mov	r4, r1
   2e48c:	e1a05003 	mov	r5, r3
   2e490:	e1a06004 	mov	r6, r4
   2e494:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2e498:	e8910003 	ldm	r1, {r0, r1}
   2e49c:	e24b3034 	sub	r3, fp, #52	; 0x34
   2e4a0:	e893000c 	ldm	r3, {r2, r3}
   2e4a4:	ebff9890 	bl	146ec <__aeabi_dsub>
   2e4a8:	e1a03000 	mov	r3, r0
   2e4ac:	e1a04001 	mov	r4, r1
   2e4b0:	e1a00003 	mov	r0, r3
   2e4b4:	e1a01004 	mov	r1, r4
   2e4b8:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2e4bc:	e893000c 	ldm	r3, {r2, r3}
   2e4c0:	ebff9889 	bl	146ec <__aeabi_dsub>
   2e4c4:	e1a03000 	mov	r3, r0
   2e4c8:	e1a04001 	mov	r4, r1
   2e4cc:	e1a00005 	mov	r0, r5
   2e4d0:	e1a01006 	mov	r1, r6
   2e4d4:	e1a02003 	mov	r2, r3
   2e4d8:	e1a03004 	mov	r3, r4
   2e4dc:	ebff9882 	bl	146ec <__aeabi_dsub>
   2e4e0:	e1a03000 	mov	r3, r0
   2e4e4:	e1a04001 	mov	r4, r1
   2e4e8:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2e4ec:	e50b4028 	str	r4, [fp, #-40]	; 0x28
		    y[0] = r-w;
   2e4f0:	e24b1034 	sub	r1, fp, #52	; 0x34
   2e4f4:	e8910003 	ldm	r1, {r0, r1}
   2e4f8:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2e4fc:	e893000c 	ldm	r3, {r2, r3}
   2e500:	ebff9879 	bl	146ec <__aeabi_dsub>
   2e504:	e1a03000 	mov	r3, r0
   2e508:	e1a04001 	mov	r4, r1
   2e50c:	e51b20c0 	ldr	r2, [fp, #-192]	; 0xc0
   2e510:	e8820018 	stm	r2, {r3, r4}
		    GET_HIGH_WORD(high,y[0]);
   2e514:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e518:	e8930018 	ldm	r3, {r3, r4}
   2e51c:	e50b309c 	str	r3, [fp, #-156]	; 0x9c
   2e520:	e50b4098 	str	r4, [fp, #-152]	; 0x98
   2e524:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   2e528:	e50b3064 	str	r3, [fp, #-100]	; 0x64
		    i = j-((high>>20)&0x7ff);
   2e52c:	e51b2060 	ldr	r2, [fp, #-96]	; 0x60
   2e530:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   2e534:	e1a03a23 	lsr	r3, r3, #20
   2e538:	e1a03a83 	lsl	r3, r3, #21
   2e53c:	e1a03aa3 	lsr	r3, r3, #21
   2e540:	e0633002 	rsb	r3, r3, r2
   2e544:	e50b3038 	str	r3, [fp, #-56]	; 0x38
		    if(i>49)  {	/* 3rd iteration need, 151 bits acc */
   2e548:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2e54c:	e3530031 	cmp	r3, #49	; 0x31
   2e550:	da000042 	ble	2e660 <__ieee754_rem_pio2+0x830>
		    	t  = r;	/* will cover all possible cases */
   2e554:	e24b4034 	sub	r4, fp, #52	; 0x34
   2e558:	e8940018 	ldm	r4, {r3, r4}
   2e55c:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   2e560:	e50b4048 	str	r4, [fp, #-72]	; 0x48
		    	w  = fn*pio2_3;	
   2e564:	e3a0342e 	mov	r3, #771751936	; 0x2e000000
   2e568:	e59f4208 	ldr	r4, [pc, #520]	; 2e778 <__ieee754_rem_pio2+0x948>
   2e56c:	e24b105c 	sub	r1, fp, #92	; 0x5c
   2e570:	e8910003 	ldm	r1, {r0, r1}
   2e574:	e1a02003 	mov	r2, r3
   2e578:	e1a03004 	mov	r3, r4
   2e57c:	ebff995f 	bl	14b00 <__aeabi_dmul>
   2e580:	e1a03000 	mov	r3, r0
   2e584:	e1a04001 	mov	r4, r1
   2e588:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2e58c:	e50b4028 	str	r4, [fp, #-40]	; 0x28
		    	r  = t-w;
   2e590:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2e594:	e8910003 	ldm	r1, {r0, r1}
   2e598:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2e59c:	e893000c 	ldm	r3, {r2, r3}
   2e5a0:	ebff9851 	bl	146ec <__aeabi_dsub>
   2e5a4:	e1a03000 	mov	r3, r0
   2e5a8:	e1a04001 	mov	r4, r1
   2e5ac:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2e5b0:	e50b4030 	str	r4, [fp, #-48]	; 0x30
		    	w  = fn*pio2_3t-((t-r)-w);	
   2e5b4:	e28f4f6d 	add	r4, pc, #436	; 0x1b4
   2e5b8:	e8940018 	ldm	r4, {r3, r4}
   2e5bc:	e1a00003 	mov	r0, r3
   2e5c0:	e1a01004 	mov	r1, r4
   2e5c4:	e24b305c 	sub	r3, fp, #92	; 0x5c
   2e5c8:	e893000c 	ldm	r3, {r2, r3}
   2e5cc:	ebff994b 	bl	14b00 <__aeabi_dmul>
   2e5d0:	e1a03000 	mov	r3, r0
   2e5d4:	e1a04001 	mov	r4, r1
   2e5d8:	e1a05003 	mov	r5, r3
   2e5dc:	e1a06004 	mov	r6, r4
   2e5e0:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2e5e4:	e8910003 	ldm	r1, {r0, r1}
   2e5e8:	e24b3034 	sub	r3, fp, #52	; 0x34
   2e5ec:	e893000c 	ldm	r3, {r2, r3}
   2e5f0:	ebff983d 	bl	146ec <__aeabi_dsub>
   2e5f4:	e1a03000 	mov	r3, r0
   2e5f8:	e1a04001 	mov	r4, r1
   2e5fc:	e1a00003 	mov	r0, r3
   2e600:	e1a01004 	mov	r1, r4
   2e604:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2e608:	e893000c 	ldm	r3, {r2, r3}
   2e60c:	ebff9836 	bl	146ec <__aeabi_dsub>
   2e610:	e1a03000 	mov	r3, r0
   2e614:	e1a04001 	mov	r4, r1
   2e618:	e1a00005 	mov	r0, r5
   2e61c:	e1a01006 	mov	r1, r6
   2e620:	e1a02003 	mov	r2, r3
   2e624:	e1a03004 	mov	r3, r4
   2e628:	ebff982f 	bl	146ec <__aeabi_dsub>
   2e62c:	e1a03000 	mov	r3, r0
   2e630:	e1a04001 	mov	r4, r1
   2e634:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2e638:	e50b4028 	str	r4, [fp, #-40]	; 0x28
		    	y[0] = r-w;
   2e63c:	e24b1034 	sub	r1, fp, #52	; 0x34
   2e640:	e8910003 	ldm	r1, {r0, r1}
   2e644:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2e648:	e893000c 	ldm	r3, {r2, r3}
   2e64c:	ebff9826 	bl	146ec <__aeabi_dsub>
   2e650:	e1a03000 	mov	r3, r0
   2e654:	e1a04001 	mov	r4, r1
   2e658:	e51b20c0 	ldr	r2, [fp, #-192]	; 0xc0
   2e65c:	e8820018 	stm	r2, {r3, r4}
		    }
		}
	    }
	    y[1] = (r-y[0])-w;
   2e660:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e664:	e2835008 	add	r5, r3, #8
   2e668:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e66c:	e8930018 	ldm	r3, {r3, r4}
   2e670:	e24b1034 	sub	r1, fp, #52	; 0x34
   2e674:	e8910003 	ldm	r1, {r0, r1}
   2e678:	e1a02003 	mov	r2, r3
   2e67c:	e1a03004 	mov	r3, r4
   2e680:	ebff9819 	bl	146ec <__aeabi_dsub>
   2e684:	e1a03000 	mov	r3, r0
   2e688:	e1a04001 	mov	r4, r1
   2e68c:	e1a00003 	mov	r0, r3
   2e690:	e1a01004 	mov	r1, r4
   2e694:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2e698:	e893000c 	ldm	r3, {r2, r3}
   2e69c:	ebff9812 	bl	146ec <__aeabi_dsub>
   2e6a0:	e1a03000 	mov	r3, r0
   2e6a4:	e1a04001 	mov	r4, r1
   2e6a8:	e8850018 	stm	r5, {r3, r4}
	    if(hx<0) 	{y[0] = -y[0]; y[1] = -y[1]; return -n;}
   2e6ac:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   2e6b0:	e3530000 	cmp	r3, #0
   2e6b4:	aa000013 	bge	2e708 <__ieee754_rem_pio2+0x8d8>
   2e6b8:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e6bc:	e8930018 	ldm	r3, {r3, r4}
   2e6c0:	e50b30cc 	str	r3, [fp, #-204]	; 0xcc
   2e6c4:	e2241102 	eor	r1, r4, #-2147483648	; 0x80000000
   2e6c8:	e50b10c8 	str	r1, [fp, #-200]	; 0xc8
   2e6cc:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e6d0:	e24b20cc 	sub	r2, fp, #204	; 0xcc
   2e6d4:	e8920006 	ldm	r2, {r1, r2}
   2e6d8:	e8830006 	stm	r3, {r1, r2}
   2e6dc:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e6e0:	e2832008 	add	r2, r3, #8
   2e6e4:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e6e8:	e2833008 	add	r3, r3, #8
   2e6ec:	e8930018 	ldm	r3, {r3, r4}
   2e6f0:	e1a08003 	mov	r8, r3
   2e6f4:	e2249102 	eor	r9, r4, #-2147483648	; 0x80000000
   2e6f8:	e8820300 	stm	r2, {r8, r9}
   2e6fc:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   2e700:	e2633000 	rsb	r3, r3, #0
   2e704:	ea0000a6 	b	2e9a4 <__ieee754_rem_pio2+0xb74>
	    else	 return n;
   2e708:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   2e70c:	ea0000a4 	b	2e9a4 <__ieee754_rem_pio2+0xb74>
	}
    /* 
     * all other (large) arguments
     */
	if(ix>=0x7ff00000) {		/* x is inf or NaN */
   2e710:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   2e714:	e59f3060 	ldr	r3, [pc, #96]	; 2e77c <__ieee754_rem_pio2+0x94c>
   2e718:	e1520003 	cmp	r2, r3
   2e71c:	da000019 	ble	2e788 <__ieee754_rem_pio2+0x958>
	    y[0]=y[1]=x-x; return 0;
   2e720:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e724:	e2835008 	add	r5, r3, #8
   2e728:	e24b10bc 	sub	r1, fp, #188	; 0xbc
   2e72c:	e8910003 	ldm	r1, {r0, r1}
   2e730:	e24b30bc 	sub	r3, fp, #188	; 0xbc
   2e734:	e893000c 	ldm	r3, {r2, r3}
   2e738:	ebff97eb 	bl	146ec <__aeabi_dsub>
   2e73c:	e1a03000 	mov	r3, r0
   2e740:	e1a04001 	mov	r4, r1
   2e744:	e8850018 	stm	r5, {r3, r4}
   2e748:	e8950018 	ldm	r5, {r3, r4}
   2e74c:	e51b20c0 	ldr	r2, [fp, #-192]	; 0xc0
   2e750:	e8820018 	stm	r2, {r3, r4}
   2e754:	e3a03000 	mov	r3, #0
   2e758:	ea000091 	b	2e9a4 <__ieee754_rem_pio2+0xb74>
   2e75c:	e1a00000 	nop			; (mov r0, r0)
   2e760:	1a600000 	.word	0x1a600000
   2e764:	3dd0b461 	.word	0x3dd0b461
   2e768:	2e037073 	.word	0x2e037073
   2e76c:	3ba3198a 	.word	0x3ba3198a
   2e770:	252049c1 	.word	0x252049c1
   2e774:	397b839a 	.word	0x397b839a
   2e778:	3ba3198a 	.word	0x3ba3198a
   2e77c:	7fefffff 	.word	0x7fefffff
   2e780:	41700000 	.word	0x41700000
   2e784:	000335c4 	.word	0x000335c4
	}
    /* set z = scalbn(|x|,ilogb(x)-23) */
	GET_LOW_WORD(low,x);
   2e788:	e24b30bc 	sub	r3, fp, #188	; 0xbc
   2e78c:	e893000c 	ldm	r3, {r2, r3}
   2e790:	e50b20a4 	str	r2, [fp, #-164]	; 0xa4
   2e794:	e50b30a0 	str	r3, [fp, #-160]	; 0xa0
   2e798:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   2e79c:	e50b3068 	str	r3, [fp, #-104]	; 0x68
	SET_LOW_WORD(z,low);
   2e7a0:	e24b3024 	sub	r3, fp, #36	; 0x24
   2e7a4:	e893000c 	ldm	r3, {r2, r3}
   2e7a8:	e50b20ac 	str	r2, [fp, #-172]	; 0xac
   2e7ac:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   2e7b0:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   2e7b4:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   2e7b8:	e24b30ac 	sub	r3, fp, #172	; 0xac
   2e7bc:	e893000c 	ldm	r3, {r2, r3}
   2e7c0:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   2e7c4:	e50b3020 	str	r3, [fp, #-32]
	e0 	= (int)((ix>>20)-1046);	/* e0 = ilogb(z)-23; */
   2e7c8:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2e7cc:	e1a03a43 	asr	r3, r3, #20
   2e7d0:	e2433e41 	sub	r3, r3, #1040	; 0x410
   2e7d4:	e2433006 	sub	r3, r3, #6
   2e7d8:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
	SET_HIGH_WORD(z, ix - ((__int32_t)e0<<20));
   2e7dc:	e24b3024 	sub	r3, fp, #36	; 0x24
   2e7e0:	e893000c 	ldm	r3, {r2, r3}
   2e7e4:	e50b20b4 	str	r2, [fp, #-180]	; 0xb4
   2e7e8:	e50b30b0 	str	r3, [fp, #-176]	; 0xb0
   2e7ec:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   2e7f0:	e1a03a03 	lsl	r3, r3, #20
   2e7f4:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   2e7f8:	e0633002 	rsb	r3, r3, r2
   2e7fc:	e50b30b0 	str	r3, [fp, #-176]	; 0xb0
   2e800:	e24b30b4 	sub	r3, fp, #180	; 0xb4
   2e804:	e893000c 	ldm	r3, {r2, r3}
   2e808:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   2e80c:	e50b3020 	str	r3, [fp, #-32]
	for(i=0;i<2;i++) {
   2e810:	e3a03000 	mov	r3, #0
   2e814:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2e818:	ea000026 	b	2e8b8 <__ieee754_rem_pio2+0xa88>
		tx[i] = (double)((__int32_t)(z));
   2e81c:	e24b1024 	sub	r1, fp, #36	; 0x24
   2e820:	e8910003 	ldm	r1, {r0, r1}
   2e824:	ebff9a2d 	bl	150e0 <__aeabi_d2iz>
   2e828:	e1a03000 	mov	r3, r0
   2e82c:	e1a00003 	mov	r0, r3
   2e830:	ebff987b 	bl	14a24 <__aeabi_i2d>
   2e834:	e1a02000 	mov	r2, r0
   2e838:	e1a03001 	mov	r3, r1
   2e83c:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
   2e840:	e3e01067 	mvn	r1, #103	; 0x67
   2e844:	e1a00180 	lsl	r0, r0, #3
   2e848:	e24bc01c 	sub	ip, fp, #28
   2e84c:	e08c0000 	add	r0, ip, r0
   2e850:	e0801001 	add	r1, r0, r1
   2e854:	e881000c 	stm	r1, {r2, r3}
		z     = (z-tx[i])*two24;
   2e858:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   2e85c:	e3e03067 	mvn	r3, #103	; 0x67
   2e860:	e1a02182 	lsl	r2, r2, #3
   2e864:	e24b101c 	sub	r1, fp, #28
   2e868:	e0812002 	add	r2, r1, r2
   2e86c:	e0823003 	add	r3, r2, r3
   2e870:	e893000c 	ldm	r3, {r2, r3}
   2e874:	e24b1024 	sub	r1, fp, #36	; 0x24
   2e878:	e8910003 	ldm	r1, {r0, r1}
   2e87c:	ebff979a 	bl	146ec <__aeabi_dsub>
   2e880:	e1a02000 	mov	r2, r0
   2e884:	e1a03001 	mov	r3, r1
   2e888:	e1a00002 	mov	r0, r2
   2e88c:	e1a01003 	mov	r1, r3
   2e890:	e3a02000 	mov	r2, #0
   2e894:	e51f311c 	ldr	r3, [pc, #-284]	; 2e780 <__ieee754_rem_pio2+0x950>
   2e898:	ebff9898 	bl	14b00 <__aeabi_dmul>
   2e89c:	e1a02000 	mov	r2, r0
   2e8a0:	e1a03001 	mov	r3, r1
   2e8a4:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   2e8a8:	e50b3020 	str	r3, [fp, #-32]
    /* set z = scalbn(|x|,ilogb(x)-23) */
	GET_LOW_WORD(low,x);
	SET_LOW_WORD(z,low);
	e0 	= (int)((ix>>20)-1046);	/* e0 = ilogb(z)-23; */
	SET_HIGH_WORD(z, ix - ((__int32_t)e0<<20));
	for(i=0;i<2;i++) {
   2e8ac:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2e8b0:	e2833001 	add	r3, r3, #1
   2e8b4:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2e8b8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2e8bc:	e3530001 	cmp	r3, #1
   2e8c0:	daffffd5 	ble	2e81c <__ieee754_rem_pio2+0x9ec>
		tx[i] = (double)((__int32_t)(z));
		z     = (z-tx[i])*two24;
	}
	tx[2] = z;
   2e8c4:	e24b3024 	sub	r3, fp, #36	; 0x24
   2e8c8:	e893000c 	ldm	r3, {r2, r3}
   2e8cc:	e50b2074 	str	r2, [fp, #-116]	; 0x74
   2e8d0:	e50b3070 	str	r3, [fp, #-112]	; 0x70
	nx = 3;
   2e8d4:	e3a03003 	mov	r3, #3
   2e8d8:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
	while(tx[nx-1]==zero) nx--;	/* skip zero term */
   2e8dc:	ea000002 	b	2e8ec <__ieee754_rem_pio2+0xabc>
   2e8e0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2e8e4:	e2433001 	sub	r3, r3, #1
   2e8e8:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2e8ec:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2e8f0:	e2432001 	sub	r2, r3, #1
   2e8f4:	e3e03067 	mvn	r3, #103	; 0x67
   2e8f8:	e1a02182 	lsl	r2, r2, #3
   2e8fc:	e24bc01c 	sub	ip, fp, #28
   2e900:	e08c2002 	add	r2, ip, r2
   2e904:	e0823003 	add	r3, r2, r3
   2e908:	e8930003 	ldm	r3, {r0, r1}
   2e90c:	e3a02000 	mov	r2, #0
   2e910:	e3a03000 	mov	r3, #0
   2e914:	ebff99d3 	bl	15068 <__aeabi_dcmpeq>
   2e918:	e1a03000 	mov	r3, r0
   2e91c:	e3530000 	cmp	r3, #0
   2e920:	1affffee 	bne	2e8e0 <__ieee754_rem_pio2+0xab0>
	n  =  __kernel_rem_pio2(tx,y,e0,nx,2,two_over_pi);
   2e924:	e24b3084 	sub	r3, fp, #132	; 0x84
   2e928:	e3a02002 	mov	r2, #2
   2e92c:	e58d2000 	str	r2, [sp]
   2e930:	e51f21b4 	ldr	r2, [pc, #-436]	; 2e784 <__ieee754_rem_pio2+0x954>
   2e934:	e58d2004 	str	r2, [sp, #4]
   2e938:	e1a00003 	mov	r0, r3
   2e93c:	e51b10c0 	ldr	r1, [fp, #-192]	; 0xc0
   2e940:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
   2e944:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2e948:	eb0002de 	bl	2f4c8 <__kernel_rem_pio2>
   2e94c:	e50b0050 	str	r0, [fp, #-80]	; 0x50
	if(hx<0) {y[0] = -y[0]; y[1] = -y[1]; return -n;}
   2e950:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   2e954:	e3530000 	cmp	r3, #0
   2e958:	aa000010 	bge	2e9a0 <__ieee754_rem_pio2+0xb70>
   2e95c:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e960:	e893000c 	ldm	r3, {r2, r3}
   2e964:	e1a06002 	mov	r6, r2
   2e968:	e2237102 	eor	r7, r3, #-2147483648	; 0x80000000
   2e96c:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e970:	e88300c0 	stm	r3, {r6, r7}
   2e974:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e978:	e2831008 	add	r1, r3, #8
   2e97c:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   2e980:	e2833008 	add	r3, r3, #8
   2e984:	e893000c 	ldm	r3, {r2, r3}
   2e988:	e1a04002 	mov	r4, r2
   2e98c:	e2235102 	eor	r5, r3, #-2147483648	; 0x80000000
   2e990:	e8810030 	stm	r1, {r4, r5}
   2e994:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   2e998:	e2633000 	rsb	r3, r3, #0
   2e99c:	ea000000 	b	2e9a4 <__ieee754_rem_pio2+0xb74>
	return n;
   2e9a0:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
}
   2e9a4:	e1a00003 	mov	r0, r3
   2e9a8:	e24bd01c 	sub	sp, fp, #28
   2e9ac:	e8bd4bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, lr}
   2e9b0:	e12fff1e 	bx	lr
   2e9b4:	e1a00000 	nop			; (mov r0, r0)

0002e9b8 <__ieee754_sqrt>:
	double __ieee754_sqrt(double x)
#else
	double __ieee754_sqrt(x)
	double x;
#endif
{
   2e9b8:	e92d4870 	push	{r4, r5, r6, fp, lr}
   2e9bc:	e28db010 	add	fp, sp, #16
   2e9c0:	e24dd054 	sub	sp, sp, #84	; 0x54
   2e9c4:	e50b0064 	str	r0, [fp, #-100]	; 0x64
   2e9c8:	e50b1060 	str	r1, [fp, #-96]	; 0x60
	double z;
	__int32_t sign = (int)0x80000000; 
   2e9cc:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
   2e9d0:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
	__uint32_t r,t1,s1,ix1,q1;
	__int32_t ix0,s0,q,m,t,i;

	EXTRACT_WORDS(ix0,ix1,x);
   2e9d4:	e24b4064 	sub	r4, fp, #100	; 0x64
   2e9d8:	e8940018 	ldm	r4, {r3, r4}
   2e9dc:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   2e9e0:	e50b4050 	str	r4, [fp, #-80]	; 0x50
   2e9e4:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   2e9e8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
   2e9ec:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   2e9f0:	e50b3020 	str	r3, [fp, #-32]

    /* take care of Inf and NaN */
	if((ix0&0x7ff00000)==0x7ff00000) {			
   2e9f4:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   2e9f8:	e59f3620 	ldr	r3, [pc, #1568]	; 2f020 <__ieee754_sqrt+0x668>
   2e9fc:	e0033002 	and	r3, r3, r2
   2ea00:	e59f2618 	ldr	r2, [pc, #1560]	; 2f020 <__ieee754_sqrt+0x668>
   2ea04:	e1530002 	cmp	r3, r2
   2ea08:	1a00000e 	bne	2ea48 <__ieee754_sqrt+0x90>
	    return x*x+x;		/* sqrt(NaN)=NaN, sqrt(+inf)=+inf
   2ea0c:	e24b1064 	sub	r1, fp, #100	; 0x64
   2ea10:	e8910003 	ldm	r1, {r0, r1}
   2ea14:	e24b3064 	sub	r3, fp, #100	; 0x64
   2ea18:	e893000c 	ldm	r3, {r2, r3}
   2ea1c:	ebff9837 	bl	14b00 <__aeabi_dmul>
   2ea20:	e1a03000 	mov	r3, r0
   2ea24:	e1a04001 	mov	r4, r1
   2ea28:	e1a00003 	mov	r0, r3
   2ea2c:	e1a01004 	mov	r1, r4
   2ea30:	e24b3064 	sub	r3, fp, #100	; 0x64
   2ea34:	e893000c 	ldm	r3, {r2, r3}
   2ea38:	ebff972c 	bl	146f0 <__adddf3>
   2ea3c:	e1a03000 	mov	r3, r0
   2ea40:	e1a04001 	mov	r4, r1
   2ea44:	ea00016e 	b	2f004 <__ieee754_sqrt+0x64c>
					   sqrt(-inf)=sNaN */
	} 
    /* take care of zero */
	if(ix0<=0) {
   2ea48:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ea4c:	e3530000 	cmp	r3, #0
   2ea50:	ca000026 	bgt	2eaf0 <__ieee754_sqrt+0x138>
	    if(((ix0&(~sign))|ix1)==0) return x;/* sqrt(+-0) = +-0 */
   2ea54:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2ea58:	e1e02003 	mvn	r2, r3
   2ea5c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ea60:	e0033002 	and	r3, r3, r2
   2ea64:	e1a02003 	mov	r2, r3
   2ea68:	e51b3020 	ldr	r3, [fp, #-32]
   2ea6c:	e1823003 	orr	r3, r2, r3
   2ea70:	e3530000 	cmp	r3, #0
   2ea74:	1a000002 	bne	2ea84 <__ieee754_sqrt+0xcc>
   2ea78:	e24b4064 	sub	r4, fp, #100	; 0x64
   2ea7c:	e8940018 	ldm	r4, {r3, r4}
   2ea80:	ea00015f 	b	2f004 <__ieee754_sqrt+0x64c>
	    else if(ix0<0)
   2ea84:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ea88:	e3530000 	cmp	r3, #0
   2ea8c:	aa000017 	bge	2eaf0 <__ieee754_sqrt+0x138>
		return (x-x)/(x-x);		/* sqrt(-ve) = sNaN */
   2ea90:	e24b1064 	sub	r1, fp, #100	; 0x64
   2ea94:	e8910003 	ldm	r1, {r0, r1}
   2ea98:	e24b3064 	sub	r3, fp, #100	; 0x64
   2ea9c:	e893000c 	ldm	r3, {r2, r3}
   2eaa0:	ebff9711 	bl	146ec <__aeabi_dsub>
   2eaa4:	e1a03000 	mov	r3, r0
   2eaa8:	e1a04001 	mov	r4, r1
   2eaac:	e1a05003 	mov	r5, r3
   2eab0:	e1a06004 	mov	r6, r4
   2eab4:	e24b1064 	sub	r1, fp, #100	; 0x64
   2eab8:	e8910003 	ldm	r1, {r0, r1}
   2eabc:	e24b3064 	sub	r3, fp, #100	; 0x64
   2eac0:	e893000c 	ldm	r3, {r2, r3}
   2eac4:	ebff9708 	bl	146ec <__aeabi_dsub>
   2eac8:	e1a03000 	mov	r3, r0
   2eacc:	e1a04001 	mov	r4, r1
   2ead0:	e1a00005 	mov	r0, r5
   2ead4:	e1a01006 	mov	r1, r6
   2ead8:	e1a02003 	mov	r2, r3
   2eadc:	e1a03004 	mov	r3, r4
   2eae0:	ebff98aa 	bl	14d90 <__aeabi_ddiv>
   2eae4:	e1a03000 	mov	r3, r0
   2eae8:	e1a04001 	mov	r4, r1
   2eaec:	ea000144 	b	2f004 <__ieee754_sqrt+0x64c>
	}
    /* normalize x */
	m = (ix0>>20);
   2eaf0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2eaf4:	e1a03a43 	asr	r3, r3, #20
   2eaf8:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	if(m==0) {				/* subnormal x */
   2eafc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2eb00:	e3530000 	cmp	r3, #0
   2eb04:	1a00002b 	bne	2ebb8 <__ieee754_sqrt+0x200>
	    while(ix0==0) {
   2eb08:	ea00000a 	b	2eb38 <__ieee754_sqrt+0x180>
		m -= 21;
   2eb0c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2eb10:	e2433015 	sub	r3, r3, #21
   2eb14:	e50b3034 	str	r3, [fp, #-52]	; 0x34
		ix0 |= (ix1>>11); ix1 <<= 21;
   2eb18:	e51b3020 	ldr	r3, [fp, #-32]
   2eb1c:	e1a025a3 	lsr	r2, r3, #11
   2eb20:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2eb24:	e1823003 	orr	r3, r2, r3
   2eb28:	e50b3028 	str	r3, [fp, #-40]	; 0x28
   2eb2c:	e51b3020 	ldr	r3, [fp, #-32]
   2eb30:	e1a03a83 	lsl	r3, r3, #21
   2eb34:	e50b3020 	str	r3, [fp, #-32]
		return (x-x)/(x-x);		/* sqrt(-ve) = sNaN */
	}
    /* normalize x */
	m = (ix0>>20);
	if(m==0) {				/* subnormal x */
	    while(ix0==0) {
   2eb38:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2eb3c:	e3530000 	cmp	r3, #0
   2eb40:	0afffff1 	beq	2eb0c <__ieee754_sqrt+0x154>
		m -= 21;
		ix0 |= (ix1>>11); ix1 <<= 21;
	    }
	    for(i=0;(ix0&0x00100000)==0;i++) ix0<<=1;
   2eb44:	e3a03000 	mov	r3, #0
   2eb48:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2eb4c:	ea000005 	b	2eb68 <__ieee754_sqrt+0x1b0>
   2eb50:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2eb54:	e1a03083 	lsl	r3, r3, #1
   2eb58:	e50b3028 	str	r3, [fp, #-40]	; 0x28
   2eb5c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2eb60:	e2833001 	add	r3, r3, #1
   2eb64:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2eb68:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2eb6c:	e2033601 	and	r3, r3, #1048576	; 0x100000
   2eb70:	e3530000 	cmp	r3, #0
   2eb74:	0afffff5 	beq	2eb50 <__ieee754_sqrt+0x198>
	    m -= i-1;
   2eb78:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2eb7c:	e2633001 	rsb	r3, r3, #1
   2eb80:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   2eb84:	e0823003 	add	r3, r2, r3
   2eb88:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	    ix0 |= (ix1>>(32-i));
   2eb8c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2eb90:	e2633020 	rsb	r3, r3, #32
   2eb94:	e51b2020 	ldr	r2, [fp, #-32]
   2eb98:	e1a02332 	lsr	r2, r2, r3
   2eb9c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2eba0:	e1823003 	orr	r3, r2, r3
   2eba4:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	    ix1 <<= i;
   2eba8:	e51b2020 	ldr	r2, [fp, #-32]
   2ebac:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2ebb0:	e1a03312 	lsl	r3, r2, r3
   2ebb4:	e50b3020 	str	r3, [fp, #-32]
	}
	m -= 1023;	/* unbias exponent */
   2ebb8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2ebbc:	e2433fff 	sub	r3, r3, #1020	; 0x3fc
   2ebc0:	e2433003 	sub	r3, r3, #3
   2ebc4:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	ix0 = (ix0&0x000fffff)|0x00100000;
   2ebc8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ebcc:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
   2ebd0:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   2ebd4:	e3833601 	orr	r3, r3, #1048576	; 0x100000
   2ebd8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	if(m&1){	/* odd m, double x to make it even */
   2ebdc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2ebe0:	e2033001 	and	r3, r3, #1
   2ebe4:	e3530000 	cmp	r3, #0
   2ebe8:	0a00000c 	beq	2ec20 <__ieee754_sqrt+0x268>
	    ix0 += ix0 + ((ix1&sign)>>31);
   2ebec:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   2ebf0:	e51b3020 	ldr	r3, [fp, #-32]
   2ebf4:	e0033002 	and	r3, r3, r2
   2ebf8:	e1a02fa3 	lsr	r2, r3, #31
   2ebfc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ec00:	e0822003 	add	r2, r2, r3
   2ec04:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ec08:	e0823003 	add	r3, r2, r3
   2ec0c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	    ix1 += ix1;
   2ec10:	e51b2020 	ldr	r2, [fp, #-32]
   2ec14:	e51b3020 	ldr	r3, [fp, #-32]
   2ec18:	e0823003 	add	r3, r2, r3
   2ec1c:	e50b3020 	str	r3, [fp, #-32]
	}
	m >>= 1;	/* m = [m/2] */
   2ec20:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2ec24:	e1a030c3 	asr	r3, r3, #1
   2ec28:	e50b3034 	str	r3, [fp, #-52]	; 0x34

    /* generate sqrt(x) bit by bit */
	ix0 += ix0 + ((ix1&sign)>>31);
   2ec2c:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   2ec30:	e51b3020 	ldr	r3, [fp, #-32]
   2ec34:	e0033002 	and	r3, r3, r2
   2ec38:	e1a02fa3 	lsr	r2, r3, #31
   2ec3c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ec40:	e0822003 	add	r2, r2, r3
   2ec44:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ec48:	e0823003 	add	r3, r2, r3
   2ec4c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	ix1 += ix1;
   2ec50:	e51b2020 	ldr	r2, [fp, #-32]
   2ec54:	e51b3020 	ldr	r3, [fp, #-32]
   2ec58:	e0823003 	add	r3, r2, r3
   2ec5c:	e50b3020 	str	r3, [fp, #-32]
	q = q1 = s0 = s1 = 0;	/* [q,q1] = sqrt(x) */
   2ec60:	e3a03000 	mov	r3, #0
   2ec64:	e50b301c 	str	r3, [fp, #-28]
   2ec68:	e3a03000 	mov	r3, #0
   2ec6c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2ec70:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   2ec74:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2ec78:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   2ec7c:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	r = 0x00200000;		/* r = moving bit from right to left */
   2ec80:	e3a03602 	mov	r3, #2097152	; 0x200000
   2ec84:	e50b3018 	str	r3, [fp, #-24]

	while(r!=0) {
   2ec88:	ea000023 	b	2ed1c <__ieee754_sqrt+0x364>
	    t = s0+r; 
   2ec8c:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
   2ec90:	e51b3018 	ldr	r3, [fp, #-24]
   2ec94:	e0823003 	add	r3, r2, r3
   2ec98:	e50b3040 	str	r3, [fp, #-64]	; 0x40
	    if(t<=ix0) { 
   2ec9c:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   2eca0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2eca4:	e1520003 	cmp	r2, r3
   2eca8:	ca00000b 	bgt	2ecdc <__ieee754_sqrt+0x324>
		s0   = t+r; 
   2ecac:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   2ecb0:	e51b3018 	ldr	r3, [fp, #-24]
   2ecb4:	e0823003 	add	r3, r2, r3
   2ecb8:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
		ix0 -= t; 
   2ecbc:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   2ecc0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   2ecc4:	e0633002 	rsb	r3, r3, r2
   2ecc8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		q   += r; 
   2eccc:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   2ecd0:	e51b3018 	ldr	r3, [fp, #-24]
   2ecd4:	e0823003 	add	r3, r2, r3
   2ecd8:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	    } 
	    ix0 += ix0 + ((ix1&sign)>>31);
   2ecdc:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   2ece0:	e51b3020 	ldr	r3, [fp, #-32]
   2ece4:	e0033002 	and	r3, r3, r2
   2ece8:	e1a02fa3 	lsr	r2, r3, #31
   2ecec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ecf0:	e0822003 	add	r2, r2, r3
   2ecf4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ecf8:	e0823003 	add	r3, r2, r3
   2ecfc:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	    ix1 += ix1;
   2ed00:	e51b2020 	ldr	r2, [fp, #-32]
   2ed04:	e51b3020 	ldr	r3, [fp, #-32]
   2ed08:	e0823003 	add	r3, r2, r3
   2ed0c:	e50b3020 	str	r3, [fp, #-32]
	    r>>=1;
   2ed10:	e51b3018 	ldr	r3, [fp, #-24]
   2ed14:	e1a030a3 	lsr	r3, r3, #1
   2ed18:	e50b3018 	str	r3, [fp, #-24]
	ix0 += ix0 + ((ix1&sign)>>31);
	ix1 += ix1;
	q = q1 = s0 = s1 = 0;	/* [q,q1] = sqrt(x) */
	r = 0x00200000;		/* r = moving bit from right to left */

	while(r!=0) {
   2ed1c:	e51b3018 	ldr	r3, [fp, #-24]
   2ed20:	e3530000 	cmp	r3, #0
   2ed24:	1affffd8 	bne	2ec8c <__ieee754_sqrt+0x2d4>
	    ix0 += ix0 + ((ix1&sign)>>31);
	    ix1 += ix1;
	    r>>=1;
	}

	r = sign;
   2ed28:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2ed2c:	e50b3018 	str	r3, [fp, #-24]
	while(r!=0) {
   2ed30:	ea000046 	b	2ee50 <__ieee754_sqrt+0x498>
	    t1 = s1+r; 
   2ed34:	e51b201c 	ldr	r2, [fp, #-28]
   2ed38:	e51b3018 	ldr	r3, [fp, #-24]
   2ed3c:	e0823003 	add	r3, r2, r3
   2ed40:	e50b3044 	str	r3, [fp, #-68]	; 0x44
	    t  = s0;
   2ed44:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   2ed48:	e50b3040 	str	r3, [fp, #-64]	; 0x40
	    if((t<ix0)||((t==ix0)&&(t1<=ix1))) { 
   2ed4c:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   2ed50:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ed54:	e1520003 	cmp	r2, r3
   2ed58:	ba000007 	blt	2ed7c <__ieee754_sqrt+0x3c4>
   2ed5c:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   2ed60:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ed64:	e1520003 	cmp	r2, r3
   2ed68:	1a000028 	bne	2ee10 <__ieee754_sqrt+0x458>
   2ed6c:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   2ed70:	e51b3020 	ldr	r3, [fp, #-32]
   2ed74:	e1520003 	cmp	r2, r3
   2ed78:	8a000024 	bhi	2ee10 <__ieee754_sqrt+0x458>
		s1  = t1+r;
   2ed7c:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   2ed80:	e51b3018 	ldr	r3, [fp, #-24]
   2ed84:	e0823003 	add	r3, r2, r3
   2ed88:	e50b301c 	str	r3, [fp, #-28]
		if(((t1&sign)==sign)&&(s1&sign)==0) s0 += 1;
   2ed8c:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   2ed90:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2ed94:	e0022003 	and	r2, r2, r3
   2ed98:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2ed9c:	e1520003 	cmp	r2, r3
   2eda0:	1a000007 	bne	2edc4 <__ieee754_sqrt+0x40c>
   2eda4:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   2eda8:	e51b301c 	ldr	r3, [fp, #-28]
   2edac:	e0033002 	and	r3, r3, r2
   2edb0:	e3530000 	cmp	r3, #0
   2edb4:	1a000002 	bne	2edc4 <__ieee754_sqrt+0x40c>
   2edb8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   2edbc:	e2833001 	add	r3, r3, #1
   2edc0:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
		ix0 -= t;
   2edc4:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   2edc8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   2edcc:	e0633002 	rsb	r3, r3, r2
   2edd0:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		if (ix1 < t1) ix0 -= 1;
   2edd4:	e51b2020 	ldr	r2, [fp, #-32]
   2edd8:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2eddc:	e1520003 	cmp	r2, r3
   2ede0:	2a000002 	bcs	2edf0 <__ieee754_sqrt+0x438>
   2ede4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ede8:	e2433001 	sub	r3, r3, #1
   2edec:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		ix1 -= t1;
   2edf0:	e51b2020 	ldr	r2, [fp, #-32]
   2edf4:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2edf8:	e0633002 	rsb	r3, r3, r2
   2edfc:	e50b3020 	str	r3, [fp, #-32]
		q1  += r;
   2ee00:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   2ee04:	e51b3018 	ldr	r3, [fp, #-24]
   2ee08:	e0823003 	add	r3, r2, r3
   2ee0c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	    }
	    ix0 += ix0 + ((ix1&sign)>>31);
   2ee10:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   2ee14:	e51b3020 	ldr	r3, [fp, #-32]
   2ee18:	e0033002 	and	r3, r3, r2
   2ee1c:	e1a02fa3 	lsr	r2, r3, #31
   2ee20:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ee24:	e0822003 	add	r2, r2, r3
   2ee28:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ee2c:	e0823003 	add	r3, r2, r3
   2ee30:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	    ix1 += ix1;
   2ee34:	e51b2020 	ldr	r2, [fp, #-32]
   2ee38:	e51b3020 	ldr	r3, [fp, #-32]
   2ee3c:	e0823003 	add	r3, r2, r3
   2ee40:	e50b3020 	str	r3, [fp, #-32]
	    r>>=1;
   2ee44:	e51b3018 	ldr	r3, [fp, #-24]
   2ee48:	e1a030a3 	lsr	r3, r3, #1
   2ee4c:	e50b3018 	str	r3, [fp, #-24]
	    ix1 += ix1;
	    r>>=1;
	}

	r = sign;
	while(r!=0) {
   2ee50:	e51b3018 	ldr	r3, [fp, #-24]
   2ee54:	e3530000 	cmp	r3, #0
   2ee58:	1affffb5 	bne	2ed34 <__ieee754_sqrt+0x37c>
	    ix1 += ix1;
	    r>>=1;
	}

    /* use floating add to find out rounding direction */
	if((ix0|ix1)!=0) {
   2ee5c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   2ee60:	e51b3020 	ldr	r3, [fp, #-32]
   2ee64:	e1823003 	orr	r3, r2, r3
   2ee68:	e3530000 	cmp	r3, #0
   2ee6c:	0a000045 	beq	2ef88 <__ieee754_sqrt+0x5d0>
	    z = one-tiny; /* trigger inexact flag */
   2ee70:	e3a01000 	mov	r1, #0
   2ee74:	e59f21a8 	ldr	r2, [pc, #424]	; 2f024 <__ieee754_sqrt+0x66c>
   2ee78:	e28f4f66 	add	r4, pc, #408	; 0x198
   2ee7c:	e8940018 	ldm	r4, {r3, r4}
   2ee80:	e1a00001 	mov	r0, r1
   2ee84:	e1a01002 	mov	r1, r2
   2ee88:	e1a02003 	mov	r2, r3
   2ee8c:	e1a03004 	mov	r3, r4
   2ee90:	ebff9615 	bl	146ec <__aeabi_dsub>
   2ee94:	e1a03000 	mov	r3, r0
   2ee98:	e1a04001 	mov	r4, r1
   2ee9c:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   2eea0:	e50b4048 	str	r4, [fp, #-72]	; 0x48
	    if (z>=one) {
   2eea4:	e3a03000 	mov	r3, #0
   2eea8:	e59f4174 	ldr	r4, [pc, #372]	; 2f024 <__ieee754_sqrt+0x66c>
   2eeac:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2eeb0:	e8910003 	ldm	r1, {r0, r1}
   2eeb4:	e1a02003 	mov	r2, r3
   2eeb8:	e1a03004 	mov	r3, r4
   2eebc:	ebff987b 	bl	150b0 <__aeabi_dcmpge>
   2eec0:	e1a03000 	mov	r3, r0
   2eec4:	e3530000 	cmp	r3, #0
   2eec8:	0a00002e 	beq	2ef88 <__ieee754_sqrt+0x5d0>
	        z = one+tiny;
   2eecc:	e3a01000 	mov	r1, #0
   2eed0:	e59f214c 	ldr	r2, [pc, #332]	; 2f024 <__ieee754_sqrt+0x66c>
   2eed4:	e28f4f4f 	add	r4, pc, #316	; 0x13c
   2eed8:	e8940018 	ldm	r4, {r3, r4}
   2eedc:	e1a00001 	mov	r0, r1
   2eee0:	e1a01002 	mov	r1, r2
   2eee4:	e1a02003 	mov	r2, r3
   2eee8:	e1a03004 	mov	r3, r4
   2eeec:	ebff95ff 	bl	146f0 <__adddf3>
   2eef0:	e1a03000 	mov	r3, r0
   2eef4:	e1a04001 	mov	r4, r1
   2eef8:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   2eefc:	e50b4048 	str	r4, [fp, #-72]	; 0x48
	        if (q1==(__uint32_t)0xffffffff) { q1=0; q += 1;}
   2ef00:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   2ef04:	e3730001 	cmn	r3, #1
   2ef08:	1a000005 	bne	2ef24 <__ieee754_sqrt+0x56c>
   2ef0c:	e3a03000 	mov	r3, #0
   2ef10:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2ef14:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2ef18:	e2833001 	add	r3, r3, #1
   2ef1c:	e50b3030 	str	r3, [fp, #-48]	; 0x30
   2ef20:	ea000018 	b	2ef88 <__ieee754_sqrt+0x5d0>
		else if (z>one) {
   2ef24:	e3a03000 	mov	r3, #0
   2ef28:	e59f40f4 	ldr	r4, [pc, #244]	; 2f024 <__ieee754_sqrt+0x66c>
   2ef2c:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2ef30:	e8910003 	ldm	r1, {r0, r1}
   2ef34:	e1a02003 	mov	r2, r3
   2ef38:	e1a03004 	mov	r3, r4
   2ef3c:	ebff9861 	bl	150c8 <__aeabi_dcmpgt>
   2ef40:	e1a03000 	mov	r3, r0
   2ef44:	e3530000 	cmp	r3, #0
   2ef48:	0a000009 	beq	2ef74 <__ieee754_sqrt+0x5bc>
		    if (q1==(__uint32_t)0xfffffffe) q+=1;
   2ef4c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   2ef50:	e3730002 	cmn	r3, #2
   2ef54:	1a000002 	bne	2ef64 <__ieee754_sqrt+0x5ac>
   2ef58:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2ef5c:	e2833001 	add	r3, r3, #1
   2ef60:	e50b3030 	str	r3, [fp, #-48]	; 0x30
		    q1+=2; 
   2ef64:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   2ef68:	e2833002 	add	r3, r3, #2
   2ef6c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   2ef70:	ea000004 	b	2ef88 <__ieee754_sqrt+0x5d0>
		} else
	            q1 += (q1&1);
   2ef74:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   2ef78:	e2033001 	and	r3, r3, #1
   2ef7c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   2ef80:	e0823003 	add	r3, r2, r3
   2ef84:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	    }
	}
	ix0 = (q>>1)+0x3fe00000;
   2ef88:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2ef8c:	e1a030c3 	asr	r3, r3, #1
   2ef90:	e28335ff 	add	r3, r3, #1069547520	; 0x3fc00000
   2ef94:	e2833602 	add	r3, r3, #2097152	; 0x200000
   2ef98:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	ix1 =  q1>>1;
   2ef9c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   2efa0:	e1a030a3 	lsr	r3, r3, #1
   2efa4:	e50b3020 	str	r3, [fp, #-32]
	if ((q&1)==1) ix1 |= sign;
   2efa8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2efac:	e2033001 	and	r3, r3, #1
   2efb0:	e3530000 	cmp	r3, #0
   2efb4:	0a000003 	beq	2efc8 <__ieee754_sqrt+0x610>
   2efb8:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2efbc:	e51b2020 	ldr	r2, [fp, #-32]
   2efc0:	e1823003 	orr	r3, r2, r3
   2efc4:	e50b3020 	str	r3, [fp, #-32]
	ix0 += (m <<20);
   2efc8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2efcc:	e1a03a03 	lsl	r3, r3, #20
   2efd0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   2efd4:	e0823003 	add	r3, r2, r3
   2efd8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	INSERT_WORDS(z,ix0,ix1);
   2efdc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2efe0:	e50b3058 	str	r3, [fp, #-88]	; 0x58
   2efe4:	e51b3020 	ldr	r3, [fp, #-32]
   2efe8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   2efec:	e24b405c 	sub	r4, fp, #92	; 0x5c
   2eff0:	e8940018 	ldm	r4, {r3, r4}
   2eff4:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   2eff8:	e50b4048 	str	r4, [fp, #-72]	; 0x48
	return z;
   2effc:	e24b404c 	sub	r4, fp, #76	; 0x4c
   2f000:	e8940018 	ldm	r4, {r3, r4}
}
   2f004:	e1a00003 	mov	r0, r3
   2f008:	e1a01004 	mov	r1, r4
   2f00c:	e24bd010 	sub	sp, fp, #16
   2f010:	e8bd4870 	pop	{r4, r5, r6, fp, lr}
   2f014:	e12fff1e 	bx	lr
   2f018:	c2f8f359 	.word	0xc2f8f359
   2f01c:	01a56e1f 	.word	0x01a56e1f
   2f020:	7ff00000 	.word	0x7ff00000
   2f024:	3ff00000 	.word	0x3ff00000

0002f028 <__kernel_cos>:
	double __kernel_cos(double x, double y)
#else
	double __kernel_cos(x, y)
	double x,y;
#endif
{
   2f028:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2f02c:	e28db020 	add	fp, sp, #32
   2f030:	e24dd054 	sub	sp, sp, #84	; 0x54
   2f034:	e50b006c 	str	r0, [fp, #-108]	; 0x6c
   2f038:	e50b1068 	str	r1, [fp, #-104]	; 0x68
   2f03c:	e50b2074 	str	r2, [fp, #-116]	; 0x74
   2f040:	e50b3070 	str	r3, [fp, #-112]	; 0x70
	double a,hz,z,r,qx;
	__int32_t ix;
	GET_HIGH_WORD(ix,x);
   2f044:	e24b406c 	sub	r4, fp, #108	; 0x6c
   2f048:	e8940018 	ldm	r4, {r3, r4}
   2f04c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   2f050:	e50b4058 	str	r4, [fp, #-88]	; 0x58
   2f054:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   2f058:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	ix &= 0x7fffffff;			/* ix = |x|'s high word*/
   2f05c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2f060:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   2f064:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	if(ix<0x3e400000) {			/* if x < 2**27 */
   2f068:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2f06c:	e35305f9 	cmp	r3, #1044381696	; 0x3e400000
   2f070:	aa000008 	bge	2f098 <__kernel_cos+0x70>
	    if(((int)x)==0) return one;		/* generate inexact */
   2f074:	e24b106c 	sub	r1, fp, #108	; 0x6c
   2f078:	e8910003 	ldm	r1, {r0, r1}
   2f07c:	ebff9817 	bl	150e0 <__aeabi_d2iz>
   2f080:	e1a03000 	mov	r3, r0
   2f084:	e3530000 	cmp	r3, #0
   2f088:	1a000002 	bne	2f098 <__kernel_cos+0x70>
   2f08c:	e3a03000 	mov	r3, #0
   2f090:	e59f4418 	ldr	r4, [pc, #1048]	; 2f4b0 <__kernel_cos+0x488>
   2f094:	ea0000f4 	b	2f46c <__kernel_cos+0x444>
	}
	z  = x*x;
   2f098:	e24b106c 	sub	r1, fp, #108	; 0x6c
   2f09c:	e8910003 	ldm	r1, {r0, r1}
   2f0a0:	e24b306c 	sub	r3, fp, #108	; 0x6c
   2f0a4:	e893000c 	ldm	r3, {r2, r3}
   2f0a8:	ebff9694 	bl	14b00 <__aeabi_dmul>
   2f0ac:	e1a03000 	mov	r3, r0
   2f0b0:	e1a04001 	mov	r4, r1
   2f0b4:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2f0b8:	e50b4038 	str	r4, [fp, #-56]	; 0x38
	r  = z*(C1+z*(C2+z*(C3+z*(C4+z*(C5+z*C6)))));
   2f0bc:	e28f4fef 	add	r4, pc, #956	; 0x3bc
   2f0c0:	e8940018 	ldm	r4, {r3, r4}
   2f0c4:	e1a00003 	mov	r0, r3
   2f0c8:	e1a01004 	mov	r1, r4
   2f0cc:	e24b303c 	sub	r3, fp, #60	; 0x3c
   2f0d0:	e893000c 	ldm	r3, {r2, r3}
   2f0d4:	ebff9689 	bl	14b00 <__aeabi_dmul>
   2f0d8:	e1a03000 	mov	r3, r0
   2f0dc:	e1a04001 	mov	r4, r1
   2f0e0:	e1a01003 	mov	r1, r3
   2f0e4:	e1a02004 	mov	r2, r4
   2f0e8:	e28f4fe6 	add	r4, pc, #920	; 0x398
   2f0ec:	e8940018 	ldm	r4, {r3, r4}
   2f0f0:	e1a00001 	mov	r0, r1
   2f0f4:	e1a01002 	mov	r1, r2
   2f0f8:	e1a02003 	mov	r2, r3
   2f0fc:	e1a03004 	mov	r3, r4
   2f100:	ebff957a 	bl	146f0 <__adddf3>
   2f104:	e1a03000 	mov	r3, r0
   2f108:	e1a04001 	mov	r4, r1
   2f10c:	e1a00003 	mov	r0, r3
   2f110:	e1a01004 	mov	r1, r4
   2f114:	e24b303c 	sub	r3, fp, #60	; 0x3c
   2f118:	e893000c 	ldm	r3, {r2, r3}
   2f11c:	ebff9677 	bl	14b00 <__aeabi_dmul>
   2f120:	e1a03000 	mov	r3, r0
   2f124:	e1a04001 	mov	r4, r1
   2f128:	e1a01003 	mov	r1, r3
   2f12c:	e1a02004 	mov	r2, r4
   2f130:	e28f4fd6 	add	r4, pc, #856	; 0x358
   2f134:	e8940018 	ldm	r4, {r3, r4}
   2f138:	e1a00001 	mov	r0, r1
   2f13c:	e1a01002 	mov	r1, r2
   2f140:	e1a02003 	mov	r2, r3
   2f144:	e1a03004 	mov	r3, r4
   2f148:	ebff9568 	bl	146f0 <__adddf3>
   2f14c:	e1a03000 	mov	r3, r0
   2f150:	e1a04001 	mov	r4, r1
   2f154:	e1a00003 	mov	r0, r3
   2f158:	e1a01004 	mov	r1, r4
   2f15c:	e24b303c 	sub	r3, fp, #60	; 0x3c
   2f160:	e893000c 	ldm	r3, {r2, r3}
   2f164:	ebff9665 	bl	14b00 <__aeabi_dmul>
   2f168:	e1a03000 	mov	r3, r0
   2f16c:	e1a04001 	mov	r4, r1
   2f170:	e1a01003 	mov	r1, r3
   2f174:	e1a02004 	mov	r2, r4
   2f178:	e28f4fc6 	add	r4, pc, #792	; 0x318
   2f17c:	e8940018 	ldm	r4, {r3, r4}
   2f180:	e1a00001 	mov	r0, r1
   2f184:	e1a01002 	mov	r1, r2
   2f188:	e1a02003 	mov	r2, r3
   2f18c:	e1a03004 	mov	r3, r4
   2f190:	ebff9556 	bl	146f0 <__adddf3>
   2f194:	e1a03000 	mov	r3, r0
   2f198:	e1a04001 	mov	r4, r1
   2f19c:	e1a00003 	mov	r0, r3
   2f1a0:	e1a01004 	mov	r1, r4
   2f1a4:	e24b303c 	sub	r3, fp, #60	; 0x3c
   2f1a8:	e893000c 	ldm	r3, {r2, r3}
   2f1ac:	ebff9653 	bl	14b00 <__aeabi_dmul>
   2f1b0:	e1a03000 	mov	r3, r0
   2f1b4:	e1a04001 	mov	r4, r1
   2f1b8:	e1a01003 	mov	r1, r3
   2f1bc:	e1a02004 	mov	r2, r4
   2f1c0:	e28f4fb6 	add	r4, pc, #728	; 0x2d8
   2f1c4:	e8940018 	ldm	r4, {r3, r4}
   2f1c8:	e1a00001 	mov	r0, r1
   2f1cc:	e1a01002 	mov	r1, r2
   2f1d0:	e1a02003 	mov	r2, r3
   2f1d4:	e1a03004 	mov	r3, r4
   2f1d8:	ebff9544 	bl	146f0 <__adddf3>
   2f1dc:	e1a03000 	mov	r3, r0
   2f1e0:	e1a04001 	mov	r4, r1
   2f1e4:	e1a00003 	mov	r0, r3
   2f1e8:	e1a01004 	mov	r1, r4
   2f1ec:	e24b303c 	sub	r3, fp, #60	; 0x3c
   2f1f0:	e893000c 	ldm	r3, {r2, r3}
   2f1f4:	ebff9641 	bl	14b00 <__aeabi_dmul>
   2f1f8:	e1a03000 	mov	r3, r0
   2f1fc:	e1a04001 	mov	r4, r1
   2f200:	e1a01003 	mov	r1, r3
   2f204:	e1a02004 	mov	r2, r4
   2f208:	e28f4fa6 	add	r4, pc, #664	; 0x298
   2f20c:	e8940018 	ldm	r4, {r3, r4}
   2f210:	e1a00001 	mov	r0, r1
   2f214:	e1a01002 	mov	r1, r2
   2f218:	e1a02003 	mov	r2, r3
   2f21c:	e1a03004 	mov	r3, r4
   2f220:	ebff9532 	bl	146f0 <__adddf3>
   2f224:	e1a03000 	mov	r3, r0
   2f228:	e1a04001 	mov	r4, r1
   2f22c:	e1a00003 	mov	r0, r3
   2f230:	e1a01004 	mov	r1, r4
   2f234:	e24b303c 	sub	r3, fp, #60	; 0x3c
   2f238:	e893000c 	ldm	r3, {r2, r3}
   2f23c:	ebff962f 	bl	14b00 <__aeabi_dmul>
   2f240:	e1a03000 	mov	r3, r0
   2f244:	e1a04001 	mov	r4, r1
   2f248:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   2f24c:	e50b4040 	str	r4, [fp, #-64]	; 0x40
	if(ix < 0x3FD33333) 			/* if |x| < 0.3 */ 
   2f250:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   2f254:	e59f3258 	ldr	r3, [pc, #600]	; 2f4b4 <__kernel_cos+0x48c>
   2f258:	e1520003 	cmp	r2, r3
   2f25c:	ca000030 	bgt	2f324 <__kernel_cos+0x2fc>
	    return one - (0.5*z - (z*r - x*y));
   2f260:	e3a05000 	mov	r5, #0
   2f264:	e59f6244 	ldr	r6, [pc, #580]	; 2f4b0 <__kernel_cos+0x488>
   2f268:	e24b103c 	sub	r1, fp, #60	; 0x3c
   2f26c:	e8910003 	ldm	r1, {r0, r1}
   2f270:	e3a02000 	mov	r2, #0
   2f274:	e59f323c 	ldr	r3, [pc, #572]	; 2f4b8 <__kernel_cos+0x490>
   2f278:	ebff9620 	bl	14b00 <__aeabi_dmul>
   2f27c:	e1a03000 	mov	r3, r0
   2f280:	e1a04001 	mov	r4, r1
   2f284:	e1a07003 	mov	r7, r3
   2f288:	e1a08004 	mov	r8, r4
   2f28c:	e24b103c 	sub	r1, fp, #60	; 0x3c
   2f290:	e8910003 	ldm	r1, {r0, r1}
   2f294:	e24b3044 	sub	r3, fp, #68	; 0x44
   2f298:	e893000c 	ldm	r3, {r2, r3}
   2f29c:	ebff9617 	bl	14b00 <__aeabi_dmul>
   2f2a0:	e1a03000 	mov	r3, r0
   2f2a4:	e1a04001 	mov	r4, r1
   2f2a8:	e1a09003 	mov	r9, r3
   2f2ac:	e1a0a004 	mov	sl, r4
   2f2b0:	e24b106c 	sub	r1, fp, #108	; 0x6c
   2f2b4:	e8910003 	ldm	r1, {r0, r1}
   2f2b8:	e24b3074 	sub	r3, fp, #116	; 0x74
   2f2bc:	e893000c 	ldm	r3, {r2, r3}
   2f2c0:	ebff960e 	bl	14b00 <__aeabi_dmul>
   2f2c4:	e1a03000 	mov	r3, r0
   2f2c8:	e1a04001 	mov	r4, r1
   2f2cc:	e1a00009 	mov	r0, r9
   2f2d0:	e1a0100a 	mov	r1, sl
   2f2d4:	e1a02003 	mov	r2, r3
   2f2d8:	e1a03004 	mov	r3, r4
   2f2dc:	ebff9502 	bl	146ec <__aeabi_dsub>
   2f2e0:	e1a03000 	mov	r3, r0
   2f2e4:	e1a04001 	mov	r4, r1
   2f2e8:	e1a00007 	mov	r0, r7
   2f2ec:	e1a01008 	mov	r1, r8
   2f2f0:	e1a02003 	mov	r2, r3
   2f2f4:	e1a03004 	mov	r3, r4
   2f2f8:	ebff94fb 	bl	146ec <__aeabi_dsub>
   2f2fc:	e1a03000 	mov	r3, r0
   2f300:	e1a04001 	mov	r4, r1
   2f304:	e1a00005 	mov	r0, r5
   2f308:	e1a01006 	mov	r1, r6
   2f30c:	e1a02003 	mov	r2, r3
   2f310:	e1a03004 	mov	r3, r4
   2f314:	ebff94f4 	bl	146ec <__aeabi_dsub>
   2f318:	e1a03000 	mov	r3, r0
   2f31c:	e1a04001 	mov	r4, r1
   2f320:	ea000051 	b	2f46c <__kernel_cos+0x444>
	else {
	    if(ix > 0x3fe90000) {		/* x > 0.78125 */
   2f324:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   2f328:	e59f318c 	ldr	r3, [pc, #396]	; 2f4bc <__kernel_cos+0x494>
   2f32c:	e1520003 	cmp	r2, r3
   2f330:	da000004 	ble	2f348 <__kernel_cos+0x320>
		qx = 0.28125;
   2f334:	e3a03000 	mov	r3, #0
   2f338:	e59f4180 	ldr	r4, [pc, #384]	; 2f4c0 <__kernel_cos+0x498>
   2f33c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2f340:	e50b4028 	str	r4, [fp, #-40]	; 0x28
   2f344:	ea000008 	b	2f36c <__kernel_cos+0x344>
	    } else {
	        INSERT_WORDS(qx,ix-0x00200000,0);	/* x/4 */
   2f348:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2f34c:	e2433602 	sub	r3, r3, #2097152	; 0x200000
   2f350:	e50b3060 	str	r3, [fp, #-96]	; 0x60
   2f354:	e3a03000 	mov	r3, #0
   2f358:	e50b3064 	str	r3, [fp, #-100]	; 0x64
   2f35c:	e24b4064 	sub	r4, fp, #100	; 0x64
   2f360:	e8940018 	ldm	r4, {r3, r4}
   2f364:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2f368:	e50b4028 	str	r4, [fp, #-40]	; 0x28
	    }
	    hz = 0.5*z-qx;
   2f36c:	e24b103c 	sub	r1, fp, #60	; 0x3c
   2f370:	e8910003 	ldm	r1, {r0, r1}
   2f374:	e3a02000 	mov	r2, #0
   2f378:	e59f3138 	ldr	r3, [pc, #312]	; 2f4b8 <__kernel_cos+0x490>
   2f37c:	ebff95df 	bl	14b00 <__aeabi_dmul>
   2f380:	e1a03000 	mov	r3, r0
   2f384:	e1a04001 	mov	r4, r1
   2f388:	e1a00003 	mov	r0, r3
   2f38c:	e1a01004 	mov	r1, r4
   2f390:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2f394:	e893000c 	ldm	r3, {r2, r3}
   2f398:	ebff94d3 	bl	146ec <__aeabi_dsub>
   2f39c:	e1a03000 	mov	r3, r0
   2f3a0:	e1a04001 	mov	r4, r1
   2f3a4:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   2f3a8:	e50b4048 	str	r4, [fp, #-72]	; 0x48
	    a  = one-qx;
   2f3ac:	e3a03000 	mov	r3, #0
   2f3b0:	e59f40f8 	ldr	r4, [pc, #248]	; 2f4b0 <__kernel_cos+0x488>
   2f3b4:	e1a00003 	mov	r0, r3
   2f3b8:	e1a01004 	mov	r1, r4
   2f3bc:	e24b302c 	sub	r3, fp, #44	; 0x2c
   2f3c0:	e893000c 	ldm	r3, {r2, r3}
   2f3c4:	ebff94c8 	bl	146ec <__aeabi_dsub>
   2f3c8:	e1a03000 	mov	r3, r0
   2f3cc:	e1a04001 	mov	r4, r1
   2f3d0:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   2f3d4:	e50b4050 	str	r4, [fp, #-80]	; 0x50
	    return a - (hz - (z*r-x*y));
   2f3d8:	e24b103c 	sub	r1, fp, #60	; 0x3c
   2f3dc:	e8910003 	ldm	r1, {r0, r1}
   2f3e0:	e24b3044 	sub	r3, fp, #68	; 0x44
   2f3e4:	e893000c 	ldm	r3, {r2, r3}
   2f3e8:	ebff95c4 	bl	14b00 <__aeabi_dmul>
   2f3ec:	e1a03000 	mov	r3, r0
   2f3f0:	e1a04001 	mov	r4, r1
   2f3f4:	e1a05003 	mov	r5, r3
   2f3f8:	e1a06004 	mov	r6, r4
   2f3fc:	e24b106c 	sub	r1, fp, #108	; 0x6c
   2f400:	e8910003 	ldm	r1, {r0, r1}
   2f404:	e24b3074 	sub	r3, fp, #116	; 0x74
   2f408:	e893000c 	ldm	r3, {r2, r3}
   2f40c:	ebff95bb 	bl	14b00 <__aeabi_dmul>
   2f410:	e1a03000 	mov	r3, r0
   2f414:	e1a04001 	mov	r4, r1
   2f418:	e1a00005 	mov	r0, r5
   2f41c:	e1a01006 	mov	r1, r6
   2f420:	e1a02003 	mov	r2, r3
   2f424:	e1a03004 	mov	r3, r4
   2f428:	ebff94af 	bl	146ec <__aeabi_dsub>
   2f42c:	e1a03000 	mov	r3, r0
   2f430:	e1a04001 	mov	r4, r1
   2f434:	e24b104c 	sub	r1, fp, #76	; 0x4c
   2f438:	e8910003 	ldm	r1, {r0, r1}
   2f43c:	e1a02003 	mov	r2, r3
   2f440:	e1a03004 	mov	r3, r4
   2f444:	ebff94a8 	bl	146ec <__aeabi_dsub>
   2f448:	e1a03000 	mov	r3, r0
   2f44c:	e1a04001 	mov	r4, r1
   2f450:	e24b1054 	sub	r1, fp, #84	; 0x54
   2f454:	e8910003 	ldm	r1, {r0, r1}
   2f458:	e1a02003 	mov	r2, r3
   2f45c:	e1a03004 	mov	r3, r4
   2f460:	ebff94a1 	bl	146ec <__aeabi_dsub>
   2f464:	e1a03000 	mov	r3, r0
   2f468:	e1a04001 	mov	r4, r1
	}
}
   2f46c:	e1a00003 	mov	r0, r3
   2f470:	e1a01004 	mov	r1, r4
   2f474:	e24bd020 	sub	sp, fp, #32
   2f478:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2f47c:	e12fff1e 	bx	lr
   2f480:	be8838d4 	.word	0xbe8838d4
   2f484:	bda8fae9 	.word	0xbda8fae9
   2f488:	bdb4b1c4 	.word	0xbdb4b1c4
   2f48c:	3e21ee9e 	.word	0x3e21ee9e
   2f490:	809c52ad 	.word	0x809c52ad
   2f494:	be927e4f 	.word	0xbe927e4f
   2f498:	19cb1590 	.word	0x19cb1590
   2f49c:	3efa01a0 	.word	0x3efa01a0
   2f4a0:	16c15177 	.word	0x16c15177
   2f4a4:	bf56c16c 	.word	0xbf56c16c
   2f4a8:	5555554c 	.word	0x5555554c
   2f4ac:	3fa55555 	.word	0x3fa55555
   2f4b0:	3ff00000 	.word	0x3ff00000
   2f4b4:	3fd33332 	.word	0x3fd33332
   2f4b8:	3fe00000 	.word	0x3fe00000
   2f4bc:	3fe90000 	.word	0x3fe90000
   2f4c0:	3fd20000 	.word	0x3fd20000
   2f4c4:	e1a00000 	nop			; (mov r0, r0)

0002f4c8 <__kernel_rem_pio2>:
	int __kernel_rem_pio2(double *x, double *y, int e0, int nx, int prec, const __int32_t *ipio2) 
#else
	int __kernel_rem_pio2(x,y,e0,nx,prec,ipio2) 	
	double x[], y[]; int e0,nx,prec; __int32_t ipio2[];
#endif
{
   2f4c8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   2f4cc:	e28db020 	add	fp, sp, #32
   2f4d0:	e24ddfa9 	sub	sp, sp, #676	; 0x2a4
   2f4d4:	e50b02a0 	str	r0, [fp, #-672]	; 0x2a0
   2f4d8:	e50b12a4 	str	r1, [fp, #-676]	; 0x2a4
   2f4dc:	e50b22a8 	str	r2, [fp, #-680]	; 0x2a8
   2f4e0:	e50b32ac 	str	r3, [fp, #-684]	; 0x2ac
	__int32_t jz,jx,jv,jp,jk,carry,n,iq[20],i,j,k,m,q0,ih;
	double z,fw,f[20],fq[20],q[20];

    /* initialize jk*/
	jk = init_jk[prec];
   2f4e4:	e59f3f60 	ldr	r3, [pc, #3936]	; 3044c <__kernel_rem_pio2+0xf84>
   2f4e8:	e59b2004 	ldr	r2, [fp, #4]
   2f4ec:	e7933102 	ldr	r3, [r3, r2, lsl #2]
   2f4f0:	e50b3060 	str	r3, [fp, #-96]	; 0x60
	jp = jk;
   2f4f4:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   2f4f8:	e50b3064 	str	r3, [fp, #-100]	; 0x64

    /* determine jx,jv,q0, note that 3>q0 */
	jx =  nx-1;
   2f4fc:	e51b32ac 	ldr	r3, [fp, #-684]	; 0x2ac
   2f500:	e2433001 	sub	r3, r3, #1
   2f504:	e50b3068 	str	r3, [fp, #-104]	; 0x68
	jv = (e0-3)/24; if(jv<0) jv=0;
   2f508:	e51b32a8 	ldr	r3, [fp, #-680]	; 0x2a8
   2f50c:	e2431003 	sub	r1, r3, #3
   2f510:	e59f3f38 	ldr	r3, [pc, #3896]	; 30450 <__kernel_rem_pio2+0xf88>
   2f514:	e0c30391 	smull	r0, r3, r1, r3
   2f518:	e1a02143 	asr	r2, r3, #2
   2f51c:	e1a03fc1 	asr	r3, r1, #31
   2f520:	e0633002 	rsb	r3, r3, r2
   2f524:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   2f528:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   2f52c:	e3530000 	cmp	r3, #0
   2f530:	aa000001 	bge	2f53c <__kernel_rem_pio2+0x74>
   2f534:	e3a03000 	mov	r3, #0
   2f538:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	q0 =  e0-24*(jv+1);
   2f53c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   2f540:	e1e02003 	mvn	r2, r3
   2f544:	e1a03002 	mov	r3, r2
   2f548:	e1a03083 	lsl	r3, r3, #1
   2f54c:	e0833002 	add	r3, r3, r2
   2f550:	e1a03183 	lsl	r3, r3, #3
   2f554:	e1a02003 	mov	r2, r3
   2f558:	e51b32a8 	ldr	r3, [fp, #-680]	; 0x2a8
   2f55c:	e0823003 	add	r3, r2, r3
   2f560:	e50b3044 	str	r3, [fp, #-68]	; 0x44

    /* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
	j = jv-jx; m = jx+jk;
   2f564:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
   2f568:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   2f56c:	e0633002 	rsb	r3, r3, r2
   2f570:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2f574:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   2f578:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   2f57c:	e0823003 	add	r3, r2, r3
   2f580:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
	for(i=0;i<=m;i++,j++) f[i] = (j<0)? zero : (double) ipio2[j];
   2f584:	e3a03000 	mov	r3, #0
   2f588:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2f58c:	ea00001b 	b	2f600 <__kernel_rem_pio2+0x138>
   2f590:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2f594:	e3530000 	cmp	r3, #0
   2f598:	ba000009 	blt	2f5c4 <__kernel_rem_pio2+0xfc>
   2f59c:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2f5a0:	e1a03103 	lsl	r3, r3, #2
   2f5a4:	e59b2008 	ldr	r2, [fp, #8]
   2f5a8:	e0823003 	add	r3, r2, r3
   2f5ac:	e5933000 	ldr	r3, [r3]
   2f5b0:	e1a00003 	mov	r0, r3
   2f5b4:	ebff951a 	bl	14a24 <__aeabi_i2d>
   2f5b8:	e1a02001 	mov	r2, r1
   2f5bc:	e1a01000 	mov	r1, r0
   2f5c0:	ea000001 	b	2f5cc <__kernel_rem_pio2+0x104>
   2f5c4:	e3a01000 	mov	r1, #0
   2f5c8:	e3a02000 	mov	r2, #0
   2f5cc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2f5d0:	e59f0e7c 	ldr	r0, [pc, #3708]	; 30454 <__kernel_rem_pio2+0xf8c>
   2f5d4:	e1a03183 	lsl	r3, r3, #3
   2f5d8:	e24b4024 	sub	r4, fp, #36	; 0x24
   2f5dc:	e0843003 	add	r3, r4, r3
   2f5e0:	e0833000 	add	r3, r3, r0
   2f5e4:	e8830006 	stm	r3, {r1, r2}
   2f5e8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2f5ec:	e2833001 	add	r3, r3, #1
   2f5f0:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2f5f4:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2f5f8:	e2833001 	add	r3, r3, #1
   2f5fc:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2f600:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   2f604:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   2f608:	e1520003 	cmp	r2, r3
   2f60c:	daffffdf 	ble	2f590 <__kernel_rem_pio2+0xc8>

    /* compute q[0],q[1],...q[jk] */
	for (i=0;i<=jk;i++) {
   2f610:	e3a03000 	mov	r3, #0
   2f614:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2f618:	ea000037 	b	2f6fc <__kernel_rem_pio2+0x234>
	    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j]; q[i] = fw;
   2f61c:	e3a03000 	mov	r3, #0
   2f620:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2f624:	e3a03000 	mov	r3, #0
   2f628:	e3a04000 	mov	r4, #0
   2f62c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   2f630:	e50b4058 	str	r4, [fp, #-88]	; 0x58
   2f634:	ea000020 	b	2f6bc <__kernel_rem_pio2+0x1f4>
   2f638:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2f63c:	e1a03183 	lsl	r3, r3, #3
   2f640:	e51b22a0 	ldr	r2, [fp, #-672]	; 0x2a0
   2f644:	e0823003 	add	r3, r2, r3
   2f648:	e8930003 	ldm	r3, {r0, r1}
   2f64c:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   2f650:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2f654:	e0822003 	add	r2, r2, r3
   2f658:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2f65c:	e0633002 	rsb	r3, r3, r2
   2f660:	e59f2dec 	ldr	r2, [pc, #3564]	; 30454 <__kernel_rem_pio2+0xf8c>
   2f664:	e1a03183 	lsl	r3, r3, #3
   2f668:	e24bc024 	sub	ip, fp, #36	; 0x24
   2f66c:	e08c3003 	add	r3, ip, r3
   2f670:	e0833002 	add	r3, r3, r2
   2f674:	e8930018 	ldm	r3, {r3, r4}
   2f678:	e1a02003 	mov	r2, r3
   2f67c:	e1a03004 	mov	r3, r4
   2f680:	ebff951e 	bl	14b00 <__aeabi_dmul>
   2f684:	e1a03000 	mov	r3, r0
   2f688:	e1a04001 	mov	r4, r1
   2f68c:	e24b105c 	sub	r1, fp, #92	; 0x5c
   2f690:	e8910003 	ldm	r1, {r0, r1}
   2f694:	e1a02003 	mov	r2, r3
   2f698:	e1a03004 	mov	r3, r4
   2f69c:	ebff9413 	bl	146f0 <__adddf3>
   2f6a0:	e1a03000 	mov	r3, r0
   2f6a4:	e1a04001 	mov	r4, r1
   2f6a8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   2f6ac:	e50b4058 	str	r4, [fp, #-88]	; 0x58
   2f6b0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2f6b4:	e2833001 	add	r3, r3, #1
   2f6b8:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2f6bc:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   2f6c0:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   2f6c4:	e1520003 	cmp	r2, r3
   2f6c8:	daffffda 	ble	2f638 <__kernel_rem_pio2+0x170>
   2f6cc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2f6d0:	e59f2d80 	ldr	r2, [pc, #3456]	; 30458 <__kernel_rem_pio2+0xf90>
   2f6d4:	e1a03183 	lsl	r3, r3, #3
   2f6d8:	e24b0024 	sub	r0, fp, #36	; 0x24
   2f6dc:	e0803003 	add	r3, r0, r3
   2f6e0:	e0832002 	add	r2, r3, r2
   2f6e4:	e24b405c 	sub	r4, fp, #92	; 0x5c
   2f6e8:	e8940018 	ldm	r4, {r3, r4}
   2f6ec:	e8820018 	stm	r2, {r3, r4}
    /* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
	j = jv-jx; m = jx+jk;
	for(i=0;i<=m;i++,j++) f[i] = (j<0)? zero : (double) ipio2[j];

    /* compute q[0],q[1],...q[jk] */
	for (i=0;i<=jk;i++) {
   2f6f0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2f6f4:	e2833001 	add	r3, r3, #1
   2f6f8:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2f6fc:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   2f700:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   2f704:	e1520003 	cmp	r2, r3
   2f708:	daffffc3 	ble	2f61c <__kernel_rem_pio2+0x154>
	    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j]; q[i] = fw;
	}

	jz = jk;
   2f70c:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   2f710:	e50b3028 	str	r3, [fp, #-40]	; 0x28
recompute:
    /* distill q[] into iq[] reversingly */
	for(i=0,j=jz,z=q[jz];j>0;i++,j--) {
   2f714:	e3a03000 	mov	r3, #0
   2f718:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2f71c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2f720:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2f724:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2f728:	e59f2d28 	ldr	r2, [pc, #3368]	; 30458 <__kernel_rem_pio2+0xf90>
   2f72c:	e1a03183 	lsl	r3, r3, #3
   2f730:	e24b1024 	sub	r1, fp, #36	; 0x24
   2f734:	e0813003 	add	r3, r1, r3
   2f738:	e0833002 	add	r3, r3, r2
   2f73c:	e8930018 	ldm	r3, {r3, r4}
   2f740:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   2f744:	e50b4050 	str	r4, [fp, #-80]	; 0x50
   2f748:	ea000044 	b	2f860 <__kernel_rem_pio2+0x398>
	    fw    =  (double)((__int32_t)(twon24* z));
   2f74c:	e3a03000 	mov	r3, #0
   2f750:	e59f4d04 	ldr	r4, [pc, #3332]	; 3045c <__kernel_rem_pio2+0xf94>
   2f754:	e1a00003 	mov	r0, r3
   2f758:	e1a01004 	mov	r1, r4
   2f75c:	e24b3054 	sub	r3, fp, #84	; 0x54
   2f760:	e893000c 	ldm	r3, {r2, r3}
   2f764:	ebff94e5 	bl	14b00 <__aeabi_dmul>
   2f768:	e1a03000 	mov	r3, r0
   2f76c:	e1a04001 	mov	r4, r1
   2f770:	e1a00003 	mov	r0, r3
   2f774:	e1a01004 	mov	r1, r4
   2f778:	ebff9658 	bl	150e0 <__aeabi_d2iz>
   2f77c:	e1a03000 	mov	r3, r0
   2f780:	e1a00003 	mov	r0, r3
   2f784:	ebff94a6 	bl	14a24 <__aeabi_i2d>
   2f788:	e1a03000 	mov	r3, r0
   2f78c:	e1a04001 	mov	r4, r1
   2f790:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   2f794:	e50b4058 	str	r4, [fp, #-88]	; 0x58
	    iq[i] =  (__int32_t)(z-two24*fw);
   2f798:	e3a03000 	mov	r3, #0
   2f79c:	e59f4cbc 	ldr	r4, [pc, #3260]	; 30460 <__kernel_rem_pio2+0xf98>
   2f7a0:	e1a00003 	mov	r0, r3
   2f7a4:	e1a01004 	mov	r1, r4
   2f7a8:	e24b305c 	sub	r3, fp, #92	; 0x5c
   2f7ac:	e893000c 	ldm	r3, {r2, r3}
   2f7b0:	ebff94d2 	bl	14b00 <__aeabi_dmul>
   2f7b4:	e1a03000 	mov	r3, r0
   2f7b8:	e1a04001 	mov	r4, r1
   2f7bc:	e24b1054 	sub	r1, fp, #84	; 0x54
   2f7c0:	e8910003 	ldm	r1, {r0, r1}
   2f7c4:	e1a02003 	mov	r2, r3
   2f7c8:	e1a03004 	mov	r3, r4
   2f7cc:	ebff93c6 	bl	146ec <__aeabi_dsub>
   2f7d0:	e1a03000 	mov	r3, r0
   2f7d4:	e1a04001 	mov	r4, r1
   2f7d8:	e1a00003 	mov	r0, r3
   2f7dc:	e1a01004 	mov	r1, r4
   2f7e0:	ebff963e 	bl	150e0 <__aeabi_d2iz>
   2f7e4:	e1a01000 	mov	r1, r0
   2f7e8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2f7ec:	e3e02097 	mvn	r2, #151	; 0x97
   2f7f0:	e1a03103 	lsl	r3, r3, #2
   2f7f4:	e24b4024 	sub	r4, fp, #36	; 0x24
   2f7f8:	e0843003 	add	r3, r4, r3
   2f7fc:	e0833002 	add	r3, r3, r2
   2f800:	e5831000 	str	r1, [r3]
	    z     =  q[j-1]+fw;
   2f804:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2f808:	e2433001 	sub	r3, r3, #1
   2f80c:	e59f2c44 	ldr	r2, [pc, #3140]	; 30458 <__kernel_rem_pio2+0xf90>
   2f810:	e1a03183 	lsl	r3, r3, #3
   2f814:	e24bc024 	sub	ip, fp, #36	; 0x24
   2f818:	e08c3003 	add	r3, ip, r3
   2f81c:	e0833002 	add	r3, r3, r2
   2f820:	e8930018 	ldm	r3, {r3, r4}
   2f824:	e1a00003 	mov	r0, r3
   2f828:	e1a01004 	mov	r1, r4
   2f82c:	e24b305c 	sub	r3, fp, #92	; 0x5c
   2f830:	e893000c 	ldm	r3, {r2, r3}
   2f834:	ebff93ad 	bl	146f0 <__adddf3>
   2f838:	e1a03000 	mov	r3, r0
   2f83c:	e1a04001 	mov	r4, r1
   2f840:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   2f844:	e50b4050 	str	r4, [fp, #-80]	; 0x50
	}

	jz = jk;
recompute:
    /* distill q[] into iq[] reversingly */
	for(i=0,j=jz,z=q[jz];j>0;i++,j--) {
   2f848:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2f84c:	e2833001 	add	r3, r3, #1
   2f850:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2f854:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2f858:	e2433001 	sub	r3, r3, #1
   2f85c:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2f860:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2f864:	e3530000 	cmp	r3, #0
   2f868:	caffffb7 	bgt	2f74c <__kernel_rem_pio2+0x284>
	    iq[i] =  (__int32_t)(z-two24*fw);
	    z     =  q[j-1]+fw;
	}

    /* compute n */
	z  = scalbn(z,(int)q0);		/* actual value of z */
   2f86c:	e24b1054 	sub	r1, fp, #84	; 0x54
   2f870:	e8910003 	ldm	r1, {r0, r1}
   2f874:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   2f878:	eb000738 	bl	31560 <scalbn>
   2f87c:	e50b0054 	str	r0, [fp, #-84]	; 0x54
   2f880:	e50b1050 	str	r1, [fp, #-80]	; 0x50
	z -= 8.0*floor(z*0.125);		/* trim off integer >= 8 */
   2f884:	e24b1054 	sub	r1, fp, #84	; 0x54
   2f888:	e8910003 	ldm	r1, {r0, r1}
   2f88c:	e3a02000 	mov	r2, #0
   2f890:	e3a035ff 	mov	r3, #1069547520	; 0x3fc00000
   2f894:	ebff9499 	bl	14b00 <__aeabi_dmul>
   2f898:	e1a03000 	mov	r3, r0
   2f89c:	e1a04001 	mov	r4, r1
   2f8a0:	e1a00003 	mov	r0, r3
   2f8a4:	e1a01004 	mov	r1, r4
   2f8a8:	eb00052a 	bl	30d58 <floor>
   2f8ac:	e1a03000 	mov	r3, r0
   2f8b0:	e1a04001 	mov	r4, r1
   2f8b4:	e1a00003 	mov	r0, r3
   2f8b8:	e1a01004 	mov	r1, r4
   2f8bc:	e3a02000 	mov	r2, #0
   2f8c0:	e59f3b9c 	ldr	r3, [pc, #2972]	; 30464 <__kernel_rem_pio2+0xf9c>
   2f8c4:	ebff948d 	bl	14b00 <__aeabi_dmul>
   2f8c8:	e1a03000 	mov	r3, r0
   2f8cc:	e1a04001 	mov	r4, r1
   2f8d0:	e24b1054 	sub	r1, fp, #84	; 0x54
   2f8d4:	e8910003 	ldm	r1, {r0, r1}
   2f8d8:	e1a02003 	mov	r2, r3
   2f8dc:	e1a03004 	mov	r3, r4
   2f8e0:	ebff9381 	bl	146ec <__aeabi_dsub>
   2f8e4:	e1a03000 	mov	r3, r0
   2f8e8:	e1a04001 	mov	r4, r1
   2f8ec:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   2f8f0:	e50b4050 	str	r4, [fp, #-80]	; 0x50
	n  = (__int32_t) z;
   2f8f4:	e24b1054 	sub	r1, fp, #84	; 0x54
   2f8f8:	e8910003 	ldm	r1, {r0, r1}
   2f8fc:	ebff95f7 	bl	150e0 <__aeabi_d2iz>
   2f900:	e1a03000 	mov	r3, r0
   2f904:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	z -= (double)n;
   2f908:	e51b0034 	ldr	r0, [fp, #-52]	; 0x34
   2f90c:	ebff9444 	bl	14a24 <__aeabi_i2d>
   2f910:	e1a03000 	mov	r3, r0
   2f914:	e1a04001 	mov	r4, r1
   2f918:	e24b1054 	sub	r1, fp, #84	; 0x54
   2f91c:	e8910003 	ldm	r1, {r0, r1}
   2f920:	e1a02003 	mov	r2, r3
   2f924:	e1a03004 	mov	r3, r4
   2f928:	ebff936f 	bl	146ec <__aeabi_dsub>
   2f92c:	e1a03000 	mov	r3, r0
   2f930:	e1a04001 	mov	r4, r1
   2f934:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   2f938:	e50b4050 	str	r4, [fp, #-80]	; 0x50
	ih = 0;
   2f93c:	e3a03000 	mov	r3, #0
   2f940:	e50b3048 	str	r3, [fp, #-72]	; 0x48
	if(q0>0) {	/* need iq[jz-1] to determine n */
   2f944:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2f948:	e3530000 	cmp	r3, #0
   2f94c:	da000031 	ble	2fa18 <__kernel_rem_pio2+0x550>
	    i  = (iq[jz-1]>>(24-q0)); n += i;
   2f950:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2f954:	e2433001 	sub	r3, r3, #1
   2f958:	e3e02097 	mvn	r2, #151	; 0x97
   2f95c:	e1a03103 	lsl	r3, r3, #2
   2f960:	e24b0024 	sub	r0, fp, #36	; 0x24
   2f964:	e0803003 	add	r3, r0, r3
   2f968:	e0833002 	add	r3, r3, r2
   2f96c:	e5932000 	ldr	r2, [r3]
   2f970:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2f974:	e2633018 	rsb	r3, r3, #24
   2f978:	e1a03352 	asr	r3, r2, r3
   2f97c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2f980:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   2f984:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2f988:	e0823003 	add	r3, r2, r3
   2f98c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	    iq[jz-1] -= i<<(24-q0);
   2f990:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2f994:	e2430001 	sub	r0, r3, #1
   2f998:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2f99c:	e2433001 	sub	r3, r3, #1
   2f9a0:	e3e02097 	mvn	r2, #151	; 0x97
   2f9a4:	e1a03103 	lsl	r3, r3, #2
   2f9a8:	e24b1024 	sub	r1, fp, #36	; 0x24
   2f9ac:	e0813003 	add	r3, r1, r3
   2f9b0:	e0833002 	add	r3, r3, r2
   2f9b4:	e5931000 	ldr	r1, [r3]
   2f9b8:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2f9bc:	e2632018 	rsb	r2, r3, #24
   2f9c0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2f9c4:	e1a03213 	lsl	r3, r3, r2
   2f9c8:	e0631001 	rsb	r1, r3, r1
   2f9cc:	e3e02097 	mvn	r2, #151	; 0x97
   2f9d0:	e1a03100 	lsl	r3, r0, #2
   2f9d4:	e24b4024 	sub	r4, fp, #36	; 0x24
   2f9d8:	e0843003 	add	r3, r4, r3
   2f9dc:	e0833002 	add	r3, r3, r2
   2f9e0:	e5831000 	str	r1, [r3]
	    ih = iq[jz-1]>>(23-q0);
   2f9e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2f9e8:	e2433001 	sub	r3, r3, #1
   2f9ec:	e3e02097 	mvn	r2, #151	; 0x97
   2f9f0:	e1a03103 	lsl	r3, r3, #2
   2f9f4:	e24bc024 	sub	ip, fp, #36	; 0x24
   2f9f8:	e08c3003 	add	r3, ip, r3
   2f9fc:	e0833002 	add	r3, r3, r2
   2fa00:	e5932000 	ldr	r2, [r3]
   2fa04:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2fa08:	e2633017 	rsb	r3, r3, #23
   2fa0c:	e1a03352 	asr	r3, r2, r3
   2fa10:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   2fa14:	ea000017 	b	2fa78 <__kernel_rem_pio2+0x5b0>
	} 
	else if(q0==0) ih = iq[jz-1]>>23;
   2fa18:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2fa1c:	e3530000 	cmp	r3, #0
   2fa20:	1a00000a 	bne	2fa50 <__kernel_rem_pio2+0x588>
   2fa24:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2fa28:	e2433001 	sub	r3, r3, #1
   2fa2c:	e3e02097 	mvn	r2, #151	; 0x97
   2fa30:	e1a03103 	lsl	r3, r3, #2
   2fa34:	e24b0024 	sub	r0, fp, #36	; 0x24
   2fa38:	e0803003 	add	r3, r0, r3
   2fa3c:	e0833002 	add	r3, r3, r2
   2fa40:	e5933000 	ldr	r3, [r3]
   2fa44:	e1a03bc3 	asr	r3, r3, #23
   2fa48:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   2fa4c:	ea000009 	b	2fa78 <__kernel_rem_pio2+0x5b0>
	else if(z>=0.5) ih=2;
   2fa50:	e24b1054 	sub	r1, fp, #84	; 0x54
   2fa54:	e8910003 	ldm	r1, {r0, r1}
   2fa58:	e3a02000 	mov	r2, #0
   2fa5c:	e59f3a04 	ldr	r3, [pc, #2564]	; 30468 <__kernel_rem_pio2+0xfa0>
   2fa60:	ebff9592 	bl	150b0 <__aeabi_dcmpge>
   2fa64:	e1a03000 	mov	r3, r0
   2fa68:	e3530000 	cmp	r3, #0
   2fa6c:	0a000001 	beq	2fa78 <__kernel_rem_pio2+0x5b0>
   2fa70:	e3a03002 	mov	r3, #2
   2fa74:	e50b3048 	str	r3, [fp, #-72]	; 0x48

	if(ih>0) {	/* q > 0.5 */
   2fa78:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2fa7c:	e3530000 	cmp	r3, #0
   2fa80:	da000083 	ble	2fc94 <__kernel_rem_pio2+0x7cc>
	    n += 1; carry = 0;
   2fa84:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2fa88:	e2833001 	add	r3, r3, #1
   2fa8c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   2fa90:	e3a03000 	mov	r3, #0
   2fa94:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	    for(i=0;i<jz ;i++) {	/* compute 1-q */
   2fa98:	e3a03000 	mov	r3, #0
   2fa9c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2faa0:	ea000026 	b	2fb40 <__kernel_rem_pio2+0x678>
		j = iq[i];
   2faa4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2faa8:	e3e02097 	mvn	r2, #151	; 0x97
   2faac:	e1a03103 	lsl	r3, r3, #2
   2fab0:	e24b1024 	sub	r1, fp, #36	; 0x24
   2fab4:	e0813003 	add	r3, r1, r3
   2fab8:	e0833002 	add	r3, r3, r2
   2fabc:	e5933000 	ldr	r3, [r3]
   2fac0:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
		if(carry==0) {
   2fac4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2fac8:	e3530000 	cmp	r3, #0
   2facc:	1a00000e 	bne	2fb0c <__kernel_rem_pio2+0x644>
		    if(j!=0) {
   2fad0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2fad4:	e3530000 	cmp	r3, #0
   2fad8:	0a000015 	beq	2fb34 <__kernel_rem_pio2+0x66c>
			carry = 1; iq[i] = 0x1000000- j;
   2fadc:	e3a03001 	mov	r3, #1
   2fae0:	e50b3030 	str	r3, [fp, #-48]	; 0x30
   2fae4:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2fae8:	e2631401 	rsb	r1, r3, #16777216	; 0x1000000
   2faec:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2faf0:	e3e02097 	mvn	r2, #151	; 0x97
   2faf4:	e1a03103 	lsl	r3, r3, #2
   2faf8:	e24b4024 	sub	r4, fp, #36	; 0x24
   2fafc:	e0843003 	add	r3, r4, r3
   2fb00:	e0833002 	add	r3, r3, r2
   2fb04:	e5831000 	str	r1, [r3]
   2fb08:	ea000009 	b	2fb34 <__kernel_rem_pio2+0x66c>
		    }
		} else  iq[i] = 0xffffff - j;
   2fb0c:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2fb10:	e3e024ff 	mvn	r2, #-16777216	; 0xff000000
   2fb14:	e0632002 	rsb	r2, r3, r2
   2fb18:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2fb1c:	e3e01097 	mvn	r1, #151	; 0x97
   2fb20:	e1a03103 	lsl	r3, r3, #2
   2fb24:	e24bc024 	sub	ip, fp, #36	; 0x24
   2fb28:	e08c3003 	add	r3, ip, r3
   2fb2c:	e0833001 	add	r3, r3, r1
   2fb30:	e5832000 	str	r2, [r3]
	else if(q0==0) ih = iq[jz-1]>>23;
	else if(z>=0.5) ih=2;

	if(ih>0) {	/* q > 0.5 */
	    n += 1; carry = 0;
	    for(i=0;i<jz ;i++) {	/* compute 1-q */
   2fb34:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2fb38:	e2833001 	add	r3, r3, #1
   2fb3c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2fb40:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   2fb44:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2fb48:	e1520003 	cmp	r2, r3
   2fb4c:	baffffd4 	blt	2faa4 <__kernel_rem_pio2+0x5dc>
		    if(j!=0) {
			carry = 1; iq[i] = 0x1000000- j;
		    }
		} else  iq[i] = 0xffffff - j;
	    }
	    if(q0>0) {		/* rare case: chance is 1 in 12 */
   2fb50:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2fb54:	e3530000 	cmp	r3, #0
   2fb58:	da00002b 	ble	2fc0c <__kernel_rem_pio2+0x744>
	        switch(q0) {
   2fb5c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2fb60:	e3530001 	cmp	r3, #1
   2fb64:	0a000002 	beq	2fb74 <__kernel_rem_pio2+0x6ac>
   2fb68:	e3530002 	cmp	r3, #2
   2fb6c:	0a000013 	beq	2fbc0 <__kernel_rem_pio2+0x6f8>
   2fb70:	ea000025 	b	2fc0c <__kernel_rem_pio2+0x744>
	        case 1:
	    	   iq[jz-1] &= 0x7fffff; break;
   2fb74:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2fb78:	e2430001 	sub	r0, r3, #1
   2fb7c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2fb80:	e2433001 	sub	r3, r3, #1
   2fb84:	e3e02097 	mvn	r2, #151	; 0x97
   2fb88:	e1a03103 	lsl	r3, r3, #2
   2fb8c:	e24b1024 	sub	r1, fp, #36	; 0x24
   2fb90:	e0813003 	add	r3, r1, r3
   2fb94:	e0833002 	add	r3, r3, r2
   2fb98:	e5933000 	ldr	r3, [r3]
   2fb9c:	e3c324ff 	bic	r2, r3, #-16777216	; 0xff000000
   2fba0:	e3c22502 	bic	r2, r2, #8388608	; 0x800000
   2fba4:	e3e01097 	mvn	r1, #151	; 0x97
   2fba8:	e1a03100 	lsl	r3, r0, #2
   2fbac:	e24b4024 	sub	r4, fp, #36	; 0x24
   2fbb0:	e0843003 	add	r3, r4, r3
   2fbb4:	e0833001 	add	r3, r3, r1
   2fbb8:	e5832000 	str	r2, [r3]
   2fbbc:	ea000012 	b	2fc0c <__kernel_rem_pio2+0x744>
	    	case 2:
	    	   iq[jz-1] &= 0x3fffff; break;
   2fbc0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2fbc4:	e2430001 	sub	r0, r3, #1
   2fbc8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2fbcc:	e2433001 	sub	r3, r3, #1
   2fbd0:	e3e02097 	mvn	r2, #151	; 0x97
   2fbd4:	e1a03103 	lsl	r3, r3, #2
   2fbd8:	e24bc024 	sub	ip, fp, #36	; 0x24
   2fbdc:	e08c3003 	add	r3, ip, r3
   2fbe0:	e0833002 	add	r3, r3, r2
   2fbe4:	e5933000 	ldr	r3, [r3]
   2fbe8:	e3c324ff 	bic	r2, r3, #-16777216	; 0xff000000
   2fbec:	e3c22503 	bic	r2, r2, #12582912	; 0xc00000
   2fbf0:	e3e01097 	mvn	r1, #151	; 0x97
   2fbf4:	e1a03100 	lsl	r3, r0, #2
   2fbf8:	e24b0024 	sub	r0, fp, #36	; 0x24
   2fbfc:	e0803003 	add	r3, r0, r3
   2fc00:	e0833001 	add	r3, r3, r1
   2fc04:	e5832000 	str	r2, [r3]
   2fc08:	e1a00000 	nop			; (mov r0, r0)
	        }
	    }
	    if(ih==2) {
   2fc0c:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   2fc10:	e3530002 	cmp	r3, #2
   2fc14:	1a00001e 	bne	2fc94 <__kernel_rem_pio2+0x7cc>
		z = one - z;
   2fc18:	e3a03000 	mov	r3, #0
   2fc1c:	e59f4848 	ldr	r4, [pc, #2120]	; 3046c <__kernel_rem_pio2+0xfa4>
   2fc20:	e1a00003 	mov	r0, r3
   2fc24:	e1a01004 	mov	r1, r4
   2fc28:	e24b3054 	sub	r3, fp, #84	; 0x54
   2fc2c:	e893000c 	ldm	r3, {r2, r3}
   2fc30:	ebff92ad 	bl	146ec <__aeabi_dsub>
   2fc34:	e1a03000 	mov	r3, r0
   2fc38:	e1a04001 	mov	r4, r1
   2fc3c:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   2fc40:	e50b4050 	str	r4, [fp, #-80]	; 0x50
		if(carry!=0) z -= scalbn(one,(int)q0);
   2fc44:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   2fc48:	e3530000 	cmp	r3, #0
   2fc4c:	0a000010 	beq	2fc94 <__kernel_rem_pio2+0x7cc>
   2fc50:	e3a03000 	mov	r3, #0
   2fc54:	e59f4810 	ldr	r4, [pc, #2064]	; 3046c <__kernel_rem_pio2+0xfa4>
   2fc58:	e1a00003 	mov	r0, r3
   2fc5c:	e1a01004 	mov	r1, r4
   2fc60:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   2fc64:	eb00063d 	bl	31560 <scalbn>
   2fc68:	e1a03000 	mov	r3, r0
   2fc6c:	e1a04001 	mov	r4, r1
   2fc70:	e24b1054 	sub	r1, fp, #84	; 0x54
   2fc74:	e8910003 	ldm	r1, {r0, r1}
   2fc78:	e1a02003 	mov	r2, r3
   2fc7c:	e1a03004 	mov	r3, r4
   2fc80:	ebff9299 	bl	146ec <__aeabi_dsub>
   2fc84:	e1a03000 	mov	r3, r0
   2fc88:	e1a04001 	mov	r4, r1
   2fc8c:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   2fc90:	e50b4050 	str	r4, [fp, #-80]	; 0x50
	    }
	}

    /* check if recomputation is needed */
	if(z==zero) {
   2fc94:	e3a03000 	mov	r3, #0
   2fc98:	e3a04000 	mov	r4, #0
   2fc9c:	e24b1054 	sub	r1, fp, #84	; 0x54
   2fca0:	e8910003 	ldm	r1, {r0, r1}
   2fca4:	e1a02003 	mov	r2, r3
   2fca8:	e1a03004 	mov	r3, r4
   2fcac:	ebff94ed 	bl	15068 <__aeabi_dcmpeq>
   2fcb0:	e1a03000 	mov	r3, r0
   2fcb4:	e3530000 	cmp	r3, #0
   2fcb8:	0a000085 	beq	2fed4 <__kernel_rem_pio2+0xa0c>
	    j = 0;
   2fcbc:	e3a03000 	mov	r3, #0
   2fcc0:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
	    for (i=jz-1;i>=jk;i--) j |= iq[i];
   2fcc4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2fcc8:	e2433001 	sub	r3, r3, #1
   2fccc:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2fcd0:	ea00000c 	b	2fd08 <__kernel_rem_pio2+0x840>
   2fcd4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2fcd8:	e3e02097 	mvn	r2, #151	; 0x97
   2fcdc:	e1a03103 	lsl	r3, r3, #2
   2fce0:	e24b1024 	sub	r1, fp, #36	; 0x24
   2fce4:	e0813003 	add	r3, r1, r3
   2fce8:	e0833002 	add	r3, r3, r2
   2fcec:	e5933000 	ldr	r3, [r3]
   2fcf0:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   2fcf4:	e1823003 	orr	r3, r2, r3
   2fcf8:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2fcfc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2fd00:	e2433001 	sub	r3, r3, #1
   2fd04:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2fd08:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   2fd0c:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   2fd10:	e1520003 	cmp	r2, r3
   2fd14:	aaffffee 	bge	2fcd4 <__kernel_rem_pio2+0x80c>
	    if(j==0) { /* need recomputation */
   2fd18:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2fd1c:	e3530000 	cmp	r3, #0
   2fd20:	1a00006b 	bne	2fed4 <__kernel_rem_pio2+0xa0c>
		for(k=1;iq[jk-k]==0;k++);   /* k = no. of terms needed */
   2fd24:	e3a03001 	mov	r3, #1
   2fd28:	e50b3040 	str	r3, [fp, #-64]	; 0x40
   2fd2c:	ea000002 	b	2fd3c <__kernel_rem_pio2+0x874>
   2fd30:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   2fd34:	e2833001 	add	r3, r3, #1
   2fd38:	e50b3040 	str	r3, [fp, #-64]	; 0x40
   2fd3c:	e51b2060 	ldr	r2, [fp, #-96]	; 0x60
   2fd40:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   2fd44:	e0633002 	rsb	r3, r3, r2
   2fd48:	e3e02097 	mvn	r2, #151	; 0x97
   2fd4c:	e1a03103 	lsl	r3, r3, #2
   2fd50:	e24b4024 	sub	r4, fp, #36	; 0x24
   2fd54:	e0843003 	add	r3, r4, r3
   2fd58:	e0833002 	add	r3, r3, r2
   2fd5c:	e5933000 	ldr	r3, [r3]
   2fd60:	e3530000 	cmp	r3, #0
   2fd64:	0afffff1 	beq	2fd30 <__kernel_rem_pio2+0x868>

		for(i=jz+1;i<=jz+k;i++) {   /* add q[jz+1] to q[jz+k] */
   2fd68:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2fd6c:	e2833001 	add	r3, r3, #1
   2fd70:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2fd74:	ea00004b 	b	2fea8 <__kernel_rem_pio2+0x9e0>
		    f[jx+i] = (double) ipio2[jv+i];
   2fd78:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   2fd7c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2fd80:	e0824003 	add	r4, r2, r3
   2fd84:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
   2fd88:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2fd8c:	e0823003 	add	r3, r2, r3
   2fd90:	e1a02103 	lsl	r2, r3, #2
   2fd94:	e59b3008 	ldr	r3, [fp, #8]
   2fd98:	e0833002 	add	r3, r3, r2
   2fd9c:	e5933000 	ldr	r3, [r3]
   2fda0:	e1a00003 	mov	r0, r3
   2fda4:	ebff931e 	bl	14a24 <__aeabi_i2d>
   2fda8:	e1a02001 	mov	r2, r1
   2fdac:	e1a01000 	mov	r1, r0
   2fdb0:	e59f069c 	ldr	r0, [pc, #1692]	; 30454 <__kernel_rem_pio2+0xf8c>
   2fdb4:	e1a03184 	lsl	r3, r4, #3
   2fdb8:	e24bc024 	sub	ip, fp, #36	; 0x24
   2fdbc:	e08c3003 	add	r3, ip, r3
   2fdc0:	e0833000 	add	r3, r3, r0
   2fdc4:	e8830006 	stm	r3, {r1, r2}
		    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j];
   2fdc8:	e3a03000 	mov	r3, #0
   2fdcc:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2fdd0:	e3a03000 	mov	r3, #0
   2fdd4:	e3a04000 	mov	r4, #0
   2fdd8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   2fddc:	e50b4058 	str	r4, [fp, #-88]	; 0x58
   2fde0:	ea000020 	b	2fe68 <__kernel_rem_pio2+0x9a0>
   2fde4:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2fde8:	e1a03183 	lsl	r3, r3, #3
   2fdec:	e51b22a0 	ldr	r2, [fp, #-672]	; 0x2a0
   2fdf0:	e0823003 	add	r3, r2, r3
   2fdf4:	e8930003 	ldm	r3, {r0, r1}
   2fdf8:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   2fdfc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2fe00:	e0822003 	add	r2, r2, r3
   2fe04:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2fe08:	e0633002 	rsb	r3, r3, r2
   2fe0c:	e59f2640 	ldr	r2, [pc, #1600]	; 30454 <__kernel_rem_pio2+0xf8c>
   2fe10:	e1a03183 	lsl	r3, r3, #3
   2fe14:	e24b4024 	sub	r4, fp, #36	; 0x24
   2fe18:	e0843003 	add	r3, r4, r3
   2fe1c:	e0833002 	add	r3, r3, r2
   2fe20:	e8930018 	ldm	r3, {r3, r4}
   2fe24:	e1a02003 	mov	r2, r3
   2fe28:	e1a03004 	mov	r3, r4
   2fe2c:	ebff9333 	bl	14b00 <__aeabi_dmul>
   2fe30:	e1a03000 	mov	r3, r0
   2fe34:	e1a04001 	mov	r4, r1
   2fe38:	e24b105c 	sub	r1, fp, #92	; 0x5c
   2fe3c:	e8910003 	ldm	r1, {r0, r1}
   2fe40:	e1a02003 	mov	r2, r3
   2fe44:	e1a03004 	mov	r3, r4
   2fe48:	ebff9228 	bl	146f0 <__adddf3>
   2fe4c:	e1a03000 	mov	r3, r0
   2fe50:	e1a04001 	mov	r4, r1
   2fe54:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   2fe58:	e50b4058 	str	r4, [fp, #-88]	; 0x58
   2fe5c:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   2fe60:	e2833001 	add	r3, r3, #1
   2fe64:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   2fe68:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   2fe6c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   2fe70:	e1520003 	cmp	r2, r3
   2fe74:	daffffda 	ble	2fde4 <__kernel_rem_pio2+0x91c>
		    q[i] = fw;
   2fe78:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2fe7c:	e59f25d4 	ldr	r2, [pc, #1492]	; 30458 <__kernel_rem_pio2+0xf90>
   2fe80:	e1a03183 	lsl	r3, r3, #3
   2fe84:	e24bc024 	sub	ip, fp, #36	; 0x24
   2fe88:	e08c3003 	add	r3, ip, r3
   2fe8c:	e0832002 	add	r2, r3, r2
   2fe90:	e24b405c 	sub	r4, fp, #92	; 0x5c
   2fe94:	e8940018 	ldm	r4, {r3, r4}
   2fe98:	e8820018 	stm	r2, {r3, r4}
	    j = 0;
	    for (i=jz-1;i>=jk;i--) j |= iq[i];
	    if(j==0) { /* need recomputation */
		for(k=1;iq[jk-k]==0;k++);   /* k = no. of terms needed */

		for(i=jz+1;i<=jz+k;i++) {   /* add q[jz+1] to q[jz+k] */
   2fe9c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2fea0:	e2833001 	add	r3, r3, #1
   2fea4:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   2fea8:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   2feac:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   2feb0:	e0822003 	add	r2, r2, r3
   2feb4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   2feb8:	e1520003 	cmp	r2, r3
   2febc:	aaffffad 	bge	2fd78 <__kernel_rem_pio2+0x8b0>
		    f[jx+i] = (double) ipio2[jv+i];
		    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j];
		    q[i] = fw;
		}
		jz += k;
   2fec0:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   2fec4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   2fec8:	e0823003 	add	r3, r2, r3
   2fecc:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		goto recompute;
   2fed0:	eafffe0f 	b	2f714 <__kernel_rem_pio2+0x24c>
	    }
	}

    /* chop off zero terms */
	if(z==0.0) {
   2fed4:	e24b1054 	sub	r1, fp, #84	; 0x54
   2fed8:	e8910003 	ldm	r1, {r0, r1}
   2fedc:	e3a02000 	mov	r2, #0
   2fee0:	e3a03000 	mov	r3, #0
   2fee4:	ebff945f 	bl	15068 <__aeabi_dcmpeq>
   2fee8:	e1a03000 	mov	r3, r0
   2feec:	e3530000 	cmp	r3, #0
   2fef0:	0a000016 	beq	2ff50 <__kernel_rem_pio2+0xa88>
	    jz -= 1; q0 -= 24;
   2fef4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2fef8:	e2433001 	sub	r3, r3, #1
   2fefc:	e50b3028 	str	r3, [fp, #-40]	; 0x28
   2ff00:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2ff04:	e2433018 	sub	r3, r3, #24
   2ff08:	e50b3044 	str	r3, [fp, #-68]	; 0x44
	    while(iq[jz]==0) { jz--; q0-=24;}
   2ff0c:	ea000005 	b	2ff28 <__kernel_rem_pio2+0xa60>
   2ff10:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ff14:	e2433001 	sub	r3, r3, #1
   2ff18:	e50b3028 	str	r3, [fp, #-40]	; 0x28
   2ff1c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2ff20:	e2433018 	sub	r3, r3, #24
   2ff24:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   2ff28:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   2ff2c:	e3e02097 	mvn	r2, #151	; 0x97
   2ff30:	e1a03103 	lsl	r3, r3, #2
   2ff34:	e24b0024 	sub	r0, fp, #36	; 0x24
   2ff38:	e0803003 	add	r3, r0, r3
   2ff3c:	e0833002 	add	r3, r3, r2
   2ff40:	e5933000 	ldr	r3, [r3]
   2ff44:	e3530000 	cmp	r3, #0
   2ff48:	0afffff0 	beq	2ff10 <__kernel_rem_pio2+0xa48>
   2ff4c:	ea00005c 	b	300c4 <__kernel_rem_pio2+0xbfc>
	} else { /* break z into 24-bit if necessary */
	    z = scalbn(z,-(int)q0);
   2ff50:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   2ff54:	e2633000 	rsb	r3, r3, #0
   2ff58:	e24b1054 	sub	r1, fp, #84	; 0x54
   2ff5c:	e8910003 	ldm	r1, {r0, r1}
   2ff60:	e1a02003 	mov	r2, r3
   2ff64:	eb00057d 	bl	31560 <scalbn>
   2ff68:	e50b0054 	str	r0, [fp, #-84]	; 0x54
   2ff6c:	e50b1050 	str	r1, [fp, #-80]	; 0x50
	    if(z>=two24) { 
   2ff70:	e3a03000 	mov	r3, #0
   2ff74:	e59f44e4 	ldr	r4, [pc, #1252]	; 30460 <__kernel_rem_pio2+0xf98>
   2ff78:	e24b1054 	sub	r1, fp, #84	; 0x54
   2ff7c:	e8910003 	ldm	r1, {r0, r1}
   2ff80:	e1a02003 	mov	r2, r3
   2ff84:	e1a03004 	mov	r3, r4
   2ff88:	ebff9448 	bl	150b0 <__aeabi_dcmpge>
   2ff8c:	e1a03000 	mov	r3, r0
   2ff90:	e3530000 	cmp	r3, #0
   2ff94:	0a00003f 	beq	30098 <__kernel_rem_pio2+0xbd0>
		fw = (double)((__int32_t)(twon24*z));
   2ff98:	e3a03000 	mov	r3, #0
   2ff9c:	e59f44b8 	ldr	r4, [pc, #1208]	; 3045c <__kernel_rem_pio2+0xf94>
   2ffa0:	e1a00003 	mov	r0, r3
   2ffa4:	e1a01004 	mov	r1, r4
   2ffa8:	e24b3054 	sub	r3, fp, #84	; 0x54
   2ffac:	e893000c 	ldm	r3, {r2, r3}
   2ffb0:	ebff92d2 	bl	14b00 <__aeabi_dmul>
   2ffb4:	e1a03000 	mov	r3, r0
   2ffb8:	e1a04001 	mov	r4, r1
   2ffbc:	e1a00003 	mov	r0, r3
   2ffc0:	e1a01004 	mov	r1, r4
   2ffc4:	ebff9445 	bl	150e0 <__aeabi_d2iz>
   2ffc8:	e1a03000 	mov	r3, r0
   2ffcc:	e1a00003 	mov	r0, r3
   2ffd0:	ebff9293 	bl	14a24 <__aeabi_i2d>
   2ffd4:	e1a03000 	mov	r3, r0
   2ffd8:	e1a04001 	mov	r4, r1
   2ffdc:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   2ffe0:	e50b4058 	str	r4, [fp, #-88]	; 0x58
		iq[jz] = (__int32_t)(z-two24*fw);
   2ffe4:	e3a03000 	mov	r3, #0
   2ffe8:	e59f4470 	ldr	r4, [pc, #1136]	; 30460 <__kernel_rem_pio2+0xf98>
   2ffec:	e1a00003 	mov	r0, r3
   2fff0:	e1a01004 	mov	r1, r4
   2fff4:	e24b305c 	sub	r3, fp, #92	; 0x5c
   2fff8:	e893000c 	ldm	r3, {r2, r3}
   2fffc:	ebff92bf 	bl	14b00 <__aeabi_dmul>
   30000:	e1a03000 	mov	r3, r0
   30004:	e1a04001 	mov	r4, r1
   30008:	e24b1054 	sub	r1, fp, #84	; 0x54
   3000c:	e8910003 	ldm	r1, {r0, r1}
   30010:	e1a02003 	mov	r2, r3
   30014:	e1a03004 	mov	r3, r4
   30018:	ebff91b3 	bl	146ec <__aeabi_dsub>
   3001c:	e1a03000 	mov	r3, r0
   30020:	e1a04001 	mov	r4, r1
   30024:	e1a00003 	mov	r0, r3
   30028:	e1a01004 	mov	r1, r4
   3002c:	ebff942b 	bl	150e0 <__aeabi_d2iz>
   30030:	e1a01000 	mov	r1, r0
   30034:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   30038:	e3e02097 	mvn	r2, #151	; 0x97
   3003c:	e1a03103 	lsl	r3, r3, #2
   30040:	e24b4024 	sub	r4, fp, #36	; 0x24
   30044:	e0843003 	add	r3, r4, r3
   30048:	e0833002 	add	r3, r3, r2
   3004c:	e5831000 	str	r1, [r3]
		jz += 1; q0 += 24;
   30050:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   30054:	e2833001 	add	r3, r3, #1
   30058:	e50b3028 	str	r3, [fp, #-40]	; 0x28
   3005c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   30060:	e2833018 	add	r3, r3, #24
   30064:	e50b3044 	str	r3, [fp, #-68]	; 0x44
		iq[jz] = (__int32_t) fw;
   30068:	e24b105c 	sub	r1, fp, #92	; 0x5c
   3006c:	e8910003 	ldm	r1, {r0, r1}
   30070:	ebff941a 	bl	150e0 <__aeabi_d2iz>
   30074:	e1a01000 	mov	r1, r0
   30078:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   3007c:	e3e02097 	mvn	r2, #151	; 0x97
   30080:	e1a03103 	lsl	r3, r3, #2
   30084:	e24bc024 	sub	ip, fp, #36	; 0x24
   30088:	e08c3003 	add	r3, ip, r3
   3008c:	e0833002 	add	r3, r3, r2
   30090:	e5831000 	str	r1, [r3]
   30094:	ea00000a 	b	300c4 <__kernel_rem_pio2+0xbfc>
	    } else iq[jz] = (__int32_t) z ;
   30098:	e24b1054 	sub	r1, fp, #84	; 0x54
   3009c:	e8910003 	ldm	r1, {r0, r1}
   300a0:	ebff940e 	bl	150e0 <__aeabi_d2iz>
   300a4:	e1a01000 	mov	r1, r0
   300a8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   300ac:	e3e02097 	mvn	r2, #151	; 0x97
   300b0:	e1a03103 	lsl	r3, r3, #2
   300b4:	e24b0024 	sub	r0, fp, #36	; 0x24
   300b8:	e0803003 	add	r3, r0, r3
   300bc:	e0833002 	add	r3, r3, r2
   300c0:	e5831000 	str	r1, [r3]
	}

    /* convert integer "bit" chunk to floating-point value */
	fw = scalbn(one,(int)q0);
   300c4:	e3a03000 	mov	r3, #0
   300c8:	e59f439c 	ldr	r4, [pc, #924]	; 3046c <__kernel_rem_pio2+0xfa4>
   300cc:	e1a00003 	mov	r0, r3
   300d0:	e1a01004 	mov	r1, r4
   300d4:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   300d8:	eb000520 	bl	31560 <scalbn>
   300dc:	e50b005c 	str	r0, [fp, #-92]	; 0x5c
   300e0:	e50b1058 	str	r1, [fp, #-88]	; 0x58
	for(i=jz;i>=0;i--) {
   300e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   300e8:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   300ec:	ea000028 	b	30194 <__kernel_rem_pio2+0xccc>
	    q[i] = fw*(double)iq[i]; fw*=twon24;
   300f0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   300f4:	e3e02097 	mvn	r2, #151	; 0x97
   300f8:	e1a03103 	lsl	r3, r3, #2
   300fc:	e24b1024 	sub	r1, fp, #36	; 0x24
   30100:	e0813003 	add	r3, r1, r3
   30104:	e0833002 	add	r3, r3, r2
   30108:	e5933000 	ldr	r3, [r3]
   3010c:	e1a00003 	mov	r0, r3
   30110:	ebff9243 	bl	14a24 <__aeabi_i2d>
   30114:	e1a03000 	mov	r3, r0
   30118:	e1a04001 	mov	r4, r1
   3011c:	e1a00003 	mov	r0, r3
   30120:	e1a01004 	mov	r1, r4
   30124:	e24b305c 	sub	r3, fp, #92	; 0x5c
   30128:	e893000c 	ldm	r3, {r2, r3}
   3012c:	ebff9273 	bl	14b00 <__aeabi_dmul>
   30130:	e1a03000 	mov	r3, r0
   30134:	e1a04001 	mov	r4, r1
   30138:	e1a01003 	mov	r1, r3
   3013c:	e1a02004 	mov	r2, r4
   30140:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   30144:	e59f030c 	ldr	r0, [pc, #780]	; 30458 <__kernel_rem_pio2+0xf90>
   30148:	e1a03183 	lsl	r3, r3, #3
   3014c:	e24b4024 	sub	r4, fp, #36	; 0x24
   30150:	e0843003 	add	r3, r4, r3
   30154:	e0833000 	add	r3, r3, r0
   30158:	e8830006 	stm	r3, {r1, r2}
   3015c:	e3a03000 	mov	r3, #0
   30160:	e59f42f4 	ldr	r4, [pc, #756]	; 3045c <__kernel_rem_pio2+0xf94>
   30164:	e24b105c 	sub	r1, fp, #92	; 0x5c
   30168:	e8910003 	ldm	r1, {r0, r1}
   3016c:	e1a02003 	mov	r2, r3
   30170:	e1a03004 	mov	r3, r4
   30174:	ebff9261 	bl	14b00 <__aeabi_dmul>
   30178:	e1a03000 	mov	r3, r0
   3017c:	e1a04001 	mov	r4, r1
   30180:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   30184:	e50b4058 	str	r4, [fp, #-88]	; 0x58
	    } else iq[jz] = (__int32_t) z ;
	}

    /* convert integer "bit" chunk to floating-point value */
	fw = scalbn(one,(int)q0);
	for(i=jz;i>=0;i--) {
   30188:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   3018c:	e2433001 	sub	r3, r3, #1
   30190:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   30194:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   30198:	e3530000 	cmp	r3, #0
   3019c:	aaffffd3 	bge	300f0 <__kernel_rem_pio2+0xc28>
	    q[i] = fw*(double)iq[i]; fw*=twon24;
	}

    /* compute PIo2[0,...,jp]*q[jz,...,0] */
	for(i=jz;i>=0;i--) {
   301a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   301a4:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   301a8:	ea00003d 	b	302a4 <__kernel_rem_pio2+0xddc>
	    for(fw=0.0,k=0;k<=jp&&k<=jz-i;k++) fw += PIo2[k]*q[i+k];
   301ac:	e3a03000 	mov	r3, #0
   301b0:	e3a04000 	mov	r4, #0
   301b4:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   301b8:	e50b4058 	str	r4, [fp, #-88]	; 0x58
   301bc:	e3a03000 	mov	r3, #0
   301c0:	e50b3040 	str	r3, [fp, #-64]	; 0x40
   301c4:	ea00001e 	b	30244 <__kernel_rem_pio2+0xd7c>
   301c8:	e59f22a0 	ldr	r2, [pc, #672]	; 30470 <__kernel_rem_pio2+0xfa8>
   301cc:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   301d0:	e1a03183 	lsl	r3, r3, #3
   301d4:	e0823003 	add	r3, r2, r3
   301d8:	e8930003 	ldm	r3, {r0, r1}
   301dc:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   301e0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   301e4:	e0823003 	add	r3, r2, r3
   301e8:	e59f2268 	ldr	r2, [pc, #616]	; 30458 <__kernel_rem_pio2+0xf90>
   301ec:	e1a03183 	lsl	r3, r3, #3
   301f0:	e24bc024 	sub	ip, fp, #36	; 0x24
   301f4:	e08c3003 	add	r3, ip, r3
   301f8:	e0833002 	add	r3, r3, r2
   301fc:	e8930018 	ldm	r3, {r3, r4}
   30200:	e1a02003 	mov	r2, r3
   30204:	e1a03004 	mov	r3, r4
   30208:	ebff923c 	bl	14b00 <__aeabi_dmul>
   3020c:	e1a03000 	mov	r3, r0
   30210:	e1a04001 	mov	r4, r1
   30214:	e24b105c 	sub	r1, fp, #92	; 0x5c
   30218:	e8910003 	ldm	r1, {r0, r1}
   3021c:	e1a02003 	mov	r2, r3
   30220:	e1a03004 	mov	r3, r4
   30224:	ebff9131 	bl	146f0 <__adddf3>
   30228:	e1a03000 	mov	r3, r0
   3022c:	e1a04001 	mov	r4, r1
   30230:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   30234:	e50b4058 	str	r4, [fp, #-88]	; 0x58
   30238:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   3023c:	e2833001 	add	r3, r3, #1
   30240:	e50b3040 	str	r3, [fp, #-64]	; 0x40
   30244:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   30248:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   3024c:	e1520003 	cmp	r2, r3
   30250:	ca000005 	bgt	3026c <__kernel_rem_pio2+0xda4>
   30254:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   30258:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   3025c:	e0632002 	rsb	r2, r3, r2
   30260:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   30264:	e1520003 	cmp	r2, r3
   30268:	aaffffd6 	bge	301c8 <__kernel_rem_pio2+0xd00>
	    fq[jz-i] = fw;
   3026c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   30270:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   30274:	e0633002 	rsb	r3, r3, r2
   30278:	e59f21f4 	ldr	r2, [pc, #500]	; 30474 <__kernel_rem_pio2+0xfac>
   3027c:	e1a03183 	lsl	r3, r3, #3
   30280:	e24b0024 	sub	r0, fp, #36	; 0x24
   30284:	e0803003 	add	r3, r0, r3
   30288:	e0832002 	add	r2, r3, r2
   3028c:	e24b405c 	sub	r4, fp, #92	; 0x5c
   30290:	e8940018 	ldm	r4, {r3, r4}
   30294:	e8820018 	stm	r2, {r3, r4}
	for(i=jz;i>=0;i--) {
	    q[i] = fw*(double)iq[i]; fw*=twon24;
	}

    /* compute PIo2[0,...,jp]*q[jz,...,0] */
	for(i=jz;i>=0;i--) {
   30298:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   3029c:	e2433001 	sub	r3, r3, #1
   302a0:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   302a4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   302a8:	e3530000 	cmp	r3, #0
   302ac:	aaffffbe 	bge	301ac <__kernel_rem_pio2+0xce4>
	    for(fw=0.0,k=0;k<=jp&&k<=jz-i;k++) fw += PIo2[k]*q[i+k];
	    fq[jz-i] = fw;
	}

    /* compress fq[] into y[] */
	switch(prec) {
   302b0:	e59b3004 	ldr	r3, [fp, #4]
   302b4:	e3530003 	cmp	r3, #3
   302b8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   302bc:	ea00017b 	b	308b0 <__kernel_rem_pio2+0x13e8>
   302c0:	000302d0 	.word	0x000302d0
   302c4:	00030374 	.word	0x00030374
   302c8:	00030374 	.word	0x00030374
   302cc:	00030508 	.word	0x00030508
	    case 0:
		fw = 0.0;
   302d0:	e3a03000 	mov	r3, #0
   302d4:	e3a04000 	mov	r4, #0
   302d8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   302dc:	e50b4058 	str	r4, [fp, #-88]	; 0x58
		for (i=jz;i>=0;i--) fw += fq[i];
   302e0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   302e4:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   302e8:	ea000012 	b	30338 <__kernel_rem_pio2+0xe70>
   302ec:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   302f0:	e59f317c 	ldr	r3, [pc, #380]	; 30474 <__kernel_rem_pio2+0xfac>
   302f4:	e1a02182 	lsl	r2, r2, #3
   302f8:	e24b1024 	sub	r1, fp, #36	; 0x24
   302fc:	e0812002 	add	r2, r1, r2
   30300:	e0823003 	add	r3, r2, r3
   30304:	e8930018 	ldm	r3, {r3, r4}
   30308:	e24b105c 	sub	r1, fp, #92	; 0x5c
   3030c:	e8910003 	ldm	r1, {r0, r1}
   30310:	e1a02003 	mov	r2, r3
   30314:	e1a03004 	mov	r3, r4
   30318:	ebff90f4 	bl	146f0 <__adddf3>
   3031c:	e1a03000 	mov	r3, r0
   30320:	e1a04001 	mov	r4, r1
   30324:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   30328:	e50b4058 	str	r4, [fp, #-88]	; 0x58
   3032c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   30330:	e2433001 	sub	r3, r3, #1
   30334:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   30338:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   3033c:	e3530000 	cmp	r3, #0
   30340:	aaffffe9 	bge	302ec <__kernel_rem_pio2+0xe24>
		y[0] = (ih==0)? fw: -fw; 
   30344:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   30348:	e3530000 	cmp	r3, #0
   3034c:	0a000003 	beq	30360 <__kernel_rem_pio2+0xe98>
   30350:	e51b905c 	ldr	r9, [fp, #-92]	; 0x5c
   30354:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   30358:	e223a102 	eor	sl, r3, #-2147483648	; 0x80000000
   3035c:	ea000001 	b	30368 <__kernel_rem_pio2+0xea0>
   30360:	e24ba05c 	sub	sl, fp, #92	; 0x5c
   30364:	e89a0600 	ldm	sl, {r9, sl}
   30368:	e51b32a4 	ldr	r3, [fp, #-676]	; 0x2a4
   3036c:	e8830600 	stm	r3, {r9, sl}
		break;
   30370:	ea00014e 	b	308b0 <__kernel_rem_pio2+0x13e8>
	    case 1:
	    case 2:
		fw = 0.0;
   30374:	e3a03000 	mov	r3, #0
   30378:	e3a04000 	mov	r4, #0
   3037c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   30380:	e50b4058 	str	r4, [fp, #-88]	; 0x58
		for (i=jz;i>=0;i--) fw += fq[i]; 
   30384:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   30388:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   3038c:	ea000012 	b	303dc <__kernel_rem_pio2+0xf14>
   30390:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   30394:	e59f30d8 	ldr	r3, [pc, #216]	; 30474 <__kernel_rem_pio2+0xfac>
   30398:	e1a02182 	lsl	r2, r2, #3
   3039c:	e24b4024 	sub	r4, fp, #36	; 0x24
   303a0:	e0842002 	add	r2, r4, r2
   303a4:	e0823003 	add	r3, r2, r3
   303a8:	e8930018 	ldm	r3, {r3, r4}
   303ac:	e24b105c 	sub	r1, fp, #92	; 0x5c
   303b0:	e8910003 	ldm	r1, {r0, r1}
   303b4:	e1a02003 	mov	r2, r3
   303b8:	e1a03004 	mov	r3, r4
   303bc:	ebff90cb 	bl	146f0 <__adddf3>
   303c0:	e1a03000 	mov	r3, r0
   303c4:	e1a04001 	mov	r4, r1
   303c8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   303cc:	e50b4058 	str	r4, [fp, #-88]	; 0x58
   303d0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   303d4:	e2433001 	sub	r3, r3, #1
   303d8:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   303dc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   303e0:	e3530000 	cmp	r3, #0
   303e4:	aaffffe9 	bge	30390 <__kernel_rem_pio2+0xec8>
		y[0] = (ih==0)? fw: -fw; 
   303e8:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   303ec:	e3530000 	cmp	r3, #0
   303f0:	0a000003 	beq	30404 <__kernel_rem_pio2+0xf3c>
   303f4:	e51b705c 	ldr	r7, [fp, #-92]	; 0x5c
   303f8:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   303fc:	e2238102 	eor	r8, r3, #-2147483648	; 0x80000000
   30400:	ea000001 	b	3040c <__kernel_rem_pio2+0xf44>
   30404:	e24b805c 	sub	r8, fp, #92	; 0x5c
   30408:	e8980180 	ldm	r8, {r7, r8}
   3040c:	e51b32a4 	ldr	r3, [fp, #-676]	; 0x2a4
   30410:	e8830180 	stm	r3, {r7, r8}
		fw = fq[0]-fw;
   30414:	e24b4f7f 	sub	r4, fp, #508	; 0x1fc
   30418:	e8940018 	ldm	r4, {r3, r4}
   3041c:	e1a00003 	mov	r0, r3
   30420:	e1a01004 	mov	r1, r4
   30424:	e24b305c 	sub	r3, fp, #92	; 0x5c
   30428:	e893000c 	ldm	r3, {r2, r3}
   3042c:	ebff90ae 	bl	146ec <__aeabi_dsub>
   30430:	e1a03000 	mov	r3, r0
   30434:	e1a04001 	mov	r4, r1
   30438:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   3043c:	e50b4058 	str	r4, [fp, #-88]	; 0x58
		for (i=1;i<=jz;i++) fw += fq[i];
   30440:	e3a03001 	mov	r3, #1
   30444:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   30448:	ea00001d 	b	304c4 <__kernel_rem_pio2+0xffc>
   3044c:	000337e8 	.word	0x000337e8
   30450:	2aaaaaab 	.word	0x2aaaaaab
   30454:	fffffec8 	.word	0xfffffec8
   30458:	fffffd88 	.word	0xfffffd88
   3045c:	3e700000 	.word	0x3e700000
   30460:	41700000 	.word	0x41700000
   30464:	40200000 	.word	0x40200000
   30468:	3fe00000 	.word	0x3fe00000
   3046c:	3ff00000 	.word	0x3ff00000
   30470:	000337f8 	.word	0x000337f8
   30474:	fffffe28 	.word	0xfffffe28
   30478:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   3047c:	e51f3010 	ldr	r3, [pc, #-16]	; 30474 <__kernel_rem_pio2+0xfac>
   30480:	e1a02182 	lsl	r2, r2, #3
   30484:	e24bc024 	sub	ip, fp, #36	; 0x24
   30488:	e08c2002 	add	r2, ip, r2
   3048c:	e0823003 	add	r3, r2, r3
   30490:	e8930018 	ldm	r3, {r3, r4}
   30494:	e24b105c 	sub	r1, fp, #92	; 0x5c
   30498:	e8910003 	ldm	r1, {r0, r1}
   3049c:	e1a02003 	mov	r2, r3
   304a0:	e1a03004 	mov	r3, r4
   304a4:	ebff9091 	bl	146f0 <__adddf3>
   304a8:	e1a03000 	mov	r3, r0
   304ac:	e1a04001 	mov	r4, r1
   304b0:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   304b4:	e50b4058 	str	r4, [fp, #-88]	; 0x58
   304b8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   304bc:	e2833001 	add	r3, r3, #1
   304c0:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   304c4:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   304c8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   304cc:	e1520003 	cmp	r2, r3
   304d0:	daffffe8 	ble	30478 <__kernel_rem_pio2+0xfb0>
		y[1] = (ih==0)? fw: -fw; 
   304d4:	e51b32a4 	ldr	r3, [fp, #-676]	; 0x2a4
   304d8:	e2833008 	add	r3, r3, #8
   304dc:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   304e0:	e3520000 	cmp	r2, #0
   304e4:	0a000003 	beq	304f8 <__kernel_rem_pio2+0x1030>
   304e8:	e51b505c 	ldr	r5, [fp, #-92]	; 0x5c
   304ec:	e51b2058 	ldr	r2, [fp, #-88]	; 0x58
   304f0:	e2226102 	eor	r6, r2, #-2147483648	; 0x80000000
   304f4:	ea000001 	b	30500 <__kernel_rem_pio2+0x1038>
   304f8:	e24b605c 	sub	r6, fp, #92	; 0x5c
   304fc:	e8960060 	ldm	r6, {r5, r6}
   30500:	e8830060 	stm	r3, {r5, r6}
		break;
   30504:	ea0000e9 	b	308b0 <__kernel_rem_pio2+0x13e8>
	    case 3:	/* painful */
		for (i=jz;i>0;i--) {
   30508:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   3050c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   30510:	ea000048 	b	30638 <__kernel_rem_pio2+0x1170>
		    fw      = fq[i-1]+fq[i]; 
   30514:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   30518:	e2432001 	sub	r2, r3, #1
   3051c:	e51f30b0 	ldr	r3, [pc, #-176]	; 30474 <__kernel_rem_pio2+0xfac>
   30520:	e1a02182 	lsl	r2, r2, #3
   30524:	e24b0024 	sub	r0, fp, #36	; 0x24
   30528:	e0802002 	add	r2, r0, r2
   3052c:	e0823003 	add	r3, r2, r3
   30530:	e8930006 	ldm	r3, {r1, r2}
   30534:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
   30538:	e51f30cc 	ldr	r3, [pc, #-204]	; 30474 <__kernel_rem_pio2+0xfac>
   3053c:	e1a00180 	lsl	r0, r0, #3
   30540:	e24b4024 	sub	r4, fp, #36	; 0x24
   30544:	e0840000 	add	r0, r4, r0
   30548:	e0803003 	add	r3, r0, r3
   3054c:	e8930018 	ldm	r3, {r3, r4}
   30550:	e1a00001 	mov	r0, r1
   30554:	e1a01002 	mov	r1, r2
   30558:	e1a02003 	mov	r2, r3
   3055c:	e1a03004 	mov	r3, r4
   30560:	ebff9062 	bl	146f0 <__adddf3>
   30564:	e1a03000 	mov	r3, r0
   30568:	e1a04001 	mov	r4, r1
   3056c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   30570:	e50b4058 	str	r4, [fp, #-88]	; 0x58
		    fq[i]  += fq[i-1]-fw;
   30574:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   30578:	e51f310c 	ldr	r3, [pc, #-268]	; 30474 <__kernel_rem_pio2+0xfac>
   3057c:	e1a02182 	lsl	r2, r2, #3
   30580:	e24bc024 	sub	ip, fp, #36	; 0x24
   30584:	e08c2002 	add	r2, ip, r2
   30588:	e0823003 	add	r3, r2, r3
   3058c:	e8930060 	ldm	r3, {r5, r6}
   30590:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   30594:	e2432001 	sub	r2, r3, #1
   30598:	e51f312c 	ldr	r3, [pc, #-300]	; 30474 <__kernel_rem_pio2+0xfac>
   3059c:	e1a02182 	lsl	r2, r2, #3
   305a0:	e24b0024 	sub	r0, fp, #36	; 0x24
   305a4:	e0802002 	add	r2, r0, r2
   305a8:	e0823003 	add	r3, r2, r3
   305ac:	e8930018 	ldm	r3, {r3, r4}
   305b0:	e1a00003 	mov	r0, r3
   305b4:	e1a01004 	mov	r1, r4
   305b8:	e24b305c 	sub	r3, fp, #92	; 0x5c
   305bc:	e893000c 	ldm	r3, {r2, r3}
   305c0:	ebff9049 	bl	146ec <__aeabi_dsub>
   305c4:	e1a03000 	mov	r3, r0
   305c8:	e1a04001 	mov	r4, r1
   305cc:	e1a00005 	mov	r0, r5
   305d0:	e1a01006 	mov	r1, r6
   305d4:	e1a02003 	mov	r2, r3
   305d8:	e1a03004 	mov	r3, r4
   305dc:	ebff9043 	bl	146f0 <__adddf3>
   305e0:	e1a03000 	mov	r3, r0
   305e4:	e1a04001 	mov	r4, r1
   305e8:	e51b1038 	ldr	r1, [fp, #-56]	; 0x38
   305ec:	e51f2180 	ldr	r2, [pc, #-384]	; 30474 <__kernel_rem_pio2+0xfac>
   305f0:	e1a01181 	lsl	r1, r1, #3
   305f4:	e24bc024 	sub	ip, fp, #36	; 0x24
   305f8:	e08c1001 	add	r1, ip, r1
   305fc:	e0812002 	add	r2, r1, r2
   30600:	e8820018 	stm	r2, {r3, r4}
		    fq[i-1] = fw;
   30604:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   30608:	e2432001 	sub	r2, r3, #1
   3060c:	e51f31a0 	ldr	r3, [pc, #-416]	; 30474 <__kernel_rem_pio2+0xfac>
   30610:	e1a02182 	lsl	r2, r2, #3
   30614:	e24b0024 	sub	r0, fp, #36	; 0x24
   30618:	e0802002 	add	r2, r0, r2
   3061c:	e0822003 	add	r2, r2, r3
   30620:	e24b405c 	sub	r4, fp, #92	; 0x5c
   30624:	e8940018 	ldm	r4, {r3, r4}
   30628:	e8820018 	stm	r2, {r3, r4}
		fw = fq[0]-fw;
		for (i=1;i<=jz;i++) fw += fq[i];
		y[1] = (ih==0)? fw: -fw; 
		break;
	    case 3:	/* painful */
		for (i=jz;i>0;i--) {
   3062c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   30630:	e2433001 	sub	r3, r3, #1
   30634:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   30638:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   3063c:	e3530000 	cmp	r3, #0
   30640:	caffffb3 	bgt	30514 <__kernel_rem_pio2+0x104c>
		    fw      = fq[i-1]+fq[i]; 
		    fq[i]  += fq[i-1]-fw;
		    fq[i-1] = fw;
		}
		for (i=jz;i>1;i--) {
   30644:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   30648:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   3064c:	ea000048 	b	30774 <__kernel_rem_pio2+0x12ac>
		    fw      = fq[i-1]+fq[i]; 
   30650:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   30654:	e2432001 	sub	r2, r3, #1
   30658:	e51f31ec 	ldr	r3, [pc, #-492]	; 30474 <__kernel_rem_pio2+0xfac>
   3065c:	e1a02182 	lsl	r2, r2, #3
   30660:	e24b1024 	sub	r1, fp, #36	; 0x24
   30664:	e0812002 	add	r2, r1, r2
   30668:	e0823003 	add	r3, r2, r3
   3066c:	e8930006 	ldm	r3, {r1, r2}
   30670:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
   30674:	e51f3208 	ldr	r3, [pc, #-520]	; 30474 <__kernel_rem_pio2+0xfac>
   30678:	e1a00180 	lsl	r0, r0, #3
   3067c:	e24b4024 	sub	r4, fp, #36	; 0x24
   30680:	e0840000 	add	r0, r4, r0
   30684:	e0803003 	add	r3, r0, r3
   30688:	e8930018 	ldm	r3, {r3, r4}
   3068c:	e1a00001 	mov	r0, r1
   30690:	e1a01002 	mov	r1, r2
   30694:	e1a02003 	mov	r2, r3
   30698:	e1a03004 	mov	r3, r4
   3069c:	ebff9013 	bl	146f0 <__adddf3>
   306a0:	e1a03000 	mov	r3, r0
   306a4:	e1a04001 	mov	r4, r1
   306a8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   306ac:	e50b4058 	str	r4, [fp, #-88]	; 0x58
		    fq[i]  += fq[i-1]-fw;
   306b0:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   306b4:	e51f3248 	ldr	r3, [pc, #-584]	; 30474 <__kernel_rem_pio2+0xfac>
   306b8:	e1a02182 	lsl	r2, r2, #3
   306bc:	e24bc024 	sub	ip, fp, #36	; 0x24
   306c0:	e08c2002 	add	r2, ip, r2
   306c4:	e0823003 	add	r3, r2, r3
   306c8:	e8930060 	ldm	r3, {r5, r6}
   306cc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   306d0:	e2432001 	sub	r2, r3, #1
   306d4:	e51f3268 	ldr	r3, [pc, #-616]	; 30474 <__kernel_rem_pio2+0xfac>
   306d8:	e1a02182 	lsl	r2, r2, #3
   306dc:	e24b0024 	sub	r0, fp, #36	; 0x24
   306e0:	e0802002 	add	r2, r0, r2
   306e4:	e0823003 	add	r3, r2, r3
   306e8:	e8930018 	ldm	r3, {r3, r4}
   306ec:	e1a00003 	mov	r0, r3
   306f0:	e1a01004 	mov	r1, r4
   306f4:	e24b305c 	sub	r3, fp, #92	; 0x5c
   306f8:	e893000c 	ldm	r3, {r2, r3}
   306fc:	ebff8ffa 	bl	146ec <__aeabi_dsub>
   30700:	e1a03000 	mov	r3, r0
   30704:	e1a04001 	mov	r4, r1
   30708:	e1a00005 	mov	r0, r5
   3070c:	e1a01006 	mov	r1, r6
   30710:	e1a02003 	mov	r2, r3
   30714:	e1a03004 	mov	r3, r4
   30718:	ebff8ff4 	bl	146f0 <__adddf3>
   3071c:	e1a03000 	mov	r3, r0
   30720:	e1a04001 	mov	r4, r1
   30724:	e51b1038 	ldr	r1, [fp, #-56]	; 0x38
   30728:	e51f22bc 	ldr	r2, [pc, #-700]	; 30474 <__kernel_rem_pio2+0xfac>
   3072c:	e1a01181 	lsl	r1, r1, #3
   30730:	e24bc024 	sub	ip, fp, #36	; 0x24
   30734:	e08c1001 	add	r1, ip, r1
   30738:	e0812002 	add	r2, r1, r2
   3073c:	e8820018 	stm	r2, {r3, r4}
		    fq[i-1] = fw;
   30740:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   30744:	e2432001 	sub	r2, r3, #1
   30748:	e51f32dc 	ldr	r3, [pc, #-732]	; 30474 <__kernel_rem_pio2+0xfac>
   3074c:	e1a02182 	lsl	r2, r2, #3
   30750:	e24b0024 	sub	r0, fp, #36	; 0x24
   30754:	e0802002 	add	r2, r0, r2
   30758:	e0822003 	add	r2, r2, r3
   3075c:	e24b405c 	sub	r4, fp, #92	; 0x5c
   30760:	e8940018 	ldm	r4, {r3, r4}
   30764:	e8820018 	stm	r2, {r3, r4}
		for (i=jz;i>0;i--) {
		    fw      = fq[i-1]+fq[i]; 
		    fq[i]  += fq[i-1]-fw;
		    fq[i-1] = fw;
		}
		for (i=jz;i>1;i--) {
   30768:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   3076c:	e2433001 	sub	r3, r3, #1
   30770:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   30774:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   30778:	e3530001 	cmp	r3, #1
   3077c:	caffffb3 	bgt	30650 <__kernel_rem_pio2+0x1188>
		    fw      = fq[i-1]+fq[i]; 
		    fq[i]  += fq[i-1]-fw;
		    fq[i-1] = fw;
		}
		for (fw=0.0,i=jz;i>=2;i--) fw += fq[i]; 
   30780:	e3a03000 	mov	r3, #0
   30784:	e3a04000 	mov	r4, #0
   30788:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   3078c:	e50b4058 	str	r4, [fp, #-88]	; 0x58
   30790:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   30794:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   30798:	ea000012 	b	307e8 <__kernel_rem_pio2+0x1320>
   3079c:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   307a0:	e51f3334 	ldr	r3, [pc, #-820]	; 30474 <__kernel_rem_pio2+0xfac>
   307a4:	e1a02182 	lsl	r2, r2, #3
   307a8:	e24b1024 	sub	r1, fp, #36	; 0x24
   307ac:	e0812002 	add	r2, r1, r2
   307b0:	e0823003 	add	r3, r2, r3
   307b4:	e8930018 	ldm	r3, {r3, r4}
   307b8:	e24b105c 	sub	r1, fp, #92	; 0x5c
   307bc:	e8910003 	ldm	r1, {r0, r1}
   307c0:	e1a02003 	mov	r2, r3
   307c4:	e1a03004 	mov	r3, r4
   307c8:	ebff8fc8 	bl	146f0 <__adddf3>
   307cc:	e1a03000 	mov	r3, r0
   307d0:	e1a04001 	mov	r4, r1
   307d4:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   307d8:	e50b4058 	str	r4, [fp, #-88]	; 0x58
   307dc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   307e0:	e2433001 	sub	r3, r3, #1
   307e4:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   307e8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   307ec:	e3530001 	cmp	r3, #1
   307f0:	caffffe9 	bgt	3079c <__kernel_rem_pio2+0x12d4>
		if(ih==0) {
   307f4:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   307f8:	e3530000 	cmp	r3, #0
   307fc:	1a00000e 	bne	3083c <__kernel_rem_pio2+0x1374>
		    y[0] =  fq[0]; y[1] =  fq[1]; y[2] =  fw;
   30800:	e24b4f7f 	sub	r4, fp, #508	; 0x1fc
   30804:	e8940018 	ldm	r4, {r3, r4}
   30808:	e51b22a4 	ldr	r2, [fp, #-676]	; 0x2a4
   3080c:	e8820018 	stm	r2, {r3, r4}
   30810:	e51b32a4 	ldr	r3, [fp, #-676]	; 0x2a4
   30814:	e2832008 	add	r2, r3, #8
   30818:	e24b4f7d 	sub	r4, fp, #500	; 0x1f4
   3081c:	e8940018 	ldm	r4, {r3, r4}
   30820:	e8820018 	stm	r2, {r3, r4}
   30824:	e51b32a4 	ldr	r3, [fp, #-676]	; 0x2a4
   30828:	e2832010 	add	r2, r3, #16
   3082c:	e24b405c 	sub	r4, fp, #92	; 0x5c
   30830:	e8940018 	ldm	r4, {r3, r4}
   30834:	e8820018 	stm	r2, {r3, r4}
   30838:	ea00001c 	b	308b0 <__kernel_rem_pio2+0x13e8>
		} else {
		    y[0] = -fq[0]; y[1] = -fq[1]; y[2] = -fw;
   3083c:	e24b4f7f 	sub	r4, fp, #508	; 0x1fc
   30840:	e8940018 	ldm	r4, {r3, r4}
   30844:	e50b32b4 	str	r3, [fp, #-692]	; 0x2b4
   30848:	e2242102 	eor	r2, r4, #-2147483648	; 0x80000000
   3084c:	e50b22b0 	str	r2, [fp, #-688]	; 0x2b0
   30850:	e51b32a4 	ldr	r3, [fp, #-676]	; 0x2a4
   30854:	e24b1fad 	sub	r1, fp, #692	; 0x2b4
   30858:	e8910003 	ldm	r1, {r0, r1}
   3085c:	e8830003 	stm	r3, {r0, r1}
   30860:	e51b32a4 	ldr	r3, [fp, #-676]	; 0x2a4
   30864:	e2832008 	add	r2, r3, #8
   30868:	e24b4f7d 	sub	r4, fp, #500	; 0x1f4
   3086c:	e8940018 	ldm	r4, {r3, r4}
   30870:	e50b32bc 	str	r3, [fp, #-700]	; 0x2bc
   30874:	e2241102 	eor	r1, r4, #-2147483648	; 0x80000000
   30878:	e50b12b8 	str	r1, [fp, #-696]	; 0x2b8
   3087c:	e24b4faf 	sub	r4, fp, #700	; 0x2bc
   30880:	e8940018 	ldm	r4, {r3, r4}
   30884:	e8820018 	stm	r2, {r3, r4}
   30888:	e51b32a4 	ldr	r3, [fp, #-676]	; 0x2a4
   3088c:	e2833010 	add	r3, r3, #16
   30890:	e51b405c 	ldr	r4, [fp, #-92]	; 0x5c
   30894:	e50b42c4 	str	r4, [fp, #-708]	; 0x2c4
   30898:	e51b2058 	ldr	r2, [fp, #-88]	; 0x58
   3089c:	e2222102 	eor	r2, r2, #-2147483648	; 0x80000000
   308a0:	e50b22c0 	str	r2, [fp, #-704]	; 0x2c0
   308a4:	e24b1fb1 	sub	r1, fp, #708	; 0x2c4
   308a8:	e8910003 	ldm	r1, {r0, r1}
   308ac:	e8830003 	stm	r3, {r0, r1}
		}
	}
	return n&7;
   308b0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   308b4:	e2033007 	and	r3, r3, #7
}
   308b8:	e1a00003 	mov	r0, r3
   308bc:	e24bd020 	sub	sp, fp, #32
   308c0:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   308c4:	e12fff1e 	bx	lr

000308c8 <__kernel_sin>:
	double __kernel_sin(double x, double y, int iy)
#else
	double __kernel_sin(x, y, iy)
	double x,y; int iy;		/* iy=0 if y is zero */
#endif
{
   308c8:	e92d4870 	push	{r4, r5, r6, fp, lr}
   308cc:	e28db010 	add	fp, sp, #16
   308d0:	e24dd03c 	sub	sp, sp, #60	; 0x3c
   308d4:	e50b0044 	str	r0, [fp, #-68]	; 0x44
   308d8:	e50b1040 	str	r1, [fp, #-64]	; 0x40
   308dc:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   308e0:	e50b3048 	str	r3, [fp, #-72]	; 0x48
	double z,r,v;
	__int32_t ix;
	GET_HIGH_WORD(ix,x);
   308e4:	e24b4044 	sub	r4, fp, #68	; 0x44
   308e8:	e8940018 	ldm	r4, {r3, r4}
   308ec:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   308f0:	e50b4038 	str	r4, [fp, #-56]	; 0x38
   308f4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   308f8:	e50b3018 	str	r3, [fp, #-24]
	ix &= 0x7fffffff;			/* high word of x */
   308fc:	e51b3018 	ldr	r3, [fp, #-24]
   30900:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   30904:	e50b3018 	str	r3, [fp, #-24]
	if(ix<0x3e400000)			/* |x| < 2**-27 */
   30908:	e51b3018 	ldr	r3, [fp, #-24]
   3090c:	e35305f9 	cmp	r3, #1044381696	; 0x3e400000
   30910:	aa000008 	bge	30938 <__kernel_sin+0x70>
	   {if((int)x==0) return x;}		/* generate inexact */
   30914:	e24b1044 	sub	r1, fp, #68	; 0x44
   30918:	e8910003 	ldm	r1, {r0, r1}
   3091c:	ebff91ef 	bl	150e0 <__aeabi_d2iz>
   30920:	e1a03000 	mov	r3, r0
   30924:	e3530000 	cmp	r3, #0
   30928:	1a000002 	bne	30938 <__kernel_sin+0x70>
   3092c:	e24b4044 	sub	r4, fp, #68	; 0x44
   30930:	e8940018 	ldm	r4, {r3, r4}
   30934:	ea0000c1 	b	30c40 <__kernel_sin+0x378>
	z	=  x*x;
   30938:	e24b1044 	sub	r1, fp, #68	; 0x44
   3093c:	e8910003 	ldm	r1, {r0, r1}
   30940:	e24b3044 	sub	r3, fp, #68	; 0x44
   30944:	e893000c 	ldm	r3, {r2, r3}
   30948:	ebff906c 	bl	14b00 <__aeabi_dmul>
   3094c:	e1a03000 	mov	r3, r0
   30950:	e1a04001 	mov	r4, r1
   30954:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   30958:	e50b4020 	str	r4, [fp, #-32]
	v	=  z*x;
   3095c:	e24b1024 	sub	r1, fp, #36	; 0x24
   30960:	e8910003 	ldm	r1, {r0, r1}
   30964:	e24b3044 	sub	r3, fp, #68	; 0x44
   30968:	e893000c 	ldm	r3, {r2, r3}
   3096c:	ebff9063 	bl	14b00 <__aeabi_dmul>
   30970:	e1a03000 	mov	r3, r0
   30974:	e1a04001 	mov	r4, r1
   30978:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   3097c:	e50b4028 	str	r4, [fp, #-40]	; 0x28
	r	=  S2+z*(S3+z*(S4+z*(S5+z*S6)));
   30980:	e28f4e2d 	add	r4, pc, #720	; 0x2d0
   30984:	e8940018 	ldm	r4, {r3, r4}
   30988:	e1a00003 	mov	r0, r3
   3098c:	e1a01004 	mov	r1, r4
   30990:	e24b3024 	sub	r3, fp, #36	; 0x24
   30994:	e893000c 	ldm	r3, {r2, r3}
   30998:	ebff9058 	bl	14b00 <__aeabi_dmul>
   3099c:	e1a03000 	mov	r3, r0
   309a0:	e1a04001 	mov	r4, r1
   309a4:	e1a01003 	mov	r1, r3
   309a8:	e1a02004 	mov	r2, r4
   309ac:	e28f4fab 	add	r4, pc, #684	; 0x2ac
   309b0:	e8940018 	ldm	r4, {r3, r4}
   309b4:	e1a00001 	mov	r0, r1
   309b8:	e1a01002 	mov	r1, r2
   309bc:	e1a02003 	mov	r2, r3
   309c0:	e1a03004 	mov	r3, r4
   309c4:	ebff8f49 	bl	146f0 <__adddf3>
   309c8:	e1a03000 	mov	r3, r0
   309cc:	e1a04001 	mov	r4, r1
   309d0:	e1a00003 	mov	r0, r3
   309d4:	e1a01004 	mov	r1, r4
   309d8:	e24b3024 	sub	r3, fp, #36	; 0x24
   309dc:	e893000c 	ldm	r3, {r2, r3}
   309e0:	ebff9046 	bl	14b00 <__aeabi_dmul>
   309e4:	e1a03000 	mov	r3, r0
   309e8:	e1a04001 	mov	r4, r1
   309ec:	e1a01003 	mov	r1, r3
   309f0:	e1a02004 	mov	r2, r4
   309f4:	e28f4f9b 	add	r4, pc, #620	; 0x26c
   309f8:	e8940018 	ldm	r4, {r3, r4}
   309fc:	e1a00001 	mov	r0, r1
   30a00:	e1a01002 	mov	r1, r2
   30a04:	e1a02003 	mov	r2, r3
   30a08:	e1a03004 	mov	r3, r4
   30a0c:	ebff8f37 	bl	146f0 <__adddf3>
   30a10:	e1a03000 	mov	r3, r0
   30a14:	e1a04001 	mov	r4, r1
   30a18:	e1a00003 	mov	r0, r3
   30a1c:	e1a01004 	mov	r1, r4
   30a20:	e24b3024 	sub	r3, fp, #36	; 0x24
   30a24:	e893000c 	ldm	r3, {r2, r3}
   30a28:	ebff9034 	bl	14b00 <__aeabi_dmul>
   30a2c:	e1a03000 	mov	r3, r0
   30a30:	e1a04001 	mov	r4, r1
   30a34:	e1a01003 	mov	r1, r3
   30a38:	e1a02004 	mov	r2, r4
   30a3c:	e28f4f8b 	add	r4, pc, #556	; 0x22c
   30a40:	e8940018 	ldm	r4, {r3, r4}
   30a44:	e1a00001 	mov	r0, r1
   30a48:	e1a01002 	mov	r1, r2
   30a4c:	e1a02003 	mov	r2, r3
   30a50:	e1a03004 	mov	r3, r4
   30a54:	ebff8f25 	bl	146f0 <__adddf3>
   30a58:	e1a03000 	mov	r3, r0
   30a5c:	e1a04001 	mov	r4, r1
   30a60:	e1a00003 	mov	r0, r3
   30a64:	e1a01004 	mov	r1, r4
   30a68:	e24b3024 	sub	r3, fp, #36	; 0x24
   30a6c:	e893000c 	ldm	r3, {r2, r3}
   30a70:	ebff9022 	bl	14b00 <__aeabi_dmul>
   30a74:	e1a03000 	mov	r3, r0
   30a78:	e1a04001 	mov	r4, r1
   30a7c:	e1a01003 	mov	r1, r3
   30a80:	e1a02004 	mov	r2, r4
   30a84:	e28f4f7b 	add	r4, pc, #492	; 0x1ec
   30a88:	e8940018 	ldm	r4, {r3, r4}
   30a8c:	e1a00001 	mov	r0, r1
   30a90:	e1a01002 	mov	r1, r2
   30a94:	e1a02003 	mov	r2, r3
   30a98:	e1a03004 	mov	r3, r4
   30a9c:	ebff8f13 	bl	146f0 <__adddf3>
   30aa0:	e1a03000 	mov	r3, r0
   30aa4:	e1a04001 	mov	r4, r1
   30aa8:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   30aac:	e50b4030 	str	r4, [fp, #-48]	; 0x30
	if(iy==0) return x+v*(S1+z*r);
   30ab0:	e59b3004 	ldr	r3, [fp, #4]
   30ab4:	e3530000 	cmp	r3, #0
   30ab8:	1a000020 	bne	30b40 <__kernel_sin+0x278>
   30abc:	e24b1024 	sub	r1, fp, #36	; 0x24
   30ac0:	e8910003 	ldm	r1, {r0, r1}
   30ac4:	e24b3034 	sub	r3, fp, #52	; 0x34
   30ac8:	e893000c 	ldm	r3, {r2, r3}
   30acc:	ebff900b 	bl	14b00 <__aeabi_dmul>
   30ad0:	e1a03000 	mov	r3, r0
   30ad4:	e1a04001 	mov	r4, r1
   30ad8:	e1a01003 	mov	r1, r3
   30adc:	e1a02004 	mov	r2, r4
   30ae0:	e28f4f66 	add	r4, pc, #408	; 0x198
   30ae4:	e8940018 	ldm	r4, {r3, r4}
   30ae8:	e1a00001 	mov	r0, r1
   30aec:	e1a01002 	mov	r1, r2
   30af0:	e1a02003 	mov	r2, r3
   30af4:	e1a03004 	mov	r3, r4
   30af8:	ebff8efc 	bl	146f0 <__adddf3>
   30afc:	e1a03000 	mov	r3, r0
   30b00:	e1a04001 	mov	r4, r1
   30b04:	e1a00003 	mov	r0, r3
   30b08:	e1a01004 	mov	r1, r4
   30b0c:	e24b302c 	sub	r3, fp, #44	; 0x2c
   30b10:	e893000c 	ldm	r3, {r2, r3}
   30b14:	ebff8ff9 	bl	14b00 <__aeabi_dmul>
   30b18:	e1a03000 	mov	r3, r0
   30b1c:	e1a04001 	mov	r4, r1
   30b20:	e1a00003 	mov	r0, r3
   30b24:	e1a01004 	mov	r1, r4
   30b28:	e24b3044 	sub	r3, fp, #68	; 0x44
   30b2c:	e893000c 	ldm	r3, {r2, r3}
   30b30:	ebff8eee 	bl	146f0 <__adddf3>
   30b34:	e1a03000 	mov	r3, r0
   30b38:	e1a04001 	mov	r4, r1
   30b3c:	ea00003f 	b	30c40 <__kernel_sin+0x378>
	else      return x-((z*(half*y-v*r)-y)-v*S1);
   30b40:	e3a03000 	mov	r3, #0
   30b44:	e59f413c 	ldr	r4, [pc, #316]	; 30c88 <__kernel_sin+0x3c0>
   30b48:	e1a00003 	mov	r0, r3
   30b4c:	e1a01004 	mov	r1, r4
   30b50:	e24b304c 	sub	r3, fp, #76	; 0x4c
   30b54:	e893000c 	ldm	r3, {r2, r3}
   30b58:	ebff8fe8 	bl	14b00 <__aeabi_dmul>
   30b5c:	e1a03000 	mov	r3, r0
   30b60:	e1a04001 	mov	r4, r1
   30b64:	e1a05003 	mov	r5, r3
   30b68:	e1a06004 	mov	r6, r4
   30b6c:	e24b102c 	sub	r1, fp, #44	; 0x2c
   30b70:	e8910003 	ldm	r1, {r0, r1}
   30b74:	e24b3034 	sub	r3, fp, #52	; 0x34
   30b78:	e893000c 	ldm	r3, {r2, r3}
   30b7c:	ebff8fdf 	bl	14b00 <__aeabi_dmul>
   30b80:	e1a03000 	mov	r3, r0
   30b84:	e1a04001 	mov	r4, r1
   30b88:	e1a00005 	mov	r0, r5
   30b8c:	e1a01006 	mov	r1, r6
   30b90:	e1a02003 	mov	r2, r3
   30b94:	e1a03004 	mov	r3, r4
   30b98:	ebff8ed3 	bl	146ec <__aeabi_dsub>
   30b9c:	e1a03000 	mov	r3, r0
   30ba0:	e1a04001 	mov	r4, r1
   30ba4:	e1a00003 	mov	r0, r3
   30ba8:	e1a01004 	mov	r1, r4
   30bac:	e24b3024 	sub	r3, fp, #36	; 0x24
   30bb0:	e893000c 	ldm	r3, {r2, r3}
   30bb4:	ebff8fd1 	bl	14b00 <__aeabi_dmul>
   30bb8:	e1a03000 	mov	r3, r0
   30bbc:	e1a04001 	mov	r4, r1
   30bc0:	e1a00003 	mov	r0, r3
   30bc4:	e1a01004 	mov	r1, r4
   30bc8:	e24b304c 	sub	r3, fp, #76	; 0x4c
   30bcc:	e893000c 	ldm	r3, {r2, r3}
   30bd0:	ebff8ec5 	bl	146ec <__aeabi_dsub>
   30bd4:	e1a03000 	mov	r3, r0
   30bd8:	e1a04001 	mov	r4, r1
   30bdc:	e1a05003 	mov	r5, r3
   30be0:	e1a06004 	mov	r6, r4
   30be4:	e28f4094 	add	r4, pc, #148	; 0x94
   30be8:	e8940018 	ldm	r4, {r3, r4}
   30bec:	e1a00003 	mov	r0, r3
   30bf0:	e1a01004 	mov	r1, r4
   30bf4:	e24b302c 	sub	r3, fp, #44	; 0x2c
   30bf8:	e893000c 	ldm	r3, {r2, r3}
   30bfc:	ebff8fbf 	bl	14b00 <__aeabi_dmul>
   30c00:	e1a03000 	mov	r3, r0
   30c04:	e1a04001 	mov	r4, r1
   30c08:	e1a00005 	mov	r0, r5
   30c0c:	e1a01006 	mov	r1, r6
   30c10:	e1a02003 	mov	r2, r3
   30c14:	e1a03004 	mov	r3, r4
   30c18:	ebff8eb3 	bl	146ec <__aeabi_dsub>
   30c1c:	e1a03000 	mov	r3, r0
   30c20:	e1a04001 	mov	r4, r1
   30c24:	e24b1044 	sub	r1, fp, #68	; 0x44
   30c28:	e8910003 	ldm	r1, {r0, r1}
   30c2c:	e1a02003 	mov	r2, r3
   30c30:	e1a03004 	mov	r3, r4
   30c34:	ebff8eac 	bl	146ec <__aeabi_dsub>
   30c38:	e1a03000 	mov	r3, r0
   30c3c:	e1a04001 	mov	r4, r1
}
   30c40:	e1a00003 	mov	r0, r3
   30c44:	e1a01004 	mov	r1, r4
   30c48:	e24bd010 	sub	sp, fp, #16
   30c4c:	e8bd4870 	pop	{r4, r5, r6, fp, lr}
   30c50:	e12fff1e 	bx	lr
   30c54:	e1a00000 	nop			; (mov r0, r0)
   30c58:	5acfd57c 	.word	0x5acfd57c
   30c5c:	3de5d93a 	.word	0x3de5d93a
   30c60:	8a2b9ceb 	.word	0x8a2b9ceb
   30c64:	be5ae5e6 	.word	0xbe5ae5e6
   30c68:	57b1fe7d 	.word	0x57b1fe7d
   30c6c:	3ec71de3 	.word	0x3ec71de3
   30c70:	19c161d5 	.word	0x19c161d5
   30c74:	bf2a01a0 	.word	0xbf2a01a0
   30c78:	1110f8a6 	.word	0x1110f8a6
   30c7c:	3f811111 	.word	0x3f811111
   30c80:	55555549 	.word	0x55555549
   30c84:	bfc55555 	.word	0xbfc55555
   30c88:	3fe00000 	.word	0x3fe00000
   30c8c:	e1a00000 	nop			; (mov r0, r0)

00030c90 <fabs>:
	double fabs(double x)
#else
	double fabs(x)
	double x;
#endif
{
   30c90:	e92d0810 	push	{r4, fp}
   30c94:	e28db004 	add	fp, sp, #4
   30c98:	e24dd020 	sub	sp, sp, #32
   30c9c:	e50b0024 	str	r0, [fp, #-36]	; 0x24
   30ca0:	e50b1020 	str	r1, [fp, #-32]
	__uint32_t high;
	GET_HIGH_WORD(high,x);
   30ca4:	e24b4024 	sub	r4, fp, #36	; 0x24
   30ca8:	e8940018 	ldm	r4, {r3, r4}
   30cac:	e50b3014 	str	r3, [fp, #-20]
   30cb0:	e50b4010 	str	r4, [fp, #-16]
   30cb4:	e51b3010 	ldr	r3, [fp, #-16]
   30cb8:	e50b3008 	str	r3, [fp, #-8]
	SET_HIGH_WORD(x,high&0x7fffffff);
   30cbc:	e24b4024 	sub	r4, fp, #36	; 0x24
   30cc0:	e8940018 	ldm	r4, {r3, r4}
   30cc4:	e50b301c 	str	r3, [fp, #-28]
   30cc8:	e50b4018 	str	r4, [fp, #-24]
   30ccc:	e51b3008 	ldr	r3, [fp, #-8]
   30cd0:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   30cd4:	e50b3018 	str	r3, [fp, #-24]
   30cd8:	e24b401c 	sub	r4, fp, #28
   30cdc:	e8940018 	ldm	r4, {r3, r4}
   30ce0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   30ce4:	e50b4020 	str	r4, [fp, #-32]
        return x;
   30ce8:	e24b4024 	sub	r4, fp, #36	; 0x24
   30cec:	e8940018 	ldm	r4, {r3, r4}
}
   30cf0:	e1a00003 	mov	r0, r3
   30cf4:	e1a01004 	mov	r1, r4
   30cf8:	e24bd004 	sub	sp, fp, #4
   30cfc:	e8bd0810 	pop	{r4, fp}
   30d00:	e12fff1e 	bx	lr

00030d04 <finite>:
	int finite(double x)
#else
	int finite(x)
	double x;
#endif
{
   30d04:	e92d0810 	push	{r4, fp}
   30d08:	e28db004 	add	fp, sp, #4
   30d0c:	e24dd018 	sub	sp, sp, #24
   30d10:	e50b001c 	str	r0, [fp, #-28]
   30d14:	e50b1018 	str	r1, [fp, #-24]
	__int32_t hx;
	GET_HIGH_WORD(hx,x);
   30d18:	e24b401c 	sub	r4, fp, #28
   30d1c:	e8940018 	ldm	r4, {r3, r4}
   30d20:	e50b3014 	str	r3, [fp, #-20]
   30d24:	e50b4010 	str	r4, [fp, #-16]
   30d28:	e51b3010 	ldr	r3, [fp, #-16]
   30d2c:	e50b3008 	str	r3, [fp, #-8]
	return  (int)((__uint32_t)((hx&0x7fffffff)-0x7ff00000)>>31);
   30d30:	e51b3008 	ldr	r3, [fp, #-8]
   30d34:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   30d38:	e2833102 	add	r3, r3, #-2147483648	; 0x80000000
   30d3c:	e2833601 	add	r3, r3, #1048576	; 0x100000
   30d40:	e1a03fa3 	lsr	r3, r3, #31
}
   30d44:	e1a00003 	mov	r0, r3
   30d48:	e24bd004 	sub	sp, fp, #4
   30d4c:	e8bd0810 	pop	{r4, fp}
   30d50:	e12fff1e 	bx	lr
   30d54:	00000000 	andeq	r0, r0, r0

00030d58 <floor>:
	double floor(double x)
#else
	double floor(x)
	double x;
#endif
{
   30d58:	e92d4810 	push	{r4, fp, lr}
   30d5c:	e28db008 	add	fp, sp, #8
   30d60:	e24dd034 	sub	sp, sp, #52	; 0x34
   30d64:	e50b003c 	str	r0, [fp, #-60]	; 0x3c
   30d68:	e50b1038 	str	r1, [fp, #-56]	; 0x38
	__int32_t i0,i1,j0;
	__uint32_t i,j;
	EXTRACT_WORDS(i0,i1,x);
   30d6c:	e24b403c 	sub	r4, fp, #60	; 0x3c
   30d70:	e8940018 	ldm	r4, {r3, r4}
   30d74:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   30d78:	e50b4028 	str	r4, [fp, #-40]	; 0x28
   30d7c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   30d80:	e50b3010 	str	r3, [fp, #-16]
   30d84:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   30d88:	e50b3014 	str	r3, [fp, #-20]
	j0 = ((i0>>20)&0x7ff)-0x3ff;
   30d8c:	e51b3010 	ldr	r3, [fp, #-16]
   30d90:	e1a03a43 	asr	r3, r3, #20
   30d94:	e1a03a83 	lsl	r3, r3, #21
   30d98:	e1a03aa3 	lsr	r3, r3, #21
   30d9c:	e2433fff 	sub	r3, r3, #1020	; 0x3fc
   30da0:	e2433003 	sub	r3, r3, #3
   30da4:	e50b3018 	str	r3, [fp, #-24]
	if(j0<20) {
   30da8:	e51b3018 	ldr	r3, [fp, #-24]
   30dac:	e3530013 	cmp	r3, #19
   30db0:	ca000058 	bgt	30f18 <floor+0x1c0>
	    if(j0<0) { 	/* raise inexact if x != 0 */
   30db4:	e51b3018 	ldr	r3, [fp, #-24]
   30db8:	e3530000 	cmp	r3, #0
   30dbc:	aa000024 	bge	30e54 <floor+0xfc>
		if(huge+x>0.0) {/* return 0*sign(x) if |x|<1 */
   30dc0:	e28f4e2d 	add	r4, pc, #720	; 0x2d0
   30dc4:	e8940018 	ldm	r4, {r3, r4}
   30dc8:	e1a00003 	mov	r0, r3
   30dcc:	e1a01004 	mov	r1, r4
   30dd0:	e24b303c 	sub	r3, fp, #60	; 0x3c
   30dd4:	e893000c 	ldm	r3, {r2, r3}
   30dd8:	ebff8e44 	bl	146f0 <__adddf3>
   30ddc:	e1a03000 	mov	r3, r0
   30de0:	e1a04001 	mov	r4, r1
   30de4:	e1a00003 	mov	r0, r3
   30de8:	e1a01004 	mov	r1, r4
   30dec:	e3a02000 	mov	r2, #0
   30df0:	e3a03000 	mov	r3, #0
   30df4:	ebff90b3 	bl	150c8 <__aeabi_dcmpgt>
   30df8:	e1a03000 	mov	r3, r0
   30dfc:	e3530000 	cmp	r3, #0
   30e00:	1a000000 	bne	30e08 <floor+0xb0>
   30e04:	ea000093 	b	31058 <floor+0x300>
		    if(i0>=0) {i0=i1=0;} 
   30e08:	e51b3010 	ldr	r3, [fp, #-16]
   30e0c:	e3530000 	cmp	r3, #0
   30e10:	ba000004 	blt	30e28 <floor+0xd0>
   30e14:	e3a03000 	mov	r3, #0
   30e18:	e50b3014 	str	r3, [fp, #-20]
   30e1c:	e51b3014 	ldr	r3, [fp, #-20]
   30e20:	e50b3010 	str	r3, [fp, #-16]
   30e24:	ea00008b 	b	31058 <floor+0x300>
		    else if(((i0&0x7fffffff)|i1)!=0)
   30e28:	e51b3010 	ldr	r3, [fp, #-16]
   30e2c:	e3c32102 	bic	r2, r3, #-2147483648	; 0x80000000
   30e30:	e51b3014 	ldr	r3, [fp, #-20]
   30e34:	e1823003 	orr	r3, r2, r3
   30e38:	e3530000 	cmp	r3, #0
   30e3c:	0a000085 	beq	31058 <floor+0x300>
			{ i0=0xbff00000;i1=0;}
   30e40:	e59f3258 	ldr	r3, [pc, #600]	; 310a0 <floor+0x348>
   30e44:	e50b3010 	str	r3, [fp, #-16]
   30e48:	e3a03000 	mov	r3, #0
   30e4c:	e50b3014 	str	r3, [fp, #-20]
   30e50:	ea000080 	b	31058 <floor+0x300>
		}
	    } else {
		i = (0x000fffff)>>j0;
   30e54:	e59f2248 	ldr	r2, [pc, #584]	; 310a4 <floor+0x34c>
   30e58:	e51b3018 	ldr	r3, [fp, #-24]
   30e5c:	e1a03352 	asr	r3, r2, r3
   30e60:	e50b301c 	str	r3, [fp, #-28]
		if(((i0&i)|i1)==0) return x; /* x is integral */
   30e64:	e51b2010 	ldr	r2, [fp, #-16]
   30e68:	e51b301c 	ldr	r3, [fp, #-28]
   30e6c:	e0022003 	and	r2, r2, r3
   30e70:	e51b3014 	ldr	r3, [fp, #-20]
   30e74:	e1823003 	orr	r3, r2, r3
   30e78:	e3530000 	cmp	r3, #0
   30e7c:	1a000002 	bne	30e8c <floor+0x134>
   30e80:	e24b403c 	sub	r4, fp, #60	; 0x3c
   30e84:	e8940018 	ldm	r4, {r3, r4}
   30e88:	ea00007c 	b	31080 <floor+0x328>
		if(huge+x>0.0) {	/* raise inexact flag */
   30e8c:	e28f4f81 	add	r4, pc, #516	; 0x204
   30e90:	e8940018 	ldm	r4, {r3, r4}
   30e94:	e1a00003 	mov	r0, r3
   30e98:	e1a01004 	mov	r1, r4
   30e9c:	e24b303c 	sub	r3, fp, #60	; 0x3c
   30ea0:	e893000c 	ldm	r3, {r2, r3}
   30ea4:	ebff8e11 	bl	146f0 <__adddf3>
   30ea8:	e1a03000 	mov	r3, r0
   30eac:	e1a04001 	mov	r4, r1
   30eb0:	e1a00003 	mov	r0, r3
   30eb4:	e1a01004 	mov	r1, r4
   30eb8:	e3a02000 	mov	r2, #0
   30ebc:	e3a03000 	mov	r3, #0
   30ec0:	ebff9080 	bl	150c8 <__aeabi_dcmpgt>
   30ec4:	e1a03000 	mov	r3, r0
   30ec8:	e3530000 	cmp	r3, #0
   30ecc:	1a000000 	bne	30ed4 <floor+0x17c>
   30ed0:	ea000060 	b	31058 <floor+0x300>
		    if(i0<0) i0 += (0x00100000)>>j0;
   30ed4:	e51b3010 	ldr	r3, [fp, #-16]
   30ed8:	e3530000 	cmp	r3, #0
   30edc:	aa000005 	bge	30ef8 <floor+0x1a0>
   30ee0:	e3a02601 	mov	r2, #1048576	; 0x100000
   30ee4:	e51b3018 	ldr	r3, [fp, #-24]
   30ee8:	e1a03352 	asr	r3, r2, r3
   30eec:	e51b2010 	ldr	r2, [fp, #-16]
   30ef0:	e0823003 	add	r3, r2, r3
   30ef4:	e50b3010 	str	r3, [fp, #-16]
		    i0 &= (~i); i1=0;
   30ef8:	e51b301c 	ldr	r3, [fp, #-28]
   30efc:	e1e02003 	mvn	r2, r3
   30f00:	e51b3010 	ldr	r3, [fp, #-16]
   30f04:	e0033002 	and	r3, r3, r2
   30f08:	e50b3010 	str	r3, [fp, #-16]
   30f0c:	e3a03000 	mov	r3, #0
   30f10:	e50b3014 	str	r3, [fp, #-20]
   30f14:	ea00004f 	b	31058 <floor+0x300>
		}
	    }
	} else if (j0>51) {
   30f18:	e51b3018 	ldr	r3, [fp, #-24]
   30f1c:	e3530033 	cmp	r3, #51	; 0x33
   30f20:	da00000f 	ble	30f64 <floor+0x20c>
	    if(j0==0x400) return x+x;	/* inf or NaN */
   30f24:	e51b3018 	ldr	r3, [fp, #-24]
   30f28:	e3530b01 	cmp	r3, #1024	; 0x400
   30f2c:	1a000009 	bne	30f58 <floor+0x200>
   30f30:	e24b403c 	sub	r4, fp, #60	; 0x3c
   30f34:	e8940018 	ldm	r4, {r3, r4}
   30f38:	e1a00003 	mov	r0, r3
   30f3c:	e1a01004 	mov	r1, r4
   30f40:	e1a02003 	mov	r2, r3
   30f44:	e1a03004 	mov	r3, r4
   30f48:	ebff8de8 	bl	146f0 <__adddf3>
   30f4c:	e1a03000 	mov	r3, r0
   30f50:	e1a04001 	mov	r4, r1
   30f54:	ea000049 	b	31080 <floor+0x328>
	    else return x;		/* x is integral */
   30f58:	e24b403c 	sub	r4, fp, #60	; 0x3c
   30f5c:	e8940018 	ldm	r4, {r3, r4}
   30f60:	ea000046 	b	31080 <floor+0x328>
	} else {
	    i = ((__uint32_t)(0xffffffff))>>(j0-20);
   30f64:	e51b3018 	ldr	r3, [fp, #-24]
   30f68:	e2433014 	sub	r3, r3, #20
   30f6c:	e3e02000 	mvn	r2, #0
   30f70:	e1a03332 	lsr	r3, r2, r3
   30f74:	e50b301c 	str	r3, [fp, #-28]
	    if((i1&i)==0) return x;	/* x is integral */
   30f78:	e51b2014 	ldr	r2, [fp, #-20]
   30f7c:	e51b301c 	ldr	r3, [fp, #-28]
   30f80:	e0033002 	and	r3, r3, r2
   30f84:	e3530000 	cmp	r3, #0
   30f88:	1a000002 	bne	30f98 <floor+0x240>
   30f8c:	e24b403c 	sub	r4, fp, #60	; 0x3c
   30f90:	e8940018 	ldm	r4, {r3, r4}
   30f94:	ea000039 	b	31080 <floor+0x328>
	    if(huge+x>0.0) { 		/* raise inexact flag */
   30f98:	e28f40f8 	add	r4, pc, #248	; 0xf8
   30f9c:	e8940018 	ldm	r4, {r3, r4}
   30fa0:	e1a00003 	mov	r0, r3
   30fa4:	e1a01004 	mov	r1, r4
   30fa8:	e24b303c 	sub	r3, fp, #60	; 0x3c
   30fac:	e893000c 	ldm	r3, {r2, r3}
   30fb0:	ebff8dce 	bl	146f0 <__adddf3>
   30fb4:	e1a03000 	mov	r3, r0
   30fb8:	e1a04001 	mov	r4, r1
   30fbc:	e1a00003 	mov	r0, r3
   30fc0:	e1a01004 	mov	r1, r4
   30fc4:	e3a02000 	mov	r2, #0
   30fc8:	e3a03000 	mov	r3, #0
   30fcc:	ebff903d 	bl	150c8 <__aeabi_dcmpgt>
   30fd0:	e1a03000 	mov	r3, r0
   30fd4:	e3530000 	cmp	r3, #0
   30fd8:	0a00001e 	beq	31058 <floor+0x300>
		if(i0<0) {
   30fdc:	e51b3010 	ldr	r3, [fp, #-16]
   30fe0:	e3530000 	cmp	r3, #0
   30fe4:	aa000016 	bge	31044 <floor+0x2ec>
		    if(j0==20) i0+=1; 
   30fe8:	e51b3018 	ldr	r3, [fp, #-24]
   30fec:	e3530014 	cmp	r3, #20
   30ff0:	1a000003 	bne	31004 <floor+0x2ac>
   30ff4:	e51b3010 	ldr	r3, [fp, #-16]
   30ff8:	e2833001 	add	r3, r3, #1
   30ffc:	e50b3010 	str	r3, [fp, #-16]
   31000:	ea00000f 	b	31044 <floor+0x2ec>
		    else {
			j = i1+(1<<(52-j0));
   31004:	e51b3018 	ldr	r3, [fp, #-24]
   31008:	e2633034 	rsb	r3, r3, #52	; 0x34
   3100c:	e3a02001 	mov	r2, #1
   31010:	e1a02312 	lsl	r2, r2, r3
   31014:	e51b3014 	ldr	r3, [fp, #-20]
   31018:	e0823003 	add	r3, r2, r3
   3101c:	e50b3020 	str	r3, [fp, #-32]
			if(j<i1) i0 +=1 ; 	/* got a carry */
   31020:	e51b2014 	ldr	r2, [fp, #-20]
   31024:	e51b3020 	ldr	r3, [fp, #-32]
   31028:	e1520003 	cmp	r2, r3
   3102c:	9a000002 	bls	3103c <floor+0x2e4>
   31030:	e51b3010 	ldr	r3, [fp, #-16]
   31034:	e2833001 	add	r3, r3, #1
   31038:	e50b3010 	str	r3, [fp, #-16]
			i1=j;
   3103c:	e51b3020 	ldr	r3, [fp, #-32]
   31040:	e50b3014 	str	r3, [fp, #-20]
		    }
		}
		i1 &= (~i);
   31044:	e51b301c 	ldr	r3, [fp, #-28]
   31048:	e1e02003 	mvn	r2, r3
   3104c:	e51b3014 	ldr	r3, [fp, #-20]
   31050:	e0033002 	and	r3, r3, r2
   31054:	e50b3014 	str	r3, [fp, #-20]
	    }
	}
	INSERT_WORDS(x,i0,i1);
   31058:	e51b3010 	ldr	r3, [fp, #-16]
   3105c:	e50b3030 	str	r3, [fp, #-48]	; 0x30
   31060:	e51b3014 	ldr	r3, [fp, #-20]
   31064:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   31068:	e24b4034 	sub	r4, fp, #52	; 0x34
   3106c:	e8940018 	ldm	r4, {r3, r4}
   31070:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   31074:	e50b4038 	str	r4, [fp, #-56]	; 0x38
	return x;
   31078:	e24b403c 	sub	r4, fp, #60	; 0x3c
   3107c:	e8940018 	ldm	r4, {r3, r4}
}
   31080:	e1a00003 	mov	r0, r3
   31084:	e1a01004 	mov	r1, r4
   31088:	e24bd008 	sub	sp, fp, #8
   3108c:	e8bd4810 	pop	{r4, fp, lr}
   31090:	e12fff1e 	bx	lr
   31094:	e1a00000 	nop			; (mov r0, r0)
   31098:	8800759c 	.word	0x8800759c
   3109c:	7e37e43c 	.word	0x7e37e43c
   310a0:	bff00000 	.word	0xbff00000
   310a4:	000fffff 	.word	0x000fffff

000310a8 <matherr>:
	int matherr(struct exception *x)
#else
	int matherr(x)
	struct exception *x;
#endif
{
   310a8:	e92d4810 	push	{r4, fp, lr}
   310ac:	e28db008 	add	fp, sp, #8
   310b0:	e24dd014 	sub	sp, sp, #20
   310b4:	e50b0018 	str	r0, [fp, #-24]
	int n=0;
   310b8:	e3a03000 	mov	r3, #0
   310bc:	e50b3010 	str	r3, [fp, #-16]
	if(x->arg1!=x->arg1) return 0;
   310c0:	e51b3018 	ldr	r3, [fp, #-24]
   310c4:	e2832008 	add	r2, r3, #8
   310c8:	e8920006 	ldm	r2, {r1, r2}
   310cc:	e51b3018 	ldr	r3, [fp, #-24]
   310d0:	e2834008 	add	r4, r3, #8
   310d4:	e8940018 	ldm	r4, {r3, r4}
   310d8:	e1a00001 	mov	r0, r1
   310dc:	e1a01002 	mov	r1, r2
   310e0:	e1a02003 	mov	r2, r3
   310e4:	e1a03004 	mov	r3, r4
   310e8:	ebff8fde 	bl	15068 <__aeabi_dcmpeq>
   310ec:	e1a03000 	mov	r3, r0
   310f0:	e3530000 	cmp	r3, #0
   310f4:	1a000001 	bne	31100 <matherr+0x58>
   310f8:	e3a03000 	mov	r3, #0
   310fc:	ea000000 	b	31104 <matherr+0x5c>
	return n;
   31100:	e51b3010 	ldr	r3, [fp, #-16]
}
   31104:	e1a00003 	mov	r0, r3
   31108:	e24bd008 	sub	sp, fp, #8
   3110c:	e8bd4810 	pop	{r4, fp, lr}
   31110:	e12fff1e 	bx	lr

00031114 <nan>:
#include "fdlibm.h"

#ifndef _DOUBLE_IS_32BITS

	double nan(const char *unused)
{
   31114:	e92d0810 	push	{r4, fp}
   31118:	e28db004 	add	fp, sp, #4
   3111c:	e24dd018 	sub	sp, sp, #24
   31120:	e50b0018 	str	r0, [fp, #-24]
	double x;

	INSERT_WORDS(x,0x7ff80000,0);
   31124:	e59f3034 	ldr	r3, [pc, #52]	; 31160 <nan+0x4c>
   31128:	e50b3010 	str	r3, [fp, #-16]
   3112c:	e3a03000 	mov	r3, #0
   31130:	e50b3014 	str	r3, [fp, #-20]
   31134:	e24b4014 	sub	r4, fp, #20
   31138:	e8940018 	ldm	r4, {r3, r4}
   3113c:	e50b300c 	str	r3, [fp, #-12]
   31140:	e50b4008 	str	r4, [fp, #-8]
	return x;
   31144:	e24b400c 	sub	r4, fp, #12
   31148:	e8940018 	ldm	r4, {r3, r4}
}
   3114c:	e1a00003 	mov	r0, r3
   31150:	e1a01004 	mov	r1, r4
   31154:	e24bd004 	sub	sp, fp, #4
   31158:	e8bd0810 	pop	{r4, fp}
   3115c:	e12fff1e 	bx	lr
   31160:	7ff80000 	.word	0x7ff80000

00031164 <rint>:
	double rint(double x)
#else
	double rint(x)
	double x;
#endif
{
   31164:	e92d4810 	push	{r4, fp, lr}
   31168:	e28db008 	add	fp, sp, #8
   3116c:	e24dd05c 	sub	sp, sp, #92	; 0x5c
   31170:	e50b0064 	str	r0, [fp, #-100]	; 0x64
   31174:	e50b1060 	str	r1, [fp, #-96]	; 0x60
	__int32_t i0,j0,sx;
	__uint32_t i,i1;
	double t;
	volatile double w;
	EXTRACT_WORDS(i0,i1,x);
   31178:	e24b4064 	sub	r4, fp, #100	; 0x64
   3117c:	e8940018 	ldm	r4, {r3, r4}
   31180:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   31184:	e50b4038 	str	r4, [fp, #-56]	; 0x38
   31188:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   3118c:	e50b3010 	str	r3, [fp, #-16]
   31190:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   31194:	e50b3014 	str	r3, [fp, #-20]
	sx = (i0>>31)&1;		/* sign */
   31198:	e51b3010 	ldr	r3, [fp, #-16]
   3119c:	e1a03fa3 	lsr	r3, r3, #31
   311a0:	e50b3018 	str	r3, [fp, #-24]
	j0 = ((i0>>20)&0x7ff)-0x3ff;	/* exponent */
   311a4:	e51b3010 	ldr	r3, [fp, #-16]
   311a8:	e1a03a43 	asr	r3, r3, #20
   311ac:	e1a03a83 	lsl	r3, r3, #21
   311b0:	e1a03aa3 	lsr	r3, r3, #21
   311b4:	e2433fff 	sub	r3, r3, #1020	; 0x3fc
   311b8:	e2433003 	sub	r3, r3, #3
   311bc:	e50b301c 	str	r3, [fp, #-28]
	if(j0<20) {			/* no integral bits in LS part */
   311c0:	e51b301c 	ldr	r3, [fp, #-28]
   311c4:	e3530013 	cmp	r3, #19
   311c8:	ca000087 	bgt	313ec <rint+0x288>
	    if(j0<0) { 			/* x is fractional or 0 */
   311cc:	e51b301c 	ldr	r3, [fp, #-28]
   311d0:	e3530000 	cmp	r3, #0
   311d4:	aa00005a 	bge	31344 <rint+0x1e0>
		if(((i0&0x7fffffff)|i1)==0) return x;	/* x == 0 */
   311d8:	e51b3010 	ldr	r3, [fp, #-16]
   311dc:	e3c32102 	bic	r2, r3, #-2147483648	; 0x80000000
   311e0:	e51b3014 	ldr	r3, [fp, #-20]
   311e4:	e1823003 	orr	r3, r2, r3
   311e8:	e3530000 	cmp	r3, #0
   311ec:	1a000002 	bne	311fc <rint+0x98>
   311f0:	e24b4064 	sub	r4, fp, #100	; 0x64
   311f4:	e8940018 	ldm	r4, {r3, r4}
   311f8:	ea0000d1 	b	31544 <rint+0x3e0>
		i1 |= (i0&0x0fffff);
   311fc:	e51b3010 	ldr	r3, [fp, #-16]
   31200:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
   31204:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   31208:	e51b2014 	ldr	r2, [fp, #-20]
   3120c:	e1823003 	orr	r3, r2, r3
   31210:	e50b3014 	str	r3, [fp, #-20]
		i0 &= 0xfffe0000;
   31214:	e51b3010 	ldr	r3, [fp, #-16]
   31218:	e1a038a3 	lsr	r3, r3, #17
   3121c:	e1a03883 	lsl	r3, r3, #17
   31220:	e50b3010 	str	r3, [fp, #-16]
		i0 |= ((i1|-i1)>>12)&0x80000;
   31224:	e51b3014 	ldr	r3, [fp, #-20]
   31228:	e2632000 	rsb	r2, r3, #0
   3122c:	e51b3014 	ldr	r3, [fp, #-20]
   31230:	e1823003 	orr	r3, r2, r3
   31234:	e1a03623 	lsr	r3, r3, #12
   31238:	e2032702 	and	r2, r3, #524288	; 0x80000
   3123c:	e51b3010 	ldr	r3, [fp, #-16]
   31240:	e1823003 	orr	r3, r2, r3
   31244:	e50b3010 	str	r3, [fp, #-16]
		SET_HIGH_WORD(x,i0);
   31248:	e24b4064 	sub	r4, fp, #100	; 0x64
   3124c:	e8940018 	ldm	r4, {r3, r4}
   31250:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   31254:	e50b4040 	str	r4, [fp, #-64]	; 0x40
   31258:	e51b3010 	ldr	r3, [fp, #-16]
   3125c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
   31260:	e24b4044 	sub	r4, fp, #68	; 0x44
   31264:	e8940018 	ldm	r4, {r3, r4}
   31268:	e50b3064 	str	r3, [fp, #-100]	; 0x64
   3126c:	e50b4060 	str	r4, [fp, #-96]	; 0x60
	        w = TWO52[sx]+x;
   31270:	e59f22e0 	ldr	r2, [pc, #736]	; 31558 <rint+0x3f4>
   31274:	e51b3018 	ldr	r3, [fp, #-24]
   31278:	e1a03183 	lsl	r3, r3, #3
   3127c:	e0823003 	add	r3, r2, r3
   31280:	e8930018 	ldm	r3, {r3, r4}
   31284:	e1a00003 	mov	r0, r3
   31288:	e1a01004 	mov	r1, r4
   3128c:	e24b3064 	sub	r3, fp, #100	; 0x64
   31290:	e893000c 	ldm	r3, {r2, r3}
   31294:	ebff8d15 	bl	146f0 <__adddf3>
   31298:	e1a03000 	mov	r3, r0
   3129c:	e1a04001 	mov	r4, r1
   312a0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   312a4:	e50b4030 	str	r4, [fp, #-48]	; 0x30
	        t =  w-TWO52[sx];
   312a8:	e24b2034 	sub	r2, fp, #52	; 0x34
   312ac:	e8920006 	ldm	r2, {r1, r2}
   312b0:	e59f02a0 	ldr	r0, [pc, #672]	; 31558 <rint+0x3f4>
   312b4:	e51b3018 	ldr	r3, [fp, #-24]
   312b8:	e1a03183 	lsl	r3, r3, #3
   312bc:	e0803003 	add	r3, r0, r3
   312c0:	e8930018 	ldm	r3, {r3, r4}
   312c4:	e1a00001 	mov	r0, r1
   312c8:	e1a01002 	mov	r1, r2
   312cc:	e1a02003 	mov	r2, r3
   312d0:	e1a03004 	mov	r3, r4
   312d4:	ebff8d04 	bl	146ec <__aeabi_dsub>
   312d8:	e1a03000 	mov	r3, r0
   312dc:	e1a04001 	mov	r4, r1
   312e0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   312e4:	e50b4020 	str	r4, [fp, #-32]
		GET_HIGH_WORD(i0,t);
   312e8:	e24b4024 	sub	r4, fp, #36	; 0x24
   312ec:	e8940018 	ldm	r4, {r3, r4}
   312f0:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   312f4:	e50b4048 	str	r4, [fp, #-72]	; 0x48
   312f8:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   312fc:	e50b3010 	str	r3, [fp, #-16]
		SET_HIGH_WORD(t,(i0&0x7fffffff)|(sx<<31));
   31300:	e24b4024 	sub	r4, fp, #36	; 0x24
   31304:	e8940018 	ldm	r4, {r3, r4}
   31308:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   3130c:	e50b4050 	str	r4, [fp, #-80]	; 0x50
   31310:	e51b3010 	ldr	r3, [fp, #-16]
   31314:	e3c32102 	bic	r2, r3, #-2147483648	; 0x80000000
   31318:	e51b3018 	ldr	r3, [fp, #-24]
   3131c:	e1a03f83 	lsl	r3, r3, #31
   31320:	e1823003 	orr	r3, r2, r3
   31324:	e50b3050 	str	r3, [fp, #-80]	; 0x50
   31328:	e24b4054 	sub	r4, fp, #84	; 0x54
   3132c:	e8940018 	ldm	r4, {r3, r4}
   31330:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   31334:	e50b4020 	str	r4, [fp, #-32]
	        return t;
   31338:	e24b4024 	sub	r4, fp, #36	; 0x24
   3133c:	e8940018 	ldm	r4, {r3, r4}
   31340:	ea00007f 	b	31544 <rint+0x3e0>
	    } else {			/* x has integer and maybe fraction */
		i = (0x000fffff)>>j0;
   31344:	e59f2210 	ldr	r2, [pc, #528]	; 3155c <rint+0x3f8>
   31348:	e51b301c 	ldr	r3, [fp, #-28]
   3134c:	e1a03352 	asr	r3, r2, r3
   31350:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		if(((i0&i)|i1)==0) return x; /* x is integral */
   31354:	e51b2010 	ldr	r2, [fp, #-16]
   31358:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   3135c:	e0022003 	and	r2, r2, r3
   31360:	e51b3014 	ldr	r3, [fp, #-20]
   31364:	e1823003 	orr	r3, r2, r3
   31368:	e3530000 	cmp	r3, #0
   3136c:	1a000002 	bne	3137c <rint+0x218>
   31370:	e24b4064 	sub	r4, fp, #100	; 0x64
   31374:	e8940018 	ldm	r4, {r3, r4}
   31378:	ea000071 	b	31544 <rint+0x3e0>
		i>>=1;
   3137c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   31380:	e1a030a3 	lsr	r3, r3, #1
   31384:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		if(((i0&i)|i1)!=0) {
   31388:	e51b2010 	ldr	r2, [fp, #-16]
   3138c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   31390:	e0022003 	and	r2, r2, r3
   31394:	e51b3014 	ldr	r3, [fp, #-20]
   31398:	e1823003 	orr	r3, r2, r3
   3139c:	e3530000 	cmp	r3, #0
   313a0:	0a000043 	beq	314b4 <rint+0x350>
		    /* 2nd or any later bit after radix is set */
		    if(j0==19) i1 = 0x80000000; else i1 = 0;
   313a4:	e51b301c 	ldr	r3, [fp, #-28]
   313a8:	e3530013 	cmp	r3, #19
   313ac:	1a000002 	bne	313bc <rint+0x258>
   313b0:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
   313b4:	e50b3014 	str	r3, [fp, #-20]
   313b8:	ea000001 	b	313c4 <rint+0x260>
   313bc:	e3a03000 	mov	r3, #0
   313c0:	e50b3014 	str	r3, [fp, #-20]
		    i0 = (i0&(~i))|((0x40000)>>j0);
   313c4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   313c8:	e1e02003 	mvn	r2, r3
   313cc:	e51b3010 	ldr	r3, [fp, #-16]
   313d0:	e0022003 	and	r2, r2, r3
   313d4:	e3a01701 	mov	r1, #262144	; 0x40000
   313d8:	e51b301c 	ldr	r3, [fp, #-28]
   313dc:	e1a03351 	asr	r3, r1, r3
   313e0:	e1823003 	orr	r3, r2, r3
   313e4:	e50b3010 	str	r3, [fp, #-16]
   313e8:	ea000031 	b	314b4 <rint+0x350>
		}
	    }
	} else if (j0>51) {
   313ec:	e51b301c 	ldr	r3, [fp, #-28]
   313f0:	e3530033 	cmp	r3, #51	; 0x33
   313f4:	da00000f 	ble	31438 <rint+0x2d4>
	    if(j0==0x400) return x+x;	/* inf or NaN */
   313f8:	e51b301c 	ldr	r3, [fp, #-28]
   313fc:	e3530b01 	cmp	r3, #1024	; 0x400
   31400:	1a000009 	bne	3142c <rint+0x2c8>
   31404:	e24b4064 	sub	r4, fp, #100	; 0x64
   31408:	e8940018 	ldm	r4, {r3, r4}
   3140c:	e1a00003 	mov	r0, r3
   31410:	e1a01004 	mov	r1, r4
   31414:	e1a02003 	mov	r2, r3
   31418:	e1a03004 	mov	r3, r4
   3141c:	ebff8cb3 	bl	146f0 <__adddf3>
   31420:	e1a03000 	mov	r3, r0
   31424:	e1a04001 	mov	r4, r1
   31428:	ea000045 	b	31544 <rint+0x3e0>
	    else return x;		/* x is integral */
   3142c:	e24b4064 	sub	r4, fp, #100	; 0x64
   31430:	e8940018 	ldm	r4, {r3, r4}
   31434:	ea000042 	b	31544 <rint+0x3e0>
	} else {
	    i = ((__uint32_t)(0xffffffff))>>(j0-20);
   31438:	e51b301c 	ldr	r3, [fp, #-28]
   3143c:	e2433014 	sub	r3, r3, #20
   31440:	e3e02000 	mvn	r2, #0
   31444:	e1a03332 	lsr	r3, r2, r3
   31448:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	    if((i1&i)==0) return x;	/* x is integral */
   3144c:	e51b2014 	ldr	r2, [fp, #-20]
   31450:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   31454:	e0033002 	and	r3, r3, r2
   31458:	e3530000 	cmp	r3, #0
   3145c:	1a000002 	bne	3146c <rint+0x308>
   31460:	e24b4064 	sub	r4, fp, #100	; 0x64
   31464:	e8940018 	ldm	r4, {r3, r4}
   31468:	ea000035 	b	31544 <rint+0x3e0>
	    i>>=1;
   3146c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   31470:	e1a030a3 	lsr	r3, r3, #1
   31474:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	    if((i1&i)!=0) i1 = (i1&(~i))|((0x40000000)>>(j0-20));
   31478:	e51b2014 	ldr	r2, [fp, #-20]
   3147c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   31480:	e0033002 	and	r3, r3, r2
   31484:	e3530000 	cmp	r3, #0
   31488:	0a000009 	beq	314b4 <rint+0x350>
   3148c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   31490:	e1e02003 	mvn	r2, r3
   31494:	e51b3014 	ldr	r3, [fp, #-20]
   31498:	e0022003 	and	r2, r2, r3
   3149c:	e51b301c 	ldr	r3, [fp, #-28]
   314a0:	e2433014 	sub	r3, r3, #20
   314a4:	e3a01101 	mov	r1, #1073741824	; 0x40000000
   314a8:	e1a03351 	asr	r3, r1, r3
   314ac:	e1823003 	orr	r3, r2, r3
   314b0:	e50b3014 	str	r3, [fp, #-20]
	}
	INSERT_WORDS(x,i0,i1);
   314b4:	e51b3010 	ldr	r3, [fp, #-16]
   314b8:	e50b3058 	str	r3, [fp, #-88]	; 0x58
   314bc:	e51b3014 	ldr	r3, [fp, #-20]
   314c0:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   314c4:	e24b405c 	sub	r4, fp, #92	; 0x5c
   314c8:	e8940018 	ldm	r4, {r3, r4}
   314cc:	e50b3064 	str	r3, [fp, #-100]	; 0x64
   314d0:	e50b4060 	str	r4, [fp, #-96]	; 0x60
	w = TWO52[sx]+x;
   314d4:	e59f207c 	ldr	r2, [pc, #124]	; 31558 <rint+0x3f4>
   314d8:	e51b3018 	ldr	r3, [fp, #-24]
   314dc:	e1a03183 	lsl	r3, r3, #3
   314e0:	e0823003 	add	r3, r2, r3
   314e4:	e8930018 	ldm	r3, {r3, r4}
   314e8:	e1a00003 	mov	r0, r3
   314ec:	e1a01004 	mov	r1, r4
   314f0:	e24b3064 	sub	r3, fp, #100	; 0x64
   314f4:	e893000c 	ldm	r3, {r2, r3}
   314f8:	ebff8c7c 	bl	146f0 <__adddf3>
   314fc:	e1a03000 	mov	r3, r0
   31500:	e1a04001 	mov	r4, r1
   31504:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   31508:	e50b4030 	str	r4, [fp, #-48]	; 0x30
	return w-TWO52[sx];
   3150c:	e24b2034 	sub	r2, fp, #52	; 0x34
   31510:	e8920006 	ldm	r2, {r1, r2}
   31514:	e59f003c 	ldr	r0, [pc, #60]	; 31558 <rint+0x3f4>
   31518:	e51b3018 	ldr	r3, [fp, #-24]
   3151c:	e1a03183 	lsl	r3, r3, #3
   31520:	e0803003 	add	r3, r0, r3
   31524:	e8930018 	ldm	r3, {r3, r4}
   31528:	e1a00001 	mov	r0, r1
   3152c:	e1a01002 	mov	r1, r2
   31530:	e1a02003 	mov	r2, r3
   31534:	e1a03004 	mov	r3, r4
   31538:	ebff8c6b 	bl	146ec <__aeabi_dsub>
   3153c:	e1a03000 	mov	r3, r0
   31540:	e1a04001 	mov	r4, r1
}
   31544:	e1a00003 	mov	r0, r3
   31548:	e1a01004 	mov	r1, r4
   3154c:	e24bd008 	sub	sp, fp, #8
   31550:	e8bd4810 	pop	{r4, fp, lr}
   31554:	e12fff1e 	bx	lr
   31558:	00033898 	.word	0x00033898
   3155c:	000fffff 	.word	0x000fffff

00031560 <scalbn>:
	double scalbn (double x, int n)
#else
	double scalbn (x,n)
	double x; int n;
#endif
{
   31560:	e92d4810 	push	{r4, fp, lr}
   31564:	e28db008 	add	fp, sp, #8
   31568:	e24dd044 	sub	sp, sp, #68	; 0x44
   3156c:	e50b0044 	str	r0, [fp, #-68]	; 0x44
   31570:	e50b1040 	str	r1, [fp, #-64]	; 0x40
   31574:	e50b2048 	str	r2, [fp, #-72]	; 0x48
	__int32_t  k,hx,lx;
	EXTRACT_WORDS(hx,lx,x);
   31578:	e24b4044 	sub	r4, fp, #68	; 0x44
   3157c:	e8940018 	ldm	r4, {r3, r4}
   31580:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   31584:	e50b4020 	str	r4, [fp, #-32]
   31588:	e51b3020 	ldr	r3, [fp, #-32]
   3158c:	e50b3014 	str	r3, [fp, #-20]
   31590:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   31594:	e50b3018 	str	r3, [fp, #-24]
        k = (hx&0x7ff00000)>>20;		/* extract exponent */
   31598:	e51b2014 	ldr	r2, [fp, #-20]
   3159c:	e59f330c 	ldr	r3, [pc, #780]	; 318b0 <scalbn+0x350>
   315a0:	e0033002 	and	r3, r3, r2
   315a4:	e1a03a43 	asr	r3, r3, #20
   315a8:	e50b3010 	str	r3, [fp, #-16]
        if (k==0) {				/* 0 or subnormal x */
   315ac:	e51b3010 	ldr	r3, [fp, #-16]
   315b0:	e3530000 	cmp	r3, #0
   315b4:	1a00002d 	bne	31670 <scalbn+0x110>
            if ((lx|(hx&0x7fffffff))==0) return x; /* +-0 */
   315b8:	e51b3014 	ldr	r3, [fp, #-20]
   315bc:	e3c32102 	bic	r2, r3, #-2147483648	; 0x80000000
   315c0:	e51b3018 	ldr	r3, [fp, #-24]
   315c4:	e1823003 	orr	r3, r2, r3
   315c8:	e3530000 	cmp	r3, #0
   315cc:	1a000002 	bne	315dc <scalbn+0x7c>
   315d0:	e24b4044 	sub	r4, fp, #68	; 0x44
   315d4:	e8940018 	ldm	r4, {r3, r4}
   315d8:	ea0000aa 	b	31888 <scalbn+0x328>
	    x *= two54; 
   315dc:	e3a03000 	mov	r3, #0
   315e0:	e59f42cc 	ldr	r4, [pc, #716]	; 318b4 <scalbn+0x354>
   315e4:	e24b1044 	sub	r1, fp, #68	; 0x44
   315e8:	e8910003 	ldm	r1, {r0, r1}
   315ec:	e1a02003 	mov	r2, r3
   315f0:	e1a03004 	mov	r3, r4
   315f4:	ebff8d41 	bl	14b00 <__aeabi_dmul>
   315f8:	e1a03000 	mov	r3, r0
   315fc:	e1a04001 	mov	r4, r1
   31600:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   31604:	e50b4040 	str	r4, [fp, #-64]	; 0x40
	    GET_HIGH_WORD(hx,x);
   31608:	e24b4044 	sub	r4, fp, #68	; 0x44
   3160c:	e8940018 	ldm	r4, {r3, r4}
   31610:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   31614:	e50b4028 	str	r4, [fp, #-40]	; 0x28
   31618:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   3161c:	e50b3014 	str	r3, [fp, #-20]
	    k = ((hx&0x7ff00000)>>20) - 54; 
   31620:	e51b2014 	ldr	r2, [fp, #-20]
   31624:	e59f3284 	ldr	r3, [pc, #644]	; 318b0 <scalbn+0x350>
   31628:	e0033002 	and	r3, r3, r2
   3162c:	e1a03a43 	asr	r3, r3, #20
   31630:	e2433036 	sub	r3, r3, #54	; 0x36
   31634:	e50b3010 	str	r3, [fp, #-16]
            if (n< -50000) return tiny*x; 	/*underflow*/
   31638:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   3163c:	e59f3274 	ldr	r3, [pc, #628]	; 318b8 <scalbn+0x358>
   31640:	e1520003 	cmp	r2, r3
   31644:	aa000009 	bge	31670 <scalbn+0x110>
   31648:	e28f4e25 	add	r4, pc, #592	; 0x250
   3164c:	e8940018 	ldm	r4, {r3, r4}
   31650:	e1a00003 	mov	r0, r3
   31654:	e1a01004 	mov	r1, r4
   31658:	e24b3044 	sub	r3, fp, #68	; 0x44
   3165c:	e893000c 	ldm	r3, {r2, r3}
   31660:	ebff8d26 	bl	14b00 <__aeabi_dmul>
   31664:	e1a03000 	mov	r3, r0
   31668:	e1a04001 	mov	r4, r1
   3166c:	ea000085 	b	31888 <scalbn+0x328>
	    }
        if (k==0x7ff) return x+x;		/* NaN or Inf */
   31670:	e51b2010 	ldr	r2, [fp, #-16]
   31674:	e59f3240 	ldr	r3, [pc, #576]	; 318bc <scalbn+0x35c>
   31678:	e1520003 	cmp	r2, r3
   3167c:	1a000009 	bne	316a8 <scalbn+0x148>
   31680:	e24b4044 	sub	r4, fp, #68	; 0x44
   31684:	e8940018 	ldm	r4, {r3, r4}
   31688:	e1a00003 	mov	r0, r3
   3168c:	e1a01004 	mov	r1, r4
   31690:	e1a02003 	mov	r2, r3
   31694:	e1a03004 	mov	r3, r4
   31698:	ebff8c14 	bl	146f0 <__adddf3>
   3169c:	e1a03000 	mov	r3, r0
   316a0:	e1a04001 	mov	r4, r1
   316a4:	ea000077 	b	31888 <scalbn+0x328>
        k = k+n; 
   316a8:	e51b2010 	ldr	r2, [fp, #-16]
   316ac:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   316b0:	e0823003 	add	r3, r2, r3
   316b4:	e50b3010 	str	r3, [fp, #-16]
        if (k >  0x7fe) return huge*copysign(huge,x); /* overflow  */
   316b8:	e51b2010 	ldr	r2, [fp, #-16]
   316bc:	e59f31fc 	ldr	r3, [pc, #508]	; 318c0 <scalbn+0x360>
   316c0:	e1520003 	cmp	r2, r3
   316c4:	da000012 	ble	31714 <scalbn+0x1b4>
   316c8:	e28f4f76 	add	r4, pc, #472	; 0x1d8
   316cc:	e8940018 	ldm	r4, {r3, r4}
   316d0:	e1a00003 	mov	r0, r3
   316d4:	e1a01004 	mov	r1, r4
   316d8:	e24b3044 	sub	r3, fp, #68	; 0x44
   316dc:	e893000c 	ldm	r3, {r2, r3}
   316e0:	eb00007a 	bl	318d0 <copysign>
   316e4:	e1a02001 	mov	r2, r1
   316e8:	e1a01000 	mov	r1, r0
   316ec:	e28f4f6d 	add	r4, pc, #436	; 0x1b4
   316f0:	e8940018 	ldm	r4, {r3, r4}
   316f4:	e1a00001 	mov	r0, r1
   316f8:	e1a01002 	mov	r1, r2
   316fc:	e1a02003 	mov	r2, r3
   31700:	e1a03004 	mov	r3, r4
   31704:	ebff8cfd 	bl	14b00 <__aeabi_dmul>
   31708:	e1a03000 	mov	r3, r0
   3170c:	e1a04001 	mov	r4, r1
   31710:	ea00005c 	b	31888 <scalbn+0x328>
        if (k > 0) 				/* normal result */
   31714:	e51b3010 	ldr	r3, [fp, #-16]
   31718:	e3530000 	cmp	r3, #0
   3171c:	da000011 	ble	31768 <scalbn+0x208>
	    {SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20)); return x;}
   31720:	e24b4044 	sub	r4, fp, #68	; 0x44
   31724:	e8940018 	ldm	r4, {r3, r4}
   31728:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   3172c:	e50b4030 	str	r4, [fp, #-48]	; 0x30
   31730:	e51b3014 	ldr	r3, [fp, #-20]
   31734:	e3c3347f 	bic	r3, r3, #2130706432	; 0x7f000000
   31738:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   3173c:	e51b2010 	ldr	r2, [fp, #-16]
   31740:	e1a02a02 	lsl	r2, r2, #20
   31744:	e1833002 	orr	r3, r3, r2
   31748:	e50b3030 	str	r3, [fp, #-48]	; 0x30
   3174c:	e24b4034 	sub	r4, fp, #52	; 0x34
   31750:	e8940018 	ldm	r4, {r3, r4}
   31754:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   31758:	e50b4040 	str	r4, [fp, #-64]	; 0x40
   3175c:	e24b4044 	sub	r4, fp, #68	; 0x44
   31760:	e8940018 	ldm	r4, {r3, r4}
   31764:	ea000047 	b	31888 <scalbn+0x328>
        if (k <= -54) {
   31768:	e51b3010 	ldr	r3, [fp, #-16]
   3176c:	e3730035 	cmn	r3, #53	; 0x35
   31770:	aa000029 	bge	3181c <scalbn+0x2bc>
            if (n > 50000) 	/* in case integer overflow in n+k */
   31774:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   31778:	e59f3144 	ldr	r3, [pc, #324]	; 318c4 <scalbn+0x364>
   3177c:	e1520003 	cmp	r2, r3
   31780:	da000012 	ble	317d0 <scalbn+0x270>
		return huge*copysign(huge,x);	/*overflow*/
   31784:	e28f4f47 	add	r4, pc, #284	; 0x11c
   31788:	e8940018 	ldm	r4, {r3, r4}
   3178c:	e1a00003 	mov	r0, r3
   31790:	e1a01004 	mov	r1, r4
   31794:	e24b3044 	sub	r3, fp, #68	; 0x44
   31798:	e893000c 	ldm	r3, {r2, r3}
   3179c:	eb00004b 	bl	318d0 <copysign>
   317a0:	e1a02001 	mov	r2, r1
   317a4:	e1a01000 	mov	r1, r0
   317a8:	e28f40f8 	add	r4, pc, #248	; 0xf8
   317ac:	e8940018 	ldm	r4, {r3, r4}
   317b0:	e1a00001 	mov	r0, r1
   317b4:	e1a01002 	mov	r1, r2
   317b8:	e1a02003 	mov	r2, r3
   317bc:	e1a03004 	mov	r3, r4
   317c0:	ebff8cce 	bl	14b00 <__aeabi_dmul>
   317c4:	e1a03000 	mov	r3, r0
   317c8:	e1a04001 	mov	r4, r1
   317cc:	ea00002d 	b	31888 <scalbn+0x328>
	    else return tiny*copysign(tiny,x); 	/*underflow*/
   317d0:	e28f40c8 	add	r4, pc, #200	; 0xc8
   317d4:	e8940018 	ldm	r4, {r3, r4}
   317d8:	e1a00003 	mov	r0, r3
   317dc:	e1a01004 	mov	r1, r4
   317e0:	e24b3044 	sub	r3, fp, #68	; 0x44
   317e4:	e893000c 	ldm	r3, {r2, r3}
   317e8:	eb000038 	bl	318d0 <copysign>
   317ec:	e1a02001 	mov	r2, r1
   317f0:	e1a01000 	mov	r1, r0
   317f4:	e28f40a4 	add	r4, pc, #164	; 0xa4
   317f8:	e8940018 	ldm	r4, {r3, r4}
   317fc:	e1a00001 	mov	r0, r1
   31800:	e1a01002 	mov	r1, r2
   31804:	e1a02003 	mov	r2, r3
   31808:	e1a03004 	mov	r3, r4
   3180c:	ebff8cbb 	bl	14b00 <__aeabi_dmul>
   31810:	e1a03000 	mov	r3, r0
   31814:	e1a04001 	mov	r4, r1
   31818:	ea00001a 	b	31888 <scalbn+0x328>
      }
        k += 54;				/* subnormal result */
   3181c:	e51b3010 	ldr	r3, [fp, #-16]
   31820:	e2833036 	add	r3, r3, #54	; 0x36
   31824:	e50b3010 	str	r3, [fp, #-16]
	SET_HIGH_WORD(x,(hx&0x800fffff)|(k<<20));
   31828:	e24b4044 	sub	r4, fp, #68	; 0x44
   3182c:	e8940018 	ldm	r4, {r3, r4}
   31830:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   31834:	e50b4038 	str	r4, [fp, #-56]	; 0x38
   31838:	e51b3014 	ldr	r3, [fp, #-20]
   3183c:	e3c3347f 	bic	r3, r3, #2130706432	; 0x7f000000
   31840:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   31844:	e51b2010 	ldr	r2, [fp, #-16]
   31848:	e1a02a02 	lsl	r2, r2, #20
   3184c:	e1833002 	orr	r3, r3, r2
   31850:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   31854:	e24b403c 	sub	r4, fp, #60	; 0x3c
   31858:	e8940018 	ldm	r4, {r3, r4}
   3185c:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   31860:	e50b4040 	str	r4, [fp, #-64]	; 0x40
        return x*twom54;
   31864:	e3a03000 	mov	r3, #0
   31868:	e59f4058 	ldr	r4, [pc, #88]	; 318c8 <scalbn+0x368>
   3186c:	e1a00003 	mov	r0, r3
   31870:	e1a01004 	mov	r1, r4
   31874:	e24b3044 	sub	r3, fp, #68	; 0x44
   31878:	e893000c 	ldm	r3, {r2, r3}
   3187c:	ebff8c9f 	bl	14b00 <__aeabi_dmul>
   31880:	e1a03000 	mov	r3, r0
   31884:	e1a04001 	mov	r4, r1
}
   31888:	e1a00003 	mov	r0, r3
   3188c:	e1a01004 	mov	r1, r4
   31890:	e24bd008 	sub	sp, fp, #8
   31894:	e8bd4810 	pop	{r4, fp, lr}
   31898:	e12fff1e 	bx	lr
   3189c:	e1a00000 	nop			; (mov r0, r0)
   318a0:	c2f8f359 	.word	0xc2f8f359
   318a4:	01a56e1f 	.word	0x01a56e1f
   318a8:	8800759c 	.word	0x8800759c
   318ac:	7e37e43c 	.word	0x7e37e43c
   318b0:	7ff00000 	.word	0x7ff00000
   318b4:	43500000 	.word	0x43500000
   318b8:	ffff3cb0 	.word	0xffff3cb0
   318bc:	000007ff 	.word	0x000007ff
   318c0:	000007fe 	.word	0x000007fe
   318c4:	0000c350 	.word	0x0000c350
   318c8:	3c900000 	.word	0x3c900000
   318cc:	e1a00000 	nop			; (mov r0, r0)

000318d0 <copysign>:
	double copysign(double x, double y)
#else
	double copysign(x,y)
	double x,y;
#endif
{
   318d0:	e92d0810 	push	{r4, fp}
   318d4:	e28db004 	add	fp, sp, #4
   318d8:	e24dd030 	sub	sp, sp, #48	; 0x30
   318dc:	e50b002c 	str	r0, [fp, #-44]	; 0x2c
   318e0:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   318e4:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   318e8:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	__uint32_t hx,hy;
	GET_HIGH_WORD(hx,x);
   318ec:	e24b402c 	sub	r4, fp, #44	; 0x2c
   318f0:	e8940018 	ldm	r4, {r3, r4}
   318f4:	e50b3014 	str	r3, [fp, #-20]
   318f8:	e50b4010 	str	r4, [fp, #-16]
   318fc:	e51b3010 	ldr	r3, [fp, #-16]
   31900:	e50b3008 	str	r3, [fp, #-8]
	GET_HIGH_WORD(hy,y);
   31904:	e24b4034 	sub	r4, fp, #52	; 0x34
   31908:	e8940018 	ldm	r4, {r3, r4}
   3190c:	e50b301c 	str	r3, [fp, #-28]
   31910:	e50b4018 	str	r4, [fp, #-24]
   31914:	e51b3018 	ldr	r3, [fp, #-24]
   31918:	e50b300c 	str	r3, [fp, #-12]
	SET_HIGH_WORD(x,(hx&0x7fffffff)|(hy&0x80000000));
   3191c:	e24b402c 	sub	r4, fp, #44	; 0x2c
   31920:	e8940018 	ldm	r4, {r3, r4}
   31924:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   31928:	e50b4020 	str	r4, [fp, #-32]
   3192c:	e51b3008 	ldr	r3, [fp, #-8]
   31930:	e3c32102 	bic	r2, r3, #-2147483648	; 0x80000000
   31934:	e51b300c 	ldr	r3, [fp, #-12]
   31938:	e2033102 	and	r3, r3, #-2147483648	; 0x80000000
   3193c:	e1823003 	orr	r3, r2, r3
   31940:	e50b3020 	str	r3, [fp, #-32]
   31944:	e24b4024 	sub	r4, fp, #36	; 0x24
   31948:	e8940018 	ldm	r4, {r3, r4}
   3194c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   31950:	e50b4028 	str	r4, [fp, #-40]	; 0x28
        return x;
   31954:	e24b402c 	sub	r4, fp, #44	; 0x2c
   31958:	e8940018 	ldm	r4, {r3, r4}
}
   3195c:	e1a00003 	mov	r0, r3
   31960:	e1a01004 	mov	r1, r4
   31964:	e24bd004 	sub	sp, fp, #4
   31968:	e8bd0810 	pop	{r4, fp}
   3196c:	e12fff1e 	bx	lr
