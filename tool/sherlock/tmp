
vmlinux:     file format elf32-littlearm


Disassembly of section .reset:

00000000 <_start>:
	.extern prefetch_abort_handler

.type   _start, %function

_start:
	b	reset_handler
   0:	ea000006 	b	20 <reset_handler>
	b undef_handler
   4:	ea00004d 	b	140 <undef_handler>
	b swi_handler
   8:	ea000084 	b	220 <swi_handler>
	b	prefetch_abort_handler
   c:	ea000027 	b	b0 <prefetch_abort_handler>
	b data_abort_handler
  10:	ea00004e 	b	150 <data_abort_handler>
	nop
  14:	e320f000 	nop	{0}
	b irq_handler
  18:	ea000057 	b	17c <irq_handler>
	b fiq_handler
  1c:	ea00004f 	b	160 <fiq_handler>

Disassembly of section .excep:

00000020 <reset_handler>:

.type   reset_handler, %function

reset_handler:
  @ Get the current cpuid
  mrc p15, 0, r0, c0, c0, 5
  20:	ee100fb0 	mrc	15, 0, r0, cr0, cr0, {5}
  mov r3, #0x400
  24:	e3a03b01 	mov	r3, #1024	; 0x400

  @ Compute the basic stack addresses
	ldr	r1, = CPU_SVC_STACK_ADDR
  28:	e59f1058 	ldr	r1, [pc, #88]	; 88 <_hell_pit+0x4>
  mul r2, r3, r0
  2c:	e0020093 	mul	r2, r3, r0
  sub r1, r1, r2
  30:	e0411002 	sub	r1, r1, r2

  # eight-byte stack alignment
  bic r1, r1, #7
  34:	e3c11007 	bic	r1, r1, #7

  @ Set the processor stack
	mov	r0, #FIQ_MODE
  38:	e3a000d1 	mov	r0, #209	; 0xd1
	msr	cpsr_c, r0
  3c:	e121f000 	msr	CPSR_c, r0
	mov	sp, r1
  40:	e1a0d001 	mov	sp, r1
	mov fp, sp
  44:	e1a0b00d 	mov	fp, sp

	mov	r0, #IRQ_MODE
  48:	e3a000d2 	mov	r0, #210	; 0xd2
	msr	cpsr_c, r0
  4c:	e121f000 	msr	CPSR_c, r0
	mov	sp, r1
  50:	e1a0d001 	mov	sp, r1
	mov fp, sp
  54:	e1a0b00d 	mov	fp, sp

	mov	r0,  #SVC_MODE
  58:	e3a000d3 	mov	r0, #211	; 0xd3
	msr cpsr_c, r0
  5c:	e121f000 	msr	CPSR_c, r0
	mov	sp, r1
  60:	e1a0d001 	mov	sp, r1
	mov fp, sp
  64:	e1a0b00d 	mov	fp, sp

	@ Enable CPU interrupts
	mrs r0, cpsr
  68:	e10f0000 	mrs	r0, CPSR
	bic r0, r0, #0xC0
  6c:	e3c000c0 	bic	r0, r0, #192	; 0xc0
	msr cpsr_c, r0
  70:	e121f000 	msr	CPSR_c, r0

	@ Call to system kickstart
	ldr	r0, = system_kickstart
  74:	e59f0010 	ldr	r0, [pc, #16]	; 8c <_hell_pit+0x8>
  blx r0
  78:	e12fff30 	blx	r0

  nop
  7c:	e320f000 	nop	{0}
  nop
  80:	e320f000 	nop	{0}

00000084 <_hell_pit>:

_hell_pit:
  b _hell_pit
  84:	eafffffe 	b	84 <_hell_pit>
  @ Get the current cpuid
  mrc p15, 0, r0, c0, c0, 5
  mov r3, #0x400

  @ Compute the basic stack addresses
	ldr	r1, = CPU_SVC_STACK_ADDR
  88:	00035548 	.word	0x00035548
	mrs r0, cpsr
	bic r0, r0, #0xC0
	msr cpsr_c, r0

	@ Call to system kickstart
	ldr	r0, = system_kickstart
  8c:	0000da54 	.word	0x0000da54

00000090 <cpu_context_save>:
.section .excep,#alloc,#execinstr
	.align 4
	.global cpu_context_save

cpu_context_save:
	stmia r0!, {r0 - r10, fp, ip, sp}
  90:	e8a03fff 	stmia	r0!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp}
  str r1, [r0], #4
  94:	e4801004 	str	r1, [r0], #4
	mrs r1, cpsr
  98:	e10f1000 	mrs	r1, CPSR
	str	r1, [r0]
  9c:	e5801000 	str	r1, [r0]
	mov pc, lr
  a0:	e1a0f00e 	mov	pc, lr
  nop
  a4:	e320f000 	nop	{0}
  nop
  a8:	e320f000 	nop	{0}
  ac:	e320f000 	nop	{0}

000000b0 <prefetch_abort_handler>:
.section .excep,#alloc,#execinstr
	.align 4
	.global prefetch_abort_handler

prefetch_abort_handler:
	b prefetch_abort_handler
  b0:	eafffffe 	b	b0 <prefetch_abort_handler>
  b4:	e320f000 	nop	{0}
  b8:	e320f000 	nop	{0}
  bc:	e320f000 	nop	{0}

000000c0 <cpu_context_init>:
# r2: stack_size
# r3: bootstrap
# [sp, #12]: signature

cpu_context_init:
	push {r4, r5, lr}
  c0:	e92d4030 	push	{r4, r5, lr}
	ldr r4, [sp, #12]
  c4:	e59d400c 	ldr	r4, [sp, #12]
	str r4, [r0], #4
  c8:	e4804004 	str	r4, [r0], #4
	stmia r0!, {r1-r10, fp, ip}
  cc:	e8a01ffe 	stmia	r0!, {r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
	add r5, r1, r2 
  d0:	e0815002 	add	r5, r1, r2
	sub r5, r5, #4
  d4:	e2455004 	sub	r5, r5, #4

  # eight-byte stack alignment	
  bic r5, r5, #7
  d8:	e3c55007 	bic	r5, r5, #7

  str r5, [r0], #4
  dc:	e4805004 	str	r5, [r0], #4
	str r3, [r0], #4
  e0:	e4803004 	str	r3, [r0], #4
	mrs r5, cpsr
  e4:	e10f5000 	mrs	r5, CPSR
	orr r5, r5, #0xC0
  e8:	e38550c0 	orr	r5, r5, #192	; 0xc0
	str r5, [r0]
  ec:	e5805000 	str	r5, [r0]
	pop {r4, r5, pc}
  f0:	e8bd8030 	pop	{r4, r5, pc}
  nop
  f4:	e320f000 	nop	{0}
  nop
  f8:	e320f000 	nop	{0}
  fc:	e320f000 	nop	{0}

00000100 <cpu_context_load>:
	.global cpu_context_load

cpu_context_load:

  @ We restore the common registers
  add r0, r0, #8
 100:	e2800008 	add	r0, r0, #8
	ldmia	r0, {r2 - r10, fp, ip, sp}
 104:	e8903ffc 	ldm	r0, {r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp}

  @ We get the new r0, r1 and pc values and push them
  sub r0, r0, #8
 108:	e2400008 	sub	r0, r0, #8
  ldr r1, [r0, #56]
 10c:	e5901038 	ldr	r1, [r0, #56]	; 0x38
  push {r1}
 110:	e52d1004 	push	{r1}		; (str r1, [sp, #-4]!)
  ldr r1, [r0, #4]
 114:	e5901004 	ldr	r1, [r0, #4]
  push {r1}
 118:	e52d1004 	push	{r1}		; (str r1, [sp, #-4]!)
  ldr r1, [r0]
 11c:	e5901000 	ldr	r1, [r0]
  push {r1}
 120:	e52d1004 	push	{r1}		; (str r1, [sp, #-4]!)

  @ We load the cpsr and spsr
    ldr	r1, [r0, #60]
 124:	e590103c 	ldr	r1, [r0, #60]	; 0x3c
	msr	cpsr, r1
 128:	e129f001 	msr	CPSR_fc, r1

  @ And now we restore the registers
  pop {r0, r1, pc}
 12c:	e8bd8003 	pop	{r0, r1, pc}
  nop
 130:	e320f000 	nop	{0}
  nop
 134:	e320f000 	nop	{0}
 138:	e320f000 	nop	{0}
 13c:	e320f000 	nop	{0}

00000140 <undef_handler>:
.section .excep,#alloc,#execinstr
	.align 4
	.global undef_handler

undef_handler:
	b undef_handler
 140:	eafffffe 	b	140 <undef_handler>
 144:	e320f000 	nop	{0}
 148:	e320f000 	nop	{0}
 14c:	e320f000 	nop	{0}

00000150 <data_abort_handler>:
.section .excep,#alloc,#execinstr
	.align 4
	.global data_abort_handler

data_abort_handler:
  b data_abort_handler
 150:	eafffffe 	b	150 <data_abort_handler>
 154:	e320f000 	nop	{0}
 158:	e320f000 	nop	{0}
 15c:	e320f000 	nop	{0}

00000160 <fiq_handler>:
	.align 4
	.global fiq_handler

fiq_handler:
	@ Not Handled
	subs pc, lr, #0x4
 160:	e25ef004 	subs	pc, lr, #4
  nop
 164:	e320f000 	nop	{0}
  nop
 168:	e320f000 	nop	{0}
 16c:	e320f000 	nop	{0}

00000170 <irq_registers>:
	...

0000017c <irq_handler>:
  .word 0x0 @ LR
  .word 0x0 @ CPSR

irq_handler:
	@ Save scratch registers and SPSR
	push {r0}
 17c:	e52d0004 	push	{r0}		; (str r0, [sp, #-4]!)
  ldr r0, =irq_registers
 180:	e59f0088 	ldr	r0, [pc, #136]	; 210 <irq_handler+0x94>
  stmia r0!, {r1, lr}
 184:	e8a04002 	stmia	r0!, {r1, lr}
	mrs	lr, spsr
 188:	e14fe000 	mrs	lr, SPSR
  str lr, [r0]
 18c:	e580e000 	str	lr, [r0]
  pop {r0}
 190:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)

	@ Move to SVC mode
	mrs lr, cpsr
 194:	e10fe000 	mrs	lr, CPSR
	orr lr, lr, #0xC3
 198:	e38ee0c3 	orr	lr, lr, #195	; 0xc3
	msr cpsr, lr 
 19c:	e129f00e 	msr	CPSR_fc, lr

  @ Save the context
  push {r0-r3, r9-r12, lr}
 1a0:	e92d5e0f 	push	{r0, r1, r2, r3, r9, sl, fp, ip, lr}
  ldr r0, =irq_registers
 1a4:	e59f0064 	ldr	r0, [pc, #100]	; 210 <irq_handler+0x94>
  ldmia r0, {r1, r2, r3}
 1a8:	e890000e 	ldm	r0, {r1, r2, r3}
  push {r1, r2, r3}
 1ac:	e92d000e 	push	{r1, r2, r3}

	@ Fetch the current interruption source
	@ Branch to IRQ handler

	ldr r1, =PLATFORM_AICU_BASE
 1b0:	e59f105c 	ldr	r1, [pc, #92]	; 214 <irq_handler+0x98>
	ldr r1, [r1]
 1b4:	e5911000 	ldr	r1, [r1]
  mrc p15,0,r2,c0,c0,5
 1b8:	ee102fb0 	mrc	15, 0, r2, cr0, cr0, {5}
  add r1, r1, #0x100
 1bc:	e2811c01 	add	r1, r1, #256	; 0x100
  add r1, r1, r2, lsl #0x4
 1c0:	e0811202 	add	r1, r1, r2, lsl #4

	ldr r0, [r1, #0xC]
 1c4:	e591000c 	ldr	r0, [r1, #12]
	ldr r1, [r1, #0x8]
 1c8:	e5911008 	ldr	r1, [r1, #8]
	blx r1
 1cc:	e12fff31 	blx	r1

	@ Restore the context
  ldr r0, =irq_registers
 1d0:	e59f0038 	ldr	r0, [pc, #56]	; 210 <irq_handler+0x94>
  pop {r1, r2, r3}
 1d4:	e8bd000e 	pop	{r1, r2, r3}
  stmia r0, {r1, r2, r3}
 1d8:	e880000e 	stm	r0, {r1, r2, r3}
  pop {r0-r3, r9-r12, lr}
 1dc:	e8bd5e0f 	pop	{r0, r1, r2, r3, r9, sl, fp, ip, lr}
  
	@ Move back to IRQ mode
	mrs r1, cpsr
 1e0:	e10f1000 	mrs	r1, CPSR
	bic r1, r1, #0x1
 1e4:	e3c11001 	bic	r1, r1, #1
	msr cpsr, r1
 1e8:	e129f001 	msr	CPSR_fc, r1

	@ Restore registers
  push {r0, r2}
 1ec:	e92d0005 	push	{r0, r2}
  ldr r0, =irq_registers
 1f0:	e59f0018 	ldr	r0, [pc, #24]	; 210 <irq_handler+0x94>
  ldmia r0!, {r1, lr}
 1f4:	e8b04002 	ldm	r0!, {r1, lr}
  ldr r2, [r0]
 1f8:	e5902000 	ldr	r2, [r0]
	msr	spsr, r2
 1fc:	e169f002 	msr	SPSR_fc, r2
  pop {r0, r2}
 200:	e8bd0005 	pop	{r0, r2}

	@ Return
	subs pc, lr, #0x4
 204:	e25ef004 	subs	pc, lr, #4
  nop
 208:	e320f000 	nop	{0}
  nop
 20c:	e320f000 	nop	{0}
  .word 0x0 @ CPSR

irq_handler:
	@ Save scratch registers and SPSR
	push {r0}
  ldr r0, =irq_registers
 210:	00000170 	.word	0x00000170
  push {r1, r2, r3}

	@ Fetch the current interruption source
	@ Branch to IRQ handler

	ldr r1, =PLATFORM_AICU_BASE
 214:	0002551c 	.word	0x0002551c
 218:	e320f000 	nop	{0}
 21c:	e320f000 	nop	{0}

00000220 <swi_handler>:
.section .excep,#alloc,#execinstr
	.align 4
	.global swi_handler

swi_handler:
	b swi_handler
 220:	eafffffe 	b	220 <swi_handler>
 224:	e320f000 	nop	{0}
 228:	e320f000 	nop	{0}
 22c:	e320f000 	nop	{0}

Disassembly of section .init:

00000238 <_init>:
 238:	e1a0c00d 	mov	ip, sp
 23c:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
 240:	e24cb004 	sub	fp, ip, #4

00000244 <__frame_dummy_init_array_entry>:
 244:	00000324 e24bd028 e89d6ff0 e12fff1e     $...(.K..o..../.

Disassembly of section .fini:

00000258 <_fini>:
 258:	e1a0c00d 	mov	ip, sp
 25c:	e92ddff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
 260:	e24cb004 	sub	fp, ip, #4

00000264 <__do_global_dtors_aux_fini_array_entry>:
 264:	000002e0 e24bd028 e89d6ff0 e12fff1e     ....(.K..o..../.

Disassembly of section .text:

00000278 <deregister_tm_clones>:
     278:	e59f301c 	ldr	r3, [pc, #28]	; 29c <deregister_tm_clones+0x24>
     27c:	e59f001c 	ldr	r0, [pc, #28]	; 2a0 <deregister_tm_clones+0x28>
     280:	e0603003 	rsb	r3, r0, r3
     284:	e3530006 	cmp	r3, #6
     288:	912fff1e 	bxls	lr
     28c:	e59f3010 	ldr	r3, [pc, #16]	; 2a4 <deregister_tm_clones+0x2c>
     290:	e3530000 	cmp	r3, #0
     294:	012fff1e 	bxeq	lr
     298:	e12fff13 	bx	r3
     29c:	000254c7 	.word	0x000254c7
     2a0:	000254c4 	.word	0x000254c4
     2a4:	00000000 	.word	0x00000000

000002a8 <register_tm_clones>:
     2a8:	e59f1024 	ldr	r1, [pc, #36]	; 2d4 <register_tm_clones+0x2c>
     2ac:	e59f0024 	ldr	r0, [pc, #36]	; 2d8 <register_tm_clones+0x30>
     2b0:	e0601001 	rsb	r1, r0, r1
     2b4:	e1a01141 	asr	r1, r1, #2
     2b8:	e0811fa1 	add	r1, r1, r1, lsr #31
     2bc:	e1b010c1 	asrs	r1, r1, #1
     2c0:	012fff1e 	bxeq	lr
     2c4:	e59f3010 	ldr	r3, [pc, #16]	; 2dc <register_tm_clones+0x34>
     2c8:	e3530000 	cmp	r3, #0
     2cc:	012fff1e 	bxeq	lr
     2d0:	e12fff13 	bx	r3
     2d4:	000254c4 	.word	0x000254c4
     2d8:	000254c4 	.word	0x000254c4
     2dc:	00000000 	.word	0x00000000

000002e0 <__do_global_dtors_aux>:
     2e0:	e92d4010 	push	{r4, lr}
     2e4:	e59f402c 	ldr	r4, [pc, #44]	; 318 <__do_global_dtors_aux+0x38>
     2e8:	e5d43000 	ldrb	r3, [r4]
     2ec:	e3530000 	cmp	r3, #0
     2f0:	1a000006 	bne	310 <__do_global_dtors_aux+0x30>
     2f4:	ebffffdf 	bl	278 <deregister_tm_clones>
     2f8:	e59f301c 	ldr	r3, [pc, #28]	; 31c <__do_global_dtors_aux+0x3c>
     2fc:	e3530000 	cmp	r3, #0
     300:	159f0018 	ldrne	r0, [pc, #24]	; 320 <__do_global_dtors_aux+0x40>
     304:	11a00000 	movne	r0, r0
     308:	e3a03001 	mov	r3, #1
     30c:	e5c43000 	strb	r3, [r4]
     310:	e8bd4010 	pop	{r4, lr}
     314:	e12fff1e 	bx	lr
     318:	00035550 	.word	0x00035550
     31c:	00000000 	.word	0x00000000
     320:	00024a30 	.word	0x00024a30

00000324 <frame_dummy>:
     324:	e92d4008 	push	{r3, lr}
     328:	e59f3034 	ldr	r3, [pc, #52]	; 364 <frame_dummy+0x40>
     32c:	e3530000 	cmp	r3, #0
     330:	159f0030 	ldrne	r0, [pc, #48]	; 368 <frame_dummy+0x44>
     334:	159f1030 	ldrne	r1, [pc, #48]	; 36c <frame_dummy+0x48>
     338:	11a00000 	movne	r0, r0
     33c:	e59f002c 	ldr	r0, [pc, #44]	; 370 <frame_dummy+0x4c>
     340:	e5903000 	ldr	r3, [r0]
     344:	e3530000 	cmp	r3, #0
     348:	0a000003 	beq	35c <frame_dummy+0x38>
     34c:	e59f3020 	ldr	r3, [pc, #32]	; 374 <frame_dummy+0x50>
     350:	e3530000 	cmp	r3, #0
     354:	11a0e00f 	movne	lr, pc
     358:	112fff13 	bxne	r3
     35c:	e8bd4008 	pop	{r3, lr}
     360:	eaffffd0 	b	2a8 <register_tm_clones>
     364:	00000000 	.word	0x00000000
     368:	00024a30 	.word	0x00024a30
     36c:	00035554 	.word	0x00035554
     370:	00000230 	.word	0x00000230
     374:	00000000 	.word	0x00000000

00000378 <_main>:
extern int __libthread_start (void);
extern void _init(void);
extern void _fini(void);

int _main(void)
{
     378:	e92d4800 	push	{fp, lr}
     37c:	e28db004 	add	fp, sp, #4
     380:	e24dd008 	sub	sp, sp, #8

	/*
	 * Create the sanity check semaphore
	 */

	semaphore_create ("libc_sanity_sem", 1, &__sanity_sem);
     384:	e59f002c 	ldr	r0, [pc, #44]	; 3b8 <_main+0x40>
     388:	e3a01001 	mov	r1, #1
     38c:	e59f2028 	ldr	r2, [pc, #40]	; 3bc <_main+0x44>
     390:	eb0030ab 	bl	c644 <semaphore_create>

	/*
	 * Call all init functions before calling main()
	 */
	_init();
     394:	ebffffa7 	bl	238 <_init>

	/*
	 * Return from the application's call
	 */

	return_value = __libthread_start ();
     398:	eb000385 	bl	11b4 <__libthread_start>
     39c:	e50b0008 	str	r0, [fp, #-8]

	/*
	 * Call all fini functions after main() retruns
	 */
	_fini();
     3a0:	ebffffac 	bl	258 <_fini>

	return return_value;
     3a4:	e51b3008 	ldr	r3, [fp, #-8]
}
     3a8:	e1a00003 	mov	r0, r3
     3ac:	e24bd004 	sub	sp, fp, #4
     3b0:	e8bd4800 	pop	{fp, lr}
     3b4:	e12fff1e 	bx	lr
     3b8:	00022cd8 	.word	0x00022cd8
     3bc:	00024bd4 	.word	0x00024bd4

000003c0 <kpn_channel_create>:
#include <DnaTools/DnaTools.h>
#include <KahnProcessNetwork/KahnProcessNetwork.h>

kpn_status_t kpn_channel_create (char * name,
    int32_t buffer_size, kpn_channel_t * channel)
{
     3c0:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
     3c4:	e1a06000 	mov	r6, r0
  kpn_channel_t c = NULL;
  
  watch (kpn_status_t)
  {
    c = malloc (sizeof (struct _kpn_channel));
     3c8:	e3a00018 	mov	r0, #24
#include <DnaTools/DnaTools.h>
#include <KahnProcessNetwork/KahnProcessNetwork.h>

kpn_status_t kpn_channel_create (char * name,
    int32_t buffer_size, kpn_channel_t * channel)
{
     3cc:	e1a05001 	mov	r5, r1
     3d0:	e1a08002 	mov	r8, r2
  kpn_channel_t c = NULL;
  
  watch (kpn_status_t)
  {
    c = malloc (sizeof (struct _kpn_channel));
     3d4:	eb003a0a 	bl	ec04 <malloc>
    ensure (c != NULL, KPN_OUT_OF_MEM);
     3d8:	e2504000 	subs	r4, r0, #0
     3dc:	0a00001a 	beq	44c <kpn_channel_create+0x8c>

    c -> fd = open (name, O_RDWR);
     3e0:	e1a00006 	mov	r0, r6
     3e4:	e3a01002 	mov	r1, #2
     3e8:	eb003ecc 	bl	ff20 <open>
     3ec:	e6ff0070 	uxth	r0, r0
    check (vfs_error, c -> fd != -1, KPN_NO_ENTRY);
     3f0:	e6bf7070 	sxth	r7, r0
     3f4:	e3770001 	cmn	r7, #1
  watch (kpn_status_t)
  {
    c = malloc (sizeof (struct _kpn_channel));
    ensure (c != NULL, KPN_OUT_OF_MEM);

    c -> fd = open (name, O_RDWR);
     3f8:	e1c400b4 	strh	r0, [r4, #4]
    check (vfs_error, c -> fd != -1, KPN_NO_ENTRY);
     3fc:	0a00002c 	beq	4b4 <kpn_channel_create+0xf4>

    if (buffer_size != 0)
     400:	e3550000 	cmp	r5, #0
     404:	1a000012 	bne	454 <kpn_channel_create+0x94>

      c -> size = buffer_size;
    }
    else
    {
      c -> data = NULL;
     408:	e5845014 	str	r5, [r4, #20]
      c -> size = 0;
     40c:	e5845008 	str	r5, [r4, #8]
    }

    c -> name = malloc (strlen (name) + 1);
     410:	e1a00006 	mov	r0, r6
     414:	eb004174 	bl	109ec <strlen>
     418:	e2800001 	add	r0, r0, #1
     41c:	eb0039f8 	bl	ec04 <malloc>
    check (name_error, c -> name != NULL, KPN_OUT_OF_MEM);
     420:	e3500000 	cmp	r0, #0
    {
      c -> data = NULL;
      c -> size = 0;
    }

    c -> name = malloc (strlen (name) + 1);
     424:	e5840000 	str	r0, [r4]
    check (name_error, c -> name != NULL, KPN_OUT_OF_MEM);
     428:	0a00001a 	beq	498 <kpn_channel_create+0xd8>

    c -> level = 0;
     42c:	e3a05000 	mov	r5, #0
    c -> position = 0;
    strcpy (c -> name, name);
     430:	e1a01006 	mov	r1, r6
    }

    c -> name = malloc (strlen (name) + 1);
    check (name_error, c -> name != NULL, KPN_OUT_OF_MEM);

    c -> level = 0;
     434:	e584500c 	str	r5, [r4, #12]
    c -> position = 0;
     438:	e5845010 	str	r5, [r4, #16]
    strcpy (c -> name, name);
     43c:	eb00412d 	bl	108f8 <strcpy>

    *channel = c;
    return KPN_OK;
     440:	e1a00005 	mov	r0, r5

    c -> level = 0;
    c -> position = 0;
    strcpy (c -> name, name);

    *channel = c;
     444:	e5884000 	str	r4, [r8]
    return KPN_OK;
     448:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  kpn_channel_t c = NULL;
  
  watch (kpn_status_t)
  {
    c = malloc (sizeof (struct _kpn_channel));
    ensure (c != NULL, KPN_OUT_OF_MEM);
     44c:	e3a00002 	mov	r0, #2
  rescue (vfs_error)
  {
    free (c);
    leave;
  }
}
     450:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
    c -> fd = open (name, O_RDWR);
    check (vfs_error, c -> fd != -1, KPN_NO_ENTRY);

    if (buffer_size != 0)
    {
      c -> data = malloc (buffer_size);
     454:	e1a00005 	mov	r0, r5
     458:	eb0039e9 	bl	ec04 <malloc>
      check (data_error, c -> data != NULL, KPN_OUT_OF_MEM);
     45c:	e3500000 	cmp	r0, #0
    c -> fd = open (name, O_RDWR);
    check (vfs_error, c -> fd != -1, KPN_NO_ENTRY);

    if (buffer_size != 0)
    {
      c -> data = malloc (buffer_size);
     460:	e1a09000 	mov	r9, r0
     464:	e5840014 	str	r0, [r4, #20]
      check (data_error, c -> data != NULL, KPN_OUT_OF_MEM);
     468:	0a00000a 	beq	498 <kpn_channel_create+0xd8>

      c -> size = buffer_size;
     46c:	e5845008 	str	r5, [r4, #8]
    {
      c -> data = NULL;
      c -> size = 0;
    }

    c -> name = malloc (strlen (name) + 1);
     470:	e1a00006 	mov	r0, r6
     474:	eb00415c 	bl	109ec <strlen>
     478:	e2800001 	add	r0, r0, #1
     47c:	eb0039e0 	bl	ec04 <malloc>
    check (name_error, c -> name != NULL, KPN_OUT_OF_MEM);
     480:	e3500000 	cmp	r0, #0
    {
      c -> data = NULL;
      c -> size = 0;
    }

    c -> name = malloc (strlen (name) + 1);
     484:	e5840000 	str	r0, [r4]
    check (name_error, c -> name != NULL, KPN_OUT_OF_MEM);
     488:	1affffe7 	bne	42c <kpn_channel_create+0x6c>
    return KPN_OK;
  }

  rescue (name_error)
  {
    if (buffer_size != 0) free (c -> data);
     48c:	e1a00009 	mov	r0, r9
     490:	eb0039ea 	bl	ec40 <free>
     494:	e1d470f4 	ldrsh	r7, [r4, #4]
  }

  rescue (data_error)
  {
    close (c -> fd);
     498:	e1a00007 	mov	r0, r7
     49c:	eb0038cf 	bl	e7e0 <close>
     4a0:	e3a05002 	mov	r5, #2
  }

  rescue (vfs_error)
  {
    free (c);
     4a4:	e1a00004 	mov	r0, r4
     4a8:	eb0039e4 	bl	ec40 <free>
    leave;
     4ac:	e1a00005 	mov	r0, r5
     4b0:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  {
    c = malloc (sizeof (struct _kpn_channel));
    ensure (c != NULL, KPN_OUT_OF_MEM);

    c -> fd = open (name, O_RDWR);
    check (vfs_error, c -> fd != -1, KPN_NO_ENTRY);
     4b4:	e3a05003 	mov	r5, #3
     4b8:	eafffff9 	b	4a4 <kpn_channel_create+0xe4>

000004bc <kpn_channel_skip>:
  int32_t bytes_to_transfer = 0;
  uint8_t * waste;

  watch (kpn_status_t)
  {
    if (c -> data == NULL)
     4bc:	e5903014 	ldr	r3, [r0, #20]

#include <DnaTools/DnaTools.h>
#include <KahnProcessNetwork/KahnProcessNetwork.h>

kpn_status_t kpn_channel_skip (kpn_channel_t c, int32_t size)
{
     4c0:	e92d4070 	push	{r4, r5, r6, lr}
  int32_t bytes_to_transfer = 0;
  uint8_t * waste;

  watch (kpn_status_t)
  {
    if (c -> data == NULL)
     4c4:	e3530000 	cmp	r3, #0

#include <DnaTools/DnaTools.h>
#include <KahnProcessNetwork/KahnProcessNetwork.h>

kpn_status_t kpn_channel_skip (kpn_channel_t c, int32_t size)
{
     4c8:	e1a06000 	mov	r6, r0
     4cc:	e1a05001 	mov	r5, r1
  int32_t bytes_to_transfer = 0;
  uint8_t * waste;

  watch (kpn_status_t)
  {
    if (c -> data == NULL)
     4d0:	0a000018 	beq	538 <kpn_channel_skip+0x7c>

      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     4d4:	e3510000 	cmp	r1, #0
     4d8:	1590400c 	ldrne	r4, [r0, #12]
     4dc:	1a00000a 	bne	50c <kpn_channel_skip+0x50>
     4e0:	ea000012 	b	530 <kpn_channel_skip+0x74>
     4e4:	e5962010 	ldr	r2, [r6, #16]
          res = read (c -> fd, c -> data, c -> size);
          c -> level = c -> size;
          c -> position = 0;
        }

        bytes_to_transfer = (counter <= c -> level) ?
     4e8:	e1540005 	cmp	r4, r5
     4ec:	b1a03004 	movlt	r3, r4
     4f0:	a1a03005 	movge	r3, r5
          counter : c -> level;

        c -> position += bytes_to_transfer;
     4f4:	e0832002 	add	r2, r3, r2
        c -> level -= bytes_to_transfer;
     4f8:	e0634004 	rsb	r4, r3, r4

      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     4fc:	e0555003 	subs	r5, r5, r3
        }

        bytes_to_transfer = (counter <= c -> level) ?
          counter : c -> level;

        c -> position += bytes_to_transfer;
     500:	e5862010 	str	r2, [r6, #16]
        c -> level -= bytes_to_transfer;
     504:	e586400c 	str	r4, [r6, #12]

      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     508:	0a000008 	beq	530 <kpn_channel_skip+0x74>
      {
        if (c -> level == 0)
     50c:	e3540000 	cmp	r4, #0
     510:	1afffff3 	bne	4e4 <kpn_channel_skip+0x28>
        {
          res = read (c -> fd, c -> data, c -> size);
     514:	e5962008 	ldr	r2, [r6, #8]
     518:	e1d600f4 	ldrsh	r0, [r6, #4]
     51c:	e5961014 	ldr	r1, [r6, #20]
     520:	eb003f32 	bl	101f0 <read>
          c -> level = c -> size;
     524:	e1a02004 	mov	r2, r4
     528:	e5964008 	ldr	r4, [r6, #8]
     52c:	eaffffed 	b	4e8 <kpn_channel_skip+0x2c>
        c -> level -= bytes_to_transfer;
        counter -= bytes_to_transfer;
      }
    }

    return KPN_OK;
     530:	e3a00000 	mov	r0, #0
     534:	e8bd8070 	pop	{r4, r5, r6, pc}

  watch (kpn_status_t)
  {
    if (c -> data == NULL)
    {
      waste = malloc (size);
     538:	e1a00001 	mov	r0, r1
     53c:	eb0039b0 	bl	ec04 <malloc>
      ensure (waste != NULL, KPN_OUT_OF_MEM);
     540:	e2504000 	subs	r4, r0, #0
     544:	0a00000a 	beq	574 <kpn_channel_skip+0xb8>

      res = read (c -> fd, waste, size);
     548:	e1a02005 	mov	r2, r5
     54c:	e1a01004 	mov	r1, r4
     550:	e1d600f4 	ldrsh	r0, [r6, #4]
     554:	eb003f25 	bl	101f0 <read>
     558:	e1a05000 	mov	r5, r0
      free (waste);
     55c:	e1a00004 	mov	r0, r4
     560:	eb0039b6 	bl	ec40 <free>
  watch (kpn_status_t)
  {
    if (c -> data == NULL)
    {
      waste = malloc (size);
      ensure (waste != NULL, KPN_OUT_OF_MEM);
     564:	e3750001 	cmn	r5, #1
     568:	13a00000 	movne	r0, #0
     56c:	03a00001 	moveq	r0, #1
     570:	e8bd8070 	pop	{r4, r5, r6, pc}
     574:	e3a00002 	mov	r0, #2
      }
    }

    return KPN_OK;
  }
}
     578:	e8bd8070 	pop	{r4, r5, r6, pc}

0000057c <kpn_channel_purge>:

#include <DnaTools/DnaTools.h>
#include <KahnProcessNetwork/KahnProcessNetwork.h>

kpn_status_t kpn_channel_purge (kpn_channel_t c, bool flush)
{
     57c:	e92d4010 	push	{r4, lr}
  int32_t res = 0;

  watch (kpn_status_t)
  {
    ensure (c != NULL, KPN_ERROR);
     580:	e2504000 	subs	r4, r0, #0
     584:	0a00000b 	beq	5b8 <kpn_channel_purge+0x3c>

    if (flush)
     588:	e3510000 	cmp	r1, #0
     58c:	1a000003 	bne	5a0 <kpn_channel_purge+0x24>
    {
      res = write (c -> fd, c -> data, c -> size);
      ensure (res != -1, KPN_ERROR);
    }

    c -> level = 0;
     590:	e3a00000 	mov	r0, #0
     594:	e584000c 	str	r0, [r4, #12]
    c -> position = 0;
     598:	e5840010 	str	r0, [r4, #16]

    return KPN_OK;
     59c:	e8bd8010 	pop	{r4, pc}
  {
    ensure (c != NULL, KPN_ERROR);

    if (flush)
    {
      res = write (c -> fd, c -> data, c -> size);
     5a0:	e1d400f4 	ldrsh	r0, [r4, #4]
     5a4:	e5941014 	ldr	r1, [r4, #20]
     5a8:	e5942008 	ldr	r2, [r4, #8]
     5ac:	eb00593e 	bl	16aac <write>
      ensure (res != -1, KPN_ERROR);
     5b0:	e3700001 	cmn	r0, #1
     5b4:	1afffff5 	bne	590 <kpn_channel_purge+0x14>
{
  int32_t res = 0;

  watch (kpn_status_t)
  {
    ensure (c != NULL, KPN_ERROR);
     5b8:	e3a00001 	mov	r0, #1
     5bc:	e8bd8010 	pop	{r4, pc}

000005c0 <kpn_channel_write>:
#include <DnaTools/DnaTools.h>
#include <KahnProcessNetwork/KahnProcessNetwork.h>
#include <VirtualFileSystem/VirtualFileSystem.h>

kpn_status_t kpn_channel_write (kpn_channel_t c, void * data, int32_t size)
{
     5c0:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
     5c4:	e1a04000 	mov	r4, r0
  int32_t counter = size, res = 0, position_in_data = 0;
  int32_t bytes_to_transfer = 0;

  watch (kpn_status_t)
  {
    if (c -> data == NULL)
     5c8:	e5900014 	ldr	r0, [r0, #20]
     5cc:	e3500000 	cmp	r0, #0
     5d0:	0a00002c 	beq	688 <kpn_channel_write+0xc8>
      res = write (c -> fd, data, size);
      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     5d4:	e3520000 	cmp	r2, #0
     5d8:	e1a06002 	mov	r6, r2
     5dc:	0a000025 	beq	678 <kpn_channel_write+0xb8>
     5e0:	e3a07000 	mov	r7, #0
     5e4:	e1a08001 	mov	r8, r1
        if (c -> level == c -> size)
        {
          res = write (c -> fd, c -> data, c -> size);
          ensure (res != -1, KPN_ERROR);

          c -> level = 0;
     5e8:	e1a09007 	mov	r9, r7
     5ec:	e594200c 	ldr	r2, [r4, #12]
     5f0:	e5943010 	ldr	r3, [r4, #16]
     5f4:	ea000002 	b	604 <kpn_channel_write+0x44>
      res = write (c -> fd, data, size);
      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     5f8:	e3560000 	cmp	r6, #0
     5fc:	0a00001d 	beq	678 <kpn_channel_write+0xb8>
     600:	e5940014 	ldr	r0, [r4, #20]
      {
        bytes_to_transfer = (counter <= c -> size - c -> level) ?
          counter : c -> size - c -> level;
     604:	e5945008 	ldr	r5, [r4, #8]

        memcpy ((void *)(c -> data + c -> position),
     608:	e0881007 	add	r1, r8, r7
    else
    {
      while (counter != 0)
      {
        bytes_to_transfer = (counter <= c -> size - c -> level) ?
          counter : c -> size - c -> level;
     60c:	e0625005 	rsb	r5, r2, r5
    }
    else
    {
      while (counter != 0)
      {
        bytes_to_transfer = (counter <= c -> size - c -> level) ?
     610:	e1560005 	cmp	r6, r5
     614:	b1a05006 	movlt	r5, r6
          counter : c -> size - c -> level;

        memcpy ((void *)(c -> data + c -> position),
     618:	e0800003 	add	r0, r0, r3
     61c:	e1a02005 	mov	r2, r5
     620:	eb003d4a 	bl	fb50 <memcpy>
            (void *)((char *)data + position_in_data),
            bytes_to_transfer);

        c -> position += bytes_to_transfer;
     624:	e2841008 	add	r1, r4, #8
     628:	e891000e 	ldm	r1, {r1, r2, r3}
        c -> level += bytes_to_transfer;
     62c:	e0852002 	add	r2, r5, r2

        memcpy ((void *)(c -> data + c -> position),
            (void *)((char *)data + position_in_data),
            bytes_to_transfer);

        c -> position += bytes_to_transfer;
     630:	e0853003 	add	r3, r5, r3
        c -> level += bytes_to_transfer;

        position_in_data += bytes_to_transfer;
        counter -= bytes_to_transfer;

        if (c -> level == c -> size)
     634:	e1520001 	cmp	r2, r1

        c -> position += bytes_to_transfer;
        c -> level += bytes_to_transfer;

        position_in_data += bytes_to_transfer;
        counter -= bytes_to_transfer;
     638:	e0656006 	rsb	r6, r5, r6
            bytes_to_transfer);

        c -> position += bytes_to_transfer;
        c -> level += bytes_to_transfer;

        position_in_data += bytes_to_transfer;
     63c:	e0877005 	add	r7, r7, r5
        memcpy ((void *)(c -> data + c -> position),
            (void *)((char *)data + position_in_data),
            bytes_to_transfer);

        c -> position += bytes_to_transfer;
        c -> level += bytes_to_transfer;
     640:	e584200c 	str	r2, [r4, #12]

        memcpy ((void *)(c -> data + c -> position),
            (void *)((char *)data + position_in_data),
            bytes_to_transfer);

        c -> position += bytes_to_transfer;
     644:	e5843010 	str	r3, [r4, #16]
        c -> level += bytes_to_transfer;

        position_in_data += bytes_to_transfer;
        counter -= bytes_to_transfer;

        if (c -> level == c -> size)
     648:	1affffea 	bne	5f8 <kpn_channel_write+0x38>
        {
          res = write (c -> fd, c -> data, c -> size);
     64c:	e1d400f4 	ldrsh	r0, [r4, #4]
     650:	e5941014 	ldr	r1, [r4, #20]
     654:	eb005914 	bl	16aac <write>
          ensure (res != -1, KPN_ERROR);
     658:	e3700001 	cmn	r0, #1
     65c:	0a000007 	beq	680 <kpn_channel_write+0xc0>

          c -> level = 0;
          c -> position = 0;
     660:	e3a03000 	mov	r3, #0
      res = write (c -> fd, data, size);
      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     664:	e3560000 	cmp	r6, #0
        {
          res = write (c -> fd, c -> data, c -> size);
          ensure (res != -1, KPN_ERROR);

          c -> level = 0;
          c -> position = 0;
     668:	e1a02003 	mov	r2, r3
        if (c -> level == c -> size)
        {
          res = write (c -> fd, c -> data, c -> size);
          ensure (res != -1, KPN_ERROR);

          c -> level = 0;
     66c:	e584900c 	str	r9, [r4, #12]
          c -> position = 0;
     670:	e5849010 	str	r9, [r4, #16]
      res = write (c -> fd, data, size);
      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     674:	1affffe1 	bne	600 <kpn_channel_write+0x40>
          c -> position = 0;
        }
      }
    }

    return KPN_OK;
     678:	e3a00000 	mov	r0, #0
     67c:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
        counter -= bytes_to_transfer;

        if (c -> level == c -> size)
        {
          res = write (c -> fd, c -> data, c -> size);
          ensure (res != -1, KPN_ERROR);
     680:	e3a00001 	mov	r0, #1
      }
    }

    return KPN_OK;
  }
}
     684:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

  watch (kpn_status_t)
  {
    if (c -> data == NULL)
    {
      res = write (c -> fd, data, size);
     688:	e1d400f4 	ldrsh	r0, [r4, #4]
     68c:	eb005906 	bl	16aac <write>
      ensure (res != -1, KPN_ERROR);
     690:	e3700001 	cmn	r0, #1
     694:	13a00000 	movne	r0, #0
     698:	03a00001 	moveq	r0, #1
     69c:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

000006a0 <kpn_channel_read>:

#include <DnaTools/DnaTools.h>
#include <KahnProcessNetwork/KahnProcessNetwork.h>

kpn_status_t kpn_channel_read (kpn_channel_t c, void * data, int32_t size)
{
     6a0:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
     6a4:	e1a04000 	mov	r4, r0
  int32_t counter = size, res = 0, position_in_data = 0;
  int32_t bytes_to_transfer = 0;

  watch (kpn_status_t)
  {
    if (c -> data == NULL)
     6a8:	e5900014 	ldr	r0, [r0, #20]
     6ac:	e3500000 	cmp	r0, #0
     6b0:	0a00002b 	beq	764 <kpn_channel_read+0xc4>
      res = read (c -> fd, data, size);
      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     6b4:	e3520000 	cmp	r2, #0
     6b8:	e1a06002 	mov	r6, r2
     6bc:	0a000024 	beq	754 <kpn_channel_read+0xb4>
     6c0:	e3a07000 	mov	r7, #0
     6c4:	e1a08001 	mov	r8, r1
        { 
          res = read (c -> fd, c -> data, c -> size);
          ensure (res != -1, KPN_ERROR);

          c -> level = c -> size;
          c -> position = 0;
     6c8:	e1a09007 	mov	r9, r7
     6cc:	e594300c 	ldr	r3, [r4, #12]
     6d0:	ea000011 	b	71c <kpn_channel_read+0x7c>
     6d4:	e5941010 	ldr	r1, [r4, #16]
        }

        bytes_to_transfer = (counter <= c -> level) ?
     6d8:	e1530006 	cmp	r3, r6
     6dc:	b1a05003 	movlt	r5, r3
     6e0:	a1a05006 	movge	r5, r6
          counter : c -> level;

        memcpy ((void *)((char *)data + position_in_data),
     6e4:	e0801001 	add	r1, r0, r1
     6e8:	e1a02005 	mov	r2, r5
     6ec:	e0880007 	add	r0, r8, r7
     6f0:	eb003d16 	bl	fb50 <memcpy>
            (void *)(c -> data + c -> position),
            bytes_to_transfer);

        position_in_data += bytes_to_transfer;
        c -> position += bytes_to_transfer;
     6f4:	e5942010 	ldr	r2, [r4, #16]

        c -> level -= bytes_to_transfer;
     6f8:	e594300c 	ldr	r3, [r4, #12]
        memcpy ((void *)((char *)data + position_in_data),
            (void *)(c -> data + c -> position),
            bytes_to_transfer);

        position_in_data += bytes_to_transfer;
        c -> position += bytes_to_transfer;
     6fc:	e0822005 	add	r2, r2, r5

        c -> level -= bytes_to_transfer;
     700:	e0653003 	rsb	r3, r5, r3
      res = read (c -> fd, data, size);
      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     704:	e0566005 	subs	r6, r6, r5

        memcpy ((void *)((char *)data + position_in_data),
            (void *)(c -> data + c -> position),
            bytes_to_transfer);

        position_in_data += bytes_to_transfer;
     708:	e0877005 	add	r7, r7, r5
        c -> position += bytes_to_transfer;
     70c:	e5842010 	str	r2, [r4, #16]

        c -> level -= bytes_to_transfer;
     710:	e584300c 	str	r3, [r4, #12]
      res = read (c -> fd, data, size);
      ensure (res != -1, KPN_ERROR);
    }
    else
    {
      while (counter != 0)
     714:	0a00000e 	beq	754 <kpn_channel_read+0xb4>
     718:	e5940014 	ldr	r0, [r4, #20]
      {
        if (c -> level == 0)
     71c:	e3530000 	cmp	r3, #0
     720:	1affffeb 	bne	6d4 <kpn_channel_read+0x34>
        { 
          res = read (c -> fd, c -> data, c -> size);
     724:	e1a01000 	mov	r1, r0
     728:	e5942008 	ldr	r2, [r4, #8]
     72c:	e1d400f4 	ldrsh	r0, [r4, #4]
     730:	eb003eae 	bl	101f0 <read>
          ensure (res != -1, KPN_ERROR);
     734:	e3700001 	cmn	r0, #1
     738:	0a000007 	beq	75c <kpn_channel_read+0xbc>

          c -> level = c -> size;
     73c:	e5943008 	ldr	r3, [r4, #8]
          c -> position = 0;
     740:	e3a01000 	mov	r1, #0
     744:	e5940014 	ldr	r0, [r4, #20]
     748:	e5849010 	str	r9, [r4, #16]
        if (c -> level == 0)
        { 
          res = read (c -> fd, c -> data, c -> size);
          ensure (res != -1, KPN_ERROR);

          c -> level = c -> size;
     74c:	e584300c 	str	r3, [r4, #12]
     750:	eaffffe0 	b	6d8 <kpn_channel_read+0x38>
        c -> level -= bytes_to_transfer;
        counter -= bytes_to_transfer;
      }
    }

    return KPN_OK;
     754:	e3a00000 	mov	r0, #0
     758:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
      while (counter != 0)
      {
        if (c -> level == 0)
        { 
          res = read (c -> fd, c -> data, c -> size);
          ensure (res != -1, KPN_ERROR);
     75c:	e3a00001 	mov	r0, #1
      }
    }

    return KPN_OK;
  }
}
     760:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

  watch (kpn_status_t)
  {
    if (c -> data == NULL)
    {
      res = read (c -> fd, data, size);
     764:	e1d400f4 	ldrsh	r0, [r4, #4]
     768:	eb003ea0 	bl	101f0 <read>
      ensure (res != -1, KPN_ERROR);
     76c:	e3700001 	cmn	r0, #1
     770:	13a00000 	movne	r0, #0
     774:	03a00001 	moveq	r0, #1
     778:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

0000077c <pthread_barrier_init>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count)
{
  ASSERT_RETURN(!count,EINVAL);
     77c:	e3520000 	cmp	r2, #0
     780:	0a000005 	beq	79c <pthread_barrier_init+0x20>
     784:	e1a03000 	mov	r3, r0

  barrier -> count = 0;
     788:	e3a01000 	mov	r1, #0
     78c:	e5831004 	str	r1, [r3, #4]
  barrier -> threshold = count;

  return 0;
     790:	e1a00001 	mov	r0, r1
int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count)
{
  ASSERT_RETURN(!count,EINVAL);

  barrier -> count = 0;
  barrier -> threshold = count;
     794:	e5832000 	str	r2, [r3]

  return 0;
     798:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count)
{
     79c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!count,EINVAL);
     7a0:	e59f3024 	ldr	r3, [pc, #36]	; 7cc <pthread_barrier_init+0x50>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned int count)
{
     7a4:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!count,EINVAL);
     7a8:	e58d3000 	str	r3, [sp]
     7ac:	e59f101c 	ldr	r1, [pc, #28]	; 7d0 <pthread_barrier_init+0x54>
     7b0:	e59f201c 	ldr	r2, [pc, #28]	; 7d4 <pthread_barrier_init+0x58>
     7b4:	e59f301c 	ldr	r3, [pc, #28]	; 7d8 <pthread_barrier_init+0x5c>
     7b8:	e59f001c 	ldr	r0, [pc, #28]	; 7dc <pthread_barrier_init+0x60>
     7bc:	eb003e04 	bl	ffd4 <printf>
     7c0:	e3a00016 	mov	r0, #22

  barrier -> count = 0;
  barrier -> threshold = count;

  return 0;
}
     7c4:	e28dd00c 	add	sp, sp, #12
     7c8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     7cc:	00022da8 	.word	0x00022da8
     7d0:	00022d2c 	.word	0x00022d2c
     7d4:	00022ce8 	.word	0x00022ce8
     7d8:	00022da0 	.word	0x00022da0
     7dc:	00022d00 	.word	0x00022d00

000007e0 <pthread_cond_destroy>:
#include <Private/PosixThreads.h>

int pthread_cond_destroy(pthread_cond_t *cond)
{
     7e0:	e92d4008 	push	{r3, lr}
  semaphore_destroy (cond -> semaphore);
     7e4:	e5900000 	ldr	r0, [r0]
     7e8:	eb00268c 	bl	a220 <semaphore_destroy>
  return 0;
}
     7ec:	e3a00000 	mov	r0, #0
     7f0:	e8bd8008 	pop	{r3, pc}

000007f4 <pthread_mutex_lock>:
#include <Private/PosixThreads.h>

int pthread_mutex_lock(pthread_mutex_t *mutex)
{
     7f4:	e92d4010 	push	{r4, lr}
     7f8:	e1a04000 	mov	r4, r0
  status_t status = DNA_OK;

  if (mutex -> lock == -1)
     7fc:	e5900008 	ldr	r0, [r0, #8]
#include <Private/PosixThreads.h>

int pthread_mutex_lock(pthread_mutex_t *mutex)
{
     800:	e24dd008 	sub	sp, sp, #8
  status_t status = DNA_OK;

  if (mutex -> lock == -1)
     804:	e3700001 	cmn	r0, #1
     808:	0a000009 	beq	834 <pthread_mutex_lock+0x40>
  {
    status = semaphore_create ("pthread_mutex", 1, & mutex -> lock);
    if (status != DNA_OK) return EINVAL;
  }

  semaphore_acquire (mutex -> lock, 1, 0, 0);
     80c:	e3a03000 	mov	r3, #0
     810:	e3a02000 	mov	r2, #0
     814:	e3a01001 	mov	r1, #1
     818:	e1cd20f0 	strd	r2, [sp]
     81c:	eb002b6a 	bl	b5cc <semaphore_acquire>

  mutex -> status = MUTEX_LOCKED;
     820:	e3a03001 	mov	r3, #1
  return 0;
     824:	e3a00000 	mov	r0, #0
    if (status != DNA_OK) return EINVAL;
  }

  semaphore_acquire (mutex -> lock, 1, 0, 0);

  mutex -> status = MUTEX_LOCKED;
     828:	e5843004 	str	r3, [r4, #4]
  return 0;
}
     82c:	e28dd008 	add	sp, sp, #8
     830:	e8bd8010 	pop	{r4, pc}
{
  status_t status = DNA_OK;

  if (mutex -> lock == -1)
  {
    status = semaphore_create ("pthread_mutex", 1, & mutex -> lock);
     834:	e59f001c 	ldr	r0, [pc, #28]	; 858 <pthread_mutex_lock+0x64>
     838:	e3a01001 	mov	r1, #1
     83c:	e2842008 	add	r2, r4, #8
     840:	eb002f7f 	bl	c644 <semaphore_create>
    if (status != DNA_OK) return EINVAL;
     844:	e3500000 	cmp	r0, #0
     848:	13a00016 	movne	r0, #22
     84c:	1afffff6 	bne	82c <pthread_mutex_lock+0x38>
     850:	e5940008 	ldr	r0, [r4, #8]
     854:	eaffffec 	b	80c <pthread_mutex_lock+0x18>
     858:	00022db0 	.word	0x00022db0

0000085c <pthread_attr_getschedparam>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getschedparam(const pthread_attr_t *attr, sched_param_t *param)
{
  ASSERT_RETURN (! attr || ! param, EINVAL);
     85c:	e3510000 	cmp	r1, #0
     860:	13500000 	cmpne	r0, #0
     864:	03a02001 	moveq	r2, #1
     868:	13a02000 	movne	r2, #0
     86c:	1a00000b 	bne	8a0 <pthread_attr_getschedparam+0x44>
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getschedparam(const pthread_attr_t *attr, sched_param_t *param)
{
     870:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN (! attr || ! param, EINVAL);
     874:	e59f3048 	ldr	r3, [pc, #72]	; 8c4 <pthread_attr_getschedparam+0x68>
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getschedparam(const pthread_attr_t *attr, sched_param_t *param)
{
     878:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN (! attr || ! param, EINVAL);
     87c:	e58d3000 	str	r3, [sp]
     880:	e59f1040 	ldr	r1, [pc, #64]	; 8c8 <pthread_attr_getschedparam+0x6c>
     884:	e59f2040 	ldr	r2, [pc, #64]	; 8cc <pthread_attr_getschedparam+0x70>
     888:	e59f3040 	ldr	r3, [pc, #64]	; 8d0 <pthread_attr_getschedparam+0x74>
     88c:	e59f0040 	ldr	r0, [pc, #64]	; 8d4 <pthread_attr_getschedparam+0x78>
     890:	eb003dcf 	bl	ffd4 <printf>
     894:	e3a00016 	mov	r0, #22

  memcpy(param, & attr -> schedparam, sizeof (*param));
  return 0;
}
     898:	e28dd00c 	add	sp, sp, #12
     89c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

int pthread_attr_getschedparam(const pthread_attr_t *attr, sched_param_t *param)
{
  ASSERT_RETURN (! attr || ! param, EINVAL);

  memcpy(param, & attr -> schedparam, sizeof (*param));
     8a0:	e1a03000 	mov	r3, r0
     8a4:	e5b3c018 	ldr	ip, [r3, #24]!
  return 0;
     8a8:	e1a00002 	mov	r0, r2

int pthread_attr_getschedparam(const pthread_attr_t *attr, sched_param_t *param)
{
  ASSERT_RETURN (! attr || ! param, EINVAL);

  memcpy(param, & attr -> schedparam, sizeof (*param));
     8ac:	e5932004 	ldr	r2, [r3, #4]
     8b0:	e5933008 	ldr	r3, [r3, #8]
     8b4:	e581c000 	str	ip, [r1]
     8b8:	e5812004 	str	r2, [r1, #4]
     8bc:	e5813008 	str	r3, [r1, #8]
  return 0;
     8c0:	e12fff1e 	bx	lr
     8c4:	00022da8 	.word	0x00022da8
     8c8:	00022ddc 	.word	0x00022ddc
     8cc:	00022dc0 	.word	0x00022dc0
     8d0:	00022e54 	.word	0x00022e54
     8d4:	00022d00 	.word	0x00022d00

000008d8 <pthread_cond_broadcast>:

int pthread_cond_broadcast(pthread_cond_t *condition)
{
  status_t status = DNA_OK;

  if (condition -> count > 0)
     8d8:	e5901004 	ldr	r1, [r0, #4]
     8dc:	e3510000 	cmp	r1, #0
     8e0:	da000008 	ble	908 <pthread_cond_broadcast+0x30>
#include <Private/PosixThreads.h>

int pthread_cond_broadcast(pthread_cond_t *condition)
{
     8e4:	e92d4008 	push	{r3, lr}
  status_t status = DNA_OK;

  if (condition -> count > 0)
  {
    status = semaphore_release (condition -> semaphore,
     8e8:	e3a02000 	mov	r2, #0
     8ec:	e5900000 	ldr	r0, [r0]
     8f0:	eb002ff6 	bl	c8d0 <semaphore_release>
        condition -> count, 0);
    if (status == DNA_BAD_SEM_ID) return EINVAL;
     8f4:	e59f3014 	ldr	r3, [pc, #20]	; 910 <pthread_cond_broadcast+0x38>
  }

  return 0;
     8f8:	e1500003 	cmp	r0, r3
     8fc:	03a00016 	moveq	r0, #22
     900:	13a00000 	movne	r0, #0
     904:	e8bd8008 	pop	{r3, pc}
     908:	e3a00000 	mov	r0, #0
     90c:	e12fff1e 	bx	lr
     910:	0000fdff 	.word	0x0000fdff

00000914 <pthread_attr_getinheritsched>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *h)
{
  ASSERT_RETURN(!attr || !h,EINVAL);
     914:	e3510000 	cmp	r1, #0
     918:	13500000 	cmpne	r0, #0
     91c:	e1a03000 	mov	r3, r0
     920:	03a00001 	moveq	r0, #1
     924:	13a00000 	movne	r0, #0
     928:	0a000002 	beq	938 <pthread_attr_getinheritsched+0x24>

  *h = attr -> schedinherited;
     92c:	e593300c 	ldr	r3, [r3, #12]
     930:	e5813000 	str	r3, [r1]
  return 0;
     934:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *h)
{
     938:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!attr || !h,EINVAL);
     93c:	e59f3024 	ldr	r3, [pc, #36]	; 968 <pthread_attr_getinheritsched+0x54>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getinheritsched(const pthread_attr_t *attr, int *h)
{
     940:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!attr || !h,EINVAL);
     944:	e58d3000 	str	r3, [sp]
     948:	e59f101c 	ldr	r1, [pc, #28]	; 96c <pthread_attr_getinheritsched+0x58>
     94c:	e59f201c 	ldr	r2, [pc, #28]	; 970 <pthread_attr_getinheritsched+0x5c>
     950:	e59f301c 	ldr	r3, [pc, #28]	; 974 <pthread_attr_getinheritsched+0x60>
     954:	e59f001c 	ldr	r0, [pc, #28]	; 978 <pthread_attr_getinheritsched+0x64>
     958:	eb003d9d 	bl	ffd4 <printf>
     95c:	e3a00016 	mov	r0, #22

  *h = attr -> schedinherited;
  return 0;
}
     960:	e28dd00c 	add	sp, sp, #12
     964:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     968:	00022da8 	.word	0x00022da8
     96c:	00022e88 	.word	0x00022e88
     970:	00022e68 	.word	0x00022e68
     974:	00022f04 	.word	0x00022f04
     978:	00022d00 	.word	0x00022d00

0000097c <pthread_attr_getstacksize>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *size)
{
  ASSERT_RETURN(!attr || !size,EINVAL);
     97c:	e3510000 	cmp	r1, #0
     980:	13500000 	cmpne	r0, #0
     984:	e1a03000 	mov	r3, r0
     988:	03a00001 	moveq	r0, #1
     98c:	13a00000 	movne	r0, #0
     990:	0a000002 	beq	9a0 <pthread_attr_getstacksize+0x24>

  *size = attr->stacksize;
     994:	e5933004 	ldr	r3, [r3, #4]
     998:	e5813000 	str	r3, [r1]
  return 0;
     99c:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *size)
{
     9a0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!attr || !size,EINVAL);
     9a4:	e59f3024 	ldr	r3, [pc, #36]	; 9d0 <pthread_attr_getstacksize+0x54>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *size)
{
     9a8:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!attr || !size,EINVAL);
     9ac:	e58d3000 	str	r3, [sp]
     9b0:	e59f101c 	ldr	r1, [pc, #28]	; 9d4 <pthread_attr_getstacksize+0x58>
     9b4:	e59f201c 	ldr	r2, [pc, #28]	; 9d8 <pthread_attr_getstacksize+0x5c>
     9b8:	e59f301c 	ldr	r3, [pc, #28]	; 9dc <pthread_attr_getstacksize+0x60>
     9bc:	e59f001c 	ldr	r0, [pc, #28]	; 9e0 <pthread_attr_getstacksize+0x64>
     9c0:	eb003d83 	bl	ffd4 <printf>
     9c4:	e3a00016 	mov	r0, #22

  *size = attr->stacksize;
  return 0;
}
     9c8:	e28dd00c 	add	sp, sp, #12
     9cc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     9d0:	00022da8 	.word	0x00022da8
     9d4:	00022f2c 	.word	0x00022f2c
     9d8:	00022f10 	.word	0x00022f10
     9dc:	00022fa4 	.word	0x00022fa4
     9e0:	00022d00 	.word	0x00022d00

000009e4 <pthread_cancel>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_cancel(pthread_t thread)
{
     9e4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN (thread == NULL, ESRCH);
     9e8:	e2503000 	subs	r3, r0, #0
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_cancel(pthread_t thread)
{
     9ec:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN (thread == NULL, ESRCH);
     9f0:	0a000021 	beq	a7c <pthread_cancel+0x98>
  ASSERT_RETURN (thread -> cancel_state != PTHREAD_CANCEL_DISABLE
     9f4:	e5d30019 	ldrb	r0, [r3, #25]
     9f8:	e3500001 	cmp	r0, #1
     9fc:	9a000009 	bls	a28 <pthread_cancel+0x44>
     a00:	e59f309c 	ldr	r3, [pc, #156]	; aa4 <pthread_cancel+0xc0>
     a04:	e59f009c 	ldr	r0, [pc, #156]	; aa8 <pthread_cancel+0xc4>
     a08:	e58d3000 	str	r3, [sp]
     a0c:	e59f1098 	ldr	r1, [pc, #152]	; aac <pthread_cancel+0xc8>
     a10:	e59f2098 	ldr	r2, [pc, #152]	; ab0 <pthread_cancel+0xcc>
     a14:	e59f3098 	ldr	r3, [pc, #152]	; ab4 <pthread_cancel+0xd0>
     a18:	eb003d6d 	bl	ffd4 <printf>
     a1c:	e3a00016 	mov	r0, #22
  }

  // FIXME : Not implemented. We need to decide
  // wether if cancel means exit or smtgh else
  return 0;
}
     a20:	e28dd00c 	add	sp, sp, #12
     a24:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
{
  ASSERT_RETURN (thread == NULL, ESRCH);
  ASSERT_RETURN (thread -> cancel_state != PTHREAD_CANCEL_DISABLE
      && thread -> cancel_state != PTHREAD_CANCEL_ENABLE, EINVAL);

  ASSERT_RETURN (thread -> cancel_type != PTHREAD_CANCEL_DEFERRED
     a28:	e5d32018 	ldrb	r2, [r3, #24]
     a2c:	e3520001 	cmp	r2, #1
     a30:	9a000009 	bls	a5c <pthread_cancel+0x78>
     a34:	e59f3068 	ldr	r3, [pc, #104]	; aa4 <pthread_cancel+0xc0>
     a38:	e59f106c 	ldr	r1, [pc, #108]	; aac <pthread_cancel+0xc8>
     a3c:	e58d3000 	str	r3, [sp]
     a40:	e59f2068 	ldr	r2, [pc, #104]	; ab0 <pthread_cancel+0xcc>
     a44:	e59f306c 	ldr	r3, [pc, #108]	; ab8 <pthread_cancel+0xd4>
     a48:	e59f0058 	ldr	r0, [pc, #88]	; aa8 <pthread_cancel+0xc4>
     a4c:	eb003d60 	bl	ffd4 <printf>
     a50:	e3a00016 	mov	r0, #22
  }

  // FIXME : Not implemented. We need to decide
  // wether if cancel means exit or smtgh else
  return 0;
}
     a54:	e28dd00c 	add	sp, sp, #12
     a58:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
      && thread -> cancel_state != PTHREAD_CANCEL_ENABLE, EINVAL);

  ASSERT_RETURN (thread -> cancel_type != PTHREAD_CANCEL_DEFERRED
      && thread -> cancel_type != PTHREAD_CANCEL_ASYNCHRONOUS, EINVAL);

  if (thread -> cancel_state == PTHREAD_CANCEL_DISABLE) return 0;
     a5c:	e3500000 	cmp	r0, #0
     a60:	0affffee 	beq	a20 <pthread_cancel+0x3c>
  if (thread -> cancel_type == PTHREAD_CANCEL_DEFERRED) {
     a64:	e3520000 	cmp	r2, #0
    thread -> cancel_bool = true;
     a68:	03a01001 	moveq	r1, #1
    return 0;
     a6c:	01a00002 	moveq	r0, r2
  ASSERT_RETURN (thread -> cancel_type != PTHREAD_CANCEL_DEFERRED
      && thread -> cancel_type != PTHREAD_CANCEL_ASYNCHRONOUS, EINVAL);

  if (thread -> cancel_state == PTHREAD_CANCEL_DISABLE) return 0;
  if (thread -> cancel_type == PTHREAD_CANCEL_DEFERRED) {
    thread -> cancel_bool = true;
     a70:	05c3101a 	strbeq	r1, [r3, #26]
      && thread -> cancel_state != PTHREAD_CANCEL_ENABLE, EINVAL);

  ASSERT_RETURN (thread -> cancel_type != PTHREAD_CANCEL_DEFERRED
      && thread -> cancel_type != PTHREAD_CANCEL_ASYNCHRONOUS, EINVAL);

  if (thread -> cancel_state == PTHREAD_CANCEL_DISABLE) return 0;
     a74:	13a00000 	movne	r0, #0
     a78:	eaffffe8 	b	a20 <pthread_cancel+0x3c>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_cancel(pthread_t thread)
{
  ASSERT_RETURN (thread == NULL, ESRCH);
     a7c:	e59f3038 	ldr	r3, [pc, #56]	; abc <pthread_cancel+0xd8>
     a80:	e59f1024 	ldr	r1, [pc, #36]	; aac <pthread_cancel+0xc8>
     a84:	e58d3000 	str	r3, [sp]
     a88:	e59f2020 	ldr	r2, [pc, #32]	; ab0 <pthread_cancel+0xcc>
     a8c:	e59f302c 	ldr	r3, [pc, #44]	; ac0 <pthread_cancel+0xdc>
     a90:	e59f0010 	ldr	r0, [pc, #16]	; aa8 <pthread_cancel+0xc4>
     a94:	eb003d4e 	bl	ffd4 <printf>
     a98:	e3a00003 	mov	r0, #3
  }

  // FIXME : Not implemented. We need to decide
  // wether if cancel means exit or smtgh else
  return 0;
}
     a9c:	e28dd00c 	add	sp, sp, #12
     aa0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     aa4:	00022da8 	.word	0x00022da8
     aa8:	00022d00 	.word	0x00022d00
     aac:	00022fc4 	.word	0x00022fc4
     ab0:	00022fb4 	.word	0x00022fb4
     ab4:	00023048 	.word	0x00023048
     ab8:	000230ac 	.word	0x000230ac
     abc:	00023040 	.word	0x00023040
     ac0:	00023030 	.word	0x00023030

00000ac4 <pthread_attr_init>:
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_init(pthread_attr_t *attr)
{
     ac4:	e92d4010 	push	{r4, lr}
  ASSERT_RETURN(!attr,EINVAL);
     ac8:	e2504000 	subs	r4, r0, #0
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_init(pthread_attr_t *attr)
{
     acc:	e24dd008 	sub	sp, sp, #8
  ASSERT_RETURN(!attr,EINVAL);
     ad0:	0a00000c 	beq	b08 <pthread_attr_init+0x44>

  memset(attr, 0, sizeof(*attr));
     ad4:	e3a01000 	mov	r1, #0
     ad8:	e3a02028 	mov	r2, #40	; 0x28
     adc:	eb003c85 	bl	fcf8 <memset>

  attr->detachstate    = PTHREAD_CREATE_JOINABLE;
     ae0:	e3a02000 	mov	r2, #0
  attr->schedpolicy    = SCHED_FIFO;
     ae4:	e3a03001 	mov	r3, #1
  attr->schedinherited = PTHREAD_EXPLICIT_SCHED;
  attr->procid         = PTHREAD_NOPROCID;
     ae8:	e3e01000 	mvn	r1, #0

  return 0;
     aec:	e1a00002 	mov	r0, r2
{
  ASSERT_RETURN(!attr,EINVAL);

  memset(attr, 0, sizeof(*attr));

  attr->detachstate    = PTHREAD_CREATE_JOINABLE;
     af0:	e5842008 	str	r2, [r4, #8]
  attr->schedpolicy    = SCHED_FIFO;
     af4:	e5843010 	str	r3, [r4, #16]
  attr->schedinherited = PTHREAD_EXPLICIT_SCHED;
     af8:	e584300c 	str	r3, [r4, #12]
  attr->procid         = PTHREAD_NOPROCID;
     afc:	e5841014 	str	r1, [r4, #20]

  return 0;
}
     b00:	e28dd008 	add	sp, sp, #8
     b04:	e8bd8010 	pop	{r4, pc}
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_init(pthread_attr_t *attr)
{
  ASSERT_RETURN(!attr,EINVAL);
     b08:	e59f3020 	ldr	r3, [pc, #32]	; b30 <pthread_attr_init+0x6c>
     b0c:	e59f1020 	ldr	r1, [pc, #32]	; b34 <pthread_attr_init+0x70>
     b10:	e58d3000 	str	r3, [sp]
     b14:	e59f201c 	ldr	r2, [pc, #28]	; b38 <pthread_attr_init+0x74>
     b18:	e59f301c 	ldr	r3, [pc, #28]	; b3c <pthread_attr_init+0x78>
     b1c:	e59f001c 	ldr	r0, [pc, #28]	; b40 <pthread_attr_init+0x7c>
     b20:	eb003d2b 	bl	ffd4 <printf>
     b24:	e3a00016 	mov	r0, #22
  attr->schedpolicy    = SCHED_FIFO;
  attr->schedinherited = PTHREAD_EXPLICIT_SCHED;
  attr->procid         = PTHREAD_NOPROCID;

  return 0;
}
     b28:	e28dd008 	add	sp, sp, #8
     b2c:	e8bd8010 	pop	{r4, pc}
     b30:	00022da8 	.word	0x00022da8
     b34:	0002312c 	.word	0x0002312c
     b38:	00023118 	.word	0x00023118
     b3c:	0002319c 	.word	0x0002319c
     b40:	00022d00 	.word	0x00022d00

00000b44 <pthread_setcanceltype>:
  if (oldtype != NULL) *oldtype = self -> cancel_type;
  self -> cancel_type = type;
#endif

  return 0;
}
     b44:	e3a00000 	mov	r0, #0
     b48:	e12fff1e 	bx	lr

00000b4c <pthread_lock_acquire>:

int pthread_lock_acquire(pthread_spinlock_t *spin)
{

  return 0;
}
     b4c:	e3a00000 	mov	r0, #0
     b50:	e12fff1e 	bx	lr

00000b54 <pthread_mutex_destroy>:
#include <Private/PosixThreads.h>

int pthread_mutex_destroy(pthread_mutex_t *mutex)
{
     b54:	e92d4008 	push	{r3, lr}
  semaphore_destroy (mutex -> lock);
     b58:	e5900008 	ldr	r0, [r0, #8]
     b5c:	eb0025af 	bl	a220 <semaphore_destroy>
  return 0;
}
     b60:	e3a00000 	mov	r0, #0
     b64:	e8bd8008 	pop	{r3, pc}

00000b68 <pthread_attr_setdetachstate>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setdetachstate(pthread_attr_t *attr, int state)
{
  ASSERT_RETURN(!attr,EINVAL);
     b68:	e2503000 	subs	r3, r0, #0
     b6c:	0a000002 	beq	b7c <pthread_attr_setdetachstate+0x14>

  attr->detachstate = state;
  return 0;
     b70:	e3a00000 	mov	r0, #0

int pthread_attr_setdetachstate(pthread_attr_t *attr, int state)
{
  ASSERT_RETURN(!attr,EINVAL);

  attr->detachstate = state;
     b74:	e5831008 	str	r1, [r3, #8]
  return 0;
     b78:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setdetachstate(pthread_attr_t *attr, int state)
{
     b7c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!attr,EINVAL);
     b80:	e59f3024 	ldr	r3, [pc, #36]	; bac <pthread_attr_setdetachstate+0x44>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setdetachstate(pthread_attr_t *attr, int state)
{
     b84:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!attr,EINVAL);
     b88:	e58d3000 	str	r3, [sp]
     b8c:	e59f101c 	ldr	r1, [pc, #28]	; bb0 <pthread_attr_setdetachstate+0x48>
     b90:	e59f201c 	ldr	r2, [pc, #28]	; bb4 <pthread_attr_setdetachstate+0x4c>
     b94:	e59f301c 	ldr	r3, [pc, #28]	; bb8 <pthread_attr_setdetachstate+0x50>
     b98:	e59f001c 	ldr	r0, [pc, #28]	; bbc <pthread_attr_setdetachstate+0x54>
     b9c:	eb003d0c 	bl	ffd4 <printf>
     ba0:	e3a00016 	mov	r0, #22

  attr->detachstate = state;
  return 0;
}
     ba4:	e28dd00c 	add	sp, sp, #12
     ba8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     bac:	00022da8 	.word	0x00022da8
     bb0:	000231c0 	.word	0x000231c0
     bb4:	000231a4 	.word	0x000231a4
     bb8:	0002319c 	.word	0x0002319c
     bbc:	00022d00 	.word	0x00022d00

00000bc0 <pthread_create>:
#include <stdio.h>
#include <string.h>

int pthread_create (pthread_t *thread, pthread_attr_t *attr,
    pthread_func_t start, void *arg)
{
     bc0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  pthread_t new;
  char * default_name = "pthread";
  void * stack_base;
  thread_info_t thread_info;

  ASSERT_RETURN( (thread == NULL), EINVAL );
     bc4:	e2508000 	subs	r8, r0, #0
#include <stdio.h>
#include <string.h>

int pthread_create (pthread_t *thread, pthread_attr_t *attr,
    pthread_func_t start, void *arg)
{
     bc8:	e24dd0b4 	sub	sp, sp, #180	; 0xb4
  pthread_t new;
  char * default_name = "pthread";
  void * stack_base;
  thread_info_t thread_info;

  ASSERT_RETURN( (thread == NULL), EINVAL );
     bcc:	0a00005d 	beq	d48 <pthread_create+0x188>

  new = malloc (sizeof(struct pthread));
     bd0:	e3a00020 	mov	r0, #32
     bd4:	e1a04001 	mov	r4, r1
     bd8:	e1a0a002 	mov	sl, r2
     bdc:	e1a09003 	mov	r9, r3
     be0:	eb003807 	bl	ec04 <malloc>
  ASSERT_RETURN (!new, ENOMEM);
     be4:	e2506000 	subs	r6, r0, #0
     be8:	0a000069 	beq	d94 <pthread_create+0x1d4>

  new -> attributs = malloc (sizeof (pthread_attr_t));
     bec:	e3a00028 	mov	r0, #40	; 0x28
     bf0:	eb003803 	bl	ec04 <malloc>
  ASSERT_RETURN(!new->attributs, ENOMEM);
     bf4:	e3500000 	cmp	r0, #0
  ASSERT_RETURN( (thread == NULL), EINVAL );

  new = malloc (sizeof(struct pthread));
  ASSERT_RETURN (!new, ENOMEM);

  new -> attributs = malloc (sizeof (pthread_attr_t));
     bf8:	e1a05000 	mov	r5, r0
     bfc:	e5860008 	str	r0, [r6, #8]
  ASSERT_RETURN(!new->attributs, ENOMEM);
     c00:	0a00005a 	beq	d70 <pthread_create+0x1b0>

  new -> father = NULL;
     c04:	e3a03000 	mov	r3, #0
  new -> children = 0;
  new -> cancel_type = PTHREAD_CANCEL_ASYNCHRONOUS;
     c08:	e3a02001 	mov	r2, #1
  new -> cancel_state = PTHREAD_CANCEL_ENABLE;
  new -> cancel_bool = false;

  if (attr == NULL)
     c0c:	e1540003 	cmp	r4, r3
  ASSERT_RETURN (!new, ENOMEM);

  new -> attributs = malloc (sizeof (pthread_attr_t));
  ASSERT_RETURN(!new->attributs, ENOMEM);

  new -> father = NULL;
     c10:	e5863010 	str	r3, [r6, #16]
  new -> children = 0;
     c14:	e5863014 	str	r3, [r6, #20]
  new -> cancel_type = PTHREAD_CANCEL_ASYNCHRONOUS;
  new -> cancel_state = PTHREAD_CANCEL_ENABLE;
  new -> cancel_bool = false;
     c18:	e5c6301a 	strb	r3, [r6, #26]
  new -> attributs = malloc (sizeof (pthread_attr_t));
  ASSERT_RETURN(!new->attributs, ENOMEM);

  new -> father = NULL;
  new -> children = 0;
  new -> cancel_type = PTHREAD_CANCEL_ASYNCHRONOUS;
     c1c:	e5c62018 	strb	r2, [r6, #24]
  new -> cancel_state = PTHREAD_CANCEL_ENABLE;
     c20:	e5c62019 	strb	r2, [r6, #25]
    new -> attributs -> stacksize = 0x8000;
    new -> attributs -> stackaddr = malloc (0x8000);
  }
  else
  {
    memcpy (new -> attributs, attr, sizeof (pthread_attr_t));
     c24:	11a0c004 	movne	ip, r4
     c28:	11a07000 	movne	r7, r0
     c2c:	1284b020 	addne	fp, r4, #32
  new -> children = 0;
  new -> cancel_type = PTHREAD_CANCEL_ASYNCHRONOUS;
  new -> cancel_state = PTHREAD_CANCEL_ENABLE;
  new -> cancel_bool = false;

  if (attr == NULL)
     c30:	0a000061 	beq	dbc <pthread_create+0x1fc>
    new -> attributs -> stacksize = 0x8000;
    new -> attributs -> stackaddr = malloc (0x8000);
  }
  else
  {
    memcpy (new -> attributs, attr, sizeof (pthread_attr_t));
     c34:	e1a0e007 	mov	lr, r7
     c38:	e59c0000 	ldr	r0, [ip]
     c3c:	e59c1004 	ldr	r1, [ip, #4]
     c40:	e59c2008 	ldr	r2, [ip, #8]
     c44:	e59c300c 	ldr	r3, [ip, #12]
     c48:	e28cc010 	add	ip, ip, #16
     c4c:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
     c50:	e15c000b 	cmp	ip, fp
     c54:	e1a0700e 	mov	r7, lr
     c58:	1afffff5 	bne	c34 <pthread_create+0x74>

    if (attr -> name == NULL)
     c5c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
    new -> attributs -> stacksize = 0x8000;
    new -> attributs -> stackaddr = malloc (0x8000);
  }
  else
  {
    memcpy (new -> attributs, attr, sizeof (pthread_attr_t));
     c60:	e59c0000 	ldr	r0, [ip]
     c64:	e59c1004 	ldr	r1, [ip, #4]

    if (attr -> name == NULL)
     c68:	e3530000 	cmp	r3, #0
    new -> attributs -> stacksize = 0x8000;
    new -> attributs -> stackaddr = malloc (0x8000);
  }
  else
  {
    memcpy (new -> attributs, attr, sizeof (pthread_attr_t));
     c6c:	e8a70003 	stmia	r7!, {r0, r1}

    if (attr -> name == NULL)
     c70:	0a000075 	beq	e4c <pthread_create+0x28c>
     {
      new -> attributs -> name = (char *) malloc (32);
      sprintf (new -> attributs -> name, "%s_%ld", default_name, index ++);
    }

    if (attr -> stackaddr == NULL)
     c74:	e5943000 	ldr	r3, [r4]
     c78:	e3530000 	cmp	r3, #0
     c7c:	0a000065 	beq	e18 <pthread_create+0x258>

  /*
   * Create the thread.
   */

  DNA_THREAD_SET_DEFAULTS (thread_info);
     c80:	e28db060 	add	fp, sp, #96	; 0x60
     c84:	e1a0000b 	mov	r0, fp
     c88:	e59f11e8 	ldr	r1, [pc, #488]	; e78 <pthread_create+0x2b8>
     c8c:	eb002295 	bl	96e8 <dna_strcpy>
     c90:	e3a07000 	mov	r7, #0
     c94:	e3e02000 	mvn	r2, #0
     c98:	e3a04000 	mov	r4, #0
     c9c:	e3a05000 	mov	r5, #0
     ca0:	e3a0e902 	mov	lr, #32768	; 0x8000

  strcpy (thread_info . name, new -> attributs -> name);
     ca4:	e5963008 	ldr	r3, [r6, #8]

  /*
   * Create the thread.
   */

  DNA_THREAD_SET_DEFAULTS (thread_info);
     ca8:	e59fc1cc 	ldr	ip, [pc, #460]	; e7c <pthread_create+0x2bc>

  strcpy (thread_info . name, new -> attributs -> name);
     cac:	e5931024 	ldr	r1, [r3, #36]	; 0x24
     cb0:	e1a0000b 	mov	r0, fp

  /*
   * Create the thread.
   */

  DNA_THREAD_SET_DEFAULTS (thread_info);
     cb4:	e58d2088 	str	r2, [sp, #136]	; 0x88
     cb8:	e58d2094 	str	r2, [sp, #148]	; 0x94
     cbc:	e1cd49f8 	strd	r4, [sp, #152]	; 0x98
     cc0:	e1cd4af0 	strd	r4, [sp, #160]	; 0xa0
     cc4:	e58de0ac 	str	lr, [sp, #172]	; 0xac
     cc8:	e1cdc9b0 	strh	ip, [sp, #144]	; 0x90

  strcpy (thread_info . name, new -> attributs -> name);
     ccc:	e58d3054 	str	r3, [sp, #84]	; 0x54

  /*
   * Create the thread.
   */

  DNA_THREAD_SET_DEFAULTS (thread_info);
     cd0:	e58d7080 	str	r7, [sp, #128]	; 0x80
     cd4:	e58d7084 	str	r7, [sp, #132]	; 0x84
     cd8:	e58d708c 	str	r7, [sp, #140]	; 0x8c
     cdc:	e5cd7092 	strb	r7, [sp, #146]	; 0x92
     ce0:	e58d70a8 	str	r7, [sp, #168]	; 0xa8

  strcpy (thread_info . name, new -> attributs -> name);
     ce4:	eb003f03 	bl	108f8 <strcpy>
  thread_info . affinity = new -> attributs -> procid;
     ce8:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
  thread_info . stack_base = new -> attributs -> stackaddr;
  thread_info . stack_size = new -> attributs -> stacksize;

  thread_create ((thread_handler_t)start, (void *) arg, thread_info, & t_new);
     cec:	e28d1068 	add	r1, sp, #104	; 0x68

  DNA_THREAD_SET_DEFAULTS (thread_info);

  strcpy (thread_info . name, new -> attributs -> name);
  thread_info . affinity = new -> attributs -> procid;
  thread_info . stack_base = new -> attributs -> stackaddr;
     cf0:	e593e000 	ldr	lr, [r3]
  thread_info . stack_size = new -> attributs -> stacksize;
     cf4:	e593c004 	ldr	ip, [r3, #4]
   */

  DNA_THREAD_SET_DEFAULTS (thread_info);

  strcpy (thread_info . name, new -> attributs -> name);
  thread_info . affinity = new -> attributs -> procid;
     cf8:	e5934014 	ldr	r4, [r3, #20]
  thread_info . stack_base = new -> attributs -> stackaddr;
  thread_info . stack_size = new -> attributs -> stacksize;

  thread_create ((thread_handler_t)start, (void *) arg, thread_info, & t_new);
     cfc:	e1a0000d 	mov	r0, sp
     d00:	e28d305c 	add	r3, sp, #92	; 0x5c
     d04:	e3a02048 	mov	r2, #72	; 0x48

  DNA_THREAD_SET_DEFAULTS (thread_info);

  strcpy (thread_info . name, new -> attributs -> name);
  thread_info . affinity = new -> attributs -> procid;
  thread_info . stack_base = new -> attributs -> stackaddr;
     d08:	e58de0a8 	str	lr, [sp, #168]	; 0xa8
  thread_info . stack_size = new -> attributs -> stacksize;
     d0c:	e58dc0ac 	str	ip, [sp, #172]	; 0xac

  thread_create ((thread_handler_t)start, (void *) arg, thread_info, & t_new);
     d10:	e58d3048 	str	r3, [sp, #72]	; 0x48
   */

  DNA_THREAD_SET_DEFAULTS (thread_info);

  strcpy (thread_info . name, new -> attributs -> name);
  thread_info . affinity = new -> attributs -> procid;
     d14:	e58d4088 	str	r4, [sp, #136]	; 0x88
  thread_info . stack_base = new -> attributs -> stackaddr;
  thread_info . stack_size = new -> attributs -> stacksize;

  thread_create ((thread_handler_t)start, (void *) arg, thread_info, & t_new);
     d18:	eb003b8c 	bl	fb50 <memcpy>
     d1c:	e89b000c 	ldm	fp, {r2, r3}
     d20:	e1a01009 	mov	r1, r9
     d24:	e1a0000a 	mov	r0, sl
     d28:	eb002898 	bl	af90 <thread_create>

  new -> tid = t_new;
     d2c:	e59d005c 	ldr	r0, [sp, #92]	; 0x5c
     d30:	e586000c 	str	r0, [r6, #12]
  thread_resume (t_new);
     d34:	eb002482 	bl	9f44 <thread_resume>

  *thread = new;
  return 0;
     d38:	e1a00007 	mov	r0, r7
  thread_create ((thread_handler_t)start, (void *) arg, thread_info, & t_new);

  new -> tid = t_new;
  thread_resume (t_new);

  *thread = new;
     d3c:	e5886000 	str	r6, [r8]
  return 0;
}
     d40:	e28dd0b4 	add	sp, sp, #180	; 0xb4
     d44:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  pthread_t new;
  char * default_name = "pthread";
  void * stack_base;
  thread_info_t thread_info;

  ASSERT_RETURN( (thread == NULL), EINVAL );
     d48:	e59f3130 	ldr	r3, [pc, #304]	; e80 <pthread_create+0x2c0>
     d4c:	e59f0130 	ldr	r0, [pc, #304]	; e84 <pthread_create+0x2c4>
     d50:	e58d3000 	str	r3, [sp]
     d54:	e59f112c 	ldr	r1, [pc, #300]	; e88 <pthread_create+0x2c8>
     d58:	e59f212c 	ldr	r2, [pc, #300]	; e8c <pthread_create+0x2cc>
     d5c:	e59f312c 	ldr	r3, [pc, #300]	; e90 <pthread_create+0x2d0>
     d60:	eb003c9b 	bl	ffd4 <printf>
     d64:	e3a00016 	mov	r0, #22
  new -> tid = t_new;
  thread_resume (t_new);

  *thread = new;
  return 0;
}
     d68:	e28dd0b4 	add	sp, sp, #180	; 0xb4
     d6c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

  new = malloc (sizeof(struct pthread));
  ASSERT_RETURN (!new, ENOMEM);

  new -> attributs = malloc (sizeof (pthread_attr_t));
  ASSERT_RETURN(!new->attributs, ENOMEM);
     d70:	e59f311c 	ldr	r3, [pc, #284]	; e94 <pthread_create+0x2d4>
     d74:	e59f0108 	ldr	r0, [pc, #264]	; e84 <pthread_create+0x2c4>
     d78:	e58d3000 	str	r3, [sp]
     d7c:	e59f1104 	ldr	r1, [pc, #260]	; e88 <pthread_create+0x2c8>
     d80:	e59f2104 	ldr	r2, [pc, #260]	; e8c <pthread_create+0x2cc>
     d84:	e59f310c 	ldr	r3, [pc, #268]	; e98 <pthread_create+0x2d8>
     d88:	eb003c91 	bl	ffd4 <printf>
     d8c:	e3a0000c 	mov	r0, #12
     d90:	eafffff4 	b	d68 <pthread_create+0x1a8>
  thread_info_t thread_info;

  ASSERT_RETURN( (thread == NULL), EINVAL );

  new = malloc (sizeof(struct pthread));
  ASSERT_RETURN (!new, ENOMEM);
     d94:	e59f30f8 	ldr	r3, [pc, #248]	; e94 <pthread_create+0x2d4>
     d98:	e59f10e8 	ldr	r1, [pc, #232]	; e88 <pthread_create+0x2c8>
     d9c:	e58d3000 	str	r3, [sp]
     da0:	e59f20e4 	ldr	r2, [pc, #228]	; e8c <pthread_create+0x2cc>
     da4:	e59f30f0 	ldr	r3, [pc, #240]	; e9c <pthread_create+0x2dc>
     da8:	e59f00d4 	ldr	r0, [pc, #212]	; e84 <pthread_create+0x2c4>
     dac:	eb003c88 	bl	ffd4 <printf>
     db0:	e3a0000c 	mov	r0, #12
  new -> tid = t_new;
  thread_resume (t_new);

  *thread = new;
  return 0;
}
     db4:	e28dd0b4 	add	sp, sp, #180	; 0xb4
     db8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  new -> cancel_state = PTHREAD_CANCEL_ENABLE;
  new -> cancel_bool = false;

  if (attr == NULL)
  {
    new -> attributs -> stacksize = 0x8000;
     dbc:	e3a07902 	mov	r7, #32768	; 0x8000
    new -> attributs -> detachstate = PTHREAD_CREATE_JOINABLE;
    new -> attributs -> schedinherited = PTHREAD_EXPLICIT_SCHED;
    new -> attributs -> schedpolicy = SCHED_FIFO;
    new -> attributs -> procid = PTHREAD_NOPROCID;
     dc0:	e3e03000 	mvn	r3, #0
  new -> cancel_bool = false;

  if (attr == NULL)
  {
    new -> attributs -> stacksize = 0x8000;
    new -> attributs -> detachstate = PTHREAD_CREATE_JOINABLE;
     dc4:	e5854008 	str	r4, [r5, #8]
    new -> attributs -> schedinherited = PTHREAD_EXPLICIT_SCHED;
     dc8:	e585200c 	str	r2, [r5, #12]
    new -> attributs -> schedpolicy = SCHED_FIFO;
     dcc:	e5852010 	str	r2, [r5, #16]
    new -> attributs -> procid = PTHREAD_NOPROCID;
     dd0:	e5853014 	str	r3, [r5, #20]
    new -> attributs -> name = (char *) malloc (32);
     dd4:	e3a00020 	mov	r0, #32
  new -> cancel_state = PTHREAD_CANCEL_ENABLE;
  new -> cancel_bool = false;

  if (attr == NULL)
  {
    new -> attributs -> stacksize = 0x8000;
     dd8:	e5857004 	str	r7, [r5, #4]
    new -> attributs -> detachstate = PTHREAD_CREATE_JOINABLE;
    new -> attributs -> schedinherited = PTHREAD_EXPLICIT_SCHED;
    new -> attributs -> schedpolicy = SCHED_FIFO;
    new -> attributs -> procid = PTHREAD_NOPROCID;
    new -> attributs -> name = (char *) malloc (32);
     ddc:	eb003788 	bl	ec04 <malloc>

    sprintf (new -> attributs -> name, "%s_%ld", default_name, index ++);
     de0:	e59fc0b8 	ldr	ip, [pc, #184]	; ea0 <pthread_create+0x2e0>
     de4:	e59f10b8 	ldr	r1, [pc, #184]	; ea4 <pthread_create+0x2e4>
     de8:	e59c3000 	ldr	r3, [ip]
     dec:	e59f20b4 	ldr	r2, [pc, #180]	; ea8 <pthread_create+0x2e8>
     df0:	e283e001 	add	lr, r3, #1
    new -> attributs -> stacksize = 0x8000;
    new -> attributs -> detachstate = PTHREAD_CREATE_JOINABLE;
    new -> attributs -> schedinherited = PTHREAD_EXPLICIT_SCHED;
    new -> attributs -> schedpolicy = SCHED_FIFO;
    new -> attributs -> procid = PTHREAD_NOPROCID;
    new -> attributs -> name = (char *) malloc (32);
     df4:	e5850024 	str	r0, [r5, #36]	; 0x24

    sprintf (new -> attributs -> name, "%s_%ld", default_name, index ++);
     df8:	e58ce000 	str	lr, [ip]
     dfc:	eb003e97 	bl	10860 <sprintf>

    new -> attributs -> stacksize = 0x8000;
     e00:	e5964008 	ldr	r4, [r6, #8]
    new -> attributs -> stackaddr = malloc (0x8000);
     e04:	e1a00007 	mov	r0, r7
    new -> attributs -> procid = PTHREAD_NOPROCID;
    new -> attributs -> name = (char *) malloc (32);

    sprintf (new -> attributs -> name, "%s_%ld", default_name, index ++);

    new -> attributs -> stacksize = 0x8000;
     e08:	e5847004 	str	r7, [r4, #4]
    new -> attributs -> stackaddr = malloc (0x8000);
     e0c:	eb00377c 	bl	ec04 <malloc>
     e10:	e5840000 	str	r0, [r4]
     e14:	eaffff99 	b	c80 <pthread_create+0xc0>
      sprintf (new -> attributs -> name, "%s_%ld", default_name, index ++);
    }

    if (attr -> stackaddr == NULL)
    {
      if (attr -> stacksize == 0)
     e18:	e5940004 	ldr	r0, [r4, #4]
     e1c:	e3500000 	cmp	r0, #0
     e20:	0a000003 	beq	e34 <pthread_create+0x274>
        stack_base = malloc (0x8000);
        new -> attributs -> stacksize = 0x8000;
      }
      else
      {
        stack_base = malloc (attr -> stacksize);
     e24:	eb003776 	bl	ec04 <malloc>
     e28:	e5963008 	ldr	r3, [r6, #8]
      }

      new -> attributs -> stackaddr = stack_base;
     e2c:	e5830000 	str	r0, [r3]
     e30:	eaffff92 	b	c80 <pthread_create+0xc0>

    if (attr -> stackaddr == NULL)
    {
      if (attr -> stacksize == 0)
      {
        stack_base = malloc (0x8000);
     e34:	e3a00902 	mov	r0, #32768	; 0x8000
     e38:	eb003771 	bl	ec04 <malloc>
        new -> attributs -> stacksize = 0x8000;
     e3c:	e3a02902 	mov	r2, #32768	; 0x8000
     e40:	e5963008 	ldr	r3, [r6, #8]
     e44:	e5832004 	str	r2, [r3, #4]
     e48:	eafffff7 	b	e2c <pthread_create+0x26c>
  {
    memcpy (new -> attributs, attr, sizeof (pthread_attr_t));

    if (attr -> name == NULL)
     {
      new -> attributs -> name = (char *) malloc (32);
     e4c:	e3a00020 	mov	r0, #32
     e50:	eb00376b 	bl	ec04 <malloc>
      sprintf (new -> attributs -> name, "%s_%ld", default_name, index ++);
     e54:	e59fc044 	ldr	ip, [pc, #68]	; ea0 <pthread_create+0x2e0>
     e58:	e59f1044 	ldr	r1, [pc, #68]	; ea4 <pthread_create+0x2e4>
     e5c:	e59c3000 	ldr	r3, [ip]
     e60:	e59f2040 	ldr	r2, [pc, #64]	; ea8 <pthread_create+0x2e8>
     e64:	e283e001 	add	lr, r3, #1
  {
    memcpy (new -> attributs, attr, sizeof (pthread_attr_t));

    if (attr -> name == NULL)
     {
      new -> attributs -> name = (char *) malloc (32);
     e68:	e5850024 	str	r0, [r5, #36]	; 0x24
      sprintf (new -> attributs -> name, "%s_%ld", default_name, index ++);
     e6c:	e58ce000 	str	lr, [ip]
     e70:	eb003e7a 	bl	10860 <sprintf>
     e74:	eaffff7e 	b	c74 <pthread_create+0xb4>
     e78:	000232fc 	.word	0x000232fc
     e7c:	ffffd15a 	.word	0xffffd15a
     e80:	00022da8 	.word	0x00022da8
     e84:	00022d00 	.word	0x00022d00
     e88:	0002324c 	.word	0x0002324c
     e8c:	0002323c 	.word	0x0002323c
     e90:	000232b8 	.word	0x000232b8
     e94:	000232d4 	.word	0x000232d4
     e98:	000232dc 	.word	0x000232dc
     e9c:	000232cc 	.word	0x000232cc
     ea0:	0003556c 	.word	0x0003556c
     ea4:	000232ec 	.word	0x000232ec
     ea8:	000232f4 	.word	0x000232f4

00000eac <pthread_attr_destroy>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_destroy(pthread_attr_t *attr)
{
  ASSERT_RETURN (!attr, EINVAL);
     eac:	e3500000 	cmp	r0, #0
     eb0:	0a000001 	beq	ebc <pthread_attr_destroy+0x10>

  return 0;
     eb4:	e3a00000 	mov	r0, #0
     eb8:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_destroy(pthread_attr_t *attr)
{
     ebc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN (!attr, EINVAL);
     ec0:	e59f3024 	ldr	r3, [pc, #36]	; eec <pthread_attr_destroy+0x40>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_destroy(pthread_attr_t *attr)
{
     ec4:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN (!attr, EINVAL);
     ec8:	e58d3000 	str	r3, [sp]
     ecc:	e59f101c 	ldr	r1, [pc, #28]	; ef0 <pthread_attr_destroy+0x44>
     ed0:	e59f201c 	ldr	r2, [pc, #28]	; ef4 <pthread_attr_destroy+0x48>
     ed4:	e59f301c 	ldr	r3, [pc, #28]	; ef8 <pthread_attr_destroy+0x4c>
     ed8:	e59f001c 	ldr	r0, [pc, #28]	; efc <pthread_attr_destroy+0x50>
     edc:	eb003c3c 	bl	ffd4 <printf>
     ee0:	e3a00016 	mov	r0, #22

  return 0;
}
     ee4:	e28dd00c 	add	sp, sp, #12
     ee8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     eec:	00022da8 	.word	0x00022da8
     ef0:	0002331c 	.word	0x0002331c
     ef4:	00023304 	.word	0x00023304
     ef8:	0002319c 	.word	0x0002319c
     efc:	00022d00 	.word	0x00022d00

00000f00 <pthread_self>:

  return pself;
#endif

  return NULL;
}
     f00:	e3a00000 	mov	r0, #0
     f04:	e12fff1e 	bx	lr

00000f08 <pthread_spin_init>:
#include <Private/Macros.h>

int pthread_spin_init(pthread_spinlock_t *spin, int pshared)
{
  return 0;
}
     f08:	e3a00000 	mov	r0, #0
     f0c:	e12fff1e 	bx	lr

00000f10 <pthread_join>:
#include <stdio.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_join(pthread_t thread, void **value_ptr)
{
     f10:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  unsigned int status = 0;

  ASSERT_RETURN (thread == NULL, EINVAL);
     f14:	e3500000 	cmp	r0, #0
#include <stdio.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_join(pthread_t thread, void **value_ptr)
{
     f18:	e24dd00c 	sub	sp, sp, #12
  unsigned int status = 0;

  ASSERT_RETURN (thread == NULL, EINVAL);
     f1c:	0a000004 	beq	f34 <pthread_join+0x24>

  thread_wait (thread -> tid, (int32_t *) value_ptr);
     f20:	e590000c 	ldr	r0, [r0, #12]
     f24:	eb002383 	bl	9d38 <thread_wait>
  return status;
     f28:	e3a00000 	mov	r0, #0
}
     f2c:	e28dd00c 	add	sp, sp, #12
     f30:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

int pthread_join(pthread_t thread, void **value_ptr)
{
  unsigned int status = 0;

  ASSERT_RETURN (thread == NULL, EINVAL);
     f34:	e59f3020 	ldr	r3, [pc, #32]	; f5c <pthread_join+0x4c>
     f38:	e59f1020 	ldr	r1, [pc, #32]	; f60 <pthread_join+0x50>
     f3c:	e58d3000 	str	r3, [sp]
     f40:	e59f201c 	ldr	r2, [pc, #28]	; f64 <pthread_join+0x54>
     f44:	e59f301c 	ldr	r3, [pc, #28]	; f68 <pthread_join+0x58>
     f48:	e59f001c 	ldr	r0, [pc, #28]	; f6c <pthread_join+0x5c>
     f4c:	eb003c20 	bl	ffd4 <printf>
     f50:	e3a00016 	mov	r0, #22

  thread_wait (thread -> tid, (int32_t *) value_ptr);
  return status;
}
     f54:	e28dd00c 	add	sp, sp, #12
     f58:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     f5c:	00022da8 	.word	0x00022da8
     f60:	000233a0 	.word	0x000233a0
     f64:	00023390 	.word	0x00023390
     f68:	00023030 	.word	0x00023030
     f6c:	00022d00 	.word	0x00022d00

00000f70 <pthread_mutex_trylock>:
#include <Private/PosixThreads.h>

int pthread_mutex_trylock(pthread_mutex_t *mutex)
{
     f70:	e92d4010 	push	{r4, lr}
  if (mutex == NULL) return EFAULT;
     f74:	e2504000 	subs	r4, r0, #0
#include <Private/PosixThreads.h>

int pthread_mutex_trylock(pthread_mutex_t *mutex)
{
     f78:	e24dd008 	sub	sp, sp, #8
  if (mutex == NULL) return EFAULT;
     f7c:	03a0000e 	moveq	r0, #14
     f80:	0a000003 	beq	f94 <pthread_mutex_trylock+0x24>
  if (mutex -> lock == -1) return EINVAL;
     f84:	e5940008 	ldr	r0, [r4, #8]
     f88:	e3700001 	cmn	r0, #1
     f8c:	03a00016 	moveq	r0, #22
     f90:	1a000001 	bne	f9c <pthread_mutex_trylock+0x2c>
    default :
      return EINVAL;
  }

  return 0;
}
     f94:	e28dd008 	add	sp, sp, #8
     f98:	e8bd8010 	pop	{r4, pc}
int pthread_mutex_trylock(pthread_mutex_t *mutex)
{
  if (mutex == NULL) return EFAULT;
  if (mutex -> lock == -1) return EINVAL;

  switch (semaphore_acquire (mutex -> lock, 1, DNA_RELATIVE_TIMEOUT, 0))
     f9c:	e3a02000 	mov	r2, #0
     fa0:	e3a03000 	mov	r3, #0
     fa4:	e3a01001 	mov	r1, #1
     fa8:	e1cd20f0 	strd	r2, [sp]
     fac:	e3a02002 	mov	r2, #2
     fb0:	eb002985 	bl	b5cc <semaphore_acquire>
     fb4:	e3500000 	cmp	r0, #0
     fb8:	0a000005 	beq	fd4 <pthread_mutex_trylock+0x64>
     fbc:	e59f301c 	ldr	r3, [pc, #28]	; fe0 <pthread_mutex_trylock+0x70>
    case DNA_OK :
      mutex -> status = MUTEX_LOCKED;
      return 0;

    default :
      return EINVAL;
     fc0:	e1500003 	cmp	r0, r3
     fc4:	03a00010 	moveq	r0, #16
     fc8:	13a00016 	movne	r0, #22
  }

  return 0;
}
     fcc:	e28dd008 	add	sp, sp, #8
     fd0:	e8bd8010 	pop	{r4, pc}
  {
    case DNA_WOULD_BLOCK :
      return EBUSY;

    case DNA_OK :
      mutex -> status = MUTEX_LOCKED;
     fd4:	e3a03001 	mov	r3, #1
     fd8:	e5843004 	str	r3, [r4, #4]
      return 0;
     fdc:	eaffffec 	b	f94 <pthread_mutex_trylock+0x24>
     fe0:	0000fdfd 	.word	0x0000fdfd

00000fe4 <pthread_mutex_init>:
#include <Private/PosixThreads.h>

int pthread_mutex_init (pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)
{
     fe4:	e92d4010 	push	{r4, lr}
  static int32_t index = 0;
  char name[32];
  status_t status = DNA_OK;

//  printf("MUTEX=%x\n", mutex);
  if (mutex == NULL) return EFAULT;
     fe8:	e2504000 	subs	r4, r0, #0
#include <Private/PosixThreads.h>

int pthread_mutex_init (pthread_mutex_t *mutex, const pthread_mutexattr_t *attr)
{
     fec:	e24dd020 	sub	sp, sp, #32
  static int32_t index = 0;
  char name[32];
  status_t status = DNA_OK;

//  printf("MUTEX=%x\n", mutex);
  if (mutex == NULL) return EFAULT;
     ff0:	03a0000e 	moveq	r0, #14
     ff4:	0a000010 	beq	103c <pthread_mutex_init+0x58>

  sprintf (name, "pthread_mutex_%ld", index ++);
     ff8:	e59f3054 	ldr	r3, [pc, #84]	; 1054 <pthread_mutex_init+0x70>
     ffc:	e59f1054 	ldr	r1, [pc, #84]	; 1058 <pthread_mutex_init+0x74>
    1000:	e5932000 	ldr	r2, [r3]
    1004:	e1a0000d 	mov	r0, sp
    1008:	e282c001 	add	ip, r2, #1
    100c:	e583c000 	str	ip, [r3]
    1010:	eb003e12 	bl	10860 <sprintf>
  status = semaphore_create (name, 1, & mutex -> lock);
    1014:	e1a0000d 	mov	r0, sp
    1018:	e2842008 	add	r2, r4, #8
    101c:	e3a01001 	mov	r1, #1
    1020:	eb002d87 	bl	c644 <semaphore_create>

  if(status == DNA_NO_MORE_SEM) dna_printf("No more semaphores\n");
    1024:	e59f3030 	ldr	r3, [pc, #48]	; 105c <pthread_mutex_init+0x78>
    1028:	e1500003 	cmp	r0, r3
    102c:	0a000004 	beq	1044 <pthread_mutex_init+0x60>

  if (status != DNA_OK) return EINVAL;
  return 0;
    1030:	e3500000 	cmp	r0, #0
    1034:	13a00016 	movne	r0, #22
    1038:	03a00000 	moveq	r0, #0
}
    103c:	e28dd020 	add	sp, sp, #32
    1040:	e8bd8010 	pop	{r4, pc}
  if (mutex == NULL) return EFAULT;

  sprintf (name, "pthread_mutex_%ld", index ++);
  status = semaphore_create (name, 1, & mutex -> lock);

  if(status == DNA_NO_MORE_SEM) dna_printf("No more semaphores\n");
    1044:	e59f0014 	ldr	r0, [pc, #20]	; 1060 <pthread_mutex_init+0x7c>
    1048:	eb001ecf 	bl	8b8c <dna_printf>

  if (status != DNA_OK) return EINVAL;
    104c:	e3a00016 	mov	r0, #22
    1050:	eafffff9 	b	103c <pthread_mutex_init+0x58>
    1054:	00035570 	.word	0x00035570
    1058:	0002340c 	.word	0x0002340c
    105c:	0000fdfe 	.word	0x0000fdfe
    1060:	00023420 	.word	0x00023420

00001064 <pthread_attr_setschedparam>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setschedparam(pthread_attr_t *attr, const sched_param_t *param)
{
  ASSERT_RETURN(!attr || !param,EINVAL);
    1064:	e3510000 	cmp	r1, #0
    1068:	13500000 	cmpne	r0, #0
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setschedparam(pthread_attr_t *attr, const sched_param_t *param)
{
    106c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!attr || !param,EINVAL);
    1070:	e1a03000 	mov	r3, r0
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setschedparam(pthread_attr_t *attr, const sched_param_t *param)
{
    1074:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!attr || !param,EINVAL);
    1078:	03a00001 	moveq	r0, #1
    107c:	13a00000 	movne	r0, #0
    1080:	1a000009 	bne	10ac <pthread_attr_setschedparam+0x48>
    1084:	e59f3040 	ldr	r3, [pc, #64]	; 10cc <pthread_attr_setschedparam+0x68>
    1088:	e59f1040 	ldr	r1, [pc, #64]	; 10d0 <pthread_attr_setschedparam+0x6c>
    108c:	e58d3000 	str	r3, [sp]
    1090:	e59f203c 	ldr	r2, [pc, #60]	; 10d4 <pthread_attr_setschedparam+0x70>
    1094:	e59f303c 	ldr	r3, [pc, #60]	; 10d8 <pthread_attr_setschedparam+0x74>
    1098:	e59f003c 	ldr	r0, [pc, #60]	; 10dc <pthread_attr_setschedparam+0x78>
    109c:	eb003bcc 	bl	ffd4 <printf>
    10a0:	e3a00016 	mov	r0, #22

  memcpy(&attr->schedparam, param, sizeof(*param));
  return 0;
}
    10a4:	e28dd00c 	add	sp, sp, #12
    10a8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

int pthread_attr_setschedparam(pthread_attr_t *attr, const sched_param_t *param)
{
  ASSERT_RETURN(!attr || !param,EINVAL);

  memcpy(&attr->schedparam, param, sizeof(*param));
    10ac:	e591e000 	ldr	lr, [r1]
    10b0:	e591c004 	ldr	ip, [r1, #4]
    10b4:	e5911008 	ldr	r1, [r1, #8]
    10b8:	e583e018 	str	lr, [r3, #24]
    10bc:	e583c01c 	str	ip, [r3, #28]
    10c0:	e5831020 	str	r1, [r3, #32]
  return 0;
}
    10c4:	e28dd00c 	add	sp, sp, #12
    10c8:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    10cc:	00022da8 	.word	0x00022da8
    10d0:	00023450 	.word	0x00023450
    10d4:	00023434 	.word	0x00023434
    10d8:	000234c8 	.word	0x000234c8
    10dc:	00022d00 	.word	0x00022d00

000010e0 <pthread_attr_getschedpolicy>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy)
{
  ASSERT_RETURN (! attr || ! policy, EINVAL);
    10e0:	e3510000 	cmp	r1, #0
    10e4:	13500000 	cmpne	r0, #0
    10e8:	e1a03000 	mov	r3, r0
    10ec:	03a00001 	moveq	r0, #1
    10f0:	13a00000 	movne	r0, #0
    10f4:	0a000002 	beq	1104 <pthread_attr_getschedpolicy+0x24>

  *policy = attr -> schedpolicy;
    10f8:	e5933010 	ldr	r3, [r3, #16]
    10fc:	e5813000 	str	r3, [r1]
  return 0;
    1100:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy)
{
    1104:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN (! attr || ! policy, EINVAL);
    1108:	e59f3024 	ldr	r3, [pc, #36]	; 1134 <pthread_attr_getschedpolicy+0x54>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getschedpolicy(const pthread_attr_t *attr, int *policy)
{
    110c:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN (! attr || ! policy, EINVAL);
    1110:	e58d3000 	str	r3, [sp]
    1114:	e59f101c 	ldr	r1, [pc, #28]	; 1138 <pthread_attr_getschedpolicy+0x58>
    1118:	e59f201c 	ldr	r2, [pc, #28]	; 113c <pthread_attr_getschedpolicy+0x5c>
    111c:	e59f301c 	ldr	r3, [pc, #28]	; 1140 <pthread_attr_getschedpolicy+0x60>
    1120:	e59f001c 	ldr	r0, [pc, #28]	; 1144 <pthread_attr_getschedpolicy+0x64>
    1124:	eb003baa 	bl	ffd4 <printf>
    1128:	e3a00016 	mov	r0, #22

  *policy = attr -> schedpolicy;
  return 0;
}
    112c:	e28dd00c 	add	sp, sp, #12
    1130:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    1134:	00022da8 	.word	0x00022da8
    1138:	000234f4 	.word	0x000234f4
    113c:	000234d8 	.word	0x000234d8
    1140:	00023570 	.word	0x00023570
    1144:	00022d00 	.word	0x00022d00

00001148 <pthread_exit>:
#include <Private/PosixThreads.h>

void pthread_exit(void *retval)
{
    1148:	e12fff1e 	bx	lr

0000114c <pthread_attr_setschedpolicy>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
{
  ASSERT_RETURN(!attr,EINVAL);
    114c:	e2503000 	subs	r3, r0, #0
    1150:	0a000002 	beq	1160 <pthread_attr_setschedpolicy+0x14>

  attr->schedpolicy = policy;
  return 0;
    1154:	e3a00000 	mov	r0, #0

int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
{
  ASSERT_RETURN(!attr,EINVAL);

  attr->schedpolicy = policy;
    1158:	e5831010 	str	r1, [r3, #16]
  return 0;
    115c:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
{
    1160:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!attr,EINVAL);
    1164:	e59f3024 	ldr	r3, [pc, #36]	; 1190 <pthread_attr_setschedpolicy+0x44>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setschedpolicy(pthread_attr_t *attr, int policy)
{
    1168:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!attr,EINVAL);
    116c:	e58d3000 	str	r3, [sp]
    1170:	e59f101c 	ldr	r1, [pc, #28]	; 1194 <pthread_attr_setschedpolicy+0x48>
    1174:	e59f201c 	ldr	r2, [pc, #28]	; 1198 <pthread_attr_setschedpolicy+0x4c>
    1178:	e59f301c 	ldr	r3, [pc, #28]	; 119c <pthread_attr_setschedpolicy+0x50>
    117c:	e59f001c 	ldr	r0, [pc, #28]	; 11a0 <pthread_attr_setschedpolicy+0x54>
    1180:	eb003b93 	bl	ffd4 <printf>
    1184:	e3a00016 	mov	r0, #22

  attr->schedpolicy = policy;
  return 0;
}
    1188:	e28dd00c 	add	sp, sp, #12
    118c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    1190:	00022da8 	.word	0x00022da8
    1194:	000235a0 	.word	0x000235a0
    1198:	00023584 	.word	0x00023584
    119c:	0002319c 	.word	0x0002319c
    11a0:	00022d00 	.word	0x00022d00

000011a4 <pthread_equal>:
#include <Private/PosixThreads.h>

int pthread_equal(pthread_t thread1, pthread_t thread2)
{
  return thread1 == thread2;
}
    11a4:	e0600001 	rsb	r0, r0, r1
    11a8:	e16f0f10 	clz	r0, r0
    11ac:	e1a002a0 	lsr	r0, r0, #5
    11b0:	e12fff1e 	bx	lr

000011b4 <__libthread_start>:
#include <Private/Macros.h>

extern int main (void);

int __libthread_start (void)
{
    11b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    11b8:	e24dd00c 	sub	sp, sp, #12
  int32_t my_id;
  pthread_t wrapper = malloc (sizeof (struct pthread));

  thread_find (NULL, & my_id);
    11bc:	e28d1004 	add	r1, sp, #4
    11c0:	e3a00000 	mov	r0, #0
    11c4:	eb002f8d 	bl	d000 <thread_find>
  wrapper -> attributs -> detachstate = PTHREAD_CREATE_JOINABLE;
  wrapper -> attributs -> schedinherited = PTHREAD_EXPLICIT_SCHED;
  wrapper -> attributs -> schedpolicy = SCHED_FIFO;
  wrapper -> attributs -> procid = PTHREAD_NOPROCID;

  return main ();
    11c8:	eb000ea3 	bl	4c5c <main>
}
    11cc:	e28dd00c 	add	sp, sp, #12
    11d0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

000011d4 <pthread_cond_init>:
#include <Private/PosixThreads.h>

int pthread_cond_init(pthread_cond_t *condition, pthread_condattr_t *condattr)
{
    11d4:	e92d4010 	push	{r4, lr}
  static int32_t index = 0;
  char name[32];
  status_t status = DNA_OK;

  sprintf (name, "pthread_cond_%ld", index ++);
    11d8:	e59f3060 	ldr	r3, [pc, #96]	; 1240 <pthread_cond_init+0x6c>
#include <Private/PosixThreads.h>

int pthread_cond_init(pthread_cond_t *condition, pthread_condattr_t *condattr)
{
    11dc:	e24dd020 	sub	sp, sp, #32
  static int32_t index = 0;
  char name[32];
  status_t status = DNA_OK;

  sprintf (name, "pthread_cond_%ld", index ++);
    11e0:	e5932000 	ldr	r2, [r3]
#include <Private/PosixThreads.h>

int pthread_cond_init(pthread_cond_t *condition, pthread_condattr_t *condattr)
{
    11e4:	e1a04000 	mov	r4, r0
  static int32_t index = 0;
  char name[32];
  status_t status = DNA_OK;

  sprintf (name, "pthread_cond_%ld", index ++);
    11e8:	e282c001 	add	ip, r2, #1
    11ec:	e59f1050 	ldr	r1, [pc, #80]	; 1244 <pthread_cond_init+0x70>
    11f0:	e1a0000d 	mov	r0, sp
    11f4:	e583c000 	str	ip, [r3]
    11f8:	eb003d98 	bl	10860 <sprintf>
  condition -> count = 0;
    11fc:	e3a01000 	mov	r1, #0
  status = semaphore_create (name, 0, & condition -> semaphore);
    1200:	e1a0000d 	mov	r0, sp
  static int32_t index = 0;
  char name[32];
  status_t status = DNA_OK;

  sprintf (name, "pthread_cond_%ld", index ++);
  condition -> count = 0;
    1204:	e5841004 	str	r1, [r4, #4]
  status = semaphore_create (name, 0, & condition -> semaphore);
    1208:	e1a02004 	mov	r2, r4
    120c:	eb002d0c 	bl	c644 <semaphore_create>

  if (status != DNA_OK)
    1210:	e3500000 	cmp	r0, #0
    1214:	0a000007 	beq	1238 <pthread_cond_init+0x64>
  {
    switch (status)
    1218:	e59f3028 	ldr	r3, [pc, #40]	; 1248 <pthread_cond_init+0x74>
    121c:	e1500003 	cmp	r0, r3
    {
      case DNA_NO_MORE_SEM :
        return EAGAIN;
    1220:	03a0000b 	moveq	r0, #11
  condition -> count = 0;
  status = semaphore_create (name, 0, & condition -> semaphore);

  if (status != DNA_OK)
  {
    switch (status)
    1224:	0a000003 	beq	1238 <pthread_cond_init+0x64>
    1228:	e59f301c 	ldr	r3, [pc, #28]	; 124c <pthread_cond_init+0x78>
      case DNA_NO_MORE_SEM :
        return EAGAIN;
      case DNA_OUT_OF_MEM :
        return ENOMEM;
      default :
        return EINVAL;
    122c:	e1500003 	cmp	r0, r3
    1230:	03a0000c 	moveq	r0, #12
    1234:	13a00016 	movne	r0, #22
    }
  }

  return 0;
}
    1238:	e28dd020 	add	sp, sp, #32
    123c:	e8bd8010 	pop	{r4, pc}
    1240:	00035574 	.word	0x00035574
    1244:	0002361c 	.word	0x0002361c
    1248:	0000fdfe 	.word	0x0000fdfe
    124c:	0000fffd 	.word	0x0000fffd

00001250 <pthread_getschedparam>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_getschedparam(pthread_t t, int *p, struct sched_param *sp)
{
  ASSERT_RETURN (!t || !sp, EINVAL);
    1250:	e3520000 	cmp	r2, #0
    1254:	13500000 	cmpne	r0, #0
    1258:	03a03001 	moveq	r3, #1
    125c:	13a03000 	movne	r3, #0
    1260:	1a00000b 	bne	1294 <pthread_getschedparam+0x44>
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_getschedparam(pthread_t t, int *p, struct sched_param *sp)
{
    1264:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN (!t || !sp, EINVAL);
    1268:	e59f3054 	ldr	r3, [pc, #84]	; 12c4 <pthread_getschedparam+0x74>
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_getschedparam(pthread_t t, int *p, struct sched_param *sp)
{
    126c:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN (!t || !sp, EINVAL);
    1270:	e58d3000 	str	r3, [sp]
    1274:	e59f104c 	ldr	r1, [pc, #76]	; 12c8 <pthread_getschedparam+0x78>
    1278:	e59f204c 	ldr	r2, [pc, #76]	; 12cc <pthread_getschedparam+0x7c>
    127c:	e59f304c 	ldr	r3, [pc, #76]	; 12d0 <pthread_getschedparam+0x80>
    1280:	e59f004c 	ldr	r0, [pc, #76]	; 12d4 <pthread_getschedparam+0x84>
    1284:	eb003b52 	bl	ffd4 <printf>
    1288:	e3a00016 	mov	r0, #22

  *p = t -> attributs -> schedpolicy;
  memcpy (sp, & t -> attributs -> schedparam, sizeof (*sp));
  return 0;
}
    128c:	e28dd00c 	add	sp, sp, #12
    1290:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

int pthread_getschedparam(pthread_t t, int *p, struct sched_param *sp)
{
  ASSERT_RETURN (!t || !sp, EINVAL);

  *p = t -> attributs -> schedpolicy;
    1294:	e590c008 	ldr	ip, [r0, #8]
  memcpy (sp, & t -> attributs -> schedparam, sizeof (*sp));
  return 0;
    1298:	e1a00003 	mov	r0, r3
int pthread_getschedparam(pthread_t t, int *p, struct sched_param *sp)
{
  ASSERT_RETURN (!t || !sp, EINVAL);

  *p = t -> attributs -> schedpolicy;
  memcpy (sp, & t -> attributs -> schedparam, sizeof (*sp));
    129c:	e1a0300c 	mov	r3, ip

int pthread_getschedparam(pthread_t t, int *p, struct sched_param *sp)
{
  ASSERT_RETURN (!t || !sp, EINVAL);

  *p = t -> attributs -> schedpolicy;
    12a0:	e59cc010 	ldr	ip, [ip, #16]
    12a4:	e581c000 	str	ip, [r1]
  memcpy (sp, & t -> attributs -> schedparam, sizeof (*sp));
    12a8:	e5b3c018 	ldr	ip, [r3, #24]!
    12ac:	e5931004 	ldr	r1, [r3, #4]
    12b0:	e5933008 	ldr	r3, [r3, #8]
    12b4:	e582c000 	str	ip, [r2]
    12b8:	e5821004 	str	r1, [r2, #4]
    12bc:	e5823008 	str	r3, [r2, #8]
  return 0;
    12c0:	e12fff1e 	bx	lr
    12c4:	00022da8 	.word	0x00022da8
    12c8:	00023648 	.word	0x00023648
    12cc:	00023630 	.word	0x00023630
    12d0:	000236bc 	.word	0x000236bc
    12d4:	00022d00 	.word	0x00022d00

000012d8 <pthread_setschedparam>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_setschedparam(pthread_t t, int p, const struct sched_param *sp)
{
  ASSERT_RETURN(!t || !sp,EINVAL);
    12d8:	e3520000 	cmp	r2, #0
    12dc:	13500000 	cmpne	r0, #0
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_setschedparam(pthread_t t, int p, const struct sched_param *sp)
{
    12e0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!t || !sp,EINVAL);
    12e4:	e1a03000 	mov	r3, r0
#include <string.h>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_setschedparam(pthread_t t, int p, const struct sched_param *sp)
{
    12e8:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!t || !sp,EINVAL);
    12ec:	03a00001 	moveq	r0, #1
    12f0:	13a00000 	movne	r0, #0
    12f4:	1a000009 	bne	1320 <pthread_setschedparam+0x48>
    12f8:	e59f3048 	ldr	r3, [pc, #72]	; 1348 <pthread_setschedparam+0x70>
    12fc:	e59f1048 	ldr	r1, [pc, #72]	; 134c <pthread_setschedparam+0x74>
    1300:	e58d3000 	str	r3, [sp]
    1304:	e59f2044 	ldr	r2, [pc, #68]	; 1350 <pthread_setschedparam+0x78>
    1308:	e59f3044 	ldr	r3, [pc, #68]	; 1354 <pthread_setschedparam+0x7c>
    130c:	e59f0044 	ldr	r0, [pc, #68]	; 1358 <pthread_setschedparam+0x80>
    1310:	eb003b2f 	bl	ffd4 <printf>
    1314:	e3a00016 	mov	r0, #22

  t -> attributs -> schedpolicy = p;
  memcpy (& t -> attributs -> schedparam, sp, sizeof(*sp));

  return 0;
}
    1318:	e28dd00c 	add	sp, sp, #12
    131c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
  // FIXME : we need to find out if
  // the thread is still in scheduled
  // => core_search ?
  // It's the same for the _getschedparam counterpart

  t -> attributs -> schedpolicy = p;
    1320:	e5933008 	ldr	r3, [r3, #8]
    1324:	e5831010 	str	r1, [r3, #16]
  memcpy (& t -> attributs -> schedparam, sp, sizeof(*sp));
    1328:	e592e000 	ldr	lr, [r2]
    132c:	e592c004 	ldr	ip, [r2, #4]
    1330:	e5921008 	ldr	r1, [r2, #8]
    1334:	e583e018 	str	lr, [r3, #24]
    1338:	e583c01c 	str	ip, [r3, #28]
    133c:	e5831020 	str	r1, [r3, #32]

  return 0;
}
    1340:	e28dd00c 	add	sp, sp, #12
    1344:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    1348:	00022da8 	.word	0x00022da8
    134c:	000236e0 	.word	0x000236e0
    1350:	000236c8 	.word	0x000236c8
    1354:	000236bc 	.word	0x000236bc
    1358:	00022d00 	.word	0x00022d00

0000135c <pthread_mutex_unlock>:
#include <Private/PosixThreads.h>

int pthread_mutex_unlock (pthread_mutex_t *mutex)
{
  if (mutex == NULL) return EFAULT;
    135c:	e2503000 	subs	r3, r0, #0
    1360:	0a00000c 	beq	1398 <pthread_mutex_unlock+0x3c>
  if (mutex -> lock == -1) return EINVAL;
    1364:	e5930008 	ldr	r0, [r3, #8]
    1368:	e3700001 	cmn	r0, #1
    136c:	1a000001 	bne	1378 <pthread_mutex_unlock+0x1c>
    1370:	e3a00016 	mov	r0, #22
    1374:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>

int pthread_mutex_unlock (pthread_mutex_t *mutex)
{
    1378:	e92d4010 	push	{r4, lr}
  if (mutex == NULL) return EFAULT;
  if (mutex -> lock == -1) return EINVAL;

  mutex -> status = MUTEX_UNLOCKED;
    137c:	e3a04000 	mov	r4, #0
  semaphore_release (mutex -> lock, 1, 0);
    1380:	e3a01001 	mov	r1, #1
int pthread_mutex_unlock (pthread_mutex_t *mutex)
{
  if (mutex == NULL) return EFAULT;
  if (mutex -> lock == -1) return EINVAL;

  mutex -> status = MUTEX_UNLOCKED;
    1384:	e5834004 	str	r4, [r3, #4]
  semaphore_release (mutex -> lock, 1, 0);
    1388:	e1a02004 	mov	r2, r4
    138c:	eb002d4f 	bl	c8d0 <semaphore_release>

  return 0;
    1390:	e1a00004 	mov	r0, r4
    1394:	e8bd8010 	pop	{r4, pc}
#include <Private/PosixThreads.h>

int pthread_mutex_unlock (pthread_mutex_t *mutex)
{
  if (mutex == NULL) return EFAULT;
    1398:	e3a0000e 	mov	r0, #14
    139c:	e12fff1e 	bx	lr

000013a0 <pthread_attr_setinheritsched>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setinheritsched(pthread_attr_t *attr, int h)
{
  ASSERT_RETURN(!attr,EINVAL);
    13a0:	e2503000 	subs	r3, r0, #0
    13a4:	0a000002 	beq	13b4 <pthread_attr_setinheritsched+0x14>

  attr->schedinherited = h;
  return 0;
    13a8:	e3a00000 	mov	r0, #0

int pthread_attr_setinheritsched(pthread_attr_t *attr, int h)
{
  ASSERT_RETURN(!attr,EINVAL);

  attr->schedinherited = h;
    13ac:	e583100c 	str	r1, [r3, #12]
  return 0;
    13b0:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setinheritsched(pthread_attr_t *attr, int h)
{
    13b4:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!attr,EINVAL);
    13b8:	e59f3024 	ldr	r3, [pc, #36]	; 13e4 <pthread_attr_setinheritsched+0x44>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setinheritsched(pthread_attr_t *attr, int h)
{
    13bc:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!attr,EINVAL);
    13c0:	e58d3000 	str	r3, [sp]
    13c4:	e59f101c 	ldr	r1, [pc, #28]	; 13e8 <pthread_attr_setinheritsched+0x48>
    13c8:	e59f201c 	ldr	r2, [pc, #28]	; 13ec <pthread_attr_setinheritsched+0x4c>
    13cc:	e59f301c 	ldr	r3, [pc, #28]	; 13f0 <pthread_attr_setinheritsched+0x50>
    13d0:	e59f001c 	ldr	r0, [pc, #28]	; 13f4 <pthread_attr_setinheritsched+0x54>
    13d4:	eb003afe 	bl	ffd4 <printf>
    13d8:	e3a00016 	mov	r0, #22

  attr->schedinherited = h;
  return 0;
}
    13dc:	e28dd00c 	add	sp, sp, #12
    13e0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    13e4:	00022da8 	.word	0x00022da8
    13e8:	00023774 	.word	0x00023774
    13ec:	00023754 	.word	0x00023754
    13f0:	0002319c 	.word	0x0002319c
    13f4:	00022d00 	.word	0x00022d00

000013f8 <pthread_setcancelstate>:
  if (oldstate != NULL) *oldstate = self -> cancel_state;
  self -> cancel_state = state;
#endif

  return 0;
}
    13f8:	e3a00000 	mov	r0, #0
    13fc:	e12fff1e 	bx	lr

00001400 <pthread_attr_setstacksize>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size)
{
  ASSERT_RETURN(!attr || size == 0,EINVAL);
    1400:	e3510000 	cmp	r1, #0
    1404:	13500000 	cmpne	r0, #0
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size)
{
    1408:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!attr || size == 0,EINVAL);
    140c:	e1a03000 	mov	r3, r0
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size)
{
    1410:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!attr || size == 0,EINVAL);
    1414:	0a00000e 	beq	1454 <pthread_attr_setstacksize+0x54>
  ASSERT_RETURN(size%4,EINVAL);
    1418:	e2110003 	ands	r0, r1, #3
  attr->stacksize = size;
    141c:	05831004 	streq	r1, [r3, #4]
#include <Private/Macros.h>

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size)
{
  ASSERT_RETURN(!attr || size == 0,EINVAL);
  ASSERT_RETURN(size%4,EINVAL);
    1420:	1a000001 	bne	142c <pthread_attr_setstacksize+0x2c>
  attr->stacksize = size;
  return 0;
}
    1424:	e28dd00c 	add	sp, sp, #12
    1428:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
#include <Private/Macros.h>

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size)
{
  ASSERT_RETURN(!attr || size == 0,EINVAL);
  ASSERT_RETURN(size%4,EINVAL);
    142c:	e59f3048 	ldr	r3, [pc, #72]	; 147c <pthread_attr_setstacksize+0x7c>
    1430:	e59f1048 	ldr	r1, [pc, #72]	; 1480 <pthread_attr_setstacksize+0x80>
    1434:	e58d3000 	str	r3, [sp]
    1438:	e59f2044 	ldr	r2, [pc, #68]	; 1484 <pthread_attr_setstacksize+0x84>
    143c:	e59f3044 	ldr	r3, [pc, #68]	; 1488 <pthread_attr_setstacksize+0x88>
    1440:	e59f0044 	ldr	r0, [pc, #68]	; 148c <pthread_attr_setstacksize+0x8c>
    1444:	eb003ae2 	bl	ffd4 <printf>
    1448:	e3a00016 	mov	r0, #22
  attr->stacksize = size;
  return 0;
}
    144c:	e28dd00c 	add	sp, sp, #12
    1450:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size)
{
  ASSERT_RETURN(!attr || size == 0,EINVAL);
    1454:	e59f3020 	ldr	r3, [pc, #32]	; 147c <pthread_attr_setstacksize+0x7c>
    1458:	e59f1020 	ldr	r1, [pc, #32]	; 1480 <pthread_attr_setstacksize+0x80>
    145c:	e58d3000 	str	r3, [sp]
    1460:	e59f201c 	ldr	r2, [pc, #28]	; 1484 <pthread_attr_setstacksize+0x84>
    1464:	e59f3024 	ldr	r3, [pc, #36]	; 1490 <pthread_attr_setstacksize+0x90>
    1468:	e59f001c 	ldr	r0, [pc, #28]	; 148c <pthread_attr_setstacksize+0x8c>
    146c:	eb003ad8 	bl	ffd4 <printf>
    1470:	e3a00016 	mov	r0, #22
  ASSERT_RETURN(size%4,EINVAL);
  attr->stacksize = size;
  return 0;
}
    1474:	e28dd00c 	add	sp, sp, #12
    1478:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    147c:	00022da8 	.word	0x00022da8
    1480:	0002380c 	.word	0x0002380c
    1484:	000237f0 	.word	0x000237f0
    1488:	00023898 	.word	0x00023898
    148c:	00022d00 	.word	0x00022d00
    1490:	00023884 	.word	0x00023884

00001494 <pthread_cond_timedwait>:
#include <Private/PosixThreads.h>

int pthread_cond_timedwait(pthread_cond_t *condition, pthread_mutex_t *mutex, const struct timespec *abstime)
{
  return 0;
}
    1494:	e3a00000 	mov	r0, #0
    1498:	e12fff1e 	bx	lr

0000149c <pthread_attr_getdetachstate>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *state)
{
  ASSERT_RETURN (!attr || !state,EINVAL);
    149c:	e3510000 	cmp	r1, #0
    14a0:	13500000 	cmpne	r0, #0
    14a4:	e1a03000 	mov	r3, r0
    14a8:	03a00001 	moveq	r0, #1
    14ac:	13a00000 	movne	r0, #0
    14b0:	0a000002 	beq	14c0 <pthread_attr_getdetachstate+0x24>
  *state = attr -> detachstate;
    14b4:	e5933008 	ldr	r3, [r3, #8]
    14b8:	e5813000 	str	r3, [r1]

  return 0;
    14bc:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *state)
{
    14c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN (!attr || !state,EINVAL);
    14c4:	e59f3024 	ldr	r3, [pc, #36]	; 14f0 <pthread_attr_getdetachstate+0x54>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *state)
{
    14c8:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN (!attr || !state,EINVAL);
    14cc:	e58d3000 	str	r3, [sp]
    14d0:	e59f101c 	ldr	r1, [pc, #28]	; 14f4 <pthread_attr_getdetachstate+0x58>
    14d4:	e59f201c 	ldr	r2, [pc, #28]	; 14f8 <pthread_attr_getdetachstate+0x5c>
    14d8:	e59f301c 	ldr	r3, [pc, #28]	; 14fc <pthread_attr_getdetachstate+0x60>
    14dc:	e59f001c 	ldr	r0, [pc, #28]	; 1500 <pthread_attr_getdetachstate+0x64>
    14e0:	eb003abb 	bl	ffd4 <printf>
    14e4:	e3a00016 	mov	r0, #22
  *state = attr -> detachstate;

  return 0;
}
    14e8:	e28dd00c 	add	sp, sp, #12
    14ec:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    14f0:	00022da8 	.word	0x00022da8
    14f4:	000238bc 	.word	0x000238bc
    14f8:	000238a0 	.word	0x000238a0
    14fc:	00023938 	.word	0x00023938
    1500:	00022d00 	.word	0x00022d00

00001504 <pthread_barrier_wait>:
  }

  lock_release(barrier -> sem);
#endif
  return res;
}
    1504:	e3a00000 	mov	r0, #0
    1508:	e12fff1e 	bx	lr

0000150c <pthread_cond_signal>:
#include <Private/PosixThreads.h>

int pthread_cond_signal(pthread_cond_t *condition)
{
    150c:	e92d4008 	push	{r3, lr}
  status_t status = DNA_OK;

  if (condition -> count > 0)
    1510:	e5903004 	ldr	r3, [r0, #4]
    1514:	e3530000 	cmp	r3, #0
    1518:	da000008 	ble	1540 <pthread_cond_signal+0x34>
  {
    status = semaphore_release (condition -> semaphore, 1, 0);
    151c:	e3a01001 	mov	r1, #1
    1520:	e3a02000 	mov	r2, #0
    1524:	e5900000 	ldr	r0, [r0]
    1528:	eb002ce8 	bl	c8d0 <semaphore_release>
    if (status == DNA_BAD_SEM_ID) return EINVAL;
    152c:	e59f3014 	ldr	r3, [pc, #20]	; 1548 <pthread_cond_signal+0x3c>
  }

  return 0;
    1530:	e1500003 	cmp	r0, r3
    1534:	03a00016 	moveq	r0, #22
    1538:	13a00000 	movne	r0, #0
    153c:	e8bd8008 	pop	{r3, pc}
    1540:	e3a00000 	mov	r0, #0
}
    1544:	e8bd8008 	pop	{r3, pc}
    1548:	0000fdff 	.word	0x0000fdff

0000154c <pthread_attr_setstackaddr>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setstackaddr(pthread_attr_t *attr, void *addr)
{
  ASSERT_RETURN(!attr || addr == NULL,EINVAL);
    154c:	e3510000 	cmp	r1, #0
    1550:	13500000 	cmpne	r0, #0
    1554:	e1a03000 	mov	r3, r0
    1558:	03a00001 	moveq	r0, #1
    155c:	13a00000 	movne	r0, #0
    1560:	0a000001 	beq	156c <pthread_attr_setstackaddr+0x20>

  attr->stackaddr = addr;
    1564:	e5831000 	str	r1, [r3]
  return 0;
    1568:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setstackaddr(pthread_attr_t *attr, void *addr)
{
    156c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN(!attr || addr == NULL,EINVAL);
    1570:	e59f3024 	ldr	r3, [pc, #36]	; 159c <pthread_attr_setstackaddr+0x50>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_setstackaddr(pthread_attr_t *attr, void *addr)
{
    1574:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN(!attr || addr == NULL,EINVAL);
    1578:	e58d3000 	str	r3, [sp]
    157c:	e59f101c 	ldr	r1, [pc, #28]	; 15a0 <pthread_attr_setstackaddr+0x54>
    1580:	e59f201c 	ldr	r2, [pc, #28]	; 15a4 <pthread_attr_setstackaddr+0x58>
    1584:	e59f301c 	ldr	r3, [pc, #28]	; 15a8 <pthread_attr_setstackaddr+0x5c>
    1588:	e59f001c 	ldr	r0, [pc, #28]	; 15ac <pthread_attr_setstackaddr+0x60>
    158c:	eb003a90 	bl	ffd4 <printf>
    1590:	e3a00016 	mov	r0, #22

  attr->stackaddr = addr;
  return 0;
}
    1594:	e28dd00c 	add	sp, sp, #12
    1598:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    159c:	00022da8 	.word	0x00022da8
    15a0:	00023964 	.word	0x00023964
    15a4:	00023948 	.word	0x00023948
    15a8:	000239dc 	.word	0x000239dc
    15ac:	00022d00 	.word	0x00022d00

000015b0 <pthread_cond_wait>:

int pthread_cond_wait (pthread_cond_t *condition, pthread_mutex_t *mutex)
{
  status_t status = DNA_OK;

  status = semaphore_acquire (condition -> semaphore, 1, DNA_RELATIVE_TIMEOUT, 0);
    15b0:	e3a03000 	mov	r3, #0
    15b4:	e3a02000 	mov	r2, #0
#include <Private/PosixThreads.h>

int pthread_cond_wait (pthread_cond_t *condition, pthread_mutex_t *mutex)
{
    15b8:	e92d4030 	push	{r4, r5, lr}
    15bc:	e24dd00c 	sub	sp, sp, #12
    15c0:	e1a04000 	mov	r4, r0
    15c4:	e1a05001 	mov	r5, r1
  status_t status = DNA_OK;

  status = semaphore_acquire (condition -> semaphore, 1, DNA_RELATIVE_TIMEOUT, 0);
    15c8:	e5900000 	ldr	r0, [r0]
    15cc:	e3a01001 	mov	r1, #1
    15d0:	e1cd20f0 	strd	r2, [sp]
    15d4:	e3a02002 	mov	r2, #2
    15d8:	eb0027fb 	bl	b5cc <semaphore_acquire>

  if (status == DNA_WOULD_BLOCK)
    15dc:	e59f3060 	ldr	r3, [pc, #96]	; 1644 <pthread_cond_wait+0x94>
    15e0:	e1500003 	cmp	r0, r3
    15e4:	0a000002 	beq	15f4 <pthread_cond_wait+0x44>

    condition -> count -= 1;
  }

  return 0;
}
    15e8:	e3a00000 	mov	r0, #0
    15ec:	e28dd00c 	add	sp, sp, #12
    15f0:	e8bd8030 	pop	{r4, r5, pc}

  status = semaphore_acquire (condition -> semaphore, 1, DNA_RELATIVE_TIMEOUT, 0);

  if (status == DNA_WOULD_BLOCK)
  {
    condition -> count += 1;
    15f4:	e5943004 	ldr	r3, [r4, #4]
    pthread_mutex_unlock (mutex);
    15f8:	e1a00005 	mov	r0, r5

  status = semaphore_acquire (condition -> semaphore, 1, DNA_RELATIVE_TIMEOUT, 0);

  if (status == DNA_WOULD_BLOCK)
  {
    condition -> count += 1;
    15fc:	e2833001 	add	r3, r3, #1
    1600:	e5843004 	str	r3, [r4, #4]
    pthread_mutex_unlock (mutex);
    1604:	ebffff54 	bl	135c <pthread_mutex_unlock>

    status = semaphore_acquire (condition -> semaphore, 1, 0, -1);
    1608:	e3e03000 	mvn	r3, #0
    160c:	e3e02000 	mvn	r2, #0
    1610:	e5940000 	ldr	r0, [r4]
    1614:	e3a01001 	mov	r1, #1
    1618:	e1cd20f0 	strd	r2, [sp]
    161c:	e3a02000 	mov	r2, #0
    1620:	eb0027e9 	bl	b5cc <semaphore_acquire>
    pthread_mutex_lock (mutex);
    1624:	e1a00005 	mov	r0, r5
    1628:	ebfffc71 	bl	7f4 <pthread_mutex_lock>

    condition -> count -= 1;
  }

  return 0;
}
    162c:	e3a00000 	mov	r0, #0
    pthread_mutex_unlock (mutex);

    status = semaphore_acquire (condition -> semaphore, 1, 0, -1);
    pthread_mutex_lock (mutex);

    condition -> count -= 1;
    1630:	e5943004 	ldr	r3, [r4, #4]
    1634:	e2433001 	sub	r3, r3, #1
    1638:	e5843004 	str	r3, [r4, #4]
  }

  return 0;
}
    163c:	e28dd00c 	add	sp, sp, #12
    1640:	e8bd8030 	pop	{r4, r5, pc}
    1644:	0000fdfd 	.word	0x0000fdfd

00001648 <pthread_spin_destroy>:

int pthread_spin_destroy(pthread_spinlock_t *spin)
{
  /* Quite bright indeed */
  return 0;
}
    1648:	e3a00000 	mov	r0, #0
    164c:	e12fff1e 	bx	lr

00001650 <pthread_attr_getstackaddr>:
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getstackaddr(const pthread_attr_t *attr, void **addr)
{
  ASSERT_RETURN (! attr || ! addr,EINVAL);
    1650:	e3510000 	cmp	r1, #0
    1654:	13500000 	cmpne	r0, #0
    1658:	e1a03000 	mov	r3, r0
    165c:	03a00001 	moveq	r0, #1
    1660:	13a00000 	movne	r0, #0
    1664:	0a000002 	beq	1674 <pthread_attr_getstackaddr+0x24>

  *addr = attr -> stackaddr;
    1668:	e5933000 	ldr	r3, [r3]
    166c:	e5813000 	str	r3, [r1]
  return 0;
    1670:	e12fff1e 	bx	lr
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getstackaddr(const pthread_attr_t *attr, void **addr)
{
    1674:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  ASSERT_RETURN (! attr || ! addr,EINVAL);
    1678:	e59f3024 	ldr	r3, [pc, #36]	; 16a4 <pthread_attr_getstackaddr+0x54>
#include <Private/PosixThreads.h>
#include <Private/Macros.h>

int pthread_attr_getstackaddr(const pthread_attr_t *attr, void **addr)
{
    167c:	e24dd00c 	sub	sp, sp, #12
  ASSERT_RETURN (! attr || ! addr,EINVAL);
    1680:	e58d3000 	str	r3, [sp]
    1684:	e59f101c 	ldr	r1, [pc, #28]	; 16a8 <pthread_attr_getstackaddr+0x58>
    1688:	e59f201c 	ldr	r2, [pc, #28]	; 16ac <pthread_attr_getstackaddr+0x5c>
    168c:	e59f301c 	ldr	r3, [pc, #28]	; 16b0 <pthread_attr_getstackaddr+0x60>
    1690:	e59f001c 	ldr	r0, [pc, #28]	; 16b4 <pthread_attr_getstackaddr+0x64>
    1694:	eb003a4e 	bl	ffd4 <printf>
    1698:	e3a00016 	mov	r0, #22

  *addr = attr -> stackaddr;
  return 0;
}
    169c:	e28dd00c 	add	sp, sp, #12
    16a0:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    16a4:	00022da8 	.word	0x00022da8
    16a8:	00023a10 	.word	0x00023a10
    16ac:	000239f4 	.word	0x000239f4
    16b0:	00023a88 	.word	0x00023a88
    16b4:	00022d00 	.word	0x00022d00

000016b8 <__libthread_errno>:

  return & pself -> errorno;
#endif

  return & p_errno;
}
    16b8:	e59f0000 	ldr	r0, [pc]	; 16c0 <__libthread_errno+0x8>
    16bc:	e12fff1e 	bx	lr
    16c0:	00035578 	.word	0x00035578

000016c4 <pthread_lock_release>:
#include <Private/Macros.h>

int pthread_lock_release(pthread_spinlock_t *spin)
{
   return 0;
}
    16c4:	e3a00000 	mov	r0, #0
    16c8:	e12fff1e 	bx	lr

000016cc <soclib_tty_write>:
#include <Processor/Processor.h>
#include <Processor/Cache.h>

status_t soclib_tty_write (void * handler, void * source,
    int64_t offset, int32_t * p_count)
{
    16cc:	e92d4070 	push	{r4, r5, r6, lr}
    16d0:	e1a05001 	mov	r5, r1
    16d4:	e59d4010 	ldr	r4, [sp, #16]
    16d8:	e1a06000 	mov	r6, r0
  soclib_tty_t * tty = (soclib_tty_t *) handler;

  cpu_dcache_invalidate((void*)source,sizeof(char)*(*p_count));
    16dc:	e5941000 	ldr	r1, [r4]
    16e0:	e1a00005 	mov	r0, r5
    16e4:	eb002171 	bl	9cb0 <cpu_dcache_invalidate>
  for (uint32_t i = 0; i < * p_count; i++)  
    16e8:	e5943000 	ldr	r3, [r4]
    16ec:	e3530000 	cmp	r3, #0
    16f0:	0a000007 	beq	1714 <soclib_tty_write+0x48>
    16f4:	e3a03000 	mov	r3, #0
  {
    cpu_write (UINT8, (& tty -> port -> write), ((char *)source)[i]);
    16f8:	e596200c 	ldr	r2, [r6, #12]
    16fc:	e7d5c003 	ldrb	ip, [r5, r3]
    int64_t offset, int32_t * p_count)
{
  soclib_tty_t * tty = (soclib_tty_t *) handler;

  cpu_dcache_invalidate((void*)source,sizeof(char)*(*p_count));
  for (uint32_t i = 0; i < * p_count; i++)  
    1700:	e2833001 	add	r3, r3, #1
  {
    cpu_write (UINT8, (& tty -> port -> write), ((char *)source)[i]);
    1704:	e5c2c000 	strb	ip, [r2]
    int64_t offset, int32_t * p_count)
{
  soclib_tty_t * tty = (soclib_tty_t *) handler;

  cpu_dcache_invalidate((void*)source,sizeof(char)*(*p_count));
  for (uint32_t i = 0; i < * p_count; i++)  
    1708:	e5942000 	ldr	r2, [r4]
    170c:	e1520003 	cmp	r2, r3
    1710:	8afffff8 	bhi	16f8 <soclib_tty_write+0x2c>
  {
    cpu_write (UINT8, (& tty -> port -> write), ((char *)source)[i]);
  }

  return DNA_OK;
}
    1714:	e3a00000 	mov	r0, #0
    1718:	e8bd8070 	pop	{r4, r5, r6, pc}

0000171c <soclib_platform_prepare_devices>:
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

soclib_tty_t * TTY = NULL;

status_t soclib_platform_prepare_devices(void) {
    171c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  char * base_path = "serial/soclib/", * device_base, alpha_index[8];

  watch (status_t)
  {
    if (soclib_platform_devices != NULL)
    1720:	e59f615c 	ldr	r6, [pc, #348]	; 1884 <soclib_platform_prepare_devices+0x168>
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

soclib_tty_t * TTY = NULL;

status_t soclib_platform_prepare_devices(void) {
    1724:	e24dd008 	sub	sp, sp, #8
  char * base_path = "serial/soclib/", * device_base, alpha_index[8];

  watch (status_t)
  {
    if (soclib_platform_devices != NULL)
    1728:	e5963000 	ldr	r3, [r6]
    172c:	e3530000 	cmp	r3, #0
    1730:	0a00000d 	beq	176c <soclib_platform_prepare_devices+0x50>
    {
      for (int32_t i = 0; soclib_platform_devices[i] != NULL; i += 1)
    1734:	e5930000 	ldr	r0, [r3]
    1738:	e3500000 	cmp	r0, #0
    173c:	0a000006 	beq	175c <soclib_platform_prepare_devices+0x40>
    1740:	e3a04004 	mov	r4, #4
      {
        kernel_free (soclib_platform_devices[i]);
    1744:	eb00301f 	bl	d7c8 <kernel_free>

  watch (status_t)
  {
    if (soclib_platform_devices != NULL)
    {
      for (int32_t i = 0; soclib_platform_devices[i] != NULL; i += 1)
    1748:	e5963000 	ldr	r3, [r6]
    174c:	e7930004 	ldr	r0, [r3, r4]
    1750:	e2844004 	add	r4, r4, #4
    1754:	e3500000 	cmp	r0, #0
    1758:	1afffff9 	bne	1744 <soclib_platform_prepare_devices+0x28>
      {
        kernel_free (soclib_platform_devices[i]);
      }

      kernel_free (soclib_platform_devices);
    175c:	e1a00003 	mov	r0, r3
    1760:	eb003018 	bl	d7c8 <kernel_free>
      soclib_platform_devices = NULL;
    1764:	e3a03000 	mov	r3, #0
    1768:	e5863000 	str	r3, [r6]
    /*
     * Generate the name database.
     */

    soclib_platform_devices = kernel_malloc
      ((SOCLIB_TTY_NDEV + 2) * sizeof (char *), true);
    176c:	e59f8114 	ldr	r8, [pc, #276]	; 1888 <soclib_platform_prepare_devices+0x16c>
    1770:	e3a01001 	mov	r1, #1
    1774:	e5980000 	ldr	r0, [r8]
    1778:	e2800002 	add	r0, r0, #2
    177c:	e1a00100 	lsl	r0, r0, #2
    1780:	eb002fdb 	bl	d6f4 <kernel_malloc>
    ensure (soclib_platform_devices != NULL, DNA_ERROR);
    1784:	e3500000 	cmp	r0, #0

    /*
     * Generate the name database.
     */

    soclib_platform_devices = kernel_malloc
    1788:	e5860000 	str	r0, [r6]
      ((SOCLIB_TTY_NDEV + 2) * sizeof (char *), true);
    ensure (soclib_platform_devices != NULL, DNA_ERROR);
    178c:	0a000039 	beq	1878 <soclib_platform_prepare_devices+0x15c>

    for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
    1790:	e5983000 	ldr	r3, [r8]
    1794:	e3530000 	cmp	r3, #0
    1798:	0a000029 	beq	1844 <soclib_platform_prepare_devices+0x128>
    179c:	e3a07000 	mov	r7, #0
    17a0:	e1a04007 	mov	r4, r7
    17a4:	ea00000f 	b	17e8 <soclib_platform_prepare_devices+0xcc>
    {
      device_base = kernel_malloc (DNA_PATH_LENGTH, false);
      check (no_memory, device_base != NULL, DNA_ERROR);

      dna_itoa (i, alpha_index);
    17a8:	e1a00004 	mov	r0, r4
    17ac:	e1a0100d 	mov	r1, sp
    17b0:	eb00203d 	bl	98ac <dna_itoa>
      dna_strcpy (device_base, base_path);
    17b4:	e59f10d0 	ldr	r1, [pc, #208]	; 188c <soclib_platform_prepare_devices+0x170>
    17b8:	e1a00005 	mov	r0, r5
    17bc:	eb001fc9 	bl	96e8 <dna_strcpy>
      dna_strcat (device_base, alpha_index);
    17c0:	e1a00005 	mov	r0, r5
    17c4:	e1a0100d 	mov	r1, sp
    17c8:	eb001f47 	bl	94ec <dna_strcat>

    soclib_platform_devices = kernel_malloc
      ((SOCLIB_TTY_NDEV + 2) * sizeof (char *), true);
    ensure (soclib_platform_devices != NULL, DNA_ERROR);

    for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
    17cc:	e5982000 	ldr	r2, [r8]
    17d0:	e2844001 	add	r4, r4, #1
      check (no_memory, device_base != NULL, DNA_ERROR);

      dna_itoa (i, alpha_index);
      dna_strcpy (device_base, base_path);
      dna_strcat (device_base, alpha_index);
      soclib_platform_devices[i] = device_base;
    17d4:	e5963000 	ldr	r3, [r6]

    soclib_platform_devices = kernel_malloc
      ((SOCLIB_TTY_NDEV + 2) * sizeof (char *), true);
    ensure (soclib_platform_devices != NULL, DNA_ERROR);

    for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
    17d8:	e1540002 	cmp	r4, r2
      check (no_memory, device_base != NULL, DNA_ERROR);

      dna_itoa (i, alpha_index);
      dna_strcpy (device_base, base_path);
      dna_strcat (device_base, alpha_index);
      soclib_platform_devices[i] = device_base;
    17dc:	e7835107 	str	r5, [r3, r7, lsl #2]

    soclib_platform_devices = kernel_malloc
      ((SOCLIB_TTY_NDEV + 2) * sizeof (char *), true);
    ensure (soclib_platform_devices != NULL, DNA_ERROR);

    for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
    17e0:	e1a07004 	mov	r7, r4
    17e4:	2a000016 	bcs	1844 <soclib_platform_prepare_devices+0x128>
    {
      device_base = kernel_malloc (DNA_PATH_LENGTH, false);
    17e8:	e3a00b01 	mov	r0, #1024	; 0x400
    17ec:	e3a01000 	mov	r1, #0
    17f0:	eb002fbf 	bl	d6f4 <kernel_malloc>
      check (no_memory, device_base != NULL, DNA_ERROR);
    17f4:	e2505000 	subs	r5, r0, #0
    17f8:	1affffea 	bne	17a8 <soclib_platform_prepare_devices+0x8c>
    return DNA_OK;
  }

  rescue (no_memory)
  {
    for (int32_t i = 0; soclib_platform_devices[i] != NULL; i += 1)
    17fc:	e5963000 	ldr	r3, [r6]
    1800:	e5930000 	ldr	r0, [r3]
    1804:	e3500000 	cmp	r0, #0
    1808:	0a000006 	beq	1828 <soclib_platform_prepare_devices+0x10c>
    180c:	e3a04004 	mov	r4, #4
    {
      kernel_free (soclib_platform_devices[i]);
    1810:	eb002fec 	bl	d7c8 <kernel_free>
    return DNA_OK;
  }

  rescue (no_memory)
  {
    for (int32_t i = 0; soclib_platform_devices[i] != NULL; i += 1)
    1814:	e5963000 	ldr	r3, [r6]
    1818:	e7930004 	ldr	r0, [r3, r4]
    181c:	e2844004 	add	r4, r4, #4
    1820:	e3500000 	cmp	r0, #0
    1824:	1afffff9 	bne	1810 <soclib_platform_prepare_devices+0xf4>
    {
      kernel_free (soclib_platform_devices[i]);
    }

    kernel_free (soclib_platform_devices);
    1828:	e1a00003 	mov	r0, r3
    182c:	eb002fe5 	bl	d7c8 <kernel_free>
    soclib_platform_devices = NULL;
    1830:	e3a03000 	mov	r3, #0

    leave;
    1834:	e59f0054 	ldr	r0, [pc, #84]	; 1890 <soclib_platform_prepare_devices+0x174>
    {
      kernel_free (soclib_platform_devices[i]);
    }

    kernel_free (soclib_platform_devices);
    soclib_platform_devices = NULL;
    1838:	e5863000 	str	r3, [r6]

    leave;
  }
}
    183c:	e28dd008 	add	sp, sp, #8
    1840:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    /*
     * Add the kernel serial devices.
     * TODO find a better way to do that => pass this info as a parameter.
     */

    device_base = kernel_malloc (DNA_PATH_LENGTH, false);
    1844:	e3a00b01 	mov	r0, #1024	; 0x400
    1848:	e3a01000 	mov	r1, #0
    184c:	eb002fa8 	bl	d6f4 <kernel_malloc>
    check (no_memory, device_base != NULL, DNA_ERROR);
    1850:	e2504000 	subs	r4, r0, #0
    1854:	0affffe8 	beq	17fc <soclib_platform_prepare_devices+0xe0>

    dna_strcpy (device_base, "serial/kernel/console");
    1858:	e59f1034 	ldr	r1, [pc, #52]	; 1894 <soclib_platform_prepare_devices+0x178>
    185c:	eb001fa1 	bl	96e8 <dna_strcpy>
    soclib_platform_devices[SOCLIB_TTY_NDEV] = device_base;

    return DNA_OK;
    1860:	e3a00000 	mov	r0, #0

    device_base = kernel_malloc (DNA_PATH_LENGTH, false);
    check (no_memory, device_base != NULL, DNA_ERROR);

    dna_strcpy (device_base, "serial/kernel/console");
    soclib_platform_devices[SOCLIB_TTY_NDEV] = device_base;
    1864:	e5982000 	ldr	r2, [r8]
    1868:	e5963000 	ldr	r3, [r6]
    186c:	e7834102 	str	r4, [r3, r2, lsl #2]
    kernel_free (soclib_platform_devices);
    soclib_platform_devices = NULL;

    leave;
  }
}
    1870:	e28dd008 	add	sp, sp, #8
    1874:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
     * Generate the name database.
     */

    soclib_platform_devices = kernel_malloc
      ((SOCLIB_TTY_NDEV + 2) * sizeof (char *), true);
    ensure (soclib_platform_devices != NULL, DNA_ERROR);
    1878:	e59f0010 	ldr	r0, [pc, #16]	; 1890 <soclib_platform_prepare_devices+0x174>
    kernel_free (soclib_platform_devices);
    soclib_platform_devices = NULL;

    leave;
  }
}
    187c:	e28dd008 	add	sp, sp, #8
    1880:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    1884:	00035580 	.word	0x00035580
    1888:	00025520 	.word	0x00025520
    188c:	00023a9c 	.word	0x00023a9c
    1890:	0000ffff 	.word	0x0000ffff
    1894:	00023aac 	.word	0x00023aac

00001898 <soclib_platform_init_driver>:

status_t soclib_platform_init_driver (void)
{
    1898:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

  /*
   * Connect the TIMER and IPI ISRs.
   */

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
    189c:	e3a04000 	mov	r4, #0
    leave;
  }
}

status_t soclib_platform_init_driver (void)
{
    18a0:	e24dd054 	sub	sp, sp, #84	; 0x54
   * Connect the TIMER and IPI ISRs.
   */

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
  {
    interrupt_attach (i, 0, 0x0, soclib_ipi_isr, true);
    18a4:	e3a06001 	mov	r6, #1
    18a8:	e1a05004 	mov	r5, r4

  /*
   * Connect the TIMER and IPI ISRs.
   */

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
    18ac:	ea00000b 	b	18e0 <soclib_platform_init_driver+0x48>
  {
    interrupt_attach (i, 0, 0x0, soclib_ipi_isr, true);
    18b0:	e3a01000 	mov	r1, #0
    18b4:	e1a00004 	mov	r0, r4
    18b8:	e1a02001 	mov	r2, r1
    18bc:	e58d6000 	str	r6, [sp]
    18c0:	eb002c93 	bl	cb14 <interrupt_attach>
    interrupt_attach (i, 1, 0x0, soclib_timer_isr, false);
    18c4:	e1a00004 	mov	r0, r4
    18c8:	e58d5000 	str	r5, [sp]
    18cc:	e3a01001 	mov	r1, #1
    18d0:	e3a02000 	mov	r2, #0
    18d4:	e59f312c 	ldr	r3, [pc, #300]	; 1a08 <soclib_platform_init_driver+0x170>
    18d8:	eb002c8d 	bl	cb14 <interrupt_attach>

  /*
   * Connect the TIMER and IPI ISRs.
   */

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
    18dc:	e2844001 	add	r4, r4, #1
    18e0:	eb00210f 	bl	9d24 <cpu_mp_count>
    18e4:	e1540000 	cmp	r4, r0
  {
    interrupt_attach (i, 0, 0x0, soclib_ipi_isr, true);
    18e8:	e59f311c 	ldr	r3, [pc, #284]	; 1a0c <soclib_platform_init_driver+0x174>

  /*
   * Connect the TIMER and IPI ISRs.
   */

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
    18ec:	baffffef 	blt	18b0 <soclib_platform_init_driver+0x18>

  /*
   * Instantiate the TTY devices.
   */

  TTY = kernel_malloc (sizeof (soclib_tty_t) * SOCLIB_TTY_NDEV, true);
    18f0:	e59fb118 	ldr	fp, [pc, #280]	; 1a10 <soclib_platform_init_driver+0x178>
    18f4:	e3a01001 	mov	r1, #1
    18f8:	e59b3000 	ldr	r3, [fp]
    18fc:	e59f7110 	ldr	r7, [pc, #272]	; 1a14 <soclib_platform_init_driver+0x17c>
    1900:	e0830103 	add	r0, r3, r3, lsl #2
    1904:	e1a00100 	lsl	r0, r0, #2
    1908:	eb002f79 	bl	d6f4 <kernel_malloc>
  if (TTY == NULL) return DNA_OUT_OF_MEM;
    190c:	e3500000 	cmp	r0, #0

  /*
   * Instantiate the TTY devices.
   */

  TTY = kernel_malloc (sizeof (soclib_tty_t) * SOCLIB_TTY_NDEV, true);
    1910:	e5870000 	str	r0, [r7]
  if (TTY == NULL) return DNA_OUT_OF_MEM;
    1914:	0a000038 	beq	19fc <soclib_platform_init_driver+0x164>

  for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
    1918:	e59b3000 	ldr	r3, [fp]
    191c:	e3530000 	cmp	r3, #0
    1920:	0a000031 	beq	19ec <soclib_platform_init_driver+0x154>
    1924:	e3a05000 	mov	r5, #0
    dna_strcpy (sem_name, "soclib_tty_");
    dna_strcat (sem_name, alpha_index);
    dna_strcat (sem_name, "_sem");

    semaphore_create (sem_name, 0, & TTY[i] . sem_id);
    TTY[i] . buffer . empty = true;
    1928:	e3a09001 	mov	r9, #1
   */

  TTY = kernel_malloc (sizeof (soclib_tty_t) * SOCLIB_TTY_NDEV, true);
  if (TTY == NULL) return DNA_OUT_OF_MEM;

  for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
    192c:	e1a06005 	mov	r6, r5
    1930:	e1a04005 	mov	r4, r5
    dna_itoa (i, alpha_index);
    dna_strcpy (sem_name, "soclib_tty_");
    dna_strcat (sem_name, alpha_index);
    dna_strcat (sem_name, "_sem");

    semaphore_create (sem_name, 0, & TTY[i] . sem_id);
    1934:	e1a0a005 	mov	sl, r5
    1938:	e59f80d8 	ldr	r8, [pc, #216]	; 1a18 <soclib_platform_init_driver+0x180>
    193c:	ea000001 	b	1948 <soclib_platform_init_driver+0xb0>
    1940:	e59f30cc 	ldr	r3, [pc, #204]	; 1a14 <soclib_platform_init_driver+0x17c>
    1944:	e5930000 	ldr	r0, [r3]
  TTY = kernel_malloc (sizeof (soclib_tty_t) * SOCLIB_TTY_NDEV, true);
  if (TTY == NULL) return DNA_OUT_OF_MEM;

  for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
  {
    TTY[i] . irq = SOCLIB_TTY_DEVICES[i] . irq;
    1948:	e0883005 	add	r3, r8, r5
    194c:	e0866106 	add	r6, r6, r6, lsl #2
    1950:	e7982005 	ldr	r2, [r8, r5]
    TTY[i] . port = SOCLIB_TTY_DEVICES[i] . port;
    1954:	e5933004 	ldr	r3, [r3, #4]
  TTY = kernel_malloc (sizeof (soclib_tty_t) * SOCLIB_TTY_NDEV, true);
  if (TTY == NULL) return DNA_OUT_OF_MEM;

  for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
  {
    TTY[i] . irq = SOCLIB_TTY_DEVICES[i] . irq;
    1958:	e1a06106 	lsl	r6, r6, #2
    195c:	e0800006 	add	r0, r0, r6
    TTY[i] . port = SOCLIB_TTY_DEVICES[i] . port;
    1960:	e580300c 	str	r3, [r0, #12]
  TTY = kernel_malloc (sizeof (soclib_tty_t) * SOCLIB_TTY_NDEV, true);
  if (TTY == NULL) return DNA_OUT_OF_MEM;

  for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
  {
    TTY[i] . irq = SOCLIB_TTY_DEVICES[i] . irq;
    1964:	e5802008 	str	r2, [r0, #8]
    TTY[i] . port = SOCLIB_TTY_DEVICES[i] . port;

    dna_itoa (i, alpha_index);
    1968:	e28d1008 	add	r1, sp, #8
    196c:	e1a00004 	mov	r0, r4
    1970:	eb001fcd 	bl	98ac <dna_itoa>
    dna_strcpy (sem_name, "soclib_tty_");
    1974:	e59f10a0 	ldr	r1, [pc, #160]	; 1a1c <soclib_platform_init_driver+0x184>
    1978:	e28d0010 	add	r0, sp, #16
    197c:	eb001f59 	bl	96e8 <dna_strcpy>
    dna_strcat (sem_name, alpha_index);
    1980:	e28d1008 	add	r1, sp, #8
    1984:	e28d0010 	add	r0, sp, #16
    1988:	eb001ed7 	bl	94ec <dna_strcat>
    dna_strcat (sem_name, "_sem");
    198c:	e59f108c 	ldr	r1, [pc, #140]	; 1a20 <soclib_platform_init_driver+0x188>
    1990:	e28d0010 	add	r0, sp, #16
    1994:	eb001ed4 	bl	94ec <dna_strcat>

    semaphore_create (sem_name, 0, & TTY[i] . sem_id);
    1998:	e5972000 	ldr	r2, [r7]
    199c:	e3a01000 	mov	r1, #0
    19a0:	e0822006 	add	r2, r2, r6
    19a4:	e2822010 	add	r2, r2, #16
    19a8:	e28d0010 	add	r0, sp, #16
    19ac:	eb002b24 	bl	c644 <semaphore_create>
    TTY[i] . buffer . empty = true;

    interrupt_attach (0, TTY[i] . irq, 0x0, soclib_tty_isr, false);
    19b0:	e3a00000 	mov	r0, #0
    dna_strcpy (sem_name, "soclib_tty_");
    dna_strcat (sem_name, alpha_index);
    dna_strcat (sem_name, "_sem");

    semaphore_create (sem_name, 0, & TTY[i] . sem_id);
    TTY[i] . buffer . empty = true;
    19b4:	e5973000 	ldr	r3, [r7]

    interrupt_attach (0, TTY[i] . irq, 0x0, soclib_tty_isr, false);
    19b8:	e1a02000 	mov	r2, r0
    dna_strcpy (sem_name, "soclib_tty_");
    dna_strcat (sem_name, alpha_index);
    dna_strcat (sem_name, "_sem");

    semaphore_create (sem_name, 0, & TTY[i] . sem_id);
    TTY[i] . buffer . empty = true;
    19bc:	e0836006 	add	r6, r3, r6

    interrupt_attach (0, TTY[i] . irq, 0x0, soclib_tty_isr, false);
    19c0:	e5961008 	ldr	r1, [r6, #8]
    dna_strcpy (sem_name, "soclib_tty_");
    dna_strcat (sem_name, alpha_index);
    dna_strcat (sem_name, "_sem");

    semaphore_create (sem_name, 0, & TTY[i] . sem_id);
    TTY[i] . buffer . empty = true;
    19c4:	e5c69004 	strb	r9, [r6, #4]

    interrupt_attach (0, TTY[i] . irq, 0x0, soclib_tty_isr, false);
    19c8:	e59f3054 	ldr	r3, [pc, #84]	; 1a24 <soclib_platform_init_driver+0x18c>
    19cc:	e58da000 	str	sl, [sp]
    19d0:	eb002c4f 	bl	cb14 <interrupt_attach>
   */

  TTY = kernel_malloc (sizeof (soclib_tty_t) * SOCLIB_TTY_NDEV, true);
  if (TTY == NULL) return DNA_OUT_OF_MEM;

  for (int32_t i = 0; i < SOCLIB_TTY_NDEV; i += 1)
    19d4:	e59b3000 	ldr	r3, [fp]
    19d8:	e2844001 	add	r4, r4, #1
    19dc:	e1540003 	cmp	r4, r3
    19e0:	e2855008 	add	r5, r5, #8
    19e4:	e1a06004 	mov	r6, r4
    19e8:	3affffd4 	bcc	1940 <soclib_platform_init_driver+0xa8>
    TTY[i] . buffer . empty = true;

    interrupt_attach (0, TTY[i] . irq, 0x0, soclib_tty_isr, false);
  }

  soclib_platform_prepare_devices();
    19ec:	ebffff4a 	bl	171c <soclib_platform_prepare_devices>

  return DNA_OK;
    19f0:	e3a00000 	mov	r0, #0
}
    19f4:	e28dd054 	add	sp, sp, #84	; 0x54
    19f8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  /*
   * Instantiate the TTY devices.
   */

  TTY = kernel_malloc (sizeof (soclib_tty_t) * SOCLIB_TTY_NDEV, true);
  if (TTY == NULL) return DNA_OUT_OF_MEM;
    19fc:	e59f0024 	ldr	r0, [pc, #36]	; 1a28 <soclib_platform_init_driver+0x190>
  }

  soclib_platform_prepare_devices();

  return DNA_OK;
}
    1a00:	e28dd054 	add	sp, sp, #84	; 0x54
    1a04:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1a08:	00001b9c 	.word	0x00001b9c
    1a0c:	00001b34 	.word	0x00001b34
    1a10:	00025520 	.word	0x00025520
    1a14:	0003557c 	.word	0x0003557c
    1a18:	00025524 	.word	0x00025524
    1a1c:	00023ac4 	.word	0x00023ac4
    1a20:	00023ad0 	.word	0x00023ad0
    1a24:	00001c60 	.word	0x00001c60
    1a28:	0000fffd 	.word	0x0000fffd

00001a2c <soclib_tty_open>:
#include <Private/Driver.h>
#include <Processor/Processor.h>
#include <DnaTools/DnaTools.h>

status_t soclib_tty_open (char * name, int32_t mode, void ** data)
{
    1a2c:	e92d4010 	push	{r4, lr}
  watch (status_t)
  {
    ensure (data != NULL, DNA_ERROR);
    1a30:	e2524000 	subs	r4, r2, #0
    1a34:	0a000003 	beq	1a48 <soclib_tty_open+0x1c>

    if (dna_strcmp (name, "serial/kernel/console") == 0)
    1a38:	e59f1020 	ldr	r1, [pc, #32]	; 1a60 <soclib_tty_open+0x34>
    1a3c:	eb001ebb 	bl	9530 <dna_strcmp>
    1a40:	e3500000 	cmp	r0, #0
    1a44:	0a000001 	beq	1a50 <soclib_tty_open+0x24>

status_t soclib_tty_open (char * name, int32_t mode, void ** data)
{
  watch (status_t)
  {
    ensure (data != NULL, DNA_ERROR);
    1a48:	e59f0014 	ldr	r0, [pc, #20]	; 1a64 <soclib_tty_open+0x38>
    1a4c:	e8bd8010 	pop	{r4, pc}

    if (dna_strcmp (name, "serial/kernel/console") == 0)
    {
      *data = (void *) & TTY[0];
    1a50:	e59f3010 	ldr	r3, [pc, #16]	; 1a68 <soclib_tty_open+0x3c>
    1a54:	e5933000 	ldr	r3, [r3]
    1a58:	e5843000 	str	r3, [r4]
    }
#endif

    return DNA_ERROR;
  }
}
    1a5c:	e8bd8010 	pop	{r4, pc}
    1a60:	00023aac 	.word	0x00023aac
    1a64:	0000ffff 	.word	0x0000ffff
    1a68:	0003557c 	.word	0x0003557c

00001a6c <soclib_tty_control>:
#include <Processor/Processor.h>

status_t soclib_tty_control (void * handler, int32_t function,
    va_list arguments, int32_t * p_ret)
{
  switch (function)
    1a6c:	e3510006 	cmp	r1, #6
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>

status_t soclib_tty_control (void * handler, int32_t function,
    va_list arguments, int32_t * p_ret)
{
    1a70:	e92d4038 	push	{r3, r4, r5, lr}
    1a74:	e1a04003 	mov	r4, r3
      }

    default :
      {
        dna_log(INFO_LEVEL, "Unsupported control code 0x%x.", function);
        *p_ret = -1;
    1a78:	13e03000 	mvnne	r3, #0
    1a7c:	15843000 	strne	r3, [r4]
#include <Processor/Processor.h>

status_t soclib_tty_control (void * handler, int32_t function,
    va_list arguments, int32_t * p_ret)
{
  switch (function)
    1a80:	0a000001 	beq	1a8c <soclib_tty_control+0x20>
        break;
      }
  }

  return DNA_OK;
}
    1a84:	e3a00000 	mov	r0, #0
    1a88:	e8bd8038 	pop	{r3, r4, r5, pc}
{
  switch (function)
  {
    case DNA_GET_INFO :
      {
        device_info_t * info = va_arg (arguments, device_info_t *);
    1a8c:	e5925000 	ldr	r5, [r2]

        dna_memset (info, 0, sizeof (device_info_t));
    1a90:	e3a01000 	mov	r1, #0
    1a94:	e1a00005 	mov	r0, r5
    1a98:	e3a02010 	mov	r2, #16
    1a9c:	eb001c10 	bl	8ae4 <dna_memset>
        info -> type = DNA_CHARACTER_DEVICE;
    1aa0:	e3a03000 	mov	r3, #0
        break;
      }
  }

  return DNA_OK;
}
    1aa4:	e3a00000 	mov	r0, #0
    case DNA_GET_INFO :
      {
        device_info_t * info = va_arg (arguments, device_info_t *);

        dna_memset (info, 0, sizeof (device_info_t));
        info -> type = DNA_CHARACTER_DEVICE;
    1aa8:	e5853000 	str	r3, [r5]

        *p_ret = 0;
    1aac:	e5843000 	str	r3, [r4]
        break;
      }
  }

  return DNA_OK;
}
    1ab0:	e8bd8038 	pop	{r3, r4, r5, pc}

00001ab4 <soclib_tty_read>:
#include <Private/Driver.h>
#include <DnaTools/DnaTools.h>

status_t soclib_tty_read (void * handler, void * destination,
    int64_t offset, int32_t * p_count)
{
    1ab4:	e92d4070 	push	{r4, r5, r6, lr}
  soclib_tty_t * tty = (soclib_tty_t *) handler;

  if (tty -> buffer . empty) semaphore_acquire (tty -> sem_id, 1, 0, -1);
    1ab8:	e5d03004 	ldrb	r3, [r0, #4]
#include <Private/Driver.h>
#include <DnaTools/DnaTools.h>

status_t soclib_tty_read (void * handler, void * destination,
    int64_t offset, int32_t * p_count)
{
    1abc:	e24dd008 	sub	sp, sp, #8
  soclib_tty_t * tty = (soclib_tty_t *) handler;

  if (tty -> buffer . empty) semaphore_acquire (tty -> sem_id, 1, 0, -1);
    1ac0:	e3530000 	cmp	r3, #0
#include <Private/Driver.h>
#include <DnaTools/DnaTools.h>

status_t soclib_tty_read (void * handler, void * destination,
    int64_t offset, int32_t * p_count)
{
    1ac4:	e1a04000 	mov	r4, r0
    1ac8:	e1a06001 	mov	r6, r1
    1acc:	e59d5018 	ldr	r5, [sp, #24]
  soclib_tty_t * tty = (soclib_tty_t *) handler;

  if (tty -> buffer . empty) semaphore_acquire (tty -> sem_id, 1, 0, -1);
    1ad0:	0a000006 	beq	1af0 <soclib_tty_read+0x3c>
    1ad4:	e3e02000 	mvn	r2, #0
    1ad8:	e3e03000 	mvn	r3, #0
    1adc:	e5900010 	ldr	r0, [r0, #16]
    1ae0:	e3a01001 	mov	r1, #1
    1ae4:	e1cd20f0 	strd	r2, [sp]
    1ae8:	e3a02000 	mov	r2, #0
    1aec:	eb0026b6 	bl	b5cc <semaphore_acquire>

  *((char *)destination) = tty -> buffer . data;
  tty -> buffer . empty = true;
    1af0:	e3a03001 	mov	r3, #1

  cpu_write (UINT8, (& tty -> port -> write), tty -> buffer . data); // echoing typed character

  *p_count = 1;
  return DNA_OK;
}
    1af4:	e3a00000 	mov	r0, #0
{
  soclib_tty_t * tty = (soclib_tty_t *) handler;

  if (tty -> buffer . empty) semaphore_acquire (tty -> sem_id, 1, 0, -1);

  *((char *)destination) = tty -> buffer . data;
    1af8:	e5d42005 	ldrb	r2, [r4, #5]
    1afc:	e5c62000 	strb	r2, [r6]
  tty -> buffer . empty = true;

  cpu_write (UINT8, (& tty -> port -> write), tty -> buffer . data); // echoing typed character
    1b00:	e594200c 	ldr	r2, [r4, #12]
    1b04:	e5d41005 	ldrb	r1, [r4, #5]
  soclib_tty_t * tty = (soclib_tty_t *) handler;

  if (tty -> buffer . empty) semaphore_acquire (tty -> sem_id, 1, 0, -1);

  *((char *)destination) = tty -> buffer . data;
  tty -> buffer . empty = true;
    1b08:	e5c43004 	strb	r3, [r4, #4]

  cpu_write (UINT8, (& tty -> port -> write), tty -> buffer . data); // echoing typed character
    1b0c:	e5c21000 	strb	r1, [r2]

  *p_count = 1;
    1b10:	e5853000 	str	r3, [r5]
  return DNA_OK;
}
    1b14:	e28dd008 	add	sp, sp, #8
    1b18:	e8bd8070 	pop	{r4, r5, r6, pc}

00001b1c <soclib_platform_uninit_driver>:

#include <Private/Driver.h>
#include <DnaTools/DnaTools.h>

void  soclib_platform_uninit_driver (void)
{
    1b1c:	e12fff1e 	bx	lr

00001b20 <soclib_platform_find_device>:
#include <DnaTools/DnaTools.h>

device_cmd_t * soclib_platform_find_device (const char * name)
{
  return & soclib_tty_commands;
}
    1b20:	e59f0000 	ldr	r0, [pc]	; 1b28 <soclib_platform_find_device+0x8>
    1b24:	e12fff1e 	bx	lr
    1b28:	00024a3c 	.word	0x00024a3c

00001b2c <soclib_tty_close>:

status_t soclib_tty_close (void * data)
{

  return DNA_OK;
}
    1b2c:	e3a00000 	mov	r0, #0
    1b30:	e12fff1e 	bx	lr

00001b34 <soclib_ipi_isr>:
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>
#include <Platform/Platform.h>

int32_t soclib_ipi_isr (void * data)
{
    1b34:	e92d4008 	push	{r3, lr}
  int32_t value, command, status;
  int32_t current_cpuid = cpu_mp_id ();
    1b38:	eb002046 	bl	9c58 <cpu_mp_id>

  cpu_read (UINT32, & (PLATFORM_IPI_BASE[current_cpuid] . data), value);
    1b3c:	e59f304c 	ldr	r3, [pc, #76]	; 1b90 <soclib_ipi_isr+0x5c>
    1b40:	e5932000 	ldr	r2, [r3]
    1b44:	e0823200 	add	r3, r2, r0, lsl #4
    1b48:	e5931004 	ldr	r1, [r3, #4]
  cpu_read (UINT32, & (PLATFORM_IPI_BASE[current_cpuid] . command), command);
    1b4c:	e7920200 	ldr	r0, [r2, r0, lsl #4]

  cpu_read (UINT32, & (PLATFORM_IPI_BASE[current_cpuid] . reset), status);
    1b50:	e593200c 	ldr	r2, [r3, #12]
  
  if (status != 0)
    1b54:	e3520000 	cmp	r2, #0
    1b58:	1a000001 	bne	1b64 <soclib_ipi_isr+0x30>
      default :
        return DNA_UNHANDLED_INTERRUPT;
    }
  }

  return DNA_UNHANDLED_INTERRUPT;
    1b5c:	e3a00004 	mov	r0, #4
    1b60:	e8bd8008 	pop	{r3, pc}

  cpu_read (UINT32, & (PLATFORM_IPI_BASE[current_cpuid] . reset), status);
  
  if (status != 0)
  {
    cpu_write (UINT32, & (PLATFORM_IPI_BASE[current_cpuid] . reset), 0);
    1b64:	e3a02000 	mov	r2, #0
    1b68:	e583200c 	str	r2, [r3, #12]

    switch (ipi_handler (command, (void *)value))
    1b6c:	eb002202 	bl	a37c <ipi_handler>
    1b70:	e3500000 	cmp	r0, #0
    1b74:	0a000003 	beq	1b88 <soclib_ipi_isr+0x54>

      case DNA_INVOKE_SCHEDULER :
        return DNA_INVOKE_SCHEDULER;

      default :
        return DNA_UNHANDLED_INTERRUPT;
    1b78:	e3500003 	cmp	r0, #3
    1b7c:	03a00003 	moveq	r0, #3
    1b80:	13a00004 	movne	r0, #4
    1b84:	e8bd8008 	pop	{r3, pc}
    cpu_write (UINT32, & (PLATFORM_IPI_BASE[current_cpuid] . reset), 0);

    switch (ipi_handler (command, (void *)value))
    {
      case DNA_OK :
        return DNA_HANDLED_INTERRUPT;
    1b88:	e3a00005 	mov	r0, #5
        return DNA_UNHANDLED_INTERRUPT;
    }
  }

  return DNA_UNHANDLED_INTERRUPT;
}
    1b8c:	e8bd8008 	pop	{r3, pc}
    1b90:	00025518 	.word	0x00025518

00001b94 <soclib_tty_free>:
#include <DnaTools/DnaTools.h>

status_t soclib_tty_free (void * data) {

  return DNA_OK;
}
    1b94:	e3a00000 	mov	r0, #0
    1b98:	e12fff1e 	bx	lr

00001b9c <soclib_timer_isr>:
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>
#include <Platform/Platform.h>

int32_t soclib_timer_isr (void * data)
{
    1b9c:	e92d4008 	push	{r3, lr}
  int32_t is_irq = 0, current_cpuid = cpu_mp_id ();
    1ba0:	eb00202c 	bl	9c58 <cpu_mp_id>
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[current_cpuid];
    1ba4:	e59f304c 	ldr	r3, [pc, #76]	; 1bf8 <soclib_timer_isr+0x5c>
    1ba8:	e5933000 	ldr	r3, [r3]
    1bac:	e0830200 	add	r0, r3, r0, lsl #4

  cpu_read (UINT32, & (timer -> irq_ack), is_irq);
    1bb0:	e590300c 	ldr	r3, [r0, #12]

  if (is_irq != 0)
    1bb4:	e3530000 	cmp	r3, #0
    1bb8:	1a000001 	bne	1bc4 <soclib_timer_isr+0x28>
      default :
        return DNA_UNHANDLED_INTERRUPT;
    }
  }

  return DNA_UNHANDLED_INTERRUPT;
    1bbc:	e3a00004 	mov	r0, #4
    1bc0:	e8bd8008 	pop	{r3, pc}

  cpu_read (UINT32, & (timer -> irq_ack), is_irq);

  if (is_irq != 0)
  {
    cpu_write(UINT32, & (timer -> irq_ack), 0);
    1bc4:	e3a02000 	mov	r2, #0
    cpu_write(UINT32, & (timer -> mode), 1);
    1bc8:	e3a03001 	mov	r3, #1

  cpu_read (UINT32, & (timer -> irq_ack), is_irq);

  if (is_irq != 0)
  {
    cpu_write(UINT32, & (timer -> irq_ack), 0);
    1bcc:	e580200c 	str	r2, [r0, #12]
    cpu_write(UINT32, & (timer -> mode), 1);
    1bd0:	e5803004 	str	r3, [r0, #4]

    switch (alarm_handler ())
    1bd4:	eb002599 	bl	b240 <alarm_handler>
    1bd8:	e3500000 	cmp	r0, #0
    1bdc:	0a000003 	beq	1bf0 <soclib_timer_isr+0x54>

      case DNA_INVOKE_SCHEDULER :
        return DNA_INVOKE_SCHEDULER;

      default :
        return DNA_UNHANDLED_INTERRUPT;
    1be0:	e3500003 	cmp	r0, #3
    1be4:	03a00003 	moveq	r0, #3
    1be8:	13a00004 	movne	r0, #4
    1bec:	e8bd8008 	pop	{r3, pc}
    cpu_write(UINT32, & (timer -> mode), 1);

    switch (alarm_handler ())
    {
      case DNA_OK :
        return DNA_HANDLED_INTERRUPT;
    1bf0:	e3a00005 	mov	r0, #5
        return DNA_UNHANDLED_INTERRUPT;
    }
  }

  return DNA_UNHANDLED_INTERRUPT;
}
    1bf4:	e8bd8008 	pop	{r3, pc}
    1bf8:	00025514 	.word	0x00025514

00001bfc <soclib_platform_init_hardware>:

status_t soclib_platform_init_hardware (void)
{
  soclib_timer_port_t timer;

  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);
    1bfc:	e3a03001 	mov	r3, #1

#include <Private/Driver.h>
#include <DnaTools/DnaTools.h>

status_t soclib_platform_init_hardware (void)
{
    1c00:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  soclib_timer_port_t timer;

  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);
    1c04:	e59f804c 	ldr	r8, [pc, #76]	; 1c58 <soclib_platform_init_hardware+0x5c>

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
  {
    timer = & PLATFORM_TIMER_BASE[i];
    cpu_write(UINT32, & (timer -> mode), 1); 
    1c08:	e1a07003 	mov	r7, r3

status_t soclib_platform_init_hardware (void)
{
  soclib_timer_port_t timer;

  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);
    1c0c:	e5982000 	ldr	r2, [r8]

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
    1c10:	e3a04000 	mov	r4, #0

status_t soclib_platform_init_hardware (void)
{
  soclib_timer_port_t timer;

  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);
    1c14:	e5823000 	str	r3, [r2]

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
  {
    timer = & PLATFORM_TIMER_BASE[i];
    1c18:	e59f603c 	ldr	r6, [pc, #60]	; 1c5c <soclib_platform_init_hardware+0x60>
    cpu_write(UINT32, & (timer -> mode), 1); 
    cpu_write (UINT32, & (PLATFORM_AICU_BASE -> slot[i] . mask), 0x3);
    1c1c:	e3a05003 	mov	r5, #3
{
  soclib_timer_port_t timer;

  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
    1c20:	ea000007 	b	1c44 <soclib_platform_init_hardware+0x48>
  {
    timer = & PLATFORM_TIMER_BASE[i];
    1c24:	e5962000 	ldr	r2, [r6]
    cpu_write(UINT32, & (timer -> mode), 1); 
    cpu_write (UINT32, & (PLATFORM_AICU_BASE -> slot[i] . mask), 0x3);
    1c28:	e5983000 	ldr	r3, [r8]
    1c2c:	e2841010 	add	r1, r4, #16

  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
  {
    timer = & PLATFORM_TIMER_BASE[i];
    1c30:	e0822204 	add	r2, r2, r4, lsl #4
    cpu_write(UINT32, & (timer -> mode), 1); 
    cpu_write (UINT32, & (PLATFORM_AICU_BASE -> slot[i] . mask), 0x3);
    1c34:	e0833201 	add	r3, r3, r1, lsl #4
  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
  {
    timer = & PLATFORM_TIMER_BASE[i];
    cpu_write(UINT32, & (timer -> mode), 1); 
    1c38:	e5827004 	str	r7, [r2, #4]
{
  soclib_timer_port_t timer;

  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
    1c3c:	e2844001 	add	r4, r4, #1
  {
    timer = & PLATFORM_TIMER_BASE[i];
    cpu_write(UINT32, & (timer -> mode), 1); 
    cpu_write (UINT32, & (PLATFORM_AICU_BASE -> slot[i] . mask), 0x3);
    1c40:	e5835004 	str	r5, [r3, #4]
{
  soclib_timer_port_t timer;

  cpu_write (UINT32, & (PLATFORM_AICU_BASE -> control), 0x1);

  for (int32_t i = 0; i < cpu_mp_count (); i += 1)
    1c44:	eb002036 	bl	9d24 <cpu_mp_count>
    1c48:	e1540000 	cmp	r4, r0
    1c4c:	bafffff4 	blt	1c24 <soclib_platform_init_hardware+0x28>
    cpu_write(UINT32, & (timer -> mode), 1); 
    cpu_write (UINT32, & (PLATFORM_AICU_BASE -> slot[i] . mask), 0x3);
  }

  return DNA_OK;
}
    1c50:	e3a00000 	mov	r0, #0
    1c54:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    1c58:	0002551c 	.word	0x0002551c
    1c5c:	00025514 	.word	0x00025514

00001c60 <soclib_tty_isr>:

#include <Private/Driver.h>
#include <DnaTools/DnaTools.h>

int32_t soclib_tty_isr (void * data)
{
    1c60:	e92d4008 	push	{r3, lr}
  int32_t index = 0, status, c;

  for (index = 0; index < SOCLIB_TTY_NDEV; index += 1)
    1c64:	e59f3084 	ldr	r3, [pc, #132]	; 1cf0 <soclib_tty_isr+0x90>
    1c68:	e593e000 	ldr	lr, [r3]
    1c6c:	e35e0000 	cmp	lr, #0
    1c70:	0a000010 	beq	1cb8 <soclib_tty_isr+0x58>
  {
    cpu_read (UINT32, & (TTY[index] . port -> status), status);
    1c74:	e59f3078 	ldr	r3, [pc, #120]	; 1cf4 <soclib_tty_isr+0x94>
    1c78:	e593c000 	ldr	ip, [r3]
    1c7c:	e59c100c 	ldr	r1, [ip, #12]
    1c80:	e5912004 	ldr	r2, [r1, #4]

    if (status != 0)
    1c84:	e3520000 	cmp	r2, #0
    1c88:	028c3014 	addeq	r3, ip, #20
    1c8c:	0a000006 	beq	1cac <soclib_tty_isr+0x4c>
    1c90:	ea00000a 	b	1cc0 <soclib_tty_isr+0x60>
{
  int32_t index = 0, status, c;

  for (index = 0; index < SOCLIB_TTY_NDEV; index += 1)
  {
    cpu_read (UINT32, & (TTY[index] . port -> status), status);
    1c94:	e593100c 	ldr	r1, [r3, #12]
    1c98:	e1a0c003 	mov	ip, r3
    1c9c:	e5910004 	ldr	r0, [r1, #4]
    1ca0:	e2833014 	add	r3, r3, #20

    if (status != 0)
    1ca4:	e3500000 	cmp	r0, #0
    1ca8:	1a000004 	bne	1cc0 <soclib_tty_isr+0x60>

int32_t soclib_tty_isr (void * data)
{
  int32_t index = 0, status, c;

  for (index = 0; index < SOCLIB_TTY_NDEV; index += 1)
    1cac:	e2822001 	add	r2, r2, #1
    1cb0:	e152000e 	cmp	r2, lr
    1cb4:	1afffff6 	bne	1c94 <soclib_tty_isr+0x34>
      semaphore_release (TTY[index] . sem_id, 1, DNA_NO_RESCHEDULE);
      return DNA_INVOKE_SCHEDULER;
    }
  }

  return DNA_UNHANDLED_INTERRUPT;
    1cb8:	e3a00004 	mov	r0, #4
}
    1cbc:	e8bd8008 	pop	{r3, pc}

    if (status != 0)
    {
      cpu_read (UINT32, & (TTY[index] . port -> read), c);

      if (TTY[index] . buffer . empty)
    1cc0:	e5dc2004 	ldrb	r2, [ip, #4]
  {
    cpu_read (UINT32, & (TTY[index] . port -> status), status);

    if (status != 0)
    {
      cpu_read (UINT32, & (TTY[index] . port -> read), c);
    1cc4:	e5913008 	ldr	r3, [r1, #8]

      if (TTY[index] . buffer . empty)
    1cc8:	e3520000 	cmp	r2, #0
      {
        TTY[index] . buffer . empty = false;
    1ccc:	13a02000 	movne	r2, #0
      }

      TTY[index] . buffer . data = c;

      semaphore_release (TTY[index] . sem_id, 1, DNA_NO_RESCHEDULE);
    1cd0:	e3a01001 	mov	r1, #1
    {
      cpu_read (UINT32, & (TTY[index] . port -> read), c);

      if (TTY[index] . buffer . empty)
      {
        TTY[index] . buffer . empty = false;
    1cd4:	15cc2004 	strbne	r2, [ip, #4]
      }

      TTY[index] . buffer . data = c;
    1cd8:	e5cc3005 	strb	r3, [ip, #5]

      semaphore_release (TTY[index] . sem_id, 1, DNA_NO_RESCHEDULE);
    1cdc:	e59c0010 	ldr	r0, [ip, #16]
    1ce0:	e1a02001 	mov	r2, r1
    1ce4:	eb002af9 	bl	c8d0 <semaphore_release>
      return DNA_INVOKE_SCHEDULER;
    1ce8:	e3a00003 	mov	r0, #3
    1cec:	e8bd8008 	pop	{r3, pc}
    1cf0:	00025520 	.word	0x00025520
    1cf4:	0003557c 	.word	0x0003557c

00001cf8 <soclib_platform_publish_devices>:



const char ** soclib_platform_publish_devices (void)
{
	 return (const char **)soclib_platform_devices;
    1cf8:	e59f3004 	ldr	r3, [pc, #4]	; 1d04 <soclib_platform_publish_devices+0xc>
}
    1cfc:	e5930000 	ldr	r0, [r3]
    1d00:	e12fff1e 	bx	lr
    1d04:	00035580 	.word	0x00035580

00001d08 <soclib_fb_isr>:

int32_t soclib_fb_isr (int32_t itn)
{

  return DNA_UNHANDLED_INTERRUPT;
}
    1d08:	e3a00004 	mov	r0, #4
    1d0c:	e12fff1e 	bx	lr

00001d10 <soclib_fb_init_driver>:

  /*
   * Create the device name array
   */

  soclib_fb_devices = kernel_malloc (sizeof (char *) *
    1d10:	e3a01001 	mov	r1, #1
#include <MemoryManager/MemoryManager.h>
#include <Processor/Processor.h>
#include <DnaTools/DnaTools.h>

status_t soclib_fb_init_driver (void)
{
    1d14:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

  /*
   * Create the device name array
   */

  soclib_fb_devices = kernel_malloc (sizeof (char *) *
    1d18:	e59fb0e4 	ldr	fp, [pc, #228]	; 1e04 <soclib_fb_init_driver+0xf4>
#include <MemoryManager/MemoryManager.h>
#include <Processor/Processor.h>
#include <DnaTools/DnaTools.h>

status_t soclib_fb_init_driver (void)
{
    1d1c:	e24dd00c 	sub	sp, sp, #12

  /*
   * Create the device name array
   */

  soclib_fb_devices = kernel_malloc (sizeof (char *) *
    1d20:	e59b0000 	ldr	r0, [fp]
    1d24:	e59f80dc 	ldr	r8, [pc, #220]	; 1e08 <soclib_fb_init_driver+0xf8>
    1d28:	e1a00100 	lsl	r0, r0, #2
    1d2c:	e0800001 	add	r0, r0, r1
    1d30:	eb002e6f 	bl	d6f4 <kernel_malloc>

  /*
   * Create the FBs
   */

  FB = kernel_malloc (sizeof (soclib_framebuffer_t) * SOCLIB_FB_NDEV, true);
    1d34:	e59b3000 	ldr	r3, [fp]

  /*
   * Create the device name array
   */

  soclib_fb_devices = kernel_malloc (sizeof (char *) *
    1d38:	e5880000 	str	r0, [r8]

  /*
   * Create the FBs
   */

  FB = kernel_malloc (sizeof (soclib_framebuffer_t) * SOCLIB_FB_NDEV, true);
    1d3c:	e0830083 	add	r0, r3, r3, lsl #1
    1d40:	e1a00200 	lsl	r0, r0, #4
    1d44:	e3a01001 	mov	r1, #1
    1d48:	eb002e69 	bl	d6f4 <kernel_malloc>
    1d4c:	e59f60b8 	ldr	r6, [pc, #184]	; 1e0c <soclib_fb_init_driver+0xfc>
  if (FB == NULL) return DNA_OUT_OF_MEM;
    1d50:	e3500000 	cmp	r0, #0

  /*
   * Create the FBs
   */

  FB = kernel_malloc (sizeof (soclib_framebuffer_t) * SOCLIB_FB_NDEV, true);
    1d54:	e5860000 	str	r0, [r6]
  if (FB == NULL) return DNA_OUT_OF_MEM;
    1d58:	0a000026 	beq	1df8 <soclib_fb_init_driver+0xe8>

  for (int32_t i = 0; i < SOCLIB_FB_NDEV; i += 1)
    1d5c:	e59b3000 	ldr	r3, [fp]
    1d60:	e3530000 	cmp	r3, #0
    1d64:	0a000020 	beq	1dec <soclib_fb_init_driver+0xdc>
    1d68:	e3a0a000 	mov	sl, #0
    1d6c:	e1a0700a 	mov	r7, sl
    1d70:	e1a0400a 	mov	r4, sl
    1d74:	e59f9094 	ldr	r9, [pc, #148]	; 1e10 <soclib_fb_init_driver+0x100>
  {
    dna_itoa (i, alpha_index);
    1d78:	e1a00004 	mov	r0, r4
    1d7c:	e1a0100d 	mov	r1, sp
    1d80:	eb001ec9 	bl	98ac <dna_itoa>
    dna_strcpy (FB[i] . name, "video/simulator/");
    1d84:	e0875087 	add	r5, r7, r7, lsl #1
    1d88:	e5960000 	ldr	r0, [r6]
    1d8c:	e1a05205 	lsl	r5, r5, #4
    1d90:	e0800005 	add	r0, r0, r5
    1d94:	e59f1078 	ldr	r1, [pc, #120]	; 1e14 <soclib_fb_init_driver+0x104>
    1d98:	eb001e52 	bl	96e8 <dna_strcpy>
    dna_strcat (FB[i] . name, alpha_index);
    1d9c:	e5960000 	ldr	r0, [r6]
    1da0:	e1a0100d 	mov	r1, sp
    1da4:	e0800005 	add	r0, r0, r5
    1da8:	eb001dcf 	bl	94ec <dna_strcat>
    soclib_fb_devices[i] = FB[i] . name;
    1dac:	e5962000 	ldr	r2, [r6]
    1db0:	e5983000 	ldr	r3, [r8]
    1db4:	e0822005 	add	r2, r2, r5
    1db8:	e7832107 	str	r2, [r3, r7, lsl #2]
    FB[i] . config = SOCLIB_FB_DEVICES[i];
    1dbc:	e5962000 	ldr	r2, [r6]
   */

  FB = kernel_malloc (sizeof (soclib_framebuffer_t) * SOCLIB_FB_NDEV, true);
  if (FB == NULL) return DNA_OUT_OF_MEM;

  for (int32_t i = 0; i < SOCLIB_FB_NDEV; i += 1)
    1dc0:	e59b3000 	ldr	r3, [fp]
    1dc4:	e2844001 	add	r4, r4, #1
  {
    dna_itoa (i, alpha_index);
    dna_strcpy (FB[i] . name, "video/simulator/");
    dna_strcat (FB[i] . name, alpha_index);
    soclib_fb_devices[i] = FB[i] . name;
    FB[i] . config = SOCLIB_FB_DEVICES[i];
    1dc8:	e0825005 	add	r5, r2, r5
   */

  FB = kernel_malloc (sizeof (soclib_framebuffer_t) * SOCLIB_FB_NDEV, true);
  if (FB == NULL) return DNA_OUT_OF_MEM;

  for (int32_t i = 0; i < SOCLIB_FB_NDEV; i += 1)
    1dcc:	e1540003 	cmp	r4, r3
  {
    dna_itoa (i, alpha_index);
    dna_strcpy (FB[i] . name, "video/simulator/");
    dna_strcat (FB[i] . name, alpha_index);
    soclib_fb_devices[i] = FB[i] . name;
    FB[i] . config = SOCLIB_FB_DEVICES[i];
    1dd0:	e2855020 	add	r5, r5, #32
    1dd4:	e089300a 	add	r3, r9, sl
    1dd8:	e8930007 	ldm	r3, {r0, r1, r2}
    1ddc:	e28aa00c 	add	sl, sl, #12
    1de0:	e8850007 	stm	r5, {r0, r1, r2}
   */

  FB = kernel_malloc (sizeof (soclib_framebuffer_t) * SOCLIB_FB_NDEV, true);
  if (FB == NULL) return DNA_OUT_OF_MEM;

  for (int32_t i = 0; i < SOCLIB_FB_NDEV; i += 1)
    1de4:	e1a07004 	mov	r7, r4
    1de8:	3affffe2 	bcc	1d78 <soclib_fb_init_driver+0x68>
    dna_strcat (FB[i] . name, alpha_index);
    soclib_fb_devices[i] = FB[i] . name;
    FB[i] . config = SOCLIB_FB_DEVICES[i];
  }

  return DNA_OK;
    1dec:	e3a00000 	mov	r0, #0
}
    1df0:	e28dd00c 	add	sp, sp, #12
    1df4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  /*
   * Create the FBs
   */

  FB = kernel_malloc (sizeof (soclib_framebuffer_t) * SOCLIB_FB_NDEV, true);
  if (FB == NULL) return DNA_OUT_OF_MEM;
    1df8:	e59f0018 	ldr	r0, [pc, #24]	; 1e18 <soclib_fb_init_driver+0x108>
    soclib_fb_devices[i] = FB[i] . name;
    FB[i] . config = SOCLIB_FB_DEVICES[i];
  }

  return DNA_OK;
}
    1dfc:	e28dd00c 	add	sp, sp, #12
    1e00:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1e04:	0002553c 	.word	0x0002553c
    1e08:	00035584 	.word	0x00035584
    1e0c:	00035588 	.word	0x00035588
    1e10:	00025540 	.word	0x00025540
    1e14:	00023ae8 	.word	0x00023ae8
    1e18:	0000fffd 	.word	0x0000fffd

00001e1c <soclib_fb_find_device>:
#include <DnaTools/DnaTools.h>

device_cmd_t * soclib_fb_find_device (const char * name)
{
  return & soclib_fb_commands;
}
    1e1c:	e59f0000 	ldr	r0, [pc]	; 1e24 <soclib_fb_find_device+0x8>
    1e20:	e12fff1e 	bx	lr
    1e24:	00024a84 	.word	0x00024a84

00001e28 <soclib_fb_open>:
#include <Private/Driver.h>
#include <Processor/Processor.h>
#include <DnaTools/DnaTools.h>

status_t soclib_fb_open (char * name, int32_t mode, void ** data)
{
    1e28:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}

  for (int32_t index = 0; FB[index] . name != NULL; index += 1)
    1e2c:	e59f505c 	ldr	r5, [pc, #92]	; 1e90 <soclib_fb_open+0x68>
    1e30:	e5951000 	ldr	r1, [r5]
    1e34:	e3510000 	cmp	r1, #0
    1e38:	0a000012 	beq	1e88 <soclib_fb_open+0x60>
    1e3c:	e1a06000 	mov	r6, r0
    1e40:	e1a08002 	mov	r8, r2
    1e44:	e3a04030 	mov	r4, #48	; 0x30
    1e48:	e3a07000 	mov	r7, #0
    1e4c:	ea000005 	b	1e68 <soclib_fb_open+0x40>
    1e50:	e5951000 	ldr	r1, [r5]
    1e54:	e2843030 	add	r3, r4, #48	; 0x30
    1e58:	e0911004 	adds	r1, r1, r4
    1e5c:	0a000009 	beq	1e88 <soclib_fb_open+0x60>
    1e60:	e1a07004 	mov	r7, r4
    1e64:	e1a04003 	mov	r4, r3
  {
    if (dna_strcmp (name, FB[index] . name) == 0)
    1e68:	e1a00006 	mov	r0, r6
    1e6c:	eb001daf 	bl	9530 <dna_strcmp>
    1e70:	e3500000 	cmp	r0, #0
    1e74:	1afffff5 	bne	1e50 <soclib_fb_open+0x28>
    {
      *data = & FB[index];
    1e78:	e5953000 	ldr	r3, [r5]
    1e7c:	e0837007 	add	r7, r3, r7
    1e80:	e5887000 	str	r7, [r8]
      return DNA_OK;
    1e84:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }
  }

  return DNA_ERROR;
    1e88:	e59f0004 	ldr	r0, [pc, #4]	; 1e94 <soclib_fb_open+0x6c>
}
    1e8c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    1e90:	00035588 	.word	0x00035588
    1e94:	0000ffff 	.word	0x0000ffff

00001e98 <soclib_fb_init_hardware>:
#include <DnaTools/DnaTools.h>

status_t soclib_fb_init_hardware (void)
{
  return DNA_OK;
}
    1e98:	e3a00000 	mov	r0, #0
    1e9c:	e12fff1e 	bx	lr

00001ea0 <soclib_fb_free>:
#include <DnaTools/DnaTools.h>

status_t soclib_fb_free (void * data)
{
  return DNA_OK;
}
    1ea0:	e3a00000 	mov	r0, #0
    1ea4:	e12fff1e 	bx	lr

00001ea8 <soclib_fb_read>:
#include <Private/Driver.h>
#include <DnaTools/DnaTools.h>

status_t soclib_fb_read (void * handler, void * destination,
    int64_t offset, int32_t * p_count)
{
    1ea8:	e92d4008 	push	{r3, lr}
    1eac:	e59d3008 	ldr	r3, [sp, #8]
  soclib_framebuffer_t * fb = handler;
  uint8_t * source = fb -> config . buffer + offset;
    1eb0:	e5900028 	ldr	r0, [r0, #40]	; 0x28


  cpu_vector_read (UINT8, destination, source, *p_count);
    1eb4:	e0800002 	add	r0, r0, r2
    1eb8:	e5932000 	ldr	r2, [r3]
    1ebc:	eb001ec7 	bl	99e0 <cpu_vector_transfer>
  return DNA_OK;
}
    1ec0:	e3a00000 	mov	r0, #0
    1ec4:	e8bd8008 	pop	{r3, pc}

00001ec8 <soclib_fb_publish_devices>:

#include <Private/Driver.h>

const char ** soclib_fb_publish_devices (void)
{
  return (const char **) soclib_fb_devices;
    1ec8:	e59f3004 	ldr	r3, [pc, #4]	; 1ed4 <soclib_fb_publish_devices+0xc>
}
    1ecc:	e5930000 	ldr	r0, [r3]
    1ed0:	e12fff1e 	bx	lr
    1ed4:	00035584 	.word	0x00035584

00001ed8 <soclib_fb_write>:
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>

status_t soclib_fb_write (void * handler, void * source,
    int64_t offset, int32_t * p_count)
{
    1ed8:	e92d4070 	push	{r4, r5, r6, lr}
    1edc:	e1a04000 	mov	r4, r0
  soclib_framebuffer_t * fb = handler;
  uint8_t * destination = NULL;

  if (fb -> autorewind)
    1ee0:	e5d0002c 	ldrb	r0, [r0, #44]	; 0x2c
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>

status_t soclib_fb_write (void * handler, void * source,
    int64_t offset, int32_t * p_count)
{
    1ee4:	e1a06001 	mov	r6, r1
  soclib_framebuffer_t * fb = handler;
  uint8_t * destination = NULL;

  if (fb -> autorewind)
    1ee8:	e3500000 	cmp	r0, #0
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>

status_t soclib_fb_write (void * handler, void * source,
    int64_t offset, int32_t * p_count)
{
    1eec:	e59d5010 	ldr	r5, [sp, #16]
  soclib_framebuffer_t * fb = handler;
  uint8_t * destination = NULL;

  if (fb -> autorewind)
    1ef0:	0a000007 	beq	1f14 <soclib_fb_write+0x3c>
  {
    offset = offset % (fb -> config . width * fb -> config . height * 2);
    1ef4:	e5941020 	ldr	r1, [r4, #32]
    1ef8:	e594c024 	ldr	ip, [r4, #36]	; 0x24
    1efc:	e1a00002 	mov	r0, r2
    1f00:	e002019c 	mul	r2, ip, r1
    1f04:	e1a01003 	mov	r1, r3
    1f08:	e1a02082 	lsl	r2, r2, #1
    1f0c:	e3a03000 	mov	r3, #0
    1f10:	eb002f8c 	bl	dd48 <__aeabi_ldivmod>
  }

  destination = fb -> config . buffer + offset;
    1f14:	e5941028 	ldr	r1, [r4, #40]	; 0x28

  dna_log(VERBOSE_LEVEL, "FB: %d bytes @ 0x%x offset to 0x%x",
      *p_count, (int32_t)offset, destination);

  cpu_vector_write (UINT8, destination, source, *p_count);
    1f18:	e1a00006 	mov	r0, r6
    1f1c:	e0811002 	add	r1, r1, r2
    1f20:	e5952000 	ldr	r2, [r5]
    1f24:	eb001ead 	bl	99e0 <cpu_vector_transfer>
  return DNA_OK;
}
    1f28:	e3a00000 	mov	r0, #0
    1f2c:	e8bd8070 	pop	{r4, r5, r6, pc}

00001f30 <soclib_fb_control>:
    va_list arguments, int32_t * p_ret)
{
  soclib_framebuffer_t * fb = (soclib_framebuffer_t *) handler;
  bool value = va_arg(arguments, int32_t);

  switch (function)
    1f30:	e59fc02c 	ldr	ip, [pc, #44]	; 1f64 <soclib_fb_control+0x34>

status_t soclib_fb_control (void * handler, int32_t function,
    va_list arguments, int32_t * p_ret)
{
  soclib_framebuffer_t * fb = (soclib_framebuffer_t *) handler;
  bool value = va_arg(arguments, int32_t);
    1f34:	e5922000 	ldr	r2, [r2]

  switch (function)
    1f38:	e151000c 	cmp	r1, ip
    1f3c:	0a000001 	beq	1f48 <soclib_fb_control+0x18>
      fb -> autorewind = value;
      *p_ret = 0;
      break;

    default:
      return DNA_ERROR;
    1f40:	e59f0020 	ldr	r0, [pc, #32]	; 1f68 <soclib_fb_control+0x38>
  }

  return DNA_OK;
}
    1f44:	e12fff1e 	bx	lr

status_t soclib_fb_control (void * handler, int32_t function,
    va_list arguments, int32_t * p_ret)
{
  soclib_framebuffer_t * fb = (soclib_framebuffer_t *) handler;
  bool value = va_arg(arguments, int32_t);
    1f48:	e2922000 	adds	r2, r2, #0
  {
    case FB_SET_AUTOREWIND:
      dna_log(INFO_LEVEL, "Setting autorewind to 0x%x", value);

      fb -> autorewind = value;
      *p_ret = 0;
    1f4c:	e3a01000 	mov	r1, #0

status_t soclib_fb_control (void * handler, int32_t function,
    va_list arguments, int32_t * p_ret)
{
  soclib_framebuffer_t * fb = (soclib_framebuffer_t *) handler;
  bool value = va_arg(arguments, int32_t);
    1f50:	13a02001 	movne	r2, #1
    1f54:	e5c0202c 	strb	r2, [r0, #44]	; 0x2c

    default:
      return DNA_ERROR;
  }

  return DNA_OK;
    1f58:	e1a00001 	mov	r0, r1
  {
    case FB_SET_AUTOREWIND:
      dna_log(INFO_LEVEL, "Setting autorewind to 0x%x", value);

      fb -> autorewind = value;
      *p_ret = 0;
    1f5c:	e5831000 	str	r1, [r3]

    default:
      return DNA_ERROR;
  }

  return DNA_OK;
    1f60:	e12fff1e 	bx	lr
    1f64:	00000fff 	.word	0x00000fff
    1f68:	0000ffff 	.word	0x0000ffff

00001f6c <soclib_fb_uninit_driver>:

#include <Private/Driver.h>
#include <DnaTools/DnaTools.h>

void  soclib_fb_uninit_driver (void)
{
    1f6c:	e12fff1e 	bx	lr

00001f70 <soclib_fb_close>:

status_t soclib_fb_close (void * data)
{

  return DNA_OK;
}
    1f70:	e3a00000 	mov	r0, #0
    1f74:	e12fff1e 	bx	lr

00001f78 <block_device_init_driver>:
#include <DnaTools/DnaTools.h>

block_device_control_t * block_device_controls ;

status_t block_device_init_driver (void)
{
    1f78:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
  char alpha_num[8], semaphore_name_buffer[64], * semaphore_prefix = "block_device_" ;
  char isr_semaphore_name[64] ;
  
  watch (status_t)
  {
    block_device_controls = kernel_malloc (sizeof (block_device_control_t) * 
    1f7c:	e59f8144 	ldr	r8, [pc, #324]	; 20c8 <block_device_init_driver+0x150>
#include <DnaTools/DnaTools.h>

block_device_control_t * block_device_controls ;

status_t block_device_init_driver (void)
{
    1f80:	e24dd090 	sub	sp, sp, #144	; 0x90
  char alpha_num[8], semaphore_name_buffer[64], * semaphore_prefix = "block_device_" ;
  char isr_semaphore_name[64] ;
  
  watch (status_t)
  {
    block_device_controls = kernel_malloc (sizeof (block_device_control_t) * 
    1f84:	e5983000 	ldr	r3, [r8]
    1f88:	e3a01001 	mov	r1, #1
    1f8c:	e0630183 	rsb	r0, r3, r3, lsl #3
    1f90:	e1a00100 	lsl	r0, r0, #2
    1f94:	eb002dd6 	bl	d6f4 <kernel_malloc>
    1f98:	e59f712c 	ldr	r7, [pc, #300]	; 20cc <block_device_init_driver+0x154>
        SOCLIB_BLOCK_DEVICES_NDEV, true) ;
    ensure (block_device_controls != NULL, DNA_OUT_OF_MEM) ;
    1f9c:	e3500000 	cmp	r0, #0
  char alpha_num[8], semaphore_name_buffer[64], * semaphore_prefix = "block_device_" ;
  char isr_semaphore_name[64] ;
  
  watch (status_t)
  {
    block_device_controls = kernel_malloc (sizeof (block_device_control_t) * 
    1fa0:	e5870000 	str	r0, [r7]
        SOCLIB_BLOCK_DEVICES_NDEV, true) ;
    ensure (block_device_controls != NULL, DNA_OUT_OF_MEM) ;
    1fa4:	0a000044 	beq	20bc <block_device_init_driver+0x144>
    

    for (i = 0 ; i < SOCLIB_BLOCK_DEVICES_NDEV ; i++)
    1fa8:	e5983000 	ldr	r3, [r8]
    1fac:	e3530000 	cmp	r3, #0
    1fb0:	da00003e 	ble	20b0 <block_device_init_driver+0x138>
    1fb4:	e3a04000 	mov	r4, #0
      dna_strcpy (semaphore_name_buffer, semaphore_prefix) ;
      dna_strcat (semaphore_name_buffer, alpha_num) ;
      dna_strcat (semaphore_name_buffer, "_sem") ;

      semaphore_create (semaphore_name_buffer, 1, 
          &block_device_controls[i] . semaphore_id) ;
    1fb8:	e1a09007 	mov	r9, r7
    block_device_controls = kernel_malloc (sizeof (block_device_control_t) * 
        SOCLIB_BLOCK_DEVICES_NDEV, true) ;
    ensure (block_device_controls != NULL, DNA_OUT_OF_MEM) ;
    

    for (i = 0 ; i < SOCLIB_BLOCK_DEVICES_NDEV ; i++)
    1fbc:	e1a06004 	mov	r6, r4
    1fc0:	e59f5108 	ldr	r5, [pc, #264]	; 20d0 <block_device_init_driver+0x158>
    1fc4:	ea000004 	b	1fdc <block_device_init_driver+0x64>
    1fc8:	e5983000 	ldr	r3, [r8]
    1fcc:	e284401c 	add	r4, r4, #28
    1fd0:	e1530006 	cmp	r3, r6
    1fd4:	e285500c 	add	r5, r5, #12
    1fd8:	da000034 	ble	20b0 <block_device_init_driver+0x138>
    {
      dna_itoa (i, alpha_num) ;
    1fdc:	e1a00006 	mov	r0, r6
    1fe0:	e28d1008 	add	r1, sp, #8
    1fe4:	eb001e30 	bl	98ac <dna_itoa>
      dna_strcpy (semaphore_name_buffer, semaphore_prefix) ;
    1fe8:	e59f10e4 	ldr	r1, [pc, #228]	; 20d4 <block_device_init_driver+0x15c>
    1fec:	e28d0010 	add	r0, sp, #16
    1ff0:	eb001dbc 	bl	96e8 <dna_strcpy>
      dna_strcat (semaphore_name_buffer, alpha_num) ;
    1ff4:	e28d1008 	add	r1, sp, #8
    1ff8:	e28d0010 	add	r0, sp, #16
    1ffc:	eb001d3a 	bl	94ec <dna_strcat>
      dna_strcat (semaphore_name_buffer, "_sem") ;
    2000:	e59f10d0 	ldr	r1, [pc, #208]	; 20d8 <block_device_init_driver+0x160>
    2004:	e28d0010 	add	r0, sp, #16
    2008:	eb001d37 	bl	94ec <dna_strcat>

      semaphore_create (semaphore_name_buffer, 1, 
          &block_device_controls[i] . semaphore_id) ;
    200c:	e5972000 	ldr	r2, [r7]
      dna_itoa (i, alpha_num) ;
      dna_strcpy (semaphore_name_buffer, semaphore_prefix) ;
      dna_strcat (semaphore_name_buffer, alpha_num) ;
      dna_strcat (semaphore_name_buffer, "_sem") ;

      semaphore_create (semaphore_name_buffer, 1, 
    2010:	e3a01001 	mov	r1, #1
    2014:	e0822004 	add	r2, r2, r4
    2018:	e28d0010 	add	r0, sp, #16
    201c:	eb002988 	bl	c644 <semaphore_create>
          &block_device_controls[i] . semaphore_id) ;

      block_device_controls[i] . should_enable_irq = 
        (bool) SOCLIB_BLOCK_DEVICES[i] . should_enable_irq ;
    2020:	e5151008 	ldr	r1, [r5, #-8]
      block_device_controls[i] . port = 
        (block_device_register_map_t) SOCLIB_BLOCK_DEVICES[i] . base_address ;
    2024:	e5952000 	ldr	r2, [r5]

      semaphore_create (semaphore_name_buffer, 1, 
          &block_device_controls[i] . semaphore_id) ;

      block_device_controls[i] . should_enable_irq = 
        (bool) SOCLIB_BLOCK_DEVICES[i] . should_enable_irq ;
    2028:	e2911000 	adds	r1, r1, #0
    202c:	13a01001 	movne	r1, #1
      dna_strcat (semaphore_name_buffer, "_sem") ;

      semaphore_create (semaphore_name_buffer, 1, 
          &block_device_controls[i] . semaphore_id) ;

      block_device_controls[i] . should_enable_irq = 
    2030:	e5973000 	ldr	r3, [r7]
        (bool) SOCLIB_BLOCK_DEVICES[i] . should_enable_irq ;
      block_device_controls[i] . port = 
        (block_device_register_map_t) SOCLIB_BLOCK_DEVICES[i] . base_address ;

      cpu_read (UINT32, 
    2034:	e5920018 	ldr	r0, [r2, #24]
      dna_strcat (semaphore_name_buffer, "_sem") ;

      semaphore_create (semaphore_name_buffer, 1, 
          &block_device_controls[i] . semaphore_id) ;

      block_device_controls[i] . should_enable_irq = 
    2038:	e0833004 	add	r3, r3, r4
        (bool) SOCLIB_BLOCK_DEVICES[i] . should_enable_irq ;
      block_device_controls[i] . port = 
        (block_device_register_map_t) SOCLIB_BLOCK_DEVICES[i] . base_address ;

      cpu_read (UINT32, 
    203c:	e5830010 	str	r0, [r3, #16]
          & (block_device_controls[i] . port -> BLOCK_DEVICE_SIZE), 
          block_device_controls[i] . block_count) ;
      cpu_read (UINT32, 
    2040:	e592001c 	ldr	r0, [r2, #28]
          & (block_device_controls[i] . port -> BLOCK_DEVICE_BLOCK_SIZE), 
          block_device_controls[i] . block_size) ;

      if (block_device_controls[i] . should_enable_irq) {
    2044:	e3510000 	cmp	r1, #0
    block_device_controls = kernel_malloc (sizeof (block_device_control_t) * 
        SOCLIB_BLOCK_DEVICES_NDEV, true) ;
    ensure (block_device_controls != NULL, DNA_OUT_OF_MEM) ;
    

    for (i = 0 ; i < SOCLIB_BLOCK_DEVICES_NDEV ; i++)
    2048:	e2866001 	add	r6, r6, #1
      semaphore_create (semaphore_name_buffer, 1, 
          &block_device_controls[i] . semaphore_id) ;

      block_device_controls[i] . should_enable_irq = 
        (bool) SOCLIB_BLOCK_DEVICES[i] . should_enable_irq ;
      block_device_controls[i] . port = 
    204c:	e5832018 	str	r2, [r3, #24]
        (block_device_register_map_t) SOCLIB_BLOCK_DEVICES[i] . base_address ;

      cpu_read (UINT32, 
          & (block_device_controls[i] . port -> BLOCK_DEVICE_SIZE), 
          block_device_controls[i] . block_count) ;
      cpu_read (UINT32, 
    2050:	e5830014 	str	r0, [r3, #20]
      dna_strcat (semaphore_name_buffer, "_sem") ;

      semaphore_create (semaphore_name_buffer, 1, 
          &block_device_controls[i] . semaphore_id) ;

      block_device_controls[i] . should_enable_irq = 
    2054:	e5c31008 	strb	r1, [r3, #8]
          block_device_controls[i] . block_count) ;
      cpu_read (UINT32, 
          & (block_device_controls[i] . port -> BLOCK_DEVICE_BLOCK_SIZE), 
          block_device_controls[i] . block_size) ;

      if (block_device_controls[i] . should_enable_irq) {
    2058:	0affffda 	beq	1fc8 <block_device_init_driver+0x50>
        block_device_controls[i] . irq = SOCLIB_BLOCK_DEVICES[i] . irq ;
        interrupt_attach (0, SOCLIB_BLOCK_DEVICES[i] . irq, 0x0, 
    205c:	e3a0a000 	mov	sl, #0
      cpu_read (UINT32, 
          & (block_device_controls[i] . port -> BLOCK_DEVICE_BLOCK_SIZE), 
          block_device_controls[i] . block_size) ;

      if (block_device_controls[i] . should_enable_irq) {
        block_device_controls[i] . irq = SOCLIB_BLOCK_DEVICES[i] . irq ;
    2060:	e5151004 	ldr	r1, [r5, #-4]
        interrupt_attach (0, SOCLIB_BLOCK_DEVICES[i] . irq, 0x0, 
    2064:	e1a0200a 	mov	r2, sl
      cpu_read (UINT32, 
          & (block_device_controls[i] . port -> BLOCK_DEVICE_BLOCK_SIZE), 
          block_device_controls[i] . block_size) ;

      if (block_device_controls[i] . should_enable_irq) {
        block_device_controls[i] . irq = SOCLIB_BLOCK_DEVICES[i] . irq ;
    2068:	e583100c 	str	r1, [r3, #12]
        interrupt_attach (0, SOCLIB_BLOCK_DEVICES[i] . irq, 0x0, 
    206c:	e1a0000a 	mov	r0, sl
    2070:	e59f3064 	ldr	r3, [pc, #100]	; 20dc <block_device_init_driver+0x164>
    2074:	e58da000 	str	sl, [sp]
    2078:	eb002aa5 	bl	cb14 <interrupt_attach>
            block_device_isr, false) ;
        dna_strcpy (isr_semaphore_name, semaphore_name_buffer) ;
    207c:	e28d1010 	add	r1, sp, #16
    2080:	e28d0050 	add	r0, sp, #80	; 0x50
    2084:	eb001d97 	bl	96e8 <dna_strcpy>
        dna_strcat (isr_semaphore_name, "_isr") ;
    2088:	e28d0050 	add	r0, sp, #80	; 0x50
    208c:	e59f104c 	ldr	r1, [pc, #76]	; 20e0 <block_device_init_driver+0x168>
    2090:	eb001d15 	bl	94ec <dna_strcat>
        semaphore_create (isr_semaphore_name, 0, 
            &block_device_controls[i] . isr_semaphore_id) ;
    2094:	e5992000 	ldr	r2, [r9]
        block_device_controls[i] . irq = SOCLIB_BLOCK_DEVICES[i] . irq ;
        interrupt_attach (0, SOCLIB_BLOCK_DEVICES[i] . irq, 0x0, 
            block_device_isr, false) ;
        dna_strcpy (isr_semaphore_name, semaphore_name_buffer) ;
        dna_strcat (isr_semaphore_name, "_isr") ;
        semaphore_create (isr_semaphore_name, 0, 
    2098:	e28d0050 	add	r0, sp, #80	; 0x50
            &block_device_controls[i] . isr_semaphore_id) ;
    209c:	e0822004 	add	r2, r2, r4
        block_device_controls[i] . irq = SOCLIB_BLOCK_DEVICES[i] . irq ;
        interrupt_attach (0, SOCLIB_BLOCK_DEVICES[i] . irq, 0x0, 
            block_device_isr, false) ;
        dna_strcpy (isr_semaphore_name, semaphore_name_buffer) ;
        dna_strcat (isr_semaphore_name, "_isr") ;
        semaphore_create (isr_semaphore_name, 0, 
    20a0:	e1a0100a 	mov	r1, sl
    20a4:	e2822004 	add	r2, r2, #4
    20a8:	eb002965 	bl	c644 <semaphore_create>
    20ac:	eaffffc5 	b	1fc8 <block_device_init_driver+0x50>
            &block_device_controls[i] . isr_semaphore_id) ;
      }

    }

    return DNA_OK ;
    20b0:	e3a00000 	mov	r0, #0
  }
}
    20b4:	e28dd090 	add	sp, sp, #144	; 0x90
    20b8:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
  
  watch (status_t)
  {
    block_device_controls = kernel_malloc (sizeof (block_device_control_t) * 
        SOCLIB_BLOCK_DEVICES_NDEV, true) ;
    ensure (block_device_controls != NULL, DNA_OUT_OF_MEM) ;
    20bc:	e59f0020 	ldr	r0, [pc, #32]	; 20e4 <block_device_init_driver+0x16c>

    }

    return DNA_OK ;
  }
}
    20c0:	e28dd090 	add	sp, sp, #144	; 0x90
    20c4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
    20c8:	0002552c 	.word	0x0002552c
    20cc:	000355d0 	.word	0x000355d0
    20d0:	00025538 	.word	0x00025538
    20d4:	00023b08 	.word	0x00023b08
    20d8:	00023ad0 	.word	0x00023ad0
    20dc:	00002100 	.word	0x00002100
    20e0:	00023b18 	.word	0x00023b18
    20e4:	0000fffd 	.word	0x0000fffd

000020e8 <block_device_open>:


status_t block_device_open (char * name, int32_t mode, void ** data)
{
  
  block_device_control_t * block_device_p = block_device_controls ;
    20e8:	e59f300c 	ldr	r3, [pc, #12]	; 20fc <block_device_open+0x14>
  *data = (void *) block_device_p ;
  return DNA_OK ;
}
    20ec:	e3a00000 	mov	r0, #0


status_t block_device_open (char * name, int32_t mode, void ** data)
{
  
  block_device_control_t * block_device_p = block_device_controls ;
    20f0:	e5933000 	ldr	r3, [r3]
  *data = (void *) block_device_p ;
    20f4:	e5823000 	str	r3, [r2]
  return DNA_OK ;
}
    20f8:	e12fff1e 	bx	lr
    20fc:	000355d0 	.word	0x000355d0

00002100 <block_device_isr>:
#include <Private/SoclibBlockDeviceDriver.h>
#include <Core/Core.h>
#include <DnaTools/DnaTools.h>

int32_t block_device_isr (void * data)
{
    2100:	e92d4008 	push	{r3, lr}
  uint32_t operation_status ;
  
  block_device_control_t block_device = block_device_controls[0] ;
    2104:	e59f3034 	ldr	r3, [pc, #52]	; 2140 <block_device_isr+0x40>
    2108:	e5933000 	ldr	r3, [r3]
    210c:	e5932018 	ldr	r2, [r3, #24]
    2110:	e5930004 	ldr	r0, [r3, #4]
  dna_log(VERBOSE_LEVEL, "Entering ISR") ;

  watch (status_t)
  {
    // ISR ACK
    cpu_read (UINT32, & (block_device . port -> BLOCK_DEVICE_STATUS), operation_status) ;
    2114:	e5923010 	ldr	r3, [r2, #16]
    ensure (operation_status == BLOCK_DEVICE_READ_SUCCESS || operation_status == BLOCK_DEVICE_WRITE_SUCCESS, DNA_ERROR) ;
    2118:	e2433002 	sub	r3, r3, #2
    211c:	e3530001 	cmp	r3, #1
    2120:	9a000001 	bls	212c <block_device_isr+0x2c>
    2124:	e59f0018 	ldr	r0, [pc, #24]	; 2144 <block_device_isr+0x44>
    dna_log(VERBOSE_LEVEL, "Operation succeeded.") ;

    semaphore_release (block_device . isr_semaphore_id, 1, DNA_NO_RESCHEDULE) ;
    return DNA_INVOKE_SCHEDULER ;
  }
}
    2128:	e8bd8008 	pop	{r3, pc}
    cpu_read (UINT32, & (block_device . port -> BLOCK_DEVICE_STATUS), operation_status) ;
    ensure (operation_status == BLOCK_DEVICE_READ_SUCCESS || operation_status == BLOCK_DEVICE_WRITE_SUCCESS, DNA_ERROR) ;

    dna_log(VERBOSE_LEVEL, "Operation succeeded.") ;

    semaphore_release (block_device . isr_semaphore_id, 1, DNA_NO_RESCHEDULE) ;
    212c:	e3a01001 	mov	r1, #1
    2130:	e1a02001 	mov	r2, r1
    2134:	eb0029e5 	bl	c8d0 <semaphore_release>
    return DNA_INVOKE_SCHEDULER ;
    2138:	e3a00003 	mov	r0, #3
    213c:	e8bd8008 	pop	{r3, pc}
    2140:	000355d0 	.word	0x000355d0
    2144:	0000ffff 	.word	0x0000ffff

00002148 <block_device_write>:
#include <DnaTools/DnaTools.h>


status_t block_device_write (void * handler, void * source, 
        int64_t offset, int32_t * p_count)
{
    2148:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

  dna_log(VERBOSE_LEVEL, "Writing %d bytes with offset %d from source 0x%x",
      *p_count, offset, source) ;
  watch (status_t)
  {
    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;
    214c:	e3e06000 	mvn	r6, #0
    2150:	e3e07000 	mvn	r7, #0
#include <DnaTools/DnaTools.h>


status_t block_device_write (void * handler, void * source, 
        int64_t offset, int32_t * p_count)
{
    2154:	e1a08000 	mov	r8, r0
    2158:	e1a04002 	mov	r4, r2
    215c:	e1a05003 	mov	r5, r3
    2160:	e24dd014 	sub	sp, sp, #20

  dna_log(VERBOSE_LEVEL, "Writing %d bytes with offset %d from source 0x%x",
      *p_count, offset, source) ;
  watch (status_t)
  {
    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;
    2164:	e5900000 	ldr	r0, [r0]
    2168:	e3a02000 	mov	r2, #0
    216c:	e1cd60f0 	strd	r6, [sp]
#include <DnaTools/DnaTools.h>


status_t block_device_write (void * handler, void * source, 
        int64_t offset, int32_t * p_count)
{
    2170:	e1a09001 	mov	r9, r1

  dna_log(VERBOSE_LEVEL, "Writing %d bytes with offset %d from source 0x%x",
      *p_count, offset, source) ;
  watch (status_t)
  {
    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;
    2174:	e3a01001 	mov	r1, #1
    2178:	eb002513 	bl	b5cc <semaphore_acquire>

    block_start = offset / block_device -> block_size ;
    217c:	e598b014 	ldr	fp, [r8, #20]
    2180:	e1a00004 	mov	r0, r4
    2184:	e1a07fcb 	asr	r7, fp, #31
    2188:	e1a03007 	mov	r3, r7
    218c:	e1a0200b 	mov	r2, fp
    2190:	e1a01005 	mov	r1, r5
    2194:	eb002eeb 	bl	dd48 <__aeabi_ldivmod>
    block_end = (offset + *p_count) / block_device -> block_size ;
    2198:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
      *p_count, offset, source) ;
  watch (status_t)
  {
    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;

    block_start = offset / block_device -> block_size ;
    219c:	e1a0a000 	mov	sl, r0
    block_end = (offset + *p_count) / block_device -> block_size ;
    21a0:	e5930000 	ldr	r0, [r3]
    21a4:	e1a03007 	mov	r3, r7
    21a8:	e0946000 	adds	r6, r4, r0
    21ac:	e0a57fc0 	adc	r7, r5, r0, asr #31
    21b0:	e1a0200b 	mov	r2, fp
    21b4:	e1a00006 	mov	r0, r6
    21b8:	e1a01007 	mov	r1, r7
    21bc:	eb002ee1 	bl	dd48 <__aeabi_ldivmod>
    nb_blocks = block_end - block_start + 1 ;
    21c0:	e06a0000 	rsb	r0, sl, r0
    21c4:	e2806001 	add	r6, r0, #1

    bulk_buffer = kernel_malloc (nb_blocks *
    21c8:	e0000b96 	mul	r0, r6, fp
    21cc:	e3a01000 	mov	r1, #0
    21d0:	eb002d47 	bl	d6f4 <kernel_malloc>
        block_device -> block_size, false) ;
    bulk_buffer_base_address = bulk_buffer ;
    ensure (bulk_buffer != NULL, DNA_OUT_OF_MEM) ;
    21d4:	e2507000 	subs	r7, r0, #0
    21d8:	059f4174 	ldreq	r4, [pc, #372]	; 2354 <block_device_write+0x20c>
    21dc:	0a00000f 	beq	2220 <block_device_write+0xd8>

    ensure (
    21e0:	e5982014 	ldr	r2, [r8, #20]
    21e4:	e1a00004 	mov	r0, r4
    21e8:	e1a03fc2 	asr	r3, r2, #31
    21ec:	e1a01005 	mov	r1, r5
    21f0:	eb002ed4 	bl	dd48 <__aeabi_ldivmod>
    21f4:	e1a03001 	mov	r3, r1
    21f8:	e3a01000 	mov	r1, #0
    21fc:	e1a02000 	mov	r2, r0
    2200:	e58d1004 	str	r1, [sp, #4]
    2204:	e58d6000 	str	r6, [sp]
    2208:	e1a00008 	mov	r0, r8
    220c:	e1a01007 	mov	r1, r7
    2210:	eb000121 	bl	269c <access_device_blocks>
    2214:	e3500000 	cmp	r0, #0
    2218:	0a000003 	beq	222c <block_device_write+0xe4>
    221c:	e59f4134 	ldr	r4, [pc, #308]	; 2358 <block_device_write+0x210>
    semaphore_release (block_device -> semaphore_id, 1, DNA_NO_RESCHEDULE) ;
    return DNA_OK ;
  }

  return DNA_NOT_IMPLEMENTED ;
}
    2220:	e1a00004 	mov	r0, r4
    2224:	e28dd014 	add	sp, sp, #20
    2228:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
                           offset / block_device -> block_size, 
                           nb_blocks,
                           READ) 
        == DNA_OK, DNA_ERROR) ;

    cpu_cache_invalidate (CPU_CACHE_DATA, bulk_buffer, 
    222c:	e5982014 	ldr	r2, [r8, #20]
    2230:	e3a00001 	mov	r0, #1
    2234:	e0020692 	mul	r2, r2, r6
    2238:	e1a01007 	mov	r1, r7
    223c:	eb001e07 	bl	9a60 <cpu_cache_invalidate>
        block_device -> block_size * nb_blocks) ;

    local_offset = offset % block_device -> block_size ;
    2240:	e598c014 	ldr	ip, [r8, #20]
    2244:	e1a00004 	mov	r0, r4
    2248:	e1a01005 	mov	r1, r5
    224c:	e1a0200c 	mov	r2, ip
    2250:	e1a03fcc 	asr	r3, ip, #31
    2254:	e58dc00c 	str	ip, [sp, #12]
    2258:	eb002eba 	bl	dd48 <__aeabi_ldivmod>
    bulk_buffer += local_offset ;
    remaining_bytes = *p_count ;
    225c:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
    source_buffer = source ;

    local_count = remaining_bytes > block_device -> block_size - local_offset ? block_device -> block_size - local_offset : remaining_bytes ;
    2260:	e59dc00c 	ldr	ip, [sp, #12]
    cpu_cache_invalidate (CPU_CACHE_DATA, bulk_buffer, 
        block_device -> block_size * nb_blocks) ;

    local_offset = offset % block_device -> block_size ;
    bulk_buffer += local_offset ;
    remaining_bytes = *p_count ;
    2264:	e593b000 	ldr	fp, [r3]
    source_buffer = source ;

    local_count = remaining_bytes > block_device -> block_size - local_offset ? block_device -> block_size - local_offset : remaining_bytes ;
    2268:	e062500c 	rsb	r5, r2, ip
    226c:	e155000b 	cmp	r5, fp
    2270:	a1a0500b 	movge	r5, fp
    
    if (local_count > 0) {
    2274:	e3550000 	cmp	r5, #0

    cpu_cache_invalidate (CPU_CACHE_DATA, bulk_buffer, 
        block_device -> block_size * nb_blocks) ;

    local_offset = offset % block_device -> block_size ;
    bulk_buffer += local_offset ;
    2278:	e0874002 	add	r4, r7, r2
    remaining_bytes = *p_count ;
    source_buffer = source ;

    local_count = remaining_bytes > block_device -> block_size - local_offset ? block_device -> block_size - local_offset : remaining_bytes ;
    
    if (local_count > 0) {
    227c:	da000007 	ble	22a0 <block_device_write+0x158>
      dna_memcpy (bulk_buffer, source_buffer, local_count) ;
    2280:	e1a00004 	mov	r0, r4
    2284:	e1a01009 	mov	r1, r9
    2288:	e1a02005 	mov	r2, r5
    228c:	eb001d1c 	bl	9704 <dna_memcpy>
    2290:	e598c014 	ldr	ip, [r8, #20]
      bulk_buffer += local_count ;
      source_buffer += local_count ;
      remaining_bytes -= local_count ;
    2294:	e065b00b 	rsb	fp, r5, fp

    local_count = remaining_bytes > block_device -> block_size - local_offset ? block_device -> block_size - local_offset : remaining_bytes ;
    
    if (local_count > 0) {
      dna_memcpy (bulk_buffer, source_buffer, local_count) ;
      bulk_buffer += local_count ;
    2298:	e0844005 	add	r4, r4, r5
      source_buffer += local_count ;
    229c:	e0899005 	add	r9, r9, r5
      remaining_bytes -= local_count ;
    }

    quot = remaining_bytes / block_device -> block_size ;
    22a0:	e1a0100c 	mov	r1, ip
    22a4:	e1a0000b 	mov	r0, fp
    22a8:	e58dc00c 	str	ip, [sp, #12]
    22ac:	eb002e52 	bl	dbfc <__aeabi_idiv>
    while (quot > 0)
    22b0:	e2505000 	subs	r5, r0, #0
    22b4:	e59dc00c 	ldr	ip, [sp, #12]
    22b8:	da000009 	ble	22e4 <block_device_write+0x19c>
    {
      dna_memcpy (bulk_buffer, source_buffer, block_device -> block_size) ;
    22bc:	e1a0200c 	mov	r2, ip
    22c0:	e1a00004 	mov	r0, r4
    22c4:	e1a01009 	mov	r1, r9
    22c8:	eb001d0d 	bl	9704 <dna_memcpy>
      bulk_buffer += block_device -> block_size ;
    22cc:	e598c014 	ldr	ip, [r8, #20]
      source_buffer += local_count ;
      remaining_bytes -= local_count ;
    }

    quot = remaining_bytes / block_device -> block_size ;
    while (quot > 0)
    22d0:	e2555001 	subs	r5, r5, #1
    {
      dna_memcpy (bulk_buffer, source_buffer, block_device -> block_size) ;
      bulk_buffer += block_device -> block_size ;
    22d4:	e084400c 	add	r4, r4, ip
      source_buffer += block_device -> block_size ;
    22d8:	e089900c 	add	r9, r9, ip
      remaining_bytes -= block_device -> block_size ;
    22dc:	e06cb00b 	rsb	fp, ip, fp
      source_buffer += local_count ;
      remaining_bytes -= local_count ;
    }

    quot = remaining_bytes / block_device -> block_size ;
    while (quot > 0)
    22e0:	1afffff5 	bne	22bc <block_device_write+0x174>
      source_buffer += block_device -> block_size ;
      remaining_bytes -= block_device -> block_size ;
      quot-- ;
    }

    if (remaining_bytes > 0)
    22e4:	e35b0000 	cmp	fp, #0
    22e8:	da000004 	ble	2300 <block_device_write+0x1b8>
    {
      dna_memcpy (bulk_buffer, source_buffer, remaining_bytes) ;
    22ec:	e1a00004 	mov	r0, r4
    22f0:	e1a01009 	mov	r1, r9
    22f4:	e1a0200b 	mov	r2, fp
    22f8:	eb001d01 	bl	9704 <dna_memcpy>
    22fc:	e598c014 	ldr	ip, [r8, #20]
    }

    cpu_cache_invalidate (CPU_CACHE_DATA, bulk_buffer_base_address, 
        block_device -> block_size * nb_blocks) ;

    ensure (access_device_blocks (block_device, 
    2300:	e3a05001 	mov	r5, #1
    if (remaining_bytes > 0)
    {
      dna_memcpy (bulk_buffer, source_buffer, remaining_bytes) ;
    }

    cpu_cache_invalidate (CPU_CACHE_DATA, bulk_buffer_base_address, 
    2304:	e002069c 	mul	r2, ip, r6
    2308:	e1a00005 	mov	r0, r5
    230c:	e1a01007 	mov	r1, r7
    2310:	eb001dd2 	bl	9a60 <cpu_cache_invalidate>
        block_device -> block_size * nb_blocks) ;

    ensure (access_device_blocks (block_device, 
    2314:	e58d6000 	str	r6, [sp]
    2318:	e58d5004 	str	r5, [sp, #4]
    231c:	e1a00008 	mov	r0, r8
    2320:	e1a01007 	mov	r1, r7
    2324:	e1a0200a 	mov	r2, sl
    2328:	e1a03fca 	asr	r3, sl, #31
    232c:	eb0000da 	bl	269c <access_device_blocks>
    2330:	e2504000 	subs	r4, r0, #0
    2334:	1affffb8 	bne	221c <block_device_write+0xd4>
        == DNA_OK, DNA_ERROR) ;

    dna_log(VERBOSE_LEVEL, "Wrote %d block(s) from block %d, using 0x%x as a source address", 
        nb_blocks, block_start, bulk_buffer_base_address) ;
    
    kernel_free (bulk_buffer_base_address) ;
    2338:	e1a00007 	mov	r0, r7
    233c:	eb002d21 	bl	d7c8 <kernel_free>
    semaphore_release (block_device -> semaphore_id, 1, DNA_NO_RESCHEDULE) ;
    2340:	e1a01005 	mov	r1, r5
    2344:	e5980000 	ldr	r0, [r8]
    2348:	e1a02005 	mov	r2, r5
    234c:	eb00295f 	bl	c8d0 <semaphore_release>
    return DNA_OK ;
    2350:	eaffffb2 	b	2220 <block_device_write+0xd8>
    2354:	0000fffd 	.word	0x0000fffd
    2358:	0000ffff 	.word	0x0000ffff

0000235c <block_device_read>:
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t block_device_read (void * handler, void * destination,
    int64_t offset, int32_t * p_count) 
{
    235c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2360:	e1a04002 	mov	r4, r2
    2364:	e1a05003 	mov	r5, r3
    2368:	e24dd01c 	sub	sp, sp, #28
  dna_log(VERBOSE_LEVEL, "Reading %d bytes with offset %d at destination 0x%x", 
      *p_count, (uint32_t) offset, destination) ;
  watch (status_t)
  {

    ensure (offset + *p_count <= 
    236c:	e590b014 	ldr	fp, [r0, #20]
    2370:	e5908010 	ldr	r8, [r0, #16]
    2374:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
    2378:	e0080b98 	mul	r8, r8, fp
    237c:	e5923000 	ldr	r3, [r2]
    2380:	e1a09fc8 	asr	r9, r8, #31
    2384:	e0946003 	adds	r6, r4, r3
    2388:	e0a57fc3 	adc	r7, r5, r3, asr #31
    238c:	e1580006 	cmp	r8, r6
    2390:	e0d93007 	sbcs	r3, r9, r7
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t block_device_read (void * handler, void * destination,
    int64_t offset, int32_t * p_count) 
{
    2394:	e1a0a000 	mov	sl, r0
  dna_log(VERBOSE_LEVEL, "Reading %d bytes with offset %d at destination 0x%x", 
      *p_count, (uint32_t) offset, destination) ;
  watch (status_t)
  {

    ensure (offset + *p_count <= 
    2398:	b59f9214 	ldrlt	r9, [pc, #532]	; 25b4 <block_device_read+0x258>
    239c:	aa000002 	bge	23ac <block_device_read+0x50>

    kernel_free (read_buffer_base_address) ;
    semaphore_release (block_device -> semaphore_id, 1, DNA_NO_RESCHEDULE) ;
    return DNA_OK ;
  }
}
    23a0:	e1a00009 	mov	r0, r9
    23a4:	e28dd01c 	add	sp, sp, #28
    23a8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ensure (offset + *p_count <= 
        block_device -> block_count * block_device -> block_size, 
        DNA_BAD_ARGUMENT) ;
    block_size = block_device -> block_size ;

    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;
    23ac:	e3e03000 	mvn	r3, #0
    23b0:	e3e02000 	mvn	r2, #0
    23b4:	e5900000 	ldr	r0, [r0]
    23b8:	e1a08001 	mov	r8, r1
    23bc:	e1cd20f0 	strd	r2, [sp]
    23c0:	e3a01001 	mov	r1, #1
    23c4:	e3a02000 	mov	r2, #0
    23c8:	eb00247f 	bl	b5cc <semaphore_acquire>

    nb_blocks = ((*p_count / block_size + 1) +
    23cc:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
    23d0:	e5910000 	ldr	r0, [r1]
    23d4:	e1a0100b 	mov	r1, fp
        ((offset + *p_count) / block_size > 0 &&
    23d8:	e0946000 	adds	r6, r4, r0
    23dc:	e0a57fc0 	adc	r7, r5, r0, asr #31
        DNA_BAD_ARGUMENT) ;
    block_size = block_device -> block_size ;

    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;

    nb_blocks = ((*p_count / block_size + 1) +
    23e0:	eb002dc0 	bl	dae8 <__aeabi_uidiv>
        ((offset + *p_count) / block_size > 0 &&
    23e4:	e1a0200b 	mov	r2, fp
    23e8:	e3a03000 	mov	r3, #0
        DNA_BAD_ARGUMENT) ;
    block_size = block_device -> block_size ;

    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;

    nb_blocks = ((*p_count / block_size + 1) +
    23ec:	e1a09000 	mov	r9, r0
        ((offset + *p_count) / block_size > 0 &&
    23f0:	e1a01007 	mov	r1, r7
    23f4:	e1a00006 	mov	r0, r6
    23f8:	eb002e52 	bl	dd48 <__aeabi_ldivmod>
        DNA_BAD_ARGUMENT) ;
    block_size = block_device -> block_size ;

    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;

    nb_blocks = ((*p_count / block_size + 1) +
    23fc:	e3500001 	cmp	r0, #1
    2400:	e2d12000 	sbcs	r2, r1, #0
    2404:	b3a03000 	movlt	r3, #0
    2408:	ba000008 	blt	2430 <block_device_read+0xd4>
        ((offset + *p_count) / block_size > 0 &&
         (offset + *p_count) % block_size > 0 ?
    240c:	e1a00006 	mov	r0, r6
    2410:	e1a01007 	mov	r1, r7
    2414:	e1a0200b 	mov	r2, fp
    2418:	e3a03000 	mov	r3, #0
    241c:	eb002e49 	bl	dd48 <__aeabi_ldivmod>
    block_size = block_device -> block_size ;

    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;

    nb_blocks = ((*p_count / block_size + 1) +
        ((offset + *p_count) / block_size > 0 &&
    2420:	e3520001 	cmp	r2, #1
    2424:	e2d31000 	sbcs	r1, r3, #0
    2428:	a3a03001 	movge	r3, #1
    242c:	b3a03000 	movlt	r3, #0
        DNA_BAD_ARGUMENT) ;
    block_size = block_device -> block_size ;

    semaphore_acquire (block_device -> semaphore_id, 1, 0, -1) ;

    nb_blocks = ((*p_count / block_size + 1) +
    2430:	e2899001 	add	r9, r9, #1
    2434:	e0899003 	add	r9, r9, r3
         (offset + *p_count) % block_size > 0 ?
         1 :
         0)) ;
    lba = offset / block_size ;

    read_buffer = kernel_malloc (nb_blocks * block_size, true) ;
    2438:	e006099b 	mul	r6, fp, r9
    243c:	e3a01001 	mov	r1, #1
    2440:	e1a00006 	mov	r0, r6
    2444:	eb002caa 	bl	d6f4 <kernel_malloc>
    read_buffer_base_address = read_buffer ;
    ensure (read_buffer != NULL, DNA_OUT_OF_MEM) ;
    2448:	e2507000 	subs	r7, r0, #0
    244c:	059f9164 	ldreq	r9, [pc, #356]	; 25b8 <block_device_read+0x25c>
    2450:	0affffd2 	beq	23a0 <block_device_read+0x44>
    nb_blocks = ((*p_count / block_size + 1) +
        ((offset + *p_count) / block_size > 0 &&
         (offset + *p_count) % block_size > 0 ?
         1 :
         0)) ;
    lba = offset / block_size ;
    2454:	e1a0200b 	mov	r2, fp
    2458:	e3a03000 	mov	r3, #0
    245c:	e1a00004 	mov	r0, r4
    2460:	e1a01005 	mov	r1, r5
    2464:	eb002e37 	bl	dd48 <__aeabi_ldivmod>

    read_buffer = kernel_malloc (nb_blocks * block_size, true) ;
    read_buffer_base_address = read_buffer ;
    ensure (read_buffer != NULL, DNA_OUT_OF_MEM) ;
    
    ensure (access_device_blocks(block_device, 
    2468:	e3a01000 	mov	r1, #0
    246c:	e1a02000 	mov	r2, r0
    2470:	e58d9000 	str	r9, [sp]
    2474:	e58d1004 	str	r1, [sp, #4]
    2478:	e3a03000 	mov	r3, #0
    247c:	e1a0000a 	mov	r0, sl
    2480:	e1a01007 	mov	r1, r7
    2484:	eb000084 	bl	269c <access_device_blocks>
    2488:	e2509000 	subs	r9, r0, #0
    248c:	159f9128 	ldrne	r9, [pc, #296]	; 25bc <block_device_read+0x260>
    2490:	1affffc2 	bne	23a0 <block_device_read+0x44>
                                 nb_blocks,
                                 READ) 
        == DNA_OK,
        DNA_ERROR) ;

    cpu_cache_invalidate (CPU_CACHE_DATA, read_buffer,
    2494:	e1a02006 	mov	r2, r6
    2498:	e3a00001 	mov	r0, #1
    249c:	e1a01007 	mov	r1, r7
    24a0:	eb001d6e 	bl	9a60 <cpu_cache_invalidate>

    // Trimming the blocks to fit the p_count size and the block offset
    remaining_bytes = *p_count ;

    // Remainder from first block
    local_offset = offset % block_size ;
    24a4:	e1a00004 	mov	r0, r4
    24a8:	e1a01005 	mov	r1, r5
    24ac:	e1a0200b 	mov	r2, fp
    24b0:	e1a03009 	mov	r3, r9
    24b4:	eb002e23 	bl	dd48 <__aeabi_ldivmod>

    cpu_cache_invalidate (CPU_CACHE_DATA, read_buffer,
        block_size * nb_blocks) ;

    // Trimming the blocks to fit the p_count size and the block offset
    remaining_bytes = *p_count ;
    24b8:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
    24bc:	e5913000 	ldr	r3, [r1]

    // Remainder from first block
    local_offset = offset % block_size ;
    local_p_count = remaining_bytes > (block_size - local_offset) ?
    24c0:	e062100b 	rsb	r1, r2, fp
      remaining_bytes - (block_size - local_offset) :
    24c4:	e1530001 	cmp	r3, r1
    24c8:	9a00002f 	bls	258c <block_device_read+0x230>
    24cc:	e06b5002 	rsb	r5, fp, r2
    24d0:	e0854003 	add	r4, r5, r3
      remaining_bytes ;
    read_buffer += local_offset ;
    24d4:	e0876002 	add	r6, r7, r2
    dna_memcpy (destination, read_buffer, local_p_count) ;
    24d8:	e1a01006 	mov	r1, r6
    24dc:	e1a02004 	mov	r2, r4
    24e0:	e1a00008 	mov	r0, r8
    24e4:	e2655000 	rsb	r5, r5, #0
    24e8:	eb001c85 	bl	9704 <dna_memcpy>
    remaining_bytes -= local_p_count ;
    destination += local_p_count ;
    read_buffer += local_p_count ;

    // Block transfers
    quot = remaining_bytes / block_size ;
    24ec:	e1a00005 	mov	r0, r5
    24f0:	e1a0100b 	mov	r1, fp
    24f4:	eb002d7b 	bl	dae8 <__aeabi_uidiv>
    read_buffer += local_offset ;
    dna_memcpy (destination, read_buffer, local_p_count) ;

    remaining_bytes -= local_p_count ;
    destination += local_p_count ;
    read_buffer += local_p_count ;
    24f8:	e0866004 	add	r6, r6, r4

    // Block transfers
    quot = remaining_bytes / block_size ;
    while (quot > 0)
    24fc:	e3500000 	cmp	r0, #0
      remaining_bytes ;
    read_buffer += local_offset ;
    dna_memcpy (destination, read_buffer, local_p_count) ;

    remaining_bytes -= local_p_count ;
    destination += local_p_count ;
    2500:	e0888004 	add	r8, r8, r4
    read_buffer += local_p_count ;

    // Block transfers
    quot = remaining_bytes / block_size ;
    while (quot > 0)
    2504:	e58d0014 	str	r0, [sp, #20]
    read_buffer += local_offset ;
    dna_memcpy (destination, read_buffer, local_p_count) ;

    remaining_bytes -= local_p_count ;
    destination += local_p_count ;
    read_buffer += local_p_count ;
    2508:	e58d6010 	str	r6, [sp, #16]
      remaining_bytes ;
    read_buffer += local_offset ;
    dna_memcpy (destination, read_buffer, local_p_count) ;

    remaining_bytes -= local_p_count ;
    destination += local_p_count ;
    250c:	e58d800c 	str	r8, [sp, #12]
    read_buffer += local_p_count ;

    // Block transfers
    quot = remaining_bytes / block_size ;
    while (quot > 0)
    2510:	0a000014 	beq	2568 <block_device_read+0x20c>
    2514:	e1a04008 	mov	r4, r8
    remaining_bytes -= local_p_count ;
    destination += local_p_count ;
    read_buffer += local_p_count ;

    // Block transfers
    quot = remaining_bytes / block_size ;
    2518:	e1a08000 	mov	r8, r0
    while (quot > 0)
    {
      dna_memcpy (destination, read_buffer, block_size) ;
    251c:	e1a00004 	mov	r0, r4
    2520:	e1a01006 	mov	r1, r6
    2524:	e1a0200b 	mov	r2, fp
    2528:	eb001c75 	bl	9704 <dna_memcpy>
    destination += local_p_count ;
    read_buffer += local_p_count ;

    // Block transfers
    quot = remaining_bytes / block_size ;
    while (quot > 0)
    252c:	e2588001 	subs	r8, r8, #1
    {
      dna_memcpy (destination, read_buffer, block_size) ;
      remaining_bytes -= block_size ;
      destination += block_size ;
    2530:	e084400b 	add	r4, r4, fp
      read_buffer += block_size ;
    2534:	e086600b 	add	r6, r6, fp
    destination += local_p_count ;
    read_buffer += local_p_count ;

    // Block transfers
    quot = remaining_bytes / block_size ;
    while (quot > 0)
    2538:	1afffff7 	bne	251c <block_device_read+0x1c0>
    253c:	e59d3014 	ldr	r3, [sp, #20]
    2540:	e06b5005 	rsb	r5, fp, r5
    2544:	e2632001 	rsb	r2, r3, #1
    2548:	e003039b 	mul	r3, fp, r3
    254c:	e59d100c 	ldr	r1, [sp, #12]
    2550:	e025529b 	mla	r5, fp, r2, r5
    2554:	e59d2010 	ldr	r2, [sp, #16]
    2558:	e0811003 	add	r1, r1, r3
    255c:	e0822003 	add	r2, r2, r3
    2560:	e58d100c 	str	r1, [sp, #12]
    2564:	e58d2010 	str	r2, [sp, #16]
      read_buffer += block_size ;
      quot-- ;
    }

    // Remainder from last block
    if (remaining_bytes > 0)
    2568:	e3550000 	cmp	r5, #0
    256c:	1a00000b 	bne	25a0 <block_device_read+0x244>
    {
      dna_memcpy (destination, read_buffer, remaining_bytes) ;
    }

    kernel_free (read_buffer_base_address) ;
    2570:	e1a00007 	mov	r0, r7
    2574:	eb002c93 	bl	d7c8 <kernel_free>
    semaphore_release (block_device -> semaphore_id, 1, DNA_NO_RESCHEDULE) ;
    2578:	e3a01001 	mov	r1, #1
    257c:	e59a0000 	ldr	r0, [sl]
    2580:	e1a02001 	mov	r2, r1
    2584:	eb0028d1 	bl	c8d0 <semaphore_release>
    return DNA_OK ;
    2588:	eaffff84 	b	23a0 <block_device_read+0x44>
    local_offset = offset % block_size ;
    local_p_count = remaining_bytes > (block_size - local_offset) ?
      remaining_bytes - (block_size - local_offset) :
      remaining_bytes ;
    read_buffer += local_offset ;
    dna_memcpy (destination, read_buffer, local_p_count) ;
    258c:	e0871002 	add	r1, r7, r2
    2590:	e1a00008 	mov	r0, r8
    2594:	e1a02003 	mov	r2, r3
    2598:	eb001c59 	bl	9704 <dna_memcpy>
    259c:	eafffff3 	b	2570 <block_device_read+0x214>
    }

    // Remainder from last block
    if (remaining_bytes > 0)
    {
      dna_memcpy (destination, read_buffer, remaining_bytes) ;
    25a0:	e59d000c 	ldr	r0, [sp, #12]
    25a4:	e59d1010 	ldr	r1, [sp, #16]
    25a8:	e1a02005 	mov	r2, r5
    25ac:	eb001c54 	bl	9704 <dna_memcpy>
    25b0:	eaffffee 	b	2570 <block_device_read+0x214>
    25b4:	0000fffc 	.word	0x0000fffc
    25b8:	0000fffd 	.word	0x0000fffd
    25bc:	0000ffff 	.word	0x0000ffff

000025c0 <block_device_find_device>:


device_cmd_t * block_device_find_device (const char * name)
{
  return & block_device_commands ;
}
    25c0:	e59f0000 	ldr	r0, [pc]	; 25c8 <block_device_find_device+0x8>
    25c4:	e12fff1e 	bx	lr
    25c8:	00024aa4 	.word	0x00024aa4

000025cc <block_device_publish_devices>:


const char ** block_device_publish_devices (void)
{
  return block_devices ;
}
    25cc:	e59f0000 	ldr	r0, [pc]	; 25d4 <block_device_publish_devices+0x8>
    25d0:	e12fff1e 	bx	lr
    25d4:	00024a9c 	.word	0x00024a9c

000025d8 <block_device_free>:


status_t block_device_free (void * data)
{
  return DNA_OK ;
}
    25d8:	e3a00000 	mov	r0, #0
    25dc:	e12fff1e 	bx	lr

000025e0 <block_device_close>:


status_t block_device_close (void * data)
{
  return DNA_OK ;
}
    25e0:	e3a00000 	mov	r0, #0
    25e4:	e12fff1e 	bx	lr

000025e8 <block_device_control>:
#include <Private/SoclibBlockDeviceDriver.h>
#include <DnaTools/DnaTools.h>

status_t block_device_control (void * handler, int32_t function,
    va_list arguments, int32_t * p_ret)
{
    25e8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  interrupt_status_t it_status;
  block_device_control_t * block_device = (block_device_control_t *)handler;

  watch (status_t)
  {
    ensure (block_device != NULL, DNA_ERROR);
    25ec:	e2507000 	subs	r7, r0, #0
    25f0:	0a000014 	beq	2648 <block_device_control+0x60>
    25f4:	e1a04001 	mov	r4, r1
    25f8:	e1a06002 	mov	r6, r2
    25fc:	e1a05003 	mov	r5, r3

    it_status = cpu_trap_mask_and_backup ();
    2600:	eb001d3e 	bl	9b00 <cpu_trap_mask_and_backup>

    switch (function)
    2604:	e3540000 	cmp	r4, #0

  watch (status_t)
  {
    ensure (block_device != NULL, DNA_ERROR);

    it_status = cpu_trap_mask_and_backup ();
    2608:	e1a08000 	mov	r8, r0

    switch (function)
    260c:	0a000015 	beq	2668 <block_device_control+0x80>
    2610:	e3540006 	cmp	r4, #6
    2614:	1a00000d 	bne	2650 <block_device_control+0x68>
          break;
        }

      case DNA_GET_INFO:
        {
          device_info_t * info = va_arg (arguments, device_info_t *);
    2618:	e5964000 	ldr	r4, [r6]
          ensure (info != NULL, DNA_ERROR);
    261c:	e3540000 	cmp	r4, #0
    2620:	0a000008 	beq	2648 <block_device_control+0x60>

          dna_memset (info, 0, sizeof (device_info_t));
    2624:	e3a02010 	mov	r2, #16
    2628:	e1a00004 	mov	r0, r4
    262c:	e3a01000 	mov	r1, #0
    2630:	eb00192b 	bl	8ae4 <dna_memset>
          info->type = DNA_DISK_DEVICE;
    2634:	e3a02001 	mov	r2, #1

          *p_ret = 0;
    2638:	e3a03000 	mov	r3, #0
        {
          device_info_t * info = va_arg (arguments, device_info_t *);
          ensure (info != NULL, DNA_ERROR);

          dna_memset (info, 0, sizeof (device_info_t));
          info->type = DNA_DISK_DEVICE;
    263c:	e5842000 	str	r2, [r4]

          *p_ret = 0;
    2640:	e5853000 	str	r3, [r5]
          break;
    2644:	ea000003 	b	2658 <block_device_control+0x70>
  interrupt_status_t it_status;
  block_device_control_t * block_device = (block_device_control_t *)handler;

  watch (status_t)
  {
    ensure (block_device != NULL, DNA_ERROR);
    2648:	e59f0040 	ldr	r0, [pc, #64]	; 2690 <block_device_control+0xa8>
    264c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        }

      default:
        {
          dna_log(INFO_LEVEL, "Unsupported control code 0x%x.", function);
          *p_ret = -1;
    2650:	e3e03000 	mvn	r3, #0
    2654:	e5853000 	str	r3, [r5]
          break;
        }
    }

    cpu_trap_restore (it_status);
    2658:	e1a00008 	mov	r0, r8
    265c:	eb001d60 	bl	9be4 <cpu_trap_restore>
    return DNA_OK;
    2660:	e3a00000 	mov	r0, #0
  }
}
    2664:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

    switch (function)
    {
      case DNA_GET_DEVICE_SIZE:
        {
          int64_t * p_size = va_arg(arguments, int64_t *);
    2668:	e5961000 	ldr	r1, [r6]
//          p_size = (int64_t *)arguments;
          ensure (p_size != NULL, DNA_ERROR);
    266c:	e3510000 	cmp	r1, #0
    2670:	0afffff4 	beq	2648 <block_device_control+0x60>

          *p_size = block_device->block_count * block_device->block_size;
    2674:	e5973010 	ldr	r3, [r7, #16]
    2678:	e5972014 	ldr	r2, [r7, #20]
    267c:	e0020392 	mul	r2, r2, r3
    2680:	e1a03fc2 	asr	r3, r2, #31
    2684:	e1c120f0 	strd	r2, [r1]

          *p_ret = 0;
    2688:	e5854000 	str	r4, [r5]
          break;
    268c:	eafffff1 	b	2658 <block_device_control+0x70>
    2690:	0000ffff 	.word	0x0000ffff

00002694 <block_device_init_hardware>:
#include <DnaTools/DnaTools.h>

status_t block_device_init_hardware (void)
{
  return DNA_OK ;
}
    2694:	e3a00000 	mov	r0, #0
    2698:	e12fff1e 	bx	lr

0000269c <access_device_blocks>:
#include <DnaTools/DnaTools.h>

status_t access_device_blocks(block_device_control_t * block_device, 
    void * access, int64_t block_offset, int32_t block_count,
    block_device_access_t read_or_write) 
{
    269c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    26a0:	e1a04000 	mov	r4, r0
    26a4:	e1a06001 	mov	r6, r1
    26a8:	e1a08002 	mov	r8, r2
    26ac:	e24dd008 	sub	sp, sp, #8
    26b0:	e59d5020 	ldr	r5, [sp, #32]
    26b4:	e5dd7024 	ldrb	r7, [sp, #36]	; 0x24
  uint32_t operation_status ;
  interrupt_status_t it_status ;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup() ;
    26b8:	eb001d10 	bl	9b00 <cpu_trap_mask_and_backup>

    cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_LBA),
        block_offset) ;
    dna_log(VERBOSE_LEVEL, "Wrote block offset (LBA): %d", block_offset) ;

    if (block_device -> should_enable_irq)
    26bc:	e5d4c008 	ldrb	ip, [r4, #8]
  interrupt_status_t it_status ;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup() ;
    cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_BUFFER),
    26c0:	e5943018 	ldr	r3, [r4, #24]

    cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_LBA),
        block_offset) ;
    dna_log(VERBOSE_LEVEL, "Wrote block offset (LBA): %d", block_offset) ;

    if (block_device -> should_enable_irq)
    26c4:	e35c0000 	cmp	ip, #0
  interrupt_status_t it_status ;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup() ;
    cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_BUFFER),
    26c8:	e5836000 	str	r6, [r3]
        access) ;
    dna_log(VERBOSE_LEVEL, "Wrote destination buffer address: 0x%x", 
        access) ;
    
    cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_COUNT),
    26cc:	e5835008 	str	r5, [r3, #8]
        block_count) ;
    dna_log(VERBOSE_LEVEL, "Wrote block count: %d", block_count) ;

    cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_LBA),
    26d0:	e5838004 	str	r8, [r3, #4]
        block_offset) ;
    dna_log(VERBOSE_LEVEL, "Wrote block offset (LBA): %d", block_offset) ;

    if (block_device -> should_enable_irq)
    26d4:	0a000010 	beq	271c <access_device_blocks+0x80>
    {
      cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_IRQ_ENABLE),
          (uint32_t) true) ;
      cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_OP), 
    26d8:	e3570000 	cmp	r7, #0
    26dc:	03a07001 	moveq	r7, #1
    26e0:	13a07002 	movne	r7, #2
        block_offset) ;
    dna_log(VERBOSE_LEVEL, "Wrote block offset (LBA): %d", block_offset) ;

    if (block_device -> should_enable_irq)
    {
      cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_IRQ_ENABLE),
    26e4:	e3a05001 	mov	r5, #1
    26e8:	e5835014 	str	r5, [r3, #20]
          (uint32_t) true) ;
      cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_OP), 
    26ec:	e583700c 	str	r7, [r3, #12]
          read_or_write == READ ? BLOCK_DEVICE_READ : BLOCK_DEVICE_WRITE) ;


      cpu_trap_restore (it_status) ;
    26f0:	eb001d3b 	bl	9be4 <cpu_trap_restore>
      semaphore_acquire (block_device -> isr_semaphore_id, 1, 0, -1) ;
    26f4:	e3e03000 	mvn	r3, #0
    26f8:	e3e02000 	mvn	r2, #0
    26fc:	e5940004 	ldr	r0, [r4, #4]
    2700:	e1a01005 	mov	r1, r5
    2704:	e1cd20f0 	strd	r2, [sp]
    2708:	e3a02000 	mov	r2, #0
    270c:	eb0023ae 	bl	b5cc <semaphore_acquire>

      cpu_trap_restore (it_status) ;
      ensure (operation_status == BLOCK_DEVICE_READ_SUCCESS ||
          operation_status == BLOCK_DEVICE_WRITE_SUCCESS, DNA_ERROR) ;
    }
    return DNA_OK ;
    2710:	e3a00000 	mov	r0, #0
  }
}
    2714:	e28dd008 	add	sp, sp, #8
    2718:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    }
    else
    {
      cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_IRQ_ENABLE),
          (uint32_t) false) ;
      cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_OP), 
    271c:	e3570000 	cmp	r7, #0
    2720:	03a07001 	moveq	r7, #1
    2724:	13a07002 	movne	r7, #2
    2728:	e1a02000 	mov	r2, r0
      cpu_trap_restore (it_status) ;
      semaphore_acquire (block_device -> isr_semaphore_id, 1, 0, -1) ;
    }
    else
    {
      cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_IRQ_ENABLE),
    272c:	e583c014 	str	ip, [r3, #20]
          (uint32_t) false) ;
      cpu_write (UINT32, & (block_device -> port -> BLOCK_DEVICE_OP), 
    2730:	e583700c 	str	r7, [r3, #12]
          read_or_write == READ ? BLOCK_DEVICE_READ : BLOCK_DEVICE_WRITE) ;

      do {
        cpu_read (UINT32, & (block_device -> port -> BLOCK_DEVICE_STATUS), 
    2734:	e5934010 	ldr	r4, [r3, #16]
            operation_status) ;
        dna_log(VERBOSE_LEVEL, "Op status is %d.", operation_status) ;
      } while (operation_status == BLOCK_DEVICE_BUSY) ;
    2738:	e3540001 	cmp	r4, #1
    273c:	0afffffc 	beq	2734 <access_device_blocks+0x98>

      cpu_trap_restore (it_status) ;
    2740:	e1a00002 	mov	r0, r2
    2744:	eb001d26 	bl	9be4 <cpu_trap_restore>
      ensure (operation_status == BLOCK_DEVICE_READ_SUCCESS ||
    2748:	e2440002 	sub	r0, r4, #2
    274c:	e3500001 	cmp	r0, #1
    2750:	93a00000 	movls	r0, #0
    2754:	83e00000 	mvnhi	r0, #0
    2758:	e6ff0070 	uxth	r0, r0
          operation_status == BLOCK_DEVICE_WRITE_SUCCESS, DNA_ERROR) ;
    }
    return DNA_OK ;
  }
}
    275c:	e28dd008 	add	sp, sp, #8
    2760:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

00002764 <block_device_uninit_driver>:
#include <Core/Core.h>
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

void block_device_uninit_driver (void)
{
    2764:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
  int32_t idx ;
  block_device_control_t block_device ;
  
  for (idx = 0 ; idx < SOCLIB_BLOCK_DEVICES_NDEV ; idx++)
    2768:	e59f6074 	ldr	r6, [pc, #116]	; 27e4 <block_device_uninit_driver+0x80>
    276c:	e596c000 	ldr	ip, [r6]
    2770:	e35c0000 	cmp	ip, #0
    2774:	da000017 	ble	27d8 <block_device_uninit_driver+0x74>
    2778:	e3a04000 	mov	r4, #0
    277c:	e59f7064 	ldr	r7, [pc, #100]	; 27e8 <block_device_uninit_driver+0x84>
    2780:	e1a05004 	mov	r5, r4
    2784:	e5970000 	ldr	r0, [r7]
    2788:	ea000002 	b	2798 <block_device_uninit_driver+0x34>
    278c:	e155000c 	cmp	r5, ip
    2790:	e284401c 	add	r4, r4, #28
    2794:	aa00000d 	bge	27d0 <block_device_uninit_driver+0x6c>
  {
    block_device = block_device_controls[idx] ;
    2798:	e0803004 	add	r3, r0, r4
    if (block_device . should_enable_irq) {
    279c:	e5d32008 	ldrb	r2, [r3, #8]
void block_device_uninit_driver (void)
{
  int32_t idx ;
  block_device_control_t block_device ;
  
  for (idx = 0 ; idx < SOCLIB_BLOCK_DEVICES_NDEV ; idx++)
    27a0:	e2855001 	add	r5, r5, #1
  {
    block_device = block_device_controls[idx] ;
    if (block_device . should_enable_irq) {
    27a4:	e3520000 	cmp	r2, #0
  int32_t idx ;
  block_device_control_t block_device ;
  
  for (idx = 0 ; idx < SOCLIB_BLOCK_DEVICES_NDEV ; idx++)
  {
    block_device = block_device_controls[idx] ;
    27a8:	e593100c 	ldr	r1, [r3, #12]
    if (block_device . should_enable_irq) {
    27ac:	0afffff6 	beq	278c <block_device_uninit_driver+0x28>
      interrupt_detach (0, block_device . irq, block_device_isr) ;
    27b0:	e3a00000 	mov	r0, #0
    27b4:	e59f2030 	ldr	r2, [pc, #48]	; 27ec <block_device_uninit_driver+0x88>
    27b8:	eb002969 	bl	cd64 <interrupt_detach>
    27bc:	e596c000 	ldr	ip, [r6]
    27c0:	e5970000 	ldr	r0, [r7]
void block_device_uninit_driver (void)
{
  int32_t idx ;
  block_device_control_t block_device ;
  
  for (idx = 0 ; idx < SOCLIB_BLOCK_DEVICES_NDEV ; idx++)
    27c4:	e155000c 	cmp	r5, ip
    27c8:	e284401c 	add	r4, r4, #28
    27cc:	bafffff1 	blt	2798 <block_device_uninit_driver+0x34>
    }
  }

  kernel_free (block_device_controls) ;

}
    27d0:	e8bd40f8 	pop	{r3, r4, r5, r6, r7, lr}
    if (block_device . should_enable_irq) {
      interrupt_detach (0, block_device . irq, block_device_isr) ;
    }
  }

  kernel_free (block_device_controls) ;
    27d4:	ea002bfb 	b	d7c8 <kernel_free>
    27d8:	e59f3008 	ldr	r3, [pc, #8]	; 27e8 <block_device_uninit_driver+0x84>
    27dc:	e5930000 	ldr	r0, [r3]
    27e0:	eafffffa 	b	27d0 <block_device_uninit_driver+0x6c>
    27e4:	0002552c 	.word	0x0002552c
    27e8:	000355d0 	.word	0x000355d0
    27ec:	00002100 	.word	0x00002100

000027f0 <rdv_uninit_driver>:

#include <Private/Driver.h>
#include <MemoryManager/MemoryManager.h>

void rdv_uninit_driver (void)
{
    27f0:	e92d4070 	push	{r4, r5, r6, lr}
  for (int32_t i = 0; i < CHANNEL_RDV_NDEV; i++)
    27f4:	e59f503c 	ldr	r5, [pc, #60]	; 2838 <rdv_uninit_driver+0x48>
    27f8:	e5953000 	ldr	r3, [r5]
    27fc:	e3530000 	cmp	r3, #0
    2800:	d59f6034 	ldrle	r6, [pc, #52]	; 283c <rdv_uninit_driver+0x4c>
    2804:	da000008 	ble	282c <rdv_uninit_driver+0x3c>
    2808:	e3a04000 	mov	r4, #0
    280c:	e59f6028 	ldr	r6, [pc, #40]	; 283c <rdv_uninit_driver+0x4c>
  {
    kernel_free ((void *)rdv_devices[i]);
    2810:	e5963000 	ldr	r3, [r6]
    2814:	e7930104 	ldr	r0, [r3, r4, lsl #2]
    2818:	eb002bea 	bl	d7c8 <kernel_free>
#include <Private/Driver.h>
#include <MemoryManager/MemoryManager.h>

void rdv_uninit_driver (void)
{
  for (int32_t i = 0; i < CHANNEL_RDV_NDEV; i++)
    281c:	e5953000 	ldr	r3, [r5]
    2820:	e2844001 	add	r4, r4, #1
    2824:	e1530004 	cmp	r3, r4
    2828:	cafffff8 	bgt	2810 <rdv_uninit_driver+0x20>
  {
    kernel_free ((void *)rdv_devices[i]);
  }

  kernel_free (rdv_devices);
    282c:	e5960000 	ldr	r0, [r6]
}
    2830:	e8bd4070 	pop	{r4, r5, r6, lr}
  for (int32_t i = 0; i < CHANNEL_RDV_NDEV; i++)
  {
    kernel_free ((void *)rdv_devices[i]);
  }

  kernel_free (rdv_devices);
    2834:	ea002be3 	b	d7c8 <kernel_free>
    2838:	0002554c 	.word	0x0002554c
    283c:	000355d4 	.word	0x000355d4

00002840 <rdv_read>:
#include <Processor/Processor.h>
#include <DnaTools/DnaTools.h>

status_t rdv_read (void * handler, void * destination,
    int64_t offset, int32_t * p_count)
{
    2840:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    2844:	e24dd00c 	sub	sp, sp, #12
    2848:	e1a06000 	mov	r6, r0
  channel_rdv_t * rdv = handler;
  interrupt_status_t it_status = 0;

  it_status = cpu_trap_mask_and_backup();
  lock_acquire (& rdv -> lock);
    284c:	e2804004 	add	r4, r0, #4
#include <Processor/Processor.h>
#include <DnaTools/DnaTools.h>

status_t rdv_read (void * handler, void * destination,
    int64_t offset, int32_t * p_count)
{
    2850:	e1a05001 	mov	r5, r1
  channel_rdv_t * rdv = handler;
  interrupt_status_t it_status = 0;

  it_status = cpu_trap_mask_and_backup();
    2854:	eb001ca9 	bl	9b00 <cpu_trap_mask_and_backup>
    2858:	e1a07000 	mov	r7, r0
  lock_acquire (& rdv -> lock);
    285c:	e1a00004 	mov	r0, r4
    2860:	eb001df2 	bl	a030 <lock_acquire>
    
  if (! rdv -> setter . ready)
    2864:	e5d6200c 	ldrb	r2, [r6, #12]
    2868:	e21280ff 	ands	r8, r2, #255	; 0xff
    286c:	0a000012 	beq	28bc <rdv_read+0x7c>
    lock_release (& rdv -> lock);
    semaphore_acquire (rdv -> sem, 1, 0, -1);
  }
  else
  {
    rdv -> setter . ready = false;
    2870:	e3a03000 	mov	r3, #0
    2874:	e5c6300c 	strb	r3, [r6, #12]
    rdv -> getter . ready = false;
    2878:	e5c63014 	strb	r3, [r6, #20]
    dna_memcpy ((void *)destination, (void *)rdv -> setter . buffer, *p_count);
    287c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
    2880:	e5961008 	ldr	r1, [r6, #8]
    2884:	e5932000 	ldr	r2, [r3]
    2888:	e1a00005 	mov	r0, r5
    288c:	eb001b9c 	bl	9704 <dna_memcpy>

    lock_release (& rdv -> lock);
    2890:	e1a00004 	mov	r0, r4
    2894:	eb002896 	bl	caf4 <lock_release>
    semaphore_release (rdv -> sem, 1, DNA_NO_RESCHEDULE);
    2898:	e3a01001 	mov	r1, #1
    289c:	e5960000 	ldr	r0, [r6]
    28a0:	e1a02001 	mov	r2, r1
    28a4:	eb002809 	bl	c8d0 <semaphore_release>
  }

  cpu_trap_restore(it_status);
    28a8:	e1a00007 	mov	r0, r7
    28ac:	eb001ccc 	bl	9be4 <cpu_trap_restore>
  return DNA_OK;
}
    28b0:	e3a00000 	mov	r0, #0
    28b4:	e28dd00c 	add	sp, sp, #12
    28b8:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  it_status = cpu_trap_mask_and_backup();
  lock_acquire (& rdv -> lock);
    
  if (! rdv -> setter . ready)
  {
    rdv -> getter . ready = true;
    28bc:	e3a09001 	mov	r9, #1
    rdv -> getter . buffer = destination;
    28c0:	e5865010 	str	r5, [r6, #16]

    lock_release (& rdv -> lock);
    28c4:	e1a00004 	mov	r0, r4
    semaphore_acquire (rdv -> sem, 1, 0, -1);
    28c8:	e3e05000 	mvn	r5, #0
    28cc:	e3e04000 	mvn	r4, #0
  it_status = cpu_trap_mask_and_backup();
  lock_acquire (& rdv -> lock);
    
  if (! rdv -> setter . ready)
  {
    rdv -> getter . ready = true;
    28d0:	e5c69014 	strb	r9, [r6, #20]
    rdv -> getter . buffer = destination;

    lock_release (& rdv -> lock);
    28d4:	eb002886 	bl	caf4 <lock_release>
    semaphore_acquire (rdv -> sem, 1, 0, -1);
    28d8:	e5960000 	ldr	r0, [r6]
    28dc:	e1a01009 	mov	r1, r9
    28e0:	e1a02008 	mov	r2, r8
    28e4:	e1cd40f0 	strd	r4, [sp]
    28e8:	eb002337 	bl	b5cc <semaphore_acquire>
    28ec:	eaffffed 	b	28a8 <rdv_read+0x68>

000028f0 <rdv_close>:
#include <DnaTools/DnaTools.h>

status_t rdv_close (void * data)
{
  return DNA_NOT_IMPLEMENTED;
}
    28f0:	e59f0000 	ldr	r0, [pc]	; 28f8 <rdv_close+0x8>
    28f4:	e12fff1e 	bx	lr
    28f8:	0000fffe 	.word	0x0000fffe

000028fc <rdv_write>:
#include <Processor/Processor.h>
#include <DnaTools/DnaTools.h>

status_t rdv_write (void * handler, void * source,
    int64_t offset, int32_t * p_count)
{
    28fc:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    2900:	e24dd00c 	sub	sp, sp, #12
    2904:	e1a06000 	mov	r6, r0
  channel_rdv_t * rdv = handler;
  interrupt_status_t it_status = 0;

  it_status = cpu_trap_mask_and_backup();
  lock_acquire (& rdv -> lock);
    2908:	e2804004 	add	r4, r0, #4
#include <Processor/Processor.h>
#include <DnaTools/DnaTools.h>

status_t rdv_write (void * handler, void * source,
    int64_t offset, int32_t * p_count)
{
    290c:	e1a05001 	mov	r5, r1
  channel_rdv_t * rdv = handler;
  interrupt_status_t it_status = 0;

  it_status = cpu_trap_mask_and_backup();
    2910:	eb001c7a 	bl	9b00 <cpu_trap_mask_and_backup>
    2914:	e1a07000 	mov	r7, r0
  lock_acquire (& rdv -> lock);
    2918:	e1a00004 	mov	r0, r4
    291c:	eb001dc3 	bl	a030 <lock_acquire>

  if (! rdv -> getter . ready)
    2920:	e5d62014 	ldrb	r2, [r6, #20]
    2924:	e21280ff 	ands	r8, r2, #255	; 0xff
    2928:	0a000012 	beq	2978 <rdv_write+0x7c>
    lock_release (& rdv -> lock);
    semaphore_acquire (rdv -> sem, 1, 0, -1);
  }
  else
  {
    rdv -> getter . ready = false;
    292c:	e3a03000 	mov	r3, #0
    2930:	e5c63014 	strb	r3, [r6, #20]
    rdv -> setter . ready = false;
    2934:	e5c6300c 	strb	r3, [r6, #12]
    dna_memcpy ((void *)rdv -> getter . buffer, (void *)source, *p_count);
    2938:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
    293c:	e1a01005 	mov	r1, r5
    2940:	e5932000 	ldr	r2, [r3]
    2944:	e5960010 	ldr	r0, [r6, #16]
    2948:	eb001b6d 	bl	9704 <dna_memcpy>

    lock_release (& rdv -> lock);
    294c:	e1a00004 	mov	r0, r4
    2950:	eb002867 	bl	caf4 <lock_release>
    semaphore_release (rdv -> sem, 1, DNA_NO_RESCHEDULE);
    2954:	e3a01001 	mov	r1, #1
    2958:	e5960000 	ldr	r0, [r6]
    295c:	e1a02001 	mov	r2, r1
    2960:	eb0027da 	bl	c8d0 <semaphore_release>
  }

  cpu_trap_restore(it_status);
    2964:	e1a00007 	mov	r0, r7
    2968:	eb001c9d 	bl	9be4 <cpu_trap_restore>
  return DNA_OK;
}
    296c:	e3a00000 	mov	r0, #0
    2970:	e28dd00c 	add	sp, sp, #12
    2974:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  it_status = cpu_trap_mask_and_backup();
  lock_acquire (& rdv -> lock);

  if (! rdv -> getter . ready)
  {
    rdv -> setter . ready = true;
    2978:	e3a09001 	mov	r9, #1
    rdv -> setter . buffer = source;
    297c:	e5865008 	str	r5, [r6, #8]

    lock_release (& rdv -> lock);
    2980:	e1a00004 	mov	r0, r4
    semaphore_acquire (rdv -> sem, 1, 0, -1);
    2984:	e3e05000 	mvn	r5, #0
    2988:	e3e04000 	mvn	r4, #0
  it_status = cpu_trap_mask_and_backup();
  lock_acquire (& rdv -> lock);

  if (! rdv -> getter . ready)
  {
    rdv -> setter . ready = true;
    298c:	e5c6900c 	strb	r9, [r6, #12]
    rdv -> setter . buffer = source;

    lock_release (& rdv -> lock);
    2990:	eb002857 	bl	caf4 <lock_release>
    semaphore_acquire (rdv -> sem, 1, 0, -1);
    2994:	e5960000 	ldr	r0, [r6]
    2998:	e1a01009 	mov	r1, r9
    299c:	e1a02008 	mov	r2, r8
    29a0:	e1cd40f0 	strd	r4, [sp]
    29a4:	eb002308 	bl	b5cc <semaphore_acquire>
    29a8:	eaffffed 	b	2964 <rdv_write+0x68>

000029ac <rdv_find_device>:
};

device_cmd_t * rdv_find_device (const char * name)
{
  return & rdv_commands;
}
    29ac:	e59f0000 	ldr	r0, [pc]	; 29b4 <rdv_find_device+0x8>
    29b0:	e12fff1e 	bx	lr
    29b4:	00024aec 	.word	0x00024aec

000029b8 <rdv_publish_devices>:

#include <Private/Driver.h>

const char ** rdv_publish_devices (void)
{
  return rdv_devices;
    29b8:	e59f3004 	ldr	r3, [pc, #4]	; 29c4 <rdv_publish_devices+0xc>
}
    29bc:	e5930000 	ldr	r0, [r3]
    29c0:	e12fff1e 	bx	lr
    29c4:	000355d4 	.word	0x000355d4

000029c8 <rdv_init_driver>:
  int32_t i = 0;
  status_t status;

  watch (status_t)
  {
    rdv_devices = kernel_malloc (sizeof (const char *)
    29c8:	e3a01001 	mov	r1, #1
#include <Private/Driver.h>
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rdv_init_driver (void)
{
    29cc:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  status_t status;

  watch (status_t)
  {
    rdv_devices = kernel_malloc (sizeof (const char *)
        * (CHANNEL_RDV_NDEV + 1), true);
    29d0:	e59f7144 	ldr	r7, [pc, #324]	; 2b1c <rdv_init_driver+0x154>
#include <Private/Driver.h>
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rdv_init_driver (void)
{
    29d4:	e24dd044 	sub	sp, sp, #68	; 0x44
  status_t status;

  watch (status_t)
  {
    rdv_devices = kernel_malloc (sizeof (const char *)
        * (CHANNEL_RDV_NDEV + 1), true);
    29d8:	e5970000 	ldr	r0, [r7]
  int32_t i = 0;
  status_t status;

  watch (status_t)
  {
    rdv_devices = kernel_malloc (sizeof (const char *)
    29dc:	e59f813c 	ldr	r8, [pc, #316]	; 2b20 <rdv_init_driver+0x158>
        * (CHANNEL_RDV_NDEV + 1), true);
    29e0:	e0800001 	add	r0, r0, r1
  int32_t i = 0;
  status_t status;

  watch (status_t)
  {
    rdv_devices = kernel_malloc (sizeof (const char *)
    29e4:	e1a00100 	lsl	r0, r0, #2
    29e8:	eb002b41 	bl	d6f4 <kernel_malloc>
        * (CHANNEL_RDV_NDEV + 1), true);
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);
    29ec:	e3500000 	cmp	r0, #0
  int32_t i = 0;
  status_t status;

  watch (status_t)
  {
    rdv_devices = kernel_malloc (sizeof (const char *)
    29f0:	e5880000 	str	r0, [r8]
        * (CHANNEL_RDV_NDEV + 1), true);
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);
    29f4:	0a00003b 	beq	2ae8 <rdv_init_driver+0x120>

    rdv = kernel_malloc (sizeof (channel_rdv_t) * (CHANNEL_RDV_NDEV), true);
    29f8:	e5973000 	ldr	r3, [r7]
    29fc:	e3a01001 	mov	r1, #1
    2a00:	e0830083 	add	r0, r3, r3, lsl #1
    2a04:	e1a00180 	lsl	r0, r0, #3
    2a08:	eb002b39 	bl	d6f4 <kernel_malloc>
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);
    2a0c:	e5983000 	ldr	r3, [r8]
  {
    rdv_devices = kernel_malloc (sizeof (const char *)
        * (CHANNEL_RDV_NDEV + 1), true);
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);

    rdv = kernel_malloc (sizeof (channel_rdv_t) * (CHANNEL_RDV_NDEV), true);
    2a10:	e59f910c 	ldr	r9, [pc, #268]	; 2b24 <rdv_init_driver+0x15c>
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);
    2a14:	e3530000 	cmp	r3, #0
  {
    rdv_devices = kernel_malloc (sizeof (const char *)
        * (CHANNEL_RDV_NDEV + 1), true);
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);

    rdv = kernel_malloc (sizeof (channel_rdv_t) * (CHANNEL_RDV_NDEV), true);
    2a18:	e5890000 	str	r0, [r9]
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);
    2a1c:	0a000031 	beq	2ae8 <rdv_init_driver+0x120>

    for (i = 0; i < CHANNEL_RDV_NDEV; i++)
    2a20:	e5972000 	ldr	r2, [r7]
    2a24:	e3520000 	cmp	r2, #0
    2a28:	da000039 	ble	2b14 <rdv_init_driver+0x14c>
    2a2c:	e3a06000 	mov	r6, #0
    2a30:	e1a04006 	mov	r4, r6
    2a34:	ea000017 	b	2a98 <rdv_init_driver+0xd0>
       */

      buffer = kernel_malloc (DNA_FILENAME_LENGTH, false);
      check (invalid_buffer, buffer != NULL, DNA_OUT_OF_MEM);
      
      dna_itoa (i, ascii);
    2a38:	e1a00004 	mov	r0, r4
    2a3c:	e1a0100d 	mov	r1, sp
    2a40:	eb001b99 	bl	98ac <dna_itoa>
      dna_strcpy (buffer, base);
    2a44:	e59f10dc 	ldr	r1, [pc, #220]	; 2b28 <rdv_init_driver+0x160>
    2a48:	e1a00005 	mov	r0, r5
    2a4c:	eb001b25 	bl	96e8 <dna_strcpy>
      dna_strcat (buffer, ascii);
    2a50:	e1a0100d 	mov	r1, sp
    2a54:	e1a00005 	mov	r0, r5
    2a58:	eb001aa3 	bl	94ec <dna_strcat>
      rdv_devices[i] = buffer;
    2a5c:	e5983000 	ldr	r3, [r8]

      /*
       * Create the channel semaphore
       */

      status = semaphore_create (buffer, 0, & rdv[i] . sem);
    2a60:	e1a00005 	mov	r0, r5
      check (invalid_buffer, buffer != NULL, DNA_OUT_OF_MEM);
      
      dna_itoa (i, ascii);
      dna_strcpy (buffer, base);
      dna_strcat (buffer, ascii);
      rdv_devices[i] = buffer;
    2a64:	e7835104 	str	r5, [r3, r4, lsl #2]

      /*
       * Create the channel semaphore
       */

      status = semaphore_create (buffer, 0, & rdv[i] . sem);
    2a68:	e5992000 	ldr	r2, [r9]
    2a6c:	e3a01000 	mov	r1, #0
    2a70:	e0822006 	add	r2, r2, r6
    2a74:	eb0026f2 	bl	c644 <semaphore_create>
      ensure (status == DNA_OK, status);
    2a78:	e3500000 	cmp	r0, #0
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);

    rdv = kernel_malloc (sizeof (channel_rdv_t) * (CHANNEL_RDV_NDEV), true);
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);

    for (i = 0; i < CHANNEL_RDV_NDEV; i++)
    2a7c:	e2844001 	add	r4, r4, #1
      check (invalid_buffer, buffer != NULL, DNA_OUT_OF_MEM);
      
      dna_itoa (i, ascii);
      dna_strcpy (buffer, base);
      dna_strcat (buffer, ascii);
      rdv_devices[i] = buffer;
    2a80:	e59f2098 	ldr	r2, [pc, #152]	; 2b20 <rdv_init_driver+0x158>
      /*
       * Create the channel semaphore
       */

      status = semaphore_create (buffer, 0, & rdv[i] . sem);
      ensure (status == DNA_OK, status);
    2a84:	1a000018 	bne	2aec <rdv_init_driver+0x124>
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);

    rdv = kernel_malloc (sizeof (channel_rdv_t) * (CHANNEL_RDV_NDEV), true);
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);

    for (i = 0; i < CHANNEL_RDV_NDEV; i++)
    2a88:	e5973000 	ldr	r3, [r7]
    2a8c:	e2866018 	add	r6, r6, #24
    2a90:	e1530004 	cmp	r3, r4
    2a94:	da000016 	ble	2af4 <rdv_init_driver+0x12c>
    {
      /*
       * Create the channel name
       */

      buffer = kernel_malloc (DNA_FILENAME_LENGTH, false);
    2a98:	e3a00c01 	mov	r0, #256	; 0x100
    2a9c:	e3a01000 	mov	r1, #0
    2aa0:	eb002b13 	bl	d6f4 <kernel_malloc>
      check (invalid_buffer, buffer != NULL, DNA_OUT_OF_MEM);
    2aa4:	e2505000 	subs	r5, r0, #0
    2aa8:	1affffe2 	bne	2a38 <rdv_init_driver+0x70>
    return DNA_OK;
  }

  rescue (invalid_buffer)
  {
    for (i = 0; i < CHANNEL_RDV_NDEV; i++)
    2aac:	e5973000 	ldr	r3, [r7]
    2ab0:	e3530000 	cmp	r3, #0
    2ab4:	c5982000 	ldrgt	r2, [r8]
    2ab8:	da000013 	ble	2b0c <rdv_init_driver+0x144>
    {
      if (rdv_devices[i] != NULL) kernel_free ((void *)rdv_devices[i]);
    2abc:	e7920105 	ldr	r0, [r2, r5, lsl #2]
    return DNA_OK;
  }

  rescue (invalid_buffer)
  {
    for (i = 0; i < CHANNEL_RDV_NDEV; i++)
    2ac0:	e2855001 	add	r5, r5, #1
    {
      if (rdv_devices[i] != NULL) kernel_free ((void *)rdv_devices[i]);
    2ac4:	e3500000 	cmp	r0, #0
    2ac8:	0a000002 	beq	2ad8 <rdv_init_driver+0x110>
    2acc:	eb002b3d 	bl	d7c8 <kernel_free>
    2ad0:	e5982000 	ldr	r2, [r8]
    2ad4:	e5973000 	ldr	r3, [r7]
    return DNA_OK;
  }

  rescue (invalid_buffer)
  {
    for (i = 0; i < CHANNEL_RDV_NDEV; i++)
    2ad8:	e1550003 	cmp	r5, r3
    2adc:	bafffff6 	blt	2abc <rdv_init_driver+0xf4>
    {
      if (rdv_devices[i] != NULL) kernel_free ((void *)rdv_devices[i]);
    }

    kernel_free (rdv_devices);
    2ae0:	e1a00002 	mov	r0, r2
    2ae4:	eb002b37 	bl	d7c8 <kernel_free>
    leave;
    2ae8:	e59f003c 	ldr	r0, [pc, #60]	; 2b2c <rdv_init_driver+0x164>
  }
}
    2aec:	e28dd044 	add	sp, sp, #68	; 0x44
    2af0:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
    2af4:	e5923000 	ldr	r3, [r2]
    2af8:	e1a04104 	lsl	r4, r4, #2

      status = semaphore_create (buffer, 0, & rdv[i] . sem);
      ensure (status == DNA_OK, status);
    }

    rdv_devices[i] = NULL;
    2afc:	e3a00000 	mov	r0, #0
    2b00:	e7830004 	str	r0, [r3, r4]
    }

    kernel_free (rdv_devices);
    leave;
  }
}
    2b04:	e28dd044 	add	sp, sp, #68	; 0x44
    2b08:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
    2b0c:	e5982000 	ldr	r2, [r8]
    2b10:	eafffff2 	b	2ae0 <rdv_init_driver+0x118>
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);

    rdv = kernel_malloc (sizeof (channel_rdv_t) * (CHANNEL_RDV_NDEV), true);
    ensure (rdv_devices != NULL, DNA_OUT_OF_MEM);

    for (i = 0; i < CHANNEL_RDV_NDEV; i++)
    2b14:	e3a04000 	mov	r4, #0
    2b18:	eafffff7 	b	2afc <rdv_init_driver+0x134>
    2b1c:	0002554c 	.word	0x0002554c
    2b20:	000355d4 	.word	0x000355d4
    2b24:	000355d8 	.word	0x000355d8
    2b28:	00023b4c 	.word	0x00023b4c
    2b2c:	0000fffd 	.word	0x0000fffd

00002b30 <rdv_open>:
{
  int32_t id;

  watch (status_t)
  {
    ensure (name != NULL, DNA_ERROR);
    2b30:	e3500000 	cmp	r0, #0
    2b34:	0a00000b 	beq	2b68 <rdv_open+0x38>
#include <Private/Driver.h>
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rdv_open (char * name, int32_t mode, void ** data)
{
    2b38:	e92d4010 	push	{r4, lr}
    /*
     * Get the channel ID from the beginning
     * of the path.
     */

    id = dna_atoi (& name[19]);
    2b3c:	e2800013 	add	r0, r0, #19
    2b40:	e1a04002 	mov	r4, r2
    2b44:	eb001b25 	bl	97e0 <dna_atoi>
    ensure (id >= 0 && id < CHANNEL_RDV_NDEV, DNA_ERROR);
    2b48:	e2503000 	subs	r3, r0, #0
    2b4c:	ba000003 	blt	2b60 <rdv_open+0x30>
    2b50:	e59f2034 	ldr	r2, [pc, #52]	; 2b8c <rdv_open+0x5c>
    2b54:	e5922000 	ldr	r2, [r2]
    2b58:	e1530002 	cmp	r3, r2
    2b5c:	ba000003 	blt	2b70 <rdv_open+0x40>
{
  int32_t id;

  watch (status_t)
  {
    ensure (name != NULL, DNA_ERROR);
    2b60:	e59f0028 	ldr	r0, [pc, #40]	; 2b90 <rdv_open+0x60>
    2b64:	e8bd8010 	pop	{r4, pc}
    2b68:	e59f0020 	ldr	r0, [pc, #32]	; 2b90 <rdv_open+0x60>
     */

    *data = (void *) & rdv[id];
    return DNA_OK;
  }
}
    2b6c:	e12fff1e 	bx	lr

    /*
     * Return the device
     */

    *data = (void *) & rdv[id];
    2b70:	e59f201c 	ldr	r2, [pc, #28]	; 2b94 <rdv_open+0x64>
    2b74:	e0833083 	add	r3, r3, r3, lsl #1
    2b78:	e5922000 	ldr	r2, [r2]
    return DNA_OK;
    2b7c:	e3a00000 	mov	r0, #0

    /*
     * Return the device
     */

    *data = (void *) & rdv[id];
    2b80:	e0823183 	add	r3, r2, r3, lsl #3
    2b84:	e5843000 	str	r3, [r4]
    return DNA_OK;
  }
}
    2b88:	e8bd8010 	pop	{r4, pc}
    2b8c:	0002554c 	.word	0x0002554c
    2b90:	0000ffff 	.word	0x0000ffff
    2b94:	000355d8 	.word	0x000355d8

00002b98 <rdv_init_hardware>:
#include <DnaTools/DnaTools.h>

status_t rdv_init_hardware (void)
{
  return DNA_OK;
}
    2b98:	e3a00000 	mov	r0, #0
    2b9c:	e12fff1e 	bx	lr

00002ba0 <rdv_free>:
#include <DnaTools/DnaTools.h>

status_t rdv_free (void * data)
{
  return DNA_NOT_IMPLEMENTED;
}
    2ba0:	e59f0000 	ldr	r0, [pc]	; 2ba8 <rdv_free+0x8>
    2ba4:	e12fff1e 	bx	lr
    2ba8:	0000fffe 	.word	0x0000fffe

00002bac <rdv_control>:

#include <Private/Driver.h>

status_t rdv_control (void * handler, int32_t operation,
    va_list arguments, int32_t * p_res)
{
    2bac:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
    2bb0:	e1a05001 	mov	r5, r1
  bool * result = NULL;
  status_t status = DNA_OK;
  interrupt_status_t it_status;

  it_status = cpu_trap_mask_and_backup ();
  lock_acquire (& rdv -> lock);
    2bb4:	e2806004 	add	r6, r0, #4

#include <Private/Driver.h>

status_t rdv_control (void * handler, int32_t operation,
    va_list arguments, int32_t * p_res)
{
    2bb8:	e1a09002 	mov	r9, r2
    2bbc:	e1a08003 	mov	r8, r3
    2bc0:	e1a04000 	mov	r4, r0
  channel_rdv_t * rdv = (channel_rdv_t *)handler;
  bool * result = NULL;
  status_t status = DNA_OK;
  interrupt_status_t it_status;

  it_status = cpu_trap_mask_and_backup ();
    2bc4:	eb001bcd 	bl	9b00 <cpu_trap_mask_and_backup>
    2bc8:	e1a07000 	mov	r7, r0
  lock_acquire (& rdv -> lock);
    2bcc:	e1a00006 	mov	r0, r6
    2bd0:	eb001d16 	bl	a030 <lock_acquire>
  
  switch (operation)
    2bd4:	e3550a01 	cmp	r5, #4096	; 0x1000
    2bd8:	0a000017 	beq	2c3c <rdv_control+0x90>
    2bdc:	e59f30c4 	ldr	r3, [pc, #196]	; 2ca8 <rdv_control+0xfc>
    2be0:	e1550003 	cmp	r5, r3
    2be4:	0a00001c 	beq	2c5c <rdv_control+0xb0>
    2be8:	e2433002 	sub	r3, r3, #2
    2bec:	e1550003 	cmp	r5, r3
    2bf0:	0a000008 	beq	2c18 <rdv_control+0x6c>
      }

      break;

    default :
      *p_res = -1;
    2bf4:	e3e03000 	mvn	r3, #0
      status = DNA_ERROR;
    2bf8:	e59f40ac 	ldr	r4, [pc, #172]	; 2cac <rdv_control+0x100>
      }

      break;

    default :
      *p_res = -1;
    2bfc:	e5883000 	str	r3, [r8]
      status = DNA_ERROR;
      break;
  }

  lock_release (& rdv -> lock);
    2c00:	e1a00006 	mov	r0, r6
    2c04:	eb0027ba 	bl	caf4 <lock_release>
  cpu_trap_restore (it_status);
    2c08:	e1a00007 	mov	r0, r7
    2c0c:	eb001bf4 	bl	9be4 <cpu_trap_restore>
 
  return status;
}
    2c10:	e1a00004 	mov	r0, r4
    2c14:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  switch (operation)
  {
    case RDV_RTEST :
      result = va_arg (arguments, bool *);

      if (rdv -> setter . ready)
    2c18:	e5d4300c 	ldrb	r3, [r4, #12]
  lock_acquire (& rdv -> lock);
  
  switch (operation)
  {
    case RDV_RTEST :
      result = va_arg (arguments, bool *);
    2c1c:	e5992000 	ldr	r2, [r9]

      if (rdv -> setter . ready)
    2c20:	e21330ff 	ands	r3, r3, #255	; 0xff
    2c24:	0a000008 	beq	2c4c <rdv_control+0xa0>
    case RDV_WTEST :
      result = va_arg (arguments, bool *);

      if (rdv -> getter . ready)
      {
        *result = true;
    2c28:	e3a03001 	mov	r3, #1
status_t rdv_control (void * handler, int32_t operation,
    va_list arguments, int32_t * p_res)
{
  channel_rdv_t * rdv = (channel_rdv_t *)handler;
  bool * result = NULL;
  status_t status = DNA_OK;
    2c2c:	e3a04000 	mov	r4, #0
    case RDV_WTEST :
      result = va_arg (arguments, bool *);

      if (rdv -> getter . ready)
      {
        *result = true;
    2c30:	e5c23000 	strb	r3, [r2]
        *p_res = 1;
    2c34:	e5883000 	str	r3, [r8]
    2c38:	eafffff0 	b	2c00 <rdv_control+0x54>
      break;

    case RDV_WTEST :
      result = va_arg (arguments, bool *);

      if (rdv -> getter . ready)
    2c3c:	e5d43014 	ldrb	r3, [r4, #20]
      }

      break;

    case RDV_WTEST :
      result = va_arg (arguments, bool *);
    2c40:	e5992000 	ldr	r2, [r9]

      if (rdv -> getter . ready)
    2c44:	e21330ff 	ands	r3, r3, #255	; 0xff
    2c48:	1afffff6 	bne	2c28 <rdv_control+0x7c>
        *result = true;
        *p_res = 1;
      }
      else
      {
        *result = false;
    2c4c:	e5c23000 	strb	r3, [r2]
status_t rdv_control (void * handler, int32_t operation,
    va_list arguments, int32_t * p_res)
{
  channel_rdv_t * rdv = (channel_rdv_t *)handler;
  bool * result = NULL;
  status_t status = DNA_OK;
    2c50:	e1a04003 	mov	r4, r3
        *p_res = 1;
      }
      else
      {
        *result = false;
        *p_res = 0;
    2c54:	e5883000 	str	r3, [r8]
    2c58:	eaffffe8 	b	2c00 <rdv_control+0x54>
      }

      break;

    case RDV_RESET :
      if (rdv -> getter . ready || rdv -> setter . ready)
    2c5c:	e5d43014 	ldrb	r3, [r4, #20]
    2c60:	e3530000 	cmp	r3, #0
    2c64:	1a000004 	bne	2c7c <rdv_control+0xd0>
    2c68:	e5d4300c 	ldrb	r3, [r4, #12]
    2c6c:	e21330ff 	ands	r3, r3, #255	; 0xff
        semaphore_release (rdv -> sem, 1, DNA_NO_RESCHEDULE);
        *p_res = 1;
      }
      else
      {
        *p_res = 0;
    2c70:	05883000 	streq	r3, [r8]
status_t rdv_control (void * handler, int32_t operation,
    va_list arguments, int32_t * p_res)
{
  channel_rdv_t * rdv = (channel_rdv_t *)handler;
  bool * result = NULL;
  status_t status = DNA_OK;
    2c74:	01a04003 	moveq	r4, r3
      }

      break;

    case RDV_RESET :
      if (rdv -> getter . ready || rdv -> setter . ready)
    2c78:	0affffe0 	beq	2c00 <rdv_control+0x54>
      {
        rdv -> getter . ready = false;
    2c7c:	e3a05000 	mov	r5, #0
        rdv -> setter . ready = false;
        semaphore_release (rdv -> sem, 1, DNA_NO_RESCHEDULE);
    2c80:	e3a01001 	mov	r1, #1
      break;

    case RDV_RESET :
      if (rdv -> getter . ready || rdv -> setter . ready)
      {
        rdv -> getter . ready = false;
    2c84:	e5c45014 	strb	r5, [r4, #20]
        rdv -> setter . ready = false;
        semaphore_release (rdv -> sem, 1, DNA_NO_RESCHEDULE);
    2c88:	e5940000 	ldr	r0, [r4]

    case RDV_RESET :
      if (rdv -> getter . ready || rdv -> setter . ready)
      {
        rdv -> getter . ready = false;
        rdv -> setter . ready = false;
    2c8c:	e5c4500c 	strb	r5, [r4, #12]
        semaphore_release (rdv -> sem, 1, DNA_NO_RESCHEDULE);
    2c90:	e1a02001 	mov	r2, r1
    2c94:	eb00270d 	bl	c8d0 <semaphore_release>
        *p_res = 1;
    2c98:	e3a03001 	mov	r3, #1
status_t rdv_control (void * handler, int32_t operation,
    va_list arguments, int32_t * p_res)
{
  channel_rdv_t * rdv = (channel_rdv_t *)handler;
  bool * result = NULL;
  status_t status = DNA_OK;
    2c9c:	e1a04005 	mov	r4, r5
      if (rdv -> getter . ready || rdv -> setter . ready)
      {
        rdv -> getter . ready = false;
        rdv -> setter . ready = false;
        semaphore_release (rdv -> sem, 1, DNA_NO_RESCHEDULE);
        *p_res = 1;
    2ca0:	e5883000 	str	r3, [r8]
    2ca4:	eaffffd5 	b	2c00 <rdv_control+0x54>
    2ca8:	00001001 	.word	0x00001001
    2cac:	0000ffff 	.word	0x0000ffff

00002cb0 <devfs_read_vnode>:

#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_read_vnode (void * ns, int64_t vnid, void ** data)
{
    2cb0:	e92d4010 	push	{r4, lr}
  devfs_inode_t inode = NULL;
  devfs_entry_t entry = NULL;

  watch (status_t)
  {
    inode = queue_lookup (& devfs -> inode_list,
    2cb4:	e2800014 	add	r0, r0, #20
    2cb8:	e59f1054 	ldr	r1, [pc, #84]	; 2d14 <devfs_read_vnode+0x64>
    2cbc:	eb001a27 	bl	9560 <queue_lookup>
        devfs_inode_id_inspector, vnid);
    ensure (inode != NULL, DNA_NO_VNODE);
    2cc0:	e2504000 	subs	r4, r0, #0
    2cc4:	0a00000e 	beq	2d04 <devfs_read_vnode+0x54>

    dna_log(VERBOSE_LEVEL, "Read inode [%s].", inode -> name);

    if (inode -> parent != NULL)
    2cc8:	e5940014 	ldr	r0, [r4, #20]
    2ccc:	e3500000 	cmp	r0, #0
    2cd0:	0a000007 	beq	2cf4 <devfs_read_vnode+0x44>
    {
      entry = queue_lookup (& inode -> parent -> entry_list,
    2cd4:	e2800f4b 	add	r0, r0, #300	; 0x12c
    2cd8:	e59f1038 	ldr	r1, [pc, #56]	; 2d18 <devfs_read_vnode+0x68>
    2cdc:	e2842018 	add	r2, r4, #24
    2ce0:	eb001a1e 	bl	9560 <queue_lookup>
          devfs_entry_name_inspector, inode -> name);
      ensure (entry != NULL, DNA_NO_ENTRY);
    2ce4:	e3500000 	cmp	r0, #0
    2ce8:	0a000007 	beq	2d0c <devfs_read_vnode+0x5c>

      entry -> loaded = true;
    2cec:	e3a03001 	mov	r3, #1
    2cf0:	e5c03010 	strb	r3, [r0, #16]
    }

    *data = inode;
    2cf4:	e59d3008 	ldr	r3, [sp, #8]
    return DNA_OK;
    2cf8:	e3a00000 	mov	r0, #0
      ensure (entry != NULL, DNA_NO_ENTRY);

      entry -> loaded = true;
    }

    *data = inode;
    2cfc:	e5834000 	str	r4, [r3]
    return DNA_OK;
    2d00:	e8bd8010 	pop	{r4, pc}

  watch (status_t)
  {
    inode = queue_lookup (& devfs -> inode_list,
        devfs_inode_id_inspector, vnid);
    ensure (inode != NULL, DNA_NO_VNODE);
    2d04:	e59f0010 	ldr	r0, [pc, #16]	; 2d1c <devfs_read_vnode+0x6c>
    2d08:	e8bd8010 	pop	{r4, pc}

    if (inode -> parent != NULL)
    {
      entry = queue_lookup (& inode -> parent -> entry_list,
          devfs_entry_name_inspector, inode -> name);
      ensure (entry != NULL, DNA_NO_ENTRY);
    2d0c:	e59f000c 	ldr	r0, [pc, #12]	; 2d20 <devfs_read_vnode+0x70>
    }

    *data = inode;
    return DNA_OK;
  }
}
    2d10:	e8bd8010 	pop	{r4, pc}
    2d14:	00003c88 	.word	0x00003c88
    2d18:	00003c54 	.word	0x00003c54
    2d1c:	0000fefd 	.word	0x0000fefd
    2d20:	0000feff 	.word	0x0000feff

00002d24 <devfs_ioctl>:
{
  devfs_inode_t inode = node;

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    2d24:	e5d1c010 	ldrb	ip, [r1, #16]
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_ioctl (void * ns, void * node, void * data,
    int32_t function, va_list arguments, int32_t * p_ret)
{
    2d28:	e92d4010 	push	{r4, lr}
  devfs_inode_t inode = node;

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    2d2c:	e35c0000 	cmp	ip, #0
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_ioctl (void * ns, void * node, void * data,
    int32_t function, va_list arguments, int32_t * p_ret)
{
    2d30:	e59d4008 	ldr	r4, [sp, #8]
    2d34:	e59de00c 	ldr	lr, [sp, #12]
  devfs_inode_t inode = node;

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    2d38:	1a00000b 	bne	2d6c <devfs_ioctl+0x48>
    {
      ensure (inode -> dev_cmd -> control != NULL, DNA_ERROR);
    2d3c:	e5911128 	ldr	r1, [r1, #296]	; 0x128
    2d40:	e591c014 	ldr	ip, [r1, #20]
    2d44:	e35c0000 	cmp	ip, #0
    2d48:	0a000005 	beq	2d64 <devfs_ioctl+0x40>
      return inode -> dev_cmd -> control (data, function, arguments, p_ret);
    2d4c:	e1a00002 	mov	r0, r2
    2d50:	e1a01003 	mov	r1, r3
    2d54:	e1a02004 	mov	r2, r4
    2d58:	e1a0300e 	mov	r3, lr
    }

    return DNA_OK;
  }
}
    2d5c:	e8bd4010 	pop	{r4, lr}
  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    {
      ensure (inode -> dev_cmd -> control != NULL, DNA_ERROR);
      return inode -> dev_cmd -> control (data, function, arguments, p_ret);
    2d60:	e12fff1c 	bx	ip

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    {
      ensure (inode -> dev_cmd -> control != NULL, DNA_ERROR);
    2d64:	e59f0008 	ldr	r0, [pc, #8]	; 2d74 <devfs_ioctl+0x50>
      return inode -> dev_cmd -> control (data, function, arguments, p_ret);
    }

    return DNA_OK;
  }
}
    2d68:	e8bd8010 	pop	{r4, pc}
    {
      ensure (inode -> dev_cmd -> control != NULL, DNA_ERROR);
      return inode -> dev_cmd -> control (data, function, arguments, p_ret);
    }

    return DNA_OK;
    2d6c:	e3a00000 	mov	r0, #0
    2d70:	e8bd8010 	pop	{r4, pc}
    2d74:	0000ffff 	.word	0x0000ffff

00002d78 <devfs_read>:
{
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (inode -> dev_cmd -> read != NULL, DNA_ERROR);
    2d78:	e5911128 	ldr	r1, [r1, #296]	; 0x128
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_read (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
    2d7c:	e92d0030 	push	{r4, r5}
    2d80:	e1cd40d8 	ldrd	r4, [sp, #8]
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (inode -> dev_cmd -> read != NULL, DNA_ERROR);
    2d84:	e591c00c 	ldr	ip, [r1, #12]
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_read (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
    2d88:	e59d1010 	ldr	r1, [sp, #16]
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (inode -> dev_cmd -> read != NULL, DNA_ERROR);
    2d8c:	e35c0000 	cmp	ip, #0
    2d90:	0a000006 	beq	2db0 <devfs_read+0x38>
    return inode -> dev_cmd -> read (file, data, offset, p_count);
    2d94:	e58d1008 	str	r1, [sp, #8]
    2d98:	e1a00002 	mov	r0, r2
    2d9c:	e1a01003 	mov	r1, r3
    2da0:	e1a02004 	mov	r2, r4
    2da4:	e1a03005 	mov	r3, r5
  }
}
    2da8:	e8bd0030 	pop	{r4, r5}
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (inode -> dev_cmd -> read != NULL, DNA_ERROR);
    return inode -> dev_cmd -> read (file, data, offset, p_count);
    2dac:	e12fff1c 	bx	ip
  }
}
    2db0:	e59f0004 	ldr	r0, [pc, #4]	; 2dbc <devfs_read+0x44>
    2db4:	e8bd0030 	pop	{r4, r5}
    2db8:	e12fff1e 	bx	lr
    2dbc:	0000ffff 	.word	0x0000ffff

00002dc0 <devfs_entry_unused_inspector>:

#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

bool devfs_entry_unused_inspector (void * entry, va_list list)
{
    2dc0:	e92d4070 	push	{r4, r5, r6, lr}
  bool is_dot, is_dotdot;
  devfs_entry_t e = entry;

  watch (bool)
  {
    ensure (e != NULL, false);
    2dc4:	e2504000 	subs	r4, r0, #0
    2dc8:	0a00000e 	beq	2e08 <devfs_entry_unused_inspector+0x48>

    is_dot = dna_strcmp (e -> name, ".") == 0;
    2dcc:	e2846011 	add	r6, r4, #17
    2dd0:	e1a00006 	mov	r0, r6
    2dd4:	e59f1034 	ldr	r1, [pc, #52]	; 2e10 <devfs_entry_unused_inspector+0x50>
    2dd8:	eb0019d4 	bl	9530 <dna_strcmp>
    is_dotdot = dna_strcmp (e -> name, "..") == 0;
    2ddc:	e59f1030 	ldr	r1, [pc, #48]	; 2e14 <devfs_entry_unused_inspector+0x54>

  watch (bool)
  {
    ensure (e != NULL, false);

    is_dot = dna_strcmp (e -> name, ".") == 0;
    2de0:	e1a05000 	mov	r5, r0
    is_dotdot = dna_strcmp (e -> name, "..") == 0;
    2de4:	e1a00006 	mov	r0, r6
    2de8:	eb0019d0 	bl	9530 <dna_strcmp>

    return  ! is_dot && ! is_dotdot && ! e -> loaded;
    2dec:	e3500000 	cmp	r0, #0
    2df0:	13550000 	cmpne	r5, #0
    2df4:	13a00001 	movne	r0, #1
    2df8:	03a00000 	moveq	r0, #0
    2dfc:	15d40010 	ldrbne	r0, [r4, #16]
    2e00:	12200001 	eorne	r0, r0, #1
    2e04:	e8bd8070 	pop	{r4, r5, r6, pc}
  bool is_dot, is_dotdot;
  devfs_entry_t e = entry;

  watch (bool)
  {
    ensure (e != NULL, false);
    2e08:	e1a00004 	mov	r0, r4
    is_dot = dna_strcmp (e -> name, ".") == 0;
    is_dotdot = dna_strcmp (e -> name, "..") == 0;

    return  ! is_dot && ! is_dotdot && ! e -> loaded;
  }
}
    2e0c:	e8bd8070 	pop	{r4, r5, r6, pc}
    2e10:	00023b60 	.word	0x00023b60
    2e14:	00023b64 	.word	0x00023b64

00002e18 <devfs_inode_create>:
#include <MemoryManager/MemoryManager.h>

status_t devfs_inode_create (devfs_t fs, devfs_inode_t parent,
    devfs_inode_class_t class, char * name, int64_t vnid,
    device_cmd_t * commands, devfs_inode_t * p_inode)
{
    2e18:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int32_t path_length = 0;
  devfs_inode_t inode;

  watch (status_t)
  {
    ensure (name != NULL, DNA_BAD_ARGUMENT);
    2e1c:	e253a000 	subs	sl, r3, #0
    2e20:	0a000039 	beq	2f0c <devfs_inode_create+0xf4>

    if (parent != NULL && parent -> id != fs -> root_vnid)
    2e24:	e3510000 	cmp	r1, #0
    2e28:	e1a08000 	mov	r8, r0
    2e2c:	e1a09001 	mov	r9, r1
    2e30:	e1a0b002 	mov	fp, r2
    2e34:	01a04001 	moveq	r4, r1
    2e38:	0a000008 	beq	2e60 <devfs_inode_create+0x48>
    2e3c:	e1c040d8 	ldrd	r4, [r0, #8]
    2e40:	e1c160d8 	ldrd	r6, [r1, #8]
    2e44:	e1570005 	cmp	r7, r5
    2e48:	01560004 	cmpeq	r6, r4
    2e4c:	03a04000 	moveq	r4, #0
    2e50:	0a000002 	beq	2e60 <devfs_inode_create+0x48>
    {
      path_length = dna_strlen (parent -> path);
    2e54:	e2810f4f 	add	r0, r1, #316	; 0x13c
    2e58:	eb0019ed 	bl	9614 <dna_strlen>
    2e5c:	e1a04000 	mov	r4, r0
    }

    path_length += dna_strlen (name);
    2e60:	e1a0000a 	mov	r0, sl
    2e64:	eb0019ea 	bl	9614 <dna_strlen>
    2e68:	e0800004 	add	r0, r0, r4
    inode = kernel_malloc (sizeof (struct _devfs_inode) + path_length, true);
    2e6c:	e2800d05 	add	r0, r0, #320	; 0x140
    2e70:	e3a01001 	mov	r1, #1
    2e74:	eb002a1e 	bl	d6f4 <kernel_malloc>
    ensure (inode != NULL, DNA_OUT_OF_MEM);
    2e78:	e2506000 	subs	r6, r0, #0
    2e7c:	0a000020 	beq	2f04 <devfs_inode_create+0xec>

    inode -> id = vnid;
    2e80:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
    2e84:	e1c620f8 	strd	r2, [r6, #8]
    inode -> class = class;
    inode -> parent = parent;
    inode -> dev_cmd = commands;
    2e88:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
    path_length += dna_strlen (name);
    inode = kernel_malloc (sizeof (struct _devfs_inode) + path_length, true);
    ensure (inode != NULL, DNA_OUT_OF_MEM);

    inode -> id = vnid;
    inode -> class = class;
    2e8c:	e5c6b010 	strb	fp, [r6, #16]
    inode -> parent = parent;
    2e90:	e5869014 	str	r9, [r6, #20]
    inode -> dev_cmd = commands;
    2e94:	e5863128 	str	r3, [r6, #296]	; 0x128
    dna_strcpy (inode -> name, name);
    2e98:	e2860018 	add	r0, r6, #24
    2e9c:	e1a0100a 	mov	r1, sl
    2ea0:	eb001a10 	bl	96e8 <dna_strcpy>
    
    if (parent != NULL && parent -> id != fs -> root_vnid)
    2ea4:	e3590000 	cmp	r9, #0
    2ea8:	0a000019 	beq	2f14 <devfs_inode_create+0xfc>
    2eac:	e1c940d8 	ldrd	r4, [r9, #8]
    2eb0:	e1c820d8 	ldrd	r2, [r8, #8]
    2eb4:	e1550003 	cmp	r5, r3
    2eb8:	01540002 	cmpeq	r4, r2
    {
      dna_strcpy (inode -> path, parent -> path);
    2ebc:	e2864f4f 	add	r4, r6, #316	; 0x13c
    inode -> class = class;
    inode -> parent = parent;
    inode -> dev_cmd = commands;
    dna_strcpy (inode -> name, name);
    
    if (parent != NULL && parent -> id != fs -> root_vnid)
    2ec0:	0a000005 	beq	2edc <devfs_inode_create+0xc4>
    {
      dna_strcpy (inode -> path, parent -> path);
    2ec4:	e2891f4f 	add	r1, r9, #316	; 0x13c
    2ec8:	e1a00004 	mov	r0, r4
    2ecc:	eb001a05 	bl	96e8 <dna_strcpy>
      dna_strcat (inode -> path, "/");
    2ed0:	e1a00004 	mov	r0, r4
    2ed4:	e59f1050 	ldr	r1, [pc, #80]	; 2f2c <devfs_inode_create+0x114>
    2ed8:	eb001983 	bl	94ec <dna_strcat>
    }

    dna_strcat (inode -> path, name);
    2edc:	e1a00004 	mov	r0, r4
    2ee0:	e1a0100a 	mov	r1, sl
    2ee4:	eb001980 	bl	94ec <dna_strcat>

    if (fs != NULL)
    {
      queue_add (& fs -> inode_list, inode);
    2ee8:	e2880014 	add	r0, r8, #20
    2eec:	e1a01006 	mov	r1, r6
    2ef0:	eb001963 	bl	9484 <queue_add>
    }

    *p_inode = inode;
    2ef4:	e59d4034 	ldr	r4, [sp, #52]	; 0x34
    return DNA_OK;
    2ef8:	e3a00000 	mov	r0, #0
    if (fs != NULL)
    {
      queue_add (& fs -> inode_list, inode);
    }

    *p_inode = inode;
    2efc:	e5846000 	str	r6, [r4]
    return DNA_OK;
    2f00:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
      path_length = dna_strlen (parent -> path);
    }

    path_length += dna_strlen (name);
    inode = kernel_malloc (sizeof (struct _devfs_inode) + path_length, true);
    ensure (inode != NULL, DNA_OUT_OF_MEM);
    2f04:	e59f0024 	ldr	r0, [pc, #36]	; 2f30 <devfs_inode_create+0x118>
    2f08:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  int32_t path_length = 0;
  devfs_inode_t inode;

  watch (status_t)
  {
    ensure (name != NULL, DNA_BAD_ARGUMENT);
    2f0c:	e59f0020 	ldr	r0, [pc, #32]	; 2f34 <devfs_inode_create+0x11c>
    2f10:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    {
      dna_strcpy (inode -> path, parent -> path);
      dna_strcat (inode -> path, "/");
    }

    dna_strcat (inode -> path, name);
    2f14:	e1a0100a 	mov	r1, sl
    2f18:	e2860f4f 	add	r0, r6, #316	; 0x13c
    2f1c:	eb001972 	bl	94ec <dna_strcat>

    if (fs != NULL)
    2f20:	e3580000 	cmp	r8, #0
    2f24:	0afffff2 	beq	2ef4 <devfs_inode_create+0xdc>
    2f28:	eaffffee 	b	2ee8 <devfs_inode_create+0xd0>
    2f2c:	00023b68 	.word	0x00023b68
    2f30:	0000fffd 	.word	0x0000fffd
    2f34:	0000fffc 	.word	0x0000fffc

00002f38 <devfs_free>:
{
  devfs_inode_t inode = node;

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    2f38:	e5d13010 	ldrb	r3, [r1, #16]
    2f3c:	e3530000 	cmp	r3, #0
    2f40:	1a000007 	bne	2f64 <devfs_free+0x2c>
    {
      ensure (inode -> dev_cmd -> free != NULL, DNA_ERROR);
    2f44:	e5913128 	ldr	r3, [r1, #296]	; 0x128
    2f48:	e5933008 	ldr	r3, [r3, #8]
    2f4c:	e3530000 	cmp	r3, #0
    2f50:	0a000001 	beq	2f5c <devfs_free+0x24>
      return inode -> dev_cmd -> free (data);
    2f54:	e1a00002 	mov	r0, r2
    2f58:	e12fff13 	bx	r3

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    {
      ensure (inode -> dev_cmd -> free != NULL, DNA_ERROR);
    2f5c:	e59f0008 	ldr	r0, [pc, #8]	; 2f6c <devfs_free+0x34>
      return inode -> dev_cmd -> free (data);
    }

    return DNA_OK;
  }
}
    2f60:	e12fff1e 	bx	lr
    {
      ensure (inode -> dev_cmd -> free != NULL, DNA_ERROR);
      return inode -> dev_cmd -> free (data);
    }

    return DNA_OK;
    2f64:	e3a00000 	mov	r0, #0
    2f68:	e12fff1e 	bx	lr
    2f6c:	0000ffff 	.word	0x0000ffff

00002f70 <devfs_write>:
{
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (inode -> dev_cmd -> write != NULL, DNA_ERROR);
    2f70:	e5911128 	ldr	r1, [r1, #296]	; 0x128
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_write (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
    2f74:	e92d0030 	push	{r4, r5}
    2f78:	e1cd40d8 	ldrd	r4, [sp, #8]
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (inode -> dev_cmd -> write != NULL, DNA_ERROR);
    2f7c:	e591c010 	ldr	ip, [r1, #16]
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_write (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
    2f80:	e59d1010 	ldr	r1, [sp, #16]
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (inode -> dev_cmd -> write != NULL, DNA_ERROR);
    2f84:	e35c0000 	cmp	ip, #0
    2f88:	0a000006 	beq	2fa8 <devfs_write+0x38>
    return inode -> dev_cmd -> write (file, data, offset, p_count);
    2f8c:	e58d1008 	str	r1, [sp, #8]
    2f90:	e1a00002 	mov	r0, r2
    2f94:	e1a01003 	mov	r1, r3
    2f98:	e1a02004 	mov	r2, r4
    2f9c:	e1a03005 	mov	r3, r5
  }
}
    2fa0:	e8bd0030 	pop	{r4, r5}
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (inode -> dev_cmd -> write != NULL, DNA_ERROR);
    return inode -> dev_cmd -> write (file, data, offset, p_count);
    2fa4:	e12fff1c 	bx	ip
  }
}
    2fa8:	e59f0004 	ldr	r0, [pc, #4]	; 2fb4 <devfs_write+0x44>
    2fac:	e8bd0030 	pop	{r4, r5}
    2fb0:	e12fff1e 	bx	lr
    2fb4:	0000ffff 	.word	0x0000ffff

00002fb8 <devfs_open>:
{
  devfs_inode_t inode = node;

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    2fb8:	e5d10010 	ldrb	r0, [r1, #16]
    2fbc:	e3500000 	cmp	r0, #0
    2fc0:	1a000009 	bne	2fec <devfs_open+0x34>
    {
      ensure (inode -> dev_cmd -> open != NULL, DNA_ERROR);
    2fc4:	e5910128 	ldr	r0, [r1, #296]	; 0x128
    2fc8:	e590c000 	ldr	ip, [r0]
    2fcc:	e35c0000 	cmp	ip, #0
    2fd0:	0a000003 	beq	2fe4 <devfs_open+0x2c>
      return inode -> dev_cmd -> open (inode -> path, mode, data);
    2fd4:	e2810f4f 	add	r0, r1, #316	; 0x13c
    2fd8:	e1a01002 	mov	r1, r2
    2fdc:	e1a02003 	mov	r2, r3
    2fe0:	e12fff1c 	bx	ip

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    {
      ensure (inode -> dev_cmd -> open != NULL, DNA_ERROR);
    2fe4:	e59f0008 	ldr	r0, [pc, #8]	; 2ff4 <devfs_open+0x3c>
      return inode -> dev_cmd -> open (inode -> path, mode, data);
    }

    return DNA_OK;
  }
}
    2fe8:	e12fff1e 	bx	lr
    {
      ensure (inode -> dev_cmd -> open != NULL, DNA_ERROR);
      return inode -> dev_cmd -> open (inode -> path, mode, data);
    }

    return DNA_OK;
    2fec:	e3a00000 	mov	r0, #0
    2ff0:	e12fff1e 	bx	lr
    2ff4:	0000ffff 	.word	0x0000ffff

00002ff8 <devfs_create>:
  /*
   * Oops! We don't authorize mkdir on this FS !
   */

  return DNA_ERROR;
}
    2ff8:	e59f0000 	ldr	r0, [pc]	; 3000 <devfs_create+0x8>
    2ffc:	e12fff1e 	bx	lr
    3000:	0000ffff 	.word	0x0000ffff

00003004 <devfs_set_info>:
status_t devfs_set_info (void * ns, void * node, void * data,
    file_info_t info, int32_t mask)
{

  return DNA_OK;
}
    3004:	e3a00000 	mov	r0, #0
    3008:	e12fff1e 	bx	lr

0000300c <_va_call.4683.constprop.0>:
      case DNA_DEVFS_FILE :
        {
          int32_t ret;
          device_info_t dev_info;

          va_call (list,
    300c:	e92d000f 	push	{r0, r1, r2, r3}
    3010:	e1a0300c 	mov	r3, ip
    3014:	e92d4010 	push	{r4, lr}
    3018:	e59c2008 	ldr	r2, [ip, #8]
    301c:	e24dd008 	sub	sp, sp, #8
    3020:	e5922128 	ldr	r2, [r2, #296]	; 0x128
    3024:	e28dc014 	add	ip, sp, #20
    3028:	e5924014 	ldr	r4, [r2, #20]
    302c:	e4930004 	ldr	r0, [r3], #4
    3030:	e1a0200c 	mov	r2, ip
    3034:	e3a01006 	mov	r1, #6
    3038:	e58dc004 	str	ip, [sp, #4]
    303c:	e12fff34 	blx	r4
    3040:	e28dd008 	add	sp, sp, #8
    3044:	e8bd4010 	pop	{r4, lr}
    3048:	e28dd010 	add	sp, sp, #16
    304c:	e12fff1e 	bx	lr

00003050 <devfs_get_info>:
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_get_info (void * ns, void * node,
    void * data, file_info_t * p_info)
{
    3050:	e92d4030 	push	{r4, r5, lr}
  devfs_t devfs = ns;
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (devfs != NULL, DNA_BAD_ARGUMENT);
    3054:	e2505000 	subs	r5, r0, #0
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_get_info (void * ns, void * node,
    void * data, file_info_t * p_info)
{
    3058:	e24dd024 	sub	sp, sp, #36	; 0x24
  devfs_t devfs = ns;
  devfs_inode_t inode = node;
    305c:	e58d100c 	str	r1, [sp, #12]
 */

#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_get_info (void * ns, void * node,
    3060:	e58d2004 	str	r2, [sp, #4]
  devfs_t devfs = ns;
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (devfs != NULL, DNA_BAD_ARGUMENT);
    3064:	0a000017 	beq	30c8 <devfs_get_info+0x78>
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    3068:	e3510000 	cmp	r1, #0
    306c:	0a000015 	beq	30c8 <devfs_get_info+0x78>
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);
    3070:	e3530000 	cmp	r3, #0
    3074:	e1a04003 	mov	r4, r3
    3078:	0a000012 	beq	30c8 <devfs_get_info+0x78>

    dna_memset (p_info, 0, sizeof (file_info_t));
    307c:	e1a00003 	mov	r0, r3
    3080:	e3a01000 	mov	r1, #0
    3084:	e3a02040 	mov	r2, #64	; 0x40
    3088:	eb001695 	bl	8ae4 <dna_memset>

    p_info -> volume = devfs -> vid;
    p_info -> vnode = inode -> id;
    308c:	e59d300c 	ldr	r3, [sp, #12]
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);

    dna_memset (p_info, 0, sizeof (file_info_t));

    p_info -> volume = devfs -> vid;
    3090:	e5952010 	ldr	r2, [r5, #16]
    p_info -> vnode = inode -> id;

    switch (inode -> class)
    3094:	e5d31010 	ldrb	r1, [r3, #16]
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);

    dna_memset (p_info, 0, sizeof (file_info_t));

    p_info -> volume = devfs -> vid;
    3098:	e5842000 	str	r2, [r4]
    p_info -> vnode = inode -> id;

    switch (inode -> class)
    309c:	e3510001 	cmp	r1, #1
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);

    dna_memset (p_info, 0, sizeof (file_info_t));

    p_info -> volume = devfs -> vid;
    p_info -> vnode = inode -> id;
    30a0:	e1c320d8 	ldrd	r2, [r3, #8]
    30a4:	e1c420f8 	strd	r2, [r4, #8]

    switch (inode -> class)
    30a8:	0a000002 	beq	30b8 <devfs_get_info+0x68>
    30ac:	3a000008 	bcc	30d4 <devfs_get_info+0x84>
    30b0:	e3510002 	cmp	r1, #2
    30b4:	1a000015 	bne	3110 <devfs_get_info+0xc0>
          p_info -> type = DNA_FILE_SYMBOLIC_LINK;
          break;
        }
    }

    return DNA_OK;
    30b8:	e3a00000 	mov	r0, #0
          break;
        }

      case DNA_DEVFS_SYMLINK :
        {
          p_info -> type = DNA_FILE_SYMBOLIC_LINK;
    30bc:	e5c41010 	strb	r1, [r4, #16]
        }
    }

    return DNA_OK;
  }
}
    30c0:	e28dd024 	add	sp, sp, #36	; 0x24
    30c4:	e8bd8030 	pop	{r4, r5, pc}
  devfs_t devfs = ns;
  devfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (devfs != NULL, DNA_BAD_ARGUMENT);
    30c8:	e59f0064 	ldr	r0, [pc, #100]	; 3134 <devfs_get_info+0xe4>
        }
    }

    return DNA_OK;
  }
}
    30cc:	e28dd024 	add	sp, sp, #36	; 0x24
    30d0:	e8bd8030 	pop	{r4, r5, pc}
      case DNA_DEVFS_FILE :
        {
          int32_t ret;
          device_info_t dev_info;

          va_call (list,
    30d4:	e28dc004 	add	ip, sp, #4
    30d8:	e59f0058 	ldr	r0, [pc, #88]	; 3138 <devfs_get_info+0xe8>
    30dc:	e28d1010 	add	r1, sp, #16
    30e0:	ebffffc9 	bl	300c <_va_call.4683.constprop.0>
              {
                inode -> dev_cmd -> control (data, DNA_GET_INFO, list, & ret);
              },
              & dev_info);

          switch (dev_info . type)
    30e4:	e59d3010 	ldr	r3, [sp, #16]
    30e8:	e3530004 	cmp	r3, #4
    30ec:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    30f0:	ea000004 	b	3108 <devfs_get_info+0xb8>
    30f4:	00003128 	.word	0x00003128
    30f8:	0000311c 	.word	0x0000311c
    30fc:	0000311c 	.word	0x0000311c
    3100:	0000311c 	.word	0x0000311c
    3104:	00003128 	.word	0x00003128
            case DNA_CD_DEVICE :
              p_info -> type = DNA_FILE_SPECIAL_BLOCK;
              break;

            default :
              p_info -> type = DNA_FILE_REGULAR;
    3108:	e3a03000 	mov	r3, #0
    310c:	e5c43010 	strb	r3, [r4, #16]
          p_info -> type = DNA_FILE_SYMBOLIC_LINK;
          break;
        }
    }

    return DNA_OK;
    3110:	e3a00000 	mov	r0, #0
  }
}
    3114:	e28dd024 	add	sp, sp, #36	; 0x24
    3118:	e8bd8030 	pop	{r4, r5, pc}
              break;

            case DNA_DISK_DEVICE :
            case DNA_WORM_DEVICE :
            case DNA_CD_DEVICE :
              p_info -> type = DNA_FILE_SPECIAL_BLOCK;
    311c:	e3a03004 	mov	r3, #4
    3120:	e5c43010 	strb	r3, [r4, #16]
              break;
    3124:	eafffff9 	b	3110 <devfs_get_info+0xc0>

          switch (dev_info . type)
          {
            case DNA_NETWORK_DEVICE :
            case DNA_CHARACTER_DEVICE :
              p_info -> type = DNA_FILE_SPECIAL_CHARACTER;
    3128:	e3a03003 	mov	r3, #3
    312c:	e5c43010 	strb	r3, [r4, #16]
              break;
    3130:	eafffff6 	b	3110 <devfs_get_info+0xc0>
    3134:	0000fffc 	.word	0x0000fffc
    3138:	00023b6c 	.word	0x00023b6c

0000313c <devfs_walk>:
  char ** devices = NULL, * a_path = NULL;
  int32_t driver_index = 0;

  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    313c:	e3510000 	cmp	r1, #0
    3140:	13500000 	cmpne	r0, #0
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_walk (void * ns, void * base, char * path,
    char ** new_path, int64_t * p_vnid)
{
    3144:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  char ** devices = NULL, * a_path = NULL;
  int32_t driver_index = 0;

  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    3148:	e1a0a000 	mov	sl, r0
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_walk (void * ns, void * base, char * path,
    char ** new_path, int64_t * p_vnid)
{
    314c:	e24dd00c 	sub	sp, sp, #12
  char ** devices = NULL, * a_path = NULL;
  int32_t driver_index = 0;

  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    3150:	e1a08001 	mov	r8, r1
    3154:	03a04001 	moveq	r4, #1
    3158:	13a04000 	movne	r4, #0
    315c:	059f0160 	ldreq	r0, [pc, #352]	; 32c4 <devfs_walk+0x188>
    3160:	1a000001 	bne	316c <devfs_walk+0x30>
    ensure (entry != NULL, DNA_NO_ENTRY);

    *p_vnid = entry -> id;
    return DNA_OK;
  }
}
    3164:	e28dd00c 	add	sp, sp, #12
    3168:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    dna_log(VERBOSE_LEVEL, "Analyzing \"%s\" on vnode %lld", path, inode -> id);

    if (inode -> id == devfs -> root_vnid)
    316c:	e1c160d8 	ldrd	r6, [r1, #8]
    3170:	e1a09002 	mov	r9, r2
    3174:	e1ca20d8 	ldrd	r2, [sl, #8]
    3178:	e1570003 	cmp	r7, r3
    317c:	01560002 	cmpeq	r6, r2
    3180:	0a00000d 	beq	31bc <devfs_walk+0x80>
    /*
     * Check whether the dummy inode is empty or not.
     * If everything is fine, get the path vnid.
     */

    entry = queue_lookup (& inode -> entry_list,
    3184:	e2880f4b 	add	r0, r8, #300	; 0x12c
    3188:	e1a02009 	mov	r2, r9
    318c:	e59f1134 	ldr	r1, [pc, #308]	; 32c8 <devfs_walk+0x18c>
    3190:	eb0018f2 	bl	9560 <queue_lookup>
        devfs_entry_name_inspector, path);
    ensure (entry != NULL, DNA_NO_ENTRY);
    3194:	e3500000 	cmp	r0, #0
    3198:	0a000005 	beq	31b4 <devfs_walk+0x78>

    *p_vnid = entry -> id;
    319c:	e1c020d8 	ldrd	r2, [r0, #8]
    return DNA_OK;
    31a0:	e3a00000 	mov	r0, #0

    entry = queue_lookup (& inode -> entry_list,
        devfs_entry_name_inspector, path);
    ensure (entry != NULL, DNA_NO_ENTRY);

    *p_vnid = entry -> id;
    31a4:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
    31a8:	e1c120f0 	strd	r2, [r1]
    return DNA_OK;
  }
}
    31ac:	e28dd00c 	add	sp, sp, #12
    31b0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
     * If everything is fine, get the path vnid.
     */

    entry = queue_lookup (& inode -> entry_list,
        devfs_entry_name_inspector, path);
    ensure (entry != NULL, DNA_NO_ENTRY);
    31b4:	e59f0110 	ldr	r0, [pc, #272]	; 32cc <devfs_walk+0x190>
    31b8:	eaffffe9 	b	3164 <devfs_walk+0x28>
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    dna_log(VERBOSE_LEVEL, "Analyzing \"%s\" on vnode %lld", path, inode -> id);

    if (inode -> id == devfs -> root_vnid)
    {
      ensure (dna_strcmp (path, "..") != 0, DNA_ALREADY_AT_ROOT);
    31bc:	e1a00009 	mov	r0, r9
    31c0:	e59f1108 	ldr	r1, [pc, #264]	; 32d0 <devfs_walk+0x194>
    31c4:	eb0018d9 	bl	9530 <dna_strcmp>
    31c8:	e3500000 	cmp	r0, #0
    31cc:	03a00002 	moveq	r0, #2
    31d0:	0affffe3 	beq	3164 <devfs_walk+0x28>

     /*
      * Parse the publish_devices.
      */

      a_path = kernel_malloc (DNA_PATH_LENGTH, false);
    31d4:	e3a00b01 	mov	r0, #1024	; 0x400
    31d8:	e1a01004 	mov	r1, r4
    31dc:	eb002944 	bl	d6f4 <kernel_malloc>
      ensure (a_path != NULL, DNA_OUT_OF_MEM);
    31e0:	e2505000 	subs	r5, r0, #0
    31e4:	0a000034 	beq	32bc <devfs_walk+0x180>

      for (driver_index = 0; driver_index < OS_N_DRIVERS; driver_index ++)
    31e8:	e59f10e4 	ldr	r1, [pc, #228]	; 32d4 <devfs_walk+0x198>
    31ec:	e5912000 	ldr	r2, [r1]
    31f0:	e3520000 	cmp	r2, #0
    31f4:	da00002d 	ble	32b0 <devfs_walk+0x174>
    31f8:	e59f60d8 	ldr	r6, [pc, #216]	; 32d8 <devfs_walk+0x19c>
    31fc:	e58d4004 	str	r4, [sp, #4]
      {
        devices = (char **) OS_DRIVERS_LIST[driver_index] -> publish_devices ();
    3200:	e4963004 	ldr	r3, [r6], #4
    3204:	e5933010 	ldr	r3, [r3, #16]
    3208:	e12fff33 	blx	r3

        for (int32_t j = 0; devices[j] != NULL; j ++)
    320c:	e5907000 	ldr	r7, [r0]
    3210:	e3570000 	cmp	r7, #0
    3214:	0a00001e 	beq	3294 <devfs_walk+0x158>
    3218:	e1a04000 	mov	r4, r0
    321c:	e280b004 	add	fp, r0, #4
    3220:	ea000003 	b	3234 <devfs_walk+0xf8>
    3224:	e1a0400b 	mov	r4, fp
    3228:	e49b7004 	ldr	r7, [fp], #4
    322c:	e3570000 	cmp	r7, #0
    3230:	0a000017 	beq	3294 <devfs_walk+0x158>
        {
          if (dna_memcmp (path, devices[j], dna_strlen(path)) == 0)
    3234:	e1a00009 	mov	r0, r9
    3238:	eb0018f5 	bl	9614 <dna_strlen>
    323c:	e1a01007 	mov	r1, r7
    3240:	e1a02000 	mov	r2, r0
    3244:	e1a00009 	mov	r0, r9
    3248:	eb001638 	bl	8b30 <dna_memcmp>
    324c:	e3500000 	cmp	r0, #0
    3250:	1afffff3 	bne	3224 <devfs_walk+0xe8>
          {
            dna_strcpy (a_path, devices[j]);
    3254:	e5941000 	ldr	r1, [r4]
    3258:	e1a00005 	mov	r0, r5
    325c:	eb001921 	bl	96e8 <dna_strcpy>
            commands = OS_DRIVERS_LIST[driver_index] -> find_device (a_path);
    3260:	e5163004 	ldr	r3, [r6, #-4]
    3264:	e1a00005 	mov	r0, r5
    3268:	e5933014 	ldr	r3, [r3, #20]
    326c:	e12fff33 	blx	r3
            devfs_inode_insert (devfs, inode, a_path, commands);
    3270:	e1a01008 	mov	r1, r8
        for (int32_t j = 0; devices[j] != NULL; j ++)
        {
          if (dna_memcmp (path, devices[j], dna_strlen(path)) == 0)
          {
            dna_strcpy (a_path, devices[j]);
            commands = OS_DRIVERS_LIST[driver_index] -> find_device (a_path);
    3274:	e1a03000 	mov	r3, r0
            devfs_inode_insert (devfs, inode, a_path, commands);
    3278:	e1a02005 	mov	r2, r5
    327c:	e1a0000a 	mov	r0, sl
    3280:	eb0001ca 	bl	39b0 <devfs_inode_insert>

      for (driver_index = 0; driver_index < OS_N_DRIVERS; driver_index ++)
      {
        devices = (char **) OS_DRIVERS_LIST[driver_index] -> publish_devices ();

        for (int32_t j = 0; devices[j] != NULL; j ++)
    3284:	e1a0400b 	mov	r4, fp
    3288:	e49b7004 	ldr	r7, [fp], #4
    328c:	e3570000 	cmp	r7, #0
    3290:	1affffe7 	bne	3234 <devfs_walk+0xf8>
      */

      a_path = kernel_malloc (DNA_PATH_LENGTH, false);
      ensure (a_path != NULL, DNA_OUT_OF_MEM);

      for (driver_index = 0; driver_index < OS_N_DRIVERS; driver_index ++)
    3294:	e59f2038 	ldr	r2, [pc, #56]	; 32d4 <devfs_walk+0x198>
    3298:	e59d1004 	ldr	r1, [sp, #4]
    329c:	e5923000 	ldr	r3, [r2]
    32a0:	e2811001 	add	r1, r1, #1
    32a4:	e1530001 	cmp	r3, r1
    32a8:	e58d1004 	str	r1, [sp, #4]
    32ac:	caffffd3 	bgt	3200 <devfs_walk+0xc4>
            devfs_inode_insert (devfs, inode, a_path, commands);
          }
        }
      }

      kernel_free (a_path);
    32b0:	e1a00005 	mov	r0, r5
    32b4:	eb002943 	bl	d7c8 <kernel_free>
    32b8:	eaffffb1 	b	3184 <devfs_walk+0x48>
     /*
      * Parse the publish_devices.
      */

      a_path = kernel_malloc (DNA_PATH_LENGTH, false);
      ensure (a_path != NULL, DNA_OUT_OF_MEM);
    32bc:	e59f0018 	ldr	r0, [pc, #24]	; 32dc <devfs_walk+0x1a0>
    32c0:	eaffffa7 	b	3164 <devfs_walk+0x28>
    32c4:	0000ffff 	.word	0x0000ffff
    32c8:	00003c54 	.word	0x00003c54
    32cc:	0000feff 	.word	0x0000feff
    32d0:	00023b64 	.word	0x00023b64
    32d4:	000254c8 	.word	0x000254c8
    32d8:	000254cc 	.word	0x000254cc
    32dc:	0000fffd 	.word	0x0000fffd

000032e0 <devfs_destroy_vnode>:
#include <DnaTools/DnaTools.h>

status_t devfs_destroy_vnode (void * ns, void * node)
{
  return DNA_OK;
}
    32e0:	e3a00000 	mov	r0, #0
    32e4:	e12fff1e 	bx	lr

000032e8 <devfs_inode_destroy>:
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_inode_destroy (devfs_t fs, devfs_inode_t inode)
{
    32e8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  devfs_entry_t entry;
  devfs_inode_t next_inode = NULL;

  watch (status_t)
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    32ec:	e2512000 	subs	r2, r1, #0
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_inode_destroy (devfs_t fs, devfs_inode_t inode)
{
    32f0:	e24dd05c 	sub	sp, sp, #92	; 0x5c
  devfs_entry_t entry;
  devfs_inode_t next_inode = NULL;

  watch (status_t)
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    32f4:	e58d204c 	str	r2, [sp, #76]	; 0x4c
    32f8:	059f04d8 	ldreq	r0, [pc, #1240]	; 37d8 <devfs_inode_destroy+0x4f0>
    32fc:	0a00000a 	beq	332c <devfs_inode_destroy+0x44>

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    3300:	e280b014 	add	fp, r0, #20
    3304:	e1a0a000 	mov	sl, r0
    3308:	e1a0000b 	mov	r0, fp
    330c:	eb001553 	bl	8860 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    3310:	e59d104c 	ldr	r1, [sp, #76]	; 0x4c
    3314:	e5d13010 	ldrb	r3, [r1, #16]
    3318:	e3530001 	cmp	r3, #1
    331c:	0a000004 	beq	3334 <devfs_inode_destroy+0x4c>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    3320:	e59d004c 	ldr	r0, [sp, #76]	; 0x4c
    3324:	eb002927 	bl	d7c8 <kernel_free>
    return DNA_OK;
    3328:	e3a00000 	mov	r0, #0
  }
}
    332c:	e28dd05c 	add	sp, sp, #92	; 0x5c
    3330:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    queue_extract (& fs -> inode_list, inode);
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
    3334:	e1a00001 	mov	r0, r1
    3338:	e59f149c 	ldr	r1, [pc, #1180]	; 37dc <devfs_inode_destroy+0x4f4>
    333c:	eb0002eb 	bl	3ef0 <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");
    3340:	e59d004c 	ldr	r0, [sp, #76]	; 0x4c
    3344:	e59f1494 	ldr	r1, [pc, #1172]	; 37e0 <devfs_inode_destroy+0x4f8>

      entry = queue_rem (& inode -> entry_list);
    3348:	e2802f4b 	add	r2, r0, #300	; 0x12c
    334c:	e58d2054 	str	r2, [sp, #84]	; 0x54
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    3350:	eb0002e6 	bl	3ef0 <devfs_entry_remove_by_name>
    3354:	ea000003 	b	3368 <devfs_inode_destroy+0x80>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    3358:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
    335c:	eb002919 	bl	d7c8 <kernel_free>
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
        ensure (status == DNA_OK, status);

        kernel_free (entry);
    3360:	e59d0044 	ldr	r0, [sp, #68]	; 0x44
    3364:	eb002917 	bl	d7c8 <kernel_free>
    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
    3368:	e59d0054 	ldr	r0, [sp, #84]	; 0x54
    336c:	eb00157b 	bl	8960 <queue_rem>
      while (entry != NULL)
    3370:	e3500000 	cmp	r0, #0
    3374:	e58d0044 	str	r0, [sp, #68]	; 0x44
    3378:	0affffe8 	beq	3320 <devfs_inode_destroy+0x38>
      {
        next_inode = queue_lookup (& fs -> inode_list,
    337c:	e59d1044 	ldr	r1, [sp, #68]	; 0x44
    3380:	e1a0000b 	mov	r0, fp
    3384:	e1c120d8 	ldrd	r2, [r1, #8]
    3388:	e59f1454 	ldr	r1, [pc, #1108]	; 37e4 <devfs_inode_destroy+0x4fc>
    338c:	eb001873 	bl	9560 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    3390:	e3500000 	cmp	r0, #0
    3394:	e58d0038 	str	r0, [sp, #56]	; 0x38
    3398:	0a0000e8 	beq	3740 <devfs_inode_destroy+0x458>
    339c:	e1a01000 	mov	r1, r0
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    33a0:	e1a0000b 	mov	r0, fp
    33a4:	eb00152d 	bl	8860 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    33a8:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
    33ac:	e5d23010 	ldrb	r3, [r2, #16]
    33b0:	e3530001 	cmp	r3, #1
    33b4:	1affffe7 	bne	3358 <devfs_inode_destroy+0x70>
    {
      devfs_entry_remove_by_name (inode, ".");
    33b8:	e1a00002 	mov	r0, r2
    33bc:	e59f1418 	ldr	r1, [pc, #1048]	; 37dc <devfs_inode_destroy+0x4f4>
    33c0:	eb0002ca 	bl	3ef0 <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");
    33c4:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
    33c8:	e59f1410 	ldr	r1, [pc, #1040]	; 37e0 <devfs_inode_destroy+0x4f8>

      entry = queue_rem (& inode -> entry_list);
    33cc:	e2803f4b 	add	r3, r0, #300	; 0x12c
    33d0:	e58d3050 	str	r3, [sp, #80]	; 0x50
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    33d4:	eb0002c5 	bl	3ef0 <devfs_entry_remove_by_name>
    33d8:	ea000003 	b	33ec <devfs_inode_destroy+0x104>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    33dc:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    33e0:	eb0028f8 	bl	d7c8 <kernel_free>
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
        ensure (status == DNA_OK, status);

        kernel_free (entry);
    33e4:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
    33e8:	eb0028f6 	bl	d7c8 <kernel_free>
    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
    33ec:	e59d0050 	ldr	r0, [sp, #80]	; 0x50
    33f0:	eb00155a 	bl	8960 <queue_rem>
      while (entry != NULL)
    33f4:	e3500000 	cmp	r0, #0
    33f8:	e58d0034 	str	r0, [sp, #52]	; 0x34
    33fc:	0affffd5 	beq	3358 <devfs_inode_destroy+0x70>
      {
        next_inode = queue_lookup (& fs -> inode_list,
    3400:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
    3404:	e1a0000b 	mov	r0, fp
    3408:	e1c120d8 	ldrd	r2, [r1, #8]
    340c:	e59f13d0 	ldr	r1, [pc, #976]	; 37e4 <devfs_inode_destroy+0x4fc>
    3410:	eb001852 	bl	9560 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    3414:	e3500000 	cmp	r0, #0
    3418:	e58d002c 	str	r0, [sp, #44]	; 0x2c
    341c:	0a0000c7 	beq	3740 <devfs_inode_destroy+0x458>
    3420:	e1a01000 	mov	r1, r0
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    3424:	e1a0000b 	mov	r0, fp
    3428:	eb00150c 	bl	8860 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    342c:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    3430:	e5d23010 	ldrb	r3, [r2, #16]
    3434:	e3530001 	cmp	r3, #1
    3438:	1affffe7 	bne	33dc <devfs_inode_destroy+0xf4>
    {
      devfs_entry_remove_by_name (inode, ".");
    343c:	e1a00002 	mov	r0, r2
    3440:	e59f1394 	ldr	r1, [pc, #916]	; 37dc <devfs_inode_destroy+0x4f4>
    3444:	eb0002a9 	bl	3ef0 <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");
    3448:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    344c:	e59f138c 	ldr	r1, [pc, #908]	; 37e0 <devfs_inode_destroy+0x4f8>

      entry = queue_rem (& inode -> entry_list);
    3450:	e2803f4b 	add	r3, r0, #300	; 0x12c
    3454:	e58d3048 	str	r3, [sp, #72]	; 0x48
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    3458:	eb0002a4 	bl	3ef0 <devfs_entry_remove_by_name>
    345c:	ea000003 	b	3470 <devfs_inode_destroy+0x188>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    3460:	e59d0020 	ldr	r0, [sp, #32]
    3464:	eb0028d7 	bl	d7c8 <kernel_free>
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
        ensure (status == DNA_OK, status);

        kernel_free (entry);
    3468:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    346c:	eb0028d5 	bl	d7c8 <kernel_free>
    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
    3470:	e59d0048 	ldr	r0, [sp, #72]	; 0x48
    3474:	eb001539 	bl	8960 <queue_rem>
      while (entry != NULL)
    3478:	e3500000 	cmp	r0, #0
    347c:	e58d0028 	str	r0, [sp, #40]	; 0x28
    3480:	0affffd5 	beq	33dc <devfs_inode_destroy+0xf4>
      {
        next_inode = queue_lookup (& fs -> inode_list,
    3484:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
    3488:	e1a0000b 	mov	r0, fp
    348c:	e1c120d8 	ldrd	r2, [r1, #8]
    3490:	e59f134c 	ldr	r1, [pc, #844]	; 37e4 <devfs_inode_destroy+0x4fc>
    3494:	eb001831 	bl	9560 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    3498:	e3500000 	cmp	r0, #0
    349c:	e58d0020 	str	r0, [sp, #32]
    34a0:	0a0000a6 	beq	3740 <devfs_inode_destroy+0x458>
    34a4:	e1a01000 	mov	r1, r0
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    34a8:	e1a0000b 	mov	r0, fp
    34ac:	eb0014eb 	bl	8860 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    34b0:	e59d2020 	ldr	r2, [sp, #32]
    34b4:	e5d23010 	ldrb	r3, [r2, #16]
    34b8:	e3530001 	cmp	r3, #1
    34bc:	1affffe7 	bne	3460 <devfs_inode_destroy+0x178>
    {
      devfs_entry_remove_by_name (inode, ".");
    34c0:	e1a00002 	mov	r0, r2
    34c4:	e59f1310 	ldr	r1, [pc, #784]	; 37dc <devfs_inode_destroy+0x4f4>
    34c8:	eb000288 	bl	3ef0 <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");
    34cc:	e59d0020 	ldr	r0, [sp, #32]
    34d0:	e59f1308 	ldr	r1, [pc, #776]	; 37e0 <devfs_inode_destroy+0x4f8>

      entry = queue_rem (& inode -> entry_list);
    34d4:	e2803f4b 	add	r3, r0, #300	; 0x12c
    34d8:	e58d3040 	str	r3, [sp, #64]	; 0x40
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    34dc:	eb000283 	bl	3ef0 <devfs_entry_remove_by_name>
    34e0:	ea000003 	b	34f4 <devfs_inode_destroy+0x20c>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    34e4:	e59d0014 	ldr	r0, [sp, #20]
    34e8:	eb0028b6 	bl	d7c8 <kernel_free>
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
        ensure (status == DNA_OK, status);

        kernel_free (entry);
    34ec:	e59d001c 	ldr	r0, [sp, #28]
    34f0:	eb0028b4 	bl	d7c8 <kernel_free>
    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
    34f4:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
    34f8:	eb001518 	bl	8960 <queue_rem>
      while (entry != NULL)
    34fc:	e3500000 	cmp	r0, #0
    3500:	e58d001c 	str	r0, [sp, #28]
    3504:	0affffd5 	beq	3460 <devfs_inode_destroy+0x178>
      {
        next_inode = queue_lookup (& fs -> inode_list,
    3508:	e59d101c 	ldr	r1, [sp, #28]
    350c:	e1a0000b 	mov	r0, fp
    3510:	e1c120d8 	ldrd	r2, [r1, #8]
    3514:	e59f12c8 	ldr	r1, [pc, #712]	; 37e4 <devfs_inode_destroy+0x4fc>
    3518:	eb001810 	bl	9560 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    351c:	e3500000 	cmp	r0, #0
    3520:	e58d0014 	str	r0, [sp, #20]
    3524:	0a000085 	beq	3740 <devfs_inode_destroy+0x458>
    3528:	e1a01000 	mov	r1, r0
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    352c:	e1a0000b 	mov	r0, fp
    3530:	eb0014ca 	bl	8860 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    3534:	e59d2014 	ldr	r2, [sp, #20]
    3538:	e5d23010 	ldrb	r3, [r2, #16]
    353c:	e3530001 	cmp	r3, #1
    3540:	1affffe7 	bne	34e4 <devfs_inode_destroy+0x1fc>
    {
      devfs_entry_remove_by_name (inode, ".");
    3544:	e1a00002 	mov	r0, r2
    3548:	e59f128c 	ldr	r1, [pc, #652]	; 37dc <devfs_inode_destroy+0x4f4>
    354c:	eb000267 	bl	3ef0 <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");
    3550:	e59d0014 	ldr	r0, [sp, #20]
    3554:	e59f1284 	ldr	r1, [pc, #644]	; 37e0 <devfs_inode_destroy+0x4f8>

      entry = queue_rem (& inode -> entry_list);
    3558:	e2803f4b 	add	r3, r0, #300	; 0x12c
    355c:	e58d3030 	str	r3, [sp, #48]	; 0x30
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    3560:	eb000262 	bl	3ef0 <devfs_entry_remove_by_name>
    3564:	ea000003 	b	3578 <devfs_inode_destroy+0x290>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    3568:	e59d000c 	ldr	r0, [sp, #12]
    356c:	eb002895 	bl	d7c8 <kernel_free>
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
        ensure (status == DNA_OK, status);

        kernel_free (entry);
    3570:	e59d0010 	ldr	r0, [sp, #16]
    3574:	eb002893 	bl	d7c8 <kernel_free>
    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
    3578:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
    357c:	eb0014f7 	bl	8960 <queue_rem>
      while (entry != NULL)
    3580:	e3500000 	cmp	r0, #0
    3584:	e58d0010 	str	r0, [sp, #16]
    3588:	0affffd5 	beq	34e4 <devfs_inode_destroy+0x1fc>
      {
        next_inode = queue_lookup (& fs -> inode_list,
    358c:	e59d1010 	ldr	r1, [sp, #16]
    3590:	e1a0000b 	mov	r0, fp
    3594:	e1c120d8 	ldrd	r2, [r1, #8]
    3598:	e59f1244 	ldr	r1, [pc, #580]	; 37e4 <devfs_inode_destroy+0x4fc>
    359c:	eb0017ef 	bl	9560 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    35a0:	e3500000 	cmp	r0, #0
    35a4:	e58d000c 	str	r0, [sp, #12]
    35a8:	0a000064 	beq	3740 <devfs_inode_destroy+0x458>
    35ac:	e1a01000 	mov	r1, r0
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    35b0:	e1a0000b 	mov	r0, fp
    35b4:	eb0014a9 	bl	8860 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    35b8:	e59d200c 	ldr	r2, [sp, #12]
    35bc:	e5d23010 	ldrb	r3, [r2, #16]
    35c0:	e3530001 	cmp	r3, #1
    35c4:	1affffe7 	bne	3568 <devfs_inode_destroy+0x280>
    {
      devfs_entry_remove_by_name (inode, ".");
    35c8:	e1a00002 	mov	r0, r2
    35cc:	e59f1208 	ldr	r1, [pc, #520]	; 37dc <devfs_inode_destroy+0x4f4>
    35d0:	eb000246 	bl	3ef0 <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");
    35d4:	e59d000c 	ldr	r0, [sp, #12]
    35d8:	e59f1200 	ldr	r1, [pc, #512]	; 37e0 <devfs_inode_destroy+0x4f8>

      entry = queue_rem (& inode -> entry_list);
    35dc:	e2803f4b 	add	r3, r0, #300	; 0x12c
    35e0:	e58d3024 	str	r3, [sp, #36]	; 0x24
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    35e4:	eb000241 	bl	3ef0 <devfs_entry_remove_by_name>
    35e8:	ea000003 	b	35fc <devfs_inode_destroy+0x314>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    35ec:	e59d0004 	ldr	r0, [sp, #4]
    35f0:	eb002874 	bl	d7c8 <kernel_free>
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
        ensure (status == DNA_OK, status);

        kernel_free (entry);
    35f4:	e59d0008 	ldr	r0, [sp, #8]
    35f8:	eb002872 	bl	d7c8 <kernel_free>
    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
    35fc:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
    3600:	eb0014d6 	bl	8960 <queue_rem>
      while (entry != NULL)
    3604:	e3500000 	cmp	r0, #0
    3608:	e58d0008 	str	r0, [sp, #8]
    360c:	0affffd5 	beq	3568 <devfs_inode_destroy+0x280>
      {
        next_inode = queue_lookup (& fs -> inode_list,
    3610:	e59d1008 	ldr	r1, [sp, #8]
    3614:	e1a0000b 	mov	r0, fp
    3618:	e1c120d8 	ldrd	r2, [r1, #8]
    361c:	e59f11c0 	ldr	r1, [pc, #448]	; 37e4 <devfs_inode_destroy+0x4fc>
    3620:	eb0017ce 	bl	9560 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    3624:	e3500000 	cmp	r0, #0
    3628:	e58d0004 	str	r0, [sp, #4]
    362c:	0a000043 	beq	3740 <devfs_inode_destroy+0x458>
    3630:	e1a01000 	mov	r1, r0
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    3634:	e1a0000b 	mov	r0, fp
    3638:	eb001488 	bl	8860 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    363c:	e59d2004 	ldr	r2, [sp, #4]
    3640:	e5d23010 	ldrb	r3, [r2, #16]
    3644:	e3530001 	cmp	r3, #1
    3648:	1affffe7 	bne	35ec <devfs_inode_destroy+0x304>
    {
      devfs_entry_remove_by_name (inode, ".");
    364c:	e1a00002 	mov	r0, r2
    3650:	e59f1184 	ldr	r1, [pc, #388]	; 37dc <devfs_inode_destroy+0x4f4>
    3654:	eb000225 	bl	3ef0 <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");
    3658:	e59d0004 	ldr	r0, [sp, #4]
    365c:	e59f117c 	ldr	r1, [pc, #380]	; 37e0 <devfs_inode_destroy+0x4f8>

      entry = queue_rem (& inode -> entry_list);
    3660:	e2803f4b 	add	r3, r0, #300	; 0x12c
    3664:	e58d3018 	str	r3, [sp, #24]
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    3668:	eb000220 	bl	3ef0 <devfs_entry_remove_by_name>

      entry = queue_rem (& inode -> entry_list);
    366c:	e59d0018 	ldr	r0, [sp, #24]
    3670:	eb0014ba 	bl	8960 <queue_rem>
      while (entry != NULL)
    3674:	e2509000 	subs	r9, r0, #0
    3678:	0affffdb 	beq	35ec <devfs_inode_destroy+0x304>
      {
        next_inode = queue_lookup (& fs -> inode_list,
    367c:	e1c920d8 	ldrd	r2, [r9, #8]
    3680:	e1a0000b 	mov	r0, fp
    3684:	e59f1158 	ldr	r1, [pc, #344]	; 37e4 <devfs_inode_destroy+0x4fc>
    3688:	eb0017b4 	bl	9560 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    368c:	e2508000 	subs	r8, r0, #0
    3690:	0a00002a 	beq	3740 <devfs_inode_destroy+0x458>
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    3694:	e1a0000b 	mov	r0, fp
    3698:	e1a01008 	mov	r1, r8
    369c:	eb00146f 	bl	8860 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    36a0:	e5d83010 	ldrb	r3, [r8, #16]
    36a4:	e3530001 	cmp	r3, #1
    36a8:	0a000027 	beq	374c <devfs_inode_destroy+0x464>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    36ac:	e1a00008 	mov	r0, r8
    36b0:	eb002844 	bl	d7c8 <kernel_free>
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
        ensure (status == DNA_OK, status);

        kernel_free (entry);
    36b4:	e1a00009 	mov	r0, r9
    36b8:	eb002842 	bl	d7c8 <kernel_free>
        entry = queue_rem (& inode -> entry_list);
    36bc:	e59d0018 	ldr	r0, [sp, #24]
    36c0:	eb0014a6 	bl	8960 <queue_rem>
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
      while (entry != NULL)
    36c4:	e2509000 	subs	r9, r0, #0
    36c8:	1affffeb 	bne	367c <devfs_inode_destroy+0x394>
    36cc:	eaffffc6 	b	35ec <devfs_inode_destroy+0x304>
    queue_extract (& fs -> inode_list, inode);
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
    36d0:	e59f1104 	ldr	r1, [pc, #260]	; 37dc <devfs_inode_destroy+0x4f4>
    36d4:	e1a00005 	mov	r0, r5
    36d8:	eb000204 	bl	3ef0 <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
    36dc:	e2857f4b 	add	r7, r5, #300	; 0x12c
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    36e0:	e59f10f8 	ldr	r1, [pc, #248]	; 37e0 <devfs_inode_destroy+0x4f8>
    36e4:	e1a00005 	mov	r0, r5
    36e8:	eb000200 	bl	3ef0 <devfs_entry_remove_by_name>

      entry = queue_rem (& inode -> entry_list);
    36ec:	e1a00007 	mov	r0, r7
    36f0:	eb00149a 	bl	8960 <queue_rem>
      while (entry != NULL)
    36f4:	e2504000 	subs	r4, r0, #0
    36f8:	1a00000a 	bne	3728 <devfs_inode_destroy+0x440>
    36fc:	ea00002b 	b	37b0 <devfs_inode_destroy+0x4c8>
      {
        next_inode = queue_lookup (& fs -> inode_list,
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
    3700:	e1a0000a 	mov	r0, sl
    3704:	ebfffef7 	bl	32e8 <devfs_inode_destroy>
        ensure (status == DNA_OK, status);
    3708:	e3500000 	cmp	r0, #0
    370c:	1affff06 	bne	332c <devfs_inode_destroy+0x44>

        kernel_free (entry);
    3710:	e1a00004 	mov	r0, r4
    3714:	eb00282b 	bl	d7c8 <kernel_free>
        entry = queue_rem (& inode -> entry_list);
    3718:	e1a00007 	mov	r0, r7
    371c:	eb00148f 	bl	8960 <queue_rem>
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
      while (entry != NULL)
    3720:	e2504000 	subs	r4, r0, #0
    3724:	0a000021 	beq	37b0 <devfs_inode_destroy+0x4c8>
      {
        next_inode = queue_lookup (& fs -> inode_list,
    3728:	e1c420d8 	ldrd	r2, [r4, #8]
    372c:	e59f10b0 	ldr	r1, [pc, #176]	; 37e4 <devfs_inode_destroy+0x4fc>
    3730:	e1a0000b 	mov	r0, fp
    3734:	eb001789 	bl	9560 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    3738:	e2501000 	subs	r1, r0, #0
    373c:	1affffef 	bne	3700 <devfs_inode_destroy+0x418>
    3740:	e59f00a0 	ldr	r0, [pc, #160]	; 37e8 <devfs_inode_destroy+0x500>
    }

    kernel_free (inode);
    return DNA_OK;
  }
}
    3744:	e28dd05c 	add	sp, sp, #92	; 0x5c
    3748:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    queue_extract (& fs -> inode_list, inode);
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
    374c:	e59f1088 	ldr	r1, [pc, #136]	; 37dc <devfs_inode_destroy+0x4f4>
    3750:	e1a00008 	mov	r0, r8
    3754:	eb0001e5 	bl	3ef0 <devfs_entry_remove_by_name>
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
    3758:	e2884f4b 	add	r4, r8, #300	; 0x12c
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");
    375c:	e59f107c 	ldr	r1, [pc, #124]	; 37e0 <devfs_inode_destroy+0x4f8>
    3760:	e1a00008 	mov	r0, r8
    3764:	eb0001e1 	bl	3ef0 <devfs_entry_remove_by_name>

      entry = queue_rem (& inode -> entry_list);
    3768:	e1a00004 	mov	r0, r4
    376c:	eb00147b 	bl	8960 <queue_rem>
      while (entry != NULL)
    3770:	e2506000 	subs	r6, r0, #0
    3774:	0affffcc 	beq	36ac <devfs_inode_destroy+0x3c4>
    3778:	e58d803c 	str	r8, [sp, #60]	; 0x3c
    377c:	e1a08004 	mov	r8, r4
      {
        next_inode = queue_lookup (& fs -> inode_list,
    3780:	e1c620d8 	ldrd	r2, [r6, #8]
    3784:	e1a0000b 	mov	r0, fp
    3788:	e59f1054 	ldr	r1, [pc, #84]	; 37e4 <devfs_inode_destroy+0x4fc>
    378c:	eb001773 	bl	9560 <queue_lookup>
            devfs_inode_id_inspector, entry -> id);
        ensure (next_inode != NULL, DNA_NO_VNODE);
    3790:	e2505000 	subs	r5, r0, #0
    3794:	0affffe9 	beq	3740 <devfs_inode_destroy+0x458>
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);

    dna_log(VERBOSE_LEVEL, "Destroy inode [%s].", inode -> name);

    queue_extract (& fs -> inode_list, inode);
    3798:	e1a0000b 	mov	r0, fp
    379c:	e1a01005 	mov	r1, r5
    37a0:	eb00142e 	bl	8860 <queue_extract>
    ensure (status == DNA_OK, status);

    if (inode -> class == DNA_DEVFS_DIRECTORY)
    37a4:	e5d53010 	ldrb	r3, [r5, #16]
    37a8:	e3530001 	cmp	r3, #1
    37ac:	0affffc7 	beq	36d0 <devfs_inode_destroy+0x3e8>
        kernel_free (entry);
        entry = queue_rem (& inode -> entry_list);
      }
    }

    kernel_free (inode);
    37b0:	e1a00005 	mov	r0, r5
    37b4:	eb002803 	bl	d7c8 <kernel_free>
        ensure (next_inode != NULL, DNA_NO_VNODE);

        status = devfs_inode_destroy (fs, next_inode);
        ensure (status == DNA_OK, status);

        kernel_free (entry);
    37b8:	e1a00006 	mov	r0, r6
    37bc:	eb002801 	bl	d7c8 <kernel_free>
        entry = queue_rem (& inode -> entry_list);
    37c0:	e1a00008 	mov	r0, r8
    37c4:	eb001465 	bl	8960 <queue_rem>
    {
      devfs_entry_remove_by_name (inode, ".");
      devfs_entry_remove_by_name (inode, "..");

      entry = queue_rem (& inode -> entry_list);
      while (entry != NULL)
    37c8:	e2506000 	subs	r6, r0, #0
    37cc:	1affffeb 	bne	3780 <devfs_inode_destroy+0x498>
    37d0:	e59d803c 	ldr	r8, [sp, #60]	; 0x3c
    37d4:	eaffffb4 	b	36ac <devfs_inode_destroy+0x3c4>
    37d8:	0000fffc 	.word	0x0000fffc
    37dc:	00023b60 	.word	0x00023b60
    37e0:	00023b64 	.word	0x00023b64
    37e4:	00003c88 	.word	0x00003c88
    37e8:	0000fefd 	.word	0x0000fefd

000037ec <devfs_mount>:
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t devfs_mount (int32_t vid, const char * dev_path, uint32_t flags,
    void * params, void ** data, int64_t * vnid)
{
    37ec:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  status_t status = DNA_OK;
  devfs_t devfs = NULL;
  devfs_inode_t root_inode = NULL;
    37f0:	e3a07000 	mov	r7, #0
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t devfs_mount (int32_t vid, const char * dev_path, uint32_t flags,
    void * params, void ** data, int64_t * vnid)
{
    37f4:	e24dd01c 	sub	sp, sp, #28
    37f8:	e1a08000 	mov	r8, r0
  {
    /*
     * Initialize the DevFS structure.
     */

    devfs = kernel_malloc (sizeof (struct devfs), true);
    37fc:	e3a01001 	mov	r1, #1
    3800:	e3a00028 	mov	r0, #40	; 0x28
status_t devfs_mount (int32_t vid, const char * dev_path, uint32_t flags,
    void * params, void ** data, int64_t * vnid)
{
  status_t status = DNA_OK;
  devfs_t devfs = NULL;
  devfs_inode_t root_inode = NULL;
    3804:	e58d7014 	str	r7, [sp, #20]
  {
    /*
     * Initialize the DevFS structure.
     */

    devfs = kernel_malloc (sizeof (struct devfs), true);
    3808:	eb0027b9 	bl	d6f4 <kernel_malloc>
    ensure (devfs != NULL, DNA_OUT_OF_MEM);
    380c:	e2506000 	subs	r6, r0, #0
    3810:	059f0148 	ldreq	r0, [pc, #328]	; 3960 <devfs_mount+0x174>
    3814:	0a000012 	beq	3864 <devfs_mount+0x78>

    devfs -> inode_index = 1;
    devfs -> vid = vid;
    devfs -> root_vnid = devfs -> inode_index ++;
    3818:	e3a02001 	mov	r2, #1
    381c:	e3a03000 	mov	r3, #0
    3820:	e3a04002 	mov	r4, #2
    3824:	e3a05000 	mov	r5, #0

    /*
     * Initialize the root inode structure.
     */

    status = devfs_inode_create (devfs, NULL, DNA_DEVFS_DIRECTORY,
    3828:	e28dc014 	add	ip, sp, #20
    devfs = kernel_malloc (sizeof (struct devfs), true);
    ensure (devfs != NULL, DNA_OUT_OF_MEM);

    devfs -> inode_index = 1;
    devfs -> vid = vid;
    devfs -> root_vnid = devfs -> inode_index ++;
    382c:	e1c640f0 	strd	r4, [r6]
    3830:	e1c620f8 	strd	r2, [r6, #8]

    devfs = kernel_malloc (sizeof (struct devfs), true);
    ensure (devfs != NULL, DNA_OUT_OF_MEM);

    devfs -> inode_index = 1;
    devfs -> vid = vid;
    3834:	e5868010 	str	r8, [r6, #16]

    /*
     * Initialize the root inode structure.
     */

    status = devfs_inode_create (devfs, NULL, DNA_DEVFS_DIRECTORY,
    3838:	e1a01007 	mov	r1, r7
    383c:	e1cd20f0 	strd	r2, [sp]
    3840:	e58d7008 	str	r7, [sp, #8]
    3844:	e58dc00c 	str	ip, [sp, #12]
    3848:	e59f3114 	ldr	r3, [pc, #276]	; 3964 <devfs_mount+0x178>
    384c:	ebfffd71 	bl	2e18 <devfs_inode_create>
        "", devfs -> root_vnid, NULL, & root_inode);
    check (inode_error, status == DNA_OK, status);
    3850:	e2504000 	subs	r4, r0, #0
    3854:	0a000004 	beq	386c <devfs_mount+0x80>
    devfs_inode_destroy (devfs, root_inode);
  }

  rescue (inode_error)
  {
    kernel_free (devfs);
    3858:	e1a00006 	mov	r0, r6
    385c:	eb0027d9 	bl	d7c8 <kernel_free>
    leave;
    3860:	e1a00004 	mov	r0, r4
  }
}
    3864:	e28dd01c 	add	sp, sp, #28
    3868:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}

    status = devfs_inode_create (devfs, NULL, DNA_DEVFS_DIRECTORY,
        "", devfs -> root_vnid, NULL, & root_inode);
    check (inode_error, status == DNA_OK, status);

    status = devfs_entry_add (root_inode, ".", root_inode -> id);
    386c:	e59d0014 	ldr	r0, [sp, #20]
    3870:	e59f10f0 	ldr	r1, [pc, #240]	; 3968 <devfs_mount+0x17c>
    3874:	e1c020d8 	ldrd	r2, [r0, #8]
    3878:	eb000180 	bl	3e80 <devfs_entry_add>
    check (entry_error, status == DNA_OK, status);
    387c:	e2504000 	subs	r4, r0, #0
    3880:	1a000028 	bne	3928 <devfs_mount+0x13c>

    status = devfs_entry_add (root_inode, "..", root_inode -> id);
    3884:	e59d0014 	ldr	r0, [sp, #20]
    3888:	e59f10dc 	ldr	r1, [pc, #220]	; 396c <devfs_mount+0x180>
    388c:	e1c020d8 	ldrd	r2, [r0, #8]
    3890:	eb00017a 	bl	3e80 <devfs_entry_add>
    check (entry_error, status == DNA_OK, status);
    3894:	e2504000 	subs	r4, r0, #0
    3898:	1a000022 	bne	3928 <devfs_mount+0x13c>

    /*
     * Load the in-kernel drivers and check if they are consistent.
     */

    for (driver_index = 0; driver_index < OS_N_DRIVERS; driver_index ++)
    389c:	e59f90cc 	ldr	r9, [pc, #204]	; 3970 <devfs_mount+0x184>
    38a0:	e5993000 	ldr	r3, [r9]
    38a4:	e1530007 	cmp	r3, r7
    38a8:	da000022 	ble	3938 <devfs_mount+0x14c>
    38ac:	e59f80c0 	ldr	r8, [pc, #192]	; 3974 <devfs_mount+0x188>
    38b0:	e1a05004 	mov	r5, r4
    38b4:	e1a07008 	mov	r7, r8
    38b8:	ea000008 	b	38e0 <devfs_mount+0xf4>
    {
      status = OS_DRIVERS_LIST[driver_index] -> init_hardware ();
      check (bad_driver, status == DNA_OK, status);

      status = OS_DRIVERS_LIST[driver_index] -> init_driver ();
    38bc:	e5b73004 	ldr	r3, [r7, #4]!
    38c0:	e5933008 	ldr	r3, [r3, #8]
    38c4:	e12fff33 	blx	r3
      check (bad_driver, status == DNA_OK, status);
    38c8:	e2504000 	subs	r4, r0, #0
    38cc:	1a000008 	bne	38f4 <devfs_mount+0x108>

    /*
     * Load the in-kernel drivers and check if they are consistent.
     */

    for (driver_index = 0; driver_index < OS_N_DRIVERS; driver_index ++)
    38d0:	e5993000 	ldr	r3, [r9]
    38d4:	e2855001 	add	r5, r5, #1
    38d8:	e1530005 	cmp	r3, r5
    38dc:	da000015 	ble	3938 <devfs_mount+0x14c>
    {
      status = OS_DRIVERS_LIST[driver_index] -> init_hardware ();
    38e0:	e5973004 	ldr	r3, [r7, #4]
    38e4:	e5933004 	ldr	r3, [r3, #4]
    38e8:	e12fff33 	blx	r3
      check (bad_driver, status == DNA_OK, status);
    38ec:	e2504000 	subs	r4, r0, #0
    38f0:	0afffff1 	beq	38bc <devfs_mount+0xd0>
    return vnode_create (root_inode -> id, devfs -> vid, (void *) root_inode);
  }

  rescue (bad_driver)
  {
    for (int32_t i = 0; i < driver_index; i += 1)
    38f4:	e3550000 	cmp	r5, #0
    38f8:	0a000006 	beq	3918 <devfs_mount+0x12c>
    38fc:	e3a07000 	mov	r7, #0
    {
      OS_DRIVERS_LIST[i] -> uninit_driver ();
    3900:	e5b83004 	ldr	r3, [r8, #4]!
    return vnode_create (root_inode -> id, devfs -> vid, (void *) root_inode);
  }

  rescue (bad_driver)
  {
    for (int32_t i = 0; i < driver_index; i += 1)
    3904:	e2877001 	add	r7, r7, #1
    {
      OS_DRIVERS_LIST[i] -> uninit_driver ();
    3908:	e593300c 	ldr	r3, [r3, #12]
    390c:	e12fff33 	blx	r3
    return vnode_create (root_inode -> id, devfs -> vid, (void *) root_inode);
  }

  rescue (bad_driver)
  {
    for (int32_t i = 0; i < driver_index; i += 1)
    3910:	e1570005 	cmp	r7, r5
    3914:	1afffff9 	bne	3900 <devfs_mount+0x114>
    {
      OS_DRIVERS_LIST[i] -> uninit_driver ();
    }

    devfs_entry_t entry = queue_rem (& root_inode -> entry_list);
    3918:	e59d0014 	ldr	r0, [sp, #20]
    391c:	e2800f4b 	add	r0, r0, #300	; 0x12c
    3920:	eb00140e 	bl	8960 <queue_rem>
    kernel_free (entry);
    3924:	eb0027a7 	bl	d7c8 <kernel_free>
  }

  rescue (entry_error)
  {
    devfs_inode_destroy (devfs, root_inode);
    3928:	e1a00006 	mov	r0, r6
    392c:	e59d1014 	ldr	r1, [sp, #20]
    3930:	ebfffe6c 	bl	32e8 <devfs_inode_destroy>
    3934:	eaffffc7 	b	3858 <devfs_mount+0x6c>

    /*
     * Add the root vnode to the system
     */

    *data = devfs;
    3938:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
    *vnid = root_inode -> id;
    393c:	e59d3014 	ldr	r3, [sp, #20]

    /*
     * Add the root vnode to the system
     */

    *data = devfs;
    3940:	e5826000 	str	r6, [r2]
    *vnid = root_inode -> id;
    3944:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
    3948:	e1c300d8 	ldrd	r0, [r3, #8]
    394c:	e1c200f0 	strd	r0, [r2]

    dna_log(VERBOSE_LEVEL, "DevFS mount succeeded.");
    return vnode_create (root_inode -> id, devfs -> vid, (void *) root_inode);
    3950:	e5962010 	ldr	r2, [r6, #16]
    3954:	e1c300d8 	ldrd	r0, [r3, #8]
    3958:	eb000d77 	bl	6f3c <vnode_create>
    395c:	eaffffc0 	b	3864 <devfs_mount+0x78>
    3960:	0000fffd 	.word	0x0000fffd
    3964:	00023d94 	.word	0x00023d94
    3968:	00023b60 	.word	0x00023b60
    396c:	00023b64 	.word	0x00023b64
    3970:	000254c8 	.word	0x000254c8
    3974:	000254c8 	.word	0x000254c8

00003978 <devfs_close>:
{
  devfs_inode_t inode = node;

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    3978:	e5d13010 	ldrb	r3, [r1, #16]
    397c:	e3530000 	cmp	r3, #0
    3980:	1a000007 	bne	39a4 <devfs_close+0x2c>
    {
      ensure (inode -> dev_cmd -> close != NULL, DNA_ERROR);
    3984:	e5913128 	ldr	r3, [r1, #296]	; 0x128
    3988:	e5933004 	ldr	r3, [r3, #4]
    398c:	e3530000 	cmp	r3, #0
    3990:	0a000001 	beq	399c <devfs_close+0x24>
      return inode -> dev_cmd -> close (data);
    3994:	e1a00002 	mov	r0, r2
    3998:	e12fff13 	bx	r3

  watch (status_t)
  {
    if (inode -> class == DNA_DEVFS_FILE)
    {
      ensure (inode -> dev_cmd -> close != NULL, DNA_ERROR);
    399c:	e59f0008 	ldr	r0, [pc, #8]	; 39ac <devfs_close+0x34>
      return inode -> dev_cmd -> close (data);
    }

    return DNA_OK;
  }
}
    39a0:	e12fff1e 	bx	lr
    {
      ensure (inode -> dev_cmd -> close != NULL, DNA_ERROR);
      return inode -> dev_cmd -> close (data);
    }

    return DNA_OK;
    39a4:	e3a00000 	mov	r0, #0
    39a8:	e12fff1e 	bx	lr
    39ac:	0000ffff 	.word	0x0000ffff

000039b0 <devfs_inode_insert>:

status_t devfs_inode_insert (devfs_t fs, devfs_inode_t inode,
    char * path, device_cmd_t * commands)
{
  devfs_entry_t entry = NULL;
  devfs_inode_t next_inode = NULL;
    39b0:	e3a0c000 	mov	ip, #0
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_inode_insert (devfs_t fs, devfs_inode_t inode,
    char * path, device_cmd_t * commands)
{
    39b4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  char token[DNA_FILENAME_LENGTH];
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (path != NULL, DNA_BAD_ARGUMENT);
    39b8:	e152000c 	cmp	r2, ip
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_inode_insert (devfs_t fs, devfs_inode_t inode,
    char * path, device_cmd_t * commands)
{
    39bc:	e24ddf49 	sub	sp, sp, #292	; 0x124
    39c0:	e58d2014 	str	r2, [sp, #20]
  devfs_entry_t entry = NULL;
  devfs_inode_t next_inode = NULL;
    39c4:	e58dc01c 	str	ip, [sp, #28]
  char token[DNA_FILENAME_LENGTH];
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (path != NULL, DNA_BAD_ARGUMENT);
    39c8:	059f015c 	ldreq	r0, [pc, #348]	; 3b2c <devfs_inode_insert+0x17c>
    39cc:	0a000010 	beq	3a14 <devfs_inode_insert+0x64>
    39d0:	e1a06001 	mov	r6, r1
    39d4:	e1a07000 	mov	r7, r0

    path_get_next_entry (& path, token);
    39d8:	e28d1020 	add	r1, sp, #32
    39dc:	e28d0014 	add	r0, sp, #20
    39e0:	e1a08003 	mov	r8, r3
    39e4:	eb0013f9 	bl	89d0 <path_get_next_entry>
    entry = queue_lookup (& inode -> entry_list,
    39e8:	e28d2020 	add	r2, sp, #32
    39ec:	e2860f4b 	add	r0, r6, #300	; 0x12c
    39f0:	e59f1138 	ldr	r1, [pc, #312]	; 3b30 <devfs_inode_insert+0x180>
    39f4:	eb0016d9 	bl	9560 <queue_lookup>
        devfs_entry_name_inspector, token);

    if (entry == NULL)
    39f8:	e2509000 	subs	r9, r0, #0
    {
      if (dna_strlen (path) != 0)
    39fc:	e59d0014 	ldr	r0, [sp, #20]

    path_get_next_entry (& path, token);
    entry = queue_lookup (& inode -> entry_list,
        devfs_entry_name_inspector, token);

    if (entry == NULL)
    3a00:	0a000005 	beq	3a1c <devfs_inode_insert+0x6c>
      devfs_entry_add (inode, token, next_inode -> id);
      dna_log(VERBOSE_LEVEL, "inode %s created", token);
    }
    else
    {
      ensure (dna_strlen (path) != 0, DNA_INODE_EXISTS);
    3a04:	eb001702 	bl	9614 <dna_strlen>
    3a08:	e3500000 	cmp	r0, #0
    3a0c:	059f0120 	ldreq	r0, [pc, #288]	; 3b34 <devfs_inode_insert+0x184>
    3a10:	1a000017 	bne	3a74 <devfs_inode_insert+0xc4>
      status = devfs_inode_insert (fs, next_inode, path, commands);
    }

    return status;
  }
}
    3a14:	e28ddf49 	add	sp, sp, #292	; 0x124
    3a18:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    entry = queue_lookup (& inode -> entry_list,
        devfs_entry_name_inspector, token);

    if (entry == NULL)
    {
      if (dna_strlen (path) != 0)
    3a1c:	eb0016fc 	bl	9614 <dna_strlen>
    3a20:	e2502000 	subs	r2, r0, #0
    3a24:	1a000023 	bne	3ab8 <devfs_inode_insert+0x108>
        devfs_inode_insert (fs, next_inode, path, commands);
      }
      else
      {
        devfs_inode_create (fs, inode, DNA_DEVFS_FILE, token,
            fs -> inode_index ++, commands, & next_inode);
    3a28:	e1c740d0 	ldrd	r4, [r7]

        devfs_inode_insert (fs, next_inode, path, commands);
      }
      else
      {
        devfs_inode_create (fs, inode, DNA_DEVFS_FILE, token,
    3a2c:	e294a001 	adds	sl, r4, #1
    3a30:	e28d301c 	add	r3, sp, #28
    3a34:	e2a5b000 	adc	fp, r5, #0
    3a38:	e58d8008 	str	r8, [sp, #8]
    3a3c:	e1cd40f0 	strd	r4, [sp]
    3a40:	e1a00007 	mov	r0, r7
    3a44:	e1c7a0f0 	strd	sl, [r7]
    3a48:	e1a01006 	mov	r1, r6
    3a4c:	e58d300c 	str	r3, [sp, #12]
    3a50:	e28d3020 	add	r3, sp, #32
    3a54:	ebfffcef 	bl	2e18 <devfs_inode_create>
            fs -> inode_index ++, commands, & next_inode);
      }

      devfs_entry_add (inode, token, next_inode -> id);
    3a58:	e59d301c 	ldr	r3, [sp, #28]
    3a5c:	e1a00006 	mov	r0, r6
    3a60:	e1c320d8 	ldrd	r2, [r3, #8]
    3a64:	e28d1020 	add	r1, sp, #32
    3a68:	eb000104 	bl	3e80 <devfs_entry_add>
    char * path, device_cmd_t * commands)
{
  devfs_entry_t entry = NULL;
  devfs_inode_t next_inode = NULL;
  char token[DNA_FILENAME_LENGTH];
  status_t status = DNA_OK;
    3a6c:	e3a00000 	mov	r0, #0
    3a70:	eaffffe7 	b	3a14 <devfs_inode_insert+0x64>

      /*
       * Load the corresponding inode.
       */

      next_inode = queue_lookup (& fs -> inode_list,
    3a74:	e59f10bc 	ldr	r1, [pc, #188]	; 3b38 <devfs_inode_insert+0x188>
    3a78:	e1c920d8 	ldrd	r2, [r9, #8]
    3a7c:	e2870014 	add	r0, r7, #20
    3a80:	eb0016b6 	bl	9560 <queue_lookup>
          devfs_inode_id_inspector, entry -> id);
      ensure (next_inode != NULL, DNA_NO_VNODE);
    3a84:	e3500000 	cmp	r0, #0

      /*
       * Load the corresponding inode.
       */

      next_inode = queue_lookup (& fs -> inode_list,
    3a88:	e1a01000 	mov	r1, r0
    3a8c:	e58d001c 	str	r0, [sp, #28]
          devfs_inode_id_inspector, entry -> id);
      ensure (next_inode != NULL, DNA_NO_VNODE);
    3a90:	0a000023 	beq	3b24 <devfs_inode_insert+0x174>
      ensure (next_inode -> class == DNA_DEVFS_DIRECTORY, DNA_BAD_INODE_TYPE);
    3a94:	e5d03010 	ldrb	r3, [r0, #16]
    3a98:	e3530001 	cmp	r3, #1
    3a9c:	159f0098 	ldrne	r0, [pc, #152]	; 3b3c <devfs_inode_insert+0x18c>
    3aa0:	1affffdb 	bne	3a14 <devfs_inode_insert+0x64>

      /*
       * Parse the rest of the path.
       */

      status = devfs_inode_insert (fs, next_inode, path, commands);
    3aa4:	e1a00007 	mov	r0, r7
    3aa8:	e1a03008 	mov	r3, r8
    3aac:	e59d2014 	ldr	r2, [sp, #20]
    3ab0:	ebffffbe 	bl	39b0 <devfs_inode_insert>
    3ab4:	eaffffd6 	b	3a14 <devfs_inode_insert+0x64>
    if (entry == NULL)
    {
      if (dna_strlen (path) != 0)
      {
        devfs_inode_create (fs, inode, DNA_DEVFS_DIRECTORY,
            token, fs -> inode_index ++, NULL, & next_inode);
    3ab8:	e1c720d0 	ldrd	r2, [r7]

    if (entry == NULL)
    {
      if (dna_strlen (path) != 0)
      {
        devfs_inode_create (fs, inode, DNA_DEVFS_DIRECTORY,
    3abc:	e2924001 	adds	r4, r2, #1
    3ac0:	e2a35000 	adc	r5, r3, #0
    3ac4:	e28d101c 	add	r1, sp, #28
    3ac8:	e1cd20f0 	strd	r2, [sp]
    3acc:	e58d9008 	str	r9, [sp, #8]
    3ad0:	e28d3020 	add	r3, sp, #32
    3ad4:	e1c740f0 	strd	r4, [r7]
    3ad8:	e1a00007 	mov	r0, r7
    3adc:	e58d100c 	str	r1, [sp, #12]
    3ae0:	e3a02001 	mov	r2, #1
    3ae4:	e1a01006 	mov	r1, r6
    3ae8:	ebfffcca 	bl	2e18 <devfs_inode_create>
            token, fs -> inode_index ++, NULL, & next_inode);

        devfs_entry_add (next_inode, ".", next_inode -> id);
    3aec:	e59d001c 	ldr	r0, [sp, #28]
    3af0:	e59f1048 	ldr	r1, [pc, #72]	; 3b40 <devfs_inode_insert+0x190>
    3af4:	e1c020d8 	ldrd	r2, [r0, #8]
    3af8:	eb0000e0 	bl	3e80 <devfs_entry_add>
        devfs_entry_add (next_inode, "..", inode -> id);
    3afc:	e1c620d8 	ldrd	r2, [r6, #8]
    3b00:	e59d001c 	ldr	r0, [sp, #28]
    3b04:	e59f1038 	ldr	r1, [pc, #56]	; 3b44 <devfs_inode_insert+0x194>
    3b08:	eb0000dc 	bl	3e80 <devfs_entry_add>

        devfs_inode_insert (fs, next_inode, path, commands);
    3b0c:	e1a00007 	mov	r0, r7
    3b10:	e1a03008 	mov	r3, r8
    3b14:	e59d101c 	ldr	r1, [sp, #28]
    3b18:	e59d2014 	ldr	r2, [sp, #20]
    3b1c:	ebffffa3 	bl	39b0 <devfs_inode_insert>
    3b20:	eaffffcc 	b	3a58 <devfs_inode_insert+0xa8>
       * Load the corresponding inode.
       */

      next_inode = queue_lookup (& fs -> inode_list,
          devfs_inode_id_inspector, entry -> id);
      ensure (next_inode != NULL, DNA_NO_VNODE);
    3b24:	e59f001c 	ldr	r0, [pc, #28]	; 3b48 <devfs_inode_insert+0x198>
    3b28:	eaffffb9 	b	3a14 <devfs_inode_insert+0x64>
    3b2c:	0000fffc 	.word	0x0000fffc
    3b30:	00003c54 	.word	0x00003c54
    3b34:	0000fef4 	.word	0x0000fef4
    3b38:	00003c88 	.word	0x00003c88
    3b3c:	0000fef7 	.word	0x0000fef7
    3b40:	00023b60 	.word	0x00023b60
    3b44:	00023b64 	.word	0x00023b64
    3b48:	0000fefd 	.word	0x0000fefd

00003b4c <devfs_readdir>:
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_readdir (void * ns, void * node, void * data,
    void * entry_array, int64_t * offset, int32_t * p_count)
{
    3b4c:	e92d43b0 	push	{r4, r5, r7, r8, r9, lr}
  int64_t pos = 0;
  directory_entry_t * p_entry = entry_array;

  watch (status_t)
  {
    ensure (ns != NULL && node != NULL
    3b50:	e3510000 	cmp	r1, #0
    3b54:	13500000 	cmpne	r0, #0
{
  devfs_t devfs = ns;
  devfs_inode_t inode = node;
  devfs_entry_t entry = NULL;
  status_t status = DNA_OK;
  int64_t pos = 0;
    3b58:	e3a04000 	mov	r4, #0
    3b5c:	e3a05000 	mov	r5, #0
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

status_t devfs_readdir (void * ns, void * node, void * data,
    void * entry_array, int64_t * offset, int32_t * p_count)
{
    3b60:	e24dd010 	sub	sp, sp, #16
  int64_t pos = 0;
  directory_entry_t * p_entry = entry_array;

  watch (status_t)
  {
    ensure (ns != NULL && node != NULL
    3b64:	e1a08000 	mov	r8, r0
{
  devfs_t devfs = ns;
  devfs_inode_t inode = node;
  devfs_entry_t entry = NULL;
  status_t status = DNA_OK;
  int64_t pos = 0;
    3b68:	e1cd40f8 	strd	r4, [sp, #8]
  directory_entry_t * p_entry = entry_array;

  watch (status_t)
  {
    ensure (ns != NULL && node != NULL
    3b6c:	1a000002 	bne	3b7c <devfs_readdir+0x30>
    3b70:	e59f00d0 	ldr	r0, [pc, #208]	; 3c48 <devfs_readdir+0xfc>
      }
    }

    return status;
  }
}
    3b74:	e28dd010 	add	sp, sp, #16
    3b78:	e8bd83b0 	pop	{r4, r5, r7, r8, r9, pc}
  int64_t pos = 0;
  directory_entry_t * p_entry = entry_array;

  watch (status_t)
  {
    ensure (ns != NULL && node != NULL
    3b7c:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    3b80:	e3500000 	cmp	r0, #0
    3b84:	13530000 	cmpne	r3, #0
    3b88:	03a07001 	moveq	r7, #1
    3b8c:	13a07000 	movne	r7, #0
    3b90:	0afffff6 	beq	3b70 <devfs_readdir+0x24>
        && entry_array != NULL && p_count != NULL, DNA_ERROR);
    ensure (inode -> class == DNA_DEVFS_DIRECTORY, DNA_BAD_INODE_TYPE);
    3b94:	e5d12010 	ldrb	r2, [r1, #16]
    3b98:	e3520001 	cmp	r2, #1
    3b9c:	159f00a8 	ldrne	r0, [pc, #168]	; 3c4c <devfs_readdir+0x100>
    3ba0:	1afffff3 	bne	3b74 <devfs_readdir+0x28>

    if (inode -> entry_list . status == 0)
    3ba4:	e5910138 	ldr	r0, [r1, #312]	; 0x138
    3ba8:	e3500000 	cmp	r0, #0
    3bac:	1a000002 	bne	3bbc <devfs_readdir+0x70>
      entry = queue_lookup (& inode -> entry_list,
          devfs_entry_index_inspector, & pos);

      if (entry == NULL)
      {
        *p_count = 0;
    3bb0:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    3bb4:	e5820000 	str	r0, [r2]
    3bb8:	eaffffed 	b	3b74 <devfs_readdir+0x28>
    {
      *p_count = 0;
    }
    else
    {
      pos = * offset;
    3bbc:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    3bc0:	e28d2010 	add	r2, sp, #16
    3bc4:	e1c040d0 	ldrd	r4, [r0]
      entry = queue_lookup (& inode -> entry_list,
    3bc8:	e2810f4b 	add	r0, r1, #300	; 0x12c
    {
      *p_count = 0;
    }
    else
    {
      pos = * offset;
    3bcc:	e16240f8 	strd	r4, [r2, #-8]!
      entry = queue_lookup (& inode -> entry_list,
    3bd0:	e59f1078 	ldr	r1, [pc, #120]	; 3c50 <devfs_readdir+0x104>
    3bd4:	e58d3004 	str	r3, [sp, #4]
    3bd8:	eb001660 	bl	9560 <queue_lookup>
          devfs_entry_index_inspector, & pos);

      if (entry == NULL)
    3bdc:	e3500000 	cmp	r0, #0
    3be0:	e59d3004 	ldr	r3, [sp, #4]
    3be4:	0afffff1 	beq	3bb0 <devfs_readdir+0x64>
        *p_count = 0;
      }
      else
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = devfs -> vid;
    3be8:	e5982010 	ldr	r2, [r8, #16]
        dna_strcpy (p_entry -> d_name, entry -> name);
    3bec:	e2804011 	add	r4, r0, #17
      {
        *p_count = 0;
      }
      else
      {
        p_entry -> vnid = entry -> id;
    3bf0:	e1c080d8 	ldrd	r8, [r0, #8]
        p_entry -> vid = devfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);
    3bf4:	e1a01004 	mov	r1, r4
        *p_count = 0;
      }
      else
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = devfs -> vid;
    3bf8:	e5832008 	str	r2, [r3, #8]
      {
        *p_count = 0;
      }
      else
      {
        p_entry -> vnid = entry -> id;
    3bfc:	e1c380f0 	strd	r8, [r3]
        p_entry -> vid = devfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);
    3c00:	e283000e 	add	r0, r3, #14
    3c04:	e58d3004 	str	r3, [sp, #4]
    3c08:	eb0016b6 	bl	96e8 <dna_strcpy>

        p_entry -> d_reclen = sizeof (struct _directory_entry)
          + dna_strlen (entry -> name);
    3c0c:	e1a00004 	mov	r0, r4
    3c10:	eb00167f 	bl	9614 <dna_strlen>
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = devfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
    3c14:	e59d3004 	ldr	r3, [sp, #4]
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
        *offset += 1;
    3c18:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = devfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
    3c1c:	e2800010 	add	r0, r0, #16
    3c20:	e6ff1070 	uxth	r1, r0
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
        *offset += 1;
    3c24:	e1c240d0 	ldrd	r4, [r2]
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = devfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
    3c28:	e1c310bc 	strh	r1, [r3, #12]
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
        *offset += 1;
    3c2c:	e2944001 	adds	r4, r4, #1
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
    3c30:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
        *offset += 1;
    3c34:	e2a55000 	adc	r5, r5, #0
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
    3c38:	e5831000 	str	r1, [r3]
        *offset += 1;
      }
    }

    return status;
    3c3c:	e1a00007 	mov	r0, r7

        p_entry -> d_reclen = sizeof (struct _directory_entry)
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
        *offset += 1;
    3c40:	e1c240f0 	strd	r4, [r2]
    3c44:	eaffffca 	b	3b74 <devfs_readdir+0x28>
    3c48:	0000ffff 	.word	0x0000ffff
    3c4c:	0000fef7 	.word	0x0000fef7
    3c50:	00003e30 	.word	0x00003e30

00003c54 <devfs_entry_name_inspector>:
  devfs_entry_t e = entry;
  char * name = va_arg (list, char *);
  
  watch (bool)
  {
    ensure (e != NULL, false);
    3c54:	e3500000 	cmp	r0, #0
#include <DnaTools/DnaTools.h>

bool devfs_entry_name_inspector (void * entry, va_list list)
{
  devfs_entry_t e = entry;
  char * name = va_arg (list, char *);
    3c58:	e5911000 	ldr	r1, [r1]
  
  watch (bool)
  {
    ensure (e != NULL, false);
    3c5c:	012fff1e 	bxeq	lr
    ensure (name != NULL, false);
    3c60:	e3510000 	cmp	r1, #0
    3c64:	0a000005 	beq	3c80 <devfs_entry_name_inspector+0x2c>

#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>

bool devfs_entry_name_inspector (void * entry, va_list list)
{
    3c68:	e92d4008 	push	{r3, lr}
  watch (bool)
  {
    ensure (e != NULL, false);
    ensure (name != NULL, false);

    return dna_strcmp (e -> name, name) == 0;
    3c6c:	e2800011 	add	r0, r0, #17
    3c70:	eb00162e 	bl	9530 <dna_strcmp>
    3c74:	e16f0f10 	clz	r0, r0
    3c78:	e1a002a0 	lsr	r0, r0, #5
    3c7c:	e8bd8008 	pop	{r3, pc}
  devfs_entry_t e = entry;
  char * name = va_arg (list, char *);
  
  watch (bool)
  {
    ensure (e != NULL, false);
    3c80:	e1a00001 	mov	r0, r1
    3c84:	e12fff1e 	bx	lr

00003c88 <devfs_inode_id_inspector>:
#include <DnaTools/DnaTools.h>

bool devfs_inode_id_inspector (void * inode, va_list list)
{
  devfs_inode_t i = inode;
  int64_t id = va_arg (list, int64_t);
    3c88:	e2811007 	add	r1, r1, #7
    3c8c:	e3c11007 	bic	r1, r1, #7

  watch (bool)
  {
    ensure (i != NULL, false);
    3c90:	e3500000 	cmp	r0, #0
#include <DnaTools/DnaTools.h>

bool devfs_inode_id_inspector (void * inode, va_list list)
{
  devfs_inode_t i = inode;
  int64_t id = va_arg (list, int64_t);
    3c94:	e1c120d0 	ldrd	r2, [r1]

  watch (bool)
  {
    ensure (i != NULL, false);
    3c98:	012fff1e 	bxeq	lr
    return i -> id == id;
    3c9c:	e1c000d8 	ldrd	r0, [r0, #8]
    3ca0:	e1510003 	cmp	r1, r3
    3ca4:	01500002 	cmpeq	r0, r2
    3ca8:	03a00001 	moveq	r0, #1
    3cac:	13a00000 	movne	r0, #0
  }
}
    3cb0:	e12fff1e 	bx	lr

00003cb4 <devfs_inode_clean>:
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_inode_clean (devfs_t fs, devfs_inode_t inode)
{
    3cb4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    3cb8:	e1a06000 	mov	r6, r0
    3cbc:	e1a05001 	mov	r5, r1
    3cc0:	e2808014 	add	r8, r0, #20

  watch (status_t)
  {
    dna_log(VERBOSE_LEVEL, "Clean inode [%s] forward.", inode -> name);

    entry = queue_lookup (& inode -> entry_list, devfs_entry_unused_inspector);
    3cc4:	e2857f4b 	add	r7, r5, #300	; 0x12c
    3cc8:	e1a00007 	mov	r0, r7
    3ccc:	e59f10dc 	ldr	r1, [pc, #220]	; 3db0 <devfs_inode_clean+0xfc>
    3cd0:	eb001622 	bl	9560 <queue_lookup>
    while (entry != NULL)
    3cd4:	e2503000 	subs	r3, r0, #0
    3cd8:	1a00000f 	bne	3d1c <devfs_inode_clean+0x68>
    3cdc:	ea000016 	b	3d3c <devfs_inode_clean+0x88>

      next_inode = queue_lookup (& fs -> inode_list,
          devfs_inode_id_inspector, entry -> id);
      ensure (next_inode != NULL, DNA_NO_VNODE);

      status = devfs_inode_destroy (fs, next_inode);
    3ce0:	e1a01004 	mov	r1, r4
    3ce4:	e1a00006 	mov	r0, r6
    3ce8:	ebfffd7e 	bl	32e8 <devfs_inode_destroy>
      ensure (status == DNA_OK, status);
    3cec:	e3500000 	cmp	r0, #0

      status = devfs_entry_remove_by_name (inode, next_inode -> name);
    3cf0:	e2841018 	add	r1, r4, #24
      next_inode = queue_lookup (& fs -> inode_list,
          devfs_inode_id_inspector, entry -> id);
      ensure (next_inode != NULL, DNA_NO_VNODE);

      status = devfs_inode_destroy (fs, next_inode);
      ensure (status == DNA_OK, status);
    3cf4:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}

      status = devfs_entry_remove_by_name (inode, next_inode -> name);
    3cf8:	e1a00005 	mov	r0, r5
    3cfc:	eb00007b 	bl	3ef0 <devfs_entry_remove_by_name>
      ensure (status == DNA_OK, status);
    3d00:	e3500000 	cmp	r0, #0

      entry = queue_lookup (& inode -> entry_list,
    3d04:	e59f10a4 	ldr	r1, [pc, #164]	; 3db0 <devfs_inode_clean+0xfc>

      status = devfs_inode_destroy (fs, next_inode);
      ensure (status == DNA_OK, status);

      status = devfs_entry_remove_by_name (inode, next_inode -> name);
      ensure (status == DNA_OK, status);
    3d08:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}

      entry = queue_lookup (& inode -> entry_list,
    3d0c:	e1a00007 	mov	r0, r7
    3d10:	eb001612 	bl	9560 <queue_lookup>
  watch (status_t)
  {
    dna_log(VERBOSE_LEVEL, "Clean inode [%s] forward.", inode -> name);

    entry = queue_lookup (& inode -> entry_list, devfs_entry_unused_inspector);
    while (entry != NULL)
    3d14:	e2503000 	subs	r3, r0, #0
    3d18:	0a000007 	beq	3d3c <devfs_inode_clean+0x88>
    {
      dna_log(VERBOSE_LEVEL, "Unused entry [%s].", entry -> name);

      next_inode = queue_lookup (& fs -> inode_list,
    3d1c:	e1c320d8 	ldrd	r2, [r3, #8]
    3d20:	e1a00008 	mov	r0, r8
    3d24:	e59f1088 	ldr	r1, [pc, #136]	; 3db4 <devfs_inode_clean+0x100>
    3d28:	eb00160c 	bl	9560 <queue_lookup>
          devfs_inode_id_inspector, entry -> id);
      ensure (next_inode != NULL, DNA_NO_VNODE);
    3d2c:	e2504000 	subs	r4, r0, #0
    3d30:	1affffea 	bne	3ce0 <devfs_inode_clean+0x2c>
    3d34:	e59f007c 	ldr	r0, [pc, #124]	; 3db8 <devfs_inode_clean+0x104>
    3d38:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
          devfs_entry_unused_inspector);
    }

    dna_log(VERBOSE_LEVEL, "Clean inode [%s] backward.", inode -> name);

    if (inode -> entry_list . status == 0 && inode -> parent != NULL)
    3d3c:	e5953138 	ldr	r3, [r5, #312]	; 0x138
    3d40:	e3530000 	cmp	r3, #0
    3d44:	1a000015 	bne	3da0 <devfs_inode_clean+0xec>
    3d48:	e5950014 	ldr	r0, [r5, #20]
    3d4c:	e3500000 	cmp	r0, #0
    3d50:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
    {
      entry = queue_lookup (& inode -> parent -> entry_list,
          devfs_entry_name_inspector, inode -> name);
    3d54:	e2854018 	add	r4, r5, #24

    dna_log(VERBOSE_LEVEL, "Clean inode [%s] backward.", inode -> name);

    if (inode -> entry_list . status == 0 && inode -> parent != NULL)
    {
      entry = queue_lookup (& inode -> parent -> entry_list,
    3d58:	e2800f4b 	add	r0, r0, #300	; 0x12c
    3d5c:	e1a02004 	mov	r2, r4
    3d60:	e59f1054 	ldr	r1, [pc, #84]	; 3dbc <devfs_inode_clean+0x108>
    3d64:	eb0015fd 	bl	9560 <queue_lookup>
          devfs_entry_name_inspector, inode -> name);
      ensure (entry != NULL, DNA_NO_ENTRY);
    3d68:	e3500000 	cmp	r0, #0
    3d6c:	0a00000d 	beq	3da8 <devfs_inode_clean+0xf4>

      status = devfs_entry_remove_by_name (inode -> parent, inode -> name);
    3d70:	e1a01004 	mov	r1, r4
    3d74:	e5950014 	ldr	r0, [r5, #20]
    3d78:	eb00005c 	bl	3ef0 <devfs_entry_remove_by_name>
      ensure (status == DNA_OK, status);
    3d7c:	e3500000 	cmp	r0, #0
    3d80:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}

      status = devfs_inode_destroy (fs, inode);
    3d84:	e1a00006 	mov	r0, r6
    3d88:	e1a01005 	mov	r1, r5
    3d8c:	ebfffd55 	bl	32e8 <devfs_inode_destroy>
      ensure (status == DNA_OK, status);
    3d90:	e3500000 	cmp	r0, #0
    3d94:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}

      status = devfs_inode_clean (fs, inode -> parent);
    3d98:	e5955014 	ldr	r5, [r5, #20]
    3d9c:	eaffffc8 	b	3cc4 <devfs_inode_clean+0x10>
      ensure (status == DNA_OK, status);
    }

    return DNA_OK;
    3da0:	e3a00000 	mov	r0, #0
    3da4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

    if (inode -> entry_list . status == 0 && inode -> parent != NULL)
    {
      entry = queue_lookup (& inode -> parent -> entry_list,
          devfs_entry_name_inspector, inode -> name);
      ensure (entry != NULL, DNA_NO_ENTRY);
    3da8:	e59f0010 	ldr	r0, [pc, #16]	; 3dc0 <devfs_inode_clean+0x10c>
      ensure (status == DNA_OK, status);
    }

    return DNA_OK;
  }
}
    3dac:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    3db0:	00002dc0 	.word	0x00002dc0
    3db4:	00003c88 	.word	0x00003c88
    3db8:	0000fefd 	.word	0x0000fefd
    3dbc:	00003c54 	.word	0x00003c54
    3dc0:	0000feff 	.word	0x0000feff

00003dc4 <devfs_entry_remove_by_index>:
  devfs_entry_t entry;
  status_t status;

  watch (status_t)
  {
    ensure (node != NULL, DNA_BAD_ARGUMENT);
    3dc4:	e3500000 	cmp	r0, #0
    3dc8:	0a00000e 	beq	3e08 <devfs_entry_remove_by_index+0x44>
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_entry_remove_by_index (devfs_inode_t node, int32_t index)
{
    3dcc:	e92d4038 	push	{r3, r4, r5, lr}

  watch (status_t)
  {
    ensure (node != NULL, DNA_BAD_ARGUMENT);

    entry = queue_lookup (& node -> entry_list,
    3dd0:	e2804f4b 	add	r4, r0, #300	; 0x12c
    3dd4:	e1a02001 	mov	r2, r1
    3dd8:	e1a00004 	mov	r0, r4
    3ddc:	e59f103c 	ldr	r1, [pc, #60]	; 3e20 <devfs_entry_remove_by_index+0x5c>
    3de0:	eb0015de 	bl	9560 <queue_lookup>
        devfs_entry_index_inspector, index);
    ensure (entry != NULL, DNA_NO_ENTRY);
    3de4:	e2505000 	subs	r5, r0, #0
    3de8:	0a000004 	beq	3e00 <devfs_entry_remove_by_index+0x3c>

    status = queue_extract (& node -> entry_list, entry);
    3dec:	e1a00004 	mov	r0, r4
    3df0:	e1a01005 	mov	r1, r5
    3df4:	eb001299 	bl	8860 <queue_extract>
    ensure (status == DNA_OK, DNA_NO_ENTRY);
    3df8:	e2504000 	subs	r4, r0, #0
    3dfc:	0a000003 	beq	3e10 <devfs_entry_remove_by_index+0x4c>
  {
    ensure (node != NULL, DNA_BAD_ARGUMENT);

    entry = queue_lookup (& node -> entry_list,
        devfs_entry_index_inspector, index);
    ensure (entry != NULL, DNA_NO_ENTRY);
    3e00:	e59f001c 	ldr	r0, [pc, #28]	; 3e24 <devfs_entry_remove_by_index+0x60>
    3e04:	e8bd8038 	pop	{r3, r4, r5, pc}
  devfs_entry_t entry;
  status_t status;

  watch (status_t)
  {
    ensure (node != NULL, DNA_BAD_ARGUMENT);
    3e08:	e59f0018 	ldr	r0, [pc, #24]	; 3e28 <devfs_entry_remove_by_index+0x64>
    3e0c:	e12fff1e 	bx	lr
    ensure (entry != NULL, DNA_NO_ENTRY);

    status = queue_extract (& node -> entry_list, entry);
    ensure (status == DNA_OK, DNA_NO_ENTRY);
 
    kernel_free (entry);
    3e10:	e1a00005 	mov	r0, r5
    3e14:	eb00266b 	bl	d7c8 <kernel_free>
    return DNA_OK;
    3e18:	e1a00004 	mov	r0, r4
    3e1c:	e8bd8038 	pop	{r3, r4, r5, pc}
    3e20:	00003e30 	.word	0x00003e30
    3e24:	0000feff 	.word	0x0000feff
    3e28:	0000fffc 	.word	0x0000fffc

00003e2c <devfs_write_vnode>:

  watch (status_t)
  {
    dna_log(VERBOSE_LEVEL, "Write inode [%s].", inode -> name);

    status = devfs_inode_clean (devfs, inode);
    3e2c:	eaffffa0 	b	3cb4 <devfs_inode_clean>

00003e30 <devfs_entry_index_inspector>:
  devfs_entry_t e = entry;
  int64_t * index = va_arg (list, int64_t *);

  watch (bool)
  {
    ensure (e != NULL, false);
    3e30:	e3500000 	cmp	r0, #0
#include <DnaTools/DnaTools.h>

bool devfs_entry_index_inspector (void * entry, va_list list)
{
  devfs_entry_t e = entry;
  int64_t * index = va_arg (list, int64_t *);
    3e34:	e5911000 	ldr	r1, [r1]

  watch (bool)
  {
    ensure (e != NULL, false);
    3e38:	012fff1e 	bxeq	lr
    ensure (index != NULL, false);
    3e3c:	e3510000 	cmp	r1, #0
    3e40:	0a000009 	beq	3e6c <devfs_entry_index_inspector+0x3c>

    if (*index == 0) return true;
    3e44:	e1c120d0 	ldrd	r2, [r1]
    3e48:	e1920003 	orrs	r0, r2, r3
    3e4c:	0a000004 	beq	3e64 <devfs_entry_index_inspector+0x34>

    *index = *index - 1;
    3e50:	e2522001 	subs	r2, r2, #1
    3e54:	e2c33000 	sbc	r3, r3, #0
    return false;
    3e58:	e3a00000 	mov	r0, #0
    ensure (e != NULL, false);
    ensure (index != NULL, false);

    if (*index == 0) return true;

    *index = *index - 1;
    3e5c:	e1c120f0 	strd	r2, [r1]
    return false;
    3e60:	e12fff1e 	bx	lr
  watch (bool)
  {
    ensure (e != NULL, false);
    ensure (index != NULL, false);

    if (*index == 0) return true;
    3e64:	e3a00001 	mov	r0, #1

    *index = *index - 1;
    return false;
  }
}
    3e68:	e12fff1e 	bx	lr
  devfs_entry_t e = entry;
  int64_t * index = va_arg (list, int64_t *);

  watch (bool)
  {
    ensure (e != NULL, false);
    3e6c:	e1a00001 	mov	r0, r1
    3e70:	e12fff1e 	bx	lr

00003e74 <devfs_mkdir>:
  /*
   * Oops! We don't authorize mkdir on this FS !
   */

  return DNA_ERROR;
}
    3e74:	e59f0000 	ldr	r0, [pc]	; 3e7c <devfs_mkdir+0x8>
    3e78:	e12fff1e 	bx	lr
    3e7c:	0000ffff 	.word	0x0000ffff

00003e80 <devfs_entry_add>:
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_entry_add (devfs_inode_t inode, char * name, int64_t vnid)
{
    3e80:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  devfs_entry_t entry;

  watch (status_t)
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    3e84:	e2507000 	subs	r7, r0, #0
    3e88:	0a000012 	beq	3ed8 <devfs_entry_add+0x58>
    ensure (name != NULL, DNA_BAD_ARGUMENT);
    3e8c:	e3510000 	cmp	r1, #0
    3e90:	e1a06001 	mov	r6, r1
    3e94:	0a00000f 	beq	3ed8 <devfs_entry_add+0x58>

    entry = kernel_malloc (sizeof (struct devfs_entry), true);
    3e98:	e3a00f46 	mov	r0, #280	; 0x118
    3e9c:	e3a01001 	mov	r1, #1
    3ea0:	e1a04002 	mov	r4, r2
    3ea4:	e1a05003 	mov	r5, r3
    3ea8:	eb002611 	bl	d6f4 <kernel_malloc>
    ensure (entry != NULL, DNA_OUT_OF_MEM);
    3eac:	e2508000 	subs	r8, r0, #0
    3eb0:	0a00000a 	beq	3ee0 <devfs_entry_add+0x60>

    entry -> id = vnid;
    dna_strcpy (entry -> name, name);
    3eb4:	e1a01006 	mov	r1, r6
    ensure (name != NULL, DNA_BAD_ARGUMENT);

    entry = kernel_malloc (sizeof (struct devfs_entry), true);
    ensure (entry != NULL, DNA_OUT_OF_MEM);

    entry -> id = vnid;
    3eb8:	e1c840f8 	strd	r4, [r8, #8]
    dna_strcpy (entry -> name, name);
    3ebc:	e2880011 	add	r0, r8, #17
    3ec0:	eb001608 	bl	96e8 <dna_strcpy>
    queue_add (& inode -> entry_list, entry);
    3ec4:	e2870f4b 	add	r0, r7, #300	; 0x12c
    3ec8:	e1a01008 	mov	r1, r8
    3ecc:	eb00156c 	bl	9484 <queue_add>

    return DNA_OK;
    3ed0:	e3a00000 	mov	r0, #0
    3ed4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
{
  devfs_entry_t entry;

  watch (status_t)
  {
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    3ed8:	e59f0008 	ldr	r0, [pc, #8]	; 3ee8 <devfs_entry_add+0x68>
    3edc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    ensure (name != NULL, DNA_BAD_ARGUMENT);

    entry = kernel_malloc (sizeof (struct devfs_entry), true);
    ensure (entry != NULL, DNA_OUT_OF_MEM);
    3ee0:	e59f0004 	ldr	r0, [pc, #4]	; 3eec <devfs_entry_add+0x6c>
    dna_strcpy (entry -> name, name);
    queue_add (& inode -> entry_list, entry);

    return DNA_OK;
  }
}
    3ee4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    3ee8:	0000fffc 	.word	0x0000fffc
    3eec:	0000fffd 	.word	0x0000fffd

00003ef0 <devfs_entry_remove_by_name>:
  devfs_entry_t entry;
  status_t status;

  watch (status_t)
  {
    ensure (node != NULL, DNA_BAD_ARGUMENT);
    3ef0:	e3500000 	cmp	r0, #0
    3ef4:	0a000010 	beq	3f3c <devfs_entry_remove_by_name+0x4c>
    ensure (name != NULL, DNA_BAD_ARGUMENT);
    3ef8:	e3510000 	cmp	r1, #0
    3efc:	0a00000e 	beq	3f3c <devfs_entry_remove_by_name+0x4c>
#include <Private/DeviceFileSystem.h>
#include <DnaTools/DnaTools.h>
#include <MemoryManager/MemoryManager.h>

status_t devfs_entry_remove_by_name (devfs_inode_t node, char * name)
{
    3f00:	e92d4038 	push	{r3, r4, r5, lr}
  watch (status_t)
  {
    ensure (node != NULL, DNA_BAD_ARGUMENT);
    ensure (name != NULL, DNA_BAD_ARGUMENT);

    entry = queue_lookup (& node -> entry_list,
    3f04:	e2804f4b 	add	r4, r0, #300	; 0x12c
    3f08:	e1a02001 	mov	r2, r1
    3f0c:	e1a00004 	mov	r0, r4
    3f10:	e59f103c 	ldr	r1, [pc, #60]	; 3f54 <devfs_entry_remove_by_name+0x64>
    3f14:	eb001591 	bl	9560 <queue_lookup>
        devfs_entry_name_inspector, name);
    ensure (entry != NULL, DNA_NO_ENTRY);
    3f18:	e2505000 	subs	r5, r0, #0
    3f1c:	0a000004 	beq	3f34 <devfs_entry_remove_by_name+0x44>

    status = queue_extract (& node -> entry_list, entry);
    3f20:	e1a00004 	mov	r0, r4
    3f24:	e1a01005 	mov	r1, r5
    3f28:	eb00124c 	bl	8860 <queue_extract>
    ensure (status == DNA_OK, DNA_NO_ENTRY);
    3f2c:	e2504000 	subs	r4, r0, #0
    3f30:	0a000003 	beq	3f44 <devfs_entry_remove_by_name+0x54>
    ensure (node != NULL, DNA_BAD_ARGUMENT);
    ensure (name != NULL, DNA_BAD_ARGUMENT);

    entry = queue_lookup (& node -> entry_list,
        devfs_entry_name_inspector, name);
    ensure (entry != NULL, DNA_NO_ENTRY);
    3f34:	e59f001c 	ldr	r0, [pc, #28]	; 3f58 <devfs_entry_remove_by_name+0x68>
    3f38:	e8bd8038 	pop	{r3, r4, r5, pc}
  devfs_entry_t entry;
  status_t status;

  watch (status_t)
  {
    ensure (node != NULL, DNA_BAD_ARGUMENT);
    3f3c:	e59f0018 	ldr	r0, [pc, #24]	; 3f5c <devfs_entry_remove_by_name+0x6c>
    3f40:	e12fff1e 	bx	lr
    ensure (entry != NULL, DNA_NO_ENTRY);

    status = queue_extract (& node -> entry_list, entry);
    ensure (status == DNA_OK, DNA_NO_ENTRY);
 
    kernel_free (entry);
    3f44:	e1a00005 	mov	r0, r5
    3f48:	eb00261e 	bl	d7c8 <kernel_free>
    return DNA_OK;
    3f4c:	e1a00004 	mov	r0, r4
    3f50:	e8bd8038 	pop	{r3, r4, r5, pc}
    3f54:	00003c54 	.word	0x00003c54
    3f58:	0000feff 	.word	0x0000feff
    3f5c:	0000fffc 	.word	0x0000fffc

00003f60 <rootfs_read_vnode>:

#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_read_vnode (void * ns, int64_t vnid, void ** data)
{
    3f60:	e92d4010 	push	{r4, lr}
  rootfs_t rootfs = ns;
  rootfs_inode_t inode = NULL;

  inode = queue_lookup (& rootfs -> inode_list, rootfs_inode_inspector, vnid);
    3f64:	e59f1014 	ldr	r1, [pc, #20]	; 3f80 <rootfs_read_vnode+0x20>
    3f68:	e2800014 	add	r0, r0, #20

#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_read_vnode (void * ns, int64_t vnid, void ** data)
{
    3f6c:	e59d4008 	ldr	r4, [sp, #8]
  rootfs_t rootfs = ns;
  rootfs_inode_t inode = NULL;

  inode = queue_lookup (& rootfs -> inode_list, rootfs_inode_inspector, vnid);
    3f70:	eb00157a 	bl	9560 <queue_lookup>

  dna_log(VERBOSE_LEVEL, "NS = 0x%x, VNID = %lld, DATA = 0x%x",
      ns, vnid, inode);

  *data = inode;
    3f74:	e5840000 	str	r0, [r4]
  return DNA_OK;
}
    3f78:	e3a00000 	mov	r0, #0
    3f7c:	e8bd8010 	pop	{r4, pc}
    3f80:	00004358 	.word	0x00004358

00003f84 <rootfs_readdir>:
#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_readdir (void * ns, void * node, void * data,
    void * entry_array, int64_t * offset, int32_t * p_count)
{
    3f84:	e92d43b0 	push	{r4, r5, r7, r8, r9, lr}
  int64_t pos = 0;
  directory_entry_t * p_entry = entry_array;

  watch (status_t)
  {
    ensure (ns != NULL && node != NULL && entry_array
    3f88:	e3510000 	cmp	r1, #0
    3f8c:	13500000 	cmpne	r0, #0
    void * entry_array, int64_t * offset, int32_t * p_count)
{
  rootfs_t rootfs = ns;
  rootfs_inode_t inode = node;
  rootfs_entry_t entry = NULL;
  int64_t pos = 0;
    3f90:	e3a04000 	mov	r4, #0
    3f94:	e3a05000 	mov	r5, #0
#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_readdir (void * ns, void * node, void * data,
    void * entry_array, int64_t * offset, int32_t * p_count)
{
    3f98:	e24dd010 	sub	sp, sp, #16
  int64_t pos = 0;
  directory_entry_t * p_entry = entry_array;

  watch (status_t)
  {
    ensure (ns != NULL && node != NULL && entry_array
    3f9c:	e1a08000 	mov	r8, r0
    void * entry_array, int64_t * offset, int32_t * p_count)
{
  rootfs_t rootfs = ns;
  rootfs_inode_t inode = node;
  rootfs_entry_t entry = NULL;
  int64_t pos = 0;
    3fa0:	e1cd40f8 	strd	r4, [sp, #8]
  directory_entry_t * p_entry = entry_array;

  watch (status_t)
  {
    ensure (ns != NULL && node != NULL && entry_array
    3fa4:	1a000002 	bne	3fb4 <rootfs_readdir+0x30>
    3fa8:	e59f00d0 	ldr	r0, [pc, #208]	; 4080 <rootfs_readdir+0xfc>
      }
    }

    return DNA_OK;
  }
}
    3fac:	e28dd010 	add	sp, sp, #16
    3fb0:	e8bd83b0 	pop	{r4, r5, r7, r8, r9, pc}
  int64_t pos = 0;
  directory_entry_t * p_entry = entry_array;

  watch (status_t)
  {
    ensure (ns != NULL && node != NULL && entry_array
    3fb4:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    3fb8:	e3500000 	cmp	r0, #0
    3fbc:	13530000 	cmpne	r3, #0
    3fc0:	03a07001 	moveq	r7, #1
    3fc4:	13a07000 	movne	r7, #0
    3fc8:	0afffff6 	beq	3fa8 <rootfs_readdir+0x24>
        && p_count != NULL, DNA_ERROR);
    ensure (inode -> class == DNA_ROOTFS_DIRECTORY, DNA_BAD_INODE_TYPE);
    3fcc:	e5d12110 	ldrb	r2, [r1, #272]	; 0x110
    3fd0:	e3520001 	cmp	r2, #1
    3fd4:	159f00a8 	ldrne	r0, [pc, #168]	; 4084 <rootfs_readdir+0x100>
    3fd8:	1afffff3 	bne	3fac <rootfs_readdir+0x28>

    if (inode -> entry_list . status == 0)
    3fdc:	e5910134 	ldr	r0, [r1, #308]	; 0x134
    3fe0:	e3500000 	cmp	r0, #0
    3fe4:	1a000002 	bne	3ff4 <rootfs_readdir+0x70>
      entry = queue_lookup (& inode -> entry_list,
          rootfs_entry_index_inspector, & pos);

      if (entry == NULL)
      {
        *p_count = 0;
    3fe8:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    3fec:	e5820000 	str	r0, [r2]
    3ff0:	eaffffed 	b	3fac <rootfs_readdir+0x28>
    {
      *p_count = 0;
    }
    else
    {
      pos = *offset;
    3ff4:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    3ff8:	e28d2010 	add	r2, sp, #16
    3ffc:	e1c040d0 	ldrd	r4, [r0]
      entry = queue_lookup (& inode -> entry_list,
    4000:	e2810f4a 	add	r0, r1, #296	; 0x128
    {
      *p_count = 0;
    }
    else
    {
      pos = *offset;
    4004:	e16240f8 	strd	r4, [r2, #-8]!
      entry = queue_lookup (& inode -> entry_list,
    4008:	e59f1078 	ldr	r1, [pc, #120]	; 4088 <rootfs_readdir+0x104>
    400c:	e58d3004 	str	r3, [sp, #4]
    4010:	eb001552 	bl	9560 <queue_lookup>
          rootfs_entry_index_inspector, & pos);

      if (entry == NULL)
    4014:	e3500000 	cmp	r0, #0
    4018:	e59d3004 	ldr	r3, [sp, #4]
    401c:	0afffff1 	beq	3fe8 <rootfs_readdir+0x64>
        *p_count = 0;
      }
      else
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = rootfs -> vid;
    4020:	e5982010 	ldr	r2, [r8, #16]
        dna_strcpy (p_entry -> d_name, entry -> name);
    4024:	e2804010 	add	r4, r0, #16
      {
        *p_count = 0;
      }
      else
      {
        p_entry -> vnid = entry -> id;
    4028:	e1c080d8 	ldrd	r8, [r0, #8]
        p_entry -> vid = rootfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);
    402c:	e1a01004 	mov	r1, r4
        *p_count = 0;
      }
      else
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = rootfs -> vid;
    4030:	e5832008 	str	r2, [r3, #8]
      {
        *p_count = 0;
      }
      else
      {
        p_entry -> vnid = entry -> id;
    4034:	e1c380f0 	strd	r8, [r3]
        p_entry -> vid = rootfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);
    4038:	e283000e 	add	r0, r3, #14
    403c:	e58d3004 	str	r3, [sp, #4]
    4040:	eb0015a8 	bl	96e8 <dna_strcpy>

        p_entry -> d_reclen = sizeof (struct _directory_entry)
          + dna_strlen (entry -> name);
    4044:	e1a00004 	mov	r0, r4
    4048:	eb001571 	bl	9614 <dna_strlen>
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = rootfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
    404c:	e59d3004 	ldr	r3, [sp, #4]
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
        *offset += 1;
    4050:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = rootfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
    4054:	e2800010 	add	r0, r0, #16
    4058:	e6ff1070 	uxth	r1, r0
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
        *offset += 1;
    405c:	e1c240d0 	ldrd	r4, [r2]
      {
        p_entry -> vnid = entry -> id;
        p_entry -> vid = rootfs -> vid;
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
    4060:	e1c310bc 	strh	r1, [r3, #12]
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
        *offset += 1;
    4064:	e2944001 	adds	r4, r4, #1
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
    4068:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
        *offset += 1;
    406c:	e2a55000 	adc	r5, r5, #0
        dna_strcpy (p_entry -> d_name, entry -> name);

        p_entry -> d_reclen = sizeof (struct _directory_entry)
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
    4070:	e5831000 	str	r1, [r3]
        *offset += 1;
      }
    }

    return DNA_OK;
    4074:	e1a00007 	mov	r0, r7

        p_entry -> d_reclen = sizeof (struct _directory_entry)
          + dna_strlen (entry -> name);

        *p_count = p_entry -> d_reclen;
        *offset += 1;
    4078:	e1c240f0 	strd	r4, [r2]
    407c:	eaffffca 	b	3fac <rootfs_readdir+0x28>
    4080:	0000ffff 	.word	0x0000ffff
    4084:	0000fef7 	.word	0x0000fef7
    4088:	000041d8 	.word	0x000041d8

0000408c <rootfs_ioctl>:
status_t rootfs_ioctl (void * ns, void * node, void * data,
    int32_t function, va_list arguments, int32_t * p_ret)
{

  return DNA_ERROR;
}
    408c:	e59f0000 	ldr	r0, [pc]	; 4094 <rootfs_ioctl+0x8>
    4090:	e12fff1e 	bx	lr
    4094:	0000ffff 	.word	0x0000ffff

00004098 <rootfs_mount>:
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_mount (int32_t vid, const char * dev_path, uint32_t flags,
    void * params, void ** data, int64_t * vnid)
{
    4098:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  rootfs_t rootfs = NULL;
  rootfs_inode_t root_inode = NULL;
  rootfs_entry_t entry = NULL;
  char * entry_name[] = { ".", "..", "devices", "volumes", "system" };
    409c:	e59fe128 	ldr	lr, [pc, #296]	; 41cc <rootfs_mount+0x134>
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_mount (int32_t vid, const char * dev_path, uint32_t flags,
    void * params, void ** data, int64_t * vnid)
{
    40a0:	e24dd01c 	sub	sp, sp, #28
  rootfs_t rootfs = NULL;
  rootfs_inode_t root_inode = NULL;
  rootfs_entry_t entry = NULL;
  char * entry_name[] = { ".", "..", "devices", "volumes", "system" };
    40a4:	e28dc004 	add	ip, sp, #4
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_mount (int32_t vid, const char * dev_path, uint32_t flags,
    void * params, void ** data, int64_t * vnid)
{
    40a8:	e1a07000 	mov	r7, r0
  rootfs_t rootfs = NULL;
  rootfs_inode_t root_inode = NULL;
  rootfs_entry_t entry = NULL;
  char * entry_name[] = { ".", "..", "devices", "volumes", "system" };
    40ac:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    40b0:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    40b4:	e59e3000 	ldr	r3, [lr]

   rootfs = kernel_malloc (sizeof (struct rootfs), true);
    40b8:	e3a00028 	mov	r0, #40	; 0x28
    40bc:	e3a01001 	mov	r1, #1
    void * params, void ** data, int64_t * vnid)
{
  rootfs_t rootfs = NULL;
  rootfs_inode_t root_inode = NULL;
  rootfs_entry_t entry = NULL;
  char * entry_name[] = { ".", "..", "devices", "volumes", "system" };
    40c0:	e58c3000 	str	r3, [ip]
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_mount (int32_t vid, const char * dev_path, uint32_t flags,
    void * params, void ** data, int64_t * vnid)
{
    40c4:	e59d8040 	ldr	r8, [sp, #64]	; 0x40
    40c8:	e59d9044 	ldr	r9, [sp, #68]	; 0x44
  rootfs_t rootfs = NULL;
  rootfs_inode_t root_inode = NULL;
  rootfs_entry_t entry = NULL;
  char * entry_name[] = { ".", "..", "devices", "volumes", "system" };

   rootfs = kernel_malloc (sizeof (struct rootfs), true);
    40cc:	eb002588 	bl	d6f4 <kernel_malloc>
  if (rootfs == NULL) return DNA_OUT_OF_MEM;
    40d0:	e2506000 	subs	r6, r0, #0
    40d4:	0a000039 	beq	41c0 <rootfs_mount+0x128>

   root_inode = kernel_malloc (sizeof (struct rootfs_inode), true);
    40d8:	e3a00f4e 	mov	r0, #312	; 0x138
    40dc:	e3a01001 	mov	r1, #1
    40e0:	eb002583 	bl	d6f4 <kernel_malloc>
  if (root_inode == NULL) return DNA_OUT_OF_MEM;
    40e4:	e250a000 	subs	sl, r0, #0
    40e8:	0a000034 	beq	41c0 <rootfs_mount+0x128>

  rootfs -> inode_index = 1;
  rootfs -> vid = vid;

  root_inode -> id = rootfs -> inode_index ++;
    40ec:	e3a02001 	mov	r2, #1
    40f0:	e3a03000 	mov	r3, #0
    40f4:	e3a04002 	mov	r4, #2
    40f8:	e3a05000 	mov	r5, #0
    40fc:	e1a0b006 	mov	fp, r6

   root_inode = kernel_malloc (sizeof (struct rootfs_inode), true);
  if (root_inode == NULL) return DNA_OUT_OF_MEM;

  rootfs -> inode_index = 1;
  rootfs -> vid = vid;
    4100:	e5867010 	str	r7, [r6, #16]

  root_inode -> id = rootfs -> inode_index ++;
  dna_strcpy (root_inode -> name, "");
    4104:	e59f10c4 	ldr	r1, [pc, #196]	; 41d0 <rootfs_mount+0x138>
  if (root_inode == NULL) return DNA_OUT_OF_MEM;

  rootfs -> inode_index = 1;
  rootfs -> vid = vid;

  root_inode -> id = rootfs -> inode_index ++;
    4108:	e0cb41f4 	strd	r4, [fp], #20
  dna_strcpy (root_inode -> name, "");
    410c:	e28a0010 	add	r0, sl, #16
  if (root_inode == NULL) return DNA_OUT_OF_MEM;

  rootfs -> inode_index = 1;
  rootfs -> vid = vid;

  root_inode -> id = rootfs -> inode_index ++;
    4110:	e1ca20f8 	strd	r2, [sl, #8]
  dna_strcpy (root_inode -> name, "");
    4114:	eb001573 	bl	96e8 <dna_strcpy>
  root_inode -> class = DNA_ROOTFS_DIRECTORY;
    4118:	e3a03001 	mov	r3, #1
    411c:	e1a0400d 	mov	r4, sp
    4120:	e5ca3110 	strb	r3, [sl, #272]	; 0x110
  queue_add (& rootfs -> inode_list, root_inode);
    4124:	e1a0000b 	mov	r0, fp
    4128:	e1a0100a 	mov	r1, sl
    412c:	eb0014d4 	bl	9484 <queue_add>

  rootfs -> root_vnid = root_inode -> id;
    4130:	e1ca20d8 	ldrd	r2, [sl, #8]
    4134:	e1c620f8 	strd	r2, [r6, #8]
    4138:	e28d7008 	add	r7, sp, #8
    entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    if (entry == NULL) return DNA_OUT_OF_MEM;

    entry -> id = root_inode -> id;
    dna_strcpy (entry -> name, entry_name[i]);
    queue_add (& root_inode -> entry_list, entry);
    413c:	e28a5f4a 	add	r5, sl, #296	; 0x128
   * Add the "." and ".." entry
   */

  for (int32_t i = 0; i < 2; i ++)
  {
    entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    4140:	e3a00e11 	mov	r0, #272	; 0x110
    4144:	e3a01001 	mov	r1, #1
    4148:	eb002569 	bl	d6f4 <kernel_malloc>
    if (entry == NULL) return DNA_OUT_OF_MEM;
    414c:	e250b000 	subs	fp, r0, #0

    entry -> id = root_inode -> id;
    dna_strcpy (entry -> name, entry_name[i]);
    4150:	e28b0010 	add	r0, fp, #16
   */

  for (int32_t i = 0; i < 2; i ++)
  {
    entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    if (entry == NULL) return DNA_OUT_OF_MEM;
    4154:	0a000019 	beq	41c0 <rootfs_mount+0x128>

    entry -> id = root_inode -> id;
    4158:	e1ca20d8 	ldrd	r2, [sl, #8]
    dna_strcpy (entry -> name, entry_name[i]);
    415c:	e5b41004 	ldr	r1, [r4, #4]!
  for (int32_t i = 0; i < 2; i ++)
  {
    entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    if (entry == NULL) return DNA_OUT_OF_MEM;

    entry -> id = root_inode -> id;
    4160:	e1cb20f8 	strd	r2, [fp, #8]
    dna_strcpy (entry -> name, entry_name[i]);
    4164:	eb00155f 	bl	96e8 <dna_strcpy>
    queue_add (& root_inode -> entry_list, entry);
    4168:	e1a00005 	mov	r0, r5
    416c:	e1a0100b 	mov	r1, fp
    4170:	eb0014c3 	bl	9484 <queue_add>

  /*
   * Add the "." and ".." entry
   */

  for (int32_t i = 0; i < 2; i ++)
    4174:	e1540007 	cmp	r4, r7
    4178:	1afffff0 	bne	4140 <rootfs_mount+0xa8>
    417c:	e28d5014 	add	r5, sp, #20
   * Create the standard directories
   */

  for (int32_t i = 2; i < 5; i++)
  {
    rootfs_mkdir (rootfs, root_inode, entry_name[i], 0);
    4180:	e5b42004 	ldr	r2, [r4, #4]!
    4184:	e1a00006 	mov	r0, r6
    4188:	e1a0100a 	mov	r1, sl
    418c:	e3a03000 	mov	r3, #0
    4190:	eb0000d7 	bl	44f4 <rootfs_mkdir>

  /*
   * Create the standard directories
   */

  for (int32_t i = 2; i < 5; i++)
    4194:	e1540005 	cmp	r4, r5
    4198:	1afffff8 	bne	4180 <rootfs_mount+0xe8>
  /*
   * Add the root vnode to the system
   */

  *data = rootfs;
  *vnid = root_inode -> id;
    419c:	e1ca20d8 	ldrd	r2, [sl, #8]

  /*
   * Add the root vnode to the system
   */

  *data = rootfs;
    41a0:	e5886000 	str	r6, [r8]
  *vnid = root_inode -> id;
    41a4:	e1c920f0 	strd	r2, [r9]

  dna_log(VERBOSE_LEVEL, "VNODE CREATE ID 0x%x, VID 0x%x",
      root_inode -> id, rootfs -> vid);

  return vnode_create (root_inode -> id, rootfs -> vid, (void *) root_inode);
    41a8:	e1a0300a 	mov	r3, sl
    41ac:	e1ca00d8 	ldrd	r0, [sl, #8]
    41b0:	e5962010 	ldr	r2, [r6, #16]
}
    41b4:	e28dd01c 	add	sp, sp, #28
    41b8:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  *vnid = root_inode -> id;

  dna_log(VERBOSE_LEVEL, "VNODE CREATE ID 0x%x, VID 0x%x",
      root_inode -> id, rootfs -> vid);

  return vnode_create (root_inode -> id, rootfs -> vid, (void *) root_inode);
    41bc:	ea000b5e 	b	6f3c <vnode_create>
}
    41c0:	e59f000c 	ldr	r0, [pc, #12]	; 41d4 <rootfs_mount+0x13c>
    41c4:	e28dd01c 	add	sp, sp, #28
    41c8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    41cc:	00023b7c 	.word	0x00023b7c
    41d0:	00023d94 	.word	0x00023d94
    41d4:	0000fffd 	.word	0x0000fffd

000041d8 <rootfs_entry_index_inspector>:
  rootfs_entry_t e = entry;
  int64_t * index = va_arg (list, int64_t *);

  watch (bool)
  {
    ensure (e != NULL, false);
    41d8:	e3500000 	cmp	r0, #0
#include <DnaTools/DnaTools.h>

bool rootfs_entry_index_inspector (void * entry, va_list list)
{
  rootfs_entry_t e = entry;
  int64_t * index = va_arg (list, int64_t *);
    41dc:	e5911000 	ldr	r1, [r1]

  watch (bool)
  {
    ensure (e != NULL, false);
    41e0:	012fff1e 	bxeq	lr
    ensure (index != NULL, false);
    41e4:	e3510000 	cmp	r1, #0
    41e8:	0a000009 	beq	4214 <rootfs_entry_index_inspector+0x3c>

    if (*index == 0) return true;
    41ec:	e1c120d0 	ldrd	r2, [r1]
    41f0:	e1920003 	orrs	r0, r2, r3
    41f4:	0a000004 	beq	420c <rootfs_entry_index_inspector+0x34>
    
    *index = * index - 1;
    41f8:	e2522001 	subs	r2, r2, #1
    41fc:	e2c33000 	sbc	r3, r3, #0
    return false;
    4200:	e3a00000 	mov	r0, #0
    ensure (e != NULL, false);
    ensure (index != NULL, false);

    if (*index == 0) return true;
    
    *index = * index - 1;
    4204:	e1c120f0 	strd	r2, [r1]
    return false;
    4208:	e12fff1e 	bx	lr
  watch (bool)
  {
    ensure (e != NULL, false);
    ensure (index != NULL, false);

    if (*index == 0) return true;
    420c:	e3a00001 	mov	r0, #1
    
    *index = * index - 1;
    return false;
  }
}
    4210:	e12fff1e 	bx	lr
  rootfs_entry_t e = entry;
  int64_t * index = va_arg (list, int64_t *);

  watch (bool)
  {
    ensure (e != NULL, false);
    4214:	e1a00001 	mov	r0, r1
    4218:	e12fff1e 	bx	lr

0000421c <rootfs_write>:
status_t rootfs_write (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
  status_t status = DNA_OK;

  * p_count = 0;
    421c:	e3a03000 	mov	r3, #0
#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_write (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
    4220:	e59d2008 	ldr	r2, [sp, #8]
  status_t status = DNA_OK;

  * p_count = 0;
  return status;
}
    4224:	e1a00003 	mov	r0, r3
status_t rootfs_write (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
  status_t status = DNA_OK;

  * p_count = 0;
    4228:	e5823000 	str	r3, [r2]
  return status;
}
    422c:	e12fff1e 	bx	lr

00004230 <rootfs_get_info>:
#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_get_info (void * ns, void * node,
    void * data, file_info_t * p_info)
{
    4230:	e92d4070 	push	{r4, r5, r6, lr}
  rootfs_t rootfs = ns;
  rootfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (rootfs != NULL, DNA_BAD_ARGUMENT);
    4234:	e2506000 	subs	r6, r0, #0
    4238:	0a000015 	beq	4294 <rootfs_get_info+0x64>
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    423c:	e3510000 	cmp	r1, #0
    4240:	e1a05001 	mov	r5, r1
    4244:	0a000012 	beq	4294 <rootfs_get_info+0x64>
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);
    4248:	e3530000 	cmp	r3, #0
    424c:	e1a04003 	mov	r4, r3
    4250:	0a00000f 	beq	4294 <rootfs_get_info+0x64>

    dna_memset (p_info, 0, sizeof (file_info_t));
    4254:	e1a00003 	mov	r0, r3
    4258:	e3a01000 	mov	r1, #0
    425c:	e3a02040 	mov	r2, #64	; 0x40
    4260:	eb00121f 	bl	8ae4 <dna_memset>

    p_info -> volume = rootfs -> vid;
    p_info -> vnode = inode -> id;
    4264:	e1c520d8 	ldrd	r2, [r5, #8]

    switch (inode -> class)
    4268:	e5d51110 	ldrb	r1, [r5, #272]	; 0x110
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);

    dna_memset (p_info, 0, sizeof (file_info_t));

    p_info -> volume = rootfs -> vid;
    426c:	e5960010 	ldr	r0, [r6, #16]
    p_info -> vnode = inode -> id;

    switch (inode -> class)
    4270:	e3510001 	cmp	r1, #1
    ensure (inode != NULL, DNA_BAD_ARGUMENT);
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);

    dna_memset (p_info, 0, sizeof (file_info_t));

    p_info -> volume = rootfs -> vid;
    4274:	e5840000 	str	r0, [r4]
    p_info -> vnode = inode -> id;
    4278:	e1c420f8 	strd	r2, [r4, #8]

    switch (inode -> class)
    427c:	0a000009 	beq	42a8 <rootfs_get_info+0x78>
    4280:	3a000005 	bcc	429c <rootfs_get_info+0x6c>
    4284:	e3510002 	cmp	r1, #2
    4288:	0a000006 	beq	42a8 <rootfs_get_info+0x78>
          p_info -> type = DNA_FILE_SYMBOLIC_LINK;
          break;
        }
    }

    return DNA_OK;
    428c:	e3a00000 	mov	r0, #0
  }
}
    4290:	e8bd8070 	pop	{r4, r5, r6, pc}
  rootfs_t rootfs = ns;
  rootfs_inode_t inode = node;

  watch (status_t)
  {
    ensure (rootfs != NULL, DNA_BAD_ARGUMENT);
    4294:	e59f0018 	ldr	r0, [pc, #24]	; 42b4 <rootfs_get_info+0x84>
    4298:	e8bd8070 	pop	{r4, r5, r6, pc}

    switch (inode -> class)
    {
      case DNA_ROOTFS_FILE :
        {
          p_info -> type = DNA_FILE_REGULAR;
    429c:	e3a00000 	mov	r0, #0
    42a0:	e5c40010 	strb	r0, [r4, #16]
          break;
    42a4:	e8bd8070 	pop	{r4, r5, r6, pc}
          break;
        }

      case DNA_ROOTFS_SYMLINK :
        {
          p_info -> type = DNA_FILE_SYMBOLIC_LINK;
    42a8:	e5c41010 	strb	r1, [r4, #16]
          break;
        }
    }

    return DNA_OK;
    42ac:	e3a00000 	mov	r0, #0
        }

      case DNA_ROOTFS_SYMLINK :
        {
          p_info -> type = DNA_FILE_SYMBOLIC_LINK;
          break;
    42b0:	e8bd8070 	pop	{r4, r5, r6, pc}
    42b4:	0000fffc 	.word	0x0000fffc

000042b8 <rootfs_walk>:
  rootfs_entry_t entry = NULL;
  int64_t vnid = -1;

  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    42b8:	e3510000 	cmp	r1, #0
    42bc:	13500000 	cmpne	r0, #0
#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_walk (void * ns, void * base, char * restrict path,
    char ** new_path, int64_t * p_vnid)
{
    42c0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  rootfs_entry_t entry = NULL;
  int64_t vnid = -1;

  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    42c4:	059f007c 	ldreq	r0, [pc, #124]	; 4348 <rootfs_walk+0x90>
#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_walk (void * ns, void * base, char * restrict path,
    char ** new_path, int64_t * p_vnid)
{
    42c8:	e24dd008 	sub	sp, sp, #8
  rootfs_entry_t entry = NULL;
  int64_t vnid = -1;

  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    42cc:	e1a08001 	mov	r8, r1
    42d0:	1a000001 	bne	42dc <rootfs_walk+0x24>
    vnid = entry -> id;
    *p_vnid = vnid;

    return DNA_OK;
  }
}
    42d4:	e28dd008 	add	sp, sp, #8
    42d8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  int64_t vnid = -1;

  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    ensure (base_inode -> id != rootfs -> root_vnid ||
    42dc:	e1c140d8 	ldrd	r4, [r1, #8]
    42e0:	e1c060d8 	ldrd	r6, [r0, #8]
    42e4:	e1550007 	cmp	r5, r7
    42e8:	01540006 	cmpeq	r4, r6
    42ec:	0a00000c 	beq	4324 <rootfs_walk+0x6c>
        dna_strcmp (path, "..") != 0, DNA_ALREADY_AT_ROOT);

    entry = queue_lookup (& base_inode -> entry_list,
    42f0:	e2880f4a 	add	r0, r8, #296	; 0x128
    42f4:	e59f1050 	ldr	r1, [pc, #80]	; 434c <rootfs_walk+0x94>
    42f8:	eb001498 	bl	9560 <queue_lookup>
        rootfs_entry_name_inspector, path);
    ensure (entry != NULL, DNA_NO_ENTRY);
    42fc:	e3500000 	cmp	r0, #0
    4300:	0a000005 	beq	431c <rootfs_walk+0x64>

    vnid = entry -> id;
    4304:	e1c020d8 	ldrd	r2, [r0, #8]
    *p_vnid = vnid;

    return DNA_OK;
    4308:	e3a00000 	mov	r0, #0
    entry = queue_lookup (& base_inode -> entry_list,
        rootfs_entry_name_inspector, path);
    ensure (entry != NULL, DNA_NO_ENTRY);

    vnid = entry -> id;
    *p_vnid = vnid;
    430c:	e59d1020 	ldr	r1, [sp, #32]
    4310:	e1c120f0 	strd	r2, [r1]

    return DNA_OK;
  }
}
    4314:	e28dd008 	add	sp, sp, #8
    4318:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    ensure (base_inode -> id != rootfs -> root_vnid ||
        dna_strcmp (path, "..") != 0, DNA_ALREADY_AT_ROOT);

    entry = queue_lookup (& base_inode -> entry_list,
        rootfs_entry_name_inspector, path);
    ensure (entry != NULL, DNA_NO_ENTRY);
    431c:	e59f002c 	ldr	r0, [pc, #44]	; 4350 <rootfs_walk+0x98>
    4320:	eaffffeb 	b	42d4 <rootfs_walk+0x1c>
  int64_t vnid = -1;

  watch (status_t)
  {
    ensure (ns != NULL && base != NULL, DNA_ERROR);
    ensure (base_inode -> id != rootfs -> root_vnid ||
    4324:	e1a00002 	mov	r0, r2
    4328:	e59f1024 	ldr	r1, [pc, #36]	; 4354 <rootfs_walk+0x9c>
    432c:	e58d2004 	str	r2, [sp, #4]
    4330:	eb00147e 	bl	9530 <dna_strcmp>
    4334:	e3500000 	cmp	r0, #0
    4338:	e59d2004 	ldr	r2, [sp, #4]
    433c:	03a00002 	moveq	r0, #2
    4340:	0affffe3 	beq	42d4 <rootfs_walk+0x1c>
    4344:	eaffffe9 	b	42f0 <rootfs_walk+0x38>
    4348:	0000ffff 	.word	0x0000ffff
    434c:	0000438c 	.word	0x0000438c
    4350:	0000feff 	.word	0x0000feff
    4354:	00023b64 	.word	0x00023b64

00004358 <rootfs_inode_inspector>:
#include <DnaTools/DnaTools.h>

bool rootfs_inode_inspector (void * inode, va_list list)
{
  rootfs_inode_t i = inode;
  int64_t id = va_arg (list, int64_t);
    4358:	e2811007 	add	r1, r1, #7
    435c:	e3c11007 	bic	r1, r1, #7

  watch (bool)
  {
    ensure (i != NULL, false);
    4360:	e3500000 	cmp	r0, #0
#include <DnaTools/DnaTools.h>

bool rootfs_inode_inspector (void * inode, va_list list)
{
  rootfs_inode_t i = inode;
  int64_t id = va_arg (list, int64_t);
    4364:	e1c120d0 	ldrd	r2, [r1]

  watch (bool)
  {
    ensure (i != NULL, false);
    4368:	012fff1e 	bxeq	lr
    return i -> id == id;
    436c:	e1c000d8 	ldrd	r0, [r0, #8]
    4370:	e1510003 	cmp	r1, r3
    4374:	01500002 	cmpeq	r0, r2
    4378:	03a00001 	moveq	r0, #1
    437c:	13a00000 	movne	r0, #0
  }
}
    4380:	e12fff1e 	bx	lr

00004384 <rootfs_free>:

status_t rootfs_free (void * ns, void * node, void * data)
{

  return DNA_OK;
}
    4384:	e3a00000 	mov	r0, #0
    4388:	e12fff1e 	bx	lr

0000438c <rootfs_entry_name_inspector>:
  rootfs_entry_t e = entry;
  char * name = va_arg (list, char *);

  watch (bool)
  {
    ensure (e != NULL, false);
    438c:	e3500000 	cmp	r0, #0
#include <DnaTools/DnaTools.h>

bool rootfs_entry_name_inspector (void * entry, va_list list)
{
  rootfs_entry_t e = entry;
  char * name = va_arg (list, char *);
    4390:	e5911000 	ldr	r1, [r1]

  watch (bool)
  {
    ensure (e != NULL, false);
    4394:	012fff1e 	bxeq	lr
    ensure (name != NULL, false);
    4398:	e3510000 	cmp	r1, #0
    439c:	0a000005 	beq	43b8 <rootfs_entry_name_inspector+0x2c>

#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

bool rootfs_entry_name_inspector (void * entry, va_list list)
{
    43a0:	e92d4008 	push	{r3, lr}
  watch (bool)
  {
    ensure (e != NULL, false);
    ensure (name != NULL, false);

    return dna_strcmp (e -> name, name) == 0;
    43a4:	e2800010 	add	r0, r0, #16
    43a8:	eb001460 	bl	9530 <dna_strcmp>
    43ac:	e16f0f10 	clz	r0, r0
    43b0:	e1a002a0 	lsr	r0, r0, #5
    43b4:	e8bd8008 	pop	{r3, pc}
  rootfs_entry_t e = entry;
  char * name = va_arg (list, char *);

  watch (bool)
  {
    ensure (e != NULL, false);
    43b8:	e1a00001 	mov	r0, r1
    43bc:	e12fff1e 	bx	lr

000043c0 <rootfs_read>:
status_t rootfs_read (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
  status_t status = DNA_OK;

  * p_count = 0;
    43c0:	e3a03000 	mov	r3, #0
#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_read (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
    43c4:	e59d2008 	ldr	r2, [sp, #8]
  status_t status = DNA_OK;

  * p_count = 0;
  return status;
}
    43c8:	e1a00003 	mov	r0, r3
status_t rootfs_read (void * ns, void * node, void * file, void * data,
    int64_t offset, int32_t * p_count)
{
  status_t status = DNA_OK;

  * p_count = 0;
    43cc:	e5823000 	str	r3, [r2]
  return status;
}
    43d0:	e12fff1e 	bx	lr

000043d4 <rootfs_close>:

status_t rootfs_close (void * ns, void * node, void * data)
{

  return DNA_OK;
}
    43d4:	e3a00000 	mov	r0, #0
    43d8:	e12fff1e 	bx	lr

000043dc <rootfs_create>:
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_create (void * ns, void * node, char * restrict path,
    int32_t mode, int32_t perms, int64_t * vnid, void ** data)
{
    43dc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    43e0:	e24dd014 	sub	sp, sp, #20
    43e4:	e1a08003 	mov	r8, r3
    43e8:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
    43ec:	e58d1004 	str	r1, [sp, #4]
    43f0:	e58d3008 	str	r3, [sp, #8]
    43f4:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
    43f8:	e1a06000 	mov	r6, r0
  rootfs_t rootfs = ns;
  rootfs_inode_t root_inode = node, inode = NULL;
  rootfs_entry_t entry = NULL;

  inode = kernel_malloc (sizeof (struct rootfs_inode), true);
    43fc:	e3a01001 	mov	r1, #1
    4400:	e3a00f4e 	mov	r0, #312	; 0x138
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_create (void * ns, void * node, char * restrict path,
    int32_t mode, int32_t perms, int64_t * vnid, void ** data)
{
    4404:	e1a07002 	mov	r7, r2
    4408:	e59d9038 	ldr	r9, [sp, #56]	; 0x38
    440c:	e58d300c 	str	r3, [sp, #12]
  rootfs_t rootfs = ns;
  rootfs_inode_t root_inode = node, inode = NULL;
  rootfs_entry_t entry = NULL;

  inode = kernel_malloc (sizeof (struct rootfs_inode), true);
    4410:	eb0024b7 	bl	d6f4 <kernel_malloc>
  if (inode == NULL) return DNA_OUT_OF_MEM;
    4414:	e250b000 	subs	fp, r0, #0
    4418:	0a00002a 	beq	44c8 <rootfs_create+0xec>
  inode -> id = rootfs -> inode_index ++;
    441c:	e1c640d0 	ldrd	r4, [r6]
    4420:	e1a0c006 	mov	ip, r6
  dna_strcpy (inode -> name, path);
  inode -> class = DNA_ROOTFS_FILE;
    4424:	e3a0a000 	mov	sl, #0
  rootfs_inode_t root_inode = node, inode = NULL;
  rootfs_entry_t entry = NULL;

  inode = kernel_malloc (sizeof (struct rootfs_inode), true);
  if (inode == NULL) return DNA_OUT_OF_MEM;
  inode -> id = rootfs -> inode_index ++;
    4428:	e2942001 	adds	r2, r4, #1
    442c:	e2a53000 	adc	r3, r5, #0
    4430:	e0cc21f4 	strd	r2, [ip], #20
  dna_strcpy (inode -> name, path);
    4434:	e1a01007 	mov	r1, r7
  rootfs_inode_t root_inode = node, inode = NULL;
  rootfs_entry_t entry = NULL;

  inode = kernel_malloc (sizeof (struct rootfs_inode), true);
  if (inode == NULL) return DNA_OUT_OF_MEM;
  inode -> id = rootfs -> inode_index ++;
    4438:	e1cb40f8 	strd	r4, [fp, #8]
  dna_strcpy (inode -> name, path);
    443c:	e28b0010 	add	r0, fp, #16
    4440:	e58dc000 	str	ip, [sp]
    4444:	eb0014a7 	bl	96e8 <dna_strcpy>
  inode -> class = DNA_ROOTFS_FILE;
  inode -> perms = perms;
  inode -> mode = mode;
  queue_add (& rootfs -> inode_list, inode);
    4448:	e59dc000 	ldr	ip, [sp]
    444c:	e1a0100b 	mov	r1, fp
    4450:	e1a0000c 	mov	r0, ip
  inode = kernel_malloc (sizeof (struct rootfs_inode), true);
  if (inode == NULL) return DNA_OUT_OF_MEM;
  inode -> id = rootfs -> inode_index ++;
  dna_strcpy (inode -> name, path);
  inode -> class = DNA_ROOTFS_FILE;
  inode -> perms = perms;
    4454:	e58b9124 	str	r9, [fp, #292]	; 0x124
  inode -> mode = mode;
    4458:	e58b8120 	str	r8, [fp, #288]	; 0x120

  inode = kernel_malloc (sizeof (struct rootfs_inode), true);
  if (inode == NULL) return DNA_OUT_OF_MEM;
  inode -> id = rootfs -> inode_index ++;
  dna_strcpy (inode -> name, path);
  inode -> class = DNA_ROOTFS_FILE;
    445c:	e5cba110 	strb	sl, [fp, #272]	; 0x110
  inode -> perms = perms;
  inode -> mode = mode;
  queue_add (& rootfs -> inode_list, inode);
    4460:	eb001407 	bl	9484 <queue_add>

  /*
   * Add the new directory as an entry to its parent
   */

  entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    4464:	e3a00e11 	mov	r0, #272	; 0x110
    4468:	e3a01001 	mov	r1, #1
    446c:	eb0024a0 	bl	d6f4 <kernel_malloc>
  if (entry == NULL) return DNA_OUT_OF_MEM;
    4470:	e2504000 	subs	r4, r0, #0
    4474:	0a000013 	beq	44c8 <rootfs_create+0xec>
  entry -> id = inode -> id;
    4478:	e1cb20d8 	ldrd	r2, [fp, #8]
  dna_strcpy (entry -> name, path);
    447c:	e1a01007 	mov	r1, r7
   * Add the new directory as an entry to its parent
   */

  entry = kernel_malloc (sizeof (struct rootfs_entry), true);
  if (entry == NULL) return DNA_OUT_OF_MEM;
  entry -> id = inode -> id;
    4480:	e1c420f8 	strd	r2, [r4, #8]
  dna_strcpy (entry -> name, path);
    4484:	e2840010 	add	r0, r4, #16
    4488:	eb001496 	bl	96e8 <dna_strcpy>
  queue_add (& root_inode -> entry_list, entry);
    448c:	e59d1004 	ldr	r1, [sp, #4]
    4490:	e2810f4a 	add	r0, r1, #296	; 0x128
    4494:	e1a01004 	mov	r1, r4
    4498:	eb0013f9 	bl	9484 <queue_add>

  /*
   * Add the root vnode to the system
   */

  *vnid = inode -> id;
    449c:	e1cb20d8 	ldrd	r2, [fp, #8]
    44a0:	e59d1008 	ldr	r1, [sp, #8]
    44a4:	e1c120f0 	strd	r2, [r1]
  *data = NULL;

  return vnode_create (inode -> id, rootfs -> vid, (void *) inode);
    44a8:	e1cb00d8 	ldrd	r0, [fp, #8]
  /*
   * Add the root vnode to the system
   */

  *vnid = inode -> id;
  *data = NULL;
    44ac:	e59d300c 	ldr	r3, [sp, #12]

  return vnode_create (inode -> id, rootfs -> vid, (void *) inode);
    44b0:	e5962010 	ldr	r2, [r6, #16]
  /*
   * Add the root vnode to the system
   */

  *vnid = inode -> id;
  *data = NULL;
    44b4:	e583a000 	str	sl, [r3]

  return vnode_create (inode -> id, rootfs -> vid, (void *) inode);
    44b8:	e1a0300b 	mov	r3, fp
}
    44bc:	e28dd014 	add	sp, sp, #20
    44c0:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   */

  *vnid = inode -> id;
  *data = NULL;

  return vnode_create (inode -> id, rootfs -> vid, (void *) inode);
    44c4:	ea000a9c 	b	6f3c <vnode_create>
}
    44c8:	e59f0004 	ldr	r0, [pc, #4]	; 44d4 <rootfs_create+0xf8>
    44cc:	e28dd014 	add	sp, sp, #20
    44d0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    44d4:	0000fffd 	.word	0x0000fffd

000044d8 <rootfs_open>:
#include <Private/Filesystem.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_open (void * ns, void * node, int32_t mode, void ** data)
{
  *data = NULL;
    44d8:	e3a00000 	mov	r0, #0
    44dc:	e5830000 	str	r0, [r3]
  return DNA_OK;
}
    44e0:	e12fff1e 	bx	lr

000044e4 <rootfs_write_vnode>:

status_t rootfs_write_vnode (void * ns, void * node)
{

  return DNA_OK;
}
    44e4:	e3a00000 	mov	r0, #0
    44e8:	e12fff1e 	bx	lr

000044ec <rootfs_destroy_vnode>:

status_t rootfs_destroy_vnode (void * ns, void * node)
{

  return DNA_OK;
}
    44ec:	e3a00000 	mov	r0, #0
    44f0:	e12fff1e 	bx	lr

000044f4 <rootfs_mkdir>:
#include <MemoryManager/MemoryManager.h>
#include <DnaTools/DnaTools.h>

status_t rootfs_mkdir (void * ns, void * node,
    char * restrict name, int32_t mode)
{
    44f4:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  rootfs_entry_t dot_entry = NULL, dotdot_entry = NULL, root_entry = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (ns != NULL, DNA_ERROR);
    44f8:	e2507000 	subs	r7, r0, #0
    44fc:	0a000044 	beq	4614 <rootfs_mkdir+0x120>
    ensure (node != NULL, DNA_ERROR);
    4500:	e3510000 	cmp	r1, #0
    4504:	e1a06001 	mov	r6, r1
    4508:	0a000041 	beq	4614 <rootfs_mkdir+0x120>
    ensure (name != NULL, DNA_ERROR);
    450c:	e3520000 	cmp	r2, #0
    4510:	e1a08002 	mov	r8, r2
    4514:	0a00003e 	beq	4614 <rootfs_mkdir+0x120>

    inode = kernel_malloc (sizeof (struct rootfs_inode), true);
    4518:	e3a00f4e 	mov	r0, #312	; 0x138
    451c:	e3a01001 	mov	r1, #1
    4520:	e1a09003 	mov	r9, r3
    4524:	eb002472 	bl	d6f4 <kernel_malloc>
    ensure (inode != NULL, DNA_OUT_OF_MEM);
    4528:	e250a000 	subs	sl, r0, #0
    452c:	0a00003a 	beq	461c <rootfs_mkdir+0x128>

    inode -> id = rootfs -> inode_index ++;
    4530:	e1c740d0 	ldrd	r4, [r7]
    4534:	e1a0b007 	mov	fp, r7
    dna_strcpy (inode -> name, name);
    inode -> class = DNA_ROOTFS_DIRECTORY;
    4538:	e3a07001 	mov	r7, #1
    ensure (name != NULL, DNA_ERROR);

    inode = kernel_malloc (sizeof (struct rootfs_inode), true);
    ensure (inode != NULL, DNA_OUT_OF_MEM);

    inode -> id = rootfs -> inode_index ++;
    453c:	e2942001 	adds	r2, r4, #1
    4540:	e2a53000 	adc	r3, r5, #0
    4544:	e0cb21f4 	strd	r2, [fp], #20
    dna_strcpy (inode -> name, name);
    4548:	e1a01008 	mov	r1, r8
    454c:	e28a0010 	add	r0, sl, #16
    ensure (name != NULL, DNA_ERROR);

    inode = kernel_malloc (sizeof (struct rootfs_inode), true);
    ensure (inode != NULL, DNA_OUT_OF_MEM);

    inode -> id = rootfs -> inode_index ++;
    4550:	e1ca40f8 	strd	r4, [sl, #8]
    dna_strcpy (inode -> name, name);
    4554:	eb001463 	bl	96e8 <dna_strcpy>
    inode -> class = DNA_ROOTFS_DIRECTORY;
    inode -> mode = mode;
    4558:	e58a9120 	str	r9, [sl, #288]	; 0x120
    queue_add (& rootfs -> inode_list, inode);
    455c:	e1a0100a 	mov	r1, sl
    4560:	e1a0000b 	mov	r0, fp
    inode = kernel_malloc (sizeof (struct rootfs_inode), true);
    ensure (inode != NULL, DNA_OUT_OF_MEM);

    inode -> id = rootfs -> inode_index ++;
    dna_strcpy (inode -> name, name);
    inode -> class = DNA_ROOTFS_DIRECTORY;
    4564:	e5ca7110 	strb	r7, [sl, #272]	; 0x110
    inode -> mode = mode;
    queue_add (& rootfs -> inode_list, inode);
    4568:	eb0013c5 	bl	9484 <queue_add>

    /*
     * Add the "." entry
     */

    dot_entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    456c:	e1a01007 	mov	r1, r7
    4570:	e3a00e11 	mov	r0, #272	; 0x110
    4574:	eb00245e 	bl	d6f4 <kernel_malloc>
    check (invalid_dot_entry, dot_entry != NULL, DNA_OUT_OF_MEM);
    4578:	e2509000 	subs	r9, r0, #0
    457c:	0a00002c 	beq	4634 <rootfs_mkdir+0x140>

    dot_entry -> id = inode -> id;
    4580:	e1ca40d8 	ldrd	r4, [sl, #8]
    dna_strcpy (dot_entry -> name, ".");
    4584:	e59f10b8 	ldr	r1, [pc, #184]	; 4644 <rootfs_mkdir+0x150>
     */

    dot_entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    check (invalid_dot_entry, dot_entry != NULL, DNA_OUT_OF_MEM);

    dot_entry -> id = inode -> id;
    4588:	e1c940f8 	strd	r4, [r9, #8]
    dna_strcpy (dot_entry -> name, ".");
    458c:	e2890010 	add	r0, r9, #16
    queue_add (& inode -> entry_list, dot_entry);
    4590:	e28abf4a 	add	fp, sl, #296	; 0x128

    dot_entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    check (invalid_dot_entry, dot_entry != NULL, DNA_OUT_OF_MEM);

    dot_entry -> id = inode -> id;
    dna_strcpy (dot_entry -> name, ".");
    4594:	eb001453 	bl	96e8 <dna_strcpy>
    queue_add (& inode -> entry_list, dot_entry);
    4598:	e1a01009 	mov	r1, r9
    459c:	e1a0000b 	mov	r0, fp
    45a0:	eb0013b7 	bl	9484 <queue_add>

    /*
     * Add the ".." entry
     */

    dotdot_entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    45a4:	e3a00e11 	mov	r0, #272	; 0x110
    45a8:	e1a01007 	mov	r1, r7
    45ac:	eb002450 	bl	d6f4 <kernel_malloc>
    check (invalid_dotdot_entry, dotdot_entry != NULL, DNA_OUT_OF_MEM);
    45b0:	e2505000 	subs	r5, r0, #0
    45b4:	0a00001c 	beq	462c <rootfs_mkdir+0x138>

    dotdot_entry -> id = root_inode -> id;
    45b8:	e1c620d8 	ldrd	r2, [r6, #8]
    dna_strcpy (dotdot_entry -> name, "..");
    45bc:	e59f1084 	ldr	r1, [pc, #132]	; 4648 <rootfs_mkdir+0x154>
     */

    dotdot_entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    check (invalid_dotdot_entry, dotdot_entry != NULL, DNA_OUT_OF_MEM);

    dotdot_entry -> id = root_inode -> id;
    45c0:	e1c520f8 	strd	r2, [r5, #8]
    dna_strcpy (dotdot_entry -> name, "..");
    45c4:	e2850010 	add	r0, r5, #16
    45c8:	eb001446 	bl	96e8 <dna_strcpy>
    queue_add (& inode -> entry_list, dotdot_entry);
    45cc:	e1a01005 	mov	r1, r5
    45d0:	e1a0000b 	mov	r0, fp
    45d4:	eb0013aa 	bl	9484 <queue_add>

    /*
     * Add the new directory as an entry to its parent
     */

    root_entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    45d8:	e1a01007 	mov	r1, r7
    45dc:	e3a00e11 	mov	r0, #272	; 0x110
    45e0:	eb002443 	bl	d6f4 <kernel_malloc>
    check (invalid_root_entry, root_entry != NULL, DNA_OUT_OF_MEM);
    45e4:	e2504000 	subs	r4, r0, #0
    45e8:	0a00000d 	beq	4624 <rootfs_mkdir+0x130>

    root_entry -> id = inode -> id;
    45ec:	e1ca20d8 	ldrd	r2, [sl, #8]
    dna_strcpy (root_entry -> name, name);
    45f0:	e1a01008 	mov	r1, r8
     */

    root_entry = kernel_malloc (sizeof (struct rootfs_entry), true);
    check (invalid_root_entry, root_entry != NULL, DNA_OUT_OF_MEM);

    root_entry -> id = inode -> id;
    45f4:	e1c420f8 	strd	r2, [r4, #8]
    dna_strcpy (root_entry -> name, name);
    45f8:	e2840010 	add	r0, r4, #16
    45fc:	eb001439 	bl	96e8 <dna_strcpy>
    queue_add (& root_inode -> entry_list, root_entry);
    4600:	e2860f4a 	add	r0, r6, #296	; 0x128
    4604:	e1a01004 	mov	r1, r4
    4608:	eb00139d 	bl	9484 <queue_add>

    return status;
    460c:	e3a00000 	mov	r0, #0
    4610:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  rootfs_entry_t dot_entry = NULL, dotdot_entry = NULL, root_entry = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (ns != NULL, DNA_ERROR);
    4614:	e59f0030 	ldr	r0, [pc, #48]	; 464c <rootfs_mkdir+0x158>
    4618:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ensure (node != NULL, DNA_ERROR);
    ensure (name != NULL, DNA_ERROR);

    inode = kernel_malloc (sizeof (struct rootfs_inode), true);
    ensure (inode != NULL, DNA_OUT_OF_MEM);
    461c:	e59f002c 	ldr	r0, [pc, #44]	; 4650 <rootfs_mkdir+0x15c>
  rescue (invalid_dot_entry)
  {
    kernel_free (inode);
    leave;
  }
}
    4620:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return status;
  }

  rescue (invalid_root_entry)
  {
    kernel_free (dotdot_entry);
    4624:	e1a00005 	mov	r0, r5
    4628:	eb002466 	bl	d7c8 <kernel_free>
  }

  rescue (invalid_dotdot_entry)
  {
    kernel_free (dot_entry);
    462c:	e1a00009 	mov	r0, r9
    4630:	eb002464 	bl	d7c8 <kernel_free>
  }

  rescue (invalid_dot_entry)
  {
    kernel_free (inode);
    4634:	e1a0000a 	mov	r0, sl
    4638:	eb002462 	bl	d7c8 <kernel_free>
    leave;
    463c:	e59f000c 	ldr	r0, [pc, #12]	; 4650 <rootfs_mkdir+0x15c>
    4640:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4644:	00023b60 	.word	0x00023b60
    4648:	00023b64 	.word	0x00023b64
    464c:	0000ffff 	.word	0x0000ffff
    4650:	0000fffd 	.word	0x0000fffd

00004654 <rootfs_set_info>:
status_t rootfs_set_info (void * ns, void * node, void * data,
    file_info_t info, int32_t mask)
{

  return DNA_OK;
}
    4654:	e3a00000 	mov	r0, #0
    4658:	e12fff1e 	bx	lr

0000465c <IDCT>:
/*
 * Inverse 2-D Discrete Cosine Transform. 
 */

static inline void IDCT (int32_t * input, uint8_t * output)
{
    465c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4660:	e24ddf47 	sub	sp, sp, #284	; 0x11c
    4664:	e58d0010 	str	r0, [sp, #16]
	int32_t Y[64];
	int32_t k, l;

	for (k = 0; k < 8; k++)
    4668:	e3a00000 	mov	r0, #0
/*
 * Inverse 2-D Discrete Cosine Transform. 
 */

static inline void IDCT (int32_t * input, uint8_t * output)
{
    466c:	e58d1014 	str	r1, [sp, #20]
	int32_t Y[64];
	int32_t k, l;

	for (k = 0; k < 8; k++)
    4670:	e58d000c 	str	r0, [sp, #12]
  {	
		for (l = 0; l < 8; l++)
    {
      Y(k, l) = SCALE(input[(k << 3) + l], S_BITS);
    4674:	e59d100c 	ldr	r1, [sp, #12]
    4678:	e59d4010 	ldr	r4, [sp, #16]
    467c:	e1a03281 	lsl	r3, r1, #5
    4680:	e0842003 	add	r2, r4, r3
    4684:	e7949281 	ldr	r9, [r4, r1, lsl #5]
    4688:	e5928004 	ldr	r8, [r2, #4]
    468c:	e5926008 	ldr	r6, [r2, #8]
    4690:	e592500c 	ldr	r5, [r2, #12]
    4694:	e5924010 	ldr	r4, [r2, #16]
    4698:	e592e014 	ldr	lr, [r2, #20]
    469c:	e592c018 	ldr	ip, [r2, #24]
    46a0:	e592001c 	ldr	r0, [r2, #28]
    46a4:	e1a01181 	lsl	r1, r1, #3
    46a8:	e28d7f46 	add	r7, sp, #280	; 0x118
    46ac:	e0872003 	add	r2, r7, r3
    46b0:	e1a08188 	lsl	r8, r8, #3
    46b4:	e0877101 	add	r7, r7, r1, lsl #2
    46b8:	e1a09189 	lsl	r9, r9, #3
    46bc:	e1a06186 	lsl	r6, r6, #3
    46c0:	e1a05185 	lsl	r5, r5, #3
    46c4:	e1a04184 	lsl	r4, r4, #3
    46c8:	e1a0e18e 	lsl	lr, lr, #3
    46cc:	e1a0c18c 	lsl	ip, ip, #3
    46d0:	e1a00180 	lsl	r0, r0, #3
    }

		idct_1d(&Y(k, 0));
    46d4:	e28da018 	add	sl, sp, #24

	for (k = 0; k < 8; k++)
  {	
		for (l = 0; l < 8; l++)
    {
      Y(k, l) = SCALE(input[(k << 3) + l], S_BITS);
    46d8:	e5029100 	str	r9, [r2, #-256]	; 0x100
    }

		idct_1d(&Y(k, 0));
    46dc:	e08a3003 	add	r3, sl, r3

	for (k = 0; k < 8; k++)
  {	
		for (l = 0; l < 8; l++)
    {
      Y(k, l) = SCALE(input[(k << 3) + l], S_BITS);
    46e0:	e50750f4 	str	r5, [r7, #-244]	; 0xf4
    46e4:	e507e0ec 	str	lr, [r7, #-236]	; 0xec
    46e8:	e507c0e8 	str	ip, [r7, #-232]	; 0xe8
    46ec:	e50780fc 	str	r8, [r7, #-252]	; 0xfc
    46f0:	e50760f8 	str	r6, [r7, #-248]	; 0xf8
    46f4:	e50740f0 	str	r4, [r7, #-240]	; 0xf0
    46f8:	e50700e4 	str	r0, [r7, #-228]	; 0xe4
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    46fc:	e593100c 	ldr	r1, [r3, #12]
    4700:	e59fc40c 	ldr	ip, [pc, #1036]	; 4b14 <IDCT+0x4b8>
    4704:	e5930014 	ldr	r0, [r3, #20]
    4708:	e001019c 	mul	r1, ip, r1
    470c:	e000009c 	mul	r0, ip, r0
	 * Stage 1: 
	 */

	but(Y[0], Y[4], z1[1], z1[0]);
	rot(1, 6, Y[2], Y[6], &z1[2], &z1[3]);
	but(Y[1], Y[7], z1[4], z1[7]);
    4710:	e593401c 	ldr	r4, [r3, #28]
    4714:	e593c004 	ldr	ip, [r3, #4]
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    4718:	e2811a02 	add	r1, r1, #8192	; 0x2000
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    471c:	e08ce004 	add	lr, ip, r4
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    4720:	e1a01741 	asr	r1, r1, #14
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    4724:	e08ea001 	add	sl, lr, r1
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    4728:	e2800a02 	add	r0, r0, #8192	; 0x2000
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    472c:	e061100e 	rsb	r1, r1, lr
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    4730:	e59fe3e0 	ldr	lr, [pc, #992]	; 4b18 <IDCT+0x4bc>
	/*
	 * Stage 1: 
	 */

	but(Y[0], Y[4], z1[1], z1[0]);
	rot(1, 6, Y[2], Y[6], &z1[2], &z1[3]);
    4734:	e5938018 	ldr	r8, [r3, #24]
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    4738:	e1a00740 	asr	r0, r0, #14
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    473c:	e064c00c 	rsb	ip, r4, ip
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    4740:	e59f53d4 	ldr	r5, [pc, #980]	; 4b1c <IDCT+0x4c0>
	/*
	 * Stage 1: 
	 */

	but(Y[0], Y[4], z1[1], z1[0]);
	rot(1, 6, Y[2], Y[6], &z1[2], &z1[3]);
    4744:	e5936008 	ldr	r6, [r3, #8]
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    4748:	e060400c 	rsb	r4, r0, ip
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    474c:	e00b0a9e 	mul	fp, lr, sl
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    4750:	e08cc000 	add	ip, ip, r0
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    4754:	e59f73c4 	ldr	r7, [pc, #964]	; 4b20 <IDCT+0x4c4>
    4758:	e59fe3bc 	ldr	lr, [pc, #956]	; 4b1c <IDCT+0x4c0>
    475c:	e59f03b4 	ldr	r0, [pc, #948]	; 4b18 <IDCT+0x4bc>
    4760:	e0090895 	mul	r9, r5, r8
    4764:	e28550eb 	add	r5, r5, #235	; 0xeb
    4768:	e0080897 	mul	r8, r7, r8
    476c:	e0070697 	mul	r7, r7, r6
    4770:	e006069e 	mul	r6, lr, r6
    4774:	e00e0c95 	mul	lr, r5, ip
    4778:	e00c0c90 	mul	ip, r0, ip
    477c:	e59f03a0 	ldr	r0, [pc, #928]	; 4b24 <IDCT+0x4c8>
    4780:	e00a0a95 	mul	sl, r5, sl
    4784:	e0050490 	mul	r5, r0, r4
    4788:	e59f0398 	ldr	r0, [pc, #920]	; 4b28 <IDCT+0x4cc>
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    478c:	e2899a02 	add	r9, r9, #8192	; 0x2000
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    4790:	e0040490 	mul	r4, r0, r4
    4794:	e0000190 	mul	r0, r0, r1
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    4798:	e2877a02 	add	r7, r7, #8192	; 0x2000
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    479c:	e58d0008 	str	r0, [sp, #8]
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    47a0:	e1a09749 	asr	r9, r9, #14
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    47a4:	e0899747 	add	r9, r9, r7, asr #14
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    47a8:	e59f0374 	ldr	r0, [pc, #884]	; 4b24 <IDCT+0x4c8>
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    47ac:	e59d7008 	ldr	r7, [sp, #8]
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    47b0:	e0010190 	mul	r1, r0, r1
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    47b4:	e2888a02 	add	r8, r8, #8192	; 0x2000
    47b8:	e2870a02 	add	r0, r7, #8192	; 0x2000
    47bc:	e28bba02 	add	fp, fp, #8192	; 0x2000
static inline void IDCT (int32_t * input, uint8_t * output)
{
	int32_t Y[64];
	int32_t k, l;

	for (k = 0; k < 8; k++)
    47c0:	e59d700c 	ldr	r7, [sp, #12]
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    47c4:	e2866a02 	add	r6, r6, #8192	; 0x2000
    47c8:	e28eea02 	add	lr, lr, #8192	; 0x2000
    47cc:	e1a08748 	asr	r8, r8, #14
    47d0:	e1a0b74b 	asr	fp, fp, #14
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    47d4:	e0688746 	rsb	r8, r8, r6, asr #14
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    47d8:	e08bb74e 	add	fp, fp, lr, asr #14

	/*
	 * Stage 1: 
	 */

	but(Y[0], Y[4], z1[1], z1[0]);
    47dc:	e5126100 	ldr	r6, [r2, #-256]	; 0x100
    47e0:	e593e010 	ldr	lr, [r3, #16]
static inline void IDCT (int32_t * input, uint8_t * output)
{
	int32_t Y[64];
	int32_t k, l;

	for (k = 0; k < 8; k++)
    47e4:	e2877001 	add	r7, r7, #1
    47e8:	e58d700c 	str	r7, [sp, #12]
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    47ec:	e28aaa02 	add	sl, sl, #8192	; 0x2000
    47f0:	e2855a02 	add	r5, r5, #8192	; 0x2000
    47f4:	e2844a02 	add	r4, r4, #8192	; 0x2000
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    47f8:	e086700e 	add	r7, r6, lr
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    47fc:	e28cca02 	add	ip, ip, #8192	; 0x2000
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    4800:	e06e6006 	rsb	r6, lr, r6
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    4804:	e2811a02 	add	r1, r1, #8192	; 0x2000
static inline void IDCT (int32_t * input, uint8_t * output)
{
	int32_t Y[64];
	int32_t k, l;

	for (k = 0; k < 8; k++)
    4808:	e59de00c 	ldr	lr, [sp, #12]
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    480c:	e1a0a74a 	asr	sl, sl, #14
    4810:	e1a05745 	asr	r5, r5, #14
    4814:	e1a04744 	asr	r4, r4, #14
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    4818:	e06aa74c 	rsb	sl, sl, ip, asr #14
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    481c:	e0855740 	add	r5, r5, r0, asr #14
    4820:	e087c009 	add	ip, r7, r9
    4824:	e0860008 	add	r0, r6, r8
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    4828:	e0699007 	rsb	r9, r9, r7
    482c:	e0644741 	rsb	r4, r4, r1, asr #14
    4830:	e0686006 	rsb	r6, r8, r6
    4834:	e06b700c 	rsb	r7, fp, ip
    4838:	e0651000 	rsb	r1, r5, r0
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    483c:	e08cb00b 	add	fp, ip, fp
    4840:	e0805005 	add	r5, r0, r5
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    4844:	e064c006 	rsb	ip, r4, r6
    4848:	e06a0009 	rsb	r0, sl, r9
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    484c:	e0864004 	add	r4, r6, r4
    4850:	e089a00a 	add	sl, r9, sl
static inline void IDCT (int32_t * input, uint8_t * output)
{
	int32_t Y[64];
	int32_t k, l;

	for (k = 0; k < 8; k++)
    4854:	e35e0008 	cmp	lr, #8
	rot(0, 1, z2[5], z2[6], &z3[5], &z3[6]);

	/*
	 * Final stage 4: 
	 */
	but(z3[0], z3[7], Y[7], Y[0]);
    4858:	e583701c 	str	r7, [r3, #28]
    485c:	e502b100 	str	fp, [r2, #-256]	; 0x100
	but(z3[1], z3[6], Y[6], Y[1]);
    4860:	e5831018 	str	r1, [r3, #24]
    4864:	e5835004 	str	r5, [r3, #4]
	but(z3[2], z3[5], Y[5], Y[2]);
    4868:	e583c014 	str	ip, [r3, #20]
    486c:	e5834008 	str	r4, [r3, #8]
	but(z3[3], z3[4], Y[4], Y[3]);
    4870:	e5830010 	str	r0, [r3, #16]
    4874:	e583a00c 	str	sl, [r3, #12]
static inline void IDCT (int32_t * input, uint8_t * output)
{
	int32_t Y[64];
	int32_t k, l;

	for (k = 0; k < 8; k++)
    4878:	1affff7d 	bne	4674 <IDCT+0x18>
    487c:	e3a01000 	mov	r1, #0
    4880:	e59d3014 	ldr	r3, [sp, #20]
    4884:	e28d2018 	add	r2, sp, #24
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    4888:	e59f0284 	ldr	r0, [pc, #644]	; 4b14 <IDCT+0x4b8>
    488c:	e5926060 	ldr	r6, [r2, #96]	; 0x60
    4890:	e59240a0 	ldr	r4, [r2, #160]	; 0xa0
    4894:	e0060690 	mul	r6, r0, r6
    4898:	e0040490 	mul	r4, r0, r4

	for (l = 0; l < 8; l++)
  {
		int32_t Yc[8];

		for (k = 0; k < 8; k++) Yc[k] = Y(k, l);
    489c:	e592c0e0 	ldr	ip, [r2, #224]	; 0xe0
    48a0:	e5928020 	ldr	r8, [r2, #32]
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    48a4:	e2866a02 	add	r6, r6, #8192	; 0x2000
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    48a8:	e088000c 	add	r0, r8, ip
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    48ac:	e1a06746 	asr	r6, r6, #14
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    48b0:	e59fb260 	ldr	fp, [pc, #608]	; 4b18 <IDCT+0x4bc>
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    48b4:	e2844a02 	add	r4, r4, #8192	; 0x2000
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    48b8:	e080a006 	add	sl, r0, r6

	for (l = 0; l < 8; l++)
  {
		int32_t Yc[8];

		for (k = 0; k < 8; k++) Yc[k] = Y(k, l);
    48bc:	e59250c0 	ldr	r5, [r2, #192]	; 0xc0
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    48c0:	e06c8008 	rsb	r8, ip, r8
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    48c4:	e1a04744 	asr	r4, r4, #14
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    48c8:	e59f924c 	ldr	r9, [pc, #588]	; 4b1c <IDCT+0x4c0>
    48cc:	e00e0a9b 	mul	lr, fp, sl
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    48d0:	e088b004 	add	fp, r8, r4
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    48d4:	e0648008 	rsb	r8, r4, r8
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    48d8:	e59f424c 	ldr	r4, [pc, #588]	; 4b2c <IDCT+0x4d0>

	for (l = 0; l < 8; l++)
  {
		int32_t Yc[8];

		for (k = 0; k < 8; k++) Yc[k] = Y(k, l);
    48dc:	e5927040 	ldr	r7, [r2, #64]	; 0x40
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    48e0:	e00c0599 	mul	ip, r9, r5
    48e4:	e59f9234 	ldr	r9, [pc, #564]	; 4b20 <IDCT+0x4c4>
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    48e8:	e0666000 	rsb	r6, r6, r0
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    48ec:	e0000b94 	mul	r0, r4, fp
    48f0:	e24440eb 	sub	r4, r4, #235	; 0xeb
    48f4:	e0050599 	mul	r5, r9, r5
    48f8:	e0090799 	mul	r9, r9, r7
    48fc:	e0070794 	mul	r7, r4, r7
    4900:	e59f421c 	ldr	r4, [pc, #540]	; 4b24 <IDCT+0x4c8>
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    4904:	e28cca02 	add	ip, ip, #8192	; 0x2000
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    4908:	e0040894 	mul	r4, r4, r8
    490c:	e58d400c 	str	r4, [sp, #12]
    4910:	e59f4210 	ldr	r4, [pc, #528]	; 4b28 <IDCT+0x4cc>
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    4914:	e1a0c74c 	asr	ip, ip, #14
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    4918:	e0080894 	mul	r8, r4, r8
    491c:	e59f4208 	ldr	r4, [pc, #520]	; 4b2c <IDCT+0x4d0>
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    4920:	e2899a02 	add	r9, r9, #8192	; 0x2000
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    4924:	e00a0a94 	mul	sl, r4, sl
    4928:	e59f41e8 	ldr	r4, [pc, #488]	; 4b18 <IDCT+0x4bc>
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    492c:	e08c9749 	add	r9, ip, r9, asr #14
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    4930:	e00b0b94 	mul	fp, r4, fp
    4934:	e58db010 	str	fp, [sp, #16]
    4938:	e59fb1e8 	ldr	fp, [pc, #488]	; 4b28 <IDCT+0x4cc>
    493c:	e59f41e0 	ldr	r4, [pc, #480]	; 4b24 <IDCT+0x4c8>
    4940:	e00c069b 	mul	ip, fp, r6
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    4944:	e28eea02 	add	lr, lr, #8192	; 0x2000
    4948:	e1a0e74e 	asr	lr, lr, #14
    494c:	e59db00c 	ldr	fp, [sp, #12]
    4950:	e2855a02 	add	r5, r5, #8192	; 0x2000
    4954:	e2800a02 	add	r0, r0, #8192	; 0x2000
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    4958:	e08e0740 	add	r0, lr, r0, asr #14
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    495c:	e1a05745 	asr	r5, r5, #14
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t CMUL(int32_t c, int32_t x)
{
	int32_t r = c * x;
    4960:	e0060694 	mul	r6, r4, r6
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    4964:	e2877a02 	add	r7, r7, #8192	; 0x2000

	for (l = 0; l < 8; l++)
  {
		int32_t Yc[8];

		for (k = 0; k < 8; k++) Yc[k] = Y(k, l);
    4968:	e28de018 	add	lr, sp, #24
    496c:	e79ee001 	ldr	lr, [lr, r1]
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    4970:	e0657747 	rsb	r7, r5, r7, asr #14
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    4974:	e28b4a02 	add	r4, fp, #8192	; 0x2000

	for (l = 0; l < 8; l++)
  {
		int32_t Yc[8];

		for (k = 0; k < 8; k++) Yc[k] = Y(k, l);
    4978:	e5925080 	ldr	r5, [r2, #128]	; 0x80
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    497c:	e1a04744 	asr	r4, r4, #14
    4980:	e28aaa02 	add	sl, sl, #8192	; 0x2000
    4984:	e28cca02 	add	ip, ip, #8192	; 0x2000
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    4988:	e084c74c 	add	ip, r4, ip, asr #14

	for (l = 0; l < 8; l++)
  {
		int32_t Yc[8];

		for (k = 0; k < 8; k++) Yc[k] = Y(k, l);
    498c:	e58de004 	str	lr, [sp, #4]
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    4990:	e08e4005 	add	r4, lr, r5
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    4994:	e2888a02 	add	r8, r8, #8192	; 0x2000
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    4998:	e065e00e 	rsb	lr, r5, lr
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    499c:	e1a0574a 	asr	r5, sl, #14
    49a0:	e59da010 	ldr	sl, [sp, #16]
    49a4:	e1a08748 	asr	r8, r8, #14
    49a8:	e2866a02 	add	r6, r6, #8192	; 0x2000
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    49ac:	e0686746 	rsb	r6, r8, r6, asr #14
	
	/*
	 * Less accurate rounding here also works fine: 
	 */
	
	r = (r + (1 << (C_BITS - 1))) >> C_BITS;
    49b0:	e28aba02 	add	fp, sl, #8192	; 0x2000
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    49b4:	e0848009 	add	r8, r4, r9
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    49b8:	e065b74b 	rsb	fp, r5, fp, asr #14
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    49bc:	e0885000 	add	r5, r8, r0
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    49c0:	e0694004 	rsb	r4, r9, r4
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    49c4:	e08e9007 	add	r9, lr, r7
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    49c8:	e067e00e 	rsb	lr, r7, lr
 * This version is vital in passing overall mean error test. 
 */

static inline int32_t DESCALE (int32_t x, int32_t n)
{
	return (x + (1 << (n - 1)) - (x < 0)) >> n;
    49cc:	e2857020 	add	r7, r5, #32
    49d0:	e0477fa5 	sub	r7, r7, r5, lsr #31
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    49d4:	e089500c 	add	r5, r9, ip
 * This version is vital in passing overall mean error test. 
 */

static inline int32_t DESCALE (int32_t x, int32_t n)
{
	return (x + (1 << (n - 1)) - (x < 0)) >> n;
    49d8:	e285a020 	add	sl, r5, #32
    49dc:	e04aafa5 	sub	sl, sl, r5, lsr #31
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    49e0:	e08e5006 	add	r5, lr, r6
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    49e4:	e066e00e 	rsb	lr, r6, lr
 * This version is vital in passing overall mean error test. 
 */

static inline int32_t DESCALE (int32_t x, int32_t n)
{
	return (x + (1 << (n - 1)) - (x < 0)) >> n;
    49e8:	e2856020 	add	r6, r5, #32
    49ec:	e0466fa5 	sub	r6, r6, r5, lsr #31
    49f0:	e1a07347 	asr	r7, r7, #6
 * Maximum and minimum intermediate int values: 
 */

static inline int32_t ADD(int32_t x, int32_t y)
{
	int32_t r = x + y;
    49f4:	e084500b 	add	r5, r4, fp
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    49f8:	e06cc009 	rsb	ip, ip, r9
		
		idct_1d(Yc);
		
		for (k = 0; k < 8; k++)
    {
			int32_t r = 128 + DESCALE(Yc[k], S_BITS + 3);
    49fc:	e2877080 	add	r7, r7, #128	; 0x80
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    4a00:	e06b4004 	rsb	r4, fp, r4
 * This version is vital in passing overall mean error test. 
 */

static inline int32_t DESCALE (int32_t x, int32_t n)
{
	return (x + (1 << (n - 1)) - (x < 0)) >> n;
    4a04:	e2859020 	add	r9, r5, #32
    4a08:	e1a0a34a 	asr	sl, sl, #6
    4a0c:	e35700ff 	cmp	r7, #255	; 0xff
		
		idct_1d(Yc);
		
		for (k = 0; k < 8; k++)
    {
			int32_t r = 128 + DESCALE(Yc[k], S_BITS + 3);
    4a10:	e28aa080 	add	sl, sl, #128	; 0x80
 * This version is vital in passing overall mean error test. 
 */

static inline int32_t DESCALE (int32_t x, int32_t n)
{
	return (x + (1 << (n - 1)) - (x < 0)) >> n;
    4a14:	e0495fa5 	sub	r5, r9, r5, lsr #31
    4a18:	e1a06346 	asr	r6, r6, #6
    4a1c:	e2849020 	add	r9, r4, #32
		idct_1d(Yc);
		
		for (k = 0; k < 8; k++)
    {
			int32_t r = 128 + DESCALE(Yc[k], S_BITS + 3);
			X(k, l) = (r > 255) ? 255 : ((r < 0) ? 0 : r);
    4a20:	e1c77fc7 	bic	r7, r7, r7, asr #31
		
		idct_1d(Yc);
		
		for (k = 0; k < 8; k++)
    {
			int32_t r = 128 + DESCALE(Yc[k], S_BITS + 3);
    4a24:	e2866080 	add	r6, r6, #128	; 0x80
    4a28:	c3e07000 	mvngt	r7, #0
 * This version is vital in passing overall mean error test. 
 */

static inline int32_t DESCALE (int32_t x, int32_t n)
{
	return (x + (1 << (n - 1)) - (x < 0)) >> n;
    4a2c:	e0494fa4 	sub	r4, r9, r4, lsr #31
    4a30:	e35a00ff 	cmp	sl, #255	; 0xff
    4a34:	e28e9020 	add	r9, lr, #32
		idct_1d(Yc);
		
		for (k = 0; k < 8; k++)
    {
			int32_t r = 128 + DESCALE(Yc[k], S_BITS + 3);
			X(k, l) = (r > 255) ? 255 : ((r < 0) ? 0 : r);
    4a38:	e1caafca 	bic	sl, sl, sl, asr #31
 * This version is vital in passing overall mean error test. 
 */

static inline int32_t DESCALE (int32_t x, int32_t n)
{
	return (x + (1 << (n - 1)) - (x < 0)) >> n;
    4a3c:	e1a05345 	asr	r5, r5, #6
	return r;			/* actually: & 0x0000FFFF */
}

static inline int32_t SUB(int32_t x, int32_t y)
{
	int32_t r = x - y;
    4a40:	e0600008 	rsb	r0, r0, r8
		
		idct_1d(Yc);
		
		for (k = 0; k < 8; k++)
    {
			int32_t r = 128 + DESCALE(Yc[k], S_BITS + 3);
    4a44:	e2855080 	add	r5, r5, #128	; 0x80
    4a48:	d1a0800a 	movle	r8, sl
    4a4c:	c3e08000 	mvngt	r8, #0
 * This version is vital in passing overall mean error test. 
 */

static inline int32_t DESCALE (int32_t x, int32_t n)
{
	return (x + (1 << (n - 1)) - (x < 0)) >> n;
    4a50:	e049efae 	sub	lr, r9, lr, lsr #31
    4a54:	e35600ff 	cmp	r6, #255	; 0xff
    4a58:	e28ca020 	add	sl, ip, #32
    4a5c:	e1a04344 	asr	r4, r4, #6
		idct_1d(Yc);
		
		for (k = 0; k < 8; k++)
    {
			int32_t r = 128 + DESCALE(Yc[k], S_BITS + 3);
			X(k, l) = (r > 255) ? 255 : ((r < 0) ? 0 : r);
    4a60:	e1c66fc6 	bic	r6, r6, r6, asr #31
		
		idct_1d(Yc);
		
		for (k = 0; k < 8; k++)
    {
			int32_t r = 128 + DESCALE(Yc[k], S_BITS + 3);
    4a64:	e2844080 	add	r4, r4, #128	; 0x80
    4a68:	c3e06000 	mvngt	r6, #0
 * This version is vital in passing overall mean error test. 
 */

static inline int32_t DESCALE (int32_t x, int32_t n)
{
	return (x + (1 << (n - 1)) - (x < 0)) >> n;
    4a6c:	e04acfac 	sub	ip, sl, ip, lsr #31
    4a70:	e35500ff 	cmp	r5, #255	; 0xff
    4a74:	e1a0e34e 	asr	lr, lr, #6
    4a78:	e280a020 	add	sl, r0, #32
		
		idct_1d(Yc);
		
		for (k = 0; k < 8; k++)
    {
			int32_t r = 128 + DESCALE(Yc[k], S_BITS + 3);
    4a7c:	e28ee080 	add	lr, lr, #128	; 0x80
			X(k, l) = (r > 255) ? 255 : ((r < 0) ? 0 : r);
    4a80:	e1c55fc5 	bic	r5, r5, r5, asr #31
 * This version is vital in passing overall mean error test. 
 */

static inline int32_t DESCALE (int32_t x, int32_t n)
{
	return (x + (1 << (n - 1)) - (x < 0)) >> n;
    4a84:	e1a0c34c 	asr	ip, ip, #6
    4a88:	c3e05000 	mvngt	r5, #0
    4a8c:	e04a0fa0 	sub	r0, sl, r0, lsr #31
    4a90:	e35400ff 	cmp	r4, #255	; 0xff
		
		idct_1d(Yc);
		
		for (k = 0; k < 8; k++)
    {
			int32_t r = 128 + DESCALE(Yc[k], S_BITS + 3);
    4a94:	e28cc080 	add	ip, ip, #128	; 0x80
			X(k, l) = (r > 255) ? 255 : ((r < 0) ? 0 : r);
    4a98:	e1ce9fce 	bic	r9, lr, lr, asr #31
    4a9c:	e1c44fc4 	bic	r4, r4, r4, asr #31
 * This version is vital in passing overall mean error test. 
 */

static inline int32_t DESCALE (int32_t x, int32_t n)
{
	return (x + (1 << (n - 1)) - (x < 0)) >> n;
    4aa0:	e1a00340 	asr	r0, r0, #6
    4aa4:	c3e04000 	mvngt	r4, #0
    4aa8:	e35e00ff 	cmp	lr, #255	; 0xff
		
		idct_1d(Yc);
		
		for (k = 0; k < 8; k++)
    {
			int32_t r = 128 + DESCALE(Yc[k], S_BITS + 3);
    4aac:	e2800080 	add	r0, r0, #128	; 0x80
    4ab0:	d1a0e009 	movle	lr, r9
    4ab4:	c3e0e000 	mvngt	lr, #0
			X(k, l) = (r > 255) ? 255 : ((r < 0) ? 0 : r);
    4ab8:	e1cc9fcc 	bic	r9, ip, ip, asr #31
    4abc:	e35c00ff 	cmp	ip, #255	; 0xff
    4ac0:	d1a0c009 	movle	ip, r9
    4ac4:	c3e0c000 	mvngt	ip, #0
    4ac8:	e1c09fc0 	bic	r9, r0, r0, asr #31
    4acc:	e35000ff 	cmp	r0, #255	; 0xff
    4ad0:	d1a00009 	movle	r0, r9
    4ad4:	c3e00000 	mvngt	r0, #0
    4ad8:	e2811004 	add	r1, r1, #4
    }

		idct_1d(&Y(k, 0));
	}

	for (l = 0; l < 8; l++)
    4adc:	e3510020 	cmp	r1, #32
		idct_1d(Yc);
		
		for (k = 0; k < 8; k++)
    {
			int32_t r = 128 + DESCALE(Yc[k], S_BITS + 3);
			X(k, l) = (r > 255) ? 255 : ((r < 0) ? 0 : r);
    4ae0:	e5c37000 	strb	r7, [r3]
    4ae4:	e5c38008 	strb	r8, [r3, #8]
    4ae8:	e5c36010 	strb	r6, [r3, #16]
    4aec:	e5c35018 	strb	r5, [r3, #24]
    4af0:	e5c34020 	strb	r4, [r3, #32]
    4af4:	e5c3e028 	strb	lr, [r3, #40]	; 0x28
    4af8:	e5c3c030 	strb	ip, [r3, #48]	; 0x30
    4afc:	e5c30038 	strb	r0, [r3, #56]	; 0x38
    4b00:	e2822004 	add	r2, r2, #4
    4b04:	e2833001 	add	r3, r3, #1
    }

		idct_1d(&Y(k, 0));
	}

	for (l = 0; l < 8; l++)
    4b08:	1affff5e 	bne	4888 <IDCT+0x22c>
    {
			int32_t r = 128 + DESCALE(Yc[k], S_BITS + 3);
			X(k, l) = (r > 255) ? 255 : ((r < 0) ? 0 : r);
		}
	}
}
    4b0c:	e28ddf47 	add	sp, sp, #284	; 0x11c
    4b10:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4b14:	00005a82 	.word	0x00005a82
    4b18:	00003537 	.word	0x00003537
    4b1c:	000022a3 	.word	0x000022a3
    4b20:	0000539f 	.word	0x0000539f
    4b24:	00003ec5 	.word	0x00003ec5
    4b28:	00000c7c 	.word	0x00000c7c
    4b2c:	0000238e 	.word	0x0000238e

00004b30 <computer>:
 */

#include <Private/Computer.h>

void computer (uint32_t flit_size, int32_t * block_YCbCr, uint8_t * Idct_YCbCr)
{
    4b30:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
  for (uint32_t i = 0; i < flit_size; i++)
    4b34:	e2507000 	subs	r7, r0, #0
    4b38:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
    4b3c:	e1a06001 	mov	r6, r1
    4b40:	e1a05002 	mov	r5, r2
    4b44:	e3a04000 	mov	r4, #0
  {
    IDCT(& block_YCbCr[i * 64], & Idct_YCbCr[i * 64]);
    4b48:	e1a00006 	mov	r0, r6
    4b4c:	e1a01005 	mov	r1, r5

#include <Private/Computer.h>

void computer (uint32_t flit_size, int32_t * block_YCbCr, uint8_t * Idct_YCbCr)
{
  for (uint32_t i = 0; i < flit_size; i++)
    4b50:	e2844001 	add	r4, r4, #1
  {
    IDCT(& block_YCbCr[i * 64], & Idct_YCbCr[i * 64]);
    4b54:	ebfffec0 	bl	465c <IDCT>

#include <Private/Computer.h>

void computer (uint32_t flit_size, int32_t * block_YCbCr, uint8_t * Idct_YCbCr)
{
  for (uint32_t i = 0; i < flit_size; i++)
    4b58:	e1540007 	cmp	r4, r7
    4b5c:	e2866c01 	add	r6, r6, #256	; 0x100
    4b60:	e2855040 	add	r5, r5, #64	; 0x40
    4b64:	1afffff7 	bne	4b48 <computer+0x18>
    4b68:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

00004b6c <serializer>:
{
  uint8_t * buffer = 0;
  int32_t next_decoder = 0;
  bigtime_t old, new;
  
  uint32_t volatile frames = 1;
    4b6c:	e3a03001 	mov	r3, #1
/*
 * The serializer function
 */

int32_t serializer (kpn_channel_t c[NB_DECODER + 1])
{
    4b70:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4b74:	e1a08000 	mov	r8, r0
    4b78:	e24dd01c 	sub	sp, sp, #28

  /*
   * Allocate a dummy sized buffer
   */

  buffer = malloc (256 * 144 * 2);
    4b7c:	e3a00a12 	mov	r0, #73728	; 0x12000
 */

int32_t serializer (kpn_channel_t c[NB_DECODER + 1])
{
  uint8_t * buffer = 0;
  int32_t next_decoder = 0;
    4b80:	e3a0a000 	mov	sl, #0
  bigtime_t old, new;
  
  uint32_t volatile frames = 1;
    4b84:	e58d3000 	str	r3, [sp]

  /*
   * Allocate a dummy sized buffer
   */

  buffer = malloc (256 * 144 * 2);
    4b88:	eb00281d 	bl	ec04 <malloc>

  /*
   * Parse the flows
   */

  cpu_timer_get (0, & old);
    4b8c:	e28d1008 	add	r1, sp, #8

  /*
   * Allocate a dummy sized buffer
   */

  buffer = malloc (256 * 144 * 2);
    4b90:	e1a07000 	mov	r7, r0

  /*
   * Parse the flows
   */

  cpu_timer_get (0, & old);
    4b94:	e1a0000a 	mov	r0, sl
  {    
    kpn_channel_read (c[next_decoder + 1], buffer, 256 * 144 * 2);
    kpn_channel_write (c[0], buffer, 256 * 144 * 2);
    next_decoder = (next_decoder + 1) % NB_DECODER;

    cpu_timer_get (0, & new);
    4b98:	e1a0900a 	mov	r9, sl

  /*
   * Parse the flows
   */

  cpu_timer_get (0, & old);
    4b9c:	eb0013fc 	bl	9b94 <cpu_timer_get>

//    REG_LOG_END_OF_IMAGE;
    if (frames == MAX_FRAMES){
        unsigned volatile i = 0;
        while(i!= 10000) i++;
        EXIT_SIM_SUCCESS;
    4ba0:	e3a0b482 	mov	fp, #-2113929216	; 0x82000000
    old = new;

//    REG_LOG_END_OF_IMAGE;
    if (frames == MAX_FRAMES){
        unsigned volatile i = 0;
        while(i!= 10000) i++;
    4ba4:	e59f60a4 	ldr	r6, [pc, #164]	; 4c50 <serializer+0xe4>
    4ba8:	ea000002 	b	4bb8 <serializer+0x4c>
        EXIT_SIM_SUCCESS;
    }
    frames++;
    4bac:	e59d3000 	ldr	r3, [sp]
    4bb0:	e2833001 	add	r3, r3, #1
    4bb4:	e58d3000 	str	r3, [sp]

  cpu_timer_get (0, & old);

  while (true)
  {    
    kpn_channel_read (c[next_decoder + 1], buffer, 256 * 144 * 2);
    4bb8:	e28aa001 	add	sl, sl, #1
    4bbc:	e798010a 	ldr	r0, [r8, sl, lsl #2]
    4bc0:	e1a01007 	mov	r1, r7
    4bc4:	e3a02a12 	mov	r2, #73728	; 0x12000
    4bc8:	ebffeeb4 	bl	6a0 <kpn_channel_read>
    kpn_channel_write (c[0], buffer, 256 * 144 * 2);
    4bcc:	e3a02a12 	mov	r2, #73728	; 0x12000
    4bd0:	e1a01007 	mov	r1, r7
    4bd4:	e5980000 	ldr	r0, [r8]
    4bd8:	ebffee78 	bl	5c0 <kpn_channel_write>
    next_decoder = (next_decoder + 1) % NB_DECODER;

    cpu_timer_get (0, & new);
    4bdc:	e3a00000 	mov	r0, #0
    4be0:	e28d1010 	add	r1, sp, #16
    4be4:	eb0013ea 	bl	9b94 <cpu_timer_get>
    IPRINTF ("1 frame in %ld ns\r\n", new - old);
    4be8:	e1cd41d0 	ldrd	r4, [sp, #16]
    4bec:	e1cd20d8 	ldrd	r2, [sp, #8]
    4bf0:	e0542002 	subs	r2, r4, r2
    4bf4:	e0c53003 	sbc	r3, r5, r3
    4bf8:	e59f1054 	ldr	r1, [pc, #84]	; 4c54 <serializer+0xe8>
    4bfc:	e59f0054 	ldr	r0, [pc, #84]	; 4c58 <serializer+0xec>
    4c00:	eb002cf3 	bl	ffd4 <printf>
    old = new;
    4c04:	e1cd21d0 	ldrd	r2, [sp, #16]

//    REG_LOG_END_OF_IMAGE;
    if (frames == MAX_FRAMES){
    4c08:	e59d1000 	ldr	r1, [sp]

  while (true)
  {    
    kpn_channel_read (c[next_decoder + 1], buffer, 256 * 144 * 2);
    kpn_channel_write (c[0], buffer, 256 * 144 * 2);
    next_decoder = (next_decoder + 1) % NB_DECODER;
    4c0c:	e20aa003 	and	sl, sl, #3
    cpu_timer_get (0, & new);
    IPRINTF ("1 frame in %ld ns\r\n", new - old);
    old = new;

//    REG_LOG_END_OF_IMAGE;
    if (frames == MAX_FRAMES){
    4c10:	e351001e 	cmp	r1, #30
    kpn_channel_write (c[0], buffer, 256 * 144 * 2);
    next_decoder = (next_decoder + 1) % NB_DECODER;

    cpu_timer_get (0, & new);
    IPRINTF ("1 frame in %ld ns\r\n", new - old);
    old = new;
    4c14:	e1cd20f8 	strd	r2, [sp, #8]

//    REG_LOG_END_OF_IMAGE;
    if (frames == MAX_FRAMES){
    4c18:	1affffe3 	bne	4bac <serializer+0x40>
        unsigned volatile i = 0;
    4c1c:	e58d9004 	str	r9, [sp, #4]
        while(i!= 10000) i++;
    4c20:	e59d3004 	ldr	r3, [sp, #4]
    4c24:	e1530006 	cmp	r3, r6
    4c28:	0a000005 	beq	4c44 <serializer+0xd8>
    4c2c:	e59d3004 	ldr	r3, [sp, #4]
    4c30:	e2833001 	add	r3, r3, #1
    4c34:	e58d3004 	str	r3, [sp, #4]
    4c38:	e59d3004 	ldr	r3, [sp, #4]
    4c3c:	e1530006 	cmp	r3, r6
    4c40:	1afffff9 	bne	4c2c <serializer+0xc0>
        EXIT_SIM_SUCCESS;
    4c44:	e3a03001 	mov	r3, #1
    4c48:	e58b3004 	str	r3, [fp, #4]
    4c4c:	eaffffd6 	b	4bac <serializer+0x40>
    4c50:	00002710 	.word	0x00002710
    4c54:	00023bb0 	.word	0x00023bb0
    4c58:	00023bbc 	.word	0x00023bbc

00004c5c <main>:
        (*((volatile uint32_t *)(QEMU_ADDR_BASE + SYSTEMC_SHUTDOWN)) = 0)
#endif


int main (void)
{
    4c5c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    4c60:	e24dd084 	sub	sp, sp, #132	; 0x84

  /*
   * Create a channel connected to the input movie
   */

	status = kpn_channel_create ("/devices/disk/simulator/0",
    4c64:	e28d2008 	add	r2, sp, #8
    4c68:	e59f014c 	ldr	r0, [pc, #332]	; 4dbc <main+0x160>
    4c6c:	e3a01801 	mov	r1, #65536	; 0x10000
    4c70:	ebffedd2 	bl	3c0 <kpn_channel_create>
      0x10000, & dispatcher_channel[0]);

  if (status == KPN_NO_ENTRY)
    4c74:	e3500003 	cmp	r0, #3
    4c78:	0a00004c 	beq	4db0 <main+0x154>

  /*
   * Create a channel connected to the framebuffer 
   */

  kpn_channel_create ("/devices/video/simulator/0", 0, & serializer_channel[0]);
    4c7c:	e28d201c 	add	r2, sp, #28
    4c80:	e3a01000 	mov	r1, #0
    4c84:	e59f0134 	ldr	r0, [pc, #308]	; 4dc0 <main+0x164>
    4c88:	ebffedcc 	bl	3c0 <kpn_channel_create>
  {
    printf ("Error: Cannot open framebuffer.\r\n");
    abort ();
  }

  ioctl (serializer_channel[0] -> fd, FB_SET_AUTOREWIND, (void *) true);
    4c8c:	e59d301c 	ldr	r3, [sp, #28]
    4c90:	e59f112c 	ldr	r1, [pc, #300]	; 4dc4 <main+0x168>
    4c94:	e1d300f4 	ldrsh	r0, [r3, #4]
    4c98:	e3a02001 	mov	r2, #1
    4c9c:	eb0026ef 	bl	e860 <ioctl>
    4ca0:	e3a04000 	mov	r4, #0
    4ca4:	e28d700c 	add	r7, sp, #12
    4ca8:	e28d6020 	add	r6, sp, #32
    4cac:	e28d5034 	add	r5, sp, #52	; 0x34

  for (int32_t i = 0; i < NB_DECODER; i += 1)
  {
    char device_name[48];

    sprintf (device_name, "/devices/channel/rendezvous/%ld", 2 * i);
    4cb0:	e1a02004 	mov	r2, r4
    4cb4:	e59f110c 	ldr	r1, [pc, #268]	; 4dc8 <main+0x16c>
    4cb8:	e28d0050 	add	r0, sp, #80	; 0x50
    4cbc:	eb002ee7 	bl	10860 <sprintf>
    kpn_channel_create (device_name, 0x3000, & dispatcher_channel[i + 1]);
    4cc0:	e1a02007 	mov	r2, r7
    4cc4:	e3a01a03 	mov	r1, #12288	; 0x3000
    4cc8:	e28d0050 	add	r0, sp, #80	; 0x50
    4ccc:	ebffedbb 	bl	3c0 <kpn_channel_create>
    kpn_channel_create (device_name, 0x3000, & decoder_channel[i][0]);
    4cd0:	e2452004 	sub	r2, r5, #4
    4cd4:	e3a01a03 	mov	r1, #12288	; 0x3000
    4cd8:	e28d0050 	add	r0, sp, #80	; 0x50
    4cdc:	ebffedb7 	bl	3c0 <kpn_channel_create>

    sprintf (device_name, "/devices/channel/rendezvous/%ld", 2 * i + 1);
    4ce0:	e2842001 	add	r2, r4, #1
    4ce4:	e59f10dc 	ldr	r1, [pc, #220]	; 4dc8 <main+0x16c>
    4ce8:	e28d0050 	add	r0, sp, #80	; 0x50
    4cec:	eb002edb 	bl	10860 <sprintf>
    kpn_channel_create (device_name, 0, & serializer_channel[i + 1]);
    4cf0:	e1a02006 	mov	r2, r6
    4cf4:	e3a01000 	mov	r1, #0
    4cf8:	e28d0050 	add	r0, sp, #80	; 0x50
    4cfc:	ebffedaf 	bl	3c0 <kpn_channel_create>
    4d00:	e2844002 	add	r4, r4, #2
    kpn_channel_create (device_name, 0, & decoder_channel[i][1]);
    4d04:	e1a02005 	mov	r2, r5
    4d08:	e28d0050 	add	r0, sp, #80	; 0x50
    4d0c:	e3a01000 	mov	r1, #0
    4d10:	ebffedaa 	bl	3c0 <kpn_channel_create>

  /*
   * Create the channel between the dispatcher and the decoder
   */

  for (int32_t i = 0; i < NB_DECODER; i += 1)
    4d14:	e3540008 	cmp	r4, #8
    4d18:	e2877004 	add	r7, r7, #4
    4d1c:	e2866004 	add	r6, r6, #4
    4d20:	e2855008 	add	r5, r5, #8
    4d24:	1affffe1 	bne	4cb0 <main+0x54>

  /*
   * Create the threads
   */

  printf ("Create dispatcher thread.\r\n");
    4d28:	e59f009c 	ldr	r0, [pc, #156]	; 4dcc <main+0x170>
    4d2c:	eb002d20 	bl	101b4 <puts>
  pthread_create (& dispatcher_thread, NULL,
    4d30:	e28d3008 	add	r3, sp, #8
    4d34:	e1a0000d 	mov	r0, sp
    4d38:	e3a01000 	mov	r1, #0
    4d3c:	e59f208c 	ldr	r2, [pc, #140]	; 4dd0 <main+0x174>
    4d40:	ebffef9e 	bl	bc0 <pthread_create>
      (pthread_func_t) dispatcher, dispatcher_channel);

  for (int32_t i = 0; i < NB_DECODER; i += 1)
    4d44:	e3a04000 	mov	r4, #0
  {
    printf ("Create decoder thread %ld.\r\n", i);
    4d48:	e1a01004 	mov	r1, r4
    4d4c:	e59f0080 	ldr	r0, [pc, #128]	; 4dd4 <main+0x178>
    4d50:	eb002c9f 	bl	ffd4 <printf>
    pthread_create (& decoder_thread[i], NULL,
    4d54:	e28d3050 	add	r3, sp, #80	; 0x50
    4d58:	e28dc030 	add	ip, sp, #48	; 0x30
    4d5c:	e0830104 	add	r0, r3, r4, lsl #2
    4d60:	e3a01000 	mov	r1, #0
    4d64:	e08c3184 	add	r3, ip, r4, lsl #3
    4d68:	e59f2068 	ldr	r2, [pc, #104]	; 4dd8 <main+0x17c>

  printf ("Create dispatcher thread.\r\n");
  pthread_create (& dispatcher_thread, NULL,
      (pthread_func_t) dispatcher, dispatcher_channel);

  for (int32_t i = 0; i < NB_DECODER; i += 1)
    4d6c:	e2844001 	add	r4, r4, #1
  {
    printf ("Create decoder thread %ld.\r\n", i);
    pthread_create (& decoder_thread[i], NULL,
    4d70:	ebffef92 	bl	bc0 <pthread_create>

  printf ("Create dispatcher thread.\r\n");
  pthread_create (& dispatcher_thread, NULL,
      (pthread_func_t) dispatcher, dispatcher_channel);

  for (int32_t i = 0; i < NB_DECODER; i += 1)
    4d74:	e3540004 	cmp	r4, #4
    4d78:	1afffff2 	bne	4d48 <main+0xec>
    printf ("Create decoder thread %ld.\r\n", i);
    pthread_create (& decoder_thread[i], NULL,
        (pthread_func_t) decoder, decoder_channel[i]);
  }

  printf ("Create serializer thread.\r\n");
    4d7c:	e59f0058 	ldr	r0, [pc, #88]	; 4ddc <main+0x180>
    4d80:	eb002d0b 	bl	101b4 <puts>
  pthread_create (& serializer_thread, NULL,
    4d84:	e28d301c 	add	r3, sp, #28
    4d88:	e59f2050 	ldr	r2, [pc, #80]	; 4de0 <main+0x184>
    4d8c:	e28d0004 	add	r0, sp, #4
    4d90:	e3a01000 	mov	r1, #0
    4d94:	ebffef89 	bl	bc0 <pthread_create>

  /*
   * Joining the threads altogether
   */

  pthread_join (dispatcher_thread, NULL);
    4d98:	e59d0000 	ldr	r0, [sp]
    4d9c:	e3a01000 	mov	r1, #0
    4da0:	ebfff05a 	bl	f10 <pthread_join>
	return 0;
}
    4da4:	e3a00000 	mov	r0, #0
    4da8:	e28dd084 	add	sp, sp, #132	; 0x84
    4dac:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
	status = kpn_channel_create ("/devices/disk/simulator/0",
      0x10000, & dispatcher_channel[0]);

  if (status == KPN_NO_ENTRY)
  {
    printf ("Error: Cannot open source file.\r\n");
    4db0:	e59f002c 	ldr	r0, [pc, #44]	; 4de4 <main+0x188>
    4db4:	eb002cfe 	bl	101b4 <puts>
    abort ();
    4db8:	eb002682 	bl	e7c8 <abort>
    4dbc:	00023bd8 	.word	0x00023bd8
    4dc0:	00023c18 	.word	0x00023c18
    4dc4:	00000fff 	.word	0x00000fff
    4dc8:	00023c34 	.word	0x00023c34
    4dcc:	00023c54 	.word	0x00023c54
    4dd0:	00004de8 	.word	0x00004de8
    4dd4:	00023c70 	.word	0x00023c70
    4dd8:	00004f78 	.word	0x00004f78
    4ddc:	00023c90 	.word	0x00023c90
    4de0:	00004b6c 	.word	0x00004b6c
    4de4:	00023bf4 	.word	0x00023bf4

00004de8 <dispatcher>:
/*
 * The dispatcher function
 */

int32_t dispatcher (kpn_channel_t c[NB_DECODER + 1])
{
    4de8:	e92d4070 	push	{r4, r5, r6, lr}
    4dec:	e1a04000 	mov	r4, r0
	uint8_t marker0, marker1;
  bool soi_started = false;
    4df0:	e3a05000 	mov	r5, #0
    4df4:	e3a06001 	mov	r6, #1
/*
 * The dispatcher function
 */

int32_t dispatcher (kpn_channel_t c[NB_DECODER + 1])
{
    4df8:	e24dd008 	sub	sp, sp, #8
   * Parse the stream
   */

  while (true)
  {
    kpn_channel_read (c[0], & marker0, 1);
    4dfc:	e5940000 	ldr	r0, [r4]
    4e00:	e28d1006 	add	r1, sp, #6
    4e04:	e3a02001 	mov	r2, #1
    4e08:	ebffee24 	bl	6a0 <kpn_channel_read>

    if (marker0 == M_SMS)
    4e0c:	e5dd3006 	ldrb	r3, [sp, #6]
    4e10:	e35300ff 	cmp	r3, #255	; 0xff
    4e14:	0a000006 	beq	4e34 <dispatcher+0x4c>
          kpn_channel_write (c[next_decoder + 1], & marker0, 1);
          kpn_channel_write (c[next_decoder + 1], & marker1, 1);
          break;
      }
    }
    else if (soi_started)
    4e18:	e3550000 	cmp	r5, #0
    4e1c:	0afffff6 	beq	4dfc <dispatcher+0x14>
    {
      kpn_channel_write (c[next_decoder + 1], & marker0, 1);
    4e20:	e7940106 	ldr	r0, [r4, r6, lsl #2]
    4e24:	e28d1006 	add	r1, sp, #6
    4e28:	e3a02001 	mov	r2, #1
    4e2c:	ebffede3 	bl	5c0 <kpn_channel_write>
    4e30:	eafffff1 	b	4dfc <dispatcher+0x14>
  {
    kpn_channel_read (c[0], & marker0, 1);

    if (marker0 == M_SMS)
    {
      kpn_channel_read (c[0], & marker1, 1);
    4e34:	e5940000 	ldr	r0, [r4]
    4e38:	e28d1007 	add	r1, sp, #7
    4e3c:	e3a02001 	mov	r2, #1
    4e40:	ebffee16 	bl	6a0 <kpn_channel_read>

      switch (marker1)
    4e44:	e5dd3007 	ldrb	r3, [sp, #7]
    4e48:	e35300d8 	cmp	r3, #216	; 0xd8
    4e4c:	0a000016 	beq	4eac <dispatcher+0xc4>
    4e50:	e35300d9 	cmp	r3, #217	; 0xd9

          soi_started = true;
          break;

        case M_EOI :
          IPRINTF ("Found EOI\r\n");
    4e54:	e59f10a8 	ldr	r1, [pc, #168]	; 4f04 <dispatcher+0x11c>
    4e58:	e59f00a8 	ldr	r0, [pc, #168]	; 4f08 <dispatcher+0x120>

    if (marker0 == M_SMS)
    {
      kpn_channel_read (c[0], & marker1, 1);

      switch (marker1)
    4e5c:	1a00001f 	bne	4ee0 <dispatcher+0xf8>

          soi_started = true;
          break;

        case M_EOI :
          IPRINTF ("Found EOI\r\n");
    4e60:	eb002c5b 	bl	ffd4 <printf>

          kpn_channel_write (c[next_decoder + 1], & marker0, 1);
    4e64:	e7940106 	ldr	r0, [r4, r6, lsl #2]
    4e68:	e28d1006 	add	r1, sp, #6
    4e6c:	e3a02001 	mov	r2, #1
    4e70:	ebffedd2 	bl	5c0 <kpn_channel_write>
          kpn_channel_write (c[next_decoder + 1], & marker1, 1);
    4e74:	e3a02001 	mov	r2, #1
    4e78:	e7940106 	ldr	r0, [r4, r6, lsl #2]
    4e7c:	e28d1007 	add	r1, sp, #7
    4e80:	ebffedce 	bl	5c0 <kpn_channel_write>

          IPRINTF ("Flushing data to the decoder\r\n");
    4e84:	e59f1078 	ldr	r1, [pc, #120]	; 4f04 <dispatcher+0x11c>
    4e88:	e59f007c 	ldr	r0, [pc, #124]	; 4f0c <dispatcher+0x124>
    4e8c:	eb002c50 	bl	ffd4 <printf>
          kpn_channel_purge (c[next_decoder + 1], true);
    4e90:	e7940106 	ldr	r0, [r4, r6, lsl #2]
    4e94:	e3a01001 	mov	r1, #1

          soi_started = false;
          next_decoder = (next_decoder + 1) % NB_DECODER;
    4e98:	e2066003 	and	r6, r6, #3

          kpn_channel_write (c[next_decoder + 1], & marker0, 1);
          kpn_channel_write (c[next_decoder + 1], & marker1, 1);

          IPRINTF ("Flushing data to the decoder\r\n");
          kpn_channel_purge (c[next_decoder + 1], true);
    4e9c:	ebffedb6 	bl	57c <kpn_channel_purge>
    4ea0:	e2866001 	add	r6, r6, #1

          soi_started = false;
    4ea4:	e3a05000 	mov	r5, #0
          next_decoder = (next_decoder + 1) % NB_DECODER;
          break;
    4ea8:	eaffffd3 	b	4dfc <dispatcher+0x14>
      kpn_channel_read (c[0], & marker1, 1);

      switch (marker1)
      {
        case M_SOI :
          IPRINTF ("Found SOI\r\n");
    4eac:	e59f1050 	ldr	r1, [pc, #80]	; 4f04 <dispatcher+0x11c>
    4eb0:	e59f0058 	ldr	r0, [pc, #88]	; 4f10 <dispatcher+0x128>
    4eb4:	eb002c46 	bl	ffd4 <printf>

          kpn_channel_write (c[next_decoder + 1], & marker0, 1);
    4eb8:	e28d1006 	add	r1, sp, #6
    4ebc:	e3a02001 	mov	r2, #1
    4ec0:	e7940106 	ldr	r0, [r4, r6, lsl #2]
    4ec4:	ebffedbd 	bl	5c0 <kpn_channel_write>
          kpn_channel_write (c[next_decoder + 1], & marker1, 1);
    4ec8:	e7940106 	ldr	r0, [r4, r6, lsl #2]
    4ecc:	e28d1007 	add	r1, sp, #7
    4ed0:	e3a02001 	mov	r2, #1
    4ed4:	ebffedb9 	bl	5c0 <kpn_channel_write>

          soi_started = true;
    4ed8:	e3a05001 	mov	r5, #1
          break;
    4edc:	eaffffc6 	b	4dfc <dispatcher+0x14>
          soi_started = false;
          next_decoder = (next_decoder + 1) % NB_DECODER;
          break;

        default:
          kpn_channel_write (c[next_decoder + 1], & marker0, 1);
    4ee0:	e28d1006 	add	r1, sp, #6
    4ee4:	e3a02001 	mov	r2, #1
    4ee8:	e7940106 	ldr	r0, [r4, r6, lsl #2]
    4eec:	ebffedb3 	bl	5c0 <kpn_channel_write>
          kpn_channel_write (c[next_decoder + 1], & marker1, 1);
    4ef0:	e7940106 	ldr	r0, [r4, r6, lsl #2]
    4ef4:	e28d1007 	add	r1, sp, #7
    4ef8:	e3a02001 	mov	r2, #1
    4efc:	ebffedaf 	bl	5c0 <kpn_channel_write>
          break;
    4f00:	eaffffbd 	b	4dfc <dispatcher+0x14>
    4f04:	00023cac 	.word	0x00023cac
    4f08:	00023ccc 	.word	0x00023ccc
    4f0c:	00023ce0 	.word	0x00023ce0
    4f10:	00023cb8 	.word	0x00023cb8

00004f14 <skip_segment>:
/*
 * Decompression functions
 */

static inline void skip_segment (kpn_channel_t channel)
{
    4f14:	e92d4010 	push	{r4, lr}
    4f18:	e1a04000 	mov	r4, r0
    4f1c:	e24dd008 	sub	sp, sp, #8
		uint16_t segment_size;
		uint8_t size[2];
	}
  u;

	kpn_channel_read (channel, & u . size[0], 1);
    4f20:	e28d1004 	add	r1, sp, #4
    4f24:	e3a02001 	mov	r2, #1
    4f28:	ebffeddc 	bl	6a0 <kpn_channel_read>
	kpn_channel_read (channel, & u . size[1], 1);
    4f2c:	e28d1005 	add	r1, sp, #5
    4f30:	e1a00004 	mov	r0, r4
    4f34:	e3a02001 	mov	r2, #1
    4f38:	ebffedd8 	bl	6a0 <kpn_channel_read>
    4f3c:	e1dd30b4 	ldrh	r3, [sp, #4]
	cpu_data_is_big_endian (16, u . segment_size);

	IPRINTF("Skip segment (%d data)\r\n",(unsigned int) u . segment_size);
    4f40:	e59f1028 	ldr	r1, [pc, #40]	; 4f70 <skip_segment+0x5c>
    4f44:	e6bf3fb3 	rev16	r3, r3
    4f48:	e6ff2073 	uxth	r2, r3
    4f4c:	e59f0020 	ldr	r0, [pc, #32]	; 4f74 <skip_segment+0x60>
	}
  u;

	kpn_channel_read (channel, & u . size[0], 1);
	kpn_channel_read (channel, & u . size[1], 1);
	cpu_data_is_big_endian (16, u . segment_size);
    4f50:	e1cd30b4 	strh	r3, [sp, #4]

	IPRINTF("Skip segment (%d data)\r\n",(unsigned int) u . segment_size);
    4f54:	eb002c1e 	bl	ffd4 <printf>
	kpn_channel_skip (channel, u . segment_size - 2); 
    4f58:	e1dd10b4 	ldrh	r1, [sp, #4]
    4f5c:	e1a00004 	mov	r0, r4
    4f60:	e2411002 	sub	r1, r1, #2
    4f64:	ebffed54 	bl	4bc <kpn_channel_skip>
}
    4f68:	e28dd008 	add	sp, sp, #8
    4f6c:	e8bd8010 	pop	{r4, pc}
    4f70:	00023d08 	.word	0x00023d08
    4f74:	00023d74 	.word	0x00023d74

00004f78 <decoder>:

	uint16_t nb_MCU = 0, nb_MCU_sx = 0;

  int32_t MCU[64], * FLIT = NULL;
	uint32_t YH = 0, YV = 0, flit_size = 0, mcu_size = 0;
	uint32_t LB_X = 0, LB_Y = 0;
    4f78:	e3a03000 	mov	r3, #0
/*
 * The MJPEG decoder function
 */

int32_t decoder (kpn_channel_t c[2])
{
    4f7c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    4f80:	e24ddc09 	sub	sp, sp, #2304	; 0x900
    4f84:	e24dd004 	sub	sp, sp, #4
	SOF_section_t	SOF_section;
	SOF_component_t	SOF_component[3];
	DHT_section_t	DHT_section;
	SOS_section_t SOS_section;
	SOS_component_t	SOS_component[3];
	scan_desc_t	scan_desc = {0, 0, {}, {}};
    4f88:	e28d20c8 	add	r2, sp, #200	; 0xc8
    4f8c:	e4823004 	str	r3, [r2], #4
    4f90:	e4823004 	str	r3, [r2], #4
    4f94:	e4823004 	str	r3, [r2], #4
    4f98:	e4823004 	str	r3, [r2], #4
    4f9c:	e4823004 	str	r3, [r2], #4
/*
 * The MJPEG decoder function
 */

int32_t decoder (kpn_channel_t c[2])
{
    4fa0:	e58d0024 	str	r0, [sp, #36]	; 0x24
    4fa4:	e28d4e2e 	add	r4, sp, #736	; 0x2e0
	SOF_section_t	SOF_section;
	SOF_component_t	SOF_component[3];
	DHT_section_t	DHT_section;
	SOS_section_t SOS_section;
	SOS_component_t	SOS_component[3];
	scan_desc_t	scan_desc = {0, 0, {}, {}};
    4fa8:	e5823000 	str	r3, [r2]

	uint16_t nb_MCU = 0, nb_MCU_sx = 0;

  int32_t MCU[64], * FLIT = NULL;
	uint32_t YH = 0, YV = 0, flit_size = 0, mcu_size = 0;
	uint32_t LB_X = 0, LB_Y = 0;
    4fac:	e58d3084 	str	r3, [sp, #132]	; 0x84
    4fb0:	e58d3088 	str	r3, [sp, #136]	; 0x88
	SOF_section_t	SOF_section;
	SOF_component_t	SOF_component[3];
	DHT_section_t	DHT_section;
	SOS_section_t SOS_section;
	SOS_component_t	SOS_component[3];
	scan_desc_t	scan_desc = {0, 0, {}, {}};
    4fb4:	e58d30b8 	str	r3, [sp, #184]	; 0xb8
    4fb8:	e58d30bc 	str	r3, [sp, #188]	; 0xbc
    4fbc:	e58d30c0 	str	r3, [sp, #192]	; 0xc0
    4fc0:	e58d30c4 	str	r3, [sp, #196]	; 0xc4
    4fc4:	e28d5e5f 	add	r5, sp, #1520	; 0x5f0
	huff_table_t tables[2][4];

	for (HT_index = 0; HT_index < 4; HT_index++)
  {
		tables[HUFF_DC][HT_index] . table = (uint8_t *) malloc(MAX_SIZE(HUFF_DC));
    4fc8:	e3a0000e 	mov	r0, #14
    4fcc:	eb00270c 	bl	ec04 <malloc>
		if (tables[HUFF_DC][HT_index] . table == NULL)
    4fd0:	e3500000 	cmp	r0, #0
	scan_desc_t	scan_desc = {0, 0, {}, {}};
	huff_table_t tables[2][4];

	for (HT_index = 0; HT_index < 4; HT_index++)
  {
		tables[HUFF_DC][HT_index] . table = (uint8_t *) malloc(MAX_SIZE(HUFF_DC));
    4fd4:	e58400c0 	str	r0, [r4, #192]	; 0xc0
		if (tables[HUFF_DC][HT_index] . table == NULL)
    4fd8:	1a000003 	bne	4fec <decoder+0x74>
    {
      printf ("%s,%d: malloc failed\n", __FILE__, __LINE__);
    4fdc:	e59f0fec 	ldr	r0, [pc, #4076]	; 5fd0 <decoder+0x1058>
    4fe0:	e59f1fec 	ldr	r1, [pc, #4076]	; 5fd4 <decoder+0x105c>
    4fe4:	e3a02050 	mov	r2, #80	; 0x50
    4fe8:	eb002bf9 	bl	ffd4 <printf>
    }

		tables[HUFF_AC][HT_index] . table = (uint8_t *) malloc(MAX_SIZE(HUFF_AC));
    4fec:	e3a000a2 	mov	r0, #162	; 0xa2
    4ff0:	eb002703 	bl	ec04 <malloc>
		if (tables[HUFF_AC][HT_index] . table == NULL)
    4ff4:	e3500000 	cmp	r0, #0
		if (tables[HUFF_DC][HT_index] . table == NULL)
    {
      printf ("%s,%d: malloc failed\n", __FILE__, __LINE__);
    }

		tables[HUFF_AC][HT_index] . table = (uint8_t *) malloc(MAX_SIZE(HUFF_AC));
    4ff8:	e58403d0 	str	r0, [r4, #976]	; 0x3d0
    4ffc:	e28440c4 	add	r4, r4, #196	; 0xc4
		if (tables[HUFF_AC][HT_index] . table == NULL)
    5000:	1a000003 	bne	5014 <decoder+0x9c>
    {
      printf ("%s,%d: malloc failed\n", __FILE__, __LINE__);
    5004:	e59f0fc4 	ldr	r0, [pc, #4036]	; 5fd0 <decoder+0x1058>
    5008:	e59f1fc4 	ldr	r1, [pc, #4036]	; 5fd4 <decoder+0x105c>
    500c:	e3a02056 	mov	r2, #86	; 0x56
    5010:	eb002bef 	bl	ffd4 <printf>
	SOS_section_t SOS_section;
	SOS_component_t	SOS_component[3];
	scan_desc_t	scan_desc = {0, 0, {}, {}};
	huff_table_t tables[2][4];

	for (HT_index = 0; HT_index < 4; HT_index++)
    5014:	e1540005 	cmp	r4, r5
    5018:	1affffea 	bne	4fc8 <decoder+0x50>
	SOF_section_t	SOF_section;
	SOF_component_t	SOF_component[3];
	DHT_section_t	DHT_section;
	SOS_section_t SOS_section;
	SOS_component_t	SOS_component[3];
	scan_desc_t	scan_desc = {0, 0, {}, {}};
    501c:	e3a07000 	mov	r7, #0
	huff_table_t tables[2][4];

	for (HT_index = 0; HT_index < 4; HT_index++)
    5020:	e3a0c001 	mov	ip, #1
    5024:	e1a0a007 	mov	sl, r7
    5028:	e58dc05c 	str	ip, [sp, #92]	; 0x5c
    502c:	e59fbfa4 	ldr	fp, [pc, #4004]	; 5fd8 <decoder+0x1060>
    5030:	e28dc094 	add	ip, sp, #148	; 0x94
    5034:	e58d7060 	str	r7, [sp, #96]	; 0x60
    5038:	e58d7030 	str	r7, [sp, #48]	; 0x30
    503c:	e58d703c 	str	r7, [sp, #60]	; 0x3c
    5040:	e58d7050 	str	r7, [sp, #80]	; 0x50
    5044:	e58d7040 	str	r7, [sp, #64]	; 0x40
    5048:	e58d7058 	str	r7, [sp, #88]	; 0x58
    504c:	e58d704c 	str	r7, [sp, #76]	; 0x4c
    5050:	e58d7048 	str	r7, [sp, #72]	; 0x48
    5054:	e58dc020 	str	ip, [sp, #32]
   * Computation loop
   */

	while (1) 
  {
    kpn_channel_read (c[0], marker, 2);
    5058:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    505c:	e28d1074 	add	r1, sp, #116	; 0x74
    5060:	e59c0000 	ldr	r0, [ip]
    5064:	e3a02002 	mov	r2, #2
    5068:	ebffed8c 	bl	6a0 <kpn_channel_read>

		if (marker[0] == M_SMS)
    506c:	e5dd3074 	ldrb	r3, [sp, #116]	; 0x74
    5070:	e35300ff 	cmp	r3, #255	; 0xff
    5074:	1afffff7 	bne	5058 <decoder+0xe0>
    {
			switch (marker[1])
    5078:	e5dd2075 	ldrb	r2, [sp, #117]	; 0x75
    507c:	e2423001 	sub	r3, r2, #1
    5080:	e35300fe 	cmp	r3, #254	; 0xfe
    5084:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    5088:	ea0000fe 	b	5488 <decoder+0x510>
    508c:	00005970 	.word	0x00005970
    5090:	00005488 	.word	0x00005488
    5094:	00005488 	.word	0x00005488
    5098:	00005488 	.word	0x00005488
    509c:	00005488 	.word	0x00005488
    50a0:	00005488 	.word	0x00005488
    50a4:	00005488 	.word	0x00005488
    50a8:	00005488 	.word	0x00005488
    50ac:	00005488 	.word	0x00005488
    50b0:	00005488 	.word	0x00005488
    50b4:	00005488 	.word	0x00005488
    50b8:	00005488 	.word	0x00005488
    50bc:	00005488 	.word	0x00005488
    50c0:	00005488 	.word	0x00005488
    50c4:	00005488 	.word	0x00005488
    50c8:	00005488 	.word	0x00005488
    50cc:	00005488 	.word	0x00005488
    50d0:	00005488 	.word	0x00005488
    50d4:	00005488 	.word	0x00005488
    50d8:	00005488 	.word	0x00005488
    50dc:	00005488 	.word	0x00005488
    50e0:	00005488 	.word	0x00005488
    50e4:	00005488 	.word	0x00005488
    50e8:	00005488 	.word	0x00005488
    50ec:	00005488 	.word	0x00005488
    50f0:	00005488 	.word	0x00005488
    50f4:	00005488 	.word	0x00005488
    50f8:	00005488 	.word	0x00005488
    50fc:	00005488 	.word	0x00005488
    5100:	00005488 	.word	0x00005488
    5104:	00005488 	.word	0x00005488
    5108:	00005488 	.word	0x00005488
    510c:	00005488 	.word	0x00005488
    5110:	00005488 	.word	0x00005488
    5114:	00005488 	.word	0x00005488
    5118:	00005488 	.word	0x00005488
    511c:	00005488 	.word	0x00005488
    5120:	00005488 	.word	0x00005488
    5124:	00005488 	.word	0x00005488
    5128:	00005488 	.word	0x00005488
    512c:	00005488 	.word	0x00005488
    5130:	00005488 	.word	0x00005488
    5134:	00005488 	.word	0x00005488
    5138:	00005488 	.word	0x00005488
    513c:	00005488 	.word	0x00005488
    5140:	00005488 	.word	0x00005488
    5144:	00005488 	.word	0x00005488
    5148:	00005488 	.word	0x00005488
    514c:	00005488 	.word	0x00005488
    5150:	00005488 	.word	0x00005488
    5154:	00005488 	.word	0x00005488
    5158:	00005488 	.word	0x00005488
    515c:	00005488 	.word	0x00005488
    5160:	00005488 	.word	0x00005488
    5164:	00005488 	.word	0x00005488
    5168:	00005488 	.word	0x00005488
    516c:	00005488 	.word	0x00005488
    5170:	00005488 	.word	0x00005488
    5174:	00005488 	.word	0x00005488
    5178:	00005488 	.word	0x00005488
    517c:	00005488 	.word	0x00005488
    5180:	00005488 	.word	0x00005488
    5184:	00005488 	.word	0x00005488
    5188:	00005488 	.word	0x00005488
    518c:	00005488 	.word	0x00005488
    5190:	00005488 	.word	0x00005488
    5194:	00005488 	.word	0x00005488
    5198:	00005488 	.word	0x00005488
    519c:	00005488 	.word	0x00005488
    51a0:	00005488 	.word	0x00005488
    51a4:	00005488 	.word	0x00005488
    51a8:	00005488 	.word	0x00005488
    51ac:	00005488 	.word	0x00005488
    51b0:	00005488 	.word	0x00005488
    51b4:	00005488 	.word	0x00005488
    51b8:	00005488 	.word	0x00005488
    51bc:	00005488 	.word	0x00005488
    51c0:	00005488 	.word	0x00005488
    51c4:	00005488 	.word	0x00005488
    51c8:	00005488 	.word	0x00005488
    51cc:	00005488 	.word	0x00005488
    51d0:	00005488 	.word	0x00005488
    51d4:	00005488 	.word	0x00005488
    51d8:	00005488 	.word	0x00005488
    51dc:	00005488 	.word	0x00005488
    51e0:	00005488 	.word	0x00005488
    51e4:	00005488 	.word	0x00005488
    51e8:	00005488 	.word	0x00005488
    51ec:	00005488 	.word	0x00005488
    51f0:	00005488 	.word	0x00005488
    51f4:	00005488 	.word	0x00005488
    51f8:	00005488 	.word	0x00005488
    51fc:	00005488 	.word	0x00005488
    5200:	00005488 	.word	0x00005488
    5204:	00005488 	.word	0x00005488
    5208:	00005488 	.word	0x00005488
    520c:	00005488 	.word	0x00005488
    5210:	00005488 	.word	0x00005488
    5214:	00005488 	.word	0x00005488
    5218:	00005488 	.word	0x00005488
    521c:	00005488 	.word	0x00005488
    5220:	00005488 	.word	0x00005488
    5224:	00005488 	.word	0x00005488
    5228:	00005488 	.word	0x00005488
    522c:	00005488 	.word	0x00005488
    5230:	00005488 	.word	0x00005488
    5234:	00005488 	.word	0x00005488
    5238:	00005488 	.word	0x00005488
    523c:	00005488 	.word	0x00005488
    5240:	00005488 	.word	0x00005488
    5244:	00005488 	.word	0x00005488
    5248:	00005488 	.word	0x00005488
    524c:	00005488 	.word	0x00005488
    5250:	00005488 	.word	0x00005488
    5254:	00005488 	.word	0x00005488
    5258:	00005488 	.word	0x00005488
    525c:	00005488 	.word	0x00005488
    5260:	00005488 	.word	0x00005488
    5264:	00005488 	.word	0x00005488
    5268:	00005488 	.word	0x00005488
    526c:	00005488 	.word	0x00005488
    5270:	00005488 	.word	0x00005488
    5274:	00005488 	.word	0x00005488
    5278:	00005488 	.word	0x00005488
    527c:	00005488 	.word	0x00005488
    5280:	00005488 	.word	0x00005488
    5284:	00005488 	.word	0x00005488
    5288:	00005488 	.word	0x00005488
    528c:	00005488 	.word	0x00005488
    5290:	00005488 	.word	0x00005488
    5294:	00005488 	.word	0x00005488
    5298:	00005488 	.word	0x00005488
    529c:	00005488 	.word	0x00005488
    52a0:	00005488 	.word	0x00005488
    52a4:	00005488 	.word	0x00005488
    52a8:	00005488 	.word	0x00005488
    52ac:	00005488 	.word	0x00005488
    52b0:	00005488 	.word	0x00005488
    52b4:	00005488 	.word	0x00005488
    52b8:	00005488 	.word	0x00005488
    52bc:	00005488 	.word	0x00005488
    52c0:	00005488 	.word	0x00005488
    52c4:	00005488 	.word	0x00005488
    52c8:	00005488 	.word	0x00005488
    52cc:	00005488 	.word	0x00005488
    52d0:	00005488 	.word	0x00005488
    52d4:	00005488 	.word	0x00005488
    52d8:	00005488 	.word	0x00005488
    52dc:	00005488 	.word	0x00005488
    52e0:	00005488 	.word	0x00005488
    52e4:	00005488 	.word	0x00005488
    52e8:	00005488 	.word	0x00005488
    52ec:	00005488 	.word	0x00005488
    52f0:	00005488 	.word	0x00005488
    52f4:	00005488 	.word	0x00005488
    52f8:	00005488 	.word	0x00005488
    52fc:	00005488 	.word	0x00005488
    5300:	00005488 	.word	0x00005488
    5304:	00005488 	.word	0x00005488
    5308:	00005488 	.word	0x00005488
    530c:	00005488 	.word	0x00005488
    5310:	00005488 	.word	0x00005488
    5314:	00005488 	.word	0x00005488
    5318:	00005488 	.word	0x00005488
    531c:	00005488 	.word	0x00005488
    5320:	00005488 	.word	0x00005488
    5324:	00005488 	.word	0x00005488
    5328:	00005488 	.word	0x00005488
    532c:	00005488 	.word	0x00005488
    5330:	00005488 	.word	0x00005488
    5334:	00005488 	.word	0x00005488
    5338:	00005488 	.word	0x00005488
    533c:	00005488 	.word	0x00005488
    5340:	00005488 	.word	0x00005488
    5344:	00005488 	.word	0x00005488
    5348:	00005488 	.word	0x00005488
    534c:	00005488 	.word	0x00005488
    5350:	00005488 	.word	0x00005488
    5354:	00005488 	.word	0x00005488
    5358:	00005488 	.word	0x00005488
    535c:	00005488 	.word	0x00005488
    5360:	00005488 	.word	0x00005488
    5364:	00005488 	.word	0x00005488
    5368:	00005488 	.word	0x00005488
    536c:	00005488 	.word	0x00005488
    5370:	00005488 	.word	0x00005488
    5374:	00005488 	.word	0x00005488
    5378:	00005488 	.word	0x00005488
    537c:	00005488 	.word	0x00005488
    5380:	00005488 	.word	0x00005488
    5384:	00005488 	.word	0x00005488
    5388:	000057c8 	.word	0x000057c8
    538c:	000057c0 	.word	0x000057c0
    5390:	000057b8 	.word	0x000057b8
    5394:	000057b0 	.word	0x000057b0
    5398:	00005640 	.word	0x00005640
    539c:	00005638 	.word	0x00005638
    53a0:	00005630 	.word	0x00005630
    53a4:	00005628 	.word	0x00005628
    53a8:	00005620 	.word	0x00005620
    53ac:	00005618 	.word	0x00005618
    53b0:	00005610 	.word	0x00005610
    53b4:	00005608 	.word	0x00005608
    53b8:	00005600 	.word	0x00005600
    53bc:	000055f8 	.word	0x000055f8
    53c0:	000055f0 	.word	0x000055f0
    53c4:	000059e0 	.word	0x000059e0
    53c8:	000059d8 	.word	0x000059d8
    53cc:	000059d0 	.word	0x000059d0
    53d0:	000059c8 	.word	0x000059c8
    53d4:	000059c0 	.word	0x000059c0
    53d8:	000059b8 	.word	0x000059b8
    53dc:	000059b0 	.word	0x000059b0
    53e0:	000059a8 	.word	0x000059a8
    53e4:	0000666c 	.word	0x0000666c
    53e8:	00006560 	.word	0x00006560
    53ec:	0000665c 	.word	0x0000665c
    53f0:	000059e8 	.word	0x000059e8
    53f4:	00006578 	.word	0x00006578
    53f8:	00006570 	.word	0x00006570
    53fc:	0000660c 	.word	0x0000660c
    5400:	000055e8 	.word	0x000055e8
    5404:	000055c4 	.word	0x000055c4
    5408:	00005548 	.word	0x00005548
    540c:	00005540 	.word	0x00005540
    5410:	00005538 	.word	0x00005538
    5414:	00005530 	.word	0x00005530
    5418:	00005528 	.word	0x00005528
    541c:	00005520 	.word	0x00005520
    5420:	00005518 	.word	0x00005518
    5424:	00005510 	.word	0x00005510
    5428:	00005508 	.word	0x00005508
    542c:	00005500 	.word	0x00005500
    5430:	000054f8 	.word	0x000054f8
    5434:	000054f0 	.word	0x000054f0
    5438:	000054e8 	.word	0x000054e8
    543c:	000054e0 	.word	0x000054e0
    5440:	000054d0 	.word	0x000054d0
    5444:	000054d0 	.word	0x000054d0
    5448:	000054c8 	.word	0x000054c8
    544c:	00005488 	.word	0x00005488
    5450:	00005488 	.word	0x00005488
    5454:	00005488 	.word	0x00005488
    5458:	00005488 	.word	0x00005488
    545c:	00005488 	.word	0x00005488
    5460:	00005488 	.word	0x00005488
    5464:	00005488 	.word	0x00005488
    5468:	00005488 	.word	0x00005488
    546c:	00005488 	.word	0x00005488
    5470:	00005488 	.word	0x00005488
    5474:	00005488 	.word	0x00005488
    5478:	00005488 	.word	0x00005488
    547c:	000054c0 	.word	0x000054c0
    5480:	000054a4 	.word	0x000054a4
    5484:	000054d8 	.word	0x000054d8
					skip_segment (c[0]);
					break;
				}

				default: {
					IPRINTF("Error or unknown token: 0x%x\r\n", marker[1]);
    5488:	e59f1c84 	ldr	r1, [pc, #3204]	; 6114 <decoder+0x119c>
    548c:	e59f0b48 	ldr	r0, [pc, #2888]	; 5fdc <decoder+0x1064>
    5490:	eb002acf 	bl	ffd4 <printf>
					skip_segment (c[0]);
    5494:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    5498:	e59c0000 	ldr	r0, [ip]
    549c:	ebfffe9c 	bl	4f14 <skip_segment>
					break;
    54a0:	eafffeec 	b	5058 <decoder+0xe0>
					skip_segment (c[0]);
					break;
				}

				case M_COM: {
					IPRINTF("COM marker found\r\n");
    54a4:	e59f0b34 	ldr	r0, [pc, #2868]	; 5fe0 <decoder+0x1068>
					skip_segment (c[0]);
					break;
				}

				case M_SMS: {
					IPRINTF("SMS marker found\r\n");
    54a8:	e59f1c64 	ldr	r1, [pc, #3172]	; 6114 <decoder+0x119c>
    54ac:	eb002ac8 	bl	ffd4 <printf>
					skip_segment (c[0]);
    54b0:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    54b4:	e59c0000 	ldr	r0, [ip]
    54b8:	ebfffe95 	bl	4f14 <skip_segment>
					break;
    54bc:	eafffee5 	b	5058 <decoder+0xe0>
					skip_segment (c[0]);
					break;
				}

				case M_JPG13: {
					IPRINTF("JPG13 marker found\r\n");
    54c0:	e59f0b1c 	ldr	r0, [pc, #2844]	; 5fe4 <decoder+0x106c>
    54c4:	eafffff7 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_JPG0: {
					IPRINTF("JPG0 marker found\r\n");
    54c8:	e59f0b18 	ldr	r0, [pc, #2840]	; 5fe8 <decoder+0x1070>
    54cc:	eafffff5 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_APP15: {
					IPRINTF("APP14 marker found\r\n");
    54d0:	e59f0b14 	ldr	r0, [pc, #2836]	; 5fec <decoder+0x1074>
    54d4:	eafffff3 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_SMS: {
					IPRINTF("SMS marker found\r\n");
    54d8:	e59f0b10 	ldr	r0, [pc, #2832]	; 5ff0 <decoder+0x1078>
    54dc:	eafffff1 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_APP13: {
					IPRINTF("APP13 marker found\r\n");
    54e0:	e59f0b0c 	ldr	r0, [pc, #2828]	; 5ff4 <decoder+0x107c>
    54e4:	eaffffef 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_APP12: {
					IPRINTF("APP12 marker found\r\n");
    54e8:	e59f0b08 	ldr	r0, [pc, #2824]	; 5ff8 <decoder+0x1080>
    54ec:	eaffffed 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_APP11: {
					IPRINTF("APP11 marker found\r\n");
    54f0:	e59f0b04 	ldr	r0, [pc, #2820]	; 5ffc <decoder+0x1084>
    54f4:	eaffffeb 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_APP10: {
					IPRINTF("APP10 marker found\r\n");
    54f8:	e59f0b00 	ldr	r0, [pc, #2816]	; 6000 <decoder+0x1088>
    54fc:	eaffffe9 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_APP9: {
					IPRINTF("APP9 marker found\r\n");
    5500:	e59f0afc 	ldr	r0, [pc, #2812]	; 6004 <decoder+0x108c>
    5504:	eaffffe7 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_APP8: {
					IPRINTF("APP8 marker found\r\n");
    5508:	e59f0af8 	ldr	r0, [pc, #2808]	; 6008 <decoder+0x1090>
    550c:	eaffffe5 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_APP7: {
					IPRINTF("APP7 marker found\r\n");
    5510:	e59f0af4 	ldr	r0, [pc, #2804]	; 600c <decoder+0x1094>
    5514:	eaffffe3 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_APP6: {
					IPRINTF("APP6 marker found\r\n");
    5518:	e59f0af0 	ldr	r0, [pc, #2800]	; 6010 <decoder+0x1098>
    551c:	eaffffe1 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_APP5: {
					IPRINTF("APP5 marker found\r\n");
    5520:	e59f0aec 	ldr	r0, [pc, #2796]	; 6014 <decoder+0x109c>
    5524:	eaffffdf 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_APP4: {
					IPRINTF("APP4 marker found\r\n");
    5528:	e59f0ae8 	ldr	r0, [pc, #2792]	; 6018 <decoder+0x10a0>
    552c:	eaffffdd 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_APP3: {
					IPRINTF("APP3 marker found\r\n");
    5530:	e59f0ae4 	ldr	r0, [pc, #2788]	; 601c <decoder+0x10a4>
    5534:	eaffffdb 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}
										 
				case M_APP2: {
					IPRINTF("APP2 marker found\r\n");
    5538:	e59f0ae0 	ldr	r0, [pc, #2784]	; 6020 <decoder+0x10a8>
    553c:	eaffffd9 	b	54a8 <decoder+0x530>

					break;
				}

				case M_APP1: {
					IPRINTF("APP1 marker found\r\n");
    5540:	e59f0adc 	ldr	r0, [pc, #2780]	; 6024 <decoder+0x10ac>
    5544:	eaffffd7 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_APP0: {
					IPRINTF("APP0 marker found\r\n");
    5548:	e59f1bc4 	ldr	r1, [pc, #3012]	; 6114 <decoder+0x119c>
    554c:	e59f0ad4 	ldr	r0, [pc, #2772]	; 6028 <decoder+0x10b0>
    5550:	eb002a9f 	bl	ffd4 <printf>

					kpn_channel_read (c[0], & jfif_header, sizeof (jfif_header));
    5554:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    5558:	e28d10a8 	add	r1, sp, #168	; 0xa8
    555c:	e59c0000 	ldr	r0, [ip]
    5560:	e3a02010 	mov	r2, #16
    5564:	ebffec4d 	bl	6a0 <kpn_channel_read>
					cpu_data_is_big_endian(16, jfif_header.length);
    5568:	e59f1abc 	ldr	r1, [pc, #2748]	; 602c <decoder+0x10b4>
    556c:	e28dec09 	add	lr, sp, #2304	; 0x900
    5570:	e19ec0b1 	ldrh	ip, [lr, r1]
					cpu_data_is_big_endian(16, jfif_header.xdensity);
    5574:	e59f2ab4 	ldr	r2, [pc, #2740]	; 6030 <decoder+0x10b8>
					cpu_data_is_big_endian(16, jfif_header.ydensity);
    5578:	e59f3ab4 	ldr	r3, [pc, #2740]	; 6034 <decoder+0x10bc>
    557c:	e6bfcfbc 	rev16	ip, ip
    5580:	e19e00b2 	ldrh	r0, [lr, r2]

				case M_APP0: {
					IPRINTF("APP0 marker found\r\n");

					kpn_channel_read (c[0], & jfif_header, sizeof (jfif_header));
					cpu_data_is_big_endian(16, jfif_header.length);
    5584:	e18ec0b1 	strh	ip, [lr, r1]
    5588:	e19e10b3 	ldrh	r1, [lr, r3]
					cpu_data_is_big_endian(16, jfif_header.xdensity);
					cpu_data_is_big_endian(16, jfif_header.ydensity);

					if (jfif_header.identifier[0] != 'J' ||
    558c:	e5ddc0aa 	ldrb	ip, [sp, #170]	; 0xaa
    5590:	e6bf0fb0 	rev16	r0, r0
    5594:	e6bf1fb1 	rev16	r1, r1
    5598:	e35c004a 	cmp	ip, #74	; 0x4a
				case M_APP0: {
					IPRINTF("APP0 marker found\r\n");

					kpn_channel_read (c[0], & jfif_header, sizeof (jfif_header));
					cpu_data_is_big_endian(16, jfif_header.length);
					cpu_data_is_big_endian(16, jfif_header.xdensity);
    559c:	e18e00b2 	strh	r0, [lr, r2]
					cpu_data_is_big_endian(16, jfif_header.ydensity);
    55a0:	e18e10b3 	strh	r1, [lr, r3]

					if (jfif_header.identifier[0] != 'J' ||
    55a4:	1a000002 	bne	55b4 <decoder+0x63c>
    55a8:	e5dd30ab 	ldrb	r3, [sp, #171]	; 0xab
    55ac:	e3530046 	cmp	r3, #70	; 0x46
    55b0:	0a000005 	beq	55cc <decoder+0x654>
              jfif_header.identifier[1] != 'F' ||
							jfif_header.identifier[2] != 'I' ||
              jfif_header.identifier[3] != 'F')
          {
						VPRINTF("Not a JFIF file\r\n");
    55b4:	e59f1b58 	ldr	r1, [pc, #2904]	; 6114 <decoder+0x119c>
    55b8:	e59f0a78 	ldr	r0, [pc, #2680]	; 6038 <decoder+0x10c0>
    55bc:	eb002a84 	bl	ffd4 <printf>
    55c0:	eafffea4 	b	5058 <decoder+0xe0>
					skip_segment (c[0]);
					break;
				}

				case M_EXP: {
					IPRINTF("EXP marker found\r\n");
    55c4:	e59f0a70 	ldr	r0, [pc, #2672]	; 603c <decoder+0x10c4>
    55c8:	eaffffb6 	b	54a8 <decoder+0x530>
					cpu_data_is_big_endian(16, jfif_header.length);
					cpu_data_is_big_endian(16, jfif_header.xdensity);
					cpu_data_is_big_endian(16, jfif_header.ydensity);

					if (jfif_header.identifier[0] != 'J' ||
              jfif_header.identifier[1] != 'F' ||
    55cc:	e5dd30ac 	ldrb	r3, [sp, #172]	; 0xac
    55d0:	e3530049 	cmp	r3, #73	; 0x49
    55d4:	1afffff6 	bne	55b4 <decoder+0x63c>
							jfif_header.identifier[2] != 'I' ||
    55d8:	e5dd30ad 	ldrb	r3, [sp, #173]	; 0xad
    55dc:	e3530046 	cmp	r3, #70	; 0x46
    55e0:	1afffff3 	bne	55b4 <decoder+0x63c>
    55e4:	eafffe9b 	b	5058 <decoder+0xe0>
					skip_segment (c[0]);
					break;
				}

				case M_DHP: {
					IPRINTF("DHP marker found\r\n");
    55e8:	e59f0a50 	ldr	r0, [pc, #2640]	; 6040 <decoder+0x10c8>
    55ec:	eaffffad 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_SOF14: {
					IPRINTF("SOF14 marker found\r\n");
    55f0:	e59f0a4c 	ldr	r0, [pc, #2636]	; 6044 <decoder+0x10cc>
    55f4:	eaffffab 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_SOF13: {
					IPRINTF("SOF13 marker found\r\n");
    55f8:	e59f0a48 	ldr	r0, [pc, #2632]	; 6048 <decoder+0x10d0>
    55fc:	eaffffa9 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_DAC: {
					IPRINTF("DAC marker found\r\n");
    5600:	e59f0a44 	ldr	r0, [pc, #2628]	; 604c <decoder+0x10d4>
    5604:	eaffffa7 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_SOF11: {
					IPRINTF("SOF11 marker found\r\n");
    5608:	e59f0a40 	ldr	r0, [pc, #2624]	; 6050 <decoder+0x10d8>
    560c:	eaffffa5 	b	54a8 <decoder+0x530>
					IPRINTF("SOF9 marker found\r\n");
					skip_segment (c[0]);
					break;
				}
				case M_SOF10: {
					IPRINTF("SOF10 marker found\r\n");
    5610:	e59f0a3c 	ldr	r0, [pc, #2620]	; 6054 <decoder+0x10dc>
    5614:	eaffffa3 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}
	
				case M_SOF9: {
					IPRINTF("SOF9 marker found\r\n");
    5618:	e59f0a38 	ldr	r0, [pc, #2616]	; 6058 <decoder+0x10e0>
    561c:	eaffffa1 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_JPG: {
					IPRINTF("JPG marker found\r\n");
    5620:	e59f0a34 	ldr	r0, [pc, #2612]	; 605c <decoder+0x10e4>
    5624:	eaffff9f 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_SOF7: {
					IPRINTF("SOF7 marker found\r\n");
    5628:	e59f0a30 	ldr	r0, [pc, #2608]	; 6060 <decoder+0x10e8>
    562c:	eaffff9d 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_SOF6: {
					IPRINTF("SOF6 marker found\r\n");
    5630:	e59f0a2c 	ldr	r0, [pc, #2604]	; 6064 <decoder+0x10ec>
    5634:	eaffff9b 	b	54a8 <decoder+0x530>

					break;
				}

				case M_SOF5: {
					IPRINTF("SOF5 marker found\r\n");
    5638:	e59f0a28 	ldr	r0, [pc, #2600]	; 6068 <decoder+0x10f0>
    563c:	eaffff99 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_DHT: {
					IPRINTF("DHT marker found\r\n");
    5640:	e59f1acc 	ldr	r1, [pc, #2764]	; 6114 <decoder+0x119c>
    5644:	e59f0a20 	ldr	r0, [pc, #2592]	; 606c <decoder+0x10f4>
    5648:	eb002a61 	bl	ffd4 <printf>

					kpn_channel_read (c[0], & DHT_section, sizeof (DHT_section));
    564c:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    5650:	e28d107c 	add	r1, sp, #124	; 0x7c
    5654:	e59c0000 	ldr	r0, [ip]
    5658:	e3a02003 	mov	r2, #3
    565c:	ebffec0f 	bl	6a0 <kpn_channel_read>
					cpu_data_is_big_endian(16, DHT_section . length);
    5660:	e59f3a08 	ldr	r3, [pc, #2568]	; 6070 <decoder+0x10f8>
    5664:	e28dec09 	add	lr, sp, #2304	; 0x900

					HT_index = DHT_section . huff_info & 0x0f;
    5668:	e5dd607e 	ldrb	r6, [sp, #126]	; 0x7e
    566c:	e19ec0b3 	ldrh	ip, [lr, r3]
    5670:	e206500f 	and	r5, r6, #15
    5674:	e6bfcfbc 	rev16	ip, ip
					HT_type = (DHT_section . huff_info >> 4) & 0x01;

					VPRINTF("Huffman table index is %d\r\n", HT_index);
    5678:	e1a02005 	mov	r2, r5
    567c:	e59f1a90 	ldr	r1, [pc, #2704]	; 6114 <decoder+0x119c>

					kpn_channel_read (c[0], & DHT_section, sizeof (DHT_section));
					cpu_data_is_big_endian(16, DHT_section . length);

					HT_index = DHT_section . huff_info & 0x0f;
					HT_type = (DHT_section . huff_info >> 4) & 0x01;
    5680:	e1a06226 	lsr	r6, r6, #4

					VPRINTF("Huffman table index is %d\r\n", HT_index);
    5684:	e59f09e8 	ldr	r0, [pc, #2536]	; 6074 <decoder+0x10fc>

				case M_DHT: {
					IPRINTF("DHT marker found\r\n");

					kpn_channel_read (c[0], & DHT_section, sizeof (DHT_section));
					cpu_data_is_big_endian(16, DHT_section . length);
    5688:	e18ec0b3 	strh	ip, [lr, r3]

					HT_index = DHT_section . huff_info & 0x0f;
					HT_type = (DHT_section . huff_info >> 4) & 0x01;
    568c:	e2066001 	and	r6, r6, #1

					VPRINTF("Huffman table index is %d\r\n", HT_index);
    5690:	eb002a4f 	bl	ffd4 <printf>
					VPRINTF("Huffman table type is %s\r\n", HT_type ? "AC" : "DC");
    5694:	e59f39dc 	ldr	r3, [pc, #2524]	; 6078 <decoder+0x1100>
    5698:	e3560000 	cmp	r6, #0
    569c:	e59f29d8 	ldr	r2, [pc, #2520]	; 607c <decoder+0x1104>
    56a0:	e59f1a6c 	ldr	r1, [pc, #2668]	; 6114 <decoder+0x119c>
    56a4:	01a02003 	moveq	r2, r3
    56a8:	e59f09d0 	ldr	r0, [pc, #2512]	; 6080 <decoder+0x1108>
    56ac:	eb002a48 	bl	ffd4 <printf>

					VPRINTF("Loading Huffman table\r\n");
    56b0:	e59f1a5c 	ldr	r1, [pc, #2652]	; 6114 <decoder+0x119c>
    56b4:	e59f09c8 	ldr	r0, [pc, #2504]	; 6084 <decoder+0x110c>
    56b8:	eb002a45 	bl	ffd4 <printf>
    56bc:	e3a02e31 	mov	r2, #784	; 0x310
    56c0:	e3a010c4 	mov	r1, #196	; 0xc4

static inline void load_huffman_table (kpn_channel_t channel,
    DHT_section_t *DHT_section, huff_table_t * ht)
{
	uint8_t buffer = 0;
    56c4:	e3a03000 	mov	r3, #0
    56c8:	e0020692 	mul	r2, r2, r6
    56cc:	e0282591 	mla	r8, r1, r5, r2
    56d0:	e1a02008 	mov	r2, r8
    56d4:	e58da028 	str	sl, [sp, #40]	; 0x28
	int32_t max = 0;
	int32_t LeavesN = 0, LeavesT = 0, i = 0;
    56d8:	e1a04003 	mov	r4, r3
}

static inline void load_huffman_table (kpn_channel_t channel,
    DHT_section_t *DHT_section, huff_table_t * ht)
{
	uint8_t buffer = 0;
    56dc:	e1a0a006 	mov	sl, r6
    56e0:	e1a06005 	mov	r6, r5
    56e4:	e1a05003 	mov	r5, r3
					load_huffman_table (c[0], & DHT_section,
    56e8:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
    56ec:	e28d1e2e 	add	r1, sp, #736	; 0x2e0
    56f0:	e2488004 	sub	r8, r8, #4
    56f4:	e282203c 	add	r2, r2, #60	; 0x3c
    56f8:	e5907000 	ldr	r7, [r0]
    56fc:	e0818008 	add	r8, r1, r8
    5700:	e0819002 	add	r9, r1, r2
    5704:	e5cd3071 	strb	r3, [sp, #113]	; 0x71
	int32_t LeavesN = 0, LeavesT = 0, i = 0;
	int32_t AuxCode = 0;

	for (i = 0; i < 16; i++)
  {
		kpn_channel_read (channel, & buffer, 1);
    5708:	e3a02001 	mov	r2, #1
    570c:	e1a00007 	mov	r0, r7
    5710:	e28d1071 	add	r1, sp, #113	; 0x71
    5714:	ebffebe1 	bl	6a0 <kpn_channel_read>
		LeavesN = buffer;
    5718:	e5dd3071 	ldrb	r3, [sp, #113]	; 0x71
		ht -> ValPtr[i] = LeavesT;
    571c:	e5a85004 	str	r5, [r8, #4]!
		ht -> MinCode[i] = AuxCode * 2;
		AuxCode = ht -> MinCode[i] + LeavesN;
		ht -> MaxCode[i] = (LeavesN) ? (AuxCode - 1) : (-1);
    5720:	e3530000 	cmp	r3, #0
    5724:	03e02000 	mvneq	r2, #0
	for (i = 0; i < 16; i++)
  {
		kpn_channel_read (channel, & buffer, 1);
		LeavesN = buffer;
		ht -> ValPtr[i] = LeavesT;
		ht -> MinCode[i] = AuxCode * 2;
    5728:	e1a04084 	lsl	r4, r4, #1
    572c:	e5884040 	str	r4, [r8, #64]	; 0x40
		AuxCode = ht -> MinCode[i] + LeavesN;
    5730:	e0834004 	add	r4, r3, r4
		ht -> MaxCode[i] = (LeavesN) ? (AuxCode - 1) : (-1);
    5734:	12442001 	subne	r2, r4, #1
	uint8_t buffer = 0;
	int32_t max = 0;
	int32_t LeavesN = 0, LeavesT = 0, i = 0;
	int32_t AuxCode = 0;

	for (i = 0; i < 16; i++)
    5738:	e1580009 	cmp	r8, r9
		kpn_channel_read (channel, & buffer, 1);
		LeavesN = buffer;
		ht -> ValPtr[i] = LeavesT;
		ht -> MinCode[i] = AuxCode * 2;
		AuxCode = ht -> MinCode[i] + LeavesN;
		ht -> MaxCode[i] = (LeavesN) ? (AuxCode - 1) : (-1);
    573c:	e5882080 	str	r2, [r8, #128]	; 0x80
		LeavesT += LeavesN;
    5740:	e0855003 	add	r5, r5, r3
	uint8_t buffer = 0;
	int32_t max = 0;
	int32_t LeavesN = 0, LeavesT = 0, i = 0;
	int32_t AuxCode = 0;

	for (i = 0; i < 16; i++)
    5744:	1affffef 	bne	5708 <decoder+0x790>
    5748:	e1a04005 	mov	r4, r5
		AuxCode = ht -> MinCode[i] + LeavesN;
		ht -> MaxCode[i] = (LeavesN) ? (AuxCode - 1) : (-1);
		LeavesT += LeavesN;
	}

	if (LeavesT > MAX_SIZE((DHT_section -> huff_info & 0x10)))
    574c:	e5dd307e 	ldrb	r3, [sp, #126]	; 0x7e
    5750:	e1a05006 	mov	r5, r6
    5754:	e2033010 	and	r3, r3, #16
    5758:	e21330ff 	ands	r3, r3, #255	; 0xff
    575c:	e1a0600a 	mov	r6, sl
		LeavesN = buffer;
		ht -> ValPtr[i] = LeavesT;
		ht -> MinCode[i] = AuxCode * 2;
		AuxCode = ht -> MinCode[i] + LeavesN;
		ht -> MaxCode[i] = (LeavesN) ? (AuxCode - 1) : (-1);
		LeavesT += LeavesN;
    5760:	e1a08004 	mov	r8, r4
    5764:	e59da028 	ldr	sl, [sp, #40]	; 0x28
	}

	if (LeavesT > MAX_SIZE((DHT_section -> huff_info & 0x10)))
    5768:	0a000089 	beq	5994 <decoder+0xa1c>
    576c:	e35400a2 	cmp	r4, #162	; 0xa2
    5770:	d3a08000 	movle	r8, #0
    5774:	ca00007f 	bgt	5978 <decoder+0xa00>
		max = MAX_SIZE((DHT_section -> huff_info & 0x10));
		VPRINTF("WARNING: Truncating Table by %lu symbols\r\n", LeavesT - max);
	}
	else max = LeavesT;

	kpn_channel_read (channel, ht -> table, max);
    5778:	e3a02e31 	mov	r2, #784	; 0x310
    577c:	e3a030c4 	mov	r3, #196	; 0xc4
    5780:	e0060692 	mul	r6, r2, r6
    5784:	e0236593 	mla	r3, r3, r5, r6
    5788:	e28d2c09 	add	r2, sp, #2304	; 0x900
    578c:	e0823003 	add	r3, r2, r3
    5790:	e5131560 	ldr	r1, [r3, #-1376]	; 0x560
    5794:	e1a02004 	mov	r2, r4
    5798:	e1a00007 	mov	r0, r7
    579c:	ebffebbf 	bl	6a0 <kpn_channel_read>
	kpn_channel_skip (channel, LeavesT - max);
    57a0:	e1a00007 	mov	r0, r7
    57a4:	e1a01008 	mov	r1, r8
    57a8:	ebffeb43 	bl	4bc <kpn_channel_skip>
    57ac:	eafffe29 	b	5058 <decoder+0xe0>
					skip_segment (c[0]);
					break;
				}

				case M_SOF3: {
					IPRINTF("SOF3 marker found\r\n");
    57b0:	e59f08d0 	ldr	r0, [pc, #2256]	; 6088 <decoder+0x1110>
    57b4:	eaffff3b 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_SOF2: {
					IPRINTF("SOF2 marker found\r\n");
    57b8:	e59f08cc 	ldr	r0, [pc, #2252]	; 608c <decoder+0x1114>
    57bc:	eaffff39 	b	54a8 <decoder+0x530>

					break;
				}

				case M_SOF1: {
					IPRINTF("SOF1 marker found\r\n");
    57c0:	e59f08c8 	ldr	r0, [pc, #2248]	; 6090 <decoder+0x1118>
    57c4:	eaffff37 	b	54a8 <decoder+0x530>
		if (marker[0] == M_SMS)
    {
			switch (marker[1])
      {
				case M_SOF0: {
					IPRINTF("SOF0 marker found\r\n");
    57c8:	e59f1944 	ldr	r1, [pc, #2372]	; 6114 <decoder+0x119c>
    57cc:	e59f08c0 	ldr	r0, [pc, #2240]	; 6094 <decoder+0x111c>
    57d0:	eb0029ff 	bl	ffd4 <printf>

					kpn_channel_read (c[0], & SOF_section, sizeof (SOF_section));
    57d4:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    57d8:	e28d1094 	add	r1, sp, #148	; 0x94
    57dc:	e59c0000 	ldr	r0, [ip]
    57e0:	e3a02008 	mov	r2, #8
    57e4:	ebffebad 	bl	6a0 <kpn_channel_read>
					cpu_data_is_big_endian(16, SOF_section . length);
					cpu_data_is_big_endian(16, SOF_section . height);
    57e8:	e5dd2097 	ldrb	r2, [sp, #151]	; 0x97
    57ec:	e5ddc098 	ldrb	ip, [sp, #152]	; 0x98
      {
				case M_SOF0: {
					IPRINTF("SOF0 marker found\r\n");

					kpn_channel_read (c[0], & SOF_section, sizeof (SOF_section));
					cpu_data_is_big_endian(16, SOF_section . length);
    57f0:	e59f38a0 	ldr	r3, [pc, #2208]	; 6098 <decoder+0x1120>
					cpu_data_is_big_endian(16, SOF_section . height);
    57f4:	e182c40c 	orr	ip, r2, ip, lsl #8
    57f8:	e6bfcfbc 	rev16	ip, ip
    57fc:	e6ffc07c 	uxth	ip, ip
    5800:	e1a0242c 	lsr	r2, ip, #8
    5804:	e5cd2098 	strb	r2, [sp, #152]	; 0x98
					cpu_data_is_big_endian(16, SOF_section . width);
    5808:	e59d2098 	ldr	r2, [sp, #152]	; 0x98
    580c:	e28d0c09 	add	r0, sp, #2304	; 0x900
    5810:	e1a01422 	lsr	r1, r2, #8
    5814:	e190e0b3 	ldrh	lr, [r0, r3]
    5818:	e6bf1fb1 	rev16	r1, r1
    581c:	e3c228ff 	bic	r2, r2, #16711680	; 0xff0000
    5820:	e6ff1071 	uxth	r1, r1
    5824:	e3c22cff 	bic	r2, r2, #65280	; 0xff00
    5828:	e6bfefbe 	rev16	lr, lr
    582c:	e1824401 	orr	r4, r2, r1, lsl #8
				case M_SOF0: {
					IPRINTF("SOF0 marker found\r\n");

					kpn_channel_read (c[0], & SOF_section, sizeof (SOF_section));
					cpu_data_is_big_endian(16, SOF_section . length);
					cpu_data_is_big_endian(16, SOF_section . height);
    5830:	e5cdc097 	strb	ip, [sp, #151]	; 0x97
					cpu_data_is_big_endian(16, SOF_section . width);

					VPRINTF("Data precision = %d\r\n", SOF_section . data_precision);
    5834:	e59f18d8 	ldr	r1, [pc, #2264]	; 6114 <decoder+0x119c>
      {
				case M_SOF0: {
					IPRINTF("SOF0 marker found\r\n");

					kpn_channel_read (c[0], & SOF_section, sizeof (SOF_section));
					cpu_data_is_big_endian(16, SOF_section . length);
    5838:	e28dcc09 	add	ip, sp, #2304	; 0x900
					cpu_data_is_big_endian(16, SOF_section . height);
					cpu_data_is_big_endian(16, SOF_section . width);

					VPRINTF("Data precision = %d\r\n", SOF_section . data_precision);
    583c:	e5dd2096 	ldrb	r2, [sp, #150]	; 0x96
    5840:	e59f0854 	ldr	r0, [pc, #2132]	; 609c <decoder+0x1124>
					IPRINTF("SOF0 marker found\r\n");

					kpn_channel_read (c[0], & SOF_section, sizeof (SOF_section));
					cpu_data_is_big_endian(16, SOF_section . length);
					cpu_data_is_big_endian(16, SOF_section . height);
					cpu_data_is_big_endian(16, SOF_section . width);
    5844:	e58d4098 	str	r4, [sp, #152]	; 0x98
      {
				case M_SOF0: {
					IPRINTF("SOF0 marker found\r\n");

					kpn_channel_read (c[0], & SOF_section, sizeof (SOF_section));
					cpu_data_is_big_endian(16, SOF_section . length);
    5848:	e18ce0b3 	strh	lr, [ip, r3]
					cpu_data_is_big_endian(16, SOF_section . height);
					cpu_data_is_big_endian(16, SOF_section . width);

					VPRINTF("Data precision = %d\r\n", SOF_section . data_precision);
    584c:	eb0029e0 	bl	ffd4 <printf>
					VPRINTF("Image height = %d\r\n", SOF_section . height);
    5850:	e5dd3097 	ldrb	r3, [sp, #151]	; 0x97
    5854:	e5dd2098 	ldrb	r2, [sp, #152]	; 0x98
    5858:	e59f18b4 	ldr	r1, [pc, #2228]	; 6114 <decoder+0x119c>
    585c:	e1832402 	orr	r2, r3, r2, lsl #8
    5860:	e59f0838 	ldr	r0, [pc, #2104]	; 60a0 <decoder+0x1128>
    5864:	eb0029da 	bl	ffd4 <printf>
					VPRINTF("Image width = %d\r\n", SOF_section . width);
    5868:	e59d2098 	ldr	r2, [sp, #152]	; 0x98
    586c:	e59f18a0 	ldr	r1, [pc, #2208]	; 6114 <decoder+0x119c>
    5870:	e1a02422 	lsr	r2, r2, #8
    5874:	e6ff2072 	uxth	r2, r2
    5878:	e59f0824 	ldr	r0, [pc, #2084]	; 60a4 <decoder+0x112c>
    587c:	eb0029d4 	bl	ffd4 <printf>
					VPRINTF("%d component%c\r\n", SOF_section . n,
    5880:	e5dd209b 	ldrb	r2, [sp, #155]	; 0x9b
    5884:	e59f1888 	ldr	r1, [pc, #2184]	; 6114 <decoder+0x119c>
    5888:	e3520001 	cmp	r2, #1
    588c:	83a03073 	movhi	r3, #115	; 0x73
    5890:	93a03020 	movls	r3, #32
    5894:	e59f080c 	ldr	r0, [pc, #2060]	; 60a8 <decoder+0x1130>
    5898:	eb0029cd 	bl	ffd4 <printf>
              (SOF_section . n > 1) ? 's' : ' ');

					kpn_channel_read (c[0], & SOF_component,
    589c:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
              sizeof (SOF_component_t) * SOF_section . n);
    58a0:	e5dd209b 	ldrb	r2, [sp, #155]	; 0x9b
					VPRINTF("Image height = %d\r\n", SOF_section . height);
					VPRINTF("Image width = %d\r\n", SOF_section . width);
					VPRINTF("%d component%c\r\n", SOF_section . n,
              (SOF_section . n > 1) ? 's' : ' ');

					kpn_channel_read (c[0], & SOF_component,
    58a4:	e59c0000 	ldr	r0, [ip]
    58a8:	e0822082 	add	r2, r2, r2, lsl #1
    58ac:	e28d109c 	add	r1, sp, #156	; 0x9c
    58b0:	ebffeb7a 	bl	6a0 <kpn_channel_read>
              sizeof (SOF_component_t) * SOF_section . n);

					YV = SOF_component[0] . HV & 0x0f;
    58b4:	e5dd609d 	ldrb	r6, [sp, #157]	; 0x9d
					YH = (SOF_component[0] . HV >> 4) & 0x0f;

					VPRINTF("Subsampling factor = %lux%lu\r\n", YH, YV);
    58b8:	e59f07ec 	ldr	r0, [pc, #2028]	; 60ac <decoder+0x1134>
              (SOF_section . n > 1) ? 's' : ' ');

					kpn_channel_read (c[0], & SOF_component,
              sizeof (SOF_component_t) * SOF_section . n);

					YV = SOF_component[0] . HV & 0x0f;
    58bc:	e206500f 	and	r5, r6, #15
					YH = (SOF_component[0] . HV >> 4) & 0x0f;
    58c0:	e1a06226 	lsr	r6, r6, #4

					VPRINTF("Subsampling factor = %lux%lu\r\n", YH, YV);
    58c4:	e1a02006 	mov	r2, r6
    58c8:	e1a03005 	mov	r3, r5
    58cc:	e59f1840 	ldr	r1, [pc, #2112]	; 6114 <decoder+0x119c>
    58d0:	eb0029bf 	bl	ffd4 <printf>
					/*
           * We only dispatch the picture info once, since we suppose
           * all the picture do have the same format
           */

					if (dispatch_info)
    58d4:	e59dc05c 	ldr	ip, [sp, #92]	; 0x5c
              (SOF_section . n > 1) ? 's' : ' ');

					kpn_channel_read (c[0], & SOF_component,
              sizeof (SOF_component_t) * SOF_section . n);

					YV = SOF_component[0] . HV & 0x0f;
    58d8:	e58d503c 	str	r5, [sp, #60]	; 0x3c
					/*
           * We only dispatch the picture info once, since we suppose
           * all the picture do have the same format
           */

					if (dispatch_info)
    58dc:	e35c0000 	cmp	ip, #0

					kpn_channel_read (c[0], & SOF_component,
              sizeof (SOF_component_t) * SOF_section . n);

					YV = SOF_component[0] . HV & 0x0f;
					YH = (SOF_component[0] . HV >> 4) & 0x0f;
    58e0:	e58d6050 	str	r6, [sp, #80]	; 0x50
					/*
           * We only dispatch the picture info once, since we suppose
           * all the picture do have the same format
           */

					if (dispatch_info)
    58e4:	0afffddb 	beq	5058 <decoder+0xe0>
          {
						nb_MCU_sx = intceil(SOF_section.width, MCU_sx);
    58e8:	e59d7098 	ldr	r7, [sp, #152]	; 0x98
						flit_size = YV * nb_MCU_sx + (SOF_section . n - 1) * nb_MCU_sx / YH;
    58ec:	e5dd809b 	ldrb	r8, [sp, #155]	; 0x9b
           * all the picture do have the same format
           */

					if (dispatch_info)
          {
						nb_MCU_sx = intceil(SOF_section.width, MCU_sx);
    58f0:	e1a07427 	lsr	r7, r7, #8
    58f4:	e6ff7077 	uxth	r7, r7
 * Utils
 */

static inline int32_t intceil (int32_t N, int32_t D)
{
	int32_t i = N / D;
    58f8:	e1a041c7 	asr	r4, r7, #3

	if (N > D * i) i++;
    58fc:	e1570184 	cmp	r7, r4, lsl #3
    5900:	c2844001 	addgt	r4, r4, #1
						flit_size = YV * nb_MCU_sx + (SOF_section . n - 1) * nb_MCU_sx / YH;
    5904:	e2488001 	sub	r8, r8, #1
    5908:	e1a01006 	mov	r1, r6
    590c:	e0000894 	mul	r0, r4, r8
    5910:	eb002074 	bl	dae8 <__aeabi_uidiv>
    5914:	e0200495 	mla	r0, r5, r4, r0
    5918:	e58d0030 	str	r0, [sp, #48]	; 0x30

            /*
             * We reserve enough memory to work
             */

            FLIT = (int32_t *) malloc (flit_size * 64 * sizeof (int32_t));
    591c:	e1a00400 	lsl	r0, r0, #8
    5920:	eb0024b7 	bl	ec04 <malloc>
            DECODED_FLIT = (uint8_t *) malloc (flit_size * 64);
    5924:	e59dc030 	ldr	ip, [sp, #48]	; 0x30

            /*
             * We reserve enough memory to work
             */

            FLIT = (int32_t *) malloc (flit_size * 64 * sizeof (int32_t));
    5928:	e58d0040 	str	r0, [sp, #64]	; 0x40
            DECODED_FLIT = (uint8_t *) malloc (flit_size * 64);
    592c:	e1a0030c 	lsl	r0, ip, #6
    5930:	eb0024b3 	bl	ec04 <malloc>
            picture = (uint8_t *) malloc (SOF_section . width
                * SOF_section . height * 2);
    5934:	e5dd3097 	ldrb	r3, [sp, #151]	; 0x97
            /*
             * We reserve enough memory to work
             */

            FLIT = (int32_t *) malloc (flit_size * 64 * sizeof (int32_t));
            DECODED_FLIT = (uint8_t *) malloc (flit_size * 64);
    5938:	e58d004c 	str	r0, [sp, #76]	; 0x4c
            picture = (uint8_t *) malloc (SOF_section . width
                * SOF_section . height * 2);
    593c:	e5dd0098 	ldrb	r0, [sp, #152]	; 0x98

					if (dispatch_info)
          {
						nb_MCU_sx = intceil(SOF_section.width, MCU_sx);
						flit_size = YV * nb_MCU_sx + (SOF_section . n - 1) * nb_MCU_sx / YH;
						mcu_size = YV * YH + SOF_section . n - 1;
    5940:	e0288596 	mla	r8, r6, r5, r8
             */

            FLIT = (int32_t *) malloc (flit_size * 64 * sizeof (int32_t));
            DECODED_FLIT = (uint8_t *) malloc (flit_size * 64);
            picture = (uint8_t *) malloc (SOF_section . width
                * SOF_section . height * 2);
    5944:	e1830400 	orr	r0, r3, r0, lsl #8
    5948:	e0000790 	mul	r0, r0, r7
           * all the picture do have the same format
           */

					if (dispatch_info)
          {
						nb_MCU_sx = intceil(SOF_section.width, MCU_sx);
    594c:	e6ff4074 	uxth	r4, r4
             * We reserve enough memory to work
             */

            FLIT = (int32_t *) malloc (flit_size * 64 * sizeof (int32_t));
            DECODED_FLIT = (uint8_t *) malloc (flit_size * 64);
            picture = (uint8_t *) malloc (SOF_section . width
    5950:	e1a00080 	lsl	r0, r0, #1

					if (dispatch_info)
          {
						nb_MCU_sx = intceil(SOF_section.width, MCU_sx);
						flit_size = YV * nb_MCU_sx + (SOF_section . n - 1) * nb_MCU_sx / YH;
						mcu_size = YV * YH + SOF_section . n - 1;
    5954:	e58d8060 	str	r8, [sp, #96]	; 0x60
           * all the picture do have the same format
           */

					if (dispatch_info)
          {
						nb_MCU_sx = intceil(SOF_section.width, MCU_sx);
    5958:	e58d4058 	str	r4, [sp, #88]	; 0x58
             * We reserve enough memory to work
             */

            FLIT = (int32_t *) malloc (flit_size * 64 * sizeof (int32_t));
            DECODED_FLIT = (uint8_t *) malloc (flit_size * 64);
            picture = (uint8_t *) malloc (SOF_section . width
    595c:	eb0024a8 	bl	ec04 <malloc>
                * SOF_section . height * 2);

						dispatch_info = false;
    5960:	e3a0c000 	mov	ip, #0
             * We reserve enough memory to work
             */

            FLIT = (int32_t *) malloc (flit_size * 64 * sizeof (int32_t));
            DECODED_FLIT = (uint8_t *) malloc (flit_size * 64);
            picture = (uint8_t *) malloc (SOF_section . width
    5964:	e58d0048 	str	r0, [sp, #72]	; 0x48
                * SOF_section . height * 2);

						dispatch_info = false;
    5968:	e58dc05c 	str	ip, [sp, #92]	; 0x5c
    596c:	eafffdb9 	b	5058 <decoder+0xe0>
					skip_segment (c[0]);
					break;
				}

				case M_TEM: {
					IPRINTF("TEM marker found\r\n");
    5970:	e59f0738 	ldr	r0, [pc, #1848]	; 60b0 <decoder+0x1138>
    5974:	eafffecb 	b	54a8 <decoder+0x530>
		LeavesT += LeavesN;
	}

	if (LeavesT > MAX_SIZE((DHT_section -> huff_info & 0x10)))
  {
		max = MAX_SIZE((DHT_section -> huff_info & 0x10));
    5978:	e3a040a2 	mov	r4, #162	; 0xa2
		VPRINTF("WARNING: Truncating Table by %lu symbols\r\n", LeavesT - max);
    597c:	e0648008 	rsb	r8, r4, r8
    5980:	e1a02008 	mov	r2, r8
    5984:	e59f1728 	ldr	r1, [pc, #1832]	; 60b4 <decoder+0x113c>
    5988:	e59f0728 	ldr	r0, [pc, #1832]	; 60b8 <decoder+0x1140>
    598c:	eb002990 	bl	ffd4 <printf>
    5990:	eaffff78 	b	5778 <decoder+0x800>
		AuxCode = ht -> MinCode[i] + LeavesN;
		ht -> MaxCode[i] = (LeavesN) ? (AuxCode - 1) : (-1);
		LeavesT += LeavesN;
	}

	if (LeavesT > MAX_SIZE((DHT_section -> huff_info & 0x10)))
    5994:	e354000e 	cmp	r4, #14
    5998:	d1a08003 	movle	r8, r3
    599c:	daffff75 	ble	5778 <decoder+0x800>
  {
		max = MAX_SIZE((DHT_section -> huff_info & 0x10));
    59a0:	e3a0400e 	mov	r4, #14
    59a4:	eafffff4 	b	597c <decoder+0xa04>
					skip_segment (c[0]);
					break;
				}

				case M_RST6: {
					IPRINTF("RST6 marker found\r\n");
    59a8:	e59f070c 	ldr	r0, [pc, #1804]	; 60bc <decoder+0x1144>
    59ac:	eafffebd 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_RST5: {
					IPRINTF("RST5 marker found\r\n");
    59b0:	e59f0708 	ldr	r0, [pc, #1800]	; 60c0 <decoder+0x1148>
    59b4:	eafffebb 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_RST4: {
					IPRINTF("RST4 marker found\r\n");
    59b8:	e59f0704 	ldr	r0, [pc, #1796]	; 60c4 <decoder+0x114c>
    59bc:	eafffeb9 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_RST3: {
					IPRINTF("RST3 marker found\r\n");
    59c0:	e59f0700 	ldr	r0, [pc, #1792]	; 60c8 <decoder+0x1150>
    59c4:	eafffeb7 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_RST2: {
					IPRINTF("RST2 marker found\r\n");
    59c8:	e59f06fc 	ldr	r0, [pc, #1788]	; 60cc <decoder+0x1154>
    59cc:	eafffeb5 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_RST1: {
					IPRINTF("RST1 marker found\r\n");
    59d0:	e59f06f8 	ldr	r0, [pc, #1784]	; 60d0 <decoder+0x1158>
    59d4:	eafffeb3 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_RST0: {
					IPRINTF("RST0 marker found\r\n");
    59d8:	e59f06f4 	ldr	r0, [pc, #1780]	; 60d4 <decoder+0x115c>
    59dc:	eafffeb1 	b	54a8 <decoder+0x530>
					skip_segment (c[0]);
					break;
				}

				case M_SOF15: {
					IPRINTF("SOF15 marker found\r\n");
    59e0:	e59f06f0 	ldr	r0, [pc, #1776]	; 60d8 <decoder+0x1160>
    59e4:	eafffeaf 	b	54a8 <decoder+0x530>
					IPRINTF("EOI marker found\r\n");
					break;
				}

				case M_SOS: {
					IPRINTF("SOS marker found\r\n");
    59e8:	e59f1724 	ldr	r1, [pc, #1828]	; 6114 <decoder+0x119c>
    59ec:	e59f06e8 	ldr	r0, [pc, #1768]	; 60dc <decoder+0x1164>
    59f0:	eb002977 	bl	ffd4 <printf>

					kpn_channel_read (c[0], & SOS_section, sizeof (SOS_section));
    59f4:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    59f8:	e28d1080 	add	r1, sp, #128	; 0x80
    59fc:	e59c0000 	ldr	r0, [ip]
    5a00:	e3a02003 	mov	r2, #3
    5a04:	ebffeb25 	bl	6a0 <kpn_channel_read>
					cpu_data_is_big_endian(16, SOS_section . length);
    5a08:	e59f36d0 	ldr	r3, [pc, #1744]	; 60e0 <decoder+0x1168>
    5a0c:	e28dec09 	add	lr, sp, #2304	; 0x900
    5a10:	e19e10b3 	ldrh	r1, [lr, r3]

					kpn_channel_read (c[0], & SOS_component,
    5a14:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
              sizeof(SOS_component_t)  * SOS_section . n);
    5a18:	e5dd2082 	ldrb	r2, [sp, #130]	; 0x82
    5a1c:	e6bf1fb1 	rev16	r1, r1

				case M_SOS: {
					IPRINTF("SOS marker found\r\n");

					kpn_channel_read (c[0], & SOS_section, sizeof (SOS_section));
					cpu_data_is_big_endian(16, SOS_section . length);
    5a20:	e18e10b3 	strh	r1, [lr, r3]

					kpn_channel_read (c[0], & SOS_component,
    5a24:	e59c0000 	ldr	r0, [ip]
    5a28:	e1a02082 	lsl	r2, r2, #1
    5a2c:	e28d108c 	add	r1, sp, #140	; 0x8c
    5a30:	ebffeb1a 	bl	6a0 <kpn_channel_read>
              sizeof(SOS_component_t)  * SOS_section . n);
					VPRINTF("Scan with %d components\r\n", SOS_section . n);
    5a34:	e59f16d8 	ldr	r1, [pc, #1752]	; 6114 <decoder+0x119c>
    5a38:	e5dd2082 	ldrb	r2, [sp, #130]	; 0x82
    5a3c:	e59f06a0 	ldr	r0, [pc, #1696]	; 60e4 <decoder+0x116c>
    5a40:	eb002963 	bl	ffd4 <printf>

					kpn_channel_skip (c[0], SOS_section . n);
    5a44:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    5a48:	e5dd1082 	ldrb	r1, [sp, #130]	; 0x82
    5a4c:	e59c0000 	ldr	r0, [ip]
    5a50:	ebffea99 	bl	4bc <kpn_channel_skip>

					scan_desc . bit_count = 0;
					for (index = 0; index < SOS_section . n; index++)
    5a54:	e5dd1082 	ldrb	r1, [sp, #130]	; 0x82
    5a58:	e3510000 	cmp	r1, #0
    5a5c:	0a000021 	beq	5ae8 <decoder+0xb70>
          {
						scan_desc . pred[index] = 0;
						scan_desc . table[HUFF_AC][index] =
              & tables[HUFF_AC][(SOS_component[index] . acdc >> 4) & 0x0f];
    5a60:	e3a030c4 	mov	r3, #196	; 0xc4
					kpn_channel_skip (c[0], SOS_section . n);

					scan_desc . bit_count = 0;
					for (index = 0; index < SOS_section . n; index++)
          {
						scan_desc . pred[index] = 0;
    5a64:	e3a02000 	mov	r2, #0
						scan_desc . table[HUFF_AC][index] =
              & tables[HUFF_AC][(SOS_component[index] . acdc >> 4) & 0x0f];
    5a68:	e5dd008d 	ldrb	r0, [sp, #141]	; 0x8d
    5a6c:	e28dee2e 	add	lr, sp, #736	; 0x2e0
    5a70:	e1a0c220 	lsr	ip, r0, #4
    5a74:	e02cec93 	mla	ip, r3, ip, lr
						scan_desc . table[HUFF_DC][index] =
              & tables[HUFF_DC][SOS_component[index] . acdc & 0x0f];
    5a78:	e200000f 	and	r0, r0, #15
    5a7c:	e020e093 	mla	r0, r3, r0, lr
					scan_desc . bit_count = 0;
					for (index = 0; index < SOS_section . n; index++)
          {
						scan_desc . pred[index] = 0;
						scan_desc . table[HUFF_AC][index] =
              & tables[HUFF_AC][(SOS_component[index] . acdc >> 4) & 0x0f];
    5a80:	e28cce31 	add	ip, ip, #784	; 0x310
					VPRINTF("Scan with %d components\r\n", SOS_section . n);

					kpn_channel_skip (c[0], SOS_section . n);

					scan_desc . bit_count = 0;
					for (index = 0; index < SOS_section . n; index++)
    5a84:	e3510001 	cmp	r1, #1
          {
						scan_desc . pred[index] = 0;
						scan_desc . table[HUFF_AC][index] =
    5a88:	e58dc0d4 	str	ip, [sp, #212]	; 0xd4
              & tables[HUFF_AC][(SOS_component[index] . acdc >> 4) & 0x0f];
						scan_desc . table[HUFF_DC][index] =
    5a8c:	e58d00c8 	str	r0, [sp, #200]	; 0xc8
					kpn_channel_skip (c[0], SOS_section . n);

					scan_desc . bit_count = 0;
					for (index = 0; index < SOS_section . n; index++)
          {
						scan_desc . pred[index] = 0;
    5a90:	e58d20bc 	str	r2, [sp, #188]	; 0xbc
					VPRINTF("Scan with %d components\r\n", SOS_section . n);

					kpn_channel_skip (c[0], SOS_section . n);

					scan_desc . bit_count = 0;
					for (index = 0; index < SOS_section . n; index++)
    5a94:	9a000013 	bls	5ae8 <decoder+0xb70>
          {
						scan_desc . pred[index] = 0;
						scan_desc . table[HUFF_AC][index] =
              & tables[HUFF_AC][(SOS_component[index] . acdc >> 4) & 0x0f];
    5a98:	e5dd008f 	ldrb	r0, [sp, #143]	; 0x8f
					VPRINTF("Scan with %d components\r\n", SOS_section . n);

					kpn_channel_skip (c[0], SOS_section . n);

					scan_desc . bit_count = 0;
					for (index = 0; index < SOS_section . n; index++)
    5a9c:	e3510002 	cmp	r1, #2
          {
						scan_desc . pred[index] = 0;
						scan_desc . table[HUFF_AC][index] =
              & tables[HUFF_AC][(SOS_component[index] . acdc >> 4) & 0x0f];
    5aa0:	e1a0c220 	lsr	ip, r0, #4
						scan_desc . table[HUFF_DC][index] =
              & tables[HUFF_DC][SOS_component[index] . acdc & 0x0f];
    5aa4:	e200100f 	and	r1, r0, #15
					scan_desc . bit_count = 0;
					for (index = 0; index < SOS_section . n; index++)
          {
						scan_desc . pred[index] = 0;
						scan_desc . table[HUFF_AC][index] =
              & tables[HUFF_AC][(SOS_component[index] . acdc >> 4) & 0x0f];
    5aa8:	e02cec93 	mla	ip, r3, ip, lr
						scan_desc . table[HUFF_DC][index] =
              & tables[HUFF_DC][SOS_component[index] . acdc & 0x0f];
    5aac:	e021e193 	mla	r1, r3, r1, lr
					scan_desc . bit_count = 0;
					for (index = 0; index < SOS_section . n; index++)
          {
						scan_desc . pred[index] = 0;
						scan_desc . table[HUFF_AC][index] =
              & tables[HUFF_AC][(SOS_component[index] . acdc >> 4) & 0x0f];
    5ab0:	e28c0e31 	add	r0, ip, #784	; 0x310
					kpn_channel_skip (c[0], SOS_section . n);

					scan_desc . bit_count = 0;
					for (index = 0; index < SOS_section . n; index++)
          {
						scan_desc . pred[index] = 0;
    5ab4:	e58d20c0 	str	r2, [sp, #192]	; 0xc0
						scan_desc . table[HUFF_AC][index] =
    5ab8:	e58d00d8 	str	r0, [sp, #216]	; 0xd8
              & tables[HUFF_AC][(SOS_component[index] . acdc >> 4) & 0x0f];
						scan_desc . table[HUFF_DC][index] =
    5abc:	e58d10cc 	str	r1, [sp, #204]	; 0xcc
					VPRINTF("Scan with %d components\r\n", SOS_section . n);

					kpn_channel_skip (c[0], SOS_section . n);

					scan_desc . bit_count = 0;
					for (index = 0; index < SOS_section . n; index++)
    5ac0:	0a000008 	beq	5ae8 <decoder+0xb70>
          {
						scan_desc . pred[index] = 0;
						scan_desc . table[HUFF_AC][index] =
              & tables[HUFF_AC][(SOS_component[index] . acdc >> 4) & 0x0f];
    5ac4:	e5dd1091 	ldrb	r1, [sp, #145]	; 0x91
					kpn_channel_skip (c[0], SOS_section . n);

					scan_desc . bit_count = 0;
					for (index = 0; index < SOS_section . n; index++)
          {
						scan_desc . pred[index] = 0;
    5ac8:	e58d20c4 	str	r2, [sp, #196]	; 0xc4
						scan_desc . table[HUFF_AC][index] =
              & tables[HUFF_AC][(SOS_component[index] . acdc >> 4) & 0x0f];
    5acc:	e1a02221 	lsr	r2, r1, #4
    5ad0:	e022e293 	mla	r2, r3, r2, lr
						scan_desc . table[HUFF_DC][index] =
              & tables[HUFF_DC][SOS_component[index] . acdc & 0x0f];
    5ad4:	e201100f 	and	r1, r1, #15
    5ad8:	e023e193 	mla	r3, r3, r1, lr
					scan_desc . bit_count = 0;
					for (index = 0; index < SOS_section . n; index++)
          {
						scan_desc . pred[index] = 0;
						scan_desc . table[HUFF_AC][index] =
              & tables[HUFF_AC][(SOS_component[index] . acdc >> 4) & 0x0f];
    5adc:	e2822e31 	add	r2, r2, #784	; 0x310

					scan_desc . bit_count = 0;
					for (index = 0; index < SOS_section . n; index++)
          {
						scan_desc . pred[index] = 0;
						scan_desc . table[HUFF_AC][index] =
    5ae0:	e58d20dc 	str	r2, [sp, #220]	; 0xdc
              & tables[HUFF_AC][(SOS_component[index] . acdc >> 4) & 0x0f];
						scan_desc . table[HUFF_DC][index] =
    5ae4:	e58d30d0 	str	r3, [sp, #208]	; 0xd0
              & tables[HUFF_DC][SOS_component[index] . acdc & 0x0f];
					}

					nb_MCU = intceil (SOF_section . height, MCU_sx) *
    5ae8:	e5dd3097 	ldrb	r3, [sp, #151]	; 0x97
    5aec:	e5dd2098 	ldrb	r2, [sp, #152]	; 0x98
            intceil (SOF_section . width, MCU_sy);
					IPRINTF("%d MCU to unpack\r\n", nb_MCU);
    5af0:	e59f05f0 	ldr	r0, [pc, #1520]	; 60e8 <decoder+0x1170>
              & tables[HUFF_AC][(SOS_component[index] . acdc >> 4) & 0x0f];
						scan_desc . table[HUFF_DC][index] =
              & tables[HUFF_DC][SOS_component[index] . acdc & 0x0f];
					}

					nb_MCU = intceil (SOF_section . height, MCU_sx) *
    5af4:	e1832402 	orr	r2, r3, r2, lsl #8
 * Utils
 */

static inline int32_t intceil (int32_t N, int32_t D)
{
	int32_t i = N / D;
    5af8:	e1a031c2 	asr	r3, r2, #3

	if (N > D * i) i++;
    5afc:	e1520183 	cmp	r2, r3, lsl #3
            intceil (SOF_section . width, MCU_sy);
    5b00:	e59d2098 	ldr	r2, [sp, #152]	; 0x98
    5b04:	c2833001 	addgt	r3, r3, #1
    5b08:	e1a02422 	lsr	r2, r2, #8
    5b0c:	e6ff2072 	uxth	r2, r2
              & tables[HUFF_AC][(SOS_component[index] . acdc >> 4) & 0x0f];
						scan_desc . table[HUFF_DC][index] =
              & tables[HUFF_DC][SOS_component[index] . acdc & 0x0f];
					}

					nb_MCU = intceil (SOF_section . height, MCU_sx) *
    5b10:	e6ff1073 	uxth	r1, r3
 * Utils
 */

static inline int32_t intceil (int32_t N, int32_t D)
{
	int32_t i = N / D;
    5b14:	e1a031c2 	asr	r3, r2, #3

	if (N > D * i) i++;
    5b18:	e1520183 	cmp	r2, r3, lsl #3
    5b1c:	c2833001 	addgt	r3, r3, #1
    5b20:	e1630183 	smulbb	r3, r3, r1
    5b24:	e6ff4073 	uxth	r4, r3
            intceil (SOF_section . width, MCU_sy);
					IPRINTF("%d MCU to unpack\r\n", nb_MCU);
    5b28:	e1a02004 	mov	r2, r4
    5b2c:	e59f15e0 	ldr	r1, [pc, #1504]	; 6114 <decoder+0x119c>
    5b30:	eb002927 	bl	ffd4 <printf>

					while (nb_MCU)
    5b34:	e3540000 	cmp	r4, #0
    5b38:	0a0002b6 	beq	6618 <decoder+0x16a0>

            computer (flit_size, FLIT, DECODED_FLIT);
            builder (SOF_section, YV, YH, flit_size, DECODED_FLIT,
                picture, & LB_X, & LB_Y);

						nb_MCU -= YV * nb_MCU_sx;
    5b3c:	e59dc03c 	ldr	ip, [sp, #60]	; 0x3c
    5b40:	e59de058 	ldr	lr, [sp, #88]	; 0x58
              sizeof(SOS_component_t)  * SOS_section . n);
					VPRINTF("Scan with %d components\r\n", SOS_section . n);

					kpn_channel_skip (c[0], SOS_section . n);

					scan_desc . bit_count = 0;
    5b44:	e3a09000 	mov	r9, #0

            computer (flit_size, FLIT, DECODED_FLIT);
            builder (SOF_section, YV, YH, flit_size, DECODED_FLIT,
                picture, & LB_X, & LB_Y);

						nb_MCU -= YV * nb_MCU_sx;
    5b48:	e1630e8c 	smulbb	r3, ip, lr
    5b4c:	e6ff3073 	uxth	r3, r3
    5b50:	e0634004 	rsb	r4, r3, r4
    5b54:	e58d3064 	str	r3, [sp, #100]	; 0x64
    5b58:	e1a0300a 	mov	r3, sl
            intceil (SOF_section . width, MCU_sy);
					IPRINTF("%d MCU to unpack\r\n", nb_MCU);

					while (nb_MCU)
          {
						for (uint32_t step = 0; step < flit_size; step += mcu_size)
    5b5c:	e1a08009 	mov	r8, r9
    5b60:	e1a0a009 	mov	sl, r9
    5b64:	e1a09003 	mov	r9, r3
    5b68:	e59de050 	ldr	lr, [sp, #80]	; 0x50
    5b6c:	e6ff4074 	uxth	r4, r4
    5b70:	e00c0e9c 	mul	ip, ip, lr
    5b74:	e58d4044 	str	r4, [sp, #68]	; 0x44
    5b78:	e58dc054 	str	ip, [sp, #84]	; 0x54
    5b7c:	e59dc030 	ldr	ip, [sp, #48]	; 0x30
    5b80:	e35c0000 	cmp	ip, #0
    5b84:	0a0001ee 	beq	6344 <decoder+0x13cc>
    5b88:	e3a03000 	mov	r3, #0
    5b8c:	e58d3034 	str	r3, [sp, #52]	; 0x34
            {
							for (index = 0; index < YV * YH; index++)
    5b90:	e59dc054 	ldr	ip, [sp, #84]	; 0x54
    5b94:	e35c0000 	cmp	ip, #0
    5b98:	0a0000bf 	beq	5e9c <decoder+0xf24>
    5b9c:	e3a03000 	mov	r3, #0
    5ba0:	e1a0c009 	mov	ip, r9
    5ba4:	e58d3038 	str	r3, [sp, #56]	; 0x38
    5ba8:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	uint8_t temp = 0;
	int32_t code = 0;
	uint32_t length = 0, index = 0;
	huff_table_t * HT = scan_desc -> table[acdc][component];

	for (length = 0; length < 16; length++)
    5bac:	e3a07000 	mov	r7, #0
              {
								unpack_block (c[0], & scan_desc, 0, MCU);
    5bb0:	e59de024 	ldr	lr, [sp, #36]	; 0x24
{
	uint32_t temp = 0, i = 0, run = 0, cat = 0;
	int32_t value = 0;
	uint8_t symbol = 0;

	memset ((void *) T, 0, 64 * sizeof (int32_t));
    5bb4:	e28d0e1e 	add	r0, sp, #480	; 0x1e0
    5bb8:	e1a01007 	mov	r1, r7
    5bbc:	e3a02c01 	mov	r2, #256	; 0x100
    5bc0:	e59e6000 	ldr	r6, [lr]
    5bc4:	e58dc01c 	str	ip, [sp, #28]
    5bc8:	eb00284a 	bl	fcf8 <memset>
    uint32_t acdc, uint32_t component)
{
	uint8_t temp = 0;
	int32_t code = 0;
	uint32_t length = 0, index = 0;
	huff_table_t * HT = scan_desc -> table[acdc][component];
    5bcc:	e59d50c8 	ldr	r5, [sp, #200]	; 0xc8
    5bd0:	e59dc01c 	ldr	ip, [sp, #28]

static inline uint8_t get_symbol (kpn_channel_t channel, scan_desc_t *scan_desc,
    uint32_t acdc, uint32_t component)
{
	uint8_t temp = 0;
	int32_t code = 0;
    5bd4:	e1a04007 	mov	r4, r7
    5bd8:	e1a09005 	mov	r9, r5
    5bdc:	e1a0300c 	mov	r3, ip
    5be0:	ea00000b 	b	5c14 <decoder+0xc9c>
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
    5be4:	e1a013a3 	lsr	r1, r3, #7
	huff_table_t * HT = scan_desc -> table[acdc][component];

	for (length = 0; length < 16; length++)
  {
		temp = get_bits (channel, scan_desc, 1);
		code = (2 * code) | temp;
    5be8:	e6ef1071 	uxtb	r1, r1
		if (code <= HT -> MaxCode[length]) break;
    5bec:	e5992080 	ldr	r2, [r9, #128]	; 0x80
	huff_table_t * HT = scan_desc -> table[acdc][component];

	for (length = 0; length < 16; length++)
  {
		temp = get_bits (channel, scan_desc, 1);
		code = (2 * code) | temp;
    5bf0:	e1814084 	orr	r4, r1, r4, lsl #1
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
    5bf4:	e1a03083 	lsl	r3, r3, #1

	for (length = 0; length < 16; length++)
  {
		temp = get_bits (channel, scan_desc, 1);
		code = (2 * code) | temp;
		if (code <= HT -> MaxCode[length]) break;
    5bf8:	e1540002 	cmp	r4, r2
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
    5bfc:	e6ef3073 	uxtb	r3, r3

	for (length = 0; length < 16; length++)
  {
		temp = get_bits (channel, scan_desc, 1);
		code = (2 * code) | temp;
		if (code <= HT -> MaxCode[length]) break;
    5c00:	da000220 	ble	6488 <decoder+0x1510>
	uint8_t temp = 0;
	int32_t code = 0;
	uint32_t length = 0, index = 0;
	huff_table_t * HT = scan_desc -> table[acdc][component];

	for (length = 0; length < 16; length++)
    5c04:	e2877001 	add	r7, r7, #1
    5c08:	e3570010 	cmp	r7, #16
    5c0c:	e2899004 	add	r9, r9, #4
    5c10:	0a000014 	beq	5c68 <decoder+0xcf0>

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
  {
		if (scan_desc -> bit_count == 0)
    5c14:	e35a0000 	cmp	sl, #0
    5c18:	e24aa001 	sub	sl, sl, #1
static inline uint32_t get_bits (kpn_channel_t channel,
    scan_desc_t *scan_desc, uint8_t number)
{
	int32_t i = 0, newbit = 0;
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;
    5c1c:	e5cd8070 	strb	r8, [sp, #112]	; 0x70
    5c20:	e5cd8071 	strb	r8, [sp, #113]	; 0x71
    5c24:	16efa07a 	uxtbne	sl, sl

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
  {
		if (scan_desc -> bit_count == 0)
    5c28:	1affffed 	bne	5be4 <decoder+0xc6c>
    {
			kpn_channel_read (channel, & wwindow, 1);
    5c2c:	e1a00006 	mov	r0, r6
    5c30:	e28d1070 	add	r1, sp, #112	; 0x70
    5c34:	e3a02001 	mov	r2, #1
    5c38:	ebffea98 	bl	6a0 <kpn_channel_read>
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
    5c3c:	e5dd3070 	ldrb	r3, [sp, #112]	; 0x70
    5c40:	e35300ff 	cmp	r3, #255	; 0xff
    5c44:	13a0a007 	movne	sl, #7
    5c48:	1affffe5 	bne	5be4 <decoder+0xc6c>
    5c4c:	e1a00006 	mov	r0, r6
    5c50:	e28d1071 	add	r1, sp, #113	; 0x71
    5c54:	e3a02001 	mov	r2, #1
    5c58:	ebffea90 	bl	6a0 <kpn_channel_read>
    5c5c:	e3a0a007 	mov	sl, #7
    5c60:	e5dd3070 	ldrb	r3, [sp, #112]	; 0x70
    5c64:	eaffffde 	b	5be4 <decoder+0xc6c>
    5c68:	e1a0c003 	mov	ip, r3

static inline int32_t reformat (uint32_t S, int32_t good)
{
	int32_t St = 0;

	if (good == 0) return 0;
    5c6c:	e3a05000 	mov	r5, #0
	value += scan_desc -> pred[index];
	scan_desc -> pred[index] = value;

	T[0] = value ;

	for (i = 1; i < 64; i++)
    5c70:	e3a07001 	mov	r7, #1
	memset ((void *) T, 0, 64 * sizeof (int32_t));
	symbol = get_symbol (channel, scan_desc, HUFF_DC, index);
	temp = get_bits (channel, scan_desc, symbol);

	value = reformat (temp, symbol);
	value += scan_desc -> pred[index];
    5c74:	e59d30bc 	ldr	r3, [sp, #188]	; 0xbc
    5c78:	e0855003 	add	r5, r5, r3
    5c7c:	e59d30d4 	ldr	r3, [sp, #212]	; 0xd4
	scan_desc -> pred[index] = value;
    5c80:	e58d50bc 	str	r5, [sp, #188]	; 0xbc
    5c84:	e58d3028 	str	r3, [sp, #40]	; 0x28

	T[0] = value ;
    5c88:	e58d51e0 	str	r5, [sp, #480]	; 0x1e0
	uint8_t temp = 0;
	int32_t code = 0;
	uint32_t length = 0, index = 0;
	huff_table_t * HT = scan_desc -> table[acdc][component];

	for (length = 0; length < 16; length++)
    5c8c:	e3a09000 	mov	r9, #0
    5c90:	e59d5028 	ldr	r5, [sp, #40]	; 0x28

static inline uint8_t get_symbol (kpn_channel_t channel, scan_desc_t *scan_desc,
    uint32_t acdc, uint32_t component)
{
	uint8_t temp = 0;
	int32_t code = 0;
    5c94:	e1a04009 	mov	r4, r9
    5c98:	ea00000b 	b	5ccc <decoder+0xd54>
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
    5c9c:	e1a023ac 	lsr	r2, ip, #7
	huff_table_t * HT = scan_desc -> table[acdc][component];

	for (length = 0; length < 16; length++)
  {
		temp = get_bits (channel, scan_desc, 1);
		code = (2 * code) | temp;
    5ca0:	e6ef2072 	uxtb	r2, r2
		if (code <= HT -> MaxCode[length]) break;
    5ca4:	e5953080 	ldr	r3, [r5, #128]	; 0x80
	huff_table_t * HT = scan_desc -> table[acdc][component];

	for (length = 0; length < 16; length++)
  {
		temp = get_bits (channel, scan_desc, 1);
		code = (2 * code) | temp;
    5ca8:	e1824084 	orr	r4, r2, r4, lsl #1
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
    5cac:	e1a0c08c 	lsl	ip, ip, #1

	for (length = 0; length < 16; length++)
  {
		temp = get_bits (channel, scan_desc, 1);
		code = (2 * code) | temp;
		if (code <= HT -> MaxCode[length]) break;
    5cb0:	e1540003 	cmp	r4, r3
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
    5cb4:	e6efc07c 	uxtb	ip, ip

	for (length = 0; length < 16; length++)
  {
		temp = get_bits (channel, scan_desc, 1);
		code = (2 * code) | temp;
		if (code <= HT -> MaxCode[length]) break;
    5cb8:	da000018 	ble	5d20 <decoder+0xda8>
	uint8_t temp = 0;
	int32_t code = 0;
	uint32_t length = 0, index = 0;
	huff_table_t * HT = scan_desc -> table[acdc][component];

	for (length = 0; length < 16; length++)
    5cbc:	e2899001 	add	r9, r9, #1
    5cc0:	e3590010 	cmp	r9, #16
    5cc4:	e2855004 	add	r5, r5, #4
    5cc8:	0a000058 	beq	5e30 <decoder+0xeb8>

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
  {
		if (scan_desc -> bit_count == 0)
    5ccc:	e35a0000 	cmp	sl, #0
    5cd0:	e24aa001 	sub	sl, sl, #1
static inline uint32_t get_bits (kpn_channel_t channel,
    scan_desc_t *scan_desc, uint8_t number)
{
	int32_t i = 0, newbit = 0;
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;
    5cd4:	e5cd8070 	strb	r8, [sp, #112]	; 0x70
    5cd8:	e5cd8071 	strb	r8, [sp, #113]	; 0x71
    5cdc:	16efa07a 	uxtbne	sl, sl

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
  {
		if (scan_desc -> bit_count == 0)
    5ce0:	1affffed 	bne	5c9c <decoder+0xd24>
    {
			kpn_channel_read (channel, & wwindow, 1);
    5ce4:	e1a00006 	mov	r0, r6
    5ce8:	e28d1070 	add	r1, sp, #112	; 0x70
    5cec:	e3a02001 	mov	r2, #1
    5cf0:	ebffea6a 	bl	6a0 <kpn_channel_read>
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
    5cf4:	e5ddc070 	ldrb	ip, [sp, #112]	; 0x70
    5cf8:	e35c00ff 	cmp	ip, #255	; 0xff
    5cfc:	13a0a007 	movne	sl, #7
    5d00:	1affffe5 	bne	5c9c <decoder+0xd24>
    5d04:	e1a00006 	mov	r0, r6
    5d08:	e28d1071 	add	r1, sp, #113	; 0x71
    5d0c:	e3a02001 	mov	r2, #1
    5d10:	ebffea62 	bl	6a0 <kpn_channel_read>
    5d14:	e3a0a007 	mov	sl, #7
    5d18:	e5ddc070 	ldrb	ip, [sp, #112]	; 0x70
    5d1c:	eaffffde 	b	5c9c <decoder+0xd24>
    5d20:	e59de028 	ldr	lr, [sp, #40]	; 0x28
    5d24:	e08e3109 	add	r3, lr, r9, lsl #2
		if (code <= HT -> MaxCode[length]) break;
	}

	if (length != 16)
  {
		index = HT -> ValPtr[length] + code - HT -> MinCode[length];
    5d28:	e79e2109 	ldr	r2, [lr, r9, lsl #2]
    5d2c:	e5933040 	ldr	r3, [r3, #64]	; 0x40
    5d30:	e0844002 	add	r4, r4, r2
    5d34:	e0633004 	rsb	r3, r3, r4
		if (index < MAX_SIZE(acdc)) return HT -> table[index];
    5d38:	e35300a1 	cmp	r3, #161	; 0xa1
    5d3c:	8a00003b 	bhi	5e30 <decoder+0xeb8>
    5d40:	e59e20c0 	ldr	r2, [lr, #192]	; 0xc0
    5d44:	e7d22003 	ldrb	r2, [r2, r3]

	for (i = 1; i < 64; i++)
  {
		symbol = get_symbol (channel, scan_desc, HUFF_AC, index);

		if (symbol == HUFF_EOB) 
    5d48:	e3520000 	cmp	r2, #0
    5d4c:	0a000037 	beq	5e30 <decoder+0xeb8>
    {
			break;
		}

		if (symbol == HUFF_ZRL)
    5d50:	e35200f0 	cmp	r2, #240	; 0xf0
    {
			i += 15;
    5d54:	0287700f 	addeq	r7, r7, #15
		if (symbol == HUFF_EOB) 
    {
			break;
		}

		if (symbol == HUFF_ZRL)
    5d58:	0a000031 	beq	5e24 <decoder+0xeac>
{
	int32_t i = 0, newbit = 0;
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;

	if (number == 0) return 0;
    5d5c:	e212300f 	ands	r3, r2, #15
			continue;
		}

		cat = symbol & 15;
		run = (symbol >> 4) & 15;
		i += run;
    5d60:	e0877222 	add	r7, r7, r2, lsr #4
static inline uint32_t get_bits (kpn_channel_t channel,
    scan_desc_t *scan_desc, uint8_t number)
{
	int32_t i = 0, newbit = 0;
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;
    5d64:	e5cd806e 	strb	r8, [sp, #110]	; 0x6e
    5d68:	e5cd806f 	strb	r8, [sp, #111]	; 0x6f

	if (number == 0) return 0;
    5d6c:	0a000029 	beq	5e18 <decoder+0xea0>

	for (i = 0; i < number; i++)
    5d70:	e3a04000 	mov	r4, #0

static inline uint32_t get_bits (kpn_channel_t channel,
    scan_desc_t *scan_desc, uint8_t number)
{
	int32_t i = 0, newbit = 0;
	uint32_t result = 0;
    5d74:	e1a05003 	mov	r5, r3
    5d78:	e1a09004 	mov	r9, r4
    5d7c:	e1a0200c 	mov	r2, ip
    5d80:	ea000007 	b	5da4 <decoder+0xe2c>
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
    5d84:	e1a033a2 	lsr	r3, r2, #7
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
    5d88:	e2844001 	add	r4, r4, #1
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
		scan_desc -> bit_count -= 1;
		result = (result << 1) | newbit;
    5d8c:	e6ef3073 	uxtb	r3, r3
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
    5d90:	e1a02082 	lsl	r2, r2, #1
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
    5d94:	e1540005 	cmp	r4, r5
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
		scan_desc -> bit_count -= 1;
		result = (result << 1) | newbit;
    5d98:	e1839089 	orr	r9, r3, r9, lsl #1
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
    5d9c:	e6ef2072 	uxtb	r2, r2
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
    5da0:	aa000013 	bge	5df4 <decoder+0xe7c>
  {
		if (scan_desc -> bit_count == 0)
    5da4:	e35a0000 	cmp	sl, #0
    5da8:	e24aa001 	sub	sl, sl, #1
    {
			kpn_channel_read (channel, & wwindow, 1);
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;
    5dac:	15cd206e 	strbne	r2, [sp, #110]	; 0x6e
    5db0:	16efa07a 	uxtbne	sl, sl

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
  {
		if (scan_desc -> bit_count == 0)
    5db4:	1afffff2 	bne	5d84 <decoder+0xe0c>
    {
			kpn_channel_read (channel, & wwindow, 1);
    5db8:	e3a02001 	mov	r2, #1
    5dbc:	e1a00006 	mov	r0, r6
    5dc0:	e28d106e 	add	r1, sp, #110	; 0x6e
    5dc4:	ebffea35 	bl	6a0 <kpn_channel_read>
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
    5dc8:	e5dd206e 	ldrb	r2, [sp, #110]	; 0x6e
    5dcc:	e35200ff 	cmp	r2, #255	; 0xff
    5dd0:	13a0a007 	movne	sl, #7
    5dd4:	1affffea 	bne	5d84 <decoder+0xe0c>
    5dd8:	e3a02001 	mov	r2, #1
    5ddc:	e1a00006 	mov	r0, r6
    5de0:	e28d106f 	add	r1, sp, #111	; 0x6f
    5de4:	ebffea2d 	bl	6a0 <kpn_channel_read>
    5de8:	e3a0a007 	mov	sl, #7
    5dec:	e5dd206e 	ldrb	r2, [sp, #110]	; 0x6e
    5df0:	eaffffe3 	b	5d84 <decoder+0xe0c>
	St = 1 << (good - 1);	/* 2^(good-1) */

	if (S < St) return (S + 1 + ((-1) << good));
    5df4:	e3a00001 	mov	r0, #1
    5df8:	e1a0c002 	mov	ip, r2
static inline int32_t reformat (uint32_t S, int32_t good)
{
	int32_t St = 0;

	if (good == 0) return 0;
	St = 1 << (good - 1);	/* 2^(good-1) */
    5dfc:	e2452001 	sub	r2, r5, #1

	if (S < St) return (S + 1 + ((-1) << good));
    5e00:	e1590210 	cmp	r9, r0, lsl r2
    5e04:	33e01000 	mvncc	r1, #0
    5e08:	e1a03005 	mov	r3, r5
	else return S;
    5e0c:	21a03009 	movcs	r3, r9
	int32_t St = 0;

	if (good == 0) return 0;
	St = 1 << (good - 1);	/* 2^(good-1) */

	if (S < St) return (S + 1 + ((-1) << good));
    5e10:	30893511 	addcc	r3, r9, r1, lsl r5
    5e14:	30833000 	addcc	r3, r3, r0
		cat = symbol & 15;
		run = (symbol >> 4) & 15;
		i += run;
		temp = get_bits (channel, scan_desc, cat);
		value = reformat(temp, cat);
		T[i] = value ;    
    5e18:	e28dec09 	add	lr, sp, #2304	; 0x900
    5e1c:	e08e2107 	add	r2, lr, r7, lsl #2
    5e20:	e5023720 	str	r3, [r2, #-1824]	; 0x720
	value += scan_desc -> pred[index];
	scan_desc -> pred[index] = value;

	T[0] = value ;

	for (i = 1; i < 64; i++)
    5e24:	e2877001 	add	r7, r7, #1
    5e28:	e357003f 	cmp	r7, #63	; 0x3f
    5e2c:	9affff96 	bls	5c8c <decoder+0xd14>
static inline void iqzz_block(int32_t in[64],
    int32_t out[64], uint8_t table[64])
{
	uint32_t index;

	for( index = 0; index < 64 ; index++)
    5e30:	e3a03000 	mov	r3, #0
								iqzz_block (MCU, & FLIT[(step + index) * 64],
    5e34:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
    5e38:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
    5e3c:	e59d2040 	ldr	r2, [sp, #64]	; 0x40
                    DQT_table[SOF_component[0] . q_table]);
    5e40:	e5dd409e 	ldrb	r4, [sp, #158]	; 0x9e
						for (uint32_t step = 0; step < flit_size; step += mcu_size)
            {
							for (index = 0; index < YV * YH; index++)
              {
								unpack_block (c[0], & scan_desc, 0, MCU);
								iqzz_block (MCU, & FLIT[(step + index) * 64],
    5e44:	e0805001 	add	r5, r0, r1
                    DQT_table[SOF_component[0] . q_table]);
    5e48:	e28de0e0 	add	lr, sp, #224	; 0xe0
						for (uint32_t step = 0; step < flit_size; step += mcu_size)
            {
							for (index = 0; index < YV * YH; index++)
              {
								unpack_block (c[0], & scan_desc, 0, MCU);
								iqzz_block (MCU, & FLIT[(step + index) * 64],
    5e4c:	e0825405 	add	r5, r2, r5, lsl #8
                    DQT_table[SOF_component[0] . q_table]);
    5e50:	e08e4304 	add	r4, lr, r4, lsl #6
    5e54:	e28d2f77 	add	r2, sp, #476	; 0x1dc
  {
		out[G_ZZ[index]] = in[index] * table[index];
    5e58:	e7d4e003 	ldrb	lr, [r4, r3]
    5e5c:	e5b20004 	ldr	r0, [r2, #4]!
    5e60:	e7db1003 	ldrb	r1, [fp, r3]
    5e64:	e000009e 	mul	r0, lr, r0
static inline void iqzz_block(int32_t in[64],
    int32_t out[64], uint8_t table[64])
{
	uint32_t index;

	for( index = 0; index < 64 ; index++)
    5e68:	e2833001 	add	r3, r3, #1
    5e6c:	e3530040 	cmp	r3, #64	; 0x40
  {
		out[G_ZZ[index]] = in[index] * table[index];
    5e70:	e7850101 	str	r0, [r5, r1, lsl #2]
static inline void iqzz_block(int32_t in[64],
    int32_t out[64], uint8_t table[64])
{
	uint32_t index;

	for( index = 0; index < 64 ; index++)
    5e74:	1afffff7 	bne	5e58 <decoder+0xee0>

					while (nb_MCU)
          {
						for (uint32_t step = 0; step < flit_size; step += mcu_size)
            {
							for (index = 0; index < YV * YH; index++)
    5e78:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
    5e7c:	e59d2054 	ldr	r2, [sp, #84]	; 0x54
    5e80:	e2813001 	add	r3, r1, #1
    5e84:	e6ef3073 	uxtb	r3, r3
    5e88:	e1530002 	cmp	r3, r2
    5e8c:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    5e90:	e58d3038 	str	r3, [sp, #56]	; 0x38
    5e94:	3affff44 	bcc	5bac <decoder+0xc34>
    5e98:	e1a0900c 	mov	r9, ip
								unpack_block (c[0], & scan_desc, 0, MCU);
								iqzz_block (MCU, & FLIT[(step + index) * 64],
                    DQT_table[SOF_component[0] . q_table]);
							}

							for (index =  1; index < SOF_section . n; index++)
    5e9c:	e5dd309b 	ldrb	r3, [sp, #155]	; 0x9b
    5ea0:	e3530001 	cmp	r3, #1
    5ea4:	9a00011f 	bls	6328 <decoder+0x13b0>
    5ea8:	e3a03001 	mov	r3, #1
    5eac:	e59dc034 	ldr	ip, [sp, #52]	; 0x34
    5eb0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
    5eb4:	e24c337f 	sub	r3, ip, #-67108863	; 0xfc000001
    5eb8:	e59dc054 	ldr	ip, [sp, #84]	; 0x54
    5ebc:	e083300c 	add	r3, r3, ip
    5ec0:	e1a0c009 	mov	ip, r9
    5ec4:	e58d3038 	str	r3, [sp, #56]	; 0x38
	uint8_t temp = 0;
	int32_t code = 0;
	uint32_t length = 0, index = 0;
	huff_table_t * HT = scan_desc -> table[acdc][component];

	for (length = 0; length < 16; length++)
    5ec8:	e3a07000 	mov	r7, #0
              {
								unpack_block (c[0], & scan_desc, index, MCU);
    5ecc:	e59de024 	ldr	lr, [sp, #36]	; 0x24
{
	uint32_t temp = 0, i = 0, run = 0, cat = 0;
	int32_t value = 0;
	uint8_t symbol = 0;

	memset ((void *) T, 0, 64 * sizeof (int32_t));
    5ed0:	e1a01007 	mov	r1, r7
    5ed4:	e28d0e1e 	add	r0, sp, #480	; 0x1e0
    5ed8:	e3a02c01 	mov	r2, #256	; 0x100
    5edc:	e59e6000 	ldr	r6, [lr]
    5ee0:	e58dc01c 	str	ip, [sp, #28]
    5ee4:	eb002783 	bl	fcf8 <memset>
    uint32_t acdc, uint32_t component)
{
	uint8_t temp = 0;
	int32_t code = 0;
	uint32_t length = 0, index = 0;
	huff_table_t * HT = scan_desc -> table[acdc][component];
    5ee8:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    5eec:	e28d1c09 	add	r1, sp, #2304	; 0x900
    5ef0:	e0813100 	add	r3, r1, r0, lsl #2
    5ef4:	e5135838 	ldr	r5, [r3, #-2104]	; 0x838
    5ef8:	e59dc01c 	ldr	ip, [sp, #28]

static inline uint8_t get_symbol (kpn_channel_t channel, scan_desc_t *scan_desc,
    uint32_t acdc, uint32_t component)
{
	uint8_t temp = 0;
	int32_t code = 0;
    5efc:	e1a04007 	mov	r4, r7
    5f00:	e1a09005 	mov	r9, r5
    5f04:	e1a0300c 	mov	r3, ip
    5f08:	ea00000b 	b	5f3c <decoder+0xfc4>
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
    5f0c:	e1a013a3 	lsr	r1, r3, #7
	huff_table_t * HT = scan_desc -> table[acdc][component];

	for (length = 0; length < 16; length++)
  {
		temp = get_bits (channel, scan_desc, 1);
		code = (2 * code) | temp;
    5f10:	e6ef1071 	uxtb	r1, r1
		if (code <= HT -> MaxCode[length]) break;
    5f14:	e5992080 	ldr	r2, [r9, #128]	; 0x80
	huff_table_t * HT = scan_desc -> table[acdc][component];

	for (length = 0; length < 16; length++)
  {
		temp = get_bits (channel, scan_desc, 1);
		code = (2 * code) | temp;
    5f18:	e1814084 	orr	r4, r1, r4, lsl #1
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
    5f1c:	e1a03083 	lsl	r3, r3, #1

	for (length = 0; length < 16; length++)
  {
		temp = get_bits (channel, scan_desc, 1);
		code = (2 * code) | temp;
		if (code <= HT -> MaxCode[length]) break;
    5f20:	e1540002 	cmp	r4, r2
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
    5f24:	e6ef3073 	uxtb	r3, r3

	for (length = 0; length < 16; length++)
  {
		temp = get_bits (channel, scan_desc, 1);
		code = (2 * code) | temp;
		if (code <= HT -> MaxCode[length]) break;
    5f28:	da000120 	ble	63b0 <decoder+0x1438>
	uint8_t temp = 0;
	int32_t code = 0;
	uint32_t length = 0, index = 0;
	huff_table_t * HT = scan_desc -> table[acdc][component];

	for (length = 0; length < 16; length++)
    5f2c:	e2877001 	add	r7, r7, #1
    5f30:	e3570010 	cmp	r7, #16
    5f34:	e2899004 	add	r9, r9, #4
    5f38:	0a000014 	beq	5f90 <decoder+0x1018>

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
  {
		if (scan_desc -> bit_count == 0)
    5f3c:	e35a0000 	cmp	sl, #0
    5f40:	e24aa001 	sub	sl, sl, #1
static inline uint32_t get_bits (kpn_channel_t channel,
    scan_desc_t *scan_desc, uint8_t number)
{
	int32_t i = 0, newbit = 0;
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;
    5f44:	e5cd8070 	strb	r8, [sp, #112]	; 0x70
    5f48:	e5cd8071 	strb	r8, [sp, #113]	; 0x71
    5f4c:	16efa07a 	uxtbne	sl, sl

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
  {
		if (scan_desc -> bit_count == 0)
    5f50:	1affffed 	bne	5f0c <decoder+0xf94>
    {
			kpn_channel_read (channel, & wwindow, 1);
    5f54:	e1a00006 	mov	r0, r6
    5f58:	e28d1070 	add	r1, sp, #112	; 0x70
    5f5c:	e3a02001 	mov	r2, #1
    5f60:	ebffe9ce 	bl	6a0 <kpn_channel_read>
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
    5f64:	e5dd3070 	ldrb	r3, [sp, #112]	; 0x70
    5f68:	e35300ff 	cmp	r3, #255	; 0xff
    5f6c:	13a0a007 	movne	sl, #7
    5f70:	1affffe5 	bne	5f0c <decoder+0xf94>
    5f74:	e1a00006 	mov	r0, r6
    5f78:	e28d1071 	add	r1, sp, #113	; 0x71
    5f7c:	e3a02001 	mov	r2, #1
    5f80:	ebffe9c6 	bl	6a0 <kpn_channel_read>
    5f84:	e3a0a007 	mov	sl, #7
    5f88:	e5dd3070 	ldrb	r3, [sp, #112]	; 0x70
    5f8c:	eaffffde 	b	5f0c <decoder+0xf94>
    5f90:	e1a0c003 	mov	ip, r3

static inline int32_t reformat (uint32_t S, int32_t good)
{
	int32_t St = 0;

	if (good == 0) return 0;
    5f94:	e3a05000 	mov	r5, #0
	value += scan_desc -> pred[index];
	scan_desc -> pred[index] = value;

	T[0] = value ;

	for (i = 1; i < 64; i++)
    5f98:	e3a07001 	mov	r7, #1
	memset ((void *) T, 0, 64 * sizeof (int32_t));
	symbol = get_symbol (channel, scan_desc, HUFF_DC, index);
	temp = get_bits (channel, scan_desc, symbol);

	value = reformat (temp, symbol);
	value += scan_desc -> pred[index];
    5f9c:	e59de02c 	ldr	lr, [sp, #44]	; 0x2c
    5fa0:	e28d0c09 	add	r0, sp, #2304	; 0x900
    5fa4:	e080310e 	add	r3, r0, lr, lsl #2
    5fa8:	e5132844 	ldr	r2, [r3, #-2116]	; 0x844
    5fac:	e0855002 	add	r5, r5, r2
    5fb0:	e513282c 	ldr	r2, [r3, #-2092]	; 0x82c
	scan_desc -> pred[index] = value;
    5fb4:	e5035844 	str	r5, [r3, #-2116]	; 0x844
    5fb8:	e58d2028 	str	r2, [sp, #40]	; 0x28

	T[0] = value ;
    5fbc:	e58d51e0 	str	r5, [sp, #480]	; 0x1e0
	uint8_t temp = 0;
	int32_t code = 0;
	uint32_t length = 0, index = 0;
	huff_table_t * HT = scan_desc -> table[acdc][component];

	for (length = 0; length < 16; length++)
    5fc0:	e3a09000 	mov	r9, #0
    5fc4:	e59d5028 	ldr	r5, [sp, #40]	; 0x28

static inline uint8_t get_symbol (kpn_channel_t channel, scan_desc_t *scan_desc,
    uint32_t acdc, uint32_t component)
{
	uint8_t temp = 0;
	int32_t code = 0;
    5fc8:	e1a04009 	mov	r4, r9
    5fcc:	ea00005f 	b	6150 <decoder+0x11d8>
    5fd0:	00023db0 	.word	0x00023db0
    5fd4:	00023dc8 	.word	0x00023dc8
    5fd8:	00023d34 	.word	0x00023d34
    5fdc:	00024604 	.word	0x00024604
    5fe0:	000245b0 	.word	0x000245b0
    5fe4:	00024590 	.word	0x00024590
    5fe8:	00024574 	.word	0x00024574
    5fec:	00024554 	.word	0x00024554
    5ff0:	000245e8 	.word	0x000245e8
    5ff4:	00024534 	.word	0x00024534
    5ff8:	00024514 	.word	0x00024514
    5ffc:	000244f4 	.word	0x000244f4
    6000:	000244d4 	.word	0x000244d4
    6004:	000244b8 	.word	0x000244b8
    6008:	0002449c 	.word	0x0002449c
    600c:	00024480 	.word	0x00024480
    6010:	00024464 	.word	0x00024464
    6014:	00024448 	.word	0x00024448
    6018:	0002442c 	.word	0x0002442c
    601c:	00024410 	.word	0x00024410
    6020:	000243f4 	.word	0x000243f4
    6024:	000243d8 	.word	0x000243d8
    6028:	000243a0 	.word	0x000243a0
    602c:	fffff7a8 	.word	0xfffff7a8
    6030:	fffff7b2 	.word	0xfffff7b2
    6034:	fffff7b4 	.word	0xfffff7b4
    6038:	000243bc 	.word	0x000243bc
    603c:	00024384 	.word	0x00024384
    6040:	00024368 	.word	0x00024368
    6044:	000240e4 	.word	0x000240e4
    6048:	000240c4 	.word	0x000240c4
    604c:	000240a8 	.word	0x000240a8
    6050:	00024088 	.word	0x00024088
    6054:	00024068 	.word	0x00024068
    6058:	0002404c 	.word	0x0002404c
    605c:	00024030 	.word	0x00024030
    6060:	00024014 	.word	0x00024014
    6064:	00023ff8 	.word	0x00023ff8
    6068:	00023fdc 	.word	0x00023fdc
    606c:	00023f24 	.word	0x00023f24
    6070:	fffff77c 	.word	0xfffff77c
    6074:	00023f40 	.word	0x00023f40
    6078:	00023d9c 	.word	0x00023d9c
    607c:	00023d98 	.word	0x00023d98
    6080:	00023f64 	.word	0x00023f64
    6084:	00023f88 	.word	0x00023f88
    6088:	00023f08 	.word	0x00023f08
    608c:	00023eec 	.word	0x00023eec
    6090:	00023ed0 	.word	0x00023ed0
    6094:	00023e18 	.word	0x00023e18
    6098:	fffff794 	.word	0xfffff794
    609c:	00023e34 	.word	0x00023e34
    60a0:	00023e54 	.word	0x00023e54
    60a4:	00023e70 	.word	0x00023e70
    60a8:	00023e8c 	.word	0x00023e8c
    60ac:	00023ea8 	.word	0x00023ea8
    60b0:	000245cc 	.word	0x000245cc
    60b4:	00023d20 	.word	0x00023d20
    60b8:	00023fa8 	.word	0x00023fa8
    60bc:	000241cc 	.word	0x000241cc
    60c0:	000241b0 	.word	0x000241b0
    60c4:	00024194 	.word	0x00024194
    60c8:	00024178 	.word	0x00024178
    60cc:	0002415c 	.word	0x0002415c
    60d0:	00024140 	.word	0x00024140
    60d4:	00024124 	.word	0x00024124
    60d8:	00024104 	.word	0x00024104
    60dc:	0002423c 	.word	0x0002423c
    60e0:	fffff780 	.word	0xfffff780
    60e4:	00024258 	.word	0x00024258
    60e8:	0002427c 	.word	0x0002427c
    60ec:	00024204 	.word	0x00024204
    60f0:	00024330 	.word	0x00024330
    60f4:	00024298 	.word	0x00024298
    60f8:	fffff778 	.word	0xfffff778
    60fc:	00023da0 	.word	0x00023da0
    6100:	00023da8 	.word	0x00023da8
    6104:	000242b4 	.word	0x000242b4
    6108:	000242dc 	.word	0x000242dc
    610c:	00024308 	.word	0x00024308
    6110:	0002434c 	.word	0x0002434c
    6114:	00023d18 	.word	0x00023d18
    6118:	00024220 	.word	0x00024220
    611c:	000241e8 	.word	0x000241e8
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
    6120:	e1a023ac 	lsr	r2, ip, #7
	huff_table_t * HT = scan_desc -> table[acdc][component];

	for (length = 0; length < 16; length++)
  {
		temp = get_bits (channel, scan_desc, 1);
		code = (2 * code) | temp;
    6124:	e6ef2072 	uxtb	r2, r2
		if (code <= HT -> MaxCode[length]) break;
    6128:	e5953080 	ldr	r3, [r5, #128]	; 0x80
	huff_table_t * HT = scan_desc -> table[acdc][component];

	for (length = 0; length < 16; length++)
  {
		temp = get_bits (channel, scan_desc, 1);
		code = (2 * code) | temp;
    612c:	e1824084 	orr	r4, r2, r4, lsl #1
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
    6130:	e1a0c08c 	lsl	ip, ip, #1

	for (length = 0; length < 16; length++)
  {
		temp = get_bits (channel, scan_desc, 1);
		code = (2 * code) | temp;
		if (code <= HT -> MaxCode[length]) break;
    6134:	e1540003 	cmp	r4, r3
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
    6138:	e6efc07c 	uxtb	ip, ip

	for (length = 0; length < 16; length++)
  {
		temp = get_bits (channel, scan_desc, 1);
		code = (2 * code) | temp;
		if (code <= HT -> MaxCode[length]) break;
    613c:	da000018 	ble	61a4 <decoder+0x122c>
	uint8_t temp = 0;
	int32_t code = 0;
	uint32_t length = 0, index = 0;
	huff_table_t * HT = scan_desc -> table[acdc][component];

	for (length = 0; length < 16; length++)
    6140:	e2899001 	add	r9, r9, #1
    6144:	e3590010 	cmp	r9, #16
    6148:	e2855004 	add	r5, r5, #4
    614c:	0a000058 	beq	62b4 <decoder+0x133c>

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
  {
		if (scan_desc -> bit_count == 0)
    6150:	e35a0000 	cmp	sl, #0
    6154:	e24aa001 	sub	sl, sl, #1
static inline uint32_t get_bits (kpn_channel_t channel,
    scan_desc_t *scan_desc, uint8_t number)
{
	int32_t i = 0, newbit = 0;
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;
    6158:	e5cd8070 	strb	r8, [sp, #112]	; 0x70
    615c:	e5cd8071 	strb	r8, [sp, #113]	; 0x71

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
  {
		if (scan_desc -> bit_count == 0)
    6160:	16efa07a 	uxtbne	sl, sl
    6164:	1affffed 	bne	6120 <decoder+0x11a8>
    {
			kpn_channel_read (channel, & wwindow, 1);
    6168:	e1a00006 	mov	r0, r6
    616c:	e28d1070 	add	r1, sp, #112	; 0x70
    6170:	e3a02001 	mov	r2, #1
    6174:	ebffe949 	bl	6a0 <kpn_channel_read>
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
    6178:	e5ddc070 	ldrb	ip, [sp, #112]	; 0x70
    617c:	e35c00ff 	cmp	ip, #255	; 0xff
    6180:	13a0a007 	movne	sl, #7
    6184:	1affffe5 	bne	6120 <decoder+0x11a8>
    6188:	e1a00006 	mov	r0, r6
    618c:	e28d1071 	add	r1, sp, #113	; 0x71
    6190:	e3a02001 	mov	r2, #1
    6194:	ebffe941 	bl	6a0 <kpn_channel_read>
    6198:	e3a0a007 	mov	sl, #7
    619c:	e5ddc070 	ldrb	ip, [sp, #112]	; 0x70
    61a0:	eaffffde 	b	6120 <decoder+0x11a8>
    61a4:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    61a8:	e0803109 	add	r3, r0, r9, lsl #2
		if (code <= HT -> MaxCode[length]) break;
	}

	if (length != 16)
  {
		index = HT -> ValPtr[length] + code - HT -> MinCode[length];
    61ac:	e7902109 	ldr	r2, [r0, r9, lsl #2]
    61b0:	e5933040 	ldr	r3, [r3, #64]	; 0x40
    61b4:	e0844002 	add	r4, r4, r2
    61b8:	e0633004 	rsb	r3, r3, r4
		if (index < MAX_SIZE(acdc)) return HT -> table[index];
    61bc:	e35300a1 	cmp	r3, #161	; 0xa1
    61c0:	8a00003b 	bhi	62b4 <decoder+0x133c>
    61c4:	e59020c0 	ldr	r2, [r0, #192]	; 0xc0
    61c8:	e7d22003 	ldrb	r2, [r2, r3]

	for (i = 1; i < 64; i++)
  {
		symbol = get_symbol (channel, scan_desc, HUFF_AC, index);

		if (symbol == HUFF_EOB) 
    61cc:	e3520000 	cmp	r2, #0
    61d0:	0a000037 	beq	62b4 <decoder+0x133c>
    {
			break;
		}

		if (symbol == HUFF_ZRL)
    61d4:	e35200f0 	cmp	r2, #240	; 0xf0
    {
			i += 15;
    61d8:	0287700f 	addeq	r7, r7, #15
		if (symbol == HUFF_EOB) 
    {
			break;
		}

		if (symbol == HUFF_ZRL)
    61dc:	0a000031 	beq	62a8 <decoder+0x1330>
{
	int32_t i = 0, newbit = 0;
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;

	if (number == 0) return 0;
    61e0:	e212300f 	ands	r3, r2, #15
			continue;
		}

		cat = symbol & 15;
		run = (symbol >> 4) & 15;
		i += run;
    61e4:	e0877222 	add	r7, r7, r2, lsr #4
static inline uint32_t get_bits (kpn_channel_t channel,
    scan_desc_t *scan_desc, uint8_t number)
{
	int32_t i = 0, newbit = 0;
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;
    61e8:	e5cd8072 	strb	r8, [sp, #114]	; 0x72
    61ec:	e5cd8073 	strb	r8, [sp, #115]	; 0x73

	if (number == 0) return 0;
    61f0:	0a000029 	beq	629c <decoder+0x1324>

	for (i = 0; i < number; i++)
    61f4:	e3a04000 	mov	r4, #0

static inline uint32_t get_bits (kpn_channel_t channel,
    scan_desc_t *scan_desc, uint8_t number)
{
	int32_t i = 0, newbit = 0;
	uint32_t result = 0;
    61f8:	e1a0200c 	mov	r2, ip
    61fc:	e1a09004 	mov	r9, r4
    6200:	e1a05003 	mov	r5, r3
    6204:	ea000007 	b	6228 <decoder+0x12b0>
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
    6208:	e1a033a2 	lsr	r3, r2, #7
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
    620c:	e2844001 	add	r4, r4, #1
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
		scan_desc -> bit_count -= 1;
		result = (result << 1) | newbit;
    6210:	e6ef3073 	uxtb	r3, r3
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
    6214:	e1a02082 	lsl	r2, r2, #1
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
    6218:	e1550004 	cmp	r5, r4
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
		scan_desc -> bit_count -= 1;
		result = (result << 1) | newbit;
    621c:	e1839089 	orr	r9, r3, r9, lsl #1
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
    6220:	e6ef2072 	uxtb	r2, r2
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
    6224:	da000013 	ble	6278 <decoder+0x1300>
  {
		if (scan_desc -> bit_count == 0)
    6228:	e35a0000 	cmp	sl, #0
    622c:	e24aa001 	sub	sl, sl, #1
    {
			kpn_channel_read (channel, & wwindow, 1);
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;
    6230:	15cd2072 	strbne	r2, [sp, #114]	; 0x72
    6234:	16efa07a 	uxtbne	sl, sl

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
  {
		if (scan_desc -> bit_count == 0)
    6238:	1afffff2 	bne	6208 <decoder+0x1290>
    {
			kpn_channel_read (channel, & wwindow, 1);
    623c:	e3a02001 	mov	r2, #1
    6240:	e1a00006 	mov	r0, r6
    6244:	e28d1072 	add	r1, sp, #114	; 0x72
    6248:	ebffe914 	bl	6a0 <kpn_channel_read>
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
    624c:	e5dd2072 	ldrb	r2, [sp, #114]	; 0x72
    6250:	e35200ff 	cmp	r2, #255	; 0xff
    6254:	13a0a007 	movne	sl, #7
    6258:	1affffea 	bne	6208 <decoder+0x1290>
    625c:	e3a02001 	mov	r2, #1
    6260:	e1a00006 	mov	r0, r6
    6264:	e28d1073 	add	r1, sp, #115	; 0x73
    6268:	ebffe90c 	bl	6a0 <kpn_channel_read>
    626c:	e3a0a007 	mov	sl, #7
    6270:	e5dd2072 	ldrb	r2, [sp, #114]	; 0x72
    6274:	eaffffe3 	b	6208 <decoder+0x1290>
	St = 1 << (good - 1);	/* 2^(good-1) */

	if (S < St) return (S + 1 + ((-1) << good));
    6278:	e3a0e001 	mov	lr, #1
    627c:	e1a0c002 	mov	ip, r2
static inline int32_t reformat (uint32_t S, int32_t good)
{
	int32_t St = 0;

	if (good == 0) return 0;
	St = 1 << (good - 1);	/* 2^(good-1) */
    6280:	e2452001 	sub	r2, r5, #1

	if (S < St) return (S + 1 + ((-1) << good));
    6284:	e159021e 	cmp	r9, lr, lsl r2
    6288:	33e00000 	mvncc	r0, #0
    628c:	e1a03005 	mov	r3, r5
	else return S;
    6290:	21a03009 	movcs	r3, r9
	int32_t St = 0;

	if (good == 0) return 0;
	St = 1 << (good - 1);	/* 2^(good-1) */

	if (S < St) return (S + 1 + ((-1) << good));
    6294:	30893510 	addcc	r3, r9, r0, lsl r5
    6298:	3083300e 	addcc	r3, r3, lr
		cat = symbol & 15;
		run = (symbol >> 4) & 15;
		i += run;
		temp = get_bits (channel, scan_desc, cat);
		value = reformat(temp, cat);
		T[i] = value ;    
    629c:	e28d1c09 	add	r1, sp, #2304	; 0x900
    62a0:	e0812107 	add	r2, r1, r7, lsl #2
    62a4:	e5023720 	str	r3, [r2, #-1824]	; 0x720
	value += scan_desc -> pred[index];
	scan_desc -> pred[index] = value;

	T[0] = value ;

	for (i = 1; i < 64; i++)
    62a8:	e2877001 	add	r7, r7, #1
    62ac:	e357003f 	cmp	r7, #63	; 0x3f
    62b0:	9affff42 	bls	5fc0 <decoder+0x1048>
static inline void iqzz_block(int32_t in[64],
    int32_t out[64], uint8_t table[64])
{
	uint32_t index;

	for( index = 0; index < 64 ; index++)
    62b4:	e3a03000 	mov	r3, #0
								iqzz_block (MCU, & FLIT[(step + (YV * YH + index - 1)) * 64],
                    DQT_table[SOF_component[index] . q_table]);
    62b8:	e59de02c 	ldr	lr, [sp, #44]	; 0x2c
    62bc:	e28d0c09 	add	r0, sp, #2304	; 0x900
    62c0:	e08e208e 	add	r2, lr, lr, lsl #1
							}

							for (index =  1; index < SOF_section . n; index++)
              {
								unpack_block (c[0], & scan_desc, index, MCU);
								iqzz_block (MCU, & FLIT[(step + (YV * YH + index - 1)) * 64],
    62c4:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
                    DQT_table[SOF_component[index] . q_table]);
    62c8:	e0802002 	add	r2, r0, r2
    62cc:	e5525862 	ldrb	r5, [r2, #-2146]	; 0x862
							}

							for (index =  1; index < SOF_section . n; index++)
              {
								unpack_block (c[0], & scan_desc, index, MCU);
								iqzz_block (MCU, & FLIT[(step + (YV * YH + index - 1)) * 64],
    62d0:	e08e4001 	add	r4, lr, r1
    62d4:	e59de040 	ldr	lr, [sp, #64]	; 0x40
                    DQT_table[SOF_component[index] . q_table]);
    62d8:	e28d20e0 	add	r2, sp, #224	; 0xe0
    62dc:	e0825305 	add	r5, r2, r5, lsl #6
							}

							for (index =  1; index < SOF_section . n; index++)
              {
								unpack_block (c[0], & scan_desc, index, MCU);
								iqzz_block (MCU, & FLIT[(step + (YV * YH + index - 1)) * 64],
    62e0:	e08e4404 	add	r4, lr, r4, lsl #8
    62e4:	e28d2f77 	add	r2, sp, #476	; 0x1dc
  {
		out[G_ZZ[index]] = in[index] * table[index];
    62e8:	e7d5e003 	ldrb	lr, [r5, r3]
    62ec:	e5b20004 	ldr	r0, [r2, #4]!
    62f0:	e7db1003 	ldrb	r1, [fp, r3]
    62f4:	e000009e 	mul	r0, lr, r0
static inline void iqzz_block(int32_t in[64],
    int32_t out[64], uint8_t table[64])
{
	uint32_t index;

	for( index = 0; index < 64 ; index++)
    62f8:	e2833001 	add	r3, r3, #1
    62fc:	e3530040 	cmp	r3, #64	; 0x40
  {
		out[G_ZZ[index]] = in[index] * table[index];
    6300:	e7840101 	str	r0, [r4, r1, lsl #2]
static inline void iqzz_block(int32_t in[64],
    int32_t out[64], uint8_t table[64])
{
	uint32_t index;

	for( index = 0; index < 64 ; index++)
    6304:	1afffff7 	bne	62e8 <decoder+0x1370>
								unpack_block (c[0], & scan_desc, 0, MCU);
								iqzz_block (MCU, & FLIT[(step + index) * 64],
                    DQT_table[SOF_component[0] . q_table]);
							}

							for (index =  1; index < SOF_section . n; index++)
    6308:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
    630c:	e2832001 	add	r2, r3, #1
    6310:	e5dd309b 	ldrb	r3, [sp, #155]	; 0x9b
    6314:	e6ef2072 	uxtb	r2, r2
    6318:	e1530002 	cmp	r3, r2
    631c:	e58d202c 	str	r2, [sp, #44]	; 0x2c
    6320:	8afffee8 	bhi	5ec8 <decoder+0xf50>
    6324:	e1a0900c 	mov	r9, ip
            intceil (SOF_section . width, MCU_sy);
					IPRINTF("%d MCU to unpack\r\n", nb_MCU);

					while (nb_MCU)
          {
						for (uint32_t step = 0; step < flit_size; step += mcu_size)
    6328:	e59dc034 	ldr	ip, [sp, #52]	; 0x34
    632c:	e59de060 	ldr	lr, [sp, #96]	; 0x60
    6330:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
    6334:	e08cc00e 	add	ip, ip, lr
    6338:	e150000c 	cmp	r0, ip
    633c:	e58dc034 	str	ip, [sp, #52]	; 0x34
    6340:	8afffe12 	bhi	5b90 <decoder+0xc18>
								iqzz_block (MCU, & FLIT[(step + (YV * YH + index - 1)) * 64],
                    DQT_table[SOF_component[index] . q_table]);
							}
						}

            computer (flit_size, FLIT, DECODED_FLIT);
    6344:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
    6348:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
    634c:	e59d204c 	ldr	r2, [sp, #76]	; 0x4c
    6350:	ebfff9f6 	bl	4b30 <computer>
            builder (SOF_section, YV, YH, flit_size, DECODED_FLIT,
    6354:	e59dc020 	ldr	ip, [sp, #32]
    6358:	e28de084 	add	lr, sp, #132	; 0x84
    635c:	e89c0003 	ldm	ip, {r0, r1}
    6360:	e59dc030 	ldr	ip, [sp, #48]	; 0x30
    6364:	e28d2088 	add	r2, sp, #136	; 0x88
    6368:	e58dc000 	str	ip, [sp]
    636c:	e59dc04c 	ldr	ip, [sp, #76]	; 0x4c
    6370:	e58de00c 	str	lr, [sp, #12]
    6374:	e58dc004 	str	ip, [sp, #4]
    6378:	e59dc048 	ldr	ip, [sp, #72]	; 0x48
    637c:	e58d2010 	str	r2, [sp, #16]
    6380:	e58dc008 	str	ip, [sp, #8]
    6384:	e59d3050 	ldr	r3, [sp, #80]	; 0x50
    6388:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
    638c:	eb0000b8 	bl	6674 <builder>

					nb_MCU = intceil (SOF_section . height, MCU_sx) *
            intceil (SOF_section . width, MCU_sy);
					IPRINTF("%d MCU to unpack\r\n", nb_MCU);

					while (nb_MCU)
    6390:	e59dc044 	ldr	ip, [sp, #68]	; 0x44
    6394:	e59de064 	ldr	lr, [sp, #100]	; 0x64
    6398:	e35c0000 	cmp	ip, #0
    639c:	e06e300c 	rsb	r3, lr, ip
    63a0:	e6ff3073 	uxth	r3, r3
    63a4:	0a00009a 	beq	6614 <decoder+0x169c>
    63a8:	e58d3044 	str	r3, [sp, #68]	; 0x44
    63ac:	eafffdf2 	b	5b7c <decoder+0xc04>
    63b0:	e1a0c003 	mov	ip, r3
		if (code <= HT -> MaxCode[length]) break;
	}

	if (length != 16)
  {
		index = HT -> ValPtr[length] + code - HT -> MinCode[length];
    63b4:	e7952107 	ldr	r2, [r5, r7, lsl #2]
    63b8:	e0853107 	add	r3, r5, r7, lsl #2
    63bc:	e5933040 	ldr	r3, [r3, #64]	; 0x40
    63c0:	e0844002 	add	r4, r4, r2
    63c4:	e0633004 	rsb	r3, r3, r4
		if (index < MAX_SIZE(acdc)) return HT -> table[index];
    63c8:	e353000d 	cmp	r3, #13
    63cc:	8afffef0 	bhi	5f94 <decoder+0x101c>
    63d0:	e59520c0 	ldr	r2, [r5, #192]	; 0xc0
    63d4:	e7d27003 	ldrb	r7, [r2, r3]
static inline uint32_t get_bits (kpn_channel_t channel,
    scan_desc_t *scan_desc, uint8_t number)
{
	int32_t i = 0, newbit = 0;
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;
    63d8:	e5cd8070 	strb	r8, [sp, #112]	; 0x70

	if (number == 0) return 0;
    63dc:	e3570000 	cmp	r7, #0
static inline uint32_t get_bits (kpn_channel_t channel,
    scan_desc_t *scan_desc, uint8_t number)
{
	int32_t i = 0, newbit = 0;
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;
    63e0:	e5cd8071 	strb	r8, [sp, #113]	; 0x71

	if (number == 0) return 0;
    63e4:	0afffeea 	beq	5f94 <decoder+0x101c>

	for (i = 0; i < number; i++)
    63e8:	e3a04000 	mov	r4, #0

static inline uint32_t get_bits (kpn_channel_t channel,
    scan_desc_t *scan_desc, uint8_t number)
{
	int32_t i = 0, newbit = 0;
	uint32_t result = 0;
    63ec:	e1a0300c 	mov	r3, ip
    63f0:	e1a05004 	mov	r5, r4
    63f4:	ea000007 	b	6418 <decoder+0x14a0>
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
    63f8:	e1a023a3 	lsr	r2, r3, #7
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
    63fc:	e2844001 	add	r4, r4, #1
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
		scan_desc -> bit_count -= 1;
		result = (result << 1) | newbit;
    6400:	e6ef2072 	uxtb	r2, r2
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
    6404:	e1a03083 	lsl	r3, r3, #1
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
    6408:	e1540007 	cmp	r4, r7
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
		scan_desc -> bit_count -= 1;
		result = (result << 1) | newbit;
    640c:	e1825085 	orr	r5, r2, r5, lsl #1
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
    6410:	e6ef3073 	uxtb	r3, r3
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
    6414:	aa000013 	bge	6468 <decoder+0x14f0>
  {
		if (scan_desc -> bit_count == 0)
    6418:	e35a0000 	cmp	sl, #0
    641c:	e24aa001 	sub	sl, sl, #1
    {
			kpn_channel_read (channel, & wwindow, 1);
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;
    6420:	15cd3070 	strbne	r3, [sp, #112]	; 0x70
    6424:	16efa07a 	uxtbne	sl, sl

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
  {
		if (scan_desc -> bit_count == 0)
    6428:	1afffff2 	bne	63f8 <decoder+0x1480>
    {
			kpn_channel_read (channel, & wwindow, 1);
    642c:	e1a00006 	mov	r0, r6
    6430:	e28d1070 	add	r1, sp, #112	; 0x70
    6434:	e3a02001 	mov	r2, #1
    6438:	ebffe898 	bl	6a0 <kpn_channel_read>
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
    643c:	e5dd3070 	ldrb	r3, [sp, #112]	; 0x70
    6440:	e35300ff 	cmp	r3, #255	; 0xff
    6444:	13a0a007 	movne	sl, #7
    6448:	1affffea 	bne	63f8 <decoder+0x1480>
    644c:	e1a00006 	mov	r0, r6
    6450:	e28d1071 	add	r1, sp, #113	; 0x71
    6454:	e3a02001 	mov	r2, #1
    6458:	ebffe890 	bl	6a0 <kpn_channel_read>
    645c:	e3a0a007 	mov	sl, #7
    6460:	e5dd3070 	ldrb	r3, [sp, #112]	; 0x70
    6464:	eaffffe3 	b	63f8 <decoder+0x1480>
    6468:	e3a02001 	mov	r2, #1
    646c:	e1a0c003 	mov	ip, r3
static inline int32_t reformat (uint32_t S, int32_t good)
{
	int32_t St = 0;

	if (good == 0) return 0;
	St = 1 << (good - 1);	/* 2^(good-1) */
    6470:	e2473001 	sub	r3, r7, #1

	if (S < St) return (S + 1 + ((-1) << good));
    6474:	e1550312 	cmp	r5, r2, lsl r3
    6478:	33e03000 	mvncc	r3, #0
    647c:	30855713 	addcc	r5, r5, r3, lsl r7
    6480:	30855002 	addcc	r5, r5, r2
    6484:	eafffec3 	b	5f98 <decoder+0x1020>
    6488:	e1a0c003 	mov	ip, r3
		if (code <= HT -> MaxCode[length]) break;
	}

	if (length != 16)
  {
		index = HT -> ValPtr[length] + code - HT -> MinCode[length];
    648c:	e7952107 	ldr	r2, [r5, r7, lsl #2]
    6490:	e0853107 	add	r3, r5, r7, lsl #2
    6494:	e5933040 	ldr	r3, [r3, #64]	; 0x40
    6498:	e0844002 	add	r4, r4, r2
    649c:	e0633004 	rsb	r3, r3, r4
		if (index < MAX_SIZE(acdc)) return HT -> table[index];
    64a0:	e353000d 	cmp	r3, #13
    64a4:	8afffdf0 	bhi	5c6c <decoder+0xcf4>
    64a8:	e59520c0 	ldr	r2, [r5, #192]	; 0xc0
    64ac:	e7d27003 	ldrb	r7, [r2, r3]
static inline uint32_t get_bits (kpn_channel_t channel,
    scan_desc_t *scan_desc, uint8_t number)
{
	int32_t i = 0, newbit = 0;
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;
    64b0:	e5cd8070 	strb	r8, [sp, #112]	; 0x70

	if (number == 0) return 0;
    64b4:	e3570000 	cmp	r7, #0
static inline uint32_t get_bits (kpn_channel_t channel,
    scan_desc_t *scan_desc, uint8_t number)
{
	int32_t i = 0, newbit = 0;
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;
    64b8:	e5cd8071 	strb	r8, [sp, #113]	; 0x71

	if (number == 0) return 0;
    64bc:	0afffdea 	beq	5c6c <decoder+0xcf4>

	for (i = 0; i < number; i++)
    64c0:	e3a04000 	mov	r4, #0

static inline uint32_t get_bits (kpn_channel_t channel,
    scan_desc_t *scan_desc, uint8_t number)
{
	int32_t i = 0, newbit = 0;
	uint32_t result = 0;
    64c4:	e1a0300c 	mov	r3, ip
    64c8:	e1a05004 	mov	r5, r4
    64cc:	ea000007 	b	64f0 <decoder+0x1578>
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
    64d0:	e1a023a3 	lsr	r2, r3, #7
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
    64d4:	e2844001 	add	r4, r4, #1
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
		scan_desc -> bit_count -= 1;
		result = (result << 1) | newbit;
    64d8:	e6ef2072 	uxtb	r2, r2
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
    64dc:	e1a03083 	lsl	r3, r3, #1
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
    64e0:	e1570004 	cmp	r7, r4
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
		scan_desc -> bit_count -= 1;
		result = (result << 1) | newbit;
    64e4:	e1825085 	orr	r5, r2, r5, lsl #1
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;

		newbit = (wwindow >> 7) & 1;
		scan_desc -> window = wwindow << 1;
    64e8:	e6ef3073 	uxtb	r3, r3
	uint32_t result = 0;
	uint8_t wwindow = 0, aux = 0;

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
    64ec:	da000013 	ble	6540 <decoder+0x15c8>
  {
		if (scan_desc -> bit_count == 0)
    64f0:	e35a0000 	cmp	sl, #0
    64f4:	e24aa001 	sub	sl, sl, #1
    {
			kpn_channel_read (channel, & wwindow, 1);
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
		}
		else wwindow = scan_desc->window;
    64f8:	15cd3070 	strbne	r3, [sp, #112]	; 0x70
    64fc:	16efa07a 	uxtbne	sl, sl

	if (number == 0) return 0;

	for (i = 0; i < number; i++)
  {
		if (scan_desc -> bit_count == 0)
    6500:	1afffff2 	bne	64d0 <decoder+0x1558>
    {
			kpn_channel_read (channel, & wwindow, 1);
    6504:	e1a00006 	mov	r0, r6
    6508:	e28d1070 	add	r1, sp, #112	; 0x70
    650c:	e3a02001 	mov	r2, #1
    6510:	ebffe862 	bl	6a0 <kpn_channel_read>
			scan_desc -> bit_count = 8;
			if (wwindow == 0xFF) kpn_channel_read (channel, & aux, 1); 
    6514:	e5dd3070 	ldrb	r3, [sp, #112]	; 0x70
    6518:	e35300ff 	cmp	r3, #255	; 0xff
    651c:	13a0a007 	movne	sl, #7
    6520:	1affffea 	bne	64d0 <decoder+0x1558>
    6524:	e1a00006 	mov	r0, r6
    6528:	e28d1071 	add	r1, sp, #113	; 0x71
    652c:	e3a02001 	mov	r2, #1
    6530:	ebffe85a 	bl	6a0 <kpn_channel_read>
    6534:	e3a0a007 	mov	sl, #7
    6538:	e5dd3070 	ldrb	r3, [sp, #112]	; 0x70
    653c:	eaffffe3 	b	64d0 <decoder+0x1558>
    6540:	e3a00001 	mov	r0, #1
    6544:	e1a0c003 	mov	ip, r3
static inline int32_t reformat (uint32_t S, int32_t good)
{
	int32_t St = 0;

	if (good == 0) return 0;
	St = 1 << (good - 1);	/* 2^(good-1) */
    6548:	e2473001 	sub	r3, r7, #1

	if (S < St) return (S + 1 + ((-1) << good));
    654c:	e1550310 	cmp	r5, r0, lsl r3
    6550:	33e01000 	mvncc	r1, #0
    6554:	30855711 	addcc	r5, r5, r1, lsl r7
    6558:	30855000 	addcc	r5, r5, r0
    655c:	eafffdc3 	b	5c70 <decoder+0xcf8>
					skip_segment (c[0]);
					break;
				}

				case M_SOI: {
					IPRINTF("SOI marker found\r\n");
    6560:	e51f1454 	ldr	r1, [pc, #-1108]	; 6114 <decoder+0x119c>
    6564:	e51f0480 	ldr	r0, [pc, #-1152]	; 60ec <decoder+0x1174>
    6568:	eb002699 	bl	ffd4 <printf>
					break;
    656c:	eafffab9 	b	5058 <decoder+0xe0>

					break;
				}

				case M_DNL: {
					IPRINTF("DNL marker found\r\n");
    6570:	e51f0488 	ldr	r0, [pc, #-1160]	; 60f0 <decoder+0x1178>
    6574:	eafffbcb 	b	54a8 <decoder+0x530>
          kpn_channel_purge (c[0], false);
          break;
				}

				case M_DQT: {
					IPRINTF("DQT marker found\r\n");
    6578:	e51f146c 	ldr	r1, [pc, #-1132]	; 6114 <decoder+0x119c>
    657c:	e51f0490 	ldr	r0, [pc, #-1168]	; 60f4 <decoder+0x117c>
    6580:	eb002693 	bl	ffd4 <printf>

					kpn_channel_read (c[0], & DQT_section, sizeof (DQT_section));
    6584:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    6588:	e28d1078 	add	r1, sp, #120	; 0x78
    658c:	e59c0000 	ldr	r0, [ip]
    6590:	e3a02003 	mov	r2, #3
    6594:	ebffe841 	bl	6a0 <kpn_channel_read>
					cpu_data_is_big_endian(16, DQT_section . length);
    6598:	e51f34a8 	ldr	r3, [pc, #-1192]	; 60f8 <decoder+0x1180>
    659c:	e28dec09 	add	lr, sp, #2304	; 0x900

					VPRINTF("Quantization precision is %s\r\n",
    65a0:	e5dd007a 	ldrb	r0, [sp, #122]	; 0x7a
    65a4:	e19ec0b3 	ldrh	ip, [lr, r3]
    65a8:	e51f14b4 	ldr	r1, [pc, #-1204]	; 60fc <decoder+0x1184>
    65ac:	e1b00220 	lsrs	r0, r0, #4
    65b0:	e6bfcfbc 	rev16	ip, ip
    65b4:	e51f24bc 	ldr	r2, [pc, #-1212]	; 6100 <decoder+0x1188>
    65b8:	e51f04bc 	ldr	r0, [pc, #-1212]	; 6104 <decoder+0x118c>
    65bc:	11a02001 	movne	r2, r1
    65c0:	e51f14b4 	ldr	r1, [pc, #-1204]	; 6114 <decoder+0x119c>

				case M_DQT: {
					IPRINTF("DQT marker found\r\n");

					kpn_channel_read (c[0], & DQT_section, sizeof (DQT_section));
					cpu_data_is_big_endian(16, DQT_section . length);
    65c4:	e18ec0b3 	strh	ip, [lr, r3]

					VPRINTF("Quantization precision is %s\r\n",
    65c8:	eb002681 	bl	ffd4 <printf>
              ((DQT_section . pre_quant >> 4) & 0x0f) ? "16 bits" :	"8 bits");

					QT_index = DQT_section . pre_quant & 0x0f;
    65cc:	e5dd407a 	ldrb	r4, [sp, #122]	; 0x7a
					VPRINTF("Quantization table index is %d\r\n", QT_index);
    65d0:	e51f14c4 	ldr	r1, [pc, #-1220]	; 6114 <decoder+0x119c>
    65d4:	e204400f 	and	r4, r4, #15
    65d8:	e1a02004 	mov	r2, r4
    65dc:	e51f04dc 	ldr	r0, [pc, #-1244]	; 6108 <decoder+0x1190>
    65e0:	eb00267b 	bl	ffd4 <printf>
				
					VPRINTF("Reading quantization table\r\n");
    65e4:	e51f14d8 	ldr	r1, [pc, #-1240]	; 6114 <decoder+0x119c>
    65e8:	e51f04e4 	ldr	r0, [pc, #-1252]	; 610c <decoder+0x1194>
    65ec:	eb002678 	bl	ffd4 <printf>
					kpn_channel_read (c[0], DQT_table[QT_index], 64);
    65f0:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    65f4:	e28d00e0 	add	r0, sp, #224	; 0xe0
    65f8:	e0801304 	add	r1, r0, r4, lsl #6
    65fc:	e3a02040 	mov	r2, #64	; 0x40
    6600:	e59c0000 	ldr	r0, [ip]
    6604:	ebffe825 	bl	6a0 <kpn_channel_read>

					break;
    6608:	eafffa92 	b	5058 <decoder+0xe0>
					skip_segment (c[0]);
					break;
				}

				case M_DRI: {
					IPRINTF("DRI marker found\r\n");
    660c:	e51f0504 	ldr	r0, [pc, #-1284]	; 6110 <decoder+0x1198>
    6610:	eafffba4 	b	54a8 <decoder+0x530>
    6614:	e1a0a009 	mov	sl, r9
                picture, & LB_X, & LB_Y);

						nb_MCU -= YV * nb_MCU_sx;
					}

          kpn_channel_write (c[1], picture, SOF_section . width
    6618:	e59d3098 	ldr	r3, [sp, #152]	; 0x98
              * SOF_section . height * 2);
    661c:	e5dd1098 	ldrb	r1, [sp, #152]	; 0x98
    6620:	e5dd2097 	ldrb	r2, [sp, #151]	; 0x97
                picture, & LB_X, & LB_Y);

						nb_MCU -= YV * nb_MCU_sx;
					}

          kpn_channel_write (c[1], picture, SOF_section . width
    6624:	e1a03423 	lsr	r3, r3, #8
              * SOF_section . height * 2);
    6628:	e6ff3073 	uxth	r3, r3
    662c:	e1822401 	orr	r2, r2, r1, lsl #8
    6630:	e0020392 	mul	r2, r2, r3
                picture, & LB_X, & LB_Y);

						nb_MCU -= YV * nb_MCU_sx;
					}

          kpn_channel_write (c[1], picture, SOF_section . width
    6634:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    6638:	e59d1048 	ldr	r1, [sp, #72]	; 0x48
    663c:	e59c0004 	ldr	r0, [ip, #4]
    6640:	e1a02082 	lsl	r2, r2, #1
    6644:	ebffe7dd 	bl	5c0 <kpn_channel_write>
              * SOF_section . height * 2);

          kpn_channel_purge (c[0], false);
    6648:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
    664c:	e3a01000 	mov	r1, #0
    6650:	e59c0000 	ldr	r0, [ip]
    6654:	ebffe7c8 	bl	57c <kpn_channel_purge>
          break;
    6658:	eafffa7e 	b	5058 <decoder+0xe0>
					IPRINTF("SOI marker found\r\n");
					break;
				}

				case M_EOI: {
					IPRINTF("EOI marker found\r\n");
    665c:	e51f1550 	ldr	r1, [pc, #-1360]	; 6114 <decoder+0x119c>
    6660:	e51f0550 	ldr	r0, [pc, #-1360]	; 6118 <decoder+0x11a0>
    6664:	eb00265a 	bl	ffd4 <printf>
					break;
    6668:	eafffa7a 	b	5058 <decoder+0xe0>
					skip_segment (c[0]);
					break;
				}

				case M_RST7: {
					IPRINTF("RST7 marker found\r\n");
    666c:	e51f0558 	ldr	r0, [pc, #-1368]	; 611c <decoder+0x11a4>
    6670:	eafffb8c 	b	54a8 <decoder+0x530>

00006674 <builder>:
#include <Private/Builder.h>

void builder ( SOF_section_t SOF_section, uint32_t YV, uint32_t YH,
    uint32_t flit_size, uint8_t * MCU_YCbCr, uint8_t * picture,
    uint32_t * LB_X, uint32_t * LB_Y)
{
    6674:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6678:	e24dd04c 	sub	sp, sp, #76	; 0x4c
    667c:	e28db048 	add	fp, sp, #72	; 0x48
    6680:	e90b0003 	stmdb	fp, {r0, r1}
    6684:	e5ddc046 	ldrb	ip, [sp, #70]	; 0x46
    6688:	e5dd1045 	ldrb	r1, [sp, #69]	; 0x45
    668c:	e5dd0043 	ldrb	r0, [sp, #67]	; 0x43
    6690:	e181140c 	orr	r1, r1, ip, lsl #8
 * Utils
 */

static inline int32_t intceil (int32_t N, int32_t D)
{
	int32_t i = N / D;
    6694:	e1a0c1c1 	asr	ip, r1, #3
    6698:	e58dc028 	str	ip, [sp, #40]	; 0x28

	if (N > D * i) i++;
    669c:	e59db028 	ldr	fp, [sp, #40]	; 0x28
    66a0:	e5ddc044 	ldrb	ip, [sp, #68]	; 0x44
    66a4:	e151018b 	cmp	r1, fp, lsl #3
    66a8:	e180040c 	orr	r0, r0, ip, lsl #8
 * Utils
 */

static inline int32_t intceil (int32_t N, int32_t D)
{
	int32_t i = N / D;
    66ac:	e1a0c1c0 	asr	ip, r0, #3

	if (N > D * i) i++;
    66b0:	c28bb001 	addgt	fp, fp, #1
    66b4:	c58db028 	strgt	fp, [sp, #40]	; 0x28
    66b8:	e150018c 	cmp	r0, ip, lsl #3
 * Utils
 */

static inline int32_t intceil (int32_t N, int32_t D)
{
	int32_t i = N / D;
    66bc:	e58dc02c 	str	ip, [sp, #44]	; 0x2c
    66c0:	e58d2018 	str	r2, [sp, #24]

	if (N > D * i) i++;
    66c4:	c28cc001 	addgt	ip, ip, #1
    66c8:	e58d3008 	str	r3, [sp, #8]
    66cc:	c58dc02c 	strgt	ip, [sp, #44]	; 0x2c
	uint32_t block_index = 0;
#endif

	NB_MCU_X = intceil(SOF_section.width, MCU_sx);
	NB_MCU_Y = intceil(SOF_section.height, MCU_sy);
	NB_CELLS = YV * YH + 2;
    66d0:	e59db018 	ldr	fp, [sp, #24]
    66d4:	e59dc008 	ldr	ip, [sp, #8]
#include <Private/Builder.h>

void builder ( SOF_section_t SOF_section, uint32_t YV, uint32_t YH,
    uint32_t flit_size, uint8_t * MCU_YCbCr, uint8_t * picture,
    uint32_t * LB_X, uint32_t * LB_Y)
{
    66d8:	e59d3074 	ldr	r3, [sp, #116]	; 0x74
	uint32_t block_index = 0;
#endif

	NB_MCU_X = intceil(SOF_section.width, MCU_sx);
	NB_MCU_Y = intceil(SOF_section.height, MCU_sy);
	NB_CELLS = YV * YH + 2;
    66dc:	e1620c8b 	smulbb	r2, fp, ip
#ifdef PROGRESS
	printf ("Image %lu : |", imageCount++);
	fflush (stdout);
#endif

  for (int flit_index = 0; flit_index < flit_size; flit_index += NB_CELLS)
    66e0:	e59db070 	ldr	fp, [sp, #112]	; 0x70
	uint32_t block_index = 0;
#endif

	NB_MCU_X = intceil(SOF_section.width, MCU_sx);
	NB_MCU_Y = intceil(SOF_section.height, MCU_sy);
	NB_CELLS = YV * YH + 2;
    66e4:	e2822002 	add	r2, r2, #2
    66e8:	e6ff2072 	uxth	r2, r2
#ifdef PROGRESS
	printf ("Image %lu : |", imageCount++);
	fflush (stdout);
#endif

  for (int flit_index = 0; flit_index < flit_size; flit_index += NB_CELLS)
    66ec:	e35b0000 	cmp	fp, #0
#include <Private/Builder.h>

void builder ( SOF_section_t SOF_section, uint32_t YV, uint32_t YH,
    uint32_t flit_size, uint8_t * MCU_YCbCr, uint8_t * picture,
    uint32_t * LB_X, uint32_t * LB_Y)
{
    66f0:	e59da07c 	ldr	sl, [sp, #124]	; 0x7c
    66f4:	e59d9080 	ldr	r9, [sp, #128]	; 0x80
	uint32_t block_index = 0;
#endif

	NB_MCU_X = intceil(SOF_section.width, MCU_sx);
	NB_MCU_Y = intceil(SOF_section.height, MCU_sy);
	NB_CELLS = YV * YH + 2;
    66f8:	e58d2030 	str	r2, [sp, #48]	; 0x30
#ifdef PROGRESS
	printf ("Image %lu : |", imageCount++);
	fflush (stdout);
#endif

  for (int flit_index = 0; flit_index < flit_size; flit_index += NB_CELLS)
    66fc:	0a0000c7 	beq	6a20 <builder+0x3ac>
    6700:	e59db018 	ldr	fp, [sp, #24]
    6704:	e58d2034 	str	r2, [sp, #52]	; 0x34
    6708:	e0020b9c 	mul	r2, ip, fp
    670c:	e0000190 	mul	r0, r0, r1
    6710:	e1a02302 	lsl	r2, r2, #6
    6714:	e2822040 	add	r2, r2, #64	; 0x40
    6718:	e58d2038 	str	r2, [sp, #56]	; 0x38
    671c:	e0802080 	add	r2, r0, r0, lsl #1
    6720:	e59dc038 	ldr	ip, [sp, #56]	; 0x38
    6724:	e1a020c2 	asr	r2, r2, #1
    6728:	e59db028 	ldr	fp, [sp, #40]	; 0x28
    672c:	e58d2020 	str	r2, [sp, #32]
    6730:	e59d2008 	ldr	r2, [sp, #8]
    6734:	e083300c 	add	r3, r3, ip
    6738:	e1a0418b 	lsl	r4, fp, #3
    673c:	e262b003 	rsb	fp, r2, #3
    6740:	e1a02003 	mov	r2, r3
    6744:	e59dc030 	ldr	ip, [sp, #48]	; 0x30
    6748:	e1a01181 	lsl	r1, r1, #3
    674c:	e1a0c30c 	lsl	ip, ip, #6
    6750:	e58d001c 	str	r0, [sp, #28]
    6754:	e58d100c 	str	r1, [sp, #12]
    6758:	e58d3014 	str	r3, [sp, #20]
    675c:	e58dc03c 	str	ip, [sp, #60]	; 0x3c
  {
    CELLS = MCU_INDEX(MCU_YCbCr, flit_index);

    for (int cell_y_index = 0; cell_y_index < YV; cell_y_index += 1)
    6760:	e59dc018 	ldr	ip, [sp, #24]
    6764:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
    6768:	e35c0000 	cmp	ip, #0
    676c:	e0635002 	rsb	r5, r3, r2
    6770:	0a000090 	beq	69b8 <builder+0x344>
    6774:	e3a08000 	mov	r8, #0
    6778:	e3a00008 	mov	r0, #8
    677c:	e1a0100b 	mov	r1, fp
    6780:	eb001cd8 	bl	dae8 <__aeabi_uidiv>
    6784:	e59dc014 	ldr	ip, [sp, #20]
    6788:	e58d8004 	str	r8, [sp, #4]
    678c:	e24cc040 	sub	ip, ip, #64	; 0x40
    6790:	e58dc024 	str	ip, [sp, #36]	; 0x24
    {
      for (int cell_x_index = 0; cell_x_index < YH; cell_x_index += 1)
    6794:	e59d2008 	ldr	r2, [sp, #8]
    6798:	e3520000 	cmp	r2, #0
    679c:	0a00003d 	beq	6898 <builder+0x224>
    67a0:	e1a03002 	mov	r3, r2
    67a4:	e3a0e000 	mov	lr, #0
    67a8:	e1a0200e 	mov	r2, lr
    67ac:	e1a0c00e 	mov	ip, lr
    67b0:	e1a0e003 	mov	lr, r3
    67b4:	e0060893 	mul	r6, r3, r8
    67b8:	e59d7078 	ldr	r7, [sp, #120]	; 0x78
    67bc:	e58d0010 	str	r0, [sp, #16]
    67c0:	e58db000 	str	fp, [sp]
      {
        Y_SRC = MCU_INDEX(CELLS, (YH * cell_y_index + cell_x_index));
        Y_DST = FB_Y_INDEX(picture, *LB_X + cell_x_index, *LB_Y + cell_y_index);
    67c4:	e5991000 	ldr	r1, [r9]
    67c8:	e59a3000 	ldr	r3, [sl]
    67cc:	e0881001 	add	r1, r8, r1
    67d0:	e0213194 	mla	r1, r4, r1, r3

    for (int cell_y_index = 0; cell_y_index < YV; cell_y_index += 1)
    {
      for (int cell_x_index = 0; cell_x_index < YH; cell_x_index += 1)
      {
        Y_SRC = MCU_INDEX(CELLS, (YH * cell_y_index + cell_x_index));
    67d4:	e08c3006 	add	r3, ip, r6

        for (int line_index = 0; line_index < MCU_sy; line_index += 1)
        {
          y_line_src = (uint32_t *) MCU_LINE(Y_SRC, line_index);
          y_line_dst = (uint32_t *) FB_Y_LINE(Y_DST, line_index);
          *y_line_dst++ = *y_line_src++; *y_line_dst++ = *y_line_src++;
    67d8:	e7950303 	ldr	r0, [r5, r3, lsl #6]
    for (int cell_y_index = 0; cell_y_index < YV; cell_y_index += 1)
    {
      for (int cell_x_index = 0; cell_x_index < YH; cell_x_index += 1)
      {
        Y_SRC = MCU_INDEX(CELLS, (YH * cell_y_index + cell_x_index));
        Y_DST = FB_Y_INDEX(picture, *LB_X + cell_x_index, *LB_Y + cell_y_index);
    67dc:	e081c00c 	add	ip, r1, ip

        for (int line_index = 0; line_index < MCU_sy; line_index += 1)
        {
          y_line_src = (uint32_t *) MCU_LINE(Y_SRC, line_index);
          y_line_dst = (uint32_t *) FB_Y_LINE(Y_DST, line_index);
          *y_line_dst++ = *y_line_src++; *y_line_dst++ = *y_line_src++;
    67e0:	e787018c 	str	r0, [r7, ip, lsl #3]

    for (int cell_y_index = 0; cell_y_index < YV; cell_y_index += 1)
    {
      for (int cell_x_index = 0; cell_x_index < YH; cell_x_index += 1)
      {
        Y_SRC = MCU_INDEX(CELLS, (YH * cell_y_index + cell_x_index));
    67e4:	e0853303 	add	r3, r5, r3, lsl #6

        for (int line_index = 0; line_index < MCU_sy; line_index += 1)
        {
          y_line_src = (uint32_t *) MCU_LINE(Y_SRC, line_index);
          y_line_dst = (uint32_t *) FB_Y_LINE(Y_DST, line_index);
          *y_line_dst++ = *y_line_src++; *y_line_dst++ = *y_line_src++;
    67e8:	e5931004 	ldr	r1, [r3, #4]
    for (int cell_y_index = 0; cell_y_index < YV; cell_y_index += 1)
    {
      for (int cell_x_index = 0; cell_x_index < YH; cell_x_index += 1)
      {
        Y_SRC = MCU_INDEX(CELLS, (YH * cell_y_index + cell_x_index));
        Y_DST = FB_Y_INDEX(picture, *LB_X + cell_x_index, *LB_Y + cell_y_index);
    67ec:	e087c18c 	add	ip, r7, ip, lsl #3

        for (int line_index = 0; line_index < MCU_sy; line_index += 1)
        {
          y_line_src = (uint32_t *) MCU_LINE(Y_SRC, line_index);
          y_line_dst = (uint32_t *) FB_Y_LINE(Y_DST, line_index);
          *y_line_dst++ = *y_line_src++; *y_line_dst++ = *y_line_src++;
    67f0:	e58c1004 	str	r1, [ip, #4]
    67f4:	e5931008 	ldr	r1, [r3, #8]
        Y_DST = FB_Y_INDEX(picture, *LB_X + cell_x_index, *LB_Y + cell_y_index);

        for (int line_index = 0; line_index < MCU_sy; line_index += 1)
        {
          y_line_src = (uint32_t *) MCU_LINE(Y_SRC, line_index);
          y_line_dst = (uint32_t *) FB_Y_LINE(Y_DST, line_index);
    67f8:	e08c0004 	add	r0, ip, r4
          *y_line_dst++ = *y_line_src++; *y_line_dst++ = *y_line_src++;
    67fc:	e78c1004 	str	r1, [ip, r4]
    6800:	e593100c 	ldr	r1, [r3, #12]
  {
    CELLS = MCU_INDEX(MCU_YCbCr, flit_index);

    for (int cell_y_index = 0; cell_y_index < YV; cell_y_index += 1)
    {
      for (int cell_x_index = 0; cell_x_index < YH; cell_x_index += 1)
    6804:	e2822001 	add	r2, r2, #1

        for (int line_index = 0; line_index < MCU_sy; line_index += 1)
        {
          y_line_src = (uint32_t *) MCU_LINE(Y_SRC, line_index);
          y_line_dst = (uint32_t *) FB_Y_LINE(Y_DST, line_index);
          *y_line_dst++ = *y_line_src++; *y_line_dst++ = *y_line_src++;
    6808:	e5801004 	str	r1, [r0, #4]
    680c:	e5931010 	ldr	r1, [r3, #16]
  {
    CELLS = MCU_INDEX(MCU_YCbCr, flit_index);

    for (int cell_y_index = 0; cell_y_index < YV; cell_y_index += 1)
    {
      for (int cell_x_index = 0; cell_x_index < YH; cell_x_index += 1)
    6810:	e152000e 	cmp	r2, lr

        for (int line_index = 0; line_index < MCU_sy; line_index += 1)
        {
          y_line_src = (uint32_t *) MCU_LINE(Y_SRC, line_index);
          y_line_dst = (uint32_t *) FB_Y_LINE(Y_DST, line_index);
          *y_line_dst++ = *y_line_src++; *y_line_dst++ = *y_line_src++;
    6814:	e78c1084 	str	r1, [ip, r4, lsl #1]
    6818:	e593c014 	ldr	ip, [r3, #20]
        Y_DST = FB_Y_INDEX(picture, *LB_X + cell_x_index, *LB_Y + cell_y_index);

        for (int line_index = 0; line_index < MCU_sy; line_index += 1)
        {
          y_line_src = (uint32_t *) MCU_LINE(Y_SRC, line_index);
          y_line_dst = (uint32_t *) FB_Y_LINE(Y_DST, line_index);
    681c:	e0801004 	add	r1, r0, r4
          *y_line_dst++ = *y_line_src++; *y_line_dst++ = *y_line_src++;
    6820:	e581c004 	str	ip, [r1, #4]
    6824:	e593b018 	ldr	fp, [r3, #24]
        Y_DST = FB_Y_INDEX(picture, *LB_X + cell_x_index, *LB_Y + cell_y_index);

        for (int line_index = 0; line_index < MCU_sy; line_index += 1)
        {
          y_line_src = (uint32_t *) MCU_LINE(Y_SRC, line_index);
          y_line_dst = (uint32_t *) FB_Y_LINE(Y_DST, line_index);
    6828:	e081c004 	add	ip, r1, r4
          *y_line_dst++ = *y_line_src++; *y_line_dst++ = *y_line_src++;
    682c:	e780b084 	str	fp, [r0, r4, lsl #1]
    6830:	e593b01c 	ldr	fp, [r3, #28]
        Y_DST = FB_Y_INDEX(picture, *LB_X + cell_x_index, *LB_Y + cell_y_index);

        for (int line_index = 0; line_index < MCU_sy; line_index += 1)
        {
          y_line_src = (uint32_t *) MCU_LINE(Y_SRC, line_index);
          y_line_dst = (uint32_t *) FB_Y_LINE(Y_DST, line_index);
    6834:	e08c0004 	add	r0, ip, r4
          *y_line_dst++ = *y_line_src++; *y_line_dst++ = *y_line_src++;
    6838:	e58cb004 	str	fp, [ip, #4]
    683c:	e593b020 	ldr	fp, [r3, #32]
    6840:	e781b084 	str	fp, [r1, r4, lsl #1]
    6844:	e593b024 	ldr	fp, [r3, #36]	; 0x24
        Y_DST = FB_Y_INDEX(picture, *LB_X + cell_x_index, *LB_Y + cell_y_index);

        for (int line_index = 0; line_index < MCU_sy; line_index += 1)
        {
          y_line_src = (uint32_t *) MCU_LINE(Y_SRC, line_index);
          y_line_dst = (uint32_t *) FB_Y_LINE(Y_DST, line_index);
    6848:	e0801004 	add	r1, r0, r4
          *y_line_dst++ = *y_line_src++; *y_line_dst++ = *y_line_src++;
    684c:	e580b004 	str	fp, [r0, #4]
    6850:	e593b028 	ldr	fp, [r3, #40]	; 0x28
    6854:	e78cb084 	str	fp, [ip, r4, lsl #1]
    6858:	e593b02c 	ldr	fp, [r3, #44]	; 0x2c
        Y_DST = FB_Y_INDEX(picture, *LB_X + cell_x_index, *LB_Y + cell_y_index);

        for (int line_index = 0; line_index < MCU_sy; line_index += 1)
        {
          y_line_src = (uint32_t *) MCU_LINE(Y_SRC, line_index);
          y_line_dst = (uint32_t *) FB_Y_LINE(Y_DST, line_index);
    685c:	e081c004 	add	ip, r1, r4
          *y_line_dst++ = *y_line_src++; *y_line_dst++ = *y_line_src++;
    6860:	e581b004 	str	fp, [r1, #4]
    6864:	e593b030 	ldr	fp, [r3, #48]	; 0x30
    6868:	e780b084 	str	fp, [r0, r4, lsl #1]
    686c:	e593b034 	ldr	fp, [r3, #52]	; 0x34
        Y_DST = FB_Y_INDEX(picture, *LB_X + cell_x_index, *LB_Y + cell_y_index);

        for (int line_index = 0; line_index < MCU_sy; line_index += 1)
        {
          y_line_src = (uint32_t *) MCU_LINE(Y_SRC, line_index);
          y_line_dst = (uint32_t *) FB_Y_LINE(Y_DST, line_index);
    6870:	e08c0004 	add	r0, ip, r4
          *y_line_dst++ = *y_line_src++; *y_line_dst++ = *y_line_src++;
    6874:	e58cb004 	str	fp, [ip, #4]
    6878:	e593b038 	ldr	fp, [r3, #56]	; 0x38
  {
    CELLS = MCU_INDEX(MCU_YCbCr, flit_index);

    for (int cell_y_index = 0; cell_y_index < YV; cell_y_index += 1)
    {
      for (int cell_x_index = 0; cell_x_index < YH; cell_x_index += 1)
    687c:	e1a0c002 	mov	ip, r2

        for (int line_index = 0; line_index < MCU_sy; line_index += 1)
        {
          y_line_src = (uint32_t *) MCU_LINE(Y_SRC, line_index);
          y_line_dst = (uint32_t *) FB_Y_LINE(Y_DST, line_index);
          *y_line_dst++ = *y_line_src++; *y_line_dst++ = *y_line_src++;
    6880:	e781b084 	str	fp, [r1, r4, lsl #1]
    6884:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
    6888:	e5803004 	str	r3, [r0, #4]
  {
    CELLS = MCU_INDEX(MCU_YCbCr, flit_index);

    for (int cell_y_index = 0; cell_y_index < YV; cell_y_index += 1)
    {
      for (int cell_x_index = 0; cell_x_index < YH; cell_x_index += 1)
    688c:	1affffcc 	bne	67c4 <builder+0x150>
    6890:	e59d0010 	ldr	r0, [sp, #16]
    6894:	e59db000 	ldr	fp, [sp]
          *y_line_dst++ = *y_line_src++; *y_line_dst++ = *y_line_src++;
        }
      }

      U_SRC = MCU_INDEX(CELLS, (YH * YV));
      U_DST = FB_U_INDEX(picture, *LB_X, *LB_Y + cell_y_index);
    6898:	e3a06000 	mov	r6, #0
    689c:	e5992000 	ldr	r2, [r9]
    68a0:	e59de00c 	ldr	lr, [sp, #12]
    68a4:	e0882002 	add	r2, r8, r2
    68a8:	e002029e 	mul	r2, lr, r2
    68ac:	e59a3000 	ldr	r3, [sl]
    68b0:	e59d101c 	ldr	r1, [sp, #28]
    68b4:	e1a03183 	lsl	r3, r3, #3
    68b8:	e08130a3 	add	r3, r1, r3, lsr #1
    68bc:	e08330a2 	add	r3, r3, r2, lsr #1
    68c0:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
    68c4:	e58d8000 	str	r8, [sp]
    68c8:	e0823003 	add	r3, r2, r3

      for (int line_index = 0; line_index < MCU_sy; line_index += 1)
    68cc:	e1a07006 	mov	r7, r6
          *y_line_dst++ = *y_line_src++; *y_line_dst++ = *y_line_src++;
        }
      }

      U_SRC = MCU_INDEX(CELLS, (YH * YV));
      U_DST = FB_U_INDEX(picture, *LB_X, *LB_Y + cell_y_index);
    68d0:	e1a08003 	mov	r8, r3
    68d4:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
      for (int line_index = 0; line_index < MCU_sy; line_index += 1)
      {
        uv_line_src = MCU_LINE(U_SRC, line_index);
        uv_line_dst = FB_UV_LINE(U_DST, line_index);

        for (int i = 0; i < (MCU_sx / (3 - YH)); i += 1)
    68d8:	e3500000 	cmp	r0, #0
      U_DST = FB_U_INDEX(picture, *LB_X, *LB_Y + cell_y_index);

      for (int line_index = 0; line_index < MCU_sy; line_index += 1)
      {
        uv_line_src = MCU_LINE(U_SRC, line_index);
        uv_line_dst = FB_UV_LINE(U_DST, line_index);
    68dc:	e088e0c6 	add	lr, r8, r6, asr #1

        for (int i = 0; i < (MCU_sx / (3 - YH)); i += 1)
    68e0:	0a000008 	beq	6908 <builder+0x294>
    68e4:	e3a02000 	mov	r2, #0
    68e8:	e1a03002 	mov	r3, r2
        {
          uv_line_dst[i] = uv_line_src[i * (3 - YH)];
    68ec:	e001029b 	mul	r1, fp, r2
      for (int line_index = 0; line_index < MCU_sy; line_index += 1)
      {
        uv_line_src = MCU_LINE(U_SRC, line_index);
        uv_line_dst = FB_UV_LINE(U_DST, line_index);

        for (int i = 0; i < (MCU_sx / (3 - YH)); i += 1)
    68f0:	e2833001 	add	r3, r3, #1
        {
          uv_line_dst[i] = uv_line_src[i * (3 - YH)];
    68f4:	e7dc1001 	ldrb	r1, [ip, r1]
      for (int line_index = 0; line_index < MCU_sy; line_index += 1)
      {
        uv_line_src = MCU_LINE(U_SRC, line_index);
        uv_line_dst = FB_UV_LINE(U_DST, line_index);

        for (int i = 0; i < (MCU_sx / (3 - YH)); i += 1)
    68f8:	e1530000 	cmp	r3, r0
        {
          uv_line_dst[i] = uv_line_src[i * (3 - YH)];
    68fc:	e7ce1002 	strb	r1, [lr, r2]
      for (int line_index = 0; line_index < MCU_sy; line_index += 1)
      {
        uv_line_src = MCU_LINE(U_SRC, line_index);
        uv_line_dst = FB_UV_LINE(U_DST, line_index);

        for (int i = 0; i < (MCU_sx / (3 - YH)); i += 1)
    6900:	e1a02003 	mov	r2, r3
    6904:	1afffff8 	bne	68ec <builder+0x278>
      }

      U_SRC = MCU_INDEX(CELLS, (YH * YV));
      U_DST = FB_U_INDEX(picture, *LB_X, *LB_Y + cell_y_index);

      for (int line_index = 0; line_index < MCU_sy; line_index += 1)
    6908:	e2877001 	add	r7, r7, #1
    690c:	e3570008 	cmp	r7, #8
    6910:	e0866004 	add	r6, r6, r4
    6914:	e28cc008 	add	ip, ip, #8
    6918:	1affffee 	bne	68d8 <builder+0x264>
          uv_line_dst[i] = uv_line_src[i * (3 - YH)];
        }
      }

      V_SRC = MCU_INDEX(CELLS, (YH * YV + 1));
      V_DST = FB_V_INDEX(picture, *LB_X, *LB_Y + cell_y_index);
    691c:	e3a06000 	mov	r6, #0

      for (int line_index = 0; line_index < MCU_sy; line_index += 1)
    6920:	e1a07006 	mov	r7, r6
    6924:	e59d8000 	ldr	r8, [sp]
          uv_line_dst[i] = uv_line_src[i * (3 - YH)];
        }
      }

      V_SRC = MCU_INDEX(CELLS, (YH * YV + 1));
      V_DST = FB_V_INDEX(picture, *LB_X, *LB_Y + cell_y_index);
    6928:	e5993000 	ldr	r3, [r9]
    692c:	e59de00c 	ldr	lr, [sp, #12]
    6930:	e0883003 	add	r3, r8, r3
    6934:	e002039e 	mul	r2, lr, r3
    6938:	e59a3000 	ldr	r3, [sl]
    693c:	e59d1020 	ldr	r1, [sp, #32]
    6940:	e1a03183 	lsl	r3, r3, #3
    6944:	e08130a3 	add	r3, r1, r3, lsr #1
    6948:	e08330a2 	add	r3, r3, r2, lsr #1
    694c:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
    6950:	e59dc014 	ldr	ip, [sp, #20]
    6954:	e0828003 	add	r8, r2, r3
      for (int line_index = 0; line_index < MCU_sy; line_index += 1)
      {
        uv_line_src = MCU_LINE(V_SRC, line_index);
        uv_line_dst = FB_UV_LINE(V_DST, line_index);

        for (int i = 0; i < (MCU_sx / (3 - YH)); i += 1)
    6958:	e3500000 	cmp	r0, #0
      V_DST = FB_V_INDEX(picture, *LB_X, *LB_Y + cell_y_index);

      for (int line_index = 0; line_index < MCU_sy; line_index += 1)
      {
        uv_line_src = MCU_LINE(V_SRC, line_index);
        uv_line_dst = FB_UV_LINE(V_DST, line_index);
    695c:	e088e0c6 	add	lr, r8, r6, asr #1

        for (int i = 0; i < (MCU_sx / (3 - YH)); i += 1)
    6960:	0a000008 	beq	6988 <builder+0x314>
    6964:	e3a02000 	mov	r2, #0
    6968:	e1a03002 	mov	r3, r2
        {
          uv_line_dst[i] = uv_line_src[i * (3 - YH)];
    696c:	e001029b 	mul	r1, fp, r2
      for (int line_index = 0; line_index < MCU_sy; line_index += 1)
      {
        uv_line_src = MCU_LINE(V_SRC, line_index);
        uv_line_dst = FB_UV_LINE(V_DST, line_index);

        for (int i = 0; i < (MCU_sx / (3 - YH)); i += 1)
    6970:	e2833001 	add	r3, r3, #1
        {
          uv_line_dst[i] = uv_line_src[i * (3 - YH)];
    6974:	e7dc1001 	ldrb	r1, [ip, r1]
      for (int line_index = 0; line_index < MCU_sy; line_index += 1)
      {
        uv_line_src = MCU_LINE(V_SRC, line_index);
        uv_line_dst = FB_UV_LINE(V_DST, line_index);

        for (int i = 0; i < (MCU_sx / (3 - YH)); i += 1)
    6978:	e1530000 	cmp	r3, r0
        {
          uv_line_dst[i] = uv_line_src[i * (3 - YH)];
    697c:	e7ce1002 	strb	r1, [lr, r2]
      for (int line_index = 0; line_index < MCU_sy; line_index += 1)
      {
        uv_line_src = MCU_LINE(V_SRC, line_index);
        uv_line_dst = FB_UV_LINE(V_DST, line_index);

        for (int i = 0; i < (MCU_sx / (3 - YH)); i += 1)
    6980:	e1a02003 	mov	r2, r3
    6984:	1afffff8 	bne	696c <builder+0x2f8>
      }

      V_SRC = MCU_INDEX(CELLS, (YH * YV + 1));
      V_DST = FB_V_INDEX(picture, *LB_X, *LB_Y + cell_y_index);

      for (int line_index = 0; line_index < MCU_sy; line_index += 1)
    6988:	e2877001 	add	r7, r7, #1
    698c:	e3570008 	cmp	r7, #8
    6990:	e0866004 	add	r6, r6, r4
    6994:	e28cc008 	add	ip, ip, #8
    6998:	1affffee 	bne	6958 <builder+0x2e4>

  for (int flit_index = 0; flit_index < flit_size; flit_index += NB_CELLS)
  {
    CELLS = MCU_INDEX(MCU_YCbCr, flit_index);

    for (int cell_y_index = 0; cell_y_index < YV; cell_y_index += 1)
    699c:	e59d3004 	ldr	r3, [sp, #4]
    69a0:	e59dc018 	ldr	ip, [sp, #24]
    69a4:	e2833001 	add	r3, r3, #1
    69a8:	e153000c 	cmp	r3, ip
    69ac:	e58d3004 	str	r3, [sp, #4]
    69b0:	e1a08003 	mov	r8, r3
    69b4:	1affff76 	bne	6794 <builder+0x120>
          uv_line_dst[i] = uv_line_src[i * (3 - YH)];
        }
      }
    }

    *LB_X = (*LB_X + YH) % NB_MCU_X;
    69b8:	e59a0000 	ldr	r0, [sl]
    69bc:	e59d2008 	ldr	r2, [sp, #8]
    69c0:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
    69c4:	e0820000 	add	r0, r2, r0
    69c8:	eb001c83 	bl	dbdc <__aeabi_uidivmod>
    fputs ("\033[1D", stdout);
    putchar (progress_tab[block_index++ % 4]);
    fflush (stdout);
#endif

    if (*LB_X == 0)
    69cc:	e3510000 	cmp	r1, #0
          uv_line_dst[i] = uv_line_src[i * (3 - YH)];
        }
      }
    }

    *LB_X = (*LB_X + YH) % NB_MCU_X;
    69d0:	e58a1000 	str	r1, [sl]
    fputs ("\033[1D", stdout);
    putchar (progress_tab[block_index++ % 4]);
    fflush (stdout);
#endif

    if (*LB_X == 0)
    69d4:	1a000005 	bne	69f0 <builder+0x37c>
    {
      *LB_Y = (*LB_Y + YV) % NB_MCU_Y;
    69d8:	e5990000 	ldr	r0, [r9]
    69dc:	e59dc018 	ldr	ip, [sp, #24]
    69e0:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
    69e4:	e08c0000 	add	r0, ip, r0
    69e8:	eb001c7b 	bl	dbdc <__aeabi_uidivmod>
    69ec:	e5891000 	str	r1, [r9]
#ifdef PROGRESS
	printf ("Image %lu : |", imageCount++);
	fflush (stdout);
#endif

  for (int flit_index = 0; flit_index < flit_size; flit_index += NB_CELLS)
    69f0:	e59d2070 	ldr	r2, [sp, #112]	; 0x70
    69f4:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
    69f8:	e59dc030 	ldr	ip, [sp, #48]	; 0x30
    69fc:	e1520003 	cmp	r2, r3
    6a00:	e59d2014 	ldr	r2, [sp, #20]
    6a04:	e083300c 	add	r3, r3, ip
    6a08:	e59dc03c 	ldr	ip, [sp, #60]	; 0x3c
    6a0c:	e082200c 	add	r2, r2, ip
    6a10:	e58d2014 	str	r2, [sp, #20]
    6a14:	858d3034 	strhi	r3, [sp, #52]	; 0x34
    6a18:	859d2014 	ldrhi	r2, [sp, #20]
    6a1c:	8affff4f 	bhi	6760 <builder+0xec>
        fflush (stdout);
#endif
      }
    }
  }
}
    6a20:	e28dd04c 	add	sp, sp, #76	; 0x4c
    6a24:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

00006a28 <vfs_stop>:
 */

{

  return DNA_OK;
}
    6a28:	e3a00000 	mov	r0, #0
    6a2c:	e12fff1e 	bx	lr

00006a30 <vnode_volume_inspector>:
  vnode_t vnode = node;
  volume_t volume = va_arg (list, volume_t);

  watch (bool)
  {
    ensure (vnode != NULL, false);
    6a30:	e3500000 	cmp	r0, #0
 * SOURCE
 */

{
  vnode_t vnode = node;
  volume_t volume = va_arg (list, volume_t);
    6a34:	e5913000 	ldr	r3, [r1]

  watch (bool)
  {
    ensure (vnode != NULL, false);
    6a38:	012fff1e 	bxeq	lr
    ensure (volume != NULL, false);
    6a3c:	e3530000 	cmp	r3, #0
    return vnode -> volume == volume;
    6a40:	15900010 	ldrne	r0, [r0, #16]
    6a44:	10630000 	rsbne	r0, r3, r0
    6a48:	116f0f10 	clzne	r0, r0
    6a4c:	11a002a0 	lsrne	r0, r0, #5
  vnode_t vnode = node;
  volume_t volume = va_arg (list, volume_t);

  watch (bool)
  {
    ensure (vnode != NULL, false);
    6a50:	01a00003 	moveq	r0, r3
    ensure (volume != NULL, false);
    return vnode -> volume == volume;
  }
}
    6a54:	e12fff1e 	bx	lr

00006a58 <volume_destroy>:
 * RESULT
 *
 * SOURCE
 */

{
    6a58:	e92d4070 	push	{r4, r5, r6, lr}
    6a5c:	e1a05000 	mov	r5, r0
  interrupt_status_t it_status = 0;

  it_status = cpu_trap_mask_and_backup();
    6a60:	eb000c26 	bl	9b00 <cpu_trap_mask_and_backup>
    6a64:	e1a06000 	mov	r6, r0
  lock_acquire (& volume_manager . volume_list . lock);
    6a68:	e59f4030 	ldr	r4, [pc, #48]	; 6aa0 <volume_destroy+0x48>
    6a6c:	e1a00004 	mov	r0, r4
    6a70:	eb000d6e 	bl	a030 <lock_acquire>

  queue_extract (& volume_manager . volume_list, volume);
    6a74:	e1a01005 	mov	r1, r5
    6a78:	e1a00004 	mov	r0, r4
    6a7c:	eb000777 	bl	8860 <queue_extract>

  lock_release (& volume_manager . volume_list . lock);
    6a80:	e1a00004 	mov	r0, r4
    6a84:	eb00181a 	bl	caf4 <lock_release>
  cpu_trap_restore(it_status);
    6a88:	e1a00006 	mov	r0, r6
    6a8c:	eb000c54 	bl	9be4 <cpu_trap_restore>

  kernel_free (volume);
    6a90:	e1a00005 	mov	r0, r5
    6a94:	eb001b4b 	bl	d7c8 <kernel_free>
  return DNA_OK;
}
    6a98:	e3a00000 	mov	r0, #0
    6a9c:	e8bd8070 	pop	{r4, r5, r6, pc}
    6aa0:	00035600 	.word	0x00035600

00006aa4 <vnode_put>:
 * * DNA_ERROR if an error occured.
 *
 * SOURCE
 */

{
    6aa4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    6aa8:	e24dd00c 	sub	sp, sp, #12
    6aac:	e1a04002 	mov	r4, r2
    6ab0:	e1a05003 	mov	r5, r3
    6ab4:	e1a06000 	mov	r6, r0
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup();
    6ab8:	eb000c10 	bl	9b00 <cpu_trap_mask_and_backup>
    6abc:	e1a07000 	mov	r7, r0
    lock_acquire (& vnode_manager . vnode_list . lock);
    6ac0:	e59f00e8 	ldr	r0, [pc, #232]	; 6bb0 <vnode_put+0x10c>
    6ac4:	eb000d59 	bl	a030 <lock_acquire>

    vnode = queue_lookup (& vnode_manager . vnode_list,
    6ac8:	e1a02004 	mov	r2, r4
    6acc:	e58d6000 	str	r6, [sp]
    6ad0:	e1a03005 	mov	r3, r5
    6ad4:	e59f00d4 	ldr	r0, [pc, #212]	; 6bb0 <vnode_put+0x10c>
    6ad8:	e59f10d4 	ldr	r1, [pc, #212]	; 6bb4 <vnode_put+0x110>
    6adc:	eb000a9f 	bl	9560 <queue_lookup>
        vnode_id_inspector, vnid, vid);

    check (invalid_vnode, vnode != NULL, DNA_NO_VNODE);
    6ae0:	e2504000 	subs	r4, r0, #0
    6ae4:	0a00002a 	beq	6b94 <vnode_put+0xf0>

    atomic_add (& vnode -> usage_counter, -1);
    6ae8:	e2840018 	add	r0, r4, #24
    6aec:	e3e01000 	mvn	r1, #0
    6af0:	eb000ab8 	bl	95d8 <atomic_add>

    if (vnode -> usage_counter == 0)
    6af4:	e5943018 	ldr	r3, [r4, #24]
    {
      queue_extract (& vnode_manager . vnode_list, & vnode -> link);
    6af8:	e59f00b0 	ldr	r0, [pc, #176]	; 6bb0 <vnode_put+0x10c>

    check (invalid_vnode, vnode != NULL, DNA_NO_VNODE);

    atomic_add (& vnode -> usage_counter, -1);

    if (vnode -> usage_counter == 0)
    6afc:	e3530000 	cmp	r3, #0
    6b00:	1a00001d 	bne	6b7c <vnode_put+0xd8>
    {
      queue_extract (& vnode_manager . vnode_list, & vnode -> link);
    6b04:	e1a01004 	mov	r1, r4
    6b08:	eb000754 	bl	8860 <queue_extract>

      lock_release (& vnode_manager . vnode_list . lock);
    6b0c:	e59f009c 	ldr	r0, [pc, #156]	; 6bb0 <vnode_put+0x10c>
    6b10:	eb0017f7 	bl	caf4 <lock_release>
      cpu_trap_restore(it_status);
    6b14:	e1a00007 	mov	r0, r7
    6b18:	eb000c31 	bl	9be4 <cpu_trap_restore>

      volume = vnode -> volume;
    6b1c:	e5945010 	ldr	r5, [r4, #16]
      data = vnode -> data;
    6b20:	e594601c 	ldr	r6, [r4, #28]
      destroy = vnode -> destroy;
      status = volume -> cmd -> write_vnode (volume -> data, data);
    6b24:	e5953020 	ldr	r3, [r5, #32]
    6b28:	e5950024 	ldr	r0, [r5, #36]	; 0x24
    6b2c:	e593300c 	ldr	r3, [r3, #12]
    6b30:	e1a01006 	mov	r1, r6
      lock_release (& vnode_manager . vnode_list . lock);
      cpu_trap_restore(it_status);

      volume = vnode -> volume;
      data = vnode -> data;
      destroy = vnode -> destroy;
    6b34:	e5d47014 	ldrb	r7, [r4, #20]
      status = volume -> cmd -> write_vnode (volume -> data, data);
    6b38:	e12fff33 	blx	r3
      ensure (status == DNA_OK, status);
    6b3c:	e3500000 	cmp	r0, #0
    6b40:	1a000011 	bne	6b8c <vnode_put+0xe8>

      if (destroy)
    6b44:	e3570000 	cmp	r7, #0
    6b48:	0a000006 	beq	6b68 <vnode_put+0xc4>
      {
        status = volume -> cmd -> destroy_vnode (volume -> data, data); 
    6b4c:	e5953020 	ldr	r3, [r5, #32]
    6b50:	e1a01006 	mov	r1, r6
    6b54:	e5933010 	ldr	r3, [r3, #16]
    6b58:	e5950024 	ldr	r0, [r5, #36]	; 0x24
    6b5c:	e12fff33 	blx	r3
        ensure (status == DNA_OK, status);
    6b60:	e3500000 	cmp	r0, #0
    6b64:	1a000008 	bne	6b8c <vnode_put+0xe8>
      }

      kernel_free (vnode);
    6b68:	e1a00004 	mov	r0, r4
    6b6c:	eb001b15 	bl	d7c8 <kernel_free>
    {
      lock_release (& vnode_manager . vnode_list . lock);
      cpu_trap_restore(it_status);
    }

    return DNA_OK;
    6b70:	e3a00000 	mov	r0, #0
  {
    lock_release (& vnode_manager . vnode_list . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    6b74:	e28dd00c 	add	sp, sp, #12
    6b78:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

      kernel_free (vnode);
    }
    else
    {
      lock_release (& vnode_manager . vnode_list . lock);
    6b7c:	eb0017dc 	bl	caf4 <lock_release>
      cpu_trap_restore(it_status);
    6b80:	e1a00007 	mov	r0, r7
    6b84:	eb000c16 	bl	9be4 <cpu_trap_restore>
    }

    return DNA_OK;
    6b88:	e3a00000 	mov	r0, #0
  {
    lock_release (& vnode_manager . vnode_list . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    6b8c:	e28dd00c 	add	sp, sp, #12
    6b90:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    return DNA_OK;
  }

  rescue (invalid_vnode)
  {
    lock_release (& vnode_manager . vnode_list . lock);
    6b94:	e59f0014 	ldr	r0, [pc, #20]	; 6bb0 <vnode_put+0x10c>
    6b98:	eb0017d5 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    6b9c:	e1a00007 	mov	r0, r7
    6ba0:	eb000c0f 	bl	9be4 <cpu_trap_restore>
    leave;
    6ba4:	e59f000c 	ldr	r0, [pc, #12]	; 6bb8 <vnode_put+0x114>
  }
}
    6ba8:	e28dd00c 	add	sp, sp, #12
    6bac:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    6bb0:	000355e8 	.word	0x000355e8
    6bb4:	0000767c 	.word	0x0000767c
    6bb8:	0000fefd 	.word	0x0000fefd

00006bbc <vnode_get>:
 * * DNA_OK if the operation succeeded.
 *
 * SOURCE
 */

{
    6bbc:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    6bc0:	e24dd00c 	sub	sp, sp, #12
    6bc4:	e59d6028 	ldr	r6, [sp, #40]	; 0x28
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (data != NULL, DNA_ERROR);
    6bc8:	e3560000 	cmp	r6, #0
    6bcc:	0a00001f 	beq	6c50 <vnode_get+0x94>
    6bd0:	e1a04002 	mov	r4, r2
    6bd4:	e1a05003 	mov	r5, r3
    6bd8:	e1a08000 	mov	r8, r0

    it_status = cpu_trap_mask_and_backup();
    6bdc:	eb000bc7 	bl	9b00 <cpu_trap_mask_and_backup>
    6be0:	e1a09000 	mov	r9, r0
    lock_acquire (& vnode_manager . vnode_list . lock);
    6be4:	e59f00e4 	ldr	r0, [pc, #228]	; 6cd0 <vnode_get+0x114>
    6be8:	eb000d10 	bl	a030 <lock_acquire>

    vnode = queue_lookup (& vnode_manager . vnode_list,
    6bec:	e59f10e0 	ldr	r1, [pc, #224]	; 6cd4 <vnode_get+0x118>
    6bf0:	e1a02004 	mov	r2, r4
    6bf4:	e1a03005 	mov	r3, r5
    6bf8:	e58d8000 	str	r8, [sp]
    6bfc:	e59f00cc 	ldr	r0, [pc, #204]	; 6cd0 <vnode_get+0x114>
    6c00:	eb000a56 	bl	9560 <queue_lookup>
    6c04:	e1a07000 	mov	r7, r0
        vnode_id_inspector, vnid, vid);

    lock_release (& vnode_manager . vnode_list . lock);
    6c08:	e59f00c0 	ldr	r0, [pc, #192]	; 6cd0 <vnode_get+0x114>
    6c0c:	eb0017b8 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    6c10:	e1a00009 	mov	r0, r9
    6c14:	eb000bf2 	bl	9be4 <cpu_trap_restore>

    if (vnode == NULL)
    6c18:	e3570000 	cmp	r7, #0
    6c1c:	0a00000e 	beq	6c5c <vnode_get+0xa0>
      ensure (status == DNA_OK, status);

      status = vnode_create (vnid, volume -> id, *data);
      ensure (status == DNA_OK, status);
    }
    else if (! vnode -> destroy)
    6c20:	e5d74014 	ldrb	r4, [r7, #20]
    6c24:	e3540000 	cmp	r4, #0
    {
      *data = vnode -> data;
      atomic_add (& vnode -> usage_counter, 1);
    }

    return DNA_OK;
    6c28:	13a00000 	movne	r0, #0
      ensure (status == DNA_OK, status);

      status = vnode_create (vnid, volume -> id, *data);
      ensure (status == DNA_OK, status);
    }
    else if (! vnode -> destroy)
    6c2c:	1a000005 	bne	6c48 <vnode_get+0x8c>
    {
      *data = vnode -> data;
    6c30:	e597301c 	ldr	r3, [r7, #28]
      atomic_add (& vnode -> usage_counter, 1);
    6c34:	e2870018 	add	r0, r7, #24
      status = vnode_create (vnid, volume -> id, *data);
      ensure (status == DNA_OK, status);
    }
    else if (! vnode -> destroy)
    {
      *data = vnode -> data;
    6c38:	e5863000 	str	r3, [r6]
      atomic_add (& vnode -> usage_counter, 1);
    6c3c:	e3a01001 	mov	r1, #1
    6c40:	eb000a64 	bl	95d8 <atomic_add>
    }

    return DNA_OK;
    6c44:	e1a00004 	mov	r0, r4
  }
}
    6c48:	e28dd00c 	add	sp, sp, #12
    6c4c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (data != NULL, DNA_ERROR);
    6c50:	e59f0080 	ldr	r0, [pc, #128]	; 6cd8 <vnode_get+0x11c>
      atomic_add (& vnode -> usage_counter, 1);
    }

    return DNA_OK;
  }
}
    6c54:	e28dd00c 	add	sp, sp, #12
    6c58:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
    lock_release (& vnode_manager . vnode_list . lock);
    cpu_trap_restore(it_status);

    if (vnode == NULL)
    {
      it_status = cpu_trap_mask_and_backup();
    6c5c:	eb000ba7 	bl	9b00 <cpu_trap_mask_and_backup>
    6c60:	e1a09000 	mov	r9, r0
      lock_acquire (& volume_manager . volume_list . lock);
    6c64:	e59f0070 	ldr	r0, [pc, #112]	; 6cdc <vnode_get+0x120>
    6c68:	eb000cf0 	bl	a030 <lock_acquire>

      volume = queue_lookup (& volume_manager . volume_list,
    6c6c:	e1a02008 	mov	r2, r8
    6c70:	e59f1068 	ldr	r1, [pc, #104]	; 6ce0 <vnode_get+0x124>
    6c74:	e59f0060 	ldr	r0, [pc, #96]	; 6cdc <vnode_get+0x120>
    6c78:	eb000a38 	bl	9560 <queue_lookup>
    6c7c:	e1a07000 	mov	r7, r0
          volume_id_inspector, vid);

      lock_release (& volume_manager . volume_list . lock);
    6c80:	e59f0054 	ldr	r0, [pc, #84]	; 6cdc <vnode_get+0x120>
    6c84:	eb00179a 	bl	caf4 <lock_release>
      cpu_trap_restore(it_status);
    6c88:	e1a00009 	mov	r0, r9
    6c8c:	eb000bd4 	bl	9be4 <cpu_trap_restore>

      status = volume -> cmd -> read_vnode (volume -> data, vnid, data);
    6c90:	e5973020 	ldr	r3, [r7, #32]
    6c94:	e5970024 	ldr	r0, [r7, #36]	; 0x24
    6c98:	e58d6000 	str	r6, [sp]
    6c9c:	e5931008 	ldr	r1, [r3, #8]
    6ca0:	e1a02004 	mov	r2, r4
    6ca4:	e1a03005 	mov	r3, r5
    6ca8:	e12fff31 	blx	r1
      ensure (status == DNA_OK, status);
    6cac:	e3500000 	cmp	r0, #0
    6cb0:	1affffe4 	bne	6c48 <vnode_get+0x8c>

      status = vnode_create (vnid, volume -> id, *data);
    6cb4:	e1a00004 	mov	r0, r4
    6cb8:	e1a01005 	mov	r1, r5
    6cbc:	e5972004 	ldr	r2, [r7, #4]
    6cc0:	e5963000 	ldr	r3, [r6]
      atomic_add (& vnode -> usage_counter, 1);
    }

    return DNA_OK;
  }
}
    6cc4:	e28dd00c 	add	sp, sp, #12
    6cc8:	e8bd43f0 	pop	{r4, r5, r6, r7, r8, r9, lr}
      cpu_trap_restore(it_status);

      status = volume -> cmd -> read_vnode (volume -> data, vnid, data);
      ensure (status == DNA_OK, status);

      status = vnode_create (vnid, volume -> id, *data);
    6ccc:	ea00009a 	b	6f3c <vnode_create>
    6cd0:	000355e8 	.word	0x000355e8
    6cd4:	0000767c 	.word	0x0000767c
    6cd8:	0000ffff 	.word	0x0000ffff
    6cdc:	00035600 	.word	0x00035600
    6ce0:	00007de4 	.word	0x00007de4

00006ce4 <vfs_readdir>:
 * * DNA_OK : the operation succeeded
 *
 * SOURCE
 */

{
    6ce4:	e92d4070 	push	{r4, r5, r6, lr}
  int32_t n_data = count;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (entry_array != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    6ce8:	e3530000 	cmp	r3, #0
    6cec:	13510000 	cmpne	r1, #0
    6cf0:	e1a04003 	mov	r4, r3
 *
 * SOURCE
 */

{
  file_t file = NULL;
    6cf4:	e3a03000 	mov	r3, #0
 * * DNA_OK : the operation succeeded
 *
 * SOURCE
 */

{
    6cf8:	e24dd010 	sub	sp, sp, #16
  int32_t n_data = count;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (entry_array != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    6cfc:	e1a05001 	mov	r5, r1
 * SOURCE
 */

{
  file_t file = NULL;
  int32_t n_data = count;
    6d00:	e58d200c 	str	r2, [sp, #12]
 *
 * SOURCE
 */

{
  file_t file = NULL;
    6d04:	e58d3008 	str	r3, [sp, #8]
  int32_t n_data = count;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (entry_array != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    6d08:	1a000002 	bne	6d18 <vfs_readdir+0x34>
    6d0c:	e59f00ac 	ldr	r0, [pc, #172]	; 6dc0 <vfs_readdir+0xdc>
    panic (status != DNA_OK);

    *p_ret = -1;
    leave;
  }
}
    6d10:	e28dd010 	add	sp, sp, #16
    6d14:	e8bd8070 	pop	{r4, r5, r6, pc}
  int32_t n_data = count;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (entry_array != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    6d18:	e1520003 	cmp	r2, r3
    6d1c:	0afffffa 	beq	6d0c <vfs_readdir+0x28>
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    6d20:	e6ff3070 	uxth	r3, r0
    6d24:	e35300ff 	cmp	r3, #255	; 0xff
    6d28:	e1a06000 	mov	r6, r0
    6d2c:	859f0090 	ldrhi	r0, [pc, #144]	; 6dc4 <vfs_readdir+0xe0>
    6d30:	8afffff6 	bhi	6d10 <vfs_readdir+0x2c>

    /*
     * Get the file associated to the fd.
     */

    status = file_get (fd, & file);
    6d34:	e28d1008 	add	r1, sp, #8
    6d38:	eb0001bd 	bl	7434 <file_get>
    ensure (status == DNA_OK, status);
    6d3c:	e3500000 	cmp	r0, #0
    6d40:	1afffff2 	bne	6d10 <vfs_readdir+0x2c>

    /*
     * Read the file.
     */

    status = file -> vnode -> volume -> cmd -> readdir
    6d44:	e59d3008 	ldr	r3, [sp, #8]
    6d48:	e28de00c 	add	lr, sp, #12
    6d4c:	e5931008 	ldr	r1, [r3, #8]
    6d50:	e5932020 	ldr	r2, [r3, #32]
    6d54:	e5910010 	ldr	r0, [r1, #16]
      (file -> vnode -> volume -> data, file -> vnode -> data,
    6d58:	e2833018 	add	r3, r3, #24

    /*
     * Read the file.
     */

    status = file -> vnode -> volume -> cmd -> readdir
    6d5c:	e590c020 	ldr	ip, [r0, #32]
    6d60:	e591101c 	ldr	r1, [r1, #28]
    6d64:	e5900024 	ldr	r0, [r0, #36]	; 0x24
    6d68:	e88d4008 	stm	sp, {r3, lr}
    6d6c:	e1a03005 	mov	r3, r5
    6d70:	e59cc038 	ldr	ip, [ip, #56]	; 0x38
    6d74:	e12fff3c 	blx	ip
      (file -> vnode -> volume -> data, file -> vnode -> data,
       file -> data, entry_array, & file -> offset, & n_data);

    check (error, status == DNA_OK, status);
    6d78:	e2505000 	subs	r5, r0, #0
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    6d7c:	e1a00006 	mov	r0, r6

    status = file -> vnode -> volume -> cmd -> readdir
      (file -> vnode -> volume -> data, file -> vnode -> data,
       file -> data, entry_array, & file -> offset, & n_data);

    check (error, status == DNA_OK, status);
    6d80:	0a000003 	beq	6d94 <vfs_readdir+0xb0>
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    6d84:	eb000375 	bl	7b60 <file_put>
    panic (status != DNA_OK);
    6d88:	e3500000 	cmp	r0, #0
    6d8c:	0a000007 	beq	6db0 <vfs_readdir+0xcc>
    6d90:	eafffffe 	b	6d90 <vfs_readdir+0xac>

    /*
     * Release the file and return.
     */

    status = file_put (fd);
    6d94:	eb000371 	bl	7b60 <file_put>
    panic (status != DNA_OK);
    6d98:	e3500000 	cmp	r0, #0
    6d9c:	0a000000 	beq	6da4 <vfs_readdir+0xc0>
    6da0:	eafffffe 	b	6da0 <vfs_readdir+0xbc>

    *p_ret = n_data;
    6da4:	e59d300c 	ldr	r3, [sp, #12]
    6da8:	e5843000 	str	r3, [r4]
    return DNA_OK;
    6dac:	eaffffd7 	b	6d10 <vfs_readdir+0x2c>
  rescue (error)
  {
    status = file_put (fd);
    panic (status != DNA_OK);

    *p_ret = -1;
    6db0:	e3e03000 	mvn	r3, #0
    leave;
    6db4:	e1a00005 	mov	r0, r5
  rescue (error)
  {
    status = file_put (fd);
    panic (status != DNA_OK);

    *p_ret = -1;
    6db8:	e5843000 	str	r3, [r4]
    leave;
    6dbc:	eaffffd3 	b	6d10 <vfs_readdir+0x2c>
    6dc0:	0000ffff 	.word	0x0000ffff
    6dc4:	0000fef8 	.word	0x0000fef8

00006dc8 <file_create>:
 * * DNA_OK if the operation succeed
 *
 * SOURCE
 */

{
    6dc8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    6dcc:	e24dd064 	sub	sp, sp, #100	; 0x64
    6dd0:	e1a07000 	mov	r7, r0
    6dd4:	e1a05001 	mov	r5, r1
  file_t file = NULL, * file_array = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    6dd8:	e3a00000 	mov	r0, #0
    6ddc:	e28d100c 	add	r1, sp, #12
 * * DNA_OK if the operation succeed
 *
 * SOURCE
 */

{
    6de0:	e1a06002 	mov	r6, r2
    6de4:	e1a04003 	mov	r4, r3
  file_t file = NULL, * file_array = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    6de8:	eb001884 	bl	d000 <thread_find>
    ensure (status == DNA_OK, status);
    6dec:	e3500000 	cmp	r0, #0
    6df0:	0a000001 	beq	6dfc <file_create+0x34>
  {
    lock_release (& file_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    6df4:	e28dd064 	add	sp, sp, #100	; 0x64
    6df8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    ensure (status == DNA_OK, status);

    status = thread_get_info (tid, & info);
    6dfc:	e59d000c 	ldr	r0, [sp, #12]
    6e00:	e28d1010 	add	r1, sp, #16
    6e04:	eb001426 	bl	bea4 <thread_get_info>
    ensure (status == DNA_OK, status);
    6e08:	e3500000 	cmp	r0, #0
    6e0c:	1afffff8 	bne	6df4 <file_create+0x2c>

    ensure (info . group >= 0, DNA_BAD_ARGUMENT);
    ensure (info . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    6e10:	e59d8034 	ldr	r8, [sp, #52]	; 0x34
    6e14:	e3580000 	cmp	r8, #0
    6e18:	0a000002 	beq	6e28 <file_create+0x60>
    6e1c:	e59f0108 	ldr	r0, [pc, #264]	; 6f2c <file_create+0x164>
  {
    lock_release (& file_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    6e20:	e28dd064 	add	sp, sp, #100	; 0x64
    6e24:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ensure (status == DNA_OK, status);

    ensure (info . group >= 0, DNA_BAD_ARGUMENT);
    ensure (info . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);

    ensure (p_fd != NULL, DNA_BAD_ARGUMENT);
    6e28:	e3540000 	cmp	r4, #0
    6e2c:	0afffffa 	beq	6e1c <file_create+0x54>
    ensure (p_file != NULL, DNA_BAD_ARGUMENT);
    6e30:	e59d3088 	ldr	r3, [sp, #136]	; 0x88
    6e34:	e3530000 	cmp	r3, #0
    6e38:	0afffff7 	beq	6e1c <file_create+0x54>

    it_status = cpu_trap_mask_and_backup();
    6e3c:	eb000b2f 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& file_pool . lock);
    6e40:	e59f90e8 	ldr	r9, [pc, #232]	; 6f30 <file_create+0x168>
    ensure (info . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);

    ensure (p_fd != NULL, DNA_BAD_ARGUMENT);
    ensure (p_file != NULL, DNA_BAD_ARGUMENT);

    it_status = cpu_trap_mask_and_backup();
    6e44:	e58d0004 	str	r0, [sp, #4]
    lock_acquire (& file_pool . lock);
    6e48:	e1a00009 	mov	r0, r9
    6e4c:	eb000c77 	bl	a030 <lock_acquire>

    /*
     * Find a free file descriptor.
     */

    file_array = file_pool . file[info . group];
    6e50:	e5993004 	ldr	r3, [r9, #4]
    6e54:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
    6e58:	e7933102 	ldr	r3, [r3, r2, lsl #2]

    for (fd = 0; file_array[fd] != NULL && fd < DNA_MAX_FILE; fd += 1);
    6e5c:	e593b000 	ldr	fp, [r3]
    6e60:	e35b0000 	cmp	fp, #0
    6e64:	0a00002e 	beq	6f24 <file_create+0x15c>
    6e68:	e2630004 	rsb	r0, r3, #4
    6e6c:	ea000001 	b	6e78 <file_create+0xb0>
    6e70:	e3520c01 	cmp	r2, #256	; 0x100
    6e74:	0a000028 	beq	6f1c <file_create+0x154>
    6e78:	e080b003 	add	fp, r0, r3
    6e7c:	e5b31004 	ldr	r1, [r3, #4]!
    6e80:	e2888001 	add	r8, r8, #1
    6e84:	e6ff2078 	uxth	r2, r8
    6e88:	e3510000 	cmp	r1, #0
    6e8c:	e6ff8072 	uxth	r8, r2
    6e90:	1afffff6 	bne	6e70 <file_create+0xa8>
    check (error, fd != DNA_MAX_FILE, DNA_MAX_OPENED_FILES);
    6e94:	e6bf2078 	sxth	r2, r8
    6e98:	e3520c01 	cmp	r2, #256	; 0x100
    6e9c:	e1a0a008 	mov	sl, r8
    6ea0:	0a00001d 	beq	6f1c <file_create+0x154>

    /*
     * Allocate the new file.
     */

    file = kernel_malloc (sizeof (struct _file), true);
    6ea4:	e3a00028 	mov	r0, #40	; 0x28
    6ea8:	e3a01001 	mov	r1, #1
    6eac:	eb001a10 	bl	d6f4 <kernel_malloc>
    check (error, file != NULL, DNA_OUT_OF_MEM);
    6eb0:	e2508000 	subs	r8, r0, #0
    6eb4:	0a000011 	beq	6f00 <file_create+0x138>

    file -> vnode = vnode;
    file -> mode = mode;
    file -> data = data;
    file -> usage_counter = 1;
    6eb8:	e3a01001 	mov	r1, #1

    file_pool . file[info . group][fd] = file;
    6ebc:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
    6ec0:	e5992004 	ldr	r2, [r9, #4]
     */

    file = kernel_malloc (sizeof (struct _file), true);
    check (error, file != NULL, DNA_OUT_OF_MEM);

    file -> vnode = vnode;
    6ec4:	e5887008 	str	r7, [r8, #8]
    file -> mode = mode;
    file -> data = data;
    6ec8:	e5886020 	str	r6, [r8, #32]
    file -> usage_counter = 1;

    file_pool . file[info . group][fd] = file;
    6ecc:	e7922100 	ldr	r2, [r2, r0, lsl #2]
    check (error, file != NULL, DNA_OUT_OF_MEM);

    file -> vnode = vnode;
    file -> mode = mode;
    file -> data = data;
    file -> usage_counter = 1;
    6ed0:	e5881004 	str	r1, [r8, #4]

    file = kernel_malloc (sizeof (struct _file), true);
    check (error, file != NULL, DNA_OUT_OF_MEM);

    file -> vnode = vnode;
    file -> mode = mode;
    6ed4:	e5885010 	str	r5, [r8, #16]
    file -> data = data;
    file -> usage_counter = 1;

    file_pool . file[info . group][fd] = file;

    lock_release (& file_pool . lock);
    6ed8:	e59f0050 	ldr	r0, [pc, #80]	; 6f30 <file_create+0x168>
    file -> vnode = vnode;
    file -> mode = mode;
    file -> data = data;
    file -> usage_counter = 1;

    file_pool . file[info . group][fd] = file;
    6edc:	e782800b 	str	r8, [r2, fp]

    lock_release (& file_pool . lock);
    6ee0:	eb001703 	bl	caf4 <lock_release>
    cpu_trap_restore (it_status);
    6ee4:	e59d0004 	ldr	r0, [sp, #4]
    6ee8:	eb000b3d 	bl	9be4 <cpu_trap_restore>
     */

    dna_log(VERBOSE_LEVEL, "Created FD (%d, 0x%x).", fd, file);

    *p_fd = fd;
    *p_file = file;
    6eec:	e59d3088 	ldr	r3, [sp, #136]	; 0x88
     * Return the new file and the new FD.
     */

    dna_log(VERBOSE_LEVEL, "Created FD (%d, 0x%x).", fd, file);

    *p_fd = fd;
    6ef0:	e1c4a0b0 	strh	sl, [r4]
    *p_file = file;

    return DNA_OK;
    6ef4:	e3a00000 	mov	r0, #0
     */

    dna_log(VERBOSE_LEVEL, "Created FD (%d, 0x%x).", fd, file);

    *p_fd = fd;
    *p_file = file;
    6ef8:	e5838000 	str	r8, [r3]

    return DNA_OK;
    6efc:	eaffffbc 	b	6df4 <file_create+0x2c>
    /*
     * Allocate the new file.
     */

    file = kernel_malloc (sizeof (struct _file), true);
    check (error, file != NULL, DNA_OUT_OF_MEM);
    6f00:	e59f402c 	ldr	r4, [pc, #44]	; 6f34 <file_create+0x16c>
    return DNA_OK;
  }

  rescue (error)
  {
    lock_release (& file_pool . lock);
    6f04:	e59f0024 	ldr	r0, [pc, #36]	; 6f30 <file_create+0x168>
    6f08:	eb0016f9 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    6f0c:	e59d0004 	ldr	r0, [sp, #4]
    6f10:	eb000b33 	bl	9be4 <cpu_trap_restore>
    leave;
    6f14:	e1a00004 	mov	r0, r4
    6f18:	eaffffb5 	b	6df4 <file_create+0x2c>
     */

    file_array = file_pool . file[info . group];

    for (fd = 0; file_array[fd] != NULL && fd < DNA_MAX_FILE; fd += 1);
    check (error, fd != DNA_MAX_FILE, DNA_MAX_OPENED_FILES);
    6f1c:	e59f4014 	ldr	r4, [pc, #20]	; 6f38 <file_create+0x170>
    6f20:	eafffff7 	b	6f04 <file_create+0x13c>
     * Find a free file descriptor.
     */

    file_array = file_pool . file[info . group];

    for (fd = 0; file_array[fd] != NULL && fd < DNA_MAX_FILE; fd += 1);
    6f24:	e1a0a00b 	mov	sl, fp
    6f28:	eaffffdd 	b	6ea4 <file_create+0xdc>
    6f2c:	0000fffc 	.word	0x0000fffc
    6f30:	000355dc 	.word	0x000355dc
    6f34:	0000fffd 	.word	0x0000fffd
    6f38:	0000fef9 	.word	0x0000fef9

00006f3c <vnode_create>:
 * * DNA_OUT_OF_MEM if the system ran out of memory during the operation.
 *
 * SOURCE
 */

{
    6f3c:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    6f40:	e24dd00c 	sub	sp, sp, #12
    6f44:	e1a09003 	mov	r9, r3
    6f48:	e1a06002 	mov	r6, r2
    6f4c:	e1a05001 	mov	r5, r1
    6f50:	e1a04000 	mov	r4, r0
  {
    /*
     * We first volume corresponding to vid
     */

    it_status = cpu_trap_mask_and_backup();
    6f54:	eb000ae9 	bl	9b00 <cpu_trap_mask_and_backup>
    6f58:	e1a08000 	mov	r8, r0
    lock_acquire (& volume_manager . volume_list . lock);
    6f5c:	e59f00e4 	ldr	r0, [pc, #228]	; 7048 <vnode_create+0x10c>
    6f60:	eb000c32 	bl	a030 <lock_acquire>

    volume = queue_lookup (& volume_manager . volume_list,
    6f64:	e1a02006 	mov	r2, r6
    6f68:	e59f10dc 	ldr	r1, [pc, #220]	; 704c <vnode_create+0x110>
    6f6c:	e59f00d4 	ldr	r0, [pc, #212]	; 7048 <vnode_create+0x10c>
    6f70:	eb00097a 	bl	9560 <queue_lookup>
    6f74:	e1a07000 	mov	r7, r0
        volume_id_inspector, vid);

    lock_release (& volume_manager . volume_list . lock);
    6f78:	e59f00c8 	ldr	r0, [pc, #200]	; 7048 <vnode_create+0x10c>
    6f7c:	eb0016dc 	bl	caf4 <lock_release>
    cpu_trap_restore (it_status);
    6f80:	e1a00008 	mov	r0, r8
    6f84:	eb000b16 	bl	9be4 <cpu_trap_restore>

    ensure (volume != NULL, DNA_NO_VOLUME);
    6f88:	e3570000 	cmp	r7, #0
    6f8c:	059f00bc 	ldreq	r0, [pc, #188]	; 7050 <vnode_create+0x114>
    6f90:	0a000011 	beq	6fdc <vnode_create+0xa0>
    
    /*
     * Then we can check if the vnid is not already taken
     */

    it_status = cpu_trap_mask_and_backup();
    6f94:	eb000ad9 	bl	9b00 <cpu_trap_mask_and_backup>
    6f98:	e1a08000 	mov	r8, r0
    lock_acquire (& vnode_manager . vnode_list . lock);
    6f9c:	e59f00b0 	ldr	r0, [pc, #176]	; 7054 <vnode_create+0x118>
    6fa0:	eb000c22 	bl	a030 <lock_acquire>

    vnode = queue_lookup (& vnode_manager . vnode_list,
    6fa4:	e59f10ac 	ldr	r1, [pc, #172]	; 7058 <vnode_create+0x11c>
    6fa8:	e1a02004 	mov	r2, r4
    6fac:	e1a03005 	mov	r3, r5
    6fb0:	e58d6000 	str	r6, [sp]
    6fb4:	e59f0098 	ldr	r0, [pc, #152]	; 7054 <vnode_create+0x118>
    6fb8:	eb000968 	bl	9560 <queue_lookup>
    6fbc:	e1a06000 	mov	r6, r0
        vnode_id_inspector, vnid, vid);

    lock_release (& vnode_manager . vnode_list . lock);
    6fc0:	e59f008c 	ldr	r0, [pc, #140]	; 7054 <vnode_create+0x118>
    6fc4:	eb0016ca 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    6fc8:	e1a00008 	mov	r0, r8
    6fcc:	eb000b04 	bl	9be4 <cpu_trap_restore>

    ensure (vnode == NULL, DNA_ERROR);
    6fd0:	e3560000 	cmp	r6, #0
    6fd4:	159f0080 	ldrne	r0, [pc, #128]	; 705c <vnode_create+0x120>
    6fd8:	0a000001 	beq	6fe4 <vnode_create+0xa8>
    lock_release (& vnode_manager . vnode_list . lock);
    cpu_trap_restore(it_status);

    return DNA_OK;
  }
}
    6fdc:	e28dd00c 	add	sp, sp, #12
    6fe0:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}

    /*
     * Next, we create the vnode
     */

    vnode = kernel_malloc (sizeof (struct _vnode), true);
    6fe4:	e3a00020 	mov	r0, #32
    6fe8:	e3a01001 	mov	r1, #1
    6fec:	eb0019c0 	bl	d6f4 <kernel_malloc>
    ensure (vnode != NULL, DNA_OUT_OF_MEM);
    6ff0:	e2508000 	subs	r8, r0, #0
    6ff4:	059f0064 	ldreq	r0, [pc, #100]	; 7060 <vnode_create+0x124>
    6ff8:	0afffff7 	beq	6fdc <vnode_create+0xa0>

    vnode -> id = vnid;
    vnode -> volume = volume;
    vnode -> destroy = false;
    vnode -> data = data;
    vnode -> usage_counter = 1;
    6ffc:	e3a03001 	mov	r3, #1
     */

    vnode = kernel_malloc (sizeof (struct _vnode), true);
    ensure (vnode != NULL, DNA_OUT_OF_MEM);

    vnode -> id = vnid;
    7000:	e1c840f8 	strd	r4, [r8, #8]
    vnode -> volume = volume;
    vnode -> destroy = false;
    vnode -> data = data;
    vnode -> usage_counter = 1;
    7004:	e5883018 	str	r3, [r8, #24]

    vnode = kernel_malloc (sizeof (struct _vnode), true);
    ensure (vnode != NULL, DNA_OUT_OF_MEM);

    vnode -> id = vnid;
    vnode -> volume = volume;
    7008:	e5887010 	str	r7, [r8, #16]
    vnode -> destroy = false;
    700c:	e5c86014 	strb	r6, [r8, #20]
    vnode -> data = data;
    7010:	e588901c 	str	r9, [r8, #28]

    /*
     * And finally we add it to the vnode manager
     */

    it_status = cpu_trap_mask_and_backup();
    7014:	eb000ab9 	bl	9b00 <cpu_trap_mask_and_backup>
    7018:	e1a04000 	mov	r4, r0
    lock_acquire (& vnode_manager . vnode_list . lock);
    701c:	e59f0030 	ldr	r0, [pc, #48]	; 7054 <vnode_create+0x118>
    7020:	eb000c02 	bl	a030 <lock_acquire>

    queue_add (& vnode_manager . vnode_list, vnode);
    7024:	e1a01008 	mov	r1, r8
    7028:	e59f0024 	ldr	r0, [pc, #36]	; 7054 <vnode_create+0x118>
    702c:	eb000914 	bl	9484 <queue_add>

    lock_release (& vnode_manager . vnode_list . lock);
    7030:	e59f001c 	ldr	r0, [pc, #28]	; 7054 <vnode_create+0x118>
    7034:	eb0016ae 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    7038:	e1a00004 	mov	r0, r4
    703c:	eb000ae8 	bl	9be4 <cpu_trap_restore>

    return DNA_OK;
    7040:	e1a00006 	mov	r0, r6
    7044:	eaffffe4 	b	6fdc <vnode_create+0xa0>
    7048:	00035600 	.word	0x00035600
    704c:	00007de4 	.word	0x00007de4
    7050:	0000fefe 	.word	0x0000fefe
    7054:	000355e8 	.word	0x000355e8
    7058:	0000767c 	.word	0x0000767c
    705c:	0000ffff 	.word	0x0000ffff
    7060:	0000fffd 	.word	0x0000fffd

00007064 <vfs_set_info>:
 *
 * SOURCE
 */

{
  file_t file = NULL;
    7064:	e3a01000 	mov	r1, #0
 * File attributes are modified depending on the mask.
 *
 * SOURCE
 */

{
    7068:	e24dd008 	sub	sp, sp, #8
    706c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    7070:	e6ffc070 	uxth	ip, r0
 * File attributes are modified depending on the mask.
 *
 * SOURCE
 */

{
    7074:	e24dd050 	sub	sp, sp, #80	; 0x50
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    7078:	e35c00ff 	cmp	ip, #255	; 0xff
 * File attributes are modified depending on the mask.
 *
 * SOURCE
 */

{
    707c:	e28d4068 	add	r4, sp, #104	; 0x68
    7080:	e1a05000 	mov	r5, r0
  file_t file = NULL;
    7084:	e58d104c 	str	r1, [sp, #76]	; 0x4c
 * File attributes are modified depending on the mask.
 *
 * SOURCE
 */

{
    7088:	e884000c 	stm	r4, {r2, r3}
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    708c:	859f00b4 	ldrhi	r0, [pc, #180]	; 7148 <vfs_set_info+0xe4>
    7090:	9a000003 	bls	70a4 <vfs_set_info+0x40>
  {
    status = file_put (fd);
    panic (status != DNA_OK);
    leave;
  }
}
    7094:	e28dd050 	add	sp, sp, #80	; 0x50
    7098:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
    709c:	e28dd008 	add	sp, sp, #8
    70a0:	e12fff1e 	bx	lr

    /*
     * Get the file associated to the fd.
     */

    status = file_get (fd, & file);
    70a4:	e28d104c 	add	r1, sp, #76	; 0x4c
    70a8:	eb0000e1 	bl	7434 <file_get>
    ensure (status == DNA_OK, status);
    70ac:	e3500000 	cmp	r0, #0
    70b0:	1afffff7 	bne	7094 <vfs_set_info+0x30>

    /*
     * Call ioctl on the file.
     */

    status = file -> vnode -> volume -> cmd -> set_info
    70b4:	e1a0e004 	mov	lr, r4
    70b8:	e1a0c00d 	mov	ip, sp
    70bc:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    70c0:	e59d404c 	ldr	r4, [sp, #76]	; 0x4c
    70c4:	e5946008 	ldr	r6, [r4, #8]
    70c8:	e5947020 	ldr	r7, [r4, #32]
    70cc:	e5964010 	ldr	r4, [r6, #16]
    70d0:	e596801c 	ldr	r8, [r6, #28]
    70d4:	e5946020 	ldr	r6, [r4, #32]
    70d8:	e5944024 	ldr	r4, [r4, #36]	; 0x24
    70dc:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    70e0:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    70e4:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    70e8:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
    70ec:	e8ac000f 	stmia	ip!, {r0, r1, r2, r3}
    70f0:	e89e000f 	ldm	lr, {r0, r1, r2, r3}
    70f4:	e88c000f 	stm	ip, {r0, r1, r2, r3}
    70f8:	e59d30a8 	ldr	r3, [sp, #168]	; 0xa8
    70fc:	e1a00004 	mov	r0, r4
    7100:	e58d3040 	str	r3, [sp, #64]	; 0x40
    7104:	e1a01008 	mov	r1, r8
    7108:	e1a02007 	mov	r2, r7
    710c:	e5963030 	ldr	r3, [r6, #48]	; 0x30
    7110:	e12fff33 	blx	r3
      (file -> vnode -> volume -> data, file -> vnode -> data,
       file -> data, info, mask);

    check (error, status == DNA_OK, status);
    7114:	e2504000 	subs	r4, r0, #0
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    7118:	e1a00005 	mov	r0, r5

    status = file -> vnode -> volume -> cmd -> set_info
      (file -> vnode -> volume -> data, file -> vnode -> data,
       file -> data, info, mask);

    check (error, status == DNA_OK, status);
    711c:	0a000003 	beq	7130 <vfs_set_info+0xcc>
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    7120:	eb00028e 	bl	7b60 <file_put>
    panic (status != DNA_OK);
    7124:	e3500000 	cmp	r0, #0
    7128:	0a000004 	beq	7140 <vfs_set_info+0xdc>
    712c:	eafffffe 	b	712c <vfs_set_info+0xc8>

    /*
     * Release the file and return.
     */

    status = file_put (fd);
    7130:	eb00028a 	bl	7b60 <file_put>
    panic (status != DNA_OK);
    7134:	e3500000 	cmp	r0, #0
    7138:	0affffd5 	beq	7094 <vfs_set_info+0x30>
    713c:	eafffffe 	b	713c <vfs_set_info+0xd8>
    7140:	e1a00004 	mov	r0, r4
    7144:	eaffffd2 	b	7094 <vfs_set_info+0x30>
    7148:	0000fef8 	.word	0x0000fef8

0000714c <volume_host_inspector>:
 * SOURCE
 */

{
  volume_t volume = item;
  volume_t host = va_arg (list, volume_t);
    714c:	e491c00b 	ldr	ip, [r1], #11
  int64_t vnid = va_arg (list, int64_t); 

  watch (bool)
  {
    ensure (volume != NULL, false);
    7150:	e3500000 	cmp	r0, #0
 */

{
  volume_t volume = item;
  volume_t host = va_arg (list, volume_t);
  int64_t vnid = va_arg (list, int64_t); 
    7154:	e3c11007 	bic	r1, r1, #7
    7158:	e1c120d0 	ldrd	r2, [r1]

  watch (bool)
  {
    ensure (volume != NULL, false);
    715c:	012fff1e 	bxeq	lr
    return volume -> host_volume == host && volume -> host_vnid == vnid;
    7160:	e5901014 	ldr	r1, [r0, #20]
    7164:	e151000c 	cmp	r1, ip
    7168:	0a000001 	beq	7174 <volume_host_inspector+0x28>
    716c:	e3a00000 	mov	r0, #0
  }
}
    7170:	e12fff1e 	bx	lr
  int64_t vnid = va_arg (list, int64_t); 

  watch (bool)
  {
    ensure (volume != NULL, false);
    return volume -> host_volume == host && volume -> host_vnid == vnid;
    7174:	e1c001d8 	ldrd	r0, [r0, #24]
    7178:	e1530001 	cmp	r3, r1
    717c:	01520000 	cmpeq	r2, r0
    7180:	03a00001 	moveq	r0, #1
    7184:	13a00000 	movne	r0, #0
    7188:	e12fff1e 	bx	lr

0000718c <file_destroy>:
 * * DNA_OK if the operation succeed
 *
 * SOURCE
 */

{
    718c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    7190:	e24dd058 	sub	sp, sp, #88	; 0x58
    7194:	e1a04000 	mov	r4, r0
  interrupt_status_t it_status = 0;
  vnode_t vnode = NULL;

  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    7198:	e28d1004 	add	r1, sp, #4
    719c:	e3a00000 	mov	r0, #0
    71a0:	eb001796 	bl	d000 <thread_find>
    ensure (status == DNA_OK, status);
    71a4:	e3500000 	cmp	r0, #0
    71a8:	0a000001 	beq	71b4 <file_destroy+0x28>
  {
    lock_release (& file_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    71ac:	e28dd058 	add	sp, sp, #88	; 0x58
    71b0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    ensure (status == DNA_OK, status);

    status = thread_get_info (tid, & info);
    71b4:	e59d0004 	ldr	r0, [sp, #4]
    71b8:	e28d1008 	add	r1, sp, #8
    71bc:	eb001338 	bl	bea4 <thread_get_info>
    ensure (status == DNA_OK, status);
    71c0:	e3500000 	cmp	r0, #0
    71c4:	1afffff8 	bne	71ac <file_destroy+0x20>

    ensure (info . group >= 0, DNA_BAD_ARGUMENT);
    ensure (info . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    71c8:	e59d502c 	ldr	r5, [sp, #44]	; 0x2c
    71cc:	e3550000 	cmp	r5, #0
    71d0:	159f00d4 	ldrne	r0, [pc, #212]	; 72ac <file_destroy+0x120>
    71d4:	1afffff4 	bne	71ac <file_destroy+0x20>

    /*
     * Look for the file in the pool.
     */

    it_status = cpu_trap_mask_and_backup();
    71d8:	eb000a48 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& file_pool . lock);
    71dc:	e59f70cc 	ldr	r7, [pc, #204]	; 72b0 <file_destroy+0x124>

    /*
     * Look for the file in the pool.
     */

    it_status = cpu_trap_mask_and_backup();
    71e0:	e1a08000 	mov	r8, r0
    lock_acquire (& file_pool . lock);
    71e4:	e1a00007 	mov	r0, r7
    71e8:	eb000b90 	bl	a030 <lock_acquire>

    file = file_pool . file[info . group][fd];
    71ec:	e5973004 	ldr	r3, [r7, #4]
    71f0:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    71f4:	e7933102 	ldr	r3, [r3, r2, lsl #2]
    71f8:	e7936104 	ldr	r6, [r3, r4, lsl #2]
    check (error, file != NULL, DNA_INVALID_FD);
    71fc:	e3560000 	cmp	r6, #0
    7200:	0a000027 	beq	72a4 <file_destroy+0x118>
    check (error, file -> usage_counter > 0, DNA_ERROR);
    7204:	e5963004 	ldr	r3, [r6, #4]
    7208:	e3530000 	cmp	r3, #0
    720c:	da000015 	ble	7268 <file_destroy+0xdc>

    atomic_add (& file -> usage_counter, -1);
    7210:	e2860004 	add	r0, r6, #4
    7214:	e3e01000 	mvn	r1, #0
    7218:	eb0008ee 	bl	95d8 <atomic_add>
 
    if (file -> usage_counter == 0)
    721c:	e5963004 	ldr	r3, [r6, #4]
    7220:	e3530000 	cmp	r3, #0
    7224:	1a000016 	bne	7284 <file_destroy+0xf8>
    {
      file_pool . file[info . group][fd] = NULL;
    7228:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
    722c:	e5972004 	ldr	r2, [r7, #4]

      lock_release (& file_pool . lock);
    7230:	e1a00007 	mov	r0, r7

    atomic_add (& file -> usage_counter, -1);
 
    if (file -> usage_counter == 0)
    {
      file_pool . file[info . group][fd] = NULL;
    7234:	e7922101 	ldr	r2, [r2, r1, lsl #2]
    7238:	e7823104 	str	r3, [r2, r4, lsl #2]

      lock_release (& file_pool . lock);
    723c:	eb00162c 	bl	caf4 <lock_release>
      cpu_trap_restore(it_status);
    7240:	e1a00008 	mov	r0, r8
    7244:	eb000a66 	bl	9be4 <cpu_trap_restore>

      vnode = file -> vnode;
    7248:	e5964008 	ldr	r4, [r6, #8]
      kernel_free (file);
    724c:	e1a00006 	mov	r0, r6
    7250:	eb00195c 	bl	d7c8 <kernel_free>

      status = vnode_put (vnode -> volume -> id, vnode -> id);
    7254:	e1c420d8 	ldrd	r2, [r4, #8]
    7258:	e5941010 	ldr	r1, [r4, #16]
    725c:	e5910004 	ldr	r0, [r1, #4]
    7260:	ebfffe0f 	bl	6aa4 <vnode_put>
    7264:	eaffffd0 	b	71ac <file_destroy+0x20>
    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& file_pool . lock);

    file = file_pool . file[info . group][fd];
    check (error, file != NULL, DNA_INVALID_FD);
    check (error, file -> usage_counter > 0, DNA_ERROR);
    7268:	e59f4044 	ldr	r4, [pc, #68]	; 72b4 <file_destroy+0x128>
    return DNA_OK;
  }

  rescue (error)
  {
    lock_release (& file_pool . lock);
    726c:	e59f003c 	ldr	r0, [pc, #60]	; 72b0 <file_destroy+0x124>
    7270:	eb00161f 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    7274:	e1a00008 	mov	r0, r8
    7278:	eb000a59 	bl	9be4 <cpu_trap_restore>
    leave;
    727c:	e1a00004 	mov	r0, r4
    7280:	eaffffc9 	b	71ac <file_destroy+0x20>
      status = vnode_put (vnode -> volume -> id, vnode -> id);
      ensure (status == DNA_OK, status);
    }
    else
    {
      file -> destroy = true;
    7284:	e3a03001 	mov	r3, #1

      lock_release (& file_pool . lock);
    7288:	e1a00007 	mov	r0, r7
      status = vnode_put (vnode -> volume -> id, vnode -> id);
      ensure (status == DNA_OK, status);
    }
    else
    {
      file -> destroy = true;
    728c:	e5c6300c 	strb	r3, [r6, #12]

      lock_release (& file_pool . lock);
    7290:	eb001617 	bl	caf4 <lock_release>
      cpu_trap_restore(it_status);
    7294:	e1a00008 	mov	r0, r8
    7298:	eb000a51 	bl	9be4 <cpu_trap_restore>
    }

    dna_log(VERBOSE_LEVEL, "Destroyed FD %d.", fd);
    return DNA_OK;
    729c:	e1a00005 	mov	r0, r5
    72a0:	eaffffc1 	b	71ac <file_destroy+0x20>

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& file_pool . lock);

    file = file_pool . file[info . group][fd];
    check (error, file != NULL, DNA_INVALID_FD);
    72a4:	e59f400c 	ldr	r4, [pc, #12]	; 72b8 <file_destroy+0x12c>
    72a8:	eaffffef 	b	726c <file_destroy+0xe0>
    72ac:	0000fffc 	.word	0x0000fffc
    72b0:	000355dc 	.word	0x000355dc
    72b4:	0000ffff 	.word	0x0000ffff
    72b8:	0000fef8 	.word	0x0000fef8

000072bc <file_get_size>:
#include <Private/VirtualFileSystem.h>
#include <Core/Core.h>
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>

status_t file_get_size(file_t file, int32_t *ret, ...){
    72bc:	e92d000e 	push	{r1, r2, r3}
    72c0:	e92d4010 	push	{r4, lr}
	 
	 status_t stat;
	 va_list va_arg;
	 va_start (va_arg, ret);
	 stat = file -> vnode -> volume -> cmd -> ioctl
    72c4:	e5901008 	ldr	r1, [r0, #8]
#include <Private/VirtualFileSystem.h>
#include <Core/Core.h>
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>

status_t file_get_size(file_t file, int32_t *ret, ...){
    72c8:	e24dd014 	sub	sp, sp, #20
	 
	 status_t stat;
	 va_list va_arg;
	 va_start (va_arg, ret);
	 stat = file -> vnode -> volume -> cmd -> ioctl
    72cc:	e5913010 	ldr	r3, [r1, #16]
#include <Private/VirtualFileSystem.h>
#include <Core/Core.h>
#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>

status_t file_get_size(file_t file, int32_t *ret, ...){
    72d0:	e59d401c 	ldr	r4, [sp, #28]
	 
	 status_t stat;
	 va_list va_arg;
	 va_start (va_arg, ret);
	 stat = file -> vnode -> volume -> cmd -> ioctl
    72d4:	e593e020 	ldr	lr, [r3, #32]

status_t file_get_size(file_t file, int32_t *ret, ...){
	 
	 status_t stat;
	 va_list va_arg;
	 va_start (va_arg, ret);
    72d8:	e28dc020 	add	ip, sp, #32
	 stat = file -> vnode -> volume -> cmd -> ioctl
    72dc:	e5902020 	ldr	r2, [r0, #32]
    72e0:	e591101c 	ldr	r1, [r1, #28]
    72e4:	e5930024 	ldr	r0, [r3, #36]	; 0x24
    72e8:	e58d4004 	str	r4, [sp, #4]
    72ec:	e58dc000 	str	ip, [sp]
    72f0:	e59e403c 	ldr	r4, [lr, #60]	; 0x3c
    72f4:	e3a03000 	mov	r3, #0

status_t file_get_size(file_t file, int32_t *ret, ...){
	 
	 status_t stat;
	 va_list va_arg;
	 va_start (va_arg, ret);
    72f8:	e58dc00c 	str	ip, [sp, #12]
	 stat = file -> vnode -> volume -> cmd -> ioctl
    72fc:	e12fff34 	blx	r4
		  (file -> vnode -> volume -> data, file -> vnode -> data, file -> data,
		   DNA_GET_DEVICE_SIZE, va_arg, ret);
	 va_end (va_arg);
	 return stat;
} 
    7300:	e28dd014 	add	sp, sp, #20
    7304:	e8bd4010 	pop	{r4, lr}
    7308:	e28dd00c 	add	sp, sp, #12
    730c:	e12fff1e 	bx	lr

00007310 <vfs_lseek>:
 *
 * SOURCE
 */

{
  file_t file = NULL;
    7310:	e3a01000 	mov	r1, #0
 * * DN_OK : the operation succeeded
 *
 * SOURCE
 */

{
    7314:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  int64_t size;
  int32_t ret;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    7318:	e6ffc070 	uxth	ip, r0
 * * DN_OK : the operation succeeded
 *
 * SOURCE
 */

{
    731c:	e24dd010 	sub	sp, sp, #16
  int64_t size;
  int32_t ret;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    7320:	e35c00ff 	cmp	ip, #255	; 0xff
 * * DN_OK : the operation succeeded
 *
 * SOURCE
 */

{
    7324:	e1a06000 	mov	r6, r0
  file_t file = NULL;
    7328:	e58d1000 	str	r1, [sp]
  int64_t size;
  int32_t ret;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    732c:	859f00f8 	ldrhi	r0, [pc, #248]	; 742c <vfs_lseek+0x11c>
    7330:	9a000001 	bls	733c <vfs_lseek+0x2c>
    panic (status != DNA_OK);

    *p_ret = -1;
    leave;
  }
}
    7334:	e28dd010 	add	sp, sp, #16
    7338:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  int32_t ret;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    ensure (whence == DNA_SEEK_SET || whence == DNA_SEEK_FROM_CURRENT ||
    733c:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
    7340:	e3510002 	cmp	r1, #2
    7344:	859f00e4 	ldrhi	r0, [pc, #228]	; 7430 <vfs_lseek+0x120>
    7348:	8afffff9 	bhi	7334 <vfs_lseek+0x24>

    /*
     * Get the file associated to the fd.
     */

    status = file_get (fd, & file);
    734c:	e1a0100d 	mov	r1, sp
    7350:	e1a04002 	mov	r4, r2
    7354:	e1a05003 	mov	r5, r3
    7358:	eb000035 	bl	7434 <file_get>
    ensure (status == DNA_OK, status);
    735c:	e3500000 	cmp	r0, #0
    7360:	1afffff3 	bne	7334 <vfs_lseek+0x24>

    /*
     * Check the seek whence operator.
     */

    it_status = cpu_trap_mask_and_backup();
    7364:	eb0009e5 	bl	9b00 <cpu_trap_mask_and_backup>
    7368:	e1a07000 	mov	r7, r0
    lock_acquire (& file -> lock);
    736c:	e59d0000 	ldr	r0, [sp]
    7370:	eb000b2e 	bl	a030 <lock_acquire>

    switch (whence)
    7374:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
      case DNA_SEEK_SET :
        file -> offset = offset;
        break;

      case DNA_SEEK_FROM_CURRENT :
        file -> offset += offset;
    7378:	e59d0000 	ldr	r0, [sp]
     */

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& file -> lock);

    switch (whence)
    737c:	e3530001 	cmp	r3, #1
    7380:	0a000024 	beq	7418 <vfs_lseek+0x108>
    7384:	e3530002 	cmp	r3, #2
    7388:	1a000015 	bne	73e4 <vfs_lseek+0xd4>
        file -> offset += offset;
        break;

      case DNA_SEEK_FROM_END :

		status = file_get_size(file, &ret, &size);
    738c:	e28d1004 	add	r1, sp, #4
    7390:	e28d2008 	add	r2, sp, #8
    7394:	ebffffc8 	bl	72bc <file_get_size>
		/* FIXME: va_list cast may be a problem ... */

        check (error, status == DNA_OK, status);
    7398:	e2508000 	subs	r8, r0, #0
    739c:	1a000012 	bne	73ec <vfs_lseek+0xdc>

        file -> offset = size + offset;
    73a0:	e1cd20d8 	ldrd	r2, [sp, #8]
    73a4:	e59d0000 	ldr	r0, [sp]
    73a8:	e0922004 	adds	r2, r2, r4
    73ac:	e0a33005 	adc	r3, r3, r5
    73b0:	e1c021f8 	strd	r2, [r0, #24]

    /*
     * Update the offset, release the file, and return.$
     */

    lock_release (& file -> lock);
    73b4:	eb0015ce 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    73b8:	e1a00007 	mov	r0, r7
    73bc:	eb000a08 	bl	9be4 <cpu_trap_restore>
    
    *p_ret = file -> offset;
    73c0:	e59d3000 	ldr	r3, [sp]
    73c4:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
    73c8:	e1c321d8 	ldrd	r2, [r3, #24]

    status = file_put (fd);
    73cc:	e1a00006 	mov	r0, r6
     */

    lock_release (& file -> lock);
    cpu_trap_restore(it_status);
    
    *p_ret = file -> offset;
    73d0:	e1c120f0 	strd	r2, [r1]

    status = file_put (fd);
    73d4:	eb0001e1 	bl	7b60 <file_put>
    panic (status != DNA_OK);
    73d8:	e3500000 	cmp	r0, #0
    73dc:	0affffd4 	beq	7334 <vfs_lseek+0x24>
    73e0:	eafffffe 	b	73e0 <vfs_lseek+0xd0>
    lock_acquire (& file -> lock);

    switch (whence)
    {
      case DNA_SEEK_SET :
        file -> offset = offset;
    73e4:	e1c041f8 	strd	r4, [r0, #24]
        break;
    73e8:	eafffff1 	b	73b4 <vfs_lseek+0xa4>
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    73ec:	e1a00006 	mov	r0, r6
    73f0:	eb0001da 	bl	7b60 <file_put>
    panic (status != DNA_OK);
    73f4:	e3500000 	cmp	r0, #0
    73f8:	0a000000 	beq	7400 <vfs_lseek+0xf0>
    73fc:	eafffffe 	b	73fc <vfs_lseek+0xec>

    *p_ret = -1;
    7400:	e3e02000 	mvn	r2, #0
    7404:	e3e03000 	mvn	r3, #0
    7408:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
    leave;
    740c:	e1a00008 	mov	r0, r8
  rescue (error)
  {
    status = file_put (fd);
    panic (status != DNA_OK);

    *p_ret = -1;
    7410:	e1c120f0 	strd	r2, [r1]
    leave;
    7414:	eaffffc6 	b	7334 <vfs_lseek+0x24>
      case DNA_SEEK_SET :
        file -> offset = offset;
        break;

      case DNA_SEEK_FROM_CURRENT :
        file -> offset += offset;
    7418:	e1c021d8 	ldrd	r2, [r0, #24]
    741c:	e0922004 	adds	r2, r2, r4
    7420:	e0a33005 	adc	r3, r3, r5
    7424:	e1c021f8 	strd	r2, [r0, #24]
        break;
    7428:	eaffffe1 	b	73b4 <vfs_lseek+0xa4>
    742c:	0000fef8 	.word	0x0000fef8
    7430:	0000fef6 	.word	0x0000fef6

00007434 <file_get>:
 * * DNA_OK if the operation succeed
 *
 * SOURCE
 */

{
    7434:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    7438:	e24dd058 	sub	sp, sp, #88	; 0x58
    743c:	e1a05000 	mov	r5, r0
    7440:	e1a04001 	mov	r4, r1
  file_t file = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    7444:	e3a00000 	mov	r0, #0
    7448:	e28d1004 	add	r1, sp, #4
    744c:	eb0016eb 	bl	d000 <thread_find>
    ensure (status == DNA_OK, status);
    7450:	e3500000 	cmp	r0, #0
    7454:	0a000001 	beq	7460 <file_get+0x2c>
  {
    lock_release (& file_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    7458:	e28dd058 	add	sp, sp, #88	; 0x58
    745c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    ensure (status == DNA_OK, status);

    status = thread_get_info (tid, & info);
    7460:	e59d0004 	ldr	r0, [sp, #4]
    7464:	e28d1008 	add	r1, sp, #8
    7468:	eb00128d 	bl	bea4 <thread_get_info>
    ensure (status == DNA_OK, status);
    746c:	e3500000 	cmp	r0, #0
    7470:	1afffff8 	bne	7458 <file_get+0x24>

    ensure (info . group >= 0, DNA_BAD_ARGUMENT);
    ensure (info . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    7474:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
    7478:	e3530000 	cmp	r3, #0
    747c:	0a000002 	beq	748c <file_get+0x58>
    7480:	e59f0084 	ldr	r0, [pc, #132]	; 750c <file_get+0xd8>
  {
    lock_release (& file_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    7484:	e28dd058 	add	sp, sp, #88	; 0x58
    7488:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    status = thread_get_info (tid, & info);
    ensure (status == DNA_OK, status);

    ensure (info . group >= 0, DNA_BAD_ARGUMENT);
    ensure (info . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    ensure (p_file != NULL, DNA_BAD_ARGUMENT);
    748c:	e3540000 	cmp	r4, #0
    7490:	0afffffa 	beq	7480 <file_get+0x4c>

    /*
     * Look for the file in the pool.
     */

    it_status = cpu_trap_mask_and_backup();
    7494:	eb000999 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& file_pool . lock);
    7498:	e59f6070 	ldr	r6, [pc, #112]	; 7510 <file_get+0xdc>

    /*
     * Look for the file in the pool.
     */

    it_status = cpu_trap_mask_and_backup();
    749c:	e1a07000 	mov	r7, r0
    lock_acquire (& file_pool . lock);
    74a0:	e1a00006 	mov	r0, r6
    74a4:	eb000ae1 	bl	a030 <lock_acquire>

    file = file_pool . file[info . group][fd];
    74a8:	e5963004 	ldr	r3, [r6, #4]
    74ac:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    74b0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
    74b4:	e7935105 	ldr	r5, [r3, r5, lsl #2]
    check (error, file != NULL && ! file -> destroy, DNA_INVALID_FD);
    74b8:	e3550000 	cmp	r5, #0
    74bc:	0a000002 	beq	74cc <file_get+0x98>
    74c0:	e5d5800c 	ldrb	r8, [r5, #12]
    74c4:	e3580000 	cmp	r8, #0
    74c8:	0a000005 	beq	74e4 <file_get+0xb0>
    return DNA_OK;
  }

  rescue (error)
  {
    lock_release (& file_pool . lock);
    74cc:	e59f003c 	ldr	r0, [pc, #60]	; 7510 <file_get+0xdc>
    74d0:	eb001587 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    74d4:	e1a00007 	mov	r0, r7
    74d8:	eb0009c1 	bl	9be4 <cpu_trap_restore>
    leave;
    74dc:	e59f0030 	ldr	r0, [pc, #48]	; 7514 <file_get+0xe0>
    74e0:	eaffffdc 	b	7458 <file_get+0x24>
    lock_acquire (& file_pool . lock);

    file = file_pool . file[info . group][fd];
    check (error, file != NULL && ! file -> destroy, DNA_INVALID_FD);

    atomic_add (& file -> usage_counter, 1);
    74e4:	e3a01001 	mov	r1, #1
    74e8:	e2850004 	add	r0, r5, #4
    74ec:	eb000839 	bl	95d8 <atomic_add>

    lock_release (& file_pool . lock);
    74f0:	e1a00006 	mov	r0, r6
    74f4:	eb00157e 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    74f8:	e1a00007 	mov	r0, r7
    74fc:	eb0009b8 	bl	9be4 <cpu_trap_restore>

    dna_log(VERBOSE_LEVEL, "Got FD %d.", fd);

    *p_file = file;
    7500:	e5845000 	str	r5, [r4]
    return DNA_OK;
    7504:	e1a00008 	mov	r0, r8
    7508:	eaffffd2 	b	7458 <file_get+0x24>
    750c:	0000fffc 	.word	0x0000fffc
    7510:	000355dc 	.word	0x000355dc
    7514:	0000fef8 	.word	0x0000fef8

00007518 <vfs_ioctl>:
 *
 * SOURCE
 */

{
  file_t file = NULL;
    7518:	e3a0c000 	mov	ip, #0
 * Implementation-dependent.
 *
 * SOURCE
 */

{
    751c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    7520:	e6ffe070 	uxth	lr, r0
 * Implementation-dependent.
 *
 * SOURCE
 */

{
    7524:	e24dd014 	sub	sp, sp, #20
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    7528:	e35e00ff 	cmp	lr, #255	; 0xff
 * Implementation-dependent.
 *
 * SOURCE
 */

{
    752c:	e1a04000 	mov	r4, r0
  file_t file = NULL;
    7530:	e58dc00c 	str	ip, [sp, #12]
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    7534:	859f0090 	ldrhi	r0, [pc, #144]	; 75cc <vfs_ioctl+0xb4>
    7538:	9a000001 	bls	7544 <vfs_ioctl+0x2c>

    *p_ret = -1;
    leave;
  }

}
    753c:	e28dd014 	add	sp, sp, #20
    7540:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    7544:	e1a06001 	mov	r6, r1

    /*
     * Get the file associated to the fd.
     */

    status = file_get (fd, & file);
    7548:	e28d100c 	add	r1, sp, #12
    754c:	e1a07002 	mov	r7, r2
    7550:	e1a05003 	mov	r5, r3
    7554:	ebffffb6 	bl	7434 <file_get>
    ensure (status == DNA_OK, status);
    7558:	e3500000 	cmp	r0, #0
    755c:	1afffff6 	bne	753c <vfs_ioctl+0x24>

    /*
     * Call ioctl on the file.
     */

    status = file -> vnode -> volume -> cmd -> ioctl
    7560:	e59d200c 	ldr	r2, [sp, #12]
    7564:	e1a03006 	mov	r3, r6
    7568:	e5921008 	ldr	r1, [r2, #8]
    756c:	e5922020 	ldr	r2, [r2, #32]
    7570:	e5910010 	ldr	r0, [r1, #16]
    7574:	e591101c 	ldr	r1, [r1, #28]
    7578:	e590c020 	ldr	ip, [r0, #32]
    757c:	e5900024 	ldr	r0, [r0, #36]	; 0x24
    7580:	e58d7000 	str	r7, [sp]
    7584:	e58d5004 	str	r5, [sp, #4]
    7588:	e59cc03c 	ldr	ip, [ip, #60]	; 0x3c
    758c:	e12fff3c 	blx	ip
      (file -> vnode -> volume -> data, file -> vnode -> data, file -> data,
       function, arguments, p_ret);

    check (error, status == DNA_OK, status);
    7590:	e2506000 	subs	r6, r0, #0
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    7594:	e1a00004 	mov	r0, r4

    status = file -> vnode -> volume -> cmd -> ioctl
      (file -> vnode -> volume -> data, file -> vnode -> data, file -> data,
       function, arguments, p_ret);

    check (error, status == DNA_OK, status);
    7598:	0a000003 	beq	75ac <vfs_ioctl+0x94>
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    759c:	eb00016f 	bl	7b60 <file_put>
    panic (status != DNA_OK);
    75a0:	e3500000 	cmp	r0, #0
    75a4:	0a000004 	beq	75bc <vfs_ioctl+0xa4>
    75a8:	eafffffe 	b	75a8 <vfs_ioctl+0x90>

    /*
     * Release the file and return.
     */

    status = file_put (fd);
    75ac:	eb00016b 	bl	7b60 <file_put>
    panic (status != DNA_OK);
    75b0:	e3500000 	cmp	r0, #0
    75b4:	0affffe0 	beq	753c <vfs_ioctl+0x24>
    75b8:	eafffffe 	b	75b8 <vfs_ioctl+0xa0>
  rescue (error)
  {
    status = file_put (fd);
    panic (status != DNA_OK);

    *p_ret = -1;
    75bc:	e3e03000 	mvn	r3, #0
    leave;
    75c0:	e1a00006 	mov	r0, r6
  rescue (error)
  {
    status = file_put (fd);
    panic (status != DNA_OK);

    *p_ret = -1;
    75c4:	e5853000 	str	r3, [r5]
    leave;
    75c8:	eaffffdb 	b	753c <vfs_ioctl+0x24>
    75cc:	0000fef8 	.word	0x0000fef8

000075d0 <vfs_destroy>:
 */

{

  return DNA_NOT_IMPLEMENTED;
}
    75d0:	e59f0000 	ldr	r0, [pc]	; 75d8 <vfs_destroy+0x8>
    75d4:	e12fff1e 	bx	lr
    75d8:	0000fffe 	.word	0x0000fffe

000075dc <vfs_get_info>:
 *
 * SOURCE
 */

{
  file_t file = NULL;
    75dc:	e3a02000 	mov	r2, #0
 * Fill-in the file_info_t structure.
 *
 * SOURCE
 */

{
    75e0:	e92d4030 	push	{r4, r5, lr}
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    75e4:	e6ff3070 	uxth	r3, r0
 * Fill-in the file_info_t structure.
 *
 * SOURCE
 */

{
    75e8:	e24dd00c 	sub	sp, sp, #12
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    75ec:	e35300ff 	cmp	r3, #255	; 0xff
 * Fill-in the file_info_t structure.
 *
 * SOURCE
 */

{
    75f0:	e1a04000 	mov	r4, r0
  file_t file = NULL;
    75f4:	e58d2004 	str	r2, [sp, #4]
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    75f8:	859f0078 	ldrhi	r0, [pc, #120]	; 7678 <vfs_get_info+0x9c>
    75fc:	9a000001 	bls	7608 <vfs_get_info+0x2c>
    status = file_put (fd);
    panic (status != DNA_OK);
    leave;
  }

}
    7600:	e28dd00c 	add	sp, sp, #12
    7604:	e8bd8030 	pop	{r4, r5, pc}
    7608:	e1a05001 	mov	r5, r1

    /*
     * Get the file associated to the fd.
     */

    status = file_get (fd, & file);
    760c:	e28d1004 	add	r1, sp, #4
    7610:	ebffff87 	bl	7434 <file_get>
    ensure (status == DNA_OK, status);
    7614:	e3500000 	cmp	r0, #0
    7618:	1afffff8 	bne	7600 <vfs_get_info+0x24>

    /*
     * Call ioctl on the file.
     */

    status = file -> vnode -> volume -> cmd -> get_info
    761c:	e59d2004 	ldr	r2, [sp, #4]
    7620:	e1a03005 	mov	r3, r5
    7624:	e5921008 	ldr	r1, [r2, #8]
    7628:	e5922020 	ldr	r2, [r2, #32]
    762c:	e5910010 	ldr	r0, [r1, #16]
    7630:	e591101c 	ldr	r1, [r1, #28]
    7634:	e590c020 	ldr	ip, [r0, #32]
    7638:	e5900024 	ldr	r0, [r0, #36]	; 0x24
    763c:	e59cc02c 	ldr	ip, [ip, #44]	; 0x2c
    7640:	e12fff3c 	blx	ip
      (file -> vnode -> volume -> data, file -> vnode -> data,
       file -> data, p_info);

    check (error, status == DNA_OK, status);
    7644:	e2505000 	subs	r5, r0, #0
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    7648:	e1a00004 	mov	r0, r4

    status = file -> vnode -> volume -> cmd -> get_info
      (file -> vnode -> volume -> data, file -> vnode -> data,
       file -> data, p_info);

    check (error, status == DNA_OK, status);
    764c:	0a000003 	beq	7660 <vfs_get_info+0x84>
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    7650:	eb000142 	bl	7b60 <file_put>
    panic (status != DNA_OK);
    7654:	e3500000 	cmp	r0, #0
    7658:	0a000004 	beq	7670 <vfs_get_info+0x94>
    765c:	eafffffe 	b	765c <vfs_get_info+0x80>

    /*
     * Release the file and return.
     */

    status = file_put (fd);
    7660:	eb00013e 	bl	7b60 <file_put>
    panic (status != DNA_OK);
    7664:	e3500000 	cmp	r0, #0
    7668:	0affffe4 	beq	7600 <vfs_get_info+0x24>
    766c:	eafffffe 	b	766c <vfs_get_info+0x90>
    7670:	e1a00005 	mov	r0, r5
    7674:	eaffffe1 	b	7600 <vfs_get_info+0x24>
    7678:	0000fef8 	.word	0x0000fef8

0000767c <vnode_id_inspector>:
 * SOURCE
 */

{
  vnode_t vnode = node;
  int64_t vnid = va_arg (list, int64_t);
    767c:	e2811007 	add	r1, r1, #7
    7680:	e3c11007 	bic	r1, r1, #7
  int32_t vid = va_arg (list, int32_t);

  watch (bool)
  {
    ensure (vnode != NULL, false);
    7684:	e3500000 	cmp	r0, #0
 * SOURCE
 */

{
  vnode_t vnode = node;
  int64_t vnid = va_arg (list, int64_t);
    7688:	e1c120d0 	ldrd	r2, [r1]
  int32_t vid = va_arg (list, int32_t);
    768c:	e5911008 	ldr	r1, [r1, #8]

  watch (bool)
  {
    ensure (vnode != NULL, false);
    7690:	012fff1e 	bxeq	lr
 * Return TRUE if the strings match, FALSE otherwise.
 *
 * SOURCE
 */

{
    7694:	e92d0030 	push	{r4, r5}
  int32_t vid = va_arg (list, int32_t);

  watch (bool)
  {
    ensure (vnode != NULL, false);
    return vnode -> id == vnid && vnode -> volume -> id == vid;
    7698:	e1c040d8 	ldrd	r4, [r0, #8]
    769c:	e1550003 	cmp	r5, r3
    76a0:	01540002 	cmpeq	r4, r2
    76a4:	05903010 	ldreq	r3, [r0, #16]
    76a8:	13a00000 	movne	r0, #0
  }
}
    76ac:	e8bd0030 	pop	{r4, r5}
  int32_t vid = va_arg (list, int32_t);

  watch (bool)
  {
    ensure (vnode != NULL, false);
    return vnode -> id == vnid && vnode -> volume -> id == vid;
    76b0:	05930004 	ldreq	r0, [r3, #4]
    76b4:	00600001 	rsbeq	r0, r0, r1
    76b8:	016f0f10 	clzeq	r0, r0
    76bc:	01a002a0 	lsreq	r0, r0, #5
  }
}
    76c0:	e12fff1e 	bx	lr

000076c4 <vfs_open>:
 * * DNA_OK : the operation succeeded
 *
 * SOURCE
 */

{
    76c4:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
  int16_t fd = -1;
  file_t file = NULL;
    76c8:	e3a0c000 	mov	ip, #0
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (path != NULL && p_fd != NULL, DNA_ERROR);
    76cc:	e3530000 	cmp	r3, #0
    76d0:	13500000 	cmpne	r0, #0
 */

{
  int16_t fd = -1;
  file_t file = NULL;
  int64_t vnid = -1, file_vnid = -1;
    76d4:	e3e04000 	mvn	r4, #0
    76d8:	e3e05000 	mvn	r5, #0
 *
 * SOURCE
 */

{
  int16_t fd = -1;
    76dc:	e3e0a000 	mvn	sl, #0
 * * DNA_OK : the operation succeeded
 *
 * SOURCE
 */

{
    76e0:	e24dde53 	sub	sp, sp, #1328	; 0x530
    76e4:	e24dd008 	sub	sp, sp, #8
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (path != NULL && p_fd != NULL, DNA_ERROR);
    76e8:	e1a06003 	mov	r6, r3
 *
 * SOURCE
 */

{
  int16_t fd = -1;
    76ec:	e59fe1c4 	ldr	lr, [pc, #452]	; 78b8 <vfs_open+0x1f4>
  file_t file = NULL;
  int64_t vnid = -1, file_vnid = -1;
    76f0:	e59f31c4 	ldr	r3, [pc, #452]	; 78bc <vfs_open+0x1f8>
    76f4:	e59f71c4 	ldr	r7, [pc, #452]	; 78c0 <vfs_open+0x1fc>
 * * DNA_OK : the operation succeeded
 *
 * SOURCE
 */

{
    76f8:	e1a08001 	mov	r8, r1
  int16_t fd = -1;
    76fc:	e28d1e53 	add	r1, sp, #1328	; 0x530
    7700:	e2811008 	add	r1, r1, #8
    7704:	e181a0be 	strh	sl, [r1, lr]
  file_t file = NULL;
    7708:	e58dc018 	str	ip, [sp, #24]
  int64_t vnid = -1, file_vnid = -1;
  vnode_t vnode = NULL;
  volume_t volume = NULL;
    770c:	e58dc01c 	str	ip, [sp, #28]
  void * data = NULL, * file_data = NULL;
    7710:	e58dc020 	str	ip, [sp, #32]
    7714:	e58dc024 	str	ip, [sp, #36]	; 0x24
 */

{
  int16_t fd = -1;
  file_t file = NULL;
  int64_t vnid = -1, file_vnid = -1;
    7718:	e18140f3 	strd	r4, [r1, r3]
    771c:	e18140f7 	strd	r4, [r1, r7]
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (path != NULL && p_fd != NULL, DNA_ERROR);
    7720:	059f019c 	ldreq	r0, [pc, #412]	; 78c4 <vfs_open+0x200>
    7724:	1a000002 	bne	7734 <vfs_open+0x70>
    ensure (status == DNA_OK, status);
 
    *p_fd = fd;
    return DNA_OK;
  }
}
    7728:	e28dde53 	add	sp, sp, #1328	; 0x530
    772c:	e28dd008 	add	sp, sp, #8
    7730:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (path != NULL && p_fd != NULL, DNA_ERROR);
    dna_strcpy (buffer, path);
    7734:	e1a01000 	mov	r1, r0
    7738:	e28d0f4e 	add	r0, sp, #312	; 0x138
    773c:	e1a09002 	mov	r9, r2
    7740:	eb0007e8 	bl	96e8 <dna_strcpy>

    if ((mode & DNA_CREATE) != 0)
    7744:	e3180c02 	tst	r8, #512	; 0x200
    7748:	0a000023 	beq	77dc <vfs_open+0x118>
    {
      /*
       * Spilt the path into base + token
       */

      status = path_split (buffer, token);
    774c:	e28d1038 	add	r1, sp, #56	; 0x38
    7750:	e28d0f4e 	add	r0, sp, #312	; 0x138
    7754:	eb0007b7 	bl	9638 <path_split>
      ensure (status == DNA_OK, status);
    7758:	e3500000 	cmp	r0, #0
    775c:	1afffff1 	bne	7728 <vfs_open+0x64>

      /*
       * Get the vnode corresponding to the base directory
       */

      status = vnode_walk (buffer, & volume, & vnid, & data);
    7760:	e28d2028 	add	r2, sp, #40	; 0x28
    7764:	e28d0f4e 	add	r0, sp, #312	; 0x138
    7768:	e28d101c 	add	r1, sp, #28
    776c:	e2423008 	sub	r3, r2, #8
    7770:	eb000368 	bl	8518 <vnode_walk>
      ensure (status == DNA_OK, status);
    7774:	e3500000 	cmp	r0, #0
    7778:	1affffea 	bne	7728 <vfs_open+0x64>

      /*
       * Ask to create the file.
       */

      status = volume -> cmd -> create (volume -> data, data, token,
    777c:	e59d301c 	ldr	r3, [sp, #28]
    7780:	e28dc024 	add	ip, sp, #36	; 0x24
    7784:	e5932020 	ldr	r2, [r3, #32]
    7788:	e5930024 	ldr	r0, [r3, #36]	; 0x24
    778c:	e28d3030 	add	r3, sp, #48	; 0x30
    7790:	e58d3004 	str	r3, [sp, #4]
    7794:	e58dc008 	str	ip, [sp, #8]
    7798:	e58d9000 	str	r9, [sp]
    779c:	e592c020 	ldr	ip, [r2, #32]
    77a0:	e59d1020 	ldr	r1, [sp, #32]
    77a4:	e28d2038 	add	r2, sp, #56	; 0x38
    77a8:	e1a03008 	mov	r3, r8
    77ac:	e12fff3c 	blx	ip
          mode, perms, & file_vnid, & file_data);
      ensure (status == DNA_OK, status);
    77b0:	e3500000 	cmp	r0, #0
    77b4:	1affffdb 	bne	7728 <vfs_open+0x64>

      /*
       * Release the parent file, it is not required anymore.
       */

      status = vnode_put (volume -> id, vnid);
    77b8:	e59d101c 	ldr	r1, [sp, #28]
    77bc:	e28dce53 	add	ip, sp, #1328	; 0x530
    77c0:	e28cc008 	add	ip, ip, #8
    77c4:	e18c20d7 	ldrd	r2, [ip, r7]
    77c8:	e5910004 	ldr	r0, [r1, #4]
    77cc:	ebfffcb4 	bl	6aa4 <vnode_put>
      panic (status != DNA_OK);
    77d0:	e3500000 	cmp	r0, #0
    77d4:	0a000011 	beq	7820 <vfs_open+0x15c>
    77d8:	eafffffe 	b	77d8 <vfs_open+0x114>
    {
      /*
       * Get the vnode corresponding to the base directory
       */

      status = vnode_walk (buffer, & volume, & vnid, & data);
    77dc:	e28d2028 	add	r2, sp, #40	; 0x28
    77e0:	e28d0f4e 	add	r0, sp, #312	; 0x138
    77e4:	e28d101c 	add	r1, sp, #28
    77e8:	e2423008 	sub	r3, r2, #8
    77ec:	eb000349 	bl	8518 <vnode_walk>
      ensure (status == DNA_OK, status);
    77f0:	e3500000 	cmp	r0, #0
    77f4:	1affffcb 	bne	7728 <vfs_open+0x64>

      /*
       * Ask to open the file
       */

      status = volume -> cmd -> open (volume -> data, data, mode, & file_data);
    77f8:	e59d201c 	ldr	r2, [sp, #28]
    77fc:	e28d3024 	add	r3, sp, #36	; 0x24
    7800:	e5921020 	ldr	r1, [r2, #32]
    7804:	e5920024 	ldr	r0, [r2, #36]	; 0x24
    7808:	e591c014 	ldr	ip, [r1, #20]
    780c:	e1a02008 	mov	r2, r8
    7810:	e59d1020 	ldr	r1, [sp, #32]
    7814:	e12fff3c 	blx	ip
      ensure (status == DNA_OK, status);
    7818:	e3500000 	cmp	r0, #0
    781c:	1affffc1 	bne	7728 <vfs_open+0x64>
  
    /*
     * Find the new vnode.
     */

    it_status = cpu_trap_mask_and_backup();
    7820:	eb0008b6 	bl	9b00 <cpu_trap_mask_and_backup>
    7824:	e1a05000 	mov	r5, r0
    lock_acquire (& vnode_manager . lock);
    7828:	e59f0098 	ldr	r0, [pc, #152]	; 78c8 <vfs_open+0x204>
    782c:	eb0009ff 	bl	a030 <lock_acquire>

    vnode = queue_lookup (& vnode_manager . vnode_list,
    7830:	e59d201c 	ldr	r2, [sp, #28]
    7834:	e59f3084 	ldr	r3, [pc, #132]	; 78c0 <vfs_open+0x1fc>
    7838:	e5921004 	ldr	r1, [r2, #4]
    783c:	e28d0e53 	add	r0, sp, #1328	; 0x530
    7840:	e2800008 	add	r0, r0, #8
    7844:	e18320d0 	ldrd	r2, [r3, r0]
    7848:	e58d1000 	str	r1, [sp]
    784c:	e59f0078 	ldr	r0, [pc, #120]	; 78cc <vfs_open+0x208>
    7850:	e59f1078 	ldr	r1, [pc, #120]	; 78d0 <vfs_open+0x20c>
    7854:	eb000741 	bl	9560 <queue_lookup>
    7858:	e1a04000 	mov	r4, r0
        vnode_id_inspector, vnid, volume -> id);

    lock_release (& vnode_manager . lock);
    785c:	e59f0064 	ldr	r0, [pc, #100]	; 78c8 <vfs_open+0x204>
    7860:	eb0014a3 	bl	caf4 <lock_release>
    cpu_trap_restore (it_status);
    7864:	e1a00005 	mov	r0, r5
    7868:	eb0008dd 	bl	9be4 <cpu_trap_restore>

    ensure (vnode != NULL, DNA_NO_VNODE);
    786c:	e3540000 	cmp	r4, #0
    7870:	0a00000e 	beq	78b0 <vfs_open+0x1ec>

    /*
     * Acquire a new file.
     */

    status = file_create (vnode, mode, file_data, & fd, & file); 
    7874:	e28d3018 	add	r3, sp, #24
    7878:	e58d3000 	str	r3, [sp]
    787c:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
    7880:	e1a00004 	mov	r0, r4
    7884:	e1a01008 	mov	r1, r8
    7888:	e28d3016 	add	r3, sp, #22
    788c:	ebfffd4d 	bl	6dc8 <file_create>
    ensure (status == DNA_OK, status);
    7890:	e3500000 	cmp	r0, #0
    7894:	1affffa3 	bne	7728 <vfs_open+0x64>
 
    *p_fd = fd;
    7898:	e59f3018 	ldr	r3, [pc, #24]	; 78b8 <vfs_open+0x1f4>
    789c:	e28d1e53 	add	r1, sp, #1328	; 0x530
    78a0:	e2811008 	add	r1, r1, #8
    78a4:	e19130b3 	ldrh	r3, [r1, r3]
    78a8:	e1c630b0 	strh	r3, [r6]
    return DNA_OK;
    78ac:	eaffff9d 	b	7728 <vfs_open+0x64>
        vnode_id_inspector, vnid, volume -> id);

    lock_release (& vnode_manager . lock);
    cpu_trap_restore (it_status);

    ensure (vnode != NULL, DNA_NO_VNODE);
    78b0:	e59f001c 	ldr	r0, [pc, #28]	; 78d4 <vfs_open+0x210>
    78b4:	eaffff9b 	b	7728 <vfs_open+0x64>
    78b8:	fffffade 	.word	0xfffffade
    78bc:	fffffaf8 	.word	0xfffffaf8
    78c0:	fffffaf0 	.word	0xfffffaf0
    78c4:	0000ffff 	.word	0x0000ffff
    78c8:	000355e4 	.word	0x000355e4
    78cc:	000355e8 	.word	0x000355e8
    78d0:	0000767c 	.word	0x0000767c
    78d4:	0000fefd 	.word	0x0000fefd

000078d8 <filesystem_load>:

/*
 * SOURCE
 */

{
    78d8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}

  watch (status_t)
  {
    dna_log(INFO_LEVEL, "Loading FS \"%s\"", name);

    for (int32_t i = 0; i < OS_N_FILESYSTEMS; i++)
    78dc:	e59f612c 	ldr	r6, [pc, #300]	; 7a10 <filesystem_load+0x138>
    78e0:	e5963000 	ldr	r3, [r6]
    78e4:	e3530000 	cmp	r3, #0
    78e8:	da000046 	ble	7a08 <filesystem_load+0x130>
    78ec:	e1a07000 	mov	r7, r0
    78f0:	e1a08001 	mov	r8, r1
    78f4:	e3a04000 	mov	r4, #0
    78f8:	e59f5114 	ldr	r5, [pc, #276]	; 7a14 <filesystem_load+0x13c>
    78fc:	ea000003 	b	7910 <filesystem_load+0x38>
    7900:	e5963000 	ldr	r3, [r6]
    7904:	e2844001 	add	r4, r4, #1
    7908:	e1530004 	cmp	r3, r4
    790c:	da00003d 	ble	7a08 <filesystem_load+0x130>
    {
      if (dna_strcmp (OS_FILESYSTEMS_LIST[i] -> name, name) == 0)
    7910:	e5b53004 	ldr	r3, [r5, #4]!
    7914:	e1a01007 	mov	r1, r7
    7918:	e5930000 	ldr	r0, [r3]
    791c:	eb000703 	bl	9530 <dna_strcmp>
    7920:	e3500000 	cmp	r0, #0
    7924:	1afffff5 	bne	7900 <filesystem_load+0x28>
      {
        new_fs = OS_FILESYSTEMS_LIST[i];
    7928:	e59f30e8 	ldr	r3, [pc, #232]	; 7a18 <filesystem_load+0x140>
    792c:	e7932104 	ldr	r2, [r3, r4, lsl #2]
        break;
      }
    }

    ensure (new_fs != NULL, DNA_ERROR);
    7930:	e3520000 	cmp	r2, #0
    7934:	0a000033 	beq	7a08 <filesystem_load+0x130>
     * Check the consistency of the filesystem.
     */

    for (int32_t i = 0; i < sizeof (filesystem_cmd_t) >> 2; i += 1)
    {
      ensure (((void **)new_fs -> cmd)[i] != NULL, DNA_ERROR);
    7938:	e5923004 	ldr	r3, [r2, #4]
    793c:	e5931000 	ldr	r1, [r3]
    7940:	e3510000 	cmp	r1, #0
    7944:	0a00002f 	beq	7a08 <filesystem_load+0x130>
    7948:	e5931004 	ldr	r1, [r3, #4]
    794c:	e3510000 	cmp	r1, #0
    7950:	0a00002c 	beq	7a08 <filesystem_load+0x130>
    7954:	e5931008 	ldr	r1, [r3, #8]
    7958:	e3510000 	cmp	r1, #0
    795c:	0a000029 	beq	7a08 <filesystem_load+0x130>
    7960:	e593100c 	ldr	r1, [r3, #12]
    7964:	e3510000 	cmp	r1, #0
    7968:	0a000026 	beq	7a08 <filesystem_load+0x130>
    796c:	e5931010 	ldr	r1, [r3, #16]
    7970:	e3510000 	cmp	r1, #0
    7974:	0a000023 	beq	7a08 <filesystem_load+0x130>
    7978:	e5931014 	ldr	r1, [r3, #20]
    797c:	e3510000 	cmp	r1, #0
    7980:	0a000020 	beq	7a08 <filesystem_load+0x130>
    7984:	e5931018 	ldr	r1, [r3, #24]
    7988:	e3510000 	cmp	r1, #0
    798c:	0a00001d 	beq	7a08 <filesystem_load+0x130>
    7990:	e593101c 	ldr	r1, [r3, #28]
    7994:	e3510000 	cmp	r1, #0
    7998:	0a00001a 	beq	7a08 <filesystem_load+0x130>
    799c:	e5931020 	ldr	r1, [r3, #32]
    79a0:	e3510000 	cmp	r1, #0
    79a4:	0a000017 	beq	7a08 <filesystem_load+0x130>
    79a8:	e5931024 	ldr	r1, [r3, #36]	; 0x24
    79ac:	e3510000 	cmp	r1, #0
    79b0:	0a000014 	beq	7a08 <filesystem_load+0x130>
    79b4:	e5931028 	ldr	r1, [r3, #40]	; 0x28
    79b8:	e3510000 	cmp	r1, #0
    79bc:	0a000011 	beq	7a08 <filesystem_load+0x130>
    79c0:	e593102c 	ldr	r1, [r3, #44]	; 0x2c
    79c4:	e3510000 	cmp	r1, #0
    79c8:	0a00000e 	beq	7a08 <filesystem_load+0x130>
    79cc:	e5931030 	ldr	r1, [r3, #48]	; 0x30
    79d0:	e3510000 	cmp	r1, #0
    79d4:	0a00000b 	beq	7a08 <filesystem_load+0x130>
    79d8:	e5931034 	ldr	r1, [r3, #52]	; 0x34
    79dc:	e3510000 	cmp	r1, #0
    79e0:	0a000008 	beq	7a08 <filesystem_load+0x130>
    79e4:	e5931038 	ldr	r1, [r3, #56]	; 0x38
    79e8:	e3510000 	cmp	r1, #0
    79ec:	0a000005 	beq	7a08 <filesystem_load+0x130>
    79f0:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
    79f4:	e3530000 	cmp	r3, #0
    79f8:	0a000002 	beq	7a08 <filesystem_load+0x130>
    }

    *fs = new_fs;
    79fc:	e5882000 	str	r2, [r8]
    return DNA_OK;
    7a00:	e3a00000 	mov	r0, #0
    7a04:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        new_fs = OS_FILESYSTEMS_LIST[i];
        break;
      }
    }

    ensure (new_fs != NULL, DNA_ERROR);
    7a08:	e59f000c 	ldr	r0, [pc, #12]	; 7a1c <filesystem_load+0x144>
    7a0c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    7a10:	000254dc 	.word	0x000254dc
    7a14:	000254dc 	.word	0x000254dc
    7a18:	000254e0 	.word	0x000254e0
    7a1c:	0000ffff 	.word	0x0000ffff

00007a20 <vfs_create>:
 * Initializes the VFS structures.
 *
 * SOURCE
 */

{
    7a20:	e92d4038 	push	{r3, r4, r5, lr}
  watch (status_t)
  {
    dna_memset (& vnode_manager, 0, sizeof (vnode_manager_t));
    7a24:	e3a01000 	mov	r1, #0
    7a28:	e3a02014 	mov	r2, #20

    /*
     * Initialize the file pool.
     */

    dna_memset (& file_pool, 0, sizeof (file_pool_t));
    7a2c:	e59f407c 	ldr	r4, [pc, #124]	; 7ab0 <vfs_create+0x90>
 */

{
  watch (status_t)
  {
    dna_memset (& vnode_manager, 0, sizeof (vnode_manager_t));
    7a30:	e59f007c 	ldr	r0, [pc, #124]	; 7ab4 <vfs_create+0x94>
    7a34:	eb00042a 	bl	8ae4 <dna_memset>
    dna_memset (& volume_manager, 0, sizeof (volume_manager_t));
    7a38:	e3a01000 	mov	r1, #0
    7a3c:	e3a02018 	mov	r2, #24
    7a40:	e59f0070 	ldr	r0, [pc, #112]	; 7ab8 <vfs_create+0x98>
    7a44:	eb000426 	bl	8ae4 <dna_memset>

    /*
     * Initialize the file pool.
     */

    dna_memset (& file_pool, 0, sizeof (file_pool_t));
    7a48:	e3a01000 	mov	r1, #0
    7a4c:	e3a02008 	mov	r2, #8
    7a50:	e1a00004 	mov	r0, r4
    7a54:	eb000422 	bl	8ae4 <dna_memset>

    file_pool . file = kernel_malloc (DNA_MAX_GROUP * sizeof (file_t *), true);
    7a58:	e3a00004 	mov	r0, #4
    7a5c:	e3a01001 	mov	r1, #1
    7a60:	eb001723 	bl	d6f4 <kernel_malloc>
    ensure (file_pool . file != NULL, DNA_OUT_OF_MEM);
    7a64:	e3500000 	cmp	r0, #0
     * Initialize the file pool.
     */

    dna_memset (& file_pool, 0, sizeof (file_pool_t));

    file_pool . file = kernel_malloc (DNA_MAX_GROUP * sizeof (file_t *), true);
    7a68:	e1a05000 	mov	r5, r0
    7a6c:	e5840004 	str	r0, [r4, #4]
    ensure (file_pool . file != NULL, DNA_OUT_OF_MEM);
    7a70:	0a000009 	beq	7a9c <vfs_create+0x7c>

    for (int32_t i = 0; i < DNA_MAX_GROUP; i += 1)
    {
      file_pool . file[i] = kernel_malloc
        (DNA_MAX_FILE * sizeof (file_t), true);
    7a74:	e3a00b01 	mov	r0, #1024	; 0x400
    7a78:	e3a01001 	mov	r1, #1
    7a7c:	eb00171c 	bl	d6f4 <kernel_malloc>
    file_pool . file = kernel_malloc (DNA_MAX_GROUP * sizeof (file_t *), true);
    ensure (file_pool . file != NULL, DNA_OUT_OF_MEM);

    for (int32_t i = 0; i < DNA_MAX_GROUP; i += 1)
    {
      file_pool . file[i] = kernel_malloc
    7a80:	e5850000 	str	r0, [r5]
        (DNA_MAX_FILE * sizeof (file_t), true);
      check (file_no_mem, file_pool . file[i] != NULL, DNA_OUT_OF_MEM);
    7a84:	e5940004 	ldr	r0, [r4, #4]
    7a88:	e5903000 	ldr	r3, [r0]
    7a8c:	e3530000 	cmp	r3, #0
    7a90:	0a000003 	beq	7aa4 <vfs_create+0x84>
    }

    return DNA_OK;
    7a94:	e3a00000 	mov	r0, #0
    }

    kernel_free (file_pool . file);
    leave;
  }
}
    7a98:	e8bd8038 	pop	{r3, r4, r5, pc}
     */

    dna_memset (& file_pool, 0, sizeof (file_pool_t));

    file_pool . file = kernel_malloc (DNA_MAX_GROUP * sizeof (file_t *), true);
    ensure (file_pool . file != NULL, DNA_OUT_OF_MEM);
    7a9c:	e59f0018 	ldr	r0, [pc, #24]	; 7abc <vfs_create+0x9c>
    7aa0:	e8bd8038 	pop	{r3, r4, r5, pc}
      {
        kernel_free (file_pool . file[i]);
      }
    }

    kernel_free (file_pool . file);
    7aa4:	eb001747 	bl	d7c8 <kernel_free>
    leave;
    7aa8:	e59f000c 	ldr	r0, [pc, #12]	; 7abc <vfs_create+0x9c>
    7aac:	e8bd8038 	pop	{r3, r4, r5, pc}
    7ab0:	000355dc 	.word	0x000355dc
    7ab4:	000355e4 	.word	0x000355e4
    7ab8:	000355f8 	.word	0x000355f8
    7abc:	0000fffd 	.word	0x0000fffd

00007ac0 <volume_create>:
 * DNA_OK if th operation succedded, DNA_ERROR otherwise.
 *
 * SOURCE
 */

{
    7ac0:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
  volume_t volume = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    volume = kernel_malloc (sizeof (struct _volume), true);
    7ac4:	e3a01001 	mov	r1, #1
 * DNA_OK if th operation succedded, DNA_ERROR otherwise.
 *
 * SOURCE
 */

{
    7ac8:	e1a07000 	mov	r7, r0
  volume_t volume = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    volume = kernel_malloc (sizeof (struct _volume), true);
    7acc:	e3a00028 	mov	r0, #40	; 0x28
 * DNA_OK if th operation succedded, DNA_ERROR otherwise.
 *
 * SOURCE
 */

{
    7ad0:	e1a04002 	mov	r4, r2
    7ad4:	e1a05003 	mov	r5, r3
  volume_t volume = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    volume = kernel_malloc (sizeof (struct _volume), true);
    7ad8:	eb001705 	bl	d6f4 <kernel_malloc>
    ensure (volume != NULL, DNA_OUT_OF_MEM);
    7adc:	e2506000 	subs	r6, r0, #0
    7ae0:	0a000019 	beq	7b4c <volume_create+0x8c>

    volume -> id = atomic_add (& volume_manager . volume_index, 1);
    7ae4:	e3a01001 	mov	r1, #1
    7ae8:	e59f0064 	ldr	r0, [pc, #100]	; 7b54 <volume_create+0x94>
    7aec:	eb0006b9 	bl	95d8 <atomic_add>
    volume -> root_vnid = -1;
    7af0:	e3e02000 	mvn	r2, #0
    7af4:	e3e03000 	mvn	r3, #0
    volume -> host_volume = host_volume;
    volume -> host_vnid = host_vnid;
    volume -> cmd = cmd;
    7af8:	e59d1018 	ldr	r1, [sp, #24]
  {
    volume = kernel_malloc (sizeof (struct _volume), true);
    ensure (volume != NULL, DNA_OUT_OF_MEM);

    volume -> id = atomic_add (& volume_manager . volume_index, 1);
    volume -> root_vnid = -1;
    7afc:	e1c620f8 	strd	r2, [r6, #8]
    volume -> host_volume = host_volume;
    volume -> host_vnid = host_vnid;
    volume -> cmd = cmd;
    7b00:	e5861020 	str	r1, [r6, #32]
    ensure (volume != NULL, DNA_OUT_OF_MEM);

    volume -> id = atomic_add (& volume_manager . volume_index, 1);
    volume -> root_vnid = -1;
    volume -> host_volume = host_volume;
    volume -> host_vnid = host_vnid;
    7b04:	e1c641f8 	strd	r4, [r6, #24]
  watch (status_t)
  {
    volume = kernel_malloc (sizeof (struct _volume), true);
    ensure (volume != NULL, DNA_OUT_OF_MEM);

    volume -> id = atomic_add (& volume_manager . volume_index, 1);
    7b08:	e5860004 	str	r0, [r6, #4]
    volume -> root_vnid = -1;
    volume -> host_volume = host_volume;
    7b0c:	e5867014 	str	r7, [r6, #20]
    volume -> host_vnid = host_vnid;
    volume -> cmd = cmd;

    it_status = cpu_trap_mask_and_backup();
    7b10:	eb0007fa 	bl	9b00 <cpu_trap_mask_and_backup>
    7b14:	e1a04000 	mov	r4, r0
    lock_acquire (& volume_manager . volume_list . lock);
    7b18:	e59f0038 	ldr	r0, [pc, #56]	; 7b58 <volume_create+0x98>
    7b1c:	eb000943 	bl	a030 <lock_acquire>

    queue_add (& volume_manager . volume_list, volume);
    7b20:	e1a01006 	mov	r1, r6
    7b24:	e59f002c 	ldr	r0, [pc, #44]	; 7b58 <volume_create+0x98>
    7b28:	eb000655 	bl	9484 <queue_add>

    lock_release (& volume_manager . volume_list . lock);
    7b2c:	e59f0024 	ldr	r0, [pc, #36]	; 7b58 <volume_create+0x98>
    7b30:	eb0013ef 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    7b34:	e1a00004 	mov	r0, r4
    7b38:	eb000829 	bl	9be4 <cpu_trap_restore>

    *p_volume = volume;
    7b3c:	e59d301c 	ldr	r3, [sp, #28]
    return DNA_OK;
    7b40:	e3a00000 	mov	r0, #0
    queue_add (& volume_manager . volume_list, volume);

    lock_release (& volume_manager . volume_list . lock);
    cpu_trap_restore(it_status);

    *p_volume = volume;
    7b44:	e5836000 	str	r6, [r3]
    return DNA_OK;
    7b48:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    volume = kernel_malloc (sizeof (struct _volume), true);
    ensure (volume != NULL, DNA_OUT_OF_MEM);
    7b4c:	e59f0008 	ldr	r0, [pc, #8]	; 7b5c <volume_create+0x9c>
    cpu_trap_restore(it_status);

    *p_volume = volume;
    return DNA_OK;
  }
}
    7b50:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
    7b54:	000355fc 	.word	0x000355fc
    7b58:	00035600 	.word	0x00035600
    7b5c:	0000fffd 	.word	0x0000fffd

00007b60 <file_put>:
 * * DNA_OK if the operation succeed
 *
 * SOURCE
 */

{
    7b60:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    7b64:	e24dd05c 	sub	sp, sp, #92	; 0x5c
    7b68:	e1a04000 	mov	r4, r0
  interrupt_status_t it_status = 0;
  vnode_t vnode = NULL;

  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    7b6c:	e28d1004 	add	r1, sp, #4
    7b70:	e3a00000 	mov	r0, #0
    7b74:	eb001521 	bl	d000 <thread_find>
    ensure (status == DNA_OK, status);
    7b78:	e3500000 	cmp	r0, #0
    7b7c:	0a000001 	beq	7b88 <file_put+0x28>
  {
    lock_release (& file_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    7b80:	e28dd05c 	add	sp, sp, #92	; 0x5c
    7b84:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  watch (status_t)
  {
    status = thread_find (NULL, & tid);
    ensure (status == DNA_OK, status);

    status = thread_get_info (tid, & info);
    7b88:	e59d0004 	ldr	r0, [sp, #4]
    7b8c:	e28d1008 	add	r1, sp, #8
    7b90:	eb0010c3 	bl	bea4 <thread_get_info>
    ensure (status == DNA_OK, status);
    7b94:	e3500000 	cmp	r0, #0
    7b98:	1afffff8 	bne	7b80 <file_put+0x20>

    ensure (info . group >= 0, DNA_BAD_ARGUMENT);
    ensure (info . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    7b9c:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
    7ba0:	e3530000 	cmp	r3, #0
    7ba4:	159f010c 	ldrne	r0, [pc, #268]	; 7cb8 <file_put+0x158>
    7ba8:	1afffff4 	bne	7b80 <file_put+0x20>

    /*
     * Look for the file in the pool.
     */

    it_status = cpu_trap_mask_and_backup();
    7bac:	eb0007d3 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& file_pool . lock);
    7bb0:	e59f6104 	ldr	r6, [pc, #260]	; 7cbc <file_put+0x15c>

    /*
     * Look for the file in the pool.
     */

    it_status = cpu_trap_mask_and_backup();
    7bb4:	e1a07000 	mov	r7, r0
    lock_acquire (& file_pool . lock);
    7bb8:	e1a00006 	mov	r0, r6
    7bbc:	eb00091b 	bl	a030 <lock_acquire>

    file = file_pool . file[info . group][fd];
    7bc0:	e5963004 	ldr	r3, [r6, #4]
    7bc4:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
    7bc8:	e7933102 	ldr	r3, [r3, r2, lsl #2]
    7bcc:	e7935104 	ldr	r5, [r3, r4, lsl #2]
    check (error, file != NULL, DNA_INVALID_FD);
    7bd0:	e3550000 	cmp	r5, #0
    7bd4:	0a000018 	beq	7c3c <file_put+0xdc>
    check (error, file -> usage_counter > 0, DNA_ERROR);
    7bd8:	e5953004 	ldr	r3, [r5, #4]
    7bdc:	e3530000 	cmp	r3, #0
    7be0:	da00000e 	ble	7c20 <file_put+0xc0>

    atomic_add (& file -> usage_counter, -1);
    7be4:	e2850004 	add	r0, r5, #4
    7be8:	e3e01000 	mvn	r1, #0
    7bec:	eb000679 	bl	95d8 <atomic_add>
 
    if (file -> usage_counter == 0 && file -> destroy)
    7bf0:	e5953004 	ldr	r3, [r5, #4]
    7bf4:	e3530000 	cmp	r3, #0
    7bf8:	1a000002 	bne	7c08 <file_put+0xa8>
    7bfc:	e5d5200c 	ldrb	r2, [r5, #12]
    7c00:	e3520000 	cmp	r2, #0
    7c04:	1a00000e 	bne	7c44 <file_put+0xe4>
      status = vnode_put (vnode -> volume -> id, vnode -> id);
      panic (status != DNA_OK);
    }
    else
    {
      lock_release (& file_pool . lock);
    7c08:	e59f00ac 	ldr	r0, [pc, #172]	; 7cbc <file_put+0x15c>
    7c0c:	eb0013b8 	bl	caf4 <lock_release>
      cpu_trap_restore(it_status);
    7c10:	e1a00007 	mov	r0, r7
    7c14:	eb0007f2 	bl	9be4 <cpu_trap_restore>
    }

    dna_log(VERBOSE_LEVEL, "Put FD %d.", fd);

    return DNA_OK;
    7c18:	e3a00000 	mov	r0, #0
    7c1c:	eaffffd7 	b	7b80 <file_put+0x20>
    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& file_pool . lock);

    file = file_pool . file[info . group][fd];
    check (error, file != NULL, DNA_INVALID_FD);
    check (error, file -> usage_counter > 0, DNA_ERROR);
    7c20:	e59f4098 	ldr	r4, [pc, #152]	; 7cc0 <file_put+0x160>
    return DNA_OK;
  }

  rescue (error)
  {
    lock_release (& file_pool . lock);
    7c24:	e59f0090 	ldr	r0, [pc, #144]	; 7cbc <file_put+0x15c>
    7c28:	eb0013b1 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    7c2c:	e1a00007 	mov	r0, r7
    7c30:	eb0007eb 	bl	9be4 <cpu_trap_restore>
    leave;
    7c34:	e1a00004 	mov	r0, r4
    7c38:	eaffffd0 	b	7b80 <file_put+0x20>

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& file_pool . lock);

    file = file_pool . file[info . group][fd];
    check (error, file != NULL, DNA_INVALID_FD);
    7c3c:	e59f4080 	ldr	r4, [pc, #128]	; 7cc4 <file_put+0x164>
    7c40:	eafffff7 	b	7c24 <file_put+0xc4>

    atomic_add (& file -> usage_counter, -1);
 
    if (file -> usage_counter == 0 && file -> destroy)
    {
      file_pool . file[info . group][fd] = NULL;
    7c44:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
    7c48:	e5962004 	ldr	r2, [r6, #4]

      lock_release (& file_pool . lock);
    7c4c:	e1a00006 	mov	r0, r6

    atomic_add (& file -> usage_counter, -1);
 
    if (file -> usage_counter == 0 && file -> destroy)
    {
      file_pool . file[info . group][fd] = NULL;
    7c50:	e7922101 	ldr	r2, [r2, r1, lsl #2]
    7c54:	e7823104 	str	r3, [r2, r4, lsl #2]

      lock_release (& file_pool . lock);
    7c58:	eb0013a5 	bl	caf4 <lock_release>
      cpu_trap_restore(it_status);
    7c5c:	e1a00007 	mov	r0, r7
    7c60:	eb0007df 	bl	9be4 <cpu_trap_restore>

      status =  file -> vnode -> volume -> cmd -> free
    7c64:	e5951008 	ldr	r1, [r5, #8]
    7c68:	e5952020 	ldr	r2, [r5, #32]
    7c6c:	e5913010 	ldr	r3, [r1, #16]
    7c70:	e591101c 	ldr	r1, [r1, #28]
    7c74:	e593c020 	ldr	ip, [r3, #32]
    7c78:	e5930024 	ldr	r0, [r3, #36]	; 0x24
    7c7c:	e59c301c 	ldr	r3, [ip, #28]
    7c80:	e12fff33 	blx	r3
        (file -> vnode -> volume -> data, file -> vnode -> data, file -> data);
      panic (status != DNA_OK);
    7c84:	e3500000 	cmp	r0, #0
    7c88:	0a000000 	beq	7c90 <file_put+0x130>
    7c8c:	eafffffe 	b	7c8c <file_put+0x12c>

      vnode = file -> vnode;
    7c90:	e5954008 	ldr	r4, [r5, #8]
      kernel_free (file);
    7c94:	e1a00005 	mov	r0, r5
    7c98:	eb0016ca 	bl	d7c8 <kernel_free>

      status = vnode_put (vnode -> volume -> id, vnode -> id);
    7c9c:	e1c420d8 	ldrd	r2, [r4, #8]
    7ca0:	e5941010 	ldr	r1, [r4, #16]
    7ca4:	e5910004 	ldr	r0, [r1, #4]
    7ca8:	ebfffb7d 	bl	6aa4 <vnode_put>
      panic (status != DNA_OK);
    7cac:	e3500000 	cmp	r0, #0
    7cb0:	0affffb2 	beq	7b80 <file_put+0x20>
    7cb4:	eafffffe 	b	7cb4 <file_put+0x154>
    7cb8:	0000fffc 	.word	0x0000fffc
    7cbc:	000355dc 	.word	0x000355dc
    7cc0:	0000ffff 	.word	0x0000ffff
    7cc4:	0000fef8 	.word	0x0000fef8

00007cc8 <vfs_write>:
 * RESULT
 *
 * SOURCE
 */

{
    7cc8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  interrupt_status_t it_status;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (data != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    7ccc:	e3530000 	cmp	r3, #0
    7cd0:	13510000 	cmpne	r1, #0
    7cd4:	e1a06003 	mov	r6, r3
 *
 * SOURCE
 */

{
  file_t file = NULL;
    7cd8:	e3a03000 	mov	r3, #0
 * RESULT
 *
 * SOURCE
 */

{
    7cdc:	e24dd018 	sub	sp, sp, #24
  interrupt_status_t it_status;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (data != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    7ce0:	e1a08001 	mov	r8, r1
 * SOURCE
 */

{
  file_t file = NULL;
  int32_t n_data = count;
    7ce4:	e58d2014 	str	r2, [sp, #20]
 *
 * SOURCE
 */

{
  file_t file = NULL;
    7ce8:	e58d3010 	str	r3, [sp, #16]
  interrupt_status_t it_status;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (data != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    7cec:	1a000002 	bne	7cfc <vfs_write+0x34>
    7cf0:	e59f00e4 	ldr	r0, [pc, #228]	; 7ddc <vfs_write+0x114>
  {
    file_put (fd);
    *p_ret = -1;
    leave;
  }
}
    7cf4:	e28dd018 	add	sp, sp, #24
    7cf8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  interrupt_status_t it_status;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (data != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    7cfc:	e1520003 	cmp	r2, r3
    7d00:	dafffffa 	ble	7cf0 <vfs_write+0x28>
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    7d04:	e6ff3070 	uxth	r3, r0
    7d08:	e35300ff 	cmp	r3, #255	; 0xff
    7d0c:	e1a07000 	mov	r7, r0
    7d10:	859f00c8 	ldrhi	r0, [pc, #200]	; 7de0 <vfs_write+0x118>
    7d14:	8afffff6 	bhi	7cf4 <vfs_write+0x2c>

    /*
     * Get the file associated to the fd.
     */

    status = file_get (fd, & file);
    7d18:	e28d1010 	add	r1, sp, #16
    7d1c:	ebfffdc4 	bl	7434 <file_get>
    ensure (status == DNA_OK, status);
    7d20:	e3500000 	cmp	r0, #0
    7d24:	1afffff2 	bne	7cf4 <vfs_write+0x2c>

    /*
     * Read the file.
     */
    cpu_dcache_invalidate((void*)&file->offset, sizeof(uint32_t) );
    7d28:	e59d0010 	ldr	r0, [sp, #16]
    7d2c:	e3a01004 	mov	r1, #4
    7d30:	e2800018 	add	r0, r0, #24
    7d34:	eb0007dd 	bl	9cb0 <cpu_dcache_invalidate>
    status = file -> vnode -> volume -> cmd -> write
    7d38:	e59d3010 	ldr	r3, [sp, #16]
    7d3c:	e28de014 	add	lr, sp, #20
    7d40:	e5931008 	ldr	r1, [r3, #8]
    7d44:	e1c341d8 	ldrd	r4, [r3, #24]
    7d48:	e5910010 	ldr	r0, [r1, #16]
    7d4c:	e5932020 	ldr	r2, [r3, #32]
    7d50:	e590c020 	ldr	ip, [r0, #32]
    7d54:	e591101c 	ldr	r1, [r1, #28]
    7d58:	e5900024 	ldr	r0, [r0, #36]	; 0x24
    7d5c:	e1cd40f0 	strd	r4, [sp]
    7d60:	e58de008 	str	lr, [sp, #8]
    7d64:	e1a03008 	mov	r3, r8
    7d68:	e59cc028 	ldr	ip, [ip, #40]	; 0x28
    7d6c:	e12fff3c 	blx	ip
      (file -> vnode -> volume -> data, file -> vnode -> data, file -> data,
       data, file -> offset, & n_data);

    check (write_error, status == DNA_OK, status);
    7d70:	e2504000 	subs	r4, r0, #0
    7d74:	1a000012 	bne	7dc4 <vfs_write+0xfc>

    /*
     * If everything went well, increasing the file offset.
     */

    it_status = cpu_trap_mask_and_backup();
    7d78:	eb000760 	bl	9b00 <cpu_trap_mask_and_backup>
    7d7c:	e1a04000 	mov	r4, r0
    lock_acquire (& file -> lock);
    7d80:	e59d0010 	ldr	r0, [sp, #16]
    7d84:	eb0008a9 	bl	a030 <lock_acquire>

    file -> offset += n_data;
    7d88:	e59d1010 	ldr	r1, [sp, #16]
    7d8c:	e59d0014 	ldr	r0, [sp, #20]
    7d90:	e1c121d8 	ldrd	r2, [r1, #24]
    7d94:	e0922000 	adds	r2, r2, r0
    7d98:	e0a33fc0 	adc	r3, r3, r0, asr #31
    7d9c:	e1c121f8 	strd	r2, [r1, #24]

    lock_release (& file -> lock);
    7da0:	e1a00001 	mov	r0, r1
    7da4:	eb001352 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    7da8:	e1a00004 	mov	r0, r4
    7dac:	eb00078c 	bl	9be4 <cpu_trap_restore>

    /*
     * Release the file and return.
     */

    *p_ret = n_data;
    7db0:	e59d3014 	ldr	r3, [sp, #20]
    return file_put (fd);
    7db4:	e1a00007 	mov	r0, r7

    /*
     * Release the file and return.
     */

    *p_ret = n_data;
    7db8:	e5863000 	str	r3, [r6]
    return file_put (fd);
    7dbc:	ebffff67 	bl	7b60 <file_put>
    7dc0:	eaffffcb 	b	7cf4 <vfs_write+0x2c>
  }

  rescue (write_error)
  {
    file_put (fd);
    7dc4:	e1a00007 	mov	r0, r7
    7dc8:	ebffff64 	bl	7b60 <file_put>
    *p_ret = -1;
    7dcc:	e3e03000 	mvn	r3, #0
    leave;
    7dd0:	e1a00004 	mov	r0, r4
  }

  rescue (write_error)
  {
    file_put (fd);
    *p_ret = -1;
    7dd4:	e5863000 	str	r3, [r6]
    leave;
    7dd8:	eaffffc5 	b	7cf4 <vfs_write+0x2c>
    7ddc:	0000ffff 	.word	0x0000ffff
    7de0:	0000fef8 	.word	0x0000fef8

00007de4 <volume_id_inspector>:
  volume_t nspace = ns;
  int32_t nid = va_arg (list, int32_t);

  watch (bool)
  {
    ensure (nspace != NULL, false);
    7de4:	e3500000 	cmp	r0, #0
 * SOURCE
 */

{
  volume_t nspace = ns;
  int32_t nid = va_arg (list, int32_t);
    7de8:	e5913000 	ldr	r3, [r1]

  watch (bool)
  {
    ensure (nspace != NULL, false);
    return nspace -> id == nid;
    7dec:	15900004 	ldrne	r0, [r0, #4]
    7df0:	10630000 	rsbne	r0, r3, r0
    7df4:	116f0f10 	clzne	r0, r0
    7df8:	11a002a0 	lsrne	r0, r0, #5
  }
}
    7dfc:	e12fff1e 	bx	lr

00007e00 <vfs_start>:
     * Mounting the file systems
     */

    dna_log(INFO_LEVEL, "Mounting the default file systems.");

    status = vfs_mount ("", "/", "rootfs", 0, NULL);
    7e00:	e3a03000 	mov	r3, #0
 *
 * SOURCE
 */

{
  int16_t dummy = -1;
    7e04:	e3e0c000 	mvn	ip, #0
 * Mount the base file systems and open the standard files.
 *
 * SOURCE
 */

{
    7e08:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    7e0c:	e24dd014 	sub	sp, sp, #20
     * Mounting the file systems
     */

    dna_log(INFO_LEVEL, "Mounting the default file systems.");

    status = vfs_mount ("", "/", "rootfs", 0, NULL);
    7e10:	e58d3000 	str	r3, [sp]
    7e14:	e59f008c 	ldr	r0, [pc, #140]	; 7ea8 <vfs_start+0xa8>
    7e18:	e59f108c 	ldr	r1, [pc, #140]	; 7eac <vfs_start+0xac>
    7e1c:	e59f208c 	ldr	r2, [pc, #140]	; 7eb0 <vfs_start+0xb0>
 *
 * SOURCE
 */

{
  int16_t dummy = -1;
    7e20:	e1cdc0be 	strh	ip, [sp, #14]
     * Mounting the file systems
     */

    dna_log(INFO_LEVEL, "Mounting the default file systems.");

    status = vfs_mount ("", "/", "rootfs", 0, NULL);
    7e24:	eb000050 	bl	7f6c <vfs_mount>
    ensure (status == DNA_OK, status);
    7e28:	e2503000 	subs	r3, r0, #0
    7e2c:	11a00003 	movne	r0, r3
    7e30:	0a000001 	beq	7e3c <vfs_start+0x3c>
    status = vfs_open ("/devices/serial/kernel/console", 0, 0, & dummy);
    ensure (status == DNA_OK, status);

    return DNA_OK;
  }
}
    7e34:	e28dd014 	add	sp, sp, #20
    7e38:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    dna_log(INFO_LEVEL, "Mounting the default file systems.");

    status = vfs_mount ("", "/", "rootfs", 0, NULL);
    ensure (status == DNA_OK, status);

    status = vfs_mount ("", "/devices", "devfs", 0, NULL);
    7e3c:	e59f1070 	ldr	r1, [pc, #112]	; 7eb4 <vfs_start+0xb4>
    7e40:	e58d3000 	str	r3, [sp]
    7e44:	e59f005c 	ldr	r0, [pc, #92]	; 7ea8 <vfs_start+0xa8>
    7e48:	e59f2068 	ldr	r2, [pc, #104]	; 7eb8 <vfs_start+0xb8>
    7e4c:	eb000046 	bl	7f6c <vfs_mount>
    ensure (status == DNA_OK, status);
    7e50:	e2501000 	subs	r1, r0, #0
    7e54:	0a000002 	beq	7e64 <vfs_start+0x64>
    7e58:	e1a00001 	mov	r0, r1
    status = vfs_open ("/devices/serial/kernel/console", 0, 0, & dummy);
    ensure (status == DNA_OK, status);

    return DNA_OK;
  }
}
    7e5c:	e28dd014 	add	sp, sp, #20
    7e60:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
     * Opening the default in/out/error files
     */

    dna_log(INFO_LEVEL, "Opening the default in/out/error files.");

    status = vfs_open ("/devices/serial/kernel/console", 0, 0, & dummy);
    7e64:	e1a02001 	mov	r2, r1
    7e68:	e28d300e 	add	r3, sp, #14
    7e6c:	e59f0048 	ldr	r0, [pc, #72]	; 7ebc <vfs_start+0xbc>
    7e70:	ebfffe13 	bl	76c4 <vfs_open>
    ensure (status == DNA_OK, status);
    7e74:	e2501000 	subs	r1, r0, #0
    7e78:	1afffff6 	bne	7e58 <vfs_start+0x58>

    status = vfs_open ("/devices/serial/kernel/console", 0, 0, & dummy);
    7e7c:	e1a02001 	mov	r2, r1
    7e80:	e59f0034 	ldr	r0, [pc, #52]	; 7ebc <vfs_start+0xbc>
    7e84:	e28d300e 	add	r3, sp, #14
    7e88:	ebfffe0d 	bl	76c4 <vfs_open>
    ensure (status == DNA_OK, status);
    7e8c:	e2501000 	subs	r1, r0, #0
    7e90:	1afffff0 	bne	7e58 <vfs_start+0x58>

    status = vfs_open ("/devices/serial/kernel/console", 0, 0, & dummy);
    7e94:	e28d300e 	add	r3, sp, #14
    7e98:	e1a02001 	mov	r2, r1
    7e9c:	e59f0018 	ldr	r0, [pc, #24]	; 7ebc <vfs_start+0xbc>
    7ea0:	ebfffe07 	bl	76c4 <vfs_open>
    7ea4:	eaffffe2 	b	7e34 <vfs_start+0x34>
    7ea8:	00023d94 	.word	0x00023d94
    7eac:	00023b68 	.word	0x00023b68
    7eb0:	00023ba8 	.word	0x00023ba8
    7eb4:	0002463c 	.word	0x0002463c
    7eb8:	00023b74 	.word	0x00023b74
    7ebc:	00024648 	.word	0x00024648

00007ec0 <vfs_close>:
 *
 * SOURCE
 */

{
  file_t file = NULL;
    7ec0:	e3a03000 	mov	r3, #0
 * * DNA_OK if the operation succeed
 *
 * SOURCE
 */

{
    7ec4:	e92d4030 	push	{r4, r5, lr}
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    7ec8:	e6ff2070 	uxth	r2, r0
 * * DNA_OK if the operation succeed
 *
 * SOURCE
 */

{
    7ecc:	e24dd00c 	sub	sp, sp, #12
  file_t file = NULL;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    7ed0:	e35200ff 	cmp	r2, #255	; 0xff
 * * DNA_OK if the operation succeed
 *
 * SOURCE
 */

{
    7ed4:	e1a04000 	mov	r4, r0
  file_t file = NULL;
    7ed8:	e58d3004 	str	r3, [sp, #4]
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    7edc:	859f0084 	ldrhi	r0, [pc, #132]	; 7f68 <vfs_close+0xa8>
    7ee0:	9a000001 	bls	7eec <vfs_close+0x2c>
    status = file_put (fd);
    panic (status != DNA_OK);

    leave;
  }
}
    7ee4:	e28dd00c 	add	sp, sp, #12
    7ee8:	e8bd8030 	pop	{r4, r5, pc}

    /*
     * Get the file associated to the fd.
     */

    status = file_get (fd, & file);
    7eec:	e28d1004 	add	r1, sp, #4
    7ef0:	ebfffd4f 	bl	7434 <file_get>
    ensure (status == DNA_OK, status);
    7ef4:	e3500000 	cmp	r0, #0
    7ef8:	1afffff9 	bne	7ee4 <vfs_close+0x24>

    /*
     * Close the file.
     */

    status = file -> vnode -> volume -> cmd -> close
    7efc:	e59d3004 	ldr	r3, [sp, #4]
    7f00:	e5931008 	ldr	r1, [r3, #8]
    7f04:	e5932020 	ldr	r2, [r3, #32]
    7f08:	e5913010 	ldr	r3, [r1, #16]
    7f0c:	e591101c 	ldr	r1, [r1, #28]
    7f10:	e593c020 	ldr	ip, [r3, #32]
    7f14:	e5930024 	ldr	r0, [r3, #36]	; 0x24
    7f18:	e59c3018 	ldr	r3, [ip, #24]
    7f1c:	e12fff33 	blx	r3
      (file -> vnode -> volume -> data, file -> vnode -> data, file -> data);

    check (error, status == DNA_OK, status);
    7f20:	e2505000 	subs	r5, r0, #0
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    7f24:	e1a00004 	mov	r0, r4
     */

    status = file -> vnode -> volume -> cmd -> close
      (file -> vnode -> volume -> data, file -> vnode -> data, file -> data);

    check (error, status == DNA_OK, status);
    7f28:	0a000003 	beq	7f3c <vfs_close+0x7c>
    return DNA_OK;
  }

  rescue (error)
  {
    status = file_put (fd);
    7f2c:	ebffff0b 	bl	7b60 <file_put>
    panic (status != DNA_OK);
    7f30:	e3500000 	cmp	r0, #0
    7f34:	0a000004 	beq	7f4c <vfs_close+0x8c>
    7f38:	eafffffe 	b	7f38 <vfs_close+0x78>

    /*
     * Release the file, destroy the file, and return.
     */

    status = file_put (fd);
    7f3c:	ebffff07 	bl	7b60 <file_put>
    panic (status != DNA_OK);
    7f40:	e3500000 	cmp	r0, #0
    7f44:	0a000002 	beq	7f54 <vfs_close+0x94>
    7f48:	eafffffe 	b	7f48 <vfs_close+0x88>
    7f4c:	e1a00005 	mov	r0, r5
    7f50:	eaffffe3 	b	7ee4 <vfs_close+0x24>

    status = file_destroy (fd);
    7f54:	e1a00004 	mov	r0, r4
    7f58:	ebfffc8b 	bl	718c <file_destroy>
    panic (status != DNA_OK);
    7f5c:	e3500000 	cmp	r0, #0
    7f60:	0affffdf 	beq	7ee4 <vfs_close+0x24>
    7f64:	eafffffe 	b	7f64 <vfs_close+0xa4>
    7f68:	0000fef8 	.word	0x0000fef8

00007f6c <vfs_mount>:
 *
 * SOURCE
 */

{
  filesystem_t * fs = NULL;
    7f6c:	e3a0c000 	mov	ip, #0
 * DNA_ERROR : fs_type doesn't exist.
 *
 * SOURCE
 */

{
    7f70:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (source != NULL && target != NULL
    7f74:	e151000c 	cmp	r1, ip
    7f78:	1150000c 	cmpne	r0, ip
 * SOURCE
 */

{
  filesystem_t * fs = NULL;
  int64_t host_vnid = -1;
    7f7c:	e3e04000 	mvn	r4, #0
    7f80:	e3e05000 	mvn	r5, #0
 * DNA_ERROR : fs_type doesn't exist.
 *
 * SOURCE
 */

{
    7f84:	e24dd024 	sub	sp, sp, #36	; 0x24
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (source != NULL && target != NULL
    7f88:	e1a06000 	mov	r6, r0
 *
 * SOURCE
 */

{
  filesystem_t * fs = NULL;
    7f8c:	e58dc008 	str	ip, [sp, #8]
  int64_t host_vnid = -1;
  volume_t host_volume = NULL, volume = NULL;
    7f90:	e58dc00c 	str	ip, [sp, #12]
    7f94:	e58dc010 	str	ip, [sp, #16]

  void * node_data = NULL;
    7f98:	e58dc014 	str	ip, [sp, #20]
 * SOURCE
 */

{
  filesystem_t * fs = NULL;
  int64_t host_vnid = -1;
    7f9c:	e1cd41f8 	strd	r4, [sp, #24]
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (source != NULL && target != NULL
    7fa0:	1a000002 	bne	7fb0 <vfs_mount+0x44>
    7fa4:	e59f0148 	ldr	r0, [pc, #328]	; 80f4 <vfs_mount+0x188>
    status = volume_destroy (volume);
    panic (status != DNA_OK);

    leave;
  }
}
    7fa8:	e28dd024 	add	sp, sp, #36	; 0x24
    7fac:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (source != NULL && target != NULL
    7fb0:	e152000c 	cmp	r2, ip
    7fb4:	e1a08002 	mov	r8, r2
    7fb8:	0afffff9 	beq	7fa4 <vfs_mount+0x38>

    /*
     * Find the vnode corresponding to the path
     */

    status = vnode_walk (target, & host_volume, & host_vnid, & node_data);
    7fbc:	e1a00001 	mov	r0, r1
    7fc0:	e1a07003 	mov	r7, r3
    7fc4:	e28d100c 	add	r1, sp, #12
    7fc8:	e28d3014 	add	r3, sp, #20
    7fcc:	e28d2018 	add	r2, sp, #24
    7fd0:	eb000150 	bl	8518 <vnode_walk>
    ensure (status == DNA_OK || status == DNA_NO_VOLUME, status);
    7fd4:	e59f311c 	ldr	r3, [pc, #284]	; 80f8 <vfs_mount+0x18c>
    7fd8:	e1500003 	cmp	r0, r3
    7fdc:	13500000 	cmpne	r0, #0
    7fe0:	1afffff0 	bne	7fa8 <vfs_mount+0x3c>

    /*
     * Check if the vnode is not already associated
     */

    it_status = cpu_trap_mask_and_backup();
    7fe4:	eb0006c5 	bl	9b00 <cpu_trap_mask_and_backup>
    7fe8:	e1a09000 	mov	r9, r0
    lock_acquire (& volume_manager . volume_list . lock);
    7fec:	e59f0108 	ldr	r0, [pc, #264]	; 80fc <vfs_mount+0x190>
    7ff0:	eb00080e 	bl	a030 <lock_acquire>

    volume = queue_lookup (& volume_manager . volume_list,
    7ff4:	e1cd41d8 	ldrd	r4, [sp, #24]
    7ff8:	e59d200c 	ldr	r2, [sp, #12]
    7ffc:	e59f10fc 	ldr	r1, [pc, #252]	; 8100 <vfs_mount+0x194>
    8000:	e1cd40f0 	strd	r4, [sp]
    8004:	e59f00f0 	ldr	r0, [pc, #240]	; 80fc <vfs_mount+0x190>
    8008:	eb000554 	bl	9560 <queue_lookup>
    800c:	e58d0010 	str	r0, [sp, #16]
        volume_host_inspector, host_volume, host_vnid);

    lock_release (& volume_manager . volume_list . lock);
    8010:	e59f00e4 	ldr	r0, [pc, #228]	; 80fc <vfs_mount+0x190>
    8014:	eb0012b6 	bl	caf4 <lock_release>
    cpu_trap_restore (it_status);
    8018:	e1a00009 	mov	r0, r9
    801c:	eb0006f0 	bl	9be4 <cpu_trap_restore>

    ensure (volume == NULL, DNA_VNODE_MOUNTED);
    8020:	e59d3010 	ldr	r3, [sp, #16]
    8024:	e3530000 	cmp	r3, #0
    8028:	159f00d4 	ldrne	r0, [pc, #212]	; 8104 <vfs_mount+0x198>
    802c:	1affffdd 	bne	7fa8 <vfs_mount+0x3c>

    /*
     * Get the required filesystem
     */

    status = filesystem_load (fs_type, & fs);
    8030:	e1a00008 	mov	r0, r8
    8034:	e28d1008 	add	r1, sp, #8
    8038:	ebfffe26 	bl	78d8 <filesystem_load>
    ensure (status == DNA_OK, status);
    803c:	e3500000 	cmp	r0, #0
    8040:	1affffd8 	bne	7fa8 <vfs_mount+0x3c>

    /*
     * Create the volume
     */

    status = volume_create (host_volume, host_vnid, fs -> cmd, & volume);
    8044:	e1cd21d8 	ldrd	r2, [sp, #24]
    8048:	e59d1008 	ldr	r1, [sp, #8]
    804c:	e59d000c 	ldr	r0, [sp, #12]
    8050:	e591c004 	ldr	ip, [r1, #4]
    8054:	e28d1010 	add	r1, sp, #16
    8058:	e58dc000 	str	ip, [sp]
    805c:	e58d1004 	str	r1, [sp, #4]
    8060:	ebfffe96 	bl	7ac0 <volume_create>
    ensure (volume != NULL, DNA_OUT_OF_MEM);
    8064:	e59d3010 	ldr	r3, [sp, #16]
    8068:	e3530000 	cmp	r3, #0
    806c:	0a000017 	beq	80d0 <vfs_mount+0x164>

    /*
     * Mount the filesystem
     */

    status = fs -> cmd -> mount (volume -> id, source, flags, data,
    8070:	e59d2008 	ldr	r2, [sp, #8]
    8074:	e2831024 	add	r1, r3, #36	; 0x24
    8078:	e5920004 	ldr	r0, [r2, #4]
    807c:	e2832008 	add	r2, r3, #8
    8080:	e88d0006 	stm	sp, {r1, r2}
    8084:	e1a01006 	mov	r1, r6
    8088:	e590c004 	ldr	ip, [r0, #4]
    808c:	e1a02007 	mov	r2, r7
    8090:	e5930004 	ldr	r0, [r3, #4]
    8094:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
    8098:	e12fff3c 	blx	ip
        & volume -> data, & volume -> root_vnid);

    check (cannot_mount, status == DNA_OK, status);
    809c:	e2504000 	subs	r4, r0, #0
    80a0:	1a00000c 	bne	80d8 <vfs_mount+0x16c>

    /*
     * Put the host vnode back
     */

    if (host_volume != NULL)
    80a4:	e59d300c 	ldr	r3, [sp, #12]
    80a8:	e3530000 	cmp	r3, #0
    80ac:	0a000005 	beq	80c8 <vfs_mount+0x15c>
    {
      status = vnode_put (host_volume -> id, host_vnid);
    80b0:	e5930004 	ldr	r0, [r3, #4]
    80b4:	e1cd21d8 	ldrd	r2, [sp, #24]
    80b8:	ebfffa79 	bl	6aa4 <vnode_put>
      panic (status != DNA_OK);
    80bc:	e3500000 	cmp	r0, #0
    80c0:	0a000000 	beq	80c8 <vfs_mount+0x15c>
    80c4:	eafffffe 	b	80c4 <vfs_mount+0x158>
    }

    return DNA_OK;
    80c8:	e3a00000 	mov	r0, #0
    80cc:	eaffffb5 	b	7fa8 <vfs_mount+0x3c>
    /*
     * Create the volume
     */

    status = volume_create (host_volume, host_vnid, fs -> cmd, & volume);
    ensure (volume != NULL, DNA_OUT_OF_MEM);
    80d0:	e59f0030 	ldr	r0, [pc, #48]	; 8108 <vfs_mount+0x19c>
    80d4:	eaffffb3 	b	7fa8 <vfs_mount+0x3c>
    return DNA_OK;
  }

  rescue (cannot_mount)
  {
    status = volume_destroy (volume);
    80d8:	e59d0010 	ldr	r0, [sp, #16]
    80dc:	ebfffa5d 	bl	6a58 <volume_destroy>
    panic (status != DNA_OK);
    80e0:	e3500000 	cmp	r0, #0
    80e4:	0a000000 	beq	80ec <vfs_mount+0x180>
    80e8:	eafffffe 	b	80e8 <vfs_mount+0x17c>
    80ec:	e1a00004 	mov	r0, r4
    80f0:	eaffffac 	b	7fa8 <vfs_mount+0x3c>
    80f4:	0000ffff 	.word	0x0000ffff
    80f8:	0000fefe 	.word	0x0000fefe
    80fc:	00035600 	.word	0x00035600
    8100:	0000714c 	.word	0x0000714c
    8104:	0000fefb 	.word	0x0000fefb
    8108:	0000fffd 	.word	0x0000fffd

0000810c <vfs_read>:
 * * DNA_OK : the operation succeeded
 *
 * SOURCE
 */

{
    810c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  interrupt_status_t it_status;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (data != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    8110:	e3530000 	cmp	r3, #0
    8114:	13510000 	cmpne	r1, #0
    8118:	e1a06003 	mov	r6, r3
 *
 * SOURCE
 */

{
  file_t file = NULL;
    811c:	e3a03000 	mov	r3, #0
 * * DNA_OK : the operation succeeded
 *
 * SOURCE
 */

{
    8120:	e24dd018 	sub	sp, sp, #24
  interrupt_status_t it_status;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (data != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    8124:	e1a08001 	mov	r8, r1
 * SOURCE
 */

{
  file_t file = NULL;
  int32_t n_data = count;
    8128:	e58d2014 	str	r2, [sp, #20]
 *
 * SOURCE
 */

{
  file_t file = NULL;
    812c:	e58d3010 	str	r3, [sp, #16]
  interrupt_status_t it_status;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (data != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    8130:	1a000002 	bne	8140 <vfs_read+0x34>
    8134:	e59f00ec 	ldr	r0, [pc, #236]	; 8228 <vfs_read+0x11c>
    panic (status != DNA_OK);

    *p_ret = -1;
    leave;
  }
}
    8138:	e28dd018 	add	sp, sp, #24
    813c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  interrupt_status_t it_status;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (data != NULL && p_ret != NULL && count > 0, DNA_ERROR);
    8140:	e1520003 	cmp	r2, r3
    8144:	dafffffa 	ble	8134 <vfs_read+0x28>
    ensure (fd >= 0 && fd < DNA_MAX_FILE, DNA_INVALID_FD);
    8148:	e6ff3070 	uxth	r3, r0
    814c:	e35300ff 	cmp	r3, #255	; 0xff
    8150:	e1a07000 	mov	r7, r0
    8154:	859f00d0 	ldrhi	r0, [pc, #208]	; 822c <vfs_read+0x120>
    8158:	8afffff6 	bhi	8138 <vfs_read+0x2c>

    /*
     * Get the file associated to the fd.
     */

    status = file_get (fd, & file);
    815c:	e28d1010 	add	r1, sp, #16
    8160:	ebfffcb3 	bl	7434 <file_get>
    ensure (status == DNA_OK, status);
    8164:	e3500000 	cmp	r0, #0
    8168:	1afffff2 	bne	8138 <vfs_read+0x2c>

    /*
     * Read the file.
     */

    status = file -> vnode -> volume -> cmd -> read
    816c:	e59d3010 	ldr	r3, [sp, #16]
    8170:	e28de014 	add	lr, sp, #20
    8174:	e5931008 	ldr	r1, [r3, #8]
    8178:	e1c341d8 	ldrd	r4, [r3, #24]
    817c:	e5910010 	ldr	r0, [r1, #16]
    8180:	e5932020 	ldr	r2, [r3, #32]
    8184:	e590c020 	ldr	ip, [r0, #32]
    8188:	e591101c 	ldr	r1, [r1, #28]
    818c:	e5900024 	ldr	r0, [r0, #36]	; 0x24
    8190:	e1cd40f0 	strd	r4, [sp]
    8194:	e58de008 	str	lr, [sp, #8]
    8198:	e1a03008 	mov	r3, r8
    819c:	e59cc024 	ldr	ip, [ip, #36]	; 0x24
    81a0:	e12fff3c 	blx	ip
      (file -> vnode -> volume -> data, file -> vnode -> data, file -> data,
       data, file -> offset, & n_data);

    check (read_error, status == DNA_OK, status);
    81a4:	e2504000 	subs	r4, r0, #0
    81a8:	0a000004 	beq	81c0 <vfs_read+0xb4>
    return DNA_OK;
  }

  rescue (read_error)
  {
    status = file_put (fd);
    81ac:	e1a00007 	mov	r0, r7
    81b0:	ebfffe6a 	bl	7b60 <file_put>
    panic (status != DNA_OK);
    81b4:	e3500000 	cmp	r0, #0
    81b8:	0a000016 	beq	8218 <vfs_read+0x10c>
    81bc:	eafffffe 	b	81bc <vfs_read+0xb0>

    /*
     * If everything went well, increasing the file offset.
     */

    it_status = cpu_trap_mask_and_backup();
    81c0:	eb00064e 	bl	9b00 <cpu_trap_mask_and_backup>
    81c4:	e1a04000 	mov	r4, r0
    lock_acquire (& file -> lock);
    81c8:	e59d0010 	ldr	r0, [sp, #16]
    81cc:	eb000797 	bl	a030 <lock_acquire>

    file -> offset += n_data;
    81d0:	e59d1010 	ldr	r1, [sp, #16]
    81d4:	e59d0014 	ldr	r0, [sp, #20]
    81d8:	e1c121d8 	ldrd	r2, [r1, #24]
    81dc:	e0922000 	adds	r2, r2, r0
    81e0:	e0a33fc0 	adc	r3, r3, r0, asr #31
    81e4:	e1c121f8 	strd	r2, [r1, #24]

    lock_release (& file -> lock);
    81e8:	e1a00001 	mov	r0, r1
    81ec:	eb001240 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    81f0:	e1a00004 	mov	r0, r4
    81f4:	eb00067a 	bl	9be4 <cpu_trap_restore>

    /*
     * Release the file and return.
     */

    status = file_put (fd);
    81f8:	e1a00007 	mov	r0, r7
    81fc:	ebfffe57 	bl	7b60 <file_put>
    panic (status != DNA_OK);
    8200:	e3500000 	cmp	r0, #0
    8204:	0a000000 	beq	820c <vfs_read+0x100>
    8208:	eafffffe 	b	8208 <vfs_read+0xfc>

    *p_ret = n_data;
    820c:	e59d3014 	ldr	r3, [sp, #20]
    8210:	e5863000 	str	r3, [r6]
    return DNA_OK;
    8214:	eaffffc7 	b	8138 <vfs_read+0x2c>
  rescue (read_error)
  {
    status = file_put (fd);
    panic (status != DNA_OK);

    *p_ret = -1;
    8218:	e3e03000 	mvn	r3, #0
    leave;
    821c:	e1a00004 	mov	r0, r4
  rescue (read_error)
  {
    status = file_put (fd);
    panic (status != DNA_OK);

    *p_ret = -1;
    8220:	e5863000 	str	r3, [r6]
    leave;
    8224:	eaffffc3 	b	8138 <vfs_read+0x2c>
    8228:	0000ffff 	.word	0x0000ffff
    822c:	0000fef8 	.word	0x0000fef8

00008230 <vnode_destroy>:
 * * DNA_NO_VNODE if the specified vnode hasn't been found.
 *
 * SOURCE
 */

{
    8230:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    8234:	e24dd00c 	sub	sp, sp, #12
    8238:	e1a04002 	mov	r4, r2
    823c:	e1a05003 	mov	r5, r3
    8240:	e1a06000 	mov	r6, r0
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup();
    8244:	eb00062d 	bl	9b00 <cpu_trap_mask_and_backup>
    8248:	e1a07000 	mov	r7, r0
    lock_acquire (& vnode_manager . vnode_list . lock);
    824c:	e59f00cc 	ldr	r0, [pc, #204]	; 8320 <vnode_destroy+0xf0>
    8250:	eb000776 	bl	a030 <lock_acquire>

    vnode = queue_lookup (& vnode_manager . vnode_list,
    8254:	e1a02004 	mov	r2, r4
    8258:	e58d6000 	str	r6, [sp]
    825c:	e1a03005 	mov	r3, r5
    8260:	e59f00b8 	ldr	r0, [pc, #184]	; 8320 <vnode_destroy+0xf0>
    8264:	e59f10b8 	ldr	r1, [pc, #184]	; 8324 <vnode_destroy+0xf4>
    8268:	eb0004bc 	bl	9560 <queue_lookup>
        vnode_id_inspector, vnid, vid);
    check (invalid_vnode, vnode != NULL, DNA_NO_VNODE);
    826c:	e2504000 	subs	r4, r0, #0
    8270:	0a000023 	beq	8304 <vnode_destroy+0xd4>

    atomic_add (& vnode -> usage_counter, -1);
    8274:	e2840018 	add	r0, r4, #24
    8278:	e3e01000 	mvn	r1, #0
    827c:	eb0004d5 	bl	95d8 <atomic_add>

    if (vnode -> usage_counter == 0)
    8280:	e5943018 	ldr	r3, [r4, #24]
    8284:	e3530000 	cmp	r3, #0
    8288:	0a000008 	beq	82b0 <vnode_destroy+0x80>

      kernel_free (vnode);
    }
    else
    {
      vnode -> destroy = true;
    828c:	e3a03001 	mov	r3, #1
      lock_release (& vnode_manager . vnode_list . lock);
    8290:	e59f0088 	ldr	r0, [pc, #136]	; 8320 <vnode_destroy+0xf0>

      kernel_free (vnode);
    }
    else
    {
      vnode -> destroy = true;
    8294:	e5c43014 	strb	r3, [r4, #20]
      lock_release (& vnode_manager . vnode_list . lock);
    8298:	eb001215 	bl	caf4 <lock_release>
      cpu_trap_restore(it_status);
    829c:	e1a00007 	mov	r0, r7
    82a0:	eb00064f 	bl	9be4 <cpu_trap_restore>
    }

    return DNA_OK;
    82a4:	e3a00000 	mov	r0, #0
  {
    lock_release (& vnode_manager . vnode_list . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    82a8:	e28dd00c 	add	sp, sp, #12
    82ac:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

    atomic_add (& vnode -> usage_counter, -1);

    if (vnode -> usage_counter == 0)
    {
      queue_extract (& vnode_manager . vnode_list, & vnode -> link);
    82b0:	e1a01004 	mov	r1, r4
    82b4:	e59f0064 	ldr	r0, [pc, #100]	; 8320 <vnode_destroy+0xf0>
    82b8:	eb000168 	bl	8860 <queue_extract>

      lock_release (& vnode_manager . vnode_list . lock);
    82bc:	e59f005c 	ldr	r0, [pc, #92]	; 8320 <vnode_destroy+0xf0>
    82c0:	eb00120b 	bl	caf4 <lock_release>
      cpu_trap_restore(it_status);
    82c4:	e1a00007 	mov	r0, r7
    82c8:	eb000645 	bl	9be4 <cpu_trap_restore>

      volume = vnode -> volume;
    82cc:	e5943010 	ldr	r3, [r4, #16]
      data = vnode -> data;

      status = volume -> cmd -> destroy_vnode (volume -> data, data);
    82d0:	e594101c 	ldr	r1, [r4, #28]
    82d4:	e5932020 	ldr	r2, [r3, #32]
    82d8:	e5930024 	ldr	r0, [r3, #36]	; 0x24
    82dc:	e5923010 	ldr	r3, [r2, #16]
    82e0:	e12fff33 	blx	r3
      ensure (status == DNA_OK, status);
    82e4:	e2505000 	subs	r5, r0, #0
    82e8:	11a00005 	movne	r0, r5
    82ec:	1affffed 	bne	82a8 <vnode_destroy+0x78>

      kernel_free (vnode);
    82f0:	e1a00004 	mov	r0, r4
    82f4:	eb001533 	bl	d7c8 <kernel_free>
      vnode -> destroy = true;
      lock_release (& vnode_manager . vnode_list . lock);
      cpu_trap_restore(it_status);
    }

    return DNA_OK;
    82f8:	e1a00005 	mov	r0, r5
  {
    lock_release (& vnode_manager . vnode_list . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    82fc:	e28dd00c 	add	sp, sp, #12
    8300:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    return DNA_OK;
  }

  rescue (invalid_vnode)
  {
    lock_release (& vnode_manager . vnode_list . lock);
    8304:	e59f0014 	ldr	r0, [pc, #20]	; 8320 <vnode_destroy+0xf0>
    8308:	eb0011f9 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    830c:	e1a00007 	mov	r0, r7
    8310:	eb000633 	bl	9be4 <cpu_trap_restore>
    leave;
    8314:	e59f000c 	ldr	r0, [pc, #12]	; 8328 <vnode_destroy+0xf8>
  }
}
    8318:	e28dd00c 	add	sp, sp, #12
    831c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    8320:	000355e8 	.word	0x000355e8
    8324:	0000767c 	.word	0x0000767c
    8328:	0000fefd 	.word	0x0000fefd

0000832c <vfs_umount>:
 * RESULT
 *
 * SOURCE
 */

{
    832c:	e92d4070 	push	{r4, r5, r6, lr}
  int64_t host_vnid = -1;
  volume_t host_volume = NULL, volume = NULL;
    8330:	e3a0c000 	mov	ip, #0
 *
 * SOURCE
 */

{
  int64_t host_vnid = -1;
    8334:	e3e04000 	mvn	r4, #0
    8338:	e3e05000 	mvn	r5, #0
 * RESULT
 *
 * SOURCE
 */

{
    833c:	e24dd018 	sub	sp, sp, #24
  {
    /*
     * Find the vnode corresponding to the path
     */

    status = vnode_walk (target, & host_volume, & host_vnid, & node_data);
    8340:	e28d300c 	add	r3, sp, #12
    8344:	e28d1008 	add	r1, sp, #8
    8348:	e28d2010 	add	r2, sp, #16
 *
 * SOURCE
 */

{
  int64_t host_vnid = -1;
    834c:	e1cd41f0 	strd	r4, [sp, #16]
  volume_t host_volume = NULL, volume = NULL;
    8350:	e58dc008 	str	ip, [sp, #8]
  vnode_t vnode = NULL;
  void * node_data = NULL;
    8354:	e58dc00c 	str	ip, [sp, #12]
  {
    /*
     * Find the vnode corresponding to the path
     */

    status = vnode_walk (target, & host_volume, & host_vnid, & node_data);
    8358:	eb00006e 	bl	8518 <vnode_walk>
    ensure (status == DNA_OK || status == DNA_NO_VOLUME, status);
    835c:	e59f30c4 	ldr	r3, [pc, #196]	; 8428 <vfs_umount+0xfc>
    8360:	e1500003 	cmp	r0, r3
    8364:	13500000 	cmpne	r0, #0
    8368:	1a000007 	bne	838c <vfs_umount+0x60>
    ensure (host_volume != NULL && host_vnid != -1, DNA_NO_VNODE);
    836c:	e59d3008 	ldr	r3, [sp, #8]
    8370:	e3530000 	cmp	r3, #0
    8374:	0a000003 	beq	8388 <vfs_umount+0x5c>
    8378:	e1cd21d0 	ldrd	r2, [sp, #16]
    837c:	e1530005 	cmp	r3, r5
    8380:	01520004 	cmpeq	r2, r4
    8384:	1a000002 	bne	8394 <vfs_umount+0x68>
    8388:	e59f009c 	ldr	r0, [pc, #156]	; 842c <vfs_umount+0x100>
     * Destroy the volume
     */

    return volume_destroy (volume);
  }
}
    838c:	e28dd018 	add	sp, sp, #24
    8390:	e8bd8070 	pop	{r4, r5, r6, pc}

    /*
     * Check if something is mounted on this node
     */

    it_status = cpu_trap_mask_and_backup();
    8394:	eb0005d9 	bl	9b00 <cpu_trap_mask_and_backup>
    8398:	e1a06000 	mov	r6, r0
    lock_acquire (& volume_manager . volume_list . lock);
    839c:	e59f008c 	ldr	r0, [pc, #140]	; 8430 <vfs_umount+0x104>
    83a0:	eb000722 	bl	a030 <lock_acquire>

    volume = queue_lookup (& volume_manager . volume_list,
    83a4:	e1cd41d0 	ldrd	r4, [sp, #16]
    83a8:	e59d2008 	ldr	r2, [sp, #8]
    83ac:	e59f1080 	ldr	r1, [pc, #128]	; 8434 <vfs_umount+0x108>
    83b0:	e1cd40f0 	strd	r4, [sp]
    83b4:	e59f0074 	ldr	r0, [pc, #116]	; 8430 <vfs_umount+0x104>
    83b8:	eb000468 	bl	9560 <queue_lookup>
    83bc:	e1a04000 	mov	r4, r0
        volume_host_inspector, host_volume, host_vnid);

    lock_release (& volume_manager . volume_list . lock);
    83c0:	e59f0068 	ldr	r0, [pc, #104]	; 8430 <vfs_umount+0x104>
    83c4:	eb0011ca 	bl	caf4 <lock_release>
    cpu_trap_restore (it_status);
    83c8:	e1a00006 	mov	r0, r6
    83cc:	eb000604 	bl	9be4 <cpu_trap_restore>

    ensure (volume != NULL, DNA_ERROR);
    83d0:	e3540000 	cmp	r4, #0
    83d4:	059f005c 	ldreq	r0, [pc, #92]	; 8438 <vfs_umount+0x10c>
    83d8:	0affffeb 	beq	838c <vfs_umount+0x60>

    /*
     * Check if the volume is being used
     */

    it_status = cpu_trap_mask_and_backup();
    83dc:	eb0005c7 	bl	9b00 <cpu_trap_mask_and_backup>
    83e0:	e1a05000 	mov	r5, r0
    lock_acquire (& vnode_manager . vnode_list . lock);
    83e4:	e59f0050 	ldr	r0, [pc, #80]	; 843c <vfs_umount+0x110>
    83e8:	eb000710 	bl	a030 <lock_acquire>

    vnode = queue_lookup (& vnode_manager . vnode_list,
    83ec:	e59f104c 	ldr	r1, [pc, #76]	; 8440 <vfs_umount+0x114>
    83f0:	e1a02004 	mov	r2, r4
    83f4:	e59f0040 	ldr	r0, [pc, #64]	; 843c <vfs_umount+0x110>
    83f8:	eb000458 	bl	9560 <queue_lookup>
    83fc:	e1a06000 	mov	r6, r0
        vnode_volume_inspector, volume);

    lock_release (& vnode_manager . vnode_list . lock);
    8400:	e59f0034 	ldr	r0, [pc, #52]	; 843c <vfs_umount+0x110>
    8404:	eb0011ba 	bl	caf4 <lock_release>
    cpu_trap_restore (it_status);
    8408:	e1a00005 	mov	r0, r5
    840c:	eb0005f4 	bl	9be4 <cpu_trap_restore>

    ensure (vnode != NULL, DNA_VOLUME_IN_USE);
    8410:	e3560000 	cmp	r6, #0
    8414:	059f0028 	ldreq	r0, [pc, #40]	; 8444 <vfs_umount+0x118>
    8418:	0affffdb 	beq	838c <vfs_umount+0x60>

    /*
     * Destroy the volume
     */

    return volume_destroy (volume);
    841c:	e1a00004 	mov	r0, r4
    8420:	ebfff98c 	bl	6a58 <volume_destroy>
    8424:	eaffffd8 	b	838c <vfs_umount+0x60>
    8428:	0000fefe 	.word	0x0000fefe
    842c:	0000fefd 	.word	0x0000fefd
    8430:	00035600 	.word	0x00035600
    8434:	0000714c 	.word	0x0000714c
    8438:	0000ffff 	.word	0x0000ffff
    843c:	000355e8 	.word	0x000355e8
    8440:	00006a30 	.word	0x00006a30
    8444:	0000fef5 	.word	0x0000fef5

00008448 <vfs_mkdir>:
 */

{
  status_t status = DNA_OK;
  int64_t vnid = -1;
  volume_t volume = NULL;
    8448:	e3a0c000 	mov	ip, #0
 * SOURCE
 */

{
  status_t status = DNA_OK;
  int64_t vnid = -1;
    844c:	e3e02000 	mvn	r2, #0
    8450:	e3e03000 	mvn	r3, #0
 * * DNA_OK if the operation succeeded.
 *
 * SOURCE
 */

{
    8454:	e92d4030 	push	{r4, r5, lr}
    8458:	e24dde51 	sub	sp, sp, #1296	; 0x510
    845c:	e24dd004 	sub	sp, sp, #4
  status_t status = DNA_OK;
  int64_t vnid = -1;
    8460:	e59f40a8 	ldr	r4, [pc, #168]	; 8510 <vfs_mkdir+0xc8>
  void * data = NULL;
  char buffer[DNA_PATH_LENGTH], token[DNA_FILENAME_LENGTH];

  watch (status_t)
  {
    ensure (path != NULL, DNA_ERROR);
    8464:	e3500000 	cmp	r0, #0
 * * DNA_OK if the operation succeeded.
 *
 * SOURCE
 */

{
    8468:	e1a05001 	mov	r5, r1
  status_t status = DNA_OK;
  int64_t vnid = -1;
    846c:	e28d1e51 	add	r1, sp, #1296	; 0x510
    8470:	e18120f4 	strd	r2, [r1, r4]
  volume_t volume = NULL;
    8474:	e58dc000 	str	ip, [sp]
  void * data = NULL;
    8478:	e58dc004 	str	ip, [sp, #4]
  char buffer[DNA_PATH_LENGTH], token[DNA_FILENAME_LENGTH];

  watch (status_t)
  {
    ensure (path != NULL, DNA_ERROR);
    847c:	059f0090 	ldreq	r0, [pc, #144]	; 8514 <vfs_mkdir+0xcc>
    8480:	0a000007 	beq	84a4 <vfs_mkdir+0x5c>

    dna_strcpy (buffer, path);
    8484:	e1a01000 	mov	r1, r0
    8488:	e28d0e11 	add	r0, sp, #272	; 0x110
    848c:	eb000495 	bl	96e8 <dna_strcpy>

    status = path_split (buffer, token);
    8490:	e28d0e11 	add	r0, sp, #272	; 0x110
    8494:	e28d1010 	add	r1, sp, #16
    8498:	eb000466 	bl	9638 <path_split>
    ensure (status == DNA_OK, status);
    849c:	e3500000 	cmp	r0, #0
    84a0:	0a000002 	beq	84b0 <vfs_mkdir+0x68>
    status = vnode_put (volume -> id, vnid);
    ensure (status == DNA_OK, status);

    return DNA_OK;
  }
}
    84a4:	e28dde51 	add	sp, sp, #1296	; 0x510
    84a8:	e28dd004 	add	sp, sp, #4
    84ac:	e8bd8030 	pop	{r4, r5, pc}
    dna_strcpy (buffer, path);

    status = path_split (buffer, token);
    ensure (status == DNA_OK, status);

    status = vnode_walk (buffer, & volume, & vnid, & data);
    84b0:	e28d3010 	add	r3, sp, #16
    84b4:	e28d0e11 	add	r0, sp, #272	; 0x110
    84b8:	e1a0100d 	mov	r1, sp
    84bc:	e28d2008 	add	r2, sp, #8
    84c0:	e243300c 	sub	r3, r3, #12
    84c4:	eb000013 	bl	8518 <vnode_walk>
    ensure (status == DNA_OK, status);
    84c8:	e3500000 	cmp	r0, #0
    84cc:	1afffff4 	bne	84a4 <vfs_mkdir+0x5c>

    status = volume -> cmd -> mkdir (volume -> data, data, token, mode);
    84d0:	e59d1000 	ldr	r1, [sp]
    84d4:	e28d2010 	add	r2, sp, #16
    84d8:	e5910020 	ldr	r0, [r1, #32]
    84dc:	e1a03005 	mov	r3, r5
    84e0:	e590c034 	ldr	ip, [r0, #52]	; 0x34
    84e4:	e5910024 	ldr	r0, [r1, #36]	; 0x24
    84e8:	e59d1004 	ldr	r1, [sp, #4]
    84ec:	e12fff3c 	blx	ip
    ensure (status == DNA_OK, status);
    84f0:	e3500000 	cmp	r0, #0
    84f4:	1affffea 	bne	84a4 <vfs_mkdir+0x5c>

    status = vnode_put (volume -> id, vnid);
    84f8:	e59d1000 	ldr	r1, [sp]
    84fc:	e28dce51 	add	ip, sp, #1296	; 0x510
    8500:	e18c20d4 	ldrd	r2, [ip, r4]
    8504:	e5910004 	ldr	r0, [r1, #4]
    8508:	ebfff965 	bl	6aa4 <vnode_put>
    850c:	eaffffe4 	b	84a4 <vfs_mkdir+0x5c>
    8510:	fffffaf8 	.word	0xfffffaf8
    8514:	0000ffff 	.word	0x0000ffff

00008518 <vnode_walk>:
 * * DNA_NO_VOLUME if no root volume is present.
 *
 * SOURCE
 */

{
    8518:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    851c:	e1a07000 	mov	r7, r0
  bool keep_walking = false;
  int64_t vnid = -1, new_vnid = -1;
  void * data = NULL;
    8520:	e3a0e000 	mov	lr, #0
 * SOURCE
 */

{
  bool keep_walking = false;
  int64_t vnid = -1, new_vnid = -1;
    8524:	e3e04000 	mvn	r4, #0
    8528:	e3e05000 	mvn	r5, #0
 * * DNA_NO_VOLUME if no root volume is present.
 *
 * SOURCE
 */

{
    852c:	e24dde53 	sub	sp, sp, #1328	; 0x530
    8530:	e24dd00c 	sub	sp, sp, #12
  bool keep_walking = false;
  int64_t vnid = -1, new_vnid = -1;
  void * data = NULL;
  volume_t volume = NULL, new_volume = NULL;
  char token[DNA_FILENAME_LENGTH], buffer[DNA_PATH_LENGTH];
  char * path_ptr = buffer;
    8534:	e28dcf4e 	add	ip, sp, #312	; 0x138
 * SOURCE
 */

{
  bool keep_walking = false;
  int64_t vnid = -1, new_vnid = -1;
    8538:	e59f62c0 	ldr	r6, [pc, #704]	; 8800 <vnode_walk+0x2e8>
 * * DNA_NO_VOLUME if no root volume is present.
 *
 * SOURCE
 */

{
    853c:	e1a08002 	mov	r8, r2
  bool keep_walking = false;
  int64_t vnid = -1, new_vnid = -1;
    8540:	e28d2e53 	add	r2, sp, #1328	; 0x530
    8544:	e2822008 	add	r2, r2, #8
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    dna_strcpy (buffer, path);
    8548:	e1a0000c 	mov	r0, ip
 * * DNA_NO_VOLUME if no root volume is present.
 *
 * SOURCE
 */

{
    854c:	e1a09001 	mov	r9, r1
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    dna_strcpy (buffer, path);
    8550:	e1a01007 	mov	r1, r7
 * SOURCE
 */

{
  bool keep_walking = false;
  int64_t vnid = -1, new_vnid = -1;
    8554:	e18240f6 	strd	r4, [r2, r6]
 * * DNA_NO_VOLUME if no root volume is present.
 *
 * SOURCE
 */

{
    8558:	e1a07003 	mov	r7, r3
  bool keep_walking = false;
  int64_t vnid = -1, new_vnid = -1;
  void * data = NULL;
    855c:	e58de028 	str	lr, [sp, #40]	; 0x28
  volume_t volume = NULL, new_volume = NULL;
  char token[DNA_FILENAME_LENGTH], buffer[DNA_PATH_LENGTH];
  char * path_ptr = buffer;
    8560:	e58dc02c 	str	ip, [sp, #44]	; 0x2c
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    dna_strcpy (buffer, path);
    8564:	eb00045f 	bl	96e8 <dna_strcpy>

    /*
     * First we need to load the root volume
     */
    
    status = path_get_next_entry (& path_ptr, token);
    8568:	e28d002c 	add	r0, sp, #44	; 0x2c
    856c:	e28d1038 	add	r1, sp, #56	; 0x38
    8570:	eb000116 	bl	89d0 <path_get_next_entry>
    ensure (status == DNA_OK, status);
    8574:	e3500000 	cmp	r0, #0
    8578:	0a000002 	beq	8588 <vnode_walk+0x70>
    *p_vnid = vnid;
    *p_data = data;

    return DNA_OK;
  }
}
    857c:	e28dde53 	add	sp, sp, #1328	; 0x530
    8580:	e28dd00c 	add	sp, sp, #12
    8584:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
     * First we need to load the root volume
     */
    
    status = path_get_next_entry (& path_ptr, token);
    ensure (status == DNA_OK, status);
    ensure (dna_strlen (token) == 0, DNA_ERROR);
    8588:	e28d0038 	add	r0, sp, #56	; 0x38
    858c:	eb000420 	bl	9614 <dna_strlen>
    8590:	e250a000 	subs	sl, r0, #0
    8594:	0a000003 	beq	85a8 <vnode_walk+0x90>
    8598:	e59f0264 	ldr	r0, [pc, #612]	; 8804 <vnode_walk+0x2ec>
    *p_vnid = vnid;
    *p_data = data;

    return DNA_OK;
  }
}
    859c:	e28dde53 	add	sp, sp, #1328	; 0x530
    85a0:	e28dd00c 	add	sp, sp, #12
    85a4:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    
    status = path_get_next_entry (& path_ptr, token);
    ensure (status == DNA_OK, status);
    ensure (dna_strlen (token) == 0, DNA_ERROR);

    it_status = cpu_trap_mask_and_backup();
    85a8:	eb000554 	bl	9b00 <cpu_trap_mask_and_backup>
    85ac:	e1a0b000 	mov	fp, r0
    lock_acquire (& volume_manager . volume_list . lock);
    85b0:	e59f0250 	ldr	r0, [pc, #592]	; 8808 <vnode_walk+0x2f0>
    85b4:	eb00069d 	bl	a030 <lock_acquire>

    new_volume = queue_lookup (& volume_manager . volume_list,
    85b8:	e1a0200a 	mov	r2, sl
    85bc:	e59f1248 	ldr	r1, [pc, #584]	; 880c <vnode_walk+0x2f4>
    85c0:	e1cd40f0 	strd	r4, [sp]
    85c4:	e59f023c 	ldr	r0, [pc, #572]	; 8808 <vnode_walk+0x2f0>
    85c8:	eb0003e4 	bl	9560 <queue_lookup>
    85cc:	e1a0a000 	mov	sl, r0
        volume_host_inspector, volume, vnid);

    lock_release (& volume_manager . volume_list . lock);
    85d0:	e59f0230 	ldr	r0, [pc, #560]	; 8808 <vnode_walk+0x2f0>
    85d4:	eb001146 	bl	caf4 <lock_release>
    cpu_trap_restore (it_status);
    85d8:	e1a0000b 	mov	r0, fp
    85dc:	eb000580 	bl	9be4 <cpu_trap_restore>

    ensure (new_volume != NULL, DNA_NO_VOLUME);
    85e0:	e35a0000 	cmp	sl, #0
    85e4:	059f0224 	ldreq	r0, [pc, #548]	; 8810 <vnode_walk+0x2f8>
    85e8:	0affffe3 	beq	857c <vnode_walk+0x64>

    volume = new_volume;
    vnid = new_volume -> root_vnid;
    85ec:	e1ca40d8 	ldrd	r4, [sl, #8]

    status = vnode_get (volume -> id, vnid, & data);
    85f0:	e28d3028 	add	r3, sp, #40	; 0x28
    85f4:	e59a0004 	ldr	r0, [sl, #4]
    85f8:	e1a02004 	mov	r2, r4
    85fc:	e58d3000 	str	r3, [sp]
    8600:	e1a03005 	mov	r3, r5
    8604:	ebfff96c 	bl	6bbc <vnode_get>
    ensure (status == DNA_OK, status);
    8608:	e3500000 	cmp	r0, #0
    860c:	028db030 	addeq	fp, sp, #48	; 0x30
    8610:	1affffd9 	bne	857c <vnode_walk+0x64>

    /*
     * Then, we iteratively analyze the path.
     */

    while ((status = path_get_next_entry (& path_ptr, token)) == DNA_OK)
    8614:	e28d002c 	add	r0, sp, #44	; 0x2c
    8618:	e28d1038 	add	r1, sp, #56	; 0x38
    861c:	eb0000eb 	bl	89d0 <path_get_next_entry>
    8620:	e3500000 	cmp	r0, #0
    8624:	1a00005f 	bne	87a8 <vnode_walk+0x290>

        /*
         * Walk the current token on the current vnode.
         */

        status = volume -> cmd -> walk
    8628:	e59a3020 	ldr	r3, [sl, #32]
    862c:	e59a0024 	ldr	r0, [sl, #36]	; 0x24
    8630:	e58db000 	str	fp, [sp]
    8634:	e593c000 	ldr	ip, [r3]
    8638:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
    863c:	e3a03000 	mov	r3, #0
    8640:	e28d2038 	add	r2, sp, #56	; 0x38
    8644:	e12fff3c 	blx	ip
          (volume -> data, data, token, NULL, & new_vnid);
        ensure (status == DNA_ALREADY_AT_ROOT || status == DNA_OK, DNA_ERROR);
    8648:	e3c03002 	bic	r3, r0, #2
    864c:	e6ff3073 	uxth	r3, r3
    8650:	e3530000 	cmp	r3, #0
    8654:	1affffcf 	bne	8598 <vnode_walk+0x80>
        /*
        * If the walk is stuck to the volume's root directory,
        * we try to move one stage upward.
        */

        if (status == DNA_ALREADY_AT_ROOT)
    8658:	e3500002 	cmp	r0, #2
    865c:	1a000016 	bne	86bc <vnode_walk+0x1a4>
           *
           * Then we check if the volume has a host. In such a case, we
           * move one stage upward.
           */

          if (volume -> host_volume != NULL)
    8660:	e59a3014 	ldr	r3, [sl, #20]
        * we try to move one stage upward.
        */

        if (status == DNA_ALREADY_AT_ROOT)
        {
          new_vnid = vnid;
    8664:	e28d0e53 	add	r0, sp, #1328	; 0x530
    8668:	e2800008 	add	r0, r0, #8
           *
           * Then we check if the volume has a host. In such a case, we
           * move one stage upward.
           */

          if (volume -> host_volume != NULL)
    866c:	e3530000 	cmp	r3, #0
        * we try to move one stage upward.
        */

        if (status == DNA_ALREADY_AT_ROOT)
        {
          new_vnid = vnid;
    8670:	e18040f6 	strd	r4, [r0, r6]
           *
           * Then we check if the volume has a host. In such a case, we
           * move one stage upward.
           */

          if (volume -> host_volume != NULL)
    8674:	0affffe6 	beq	8614 <vnode_walk+0xfc>
          {
            keep_walking = true;

            status = vnode_put (volume -> id, new_vnid);
    8678:	e1a02004 	mov	r2, r4
    867c:	e1a03005 	mov	r3, r5
    8680:	e59a0004 	ldr	r0, [sl, #4]
    8684:	ebfff906 	bl	6aa4 <vnode_put>
            ensure (status == DNA_OK, status);
    8688:	e3500000 	cmp	r0, #0
    868c:	1affffba 	bne	857c <vnode_walk+0x64>

            vnid = volume -> host_vnid;
    8690:	e1ca41d8 	ldrd	r4, [sl, #24]
            volume = volume -> host_volume;
    8694:	e59aa014 	ldr	sl, [sl, #20]

            status = vnode_get (volume -> id, vnid, & data);
    8698:	e28d1028 	add	r1, sp, #40	; 0x28
    869c:	e59a0004 	ldr	r0, [sl, #4]
    86a0:	e1a02004 	mov	r2, r4
    86a4:	e1a03005 	mov	r3, r5
    86a8:	e58d1000 	str	r1, [sp]
    86ac:	ebfff942 	bl	6bbc <vnode_get>
            ensure (status == DNA_OK, status);
    86b0:	e3500000 	cmp	r0, #0
    86b4:	0affffdb 	beq	8628 <vnode_walk+0x110>
    86b8:	eaffffaf 	b	857c <vnode_walk+0x64>
      /*
       * Do we need to update the node ? If yes, put back
       * the old one, look for a vname and load the new one.
       */

      if (vnid != new_vnid)
    86bc:	e28d1e53 	add	r1, sp, #1328	; 0x530
    86c0:	e1cd42f0 	strd	r4, [sp, #32]
    86c4:	e1cd22d0 	ldrd	r2, [sp, #32]
    86c8:	e2811008 	add	r1, r1, #8
    86cc:	e18140d6 	ldrd	r4, [r1, r6]
    86d0:	e1530005 	cmp	r3, r5
    86d4:	01520004 	cmpeq	r2, r4
    86d8:	e59f3120 	ldr	r3, [pc, #288]	; 8800 <vnode_walk+0x2e8>
    86dc:	0affffcc 	beq	8614 <vnode_walk+0xfc>
      {
        it_status = cpu_trap_mask_and_backup();
    86e0:	e58d300c 	str	r3, [sp, #12]
    86e4:	eb000505 	bl	9b00 <cpu_trap_mask_and_backup>
    86e8:	e1a0c000 	mov	ip, r0
        lock_acquire (& volume_manager . volume_list . lock);
    86ec:	e59f0114 	ldr	r0, [pc, #276]	; 8808 <vnode_walk+0x2f0>
    86f0:	e58dc014 	str	ip, [sp, #20]

        new_volume = queue_lookup (& volume_manager . volume_list,
    86f4:	e28d5e53 	add	r5, sp, #1328	; 0x530
       */

      if (vnid != new_vnid)
      {
        it_status = cpu_trap_mask_and_backup();
        lock_acquire (& volume_manager . volume_list . lock);
    86f8:	eb00064c 	bl	a030 <lock_acquire>

        new_volume = queue_lookup (& volume_manager . volume_list,
    86fc:	e59d300c 	ldr	r3, [sp, #12]
    8700:	e2855008 	add	r5, r5, #8
    8704:	e18540d3 	ldrd	r4, [r5, r3]
    8708:	e1a0200a 	mov	r2, sl
    870c:	e59f10f8 	ldr	r1, [pc, #248]	; 880c <vnode_walk+0x2f4>
    8710:	e59f00f0 	ldr	r0, [pc, #240]	; 8808 <vnode_walk+0x2f0>
    8714:	e1cd40f0 	strd	r4, [sp]
    8718:	eb000390 	bl	9560 <queue_lookup>
    871c:	e1a01000 	mov	r1, r0
            volume_host_inspector, volume, new_vnid);

        lock_release (& volume_manager . volume_list . lock);
    8720:	e59f00e0 	ldr	r0, [pc, #224]	; 8808 <vnode_walk+0x2f0>
    8724:	e58d1010 	str	r1, [sp, #16]
    8728:	eb0010f1 	bl	caf4 <lock_release>
        cpu_trap_restore (it_status);
    872c:	e59dc014 	ldr	ip, [sp, #20]
    8730:	e1a0000c 	mov	r0, ip
    8734:	eb00052a 	bl	9be4 <cpu_trap_restore>

        if (new_volume != NULL)
    8738:	e59d1010 	ldr	r1, [sp, #16]
    873c:	e59d300c 	ldr	r3, [sp, #12]
    8740:	e3510000 	cmp	r1, #0
    8744:	0a00001d 	beq	87c0 <vnode_walk+0x2a8>
        {
          new_vnid = new_volume -> root_vnid;
    8748:	e1c140d8 	ldrd	r4, [r1, #8]

          status = vnode_get (new_volume -> id, new_vnid, & data);
    874c:	e28d0028 	add	r0, sp, #40	; 0x28
        lock_release (& volume_manager . volume_list . lock);
        cpu_trap_restore (it_status);

        if (new_volume != NULL)
        {
          new_vnid = new_volume -> root_vnid;
    8750:	e28d2e53 	add	r2, sp, #1328	; 0x530

          status = vnode_get (new_volume -> id, new_vnid, & data);
    8754:	e58d0000 	str	r0, [sp]
        lock_release (& volume_manager . volume_list . lock);
        cpu_trap_restore (it_status);

        if (new_volume != NULL)
        {
          new_vnid = new_volume -> root_vnid;
    8758:	e2822008 	add	r2, r2, #8

          status = vnode_get (new_volume -> id, new_vnid, & data);
    875c:	e5910004 	ldr	r0, [r1, #4]
        lock_release (& volume_manager . volume_list . lock);
        cpu_trap_restore (it_status);

        if (new_volume != NULL)
        {
          new_vnid = new_volume -> root_vnid;
    8760:	e18240f3 	strd	r4, [r2, r3]

          status = vnode_get (new_volume -> id, new_vnid, & data);
    8764:	e1a02004 	mov	r2, r4
    8768:	e1a03005 	mov	r3, r5
    876c:	e58d1010 	str	r1, [sp, #16]
    8770:	ebfff911 	bl	6bbc <vnode_get>
          ensure (status == DNA_OK, status);
    8774:	e3500000 	cmp	r0, #0
    8778:	1affff7f 	bne	857c <vnode_walk+0x64>

          status = vnode_put (volume -> id, vnid);
    877c:	e1cd22d0 	ldrd	r2, [sp, #32]
    8780:	e59a0004 	ldr	r0, [sl, #4]
    8784:	ebfff8c6 	bl	6aa4 <vnode_put>
          ensure (status == DNA_OK, status);
    8788:	e3500000 	cmp	r0, #0
    878c:	e59d1010 	ldr	r1, [sp, #16]
    8790:	1affff79 	bne	857c <vnode_walk+0x64>

          status = vnode_put (volume -> id, vnid);
          ensure (status == DNA_OK, status);
        }

        vnid = new_vnid;
    8794:	e28d0e53 	add	r0, sp, #1328	; 0x530
    8798:	e2800008 	add	r0, r0, #8
    879c:	e18040d6 	ldrd	r4, [r0, r6]
    87a0:	e1a0a001 	mov	sl, r1
    87a4:	eaffff9a 	b	8614 <vnode_walk+0xfc>
     * Assign the results into the arguments, and return.
     */

    *p_volume = volume;
    *p_vnid = vnid;
    *p_data = data;
    87a8:	e59d3028 	ldr	r3, [sp, #40]	; 0x28

    /*
     * Assign the results into the arguments, and return.
     */

    *p_volume = volume;
    87ac:	e589a000 	str	sl, [r9]
    *p_vnid = vnid;
    *p_data = data;

    return DNA_OK;
    87b0:	e3a00000 	mov	r0, #0
    /*
     * Assign the results into the arguments, and return.
     */

    *p_volume = volume;
    *p_vnid = vnid;
    87b4:	e1c840f0 	strd	r4, [r8]
    *p_data = data;
    87b8:	e5873000 	str	r3, [r7]

    return DNA_OK;
    87bc:	eaffff6e 	b	857c <vnode_walk+0x64>

          volume = new_volume;
        }
        else
        {
          status = vnode_get (volume -> id, new_vnid, & data);
    87c0:	e28d4028 	add	r4, sp, #40	; 0x28
    87c4:	e28d5e53 	add	r5, sp, #1328	; 0x530
    87c8:	e58d4000 	str	r4, [sp]
    87cc:	e2855008 	add	r5, r5, #8
    87d0:	e59a0004 	ldr	r0, [sl, #4]
    87d4:	e18320d5 	ldrd	r2, [r3, r5]
    87d8:	ebfff8f7 	bl	6bbc <vnode_get>
          ensure (status == DNA_OK, status);
    87dc:	e3500000 	cmp	r0, #0
    87e0:	1affff65 	bne	857c <vnode_walk+0x64>

          status = vnode_put (volume -> id, vnid);
    87e4:	e1cd22d0 	ldrd	r2, [sp, #32]
    87e8:	e59a0004 	ldr	r0, [sl, #4]
    87ec:	ebfff8ac 	bl	6aa4 <vnode_put>
          ensure (status == DNA_OK, status);
    87f0:	e3500000 	cmp	r0, #0
    87f4:	1affff60 	bne	857c <vnode_walk+0x64>
    87f8:	e1a0100a 	mov	r1, sl
    87fc:	eaffffe4 	b	8794 <vnode_walk+0x27c>
    8800:	fffffaf8 	.word	0xfffffaf8
    8804:	0000ffff 	.word	0x0000ffff
    8808:	00035600 	.word	0x00035600
    880c:	0000714c 	.word	0x0000714c
    8810:	0000fefe 	.word	0x0000fefe

00008814 <dna_log2>:

  register uint32_t r = 0;

  for (int32_t i = 4; i >= 0; i -= 1)
  {
    if (value & b[i])
    8814:	e1a02820 	lsr	r2, r0, #16
    8818:	e1a01802 	lsl	r1, r2, #16
    {
      value >>= S[i];
    881c:	e3510000 	cmp	r1, #0

#include <stdint.h>
#include <DnaTools/DnaTools.h>

uint32_t dna_log2 (uint32_t value)
{
    8820:	e1a03000 	mov	r3, r0

  for (int32_t i = 4; i >= 0; i -= 1)
  {
    if (value & b[i])
    {
      value >>= S[i];
    8824:	11a03002 	movne	r3, r2
    8828:	03a00000 	moveq	r0, #0
    882c:	13a00010 	movne	r0, #16

  register uint32_t r = 0;

  for (int32_t i = 4; i >= 0; i -= 1)
  {
    if (value & b[i])
    8830:	e3130cff 	tst	r3, #65280	; 0xff00
    {
      value >>= S[i];
    8834:	11a03423 	lsrne	r3, r3, #8
      r |= S[i];
    8838:	13800008 	orrne	r0, r0, #8

  register uint32_t r = 0;

  for (int32_t i = 4; i >= 0; i -= 1)
  {
    if (value & b[i])
    883c:	e31300f0 	tst	r3, #240	; 0xf0
    {
      value >>= S[i];
    8840:	11a03223 	lsrne	r3, r3, #4
      r |= S[i];
    8844:	13800004 	orrne	r0, r0, #4

  register uint32_t r = 0;

  for (int32_t i = 4; i >= 0; i -= 1)
  {
    if (value & b[i])
    8848:	e313000c 	tst	r3, #12
    {
      value >>= S[i];
    884c:	11a03123 	lsrne	r3, r3, #2
      r |= S[i];
    8850:	13800002 	orrne	r0, r0, #2

  register uint32_t r = 0;

  for (int32_t i = 4; i >= 0; i -= 1)
  {
    if (value & b[i])
    8854:	e3130002 	tst	r3, #2
    {
      value >>= S[i];
      r |= S[i];
    8858:	13800001 	orrne	r0, r0, #1
    }
  }

  return r;
}
    885c:	e12fff1e 	bx	lr

00008860 <queue_extract>:

#include <DnaTools/DnaTools.h>
#include <Processor/Cache.h>

status_t queue_extract (queue_t * queue, void * data)
{
    8860:	e92d4070 	push	{r4, r5, r6, lr}
  queue_link_t * item = data;
  queue_link_t * kitem = queue -> head;

  watch (status_t)
  {
    ensure (queue != NULL && data != NULL, DNA_BAD_ARGUMENT);
    8864:	e2516000 	subs	r6, r1, #0

#include <DnaTools/DnaTools.h>
#include <Processor/Cache.h>

status_t queue_extract (queue_t * queue, void * data)
{
    8868:	e1a04000 	mov	r4, r0
  queue_link_t * item = data;
  queue_link_t * kitem = queue -> head;
    886c:	e5905004 	ldr	r5, [r0, #4]

  watch (status_t)
  {
    ensure (queue != NULL && data != NULL, DNA_BAD_ARGUMENT);
    8870:	1a000001 	bne	887c <queue_extract+0x1c>
    8874:	e59f009c 	ldr	r0, [pc, #156]	; 8918 <queue_extract+0xb8>
    8878:	e8bd8070 	pop	{r4, r5, r6, pc}
    cpu_dcache_invalidate((void*)(&queue->status),sizeof(uint32_t));
    887c:	e280000c 	add	r0, r0, #12
    8880:	e3a01004 	mov	r1, #4
    8884:	eb000509 	bl	9cb0 <cpu_dcache_invalidate>
    ensure (queue -> status != 0, DNA_ERROR);
    8888:	e594300c 	ldr	r3, [r4, #12]
    888c:	e3530000 	cmp	r3, #0
    8890:	1a000001 	bne	889c <queue_extract+0x3c>
    8894:	e59f0080 	ldr	r0, [pc, #128]	; 891c <queue_extract+0xbc>
    8898:	e8bd8070 	pop	{r4, r5, r6, pc}

    if (queue -> head == item)
    889c:	e5943004 	ldr	r3, [r4, #4]
    88a0:	e1560003 	cmp	r6, r3
    88a4:	0a000016 	beq	8904 <queue_extract+0xa4>
    {
      queue -> head = item -> next;
    }
    else    
    {
      cpu_dcache_invalidate((void*)kitem, sizeof(struct _queue_link*));
    88a8:	e1a00005 	mov	r0, r5
    88ac:	e3a01004 	mov	r1, #4
    88b0:	eb0004fe 	bl	9cb0 <cpu_dcache_invalidate>
      cpu_dcache_invalidate((void*)kitem->next, sizeof(struct _queue_link*));
    88b4:	e5950000 	ldr	r0, [r5]
    88b8:	e3a01004 	mov	r1, #4
    88bc:	eb0004fb 	bl	9cb0 <cpu_dcache_invalidate>
      while (kitem -> next != item && kitem -> next != NULL)
    88c0:	ea000002 	b	88d0 <queue_extract+0x70>
    88c4:	e3530000 	cmp	r3, #0
    88c8:	0afffff1 	beq	8894 <queue_extract+0x34>
    88cc:	e1a05003 	mov	r5, r3
    88d0:	e5953000 	ldr	r3, [r5]
    88d4:	e1560003 	cmp	r6, r3
    88d8:	1afffff9 	bne	88c4 <queue_extract+0x64>
        kitem = kitem -> next;
      }

      ensure (kitem -> next == item, DNA_ERROR);

      kitem -> next = item -> next;
    88dc:	e5963000 	ldr	r3, [r6]

      if (kitem -> next == NULL)
    88e0:	e3530000 	cmp	r3, #0
        kitem = kitem -> next;
      }

      ensure (kitem -> next == item, DNA_ERROR);

      kitem -> next = item -> next;
    88e4:	e5853000 	str	r3, [r5]

      if (kitem -> next == NULL)
    88e8:	0a000008 	beq	8910 <queue_extract+0xb0>
      {
        queue -> tail = kitem;
      }
    }

    item -> next = NULL;
    88ec:	e3a00000 	mov	r0, #0
    queue -> status -= 1;
    88f0:	e594300c 	ldr	r3, [r4, #12]
      {
        queue -> tail = kitem;
      }
    }

    item -> next = NULL;
    88f4:	e5860000 	str	r0, [r6]
    queue -> status -= 1;
    88f8:	e2433001 	sub	r3, r3, #1
    88fc:	e584300c 	str	r3, [r4, #12]

    return DNA_OK;
    8900:	e8bd8070 	pop	{r4, r5, r6, pc}
    cpu_dcache_invalidate((void*)(&queue->status),sizeof(uint32_t));
    ensure (queue -> status != 0, DNA_ERROR);

    if (queue -> head == item)
    {
      queue -> head = item -> next;
    8904:	e5963000 	ldr	r3, [r6]
    8908:	e5843004 	str	r3, [r4, #4]
    890c:	eafffff6 	b	88ec <queue_extract+0x8c>

      kitem -> next = item -> next;

      if (kitem -> next == NULL)
      {
        queue -> tail = kitem;
    8910:	e5845008 	str	r5, [r4, #8]
    8914:	eafffff4 	b	88ec <queue_extract+0x8c>
    8918:	0000fffc 	.word	0x0000fffc
    891c:	0000ffff 	.word	0x0000ffff

00008920 <dna_strncmp>:

#include <stdint.h>
#include <DnaTools/DnaTools.h>

int32_t dna_strncmp (const char *s1, const char *s2, size_t n)
{
    8920:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
  char *s1_ptr = (char *)s1, *s2_ptr = (char *)s2;
  size_t i = 0;
    8924:	e3a03000 	mov	r3, #0
    8928:	ea000003 	b	893c <dna_strncmp+0x1c>
      return -1;
    }
       i++;
  }
  while ( (*s2_ptr++ != '\0') &&
             (i < n));
    892c:	e35c0000 	cmp	ip, #0
    8930:	0a000008 	beq	8958 <dna_strncmp+0x38>
    {
      return -1;
    }
       i++;
  }
  while ( (*s2_ptr++ != '\0') &&
    8934:	e1530002 	cmp	r3, r2
    8938:	2a000006 	bcs	8958 <dna_strncmp+0x38>
  char *s1_ptr = (char *)s1, *s2_ptr = (char *)s2;
  size_t i = 0;

  do
  {
    if (*s1_ptr++ != *s2_ptr)
    893c:	e7d1c003 	ldrb	ip, [r1, r3]
    8940:	e4d0e001 	ldrb	lr, [r0], #1
    {
      return -1;
    }
       i++;
    8944:	e2833001 	add	r3, r3, #1
  char *s1_ptr = (char *)s1, *s2_ptr = (char *)s2;
  size_t i = 0;

  do
  {
    if (*s1_ptr++ != *s2_ptr)
    8948:	e15c000e 	cmp	ip, lr
    894c:	0afffff6 	beq	892c <dna_strncmp+0xc>
    {
      return -1;
    8950:	e3e00000 	mvn	r0, #0
    8954:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
       i++;
  }
  while ( (*s2_ptr++ != '\0') &&
             (i < n));
  
  return 0;
    8958:	e3a00000 	mov	r0, #0
}
    895c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

00008960 <queue_rem>:
 */

#include <DnaTools/DnaTools.h>
#include <Processor/Cache.h>
void * queue_rem (queue_t * queue)
{
    8960:	e92d4038 	push	{r3, r4, r5, lr}
    8964:	e1a04000 	mov	r4, r0
  queue_link_t * item = NULL;

  watch (void *)
  {
    cpu_dcache_invalidate((void*)&queue->status,sizeof(uint32_t));
    8968:	e3a01004 	mov	r1, #4
    896c:	e280000c 	add	r0, r0, #12
    8970:	eb0004ce 	bl	9cb0 <cpu_dcache_invalidate>
    ensure (queue -> status != 0, NULL);
    8974:	e594300c 	ldr	r3, [r4, #12]
    8978:	e3530000 	cmp	r3, #0
    897c:	0a000011 	beq	89c8 <queue_rem+0x68>

    item = queue -> head;

    queue -> status -= 1;
    8980:	e594300c 	ldr	r3, [r4, #12]
  watch (void *)
  {
    cpu_dcache_invalidate((void*)&queue->status,sizeof(uint32_t));
    ensure (queue -> status != 0, NULL);

    item = queue -> head;
    8984:	e5945004 	ldr	r5, [r4, #4]

    queue -> status -= 1;
    8988:	e2433001 	sub	r3, r3, #1
    898c:	e584300c 	str	r3, [r4, #12]

    cpu_dcache_invalidate((void*)&(item->next), sizeof(queue_link_t)); 
    8990:	e1a00005 	mov	r0, r5
    8994:	e3a01004 	mov	r1, #4
    8998:	eb0004c4 	bl	9cb0 <cpu_dcache_invalidate>
    queue -> head = item -> next;
    899c:	e5953000 	ldr	r3, [r5]

    check (queue_error, queue -> head != NULL ||
    89a0:	e3530000 	cmp	r3, #0
    item = queue -> head;

    queue -> status -= 1;

    cpu_dcache_invalidate((void*)&(item->next), sizeof(queue_link_t)); 
    queue -> head = item -> next;
    89a4:	e5843004 	str	r3, [r4, #4]

    check (queue_error, queue -> head != NULL ||
    89a8:	0a000003 	beq	89bc <queue_rem+0x5c>
        (queue -> head == NULL && queue -> status == 0), NULL);

    item -> next = NULL;
    89ac:	e3a03000 	mov	r3, #0

    return item;
    89b0:	e1a00005 	mov	r0, r5
    queue -> head = item -> next;

    check (queue_error, queue -> head != NULL ||
        (queue -> head == NULL && queue -> status == 0), NULL);

    item -> next = NULL;
    89b4:	e5853000 	str	r3, [r5]
dna_log(PANIC_LEVEL, "Q(0x%x): status %d, item 0x%x",
        queue, queue -> status, item);

    leave;
  }
}
    89b8:	e8bd8038 	pop	{r3, r4, r5, pc}
    queue -> status -= 1;

    cpu_dcache_invalidate((void*)&(item->next), sizeof(queue_link_t)); 
    queue -> head = item -> next;

    check (queue_error, queue -> head != NULL ||
    89bc:	e594300c 	ldr	r3, [r4, #12]
    89c0:	e3530000 	cmp	r3, #0
    89c4:	0afffff8 	beq	89ac <queue_rem+0x4c>
  queue_link_t * item = NULL;

  watch (void *)
  {
    cpu_dcache_invalidate((void*)&queue->status,sizeof(uint32_t));
    ensure (queue -> status != 0, NULL);
    89c8:	e3a00000 	mov	r0, #0
    89cc:	e8bd8038 	pop	{r3, r4, r5, pc}

000089d0 <path_get_next_entry>:
 * * DNA_OK : the operation succeeded.
 *
 * SOURCE
 */

{
    89d0:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
  char * p_start = *path, * p_end = *path;
    89d4:	e590c000 	ldr	ip, [r0]
 * * DNA_OK : the operation succeeded.
 *
 * SOURCE
 */

{
    89d8:	e1a05000 	mov	r5, r0
  char * p_start = *path, * p_end = *path;
  int32_t token_size = 0;

  watch (status_t)
  {
    ensure (*p_start != '\0', DNA_ERROR);
    89dc:	e5dc3000 	ldrb	r3, [ip]
    89e0:	e3530000 	cmp	r3, #0
    89e4:	1a000001 	bne	89f0 <path_get_next_entry+0x20>
    89e8:	e59f006c 	ldr	r0, [pc, #108]	; 8a5c <path_get_next_entry+0x8c>
    89ec:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

    /*
     * Find the first occurence of '/'
     */

    while (*p_end != '/' && *p_end != '\0')
    89f0:	e353002f 	cmp	r3, #47	; 0x2f
    89f4:	e1a06001 	mov	r6, r1
    89f8:	e1a0400c 	mov	r4, ip
    89fc:	0a000008 	beq	8a24 <path_get_next_entry+0x54>
    8a00:	e5f43001 	ldrb	r3, [r4, #1]!
    8a04:	e3530000 	cmp	r3, #0
    8a08:	1353002f 	cmpne	r3, #47	; 0x2f
    8a0c:	1afffffb 	bne	8a00 <path_get_next_entry+0x30>
    8a10:	e06c7004 	rsb	r7, ip, r4
    /*
     * Copy the token
     */

    token_size = p_end - p_start;
    ensure (token_size <= DNA_FILENAME_LENGTH, DNA_NAME_TOO_LONG);
    8a14:	e3570c01 	cmp	r7, #256	; 0x100
    8a18:	da000002 	ble	8a28 <path_get_next_entry+0x58>
    8a1c:	e59f003c 	ldr	r0, [pc, #60]	; 8a60 <path_get_next_entry+0x90>
    }

    *path = p_end;
    return DNA_OK;
  }
}
    8a20:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

    /*
     * Find the first occurence of '/'
     */

    while (*p_end != '/' && *p_end != '\0')
    8a24:	e3a07000 	mov	r7, #0
     */

    token_size = p_end - p_start;
    ensure (token_size <= DNA_FILENAME_LENGTH, DNA_NAME_TOO_LONG);

    dna_memcpy (token, p_start, token_size);
    8a28:	e1a02007 	mov	r2, r7
    8a2c:	e1a0100c 	mov	r1, ip
    8a30:	e1a00006 	mov	r0, r6
    8a34:	eb000332 	bl	9704 <dna_memcpy>
    token[token_size] = '\0';
    8a38:	e3a03000 	mov	r3, #0
    8a3c:	e7c63007 	strb	r3, [r6, r7]

    /*
     * Cut the token from its original string
     */

    if (*p_end == '/')
    8a40:	e5d42000 	ldrb	r2, [r4]
    {
      *p_end ++ = '\0';
    }

    *path = p_end;
    return DNA_OK;
    8a44:	e3a00000 	mov	r0, #0

    /*
     * Cut the token from its original string
     */

    if (*p_end == '/')
    8a48:	e352002f 	cmp	r2, #47	; 0x2f
    {
      *p_end ++ = '\0';
    8a4c:	05c43000 	strbeq	r3, [r4]
    8a50:	02844001 	addeq	r4, r4, #1
    }

    *path = p_end;
    8a54:	e5854000 	str	r4, [r5]
    return DNA_OK;
    8a58:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
    8a5c:	0000ffff 	.word	0x0000ffff
    8a60:	0000fffa 	.word	0x0000fffa

00008a64 <queue_walk>:

#include <stdbool.h>
#include <DnaTools/DnaTools.h>

void queue_walk (queue_t * queue, queue_inspector_t inspector, ...)
{
    8a64:	e92d000e 	push	{r1, r2, r3}
    8a68:	e92d4070 	push	{r4, r5, r6, lr}
  va_list list, list_copy;
  queue_link_t * item = NULL, * old_item = NULL;

  va_start (list, inspector);

  if (queue -> status != 0)
    8a6c:	e590200c 	ldr	r2, [r0, #12]

#include <stdbool.h>
#include <DnaTools/DnaTools.h>

void queue_walk (queue_t * queue, queue_inspector_t inspector, ...)
{
    8a70:	e24dd00c 	sub	sp, sp, #12
  bool result;
  va_list list, list_copy;
  queue_link_t * item = NULL, * old_item = NULL;

  va_start (list, inspector);
    8a74:	e28d3020 	add	r3, sp, #32

  if (queue -> status != 0)
    8a78:	e3520000 	cmp	r2, #0

#include <stdbool.h>
#include <DnaTools/DnaTools.h>

void queue_walk (queue_t * queue, queue_inspector_t inspector, ...)
{
    8a7c:	e1a06000 	mov	r6, r0
  bool result;
  va_list list, list_copy;
  queue_link_t * item = NULL, * old_item = NULL;

  va_start (list, inspector);
    8a80:	e58d3000 	str	r3, [sp]

#include <stdbool.h>
#include <DnaTools/DnaTools.h>

void queue_walk (queue_t * queue, queue_inspector_t inspector, ...)
{
    8a84:	e59d501c 	ldr	r5, [sp, #28]
  va_list list, list_copy;
  queue_link_t * item = NULL, * old_item = NULL;

  va_start (list, inspector);

  if (queue -> status != 0)
    8a88:	0a000011 	beq	8ad4 <queue_walk+0x70>
  {
    item = queue -> head;
    8a8c:	e5904004 	ldr	r4, [r0, #4]
    while (item != NULL)
    8a90:	e3540000 	cmp	r4, #0
    8a94:	0a00000e 	beq	8ad4 <queue_walk+0x70>
    {
      result = false;

      va_copy (list_copy, list);
    8a98:	e59d3000 	ldr	r3, [sp]
      result = inspector (item, list_copy);
    8a9c:	e1a00004 	mov	r0, r4
    8aa0:	e1a01003 	mov	r1, r3
    item = queue -> head;
    while (item != NULL)
    {
      result = false;

      va_copy (list_copy, list);
    8aa4:	e58d3004 	str	r3, [sp, #4]
      result = inspector (item, list_copy);
    8aa8:	e12fff35 	blx	r5
      va_end (list_copy);

      if (result)
    8aac:	e3500000 	cmp	r0, #0
      {
        old_item = item;
        item = item -> next;
        queue_extract (queue, old_item);
      }
      else item = item -> next;
    8ab0:	05944000 	ldreq	r4, [r4]

      va_copy (list_copy, list);
      result = inspector (item, list_copy);
      va_end (list_copy);

      if (result)
    8ab4:	0afffff5 	beq	8a90 <queue_walk+0x2c>
      {
        old_item = item;
        item = item -> next;
    8ab8:	e5943000 	ldr	r3, [r4]
        queue_extract (queue, old_item);
    8abc:	e1a01004 	mov	r1, r4
      va_end (list_copy);

      if (result)
      {
        old_item = item;
        item = item -> next;
    8ac0:	e1a04003 	mov	r4, r3
        queue_extract (queue, old_item);
    8ac4:	e1a00006 	mov	r0, r6
    8ac8:	ebffff64 	bl	8860 <queue_extract>
  va_start (list, inspector);

  if (queue -> status != 0)
  {
    item = queue -> head;
    while (item != NULL)
    8acc:	e3540000 	cmp	r4, #0
    8ad0:	1afffff0 	bne	8a98 <queue_walk+0x34>
      else item = item -> next;
    }
  }

  va_end (list);
}
    8ad4:	e28dd00c 	add	sp, sp, #12
    8ad8:	e8bd4070 	pop	{r4, r5, r6, lr}
    8adc:	e28dd00c 	add	sp, sp, #12
    8ae0:	e12fff1e 	bx	lr

00008ae4 <dna_memset>:

#include <stdint.h>
#include <DnaTools/DnaTools.h>

void * dna_memset (void * s, int32_t c, size_t n)
{
    8ae4:	e92d4008 	push	{r3, lr}
  int32_t rem = n % 4;
  int32_t quo = n >> 2;
  int32_t step = 0;
  
  for (step = 0; step < quo; step++)
    8ae8:	e1b0e122 	lsrs	lr, r2, #2

#include <stdint.h>
#include <DnaTools/DnaTools.h>

void * dna_memset (void * s, int32_t c, size_t n)
{
    8aec:	e1a0c000 	mov	ip, r0
  int32_t rem = n % 4;
    8af0:	e2022003 	and	r2, r2, #3
  int32_t quo = n >> 2;
  int32_t step = 0;
  
  for (step = 0; step < quo; step++)
    8af4:	0a000005 	beq	8b10 <dna_memset+0x2c>
    8af8:	e3a03000 	mov	r3, #0
    8afc:	e1a0010e 	lsl	r0, lr, #2
  {
    *((int32_t *)s + step) = c;
    8b00:	e78c1003 	str	r1, [ip, r3]
    8b04:	e2833004 	add	r3, r3, #4
{
  int32_t rem = n % 4;
  int32_t quo = n >> 2;
  int32_t step = 0;
  
  for (step = 0; step < quo; step++)
    8b08:	e1530000 	cmp	r3, r0
    8b0c:	1afffffb 	bne	8b00 <dna_memset+0x1c>
  {
    *((int32_t *)s + step) = c;
  }

  for (step = 0; step < rem; step++)
    8b10:	e3520000 	cmp	r2, #0
    8b14:	0a000003 	beq	8b28 <dna_memset+0x44>
    8b18:	e1a0000c 	mov	r0, ip
    8b1c:	e6ef1071 	uxtb	r1, r1
    8b20:	eb001c74 	bl	fcf8 <memset>
    8b24:	e1a0c000 	mov	ip, r0
  {
    *((char *)s + step) = (char)c;
  }
  
  return s;
}
    8b28:	e1a0000c 	mov	r0, ip
    8b2c:	e8bd8008 	pop	{r3, pc}

00008b30 <dna_memcmp>:
#include <stdint.h>
#include <DnaTools/DnaTools.h>

int32_t dna_memcmp (const void *s1, const void *s2, size_t n)
{
  for (size_t i = 0; i < n; i += 1)
    8b30:	e3520000 	cmp	r2, #0
    8b34:	0a000012 	beq	8b84 <dna_memcmp+0x54>
  {
    if (((uint8_t *)s1)[i] != ((uint8_t *)s2)[i])
    8b38:	e5d0c000 	ldrb	ip, [r0]
    8b3c:	e5d13000 	ldrb	r3, [r1]
    8b40:	e15c0003 	cmp	ip, r3
    8b44:	02422001 	subeq	r2, r2, #1
    8b48:	00802002 	addeq	r2, r0, r2
    8b4c:	0a000004 	beq	8b64 <dna_memcmp+0x34>
    8b50:	ea000007 	b	8b74 <dna_memcmp+0x44>
    8b54:	e5f0c001 	ldrb	ip, [r0, #1]!
    8b58:	e5f13001 	ldrb	r3, [r1, #1]!
    8b5c:	e15c0003 	cmp	ip, r3
    8b60:	1a000003 	bne	8b74 <dna_memcmp+0x44>
#include <stdint.h>
#include <DnaTools/DnaTools.h>

int32_t dna_memcmp (const void *s1, const void *s2, size_t n)
{
  for (size_t i = 0; i < n; i += 1)
    8b64:	e1500002 	cmp	r0, r2
    8b68:	1afffff9 	bne	8b54 <dna_memcmp+0x24>
        return (int32_t)(((uint8_t *)s1)[i] - ((uint8_t *)s2)[i]);
      }
    }
  }
  
  return 0;
    8b6c:	e3a00000 	mov	r0, #0
    8b70:	e12fff1e 	bx	lr
{
  for (size_t i = 0; i < n; i += 1)
  {
    if (((uint8_t *)s1)[i] != ((uint8_t *)s2)[i])
    {
      if (((uint8_t *)s2)[i] > ((uint8_t *)s1)[i])
    8b74:	e15c0003 	cmp	ip, r3
      {
        return (int32_t)(((uint8_t *)s2)[i] - ((uint8_t *)s1)[i]);
    8b78:	306c0003 	rsbcc	r0, ip, r3
      }
      else
      {
        return (int32_t)(((uint8_t *)s1)[i] - ((uint8_t *)s2)[i]);
    8b7c:	2063000c 	rsbcs	r0, r3, ip
    8b80:	e12fff1e 	bx	lr
      }
    }
  }
  
  return 0;
    8b84:	e1a00002 	mov	r0, r2
}
    8b88:	e12fff1e 	bx	lr

00008b8c <dna_printf>:
 * Print formatted text.
 *
 * SOURCE
 */

{
    8b8c:	e92d000f 	push	{r0, r1, r2, r3}
    8b90:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8b94:	e24ddf53 	sub	sp, sp, #332	; 0x14c
    8b98:	e59d8170 	ldr	r8, [sp, #368]	; 0x170
  uint64_t unsigned_value, remainder;

  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);
    8b9c:	e28d2f5d 	add	r2, sp, #372	; 0x174

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8ba0:	e5d83000 	ldrb	r3, [r8]
  uint64_t unsigned_value, remainder;

  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);
    8ba4:	e58d2024 	str	r2, [sp, #36]	; 0x24

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8ba8:	e3530000 	cmp	r3, #0
    8bac:	0a0001e3 	beq	9340 <dna_printf+0x7b4>
  char char_value, ascii[32], * string_value, buffer[256];
  int32_t ascii_index, string_length, j = 0;
  int64_t signed_value;
  uint64_t unsigned_value, remainder;

  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;
    8bb0:	e3a02000 	mov	r2, #0

{
  bool is_long = false, is_long_long = false;
  bool is_short = false, is_char = false;
  char char_value, ascii[32], * string_value, buffer[256];
  int32_t ascii_index, string_length, j = 0;
    8bb4:	e1a09002 	mov	r9, r2
    8bb8:	e1a0b002 	mov	fp, r2
    8bbc:	e28dc048 	add	ip, sp, #72	; 0x48
 * SOURCE
 */

{
  bool is_long = false, is_long_long = false;
  bool is_short = false, is_char = false;
    8bc0:	e58d200c 	str	r2, [sp, #12]
 *
 * SOURCE
 */

{
  bool is_long = false, is_long_long = false;
    8bc4:	e58d2004 	str	r2, [sp, #4]
    8bc8:	e58d2008 	str	r2, [sp, #8]
    8bcc:	e58dc000 	str	ip, [sp]
    8bd0:	e28da028 	add	sl, sp, #40	; 0x28
  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
  {
    switch (state)
    8bd4:	e3520001 	cmp	r2, #1
    8bd8:	0a000059 	beq	8d44 <dna_printf+0x1b8>
    8bdc:	e3520002 	cmp	r2, #2
    8be0:	1a00006e 	bne	8da0 <dna_printf+0x214>
          break;
        }

      case FORMAT :
        {
          switch (format[i])
    8be4:	e2433025 	sub	r3, r3, #37	; 0x25
    8be8:	e3530053 	cmp	r3, #83	; 0x53
    8bec:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    8bf0:	ea0001a0 	b	9278 <dna_printf+0x6ec>
    8bf4:	000090fc 	.word	0x000090fc
    8bf8:	00009278 	.word	0x00009278
    8bfc:	00009278 	.word	0x00009278
    8c00:	00009278 	.word	0x00009278
    8c04:	00009278 	.word	0x00009278
    8c08:	00009278 	.word	0x00009278
    8c0c:	00009278 	.word	0x00009278
    8c10:	00009278 	.word	0x00009278
    8c14:	00009278 	.word	0x00009278
    8c18:	00008d6c 	.word	0x00008d6c
    8c1c:	00009278 	.word	0x00009278
    8c20:	00008d6c 	.word	0x00008d6c
    8c24:	00008d6c 	.word	0x00008d6c
    8c28:	00008d6c 	.word	0x00008d6c
    8c2c:	00008d6c 	.word	0x00008d6c
    8c30:	00008d6c 	.word	0x00008d6c
    8c34:	00008d6c 	.word	0x00008d6c
    8c38:	00008d6c 	.word	0x00008d6c
    8c3c:	00008d6c 	.word	0x00008d6c
    8c40:	00008d6c 	.word	0x00008d6c
    8c44:	00008d6c 	.word	0x00008d6c
    8c48:	00009278 	.word	0x00009278
    8c4c:	00009278 	.word	0x00009278
    8c50:	00009278 	.word	0x00009278
    8c54:	00009278 	.word	0x00009278
    8c58:	00009278 	.word	0x00009278
    8c5c:	00009278 	.word	0x00009278
    8c60:	00009278 	.word	0x00009278
    8c64:	00009278 	.word	0x00009278
    8c68:	00009278 	.word	0x00009278
    8c6c:	00009278 	.word	0x00009278
    8c70:	00009278 	.word	0x00009278
    8c74:	00009278 	.word	0x00009278
    8c78:	00009278 	.word	0x00009278
    8c7c:	00009278 	.word	0x00009278
    8c80:	00009278 	.word	0x00009278
    8c84:	00009278 	.word	0x00009278
    8c88:	00009278 	.word	0x00009278
    8c8c:	00009278 	.word	0x00009278
    8c90:	00009278 	.word	0x00009278
    8c94:	00009278 	.word	0x00009278
    8c98:	00009278 	.word	0x00009278
    8c9c:	00009278 	.word	0x00009278
    8ca0:	00009278 	.word	0x00009278
    8ca4:	00009278 	.word	0x00009278
    8ca8:	00009278 	.word	0x00009278
    8cac:	00009278 	.word	0x00009278
    8cb0:	00009278 	.word	0x00009278
    8cb4:	00009278 	.word	0x00009278
    8cb8:	00009278 	.word	0x00009278
    8cbc:	00009278 	.word	0x00009278
    8cc0:	00009278 	.word	0x00009278
    8cc4:	00009278 	.word	0x00009278
    8cc8:	00009278 	.word	0x00009278
    8ccc:	00009278 	.word	0x00009278
    8cd0:	00009278 	.word	0x00009278
    8cd4:	00009278 	.word	0x00009278
    8cd8:	00009278 	.word	0x00009278
    8cdc:	00009278 	.word	0x00009278
    8ce0:	00009278 	.word	0x00009278
    8ce4:	00009278 	.word	0x00009278
    8ce8:	00009278 	.word	0x00009278
    8cec:	000090c8 	.word	0x000090c8
    8cf0:	0000914c 	.word	0x0000914c
    8cf4:	00009278 	.word	0x00009278
    8cf8:	00009278 	.word	0x00009278
    8cfc:	00009278 	.word	0x00009278
    8d00:	00009120 	.word	0x00009120
    8d04:	00009278 	.word	0x00009278
    8d08:	00009278 	.word	0x00009278
    8d0c:	00009278 	.word	0x00009278
    8d10:	0000924c 	.word	0x0000924c
    8d14:	00009278 	.word	0x00009278
    8d18:	00009278 	.word	0x00009278
    8d1c:	00009278 	.word	0x00009278
    8d20:	00009020 	.word	0x00009020
    8d24:	00009278 	.word	0x00009278
    8d28:	00009278 	.word	0x00009278
    8d2c:	00008f04 	.word	0x00008f04
    8d30:	00009278 	.word	0x00009278
    8d34:	00008e50 	.word	0x00008e50
    8d38:	00009278 	.word	0x00009278
    8d3c:	00009278 	.word	0x00009278
    8d40:	00009020 	.word	0x00009020
          break;
        }

      case ESCAPE :
        {
          switch (format[i])
    8d44:	e353006e 	cmp	r3, #110	; 0x6e
    8d48:	0a000036 	beq	8e28 <dna_printf+0x29c>
    8d4c:	e3530074 	cmp	r3, #116	; 0x74
    8d50:	1a000029 	bne	8dfc <dna_printf+0x270>
                break;
              }

            case 't' :
              {
                buffer[j] = '\t';
    8d54:	e28d2f52 	add	r2, sp, #328	; 0x148
    8d58:	e3a0c009 	mov	ip, #9
    8d5c:	e0823009 	add	r3, r2, r9
                j += 2;
                break;
              }
          }

          state = NORMAL;
    8d60:	e3a02000 	mov	r2, #0
                break;
              }

            case 't' :
              {
                buffer[j] = '\t';
    8d64:	e543c100 	strb	ip, [r3, #-256]	; 0x100
                j += 1;
    8d68:	e2899001 	add	r9, r9, #1
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8d6c:	e5f83001 	ldrb	r3, [r8, #1]!
    8d70:	e3530000 	cmp	r3, #0
    8d74:	1affff96 	bne	8bd4 <dna_printf+0x48>
    8d78:	e59d0000 	ldr	r0, [sp]
          break;
        }
    }
  }

  buffer[j] = '\0';
    8d7c:	e3a03000 	mov	r3, #0
    8d80:	e28def52 	add	lr, sp, #328	; 0x148
    8d84:	e08e9009 	add	r9, lr, r9
    8d88:	e5493100 	strb	r3, [r9, #-256]	; 0x100
  platform_debug_puts (buffer);
    8d8c:	eb001325 	bl	da28 <platform_debug_puts>

  va_end (arg);
}
    8d90:	e28ddf53 	add	sp, sp, #332	; 0x14c
    8d94:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    8d98:	e28dd010 	add	sp, sp, #16
    8d9c:	e12fff1e 	bx	lr
  {
    switch (state)
    {
      case NORMAL :
        {
          switch (format[i])
    8da0:	e3530025 	cmp	r3, #37	; 0x25
    8da4:	0a00000b 	beq	8dd8 <dna_printf+0x24c>
    8da8:	e353005c 	cmp	r3, #92	; 0x5c
          {
            case '\\' :
              {
                state = ESCAPE;
    8dac:	03a02001 	moveq	r2, #1
  {
    switch (state)
    {
      case NORMAL :
        {
          switch (format[i])
    8db0:	0affffed 	beq	8d6c <dna_printf+0x1e0>
                state = FORMAT;
                break;
              }

            default :
              buffer[j] = format[i];
    8db4:	e28def52 	add	lr, sp, #328	; 0x148
    8db8:	e08e2009 	add	r2, lr, r9
    8dbc:	e5423100 	strb	r3, [r2, #-256]	; 0x100
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8dc0:	e5f83001 	ldrb	r3, [r8, #1]!
                break;
              }

            default :
              buffer[j] = format[i];
              j += 1;
    8dc4:	e2899001 	add	r9, r9, #1
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8dc8:	e3530000 	cmp	r3, #0
              }

            default :
              buffer[j] = format[i];
              j += 1;
              break;
    8dcc:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8dd0:	1affff7f 	bne	8bd4 <dna_printf+0x48>
    8dd4:	eaffffe7 	b	8d78 <dna_printf+0x1ec>
                break;
              }

            case '%' :
              {
                is_char = false;
    8dd8:	e3a0b000 	mov	fp, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8ddc:	e5f83001 	ldrb	r3, [r8, #1]!
              {
                is_char = false;
                is_short = false;
                is_long = false;
                is_long_long = false;
                state = FORMAT;
    8de0:	e3a02002 	mov	r2, #2
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8de4:	e3530000 	cmp	r3, #0
              }

            case '%' :
              {
                is_char = false;
                is_short = false;
    8de8:	e58db00c 	str	fp, [sp, #12]
                is_long = false;
                is_long_long = false;
    8dec:	e58db004 	str	fp, [sp, #4]

            case '%' :
              {
                is_char = false;
                is_short = false;
                is_long = false;
    8df0:	e58db008 	str	fp, [sp, #8]
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8df4:	1affff76 	bne	8bd4 <dna_printf+0x48>
    8df8:	eaffffde 	b	8d78 <dna_printf+0x1ec>
                break;
              }

            default :
              {
                buffer[j] = '\\';
    8dfc:	e3a0005c 	mov	r0, #92	; 0x5c
    8e00:	e28def52 	add	lr, sp, #328	; 0x148
    8e04:	e08e2009 	add	r2, lr, r9
                buffer[j + 1] = format[i];
    8e08:	e54230ff 	strb	r3, [r2, #-255]	; 0xff
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8e0c:	e5f83001 	ldrb	r3, [r8, #1]!
                break;
              }

            default :
              {
                buffer[j] = '\\';
    8e10:	e5420100 	strb	r0, [r2, #-256]	; 0x100
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8e14:	e3530000 	cmp	r3, #0

            default :
              {
                buffer[j] = '\\';
                buffer[j + 1] = format[i];
                j += 2;
    8e18:	e2899002 	add	r9, r9, #2
                break;
              }
          }

          state = NORMAL;
    8e1c:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8e20:	1affff6b 	bne	8bd4 <dna_printf+0x48>
    8e24:	eaffffd3 	b	8d78 <dna_printf+0x1ec>
        {
          switch (format[i])
          {
            case 'n' :
              {
                buffer[j] = '\n';
    8e28:	e3a0100a 	mov	r1, #10
    8e2c:	e28d0f52 	add	r0, sp, #328	; 0x148
    8e30:	e0803009 	add	r3, r0, r9
    8e34:	e5431100 	strb	r1, [r3, #-256]	; 0x100
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8e38:	e5f83001 	ldrb	r3, [r8, #1]!
          switch (format[i])
          {
            case 'n' :
              {
                buffer[j] = '\n';
                j += 1;
    8e3c:	e2899001 	add	r9, r9, #1
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8e40:	e3530000 	cmp	r3, #0
                j += 2;
                break;
              }
          }

          state = NORMAL;
    8e44:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8e48:	1affff61 	bne	8bd4 <dna_printf+0x48>
    8e4c:	eaffffc9 	b	8d78 <dna_printf+0x1ec>

                /*
                 * Check the data size
                 */

                if (is_long_long)
    8e50:	e59dc004 	ldr	ip, [sp, #4]
    8e54:	e35c0000 	cmp	ip, #0
    8e58:	0a00010b 	beq	928c <dna_printf+0x700>
                {
                  unsigned_value = va_arg (arg, unsigned long long int);
    8e5c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    8e60:	e2833007 	add	r3, r3, #7
    8e64:	e3c33007 	bic	r3, r3, #7
    8e68:	e2832008 	add	r2, r3, #8
    8e6c:	e58d2024 	str	r2, [sp, #36]	; 0x24
    8e70:	e1c340d0 	ldrd	r4, [r3]
 *
 * SOURCE
 */

{
  bool is_long = false, is_long_long = false;
    8e74:	e3a06000 	mov	r6, #0
    8e78:	ea000000 	b	8e80 <dna_printf+0x2f4>
                do
                {
                  remainder = unsigned_value % 10;
                  unsigned_value = unsigned_value / 10;
                  ascii[ascii_index] = remainder + '0';
                  ascii_index += 1;
    8e7c:	e1a06003 	mov	r6, r3
                 * Compute the data
                 */

                do
                {
                  remainder = unsigned_value % 10;
    8e80:	e1a00004 	mov	r0, r4
    8e84:	e1a01005 	mov	r1, r5
    8e88:	e3a0200a 	mov	r2, #10
    8e8c:	e3a03000 	mov	r3, #0
    8e90:	eb0013bd 	bl	dd8c <__aeabi_uldivmod>
                  unsigned_value = unsigned_value / 10;
    8e94:	e1a00004 	mov	r0, r4
                 * Compute the data
                 */

                do
                {
                  remainder = unsigned_value % 10;
    8e98:	e1a07002 	mov	r7, r2
                  unsigned_value = unsigned_value / 10;
    8e9c:	e1a01005 	mov	r1, r5
    8ea0:	e3a03000 	mov	r3, #0
    8ea4:	e3a0200a 	mov	r2, #10
    8ea8:	eb0013b7 	bl	dd8c <__aeabi_uldivmod>
    8eac:	e1a04000 	mov	r4, r0
    8eb0:	e1a05001 	mov	r5, r1
                  ascii[ascii_index] = remainder + '0';
    8eb4:	e2877030 	add	r7, r7, #48	; 0x30
                  ascii_index += 1;
                }
                while (unsigned_value > 0);
    8eb8:	e194e005 	orrs	lr, r4, r5

                do
                {
                  remainder = unsigned_value % 10;
                  unsigned_value = unsigned_value / 10;
                  ascii[ascii_index] = remainder + '0';
    8ebc:	e7ca7006 	strb	r7, [sl, r6]
                  ascii_index += 1;
    8ec0:	e2863001 	add	r3, r6, #1
                }
                while (unsigned_value > 0);
    8ec4:	1affffec 	bne	8e7c <dna_printf+0x2f0>
    8ec8:	e59dc000 	ldr	ip, [sp]
    8ecc:	e2492001 	sub	r2, r9, #1
    8ed0:	e08a3003 	add	r3, sl, r3
    8ed4:	e08c2002 	add	r2, ip, r2
                 * Echo the data into the buffer
                 */

                for (int32_t i = ascii_index - 1; i >= 0; i--)
                {
                  buffer[j] = ascii[i];
    8ed8:	e5731001 	ldrb	r1, [r3, #-1]!

                /*
                 * Echo the data into the buffer
                 */

                for (int32_t i = ascii_index - 1; i >= 0; i--)
    8edc:	e153000a 	cmp	r3, sl
                {
                  buffer[j] = ascii[i];
    8ee0:	e5e21001 	strb	r1, [r2, #1]!

                /*
                 * Echo the data into the buffer
                 */

                for (int32_t i = ascii_index - 1; i >= 0; i--)
    8ee4:	1afffffb 	bne	8ed8 <dna_printf+0x34c>
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8ee8:	e5f83001 	ldrb	r3, [r8, #1]!
    8eec:	e2899001 	add	r9, r9, #1
    8ef0:	e3530000 	cmp	r3, #0
    8ef4:	e0899006 	add	r9, r9, r6

                /*
                 * Return to NORMAL state
                 */

                state = NORMAL;
    8ef8:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8efc:	1affff34 	bne	8bd4 <dna_printf+0x48>
    8f00:	eaffff9c 	b	8d78 <dna_printf+0x1ec>
                break;
              }

            case 's' :
              {
                string_value = va_arg (arg, char *);
    8f04:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    8f08:	e5934000 	ldr	r4, [r3]
    8f0c:	e2833004 	add	r3, r3, #4
                string_length = dna_strlen (string_value);
    8f10:	e1a00004 	mov	r0, r4
                break;
              }

            case 's' :
              {
                string_value = va_arg (arg, char *);
    8f14:	e58d3024 	str	r3, [sp, #36]	; 0x24
                string_length = dna_strlen (string_value);
    8f18:	eb0001bd 	bl	9614 <dna_strlen>

                for (int32_t i = 0; i < string_length; i ++)
    8f1c:	e3500000 	cmp	r0, #0
    8f20:	da0000d4 	ble	9278 <dna_printf+0x6ec>
    8f24:	e59dc000 	ldr	ip, [sp]
    8f28:	e59de000 	ldr	lr, [sp]
    8f2c:	e08c1009 	add	r1, ip, r9
    8f30:	e1813004 	orr	r3, r1, r4
    8f34:	e289c004 	add	ip, r9, #4
    8f38:	e3130003 	tst	r3, #3
    8f3c:	e2842004 	add	r2, r4, #4
    8f40:	e08ec00c 	add	ip, lr, ip
    8f44:	03a03001 	moveq	r3, #1
    8f48:	13a03000 	movne	r3, #0
    8f4c:	e1510002 	cmp	r1, r2
    8f50:	3154000c 	cmpcc	r4, ip
    8f54:	23a02001 	movcs	r2, #1
    8f58:	33a02000 	movcc	r2, #0
    8f5c:	e0033002 	and	r3, r3, r2
    8f60:	e3500009 	cmp	r0, #9
    8f64:	93a03000 	movls	r3, #0
    8f68:	82033001 	andhi	r3, r3, #1
    8f6c:	e3530000 	cmp	r3, #0
    8f70:	0a000024 	beq	9008 <dna_printf+0x47c>
    8f74:	e3a03000 	mov	r3, #0
    8f78:	e1a02003 	mov	r2, r3
    8f7c:	e1a0e120 	lsr	lr, r0, #2
    8f80:	e1a0510e 	lsl	r5, lr, #2
                {
                  buffer[j] = string_value[i];
    8f84:	e794c003 	ldr	ip, [r4, r3]
    8f88:	e2822001 	add	r2, r2, #1
    8f8c:	e15e0002 	cmp	lr, r2
    8f90:	e781c003 	str	ip, [r1, r3]
    8f94:	e2833004 	add	r3, r3, #4
    8f98:	8afffff9 	bhi	8f84 <dna_printf+0x3f8>
    8f9c:	e1500005 	cmp	r0, r5
    8fa0:	e0893005 	add	r3, r9, r5
    8fa4:	0a000011 	beq	8ff0 <dna_printf+0x464>
    8fa8:	e7d4c10e 	ldrb	ip, [r4, lr, lsl #2]
            case 's' :
              {
                string_value = va_arg (arg, char *);
                string_length = dna_strlen (string_value);

                for (int32_t i = 0; i < string_length; i ++)
    8fac:	e2852001 	add	r2, r5, #1
                {
                  buffer[j] = string_value[i];
    8fb0:	e28def52 	add	lr, sp, #328	; 0x148
    8fb4:	e08e1003 	add	r1, lr, r3
            case 's' :
              {
                string_value = va_arg (arg, char *);
                string_length = dna_strlen (string_value);

                for (int32_t i = 0; i < string_length; i ++)
    8fb8:	e1500002 	cmp	r0, r2
                {
                  buffer[j] = string_value[i];
    8fbc:	e541c100 	strb	ip, [r1, #-256]	; 0x100
                  j += 1;
    8fc0:	e2831001 	add	r1, r3, #1
            case 's' :
              {
                string_value = va_arg (arg, char *);
                string_length = dna_strlen (string_value);

                for (int32_t i = 0; i < string_length; i ++)
    8fc4:	da000009 	ble	8ff0 <dna_printf+0x464>
                {
                  buffer[j] = string_value[i];
    8fc8:	e7d42002 	ldrb	r2, [r4, r2]
            case 's' :
              {
                string_value = va_arg (arg, char *);
                string_length = dna_strlen (string_value);

                for (int32_t i = 0; i < string_length; i ++)
    8fcc:	e2855002 	add	r5, r5, #2
                {
                  buffer[j] = string_value[i];
    8fd0:	e08e1001 	add	r1, lr, r1
            case 's' :
              {
                string_value = va_arg (arg, char *);
                string_length = dna_strlen (string_value);

                for (int32_t i = 0; i < string_length; i ++)
    8fd4:	e1550000 	cmp	r5, r0
                {
                  buffer[j] = string_value[i];
    8fd8:	e5412100 	strb	r2, [r1, #-256]	; 0x100
                  j += 1;
    8fdc:	e2833002 	add	r3, r3, #2
                string_value = va_arg (arg, char *);
                string_length = dna_strlen (string_value);

                for (int32_t i = 0; i < string_length; i ++)
                {
                  buffer[j] = string_value[i];
    8fe0:	b7d42005 	ldrblt	r2, [r4, r5]
    8fe4:	b28d1f52 	addlt	r1, sp, #328	; 0x148
    8fe8:	b0813003 	addlt	r3, r1, r3
    8fec:	b5432100 	strblt	r2, [r3, #-256]	; 0x100
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    8ff0:	e5f83001 	ldrb	r3, [r8, #1]!
    8ff4:	e0809009 	add	r9, r0, r9
    8ff8:	e3530000 	cmp	r3, #0
                {
                  buffer[j] = string_value[i];
                  j += 1;
                }

                state = NORMAL;
    8ffc:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    9000:	1afffef3 	bne	8bd4 <dna_printf+0x48>
    9004:	eaffff5b 	b	8d78 <dna_printf+0x1ec>
                string_value = va_arg (arg, char *);
                string_length = dna_strlen (string_value);

                for (int32_t i = 0; i < string_length; i ++)
                {
                  buffer[j] = string_value[i];
    9008:	e7d42003 	ldrb	r2, [r4, r3]
    900c:	e7c12003 	strb	r2, [r1, r3]
            case 's' :
              {
                string_value = va_arg (arg, char *);
                string_length = dna_strlen (string_value);

                for (int32_t i = 0; i < string_length; i ++)
    9010:	e2833001 	add	r3, r3, #1
    9014:	e1500003 	cmp	r0, r3
    9018:	1afffffa 	bne	9008 <dna_printf+0x47c>
    901c:	eafffff3 	b	8ff0 <dna_printf+0x464>

                /*
                 * Check the data size
                 */

                if (is_long_long)
    9020:	e59dc004 	ldr	ip, [sp, #4]
    9024:	e35c0000 	cmp	ip, #0
    9028:	0a0000a5 	beq	92c4 <dna_printf+0x738>
                {
                  unsigned_value = va_arg (arg, unsigned long long int);
    902c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    9030:	e2833007 	add	r3, r3, #7
    9034:	e3c33007 	bic	r3, r3, #7
    9038:	e2832008 	add	r2, r3, #8
    903c:	e58d2024 	str	r2, [sp, #36]	; 0x24
    9040:	e1c320d0 	ldrd	r2, [r3]
                do
                {
                  remainder = unsigned_value % 10;
                  unsigned_value = unsigned_value / 10;
                  ascii[ascii_index] = remainder + '0';
                  ascii_index += 1;
    9044:	e3a0e000 	mov	lr, #0
                 * Compute the data
                 */

                do
                {
                  remainder = unsigned_value & 0xf;
    9048:	e3a01000 	mov	r1, #0
                  unsigned_value >>= 4;
    904c:	e1a0c222 	lsr	ip, r2, #4
    9050:	e3510000 	cmp	r1, #0
                 * Compute the data
                 */

                do
                {
                  remainder = unsigned_value & 0xf;
    9054:	e202000f 	and	r0, r2, #15
                  unsigned_value >>= 4;
    9058:	e18cce03 	orr	ip, ip, r3, lsl #28
    905c:	e1a04223 	lsr	r4, r3, #4
    9060:	03500009 	cmpeq	r0, #9
    9064:	e1a0200c 	mov	r2, ip

                  if (remainder < 10)
                  {
                    ascii[ascii_index] = remainder + '0'; 
    9068:	e6ef0070 	uxtb	r0, r0
                 */

                do
                {
                  remainder = unsigned_value & 0xf;
                  unsigned_value >>= 4;
    906c:	e1a03004 	mov	r3, r4
    9070:	e1a0100e 	mov	r1, lr
    9074:	92800030 	addls	r0, r0, #48	; 0x30
    9078:	82800057 	addhi	r0, r0, #87	; 0x57
                  {
                    ascii[ascii_index] = remainder - 10 + 'a';
                    ascii_index += 1;
                  }
                }
                while (unsigned_value > 0);
    907c:	e192e003 	orrs	lr, r2, r3
    9080:	e7ca0001 	strb	r0, [sl, r1]
    9084:	e281e001 	add	lr, r1, #1
    9088:	1affffee 	bne	9048 <dna_printf+0x4bc>
    908c:	e59dc000 	ldr	ip, [sp]
    9090:	e2493001 	sub	r3, r9, #1
    9094:	e08ae00e 	add	lr, sl, lr
    9098:	e08c3003 	add	r3, ip, r3
                 * Echo the data into the buffer
                 */

                for(int32_t i = ascii_index - 1; i >= 0; i--)
                {
                  buffer[j] = ascii[i];
    909c:	e57e2001 	ldrb	r2, [lr, #-1]!

                /*
                 * Echo the data into the buffer
                 */

                for(int32_t i = ascii_index - 1; i >= 0; i--)
    90a0:	e15e000a 	cmp	lr, sl
                {
                  buffer[j] = ascii[i];
    90a4:	e5e32001 	strb	r2, [r3, #1]!

                /*
                 * Echo the data into the buffer
                 */

                for(int32_t i = ascii_index - 1; i >= 0; i--)
    90a8:	1afffffb 	bne	909c <dna_printf+0x510>
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    90ac:	e5f83001 	ldrb	r3, [r8, #1]!
    90b0:	e2899001 	add	r9, r9, #1
    90b4:	e3530000 	cmp	r3, #0
    90b8:	e0899001 	add	r9, r9, r1

                /*
                 * Return to NORMAL state
                 */

                state = NORMAL;
    90bc:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    90c0:	1afffec3 	bne	8bd4 <dna_printf+0x48>
    90c4:	eaffff2b 	b	8d78 <dna_printf+0x1ec>
                break;
              }

            case 'c' :
              {
                unsigned_value = va_arg (arg, unsigned long int);
    90c8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
                char_value = unsigned_value;
                buffer[j] = char_value;
    90cc:	e28def52 	add	lr, sp, #328	; 0x148
              }

            case 'c' :
              {
                unsigned_value = va_arg (arg, unsigned long int);
                char_value = unsigned_value;
    90d0:	e5931000 	ldr	r1, [r3]
                break;
              }

            case 'c' :
              {
                unsigned_value = va_arg (arg, unsigned long int);
    90d4:	e2833004 	add	r3, r3, #4
    90d8:	e58d3024 	str	r3, [sp, #36]	; 0x24
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    90dc:	e5f83001 	ldrb	r3, [r8, #1]!

            case 'c' :
              {
                unsigned_value = va_arg (arg, unsigned long int);
                char_value = unsigned_value;
                buffer[j] = char_value;
    90e0:	e08e2009 	add	r2, lr, r9
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    90e4:	e3530000 	cmp	r3, #0
              }

            case 'c' :
              {
                unsigned_value = va_arg (arg, unsigned long int);
                char_value = unsigned_value;
    90e8:	e5421100 	strb	r1, [r2, #-256]	; 0x100
                buffer[j] = char_value;
                j += 1;
    90ec:	e2899001 	add	r9, r9, #1
                state = NORMAL;
    90f0:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    90f4:	1afffeb6 	bne	8bd4 <dna_printf+0x48>
    90f8:	eaffff1e 	b	8d78 <dna_printf+0x1ec>

                state = NORMAL;
                break;
              }
            case '%':
                buffer[j] = '%';
    90fc:	e3a01025 	mov	r1, #37	; 0x25
    9100:	e28d0f52 	add	r0, sp, #328	; 0x148
    9104:	e0803009 	add	r3, r0, r9
    9108:	e5431100 	strb	r1, [r3, #-256]	; 0x100
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    910c:	e5f83001 	ldrb	r3, [r8, #1]!
                state = NORMAL;
                break;
              }
            case '%':
                buffer[j] = '%';
                j += 1;
    9110:	e2899001 	add	r9, r9, #1
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    9114:	e3530000 	cmp	r3, #0
    9118:	1afffead 	bne	8bd4 <dna_printf+0x48>
    911c:	eaffff15 	b	8d78 <dna_printf+0x1ec>
        {
          switch (format[i])
          {
            case 'h' :
              {
                if (! is_short)
    9120:	e59dc00c 	ldr	ip, [sp, #12]
    9124:	e35c0000 	cmp	ip, #0
                {
                  is_short = true;
    9128:	03a0c001 	moveq	ip, #1
    912c:	058dc00c 	streq	ip, [sp, #12]
        {
          switch (format[i])
          {
            case 'h' :
              {
                if (! is_short)
    9130:	0affff0d 	beq	8d6c <dna_printf+0x1e0>
                {
                  is_short = true;
                }
				else if (! is_char)
    9134:	e35b0000 	cmp	fp, #0
    9138:	1a00004e 	bne	9278 <dna_printf+0x6ec>
                {
                  is_short = false;
    913c:	e3a0c000 	mov	ip, #0
                  is_char = true;
    9140:	e3a0b001 	mov	fp, #1
                {
                  is_short = true;
                }
				else if (! is_char)
                {
                  is_short = false;
    9144:	e58dc00c 	str	ip, [sp, #12]
    9148:	eaffff07 	b	8d6c <dna_printf+0x1e0>

                /*
                 * Check the data size
                 */

                if (is_long_long)
    914c:	e59dc004 	ldr	ip, [sp, #4]
    9150:	e35c0000 	cmp	ip, #0
    9154:	0a000068 	beq	92fc <dna_printf+0x770>
                {
                  signed_value = va_arg (arg, long long int);
    9158:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    915c:	e2833007 	add	r3, r3, #7
    9160:	e3c33007 	bic	r3, r3, #7
    9164:	e2832008 	add	r2, r3, #8
    9168:	e1c300d0 	ldrd	r0, [r3]
    916c:	e58d2024 	str	r2, [sp, #36]	; 0x24
    9170:	e1a03001 	mov	r3, r1
    9174:	e1a02000 	mov	r2, r0
    9178:	e1cd01f0 	strd	r0, [sp, #16]
 *
 * SOURCE
 */

{
  bool is_long = false, is_long_long = false;
    917c:	e3a06000 	mov	r6, #0
                 * Check the data sign
                 */

                if (signed_value < 0)
                {
                  unsigned_value = -1 * signed_value;
    9180:	e59d1014 	ldr	r1, [sp, #20]
    9184:	e1a01fc1 	asr	r1, r1, #31
    9188:	e58d1018 	str	r1, [sp, #24]
    918c:	e58d101c 	str	r1, [sp, #28]
    9190:	e1cd41d8 	ldrd	r4, [sp, #24]
    9194:	e0244002 	eor	r4, r4, r2
    9198:	e1cd01d8 	ldrd	r0, [sp, #24]
    919c:	e0255003 	eor	r5, r5, r3
    91a0:	e0544000 	subs	r4, r4, r0
    91a4:	e0c55001 	sbc	r5, r5, r1
                 * Compute the data
                 */

                do
                {
                  remainder = unsigned_value % 10;
    91a8:	e1a00004 	mov	r0, r4
    91ac:	e1a01005 	mov	r1, r5
    91b0:	e3a0200a 	mov	r2, #10
    91b4:	e3a03000 	mov	r3, #0
    91b8:	eb0012f3 	bl	dd8c <__aeabi_uldivmod>
                  unsigned_value = unsigned_value / 10;
    91bc:	e1a00004 	mov	r0, r4
                 * Compute the data
                 */

                do
                {
                  remainder = unsigned_value % 10;
    91c0:	e1a07002 	mov	r7, r2
                  unsigned_value = unsigned_value / 10;
    91c4:	e1a01005 	mov	r1, r5
    91c8:	e3a0200a 	mov	r2, #10
    91cc:	e3a03000 	mov	r3, #0
    91d0:	eb0012ed 	bl	dd8c <__aeabi_uldivmod>
    91d4:	e1a04000 	mov	r4, r0
    91d8:	e1a05001 	mov	r5, r1
                  ascii[ascii_index] = remainder + '0';
    91dc:	e2877030 	add	r7, r7, #48	; 0x30
                  ascii_index += 1;
                }
                while (unsigned_value > 0);
    91e0:	e1941005 	orrs	r1, r4, r5

                do
                {
                  remainder = unsigned_value % 10;
                  unsigned_value = unsigned_value / 10;
                  ascii[ascii_index] = remainder + '0';
    91e4:	e7ca7006 	strb	r7, [sl, r6]
                  ascii_index += 1;
    91e8:	e2866001 	add	r6, r6, #1
                }
                while (unsigned_value > 0);
    91ec:	1affffed 	bne	91a8 <dna_printf+0x61c>

                /*
                 * Adjust the sign
                 */

                if (signed_value < 0)
    91f0:	e1cd21d0 	ldrd	r2, [sp, #16]
    91f4:	e3520000 	cmp	r2, #0
    91f8:	e2d33000 	sbcs	r3, r3, #0
                {
                  ascii[ascii_index ++] = '-';
    91fc:	b3a0202d 	movlt	r2, #45	; 0x2d
                do
                {
                  remainder = unsigned_value % 10;
                  unsigned_value = unsigned_value / 10;
                  ascii[ascii_index] = remainder + '0';
                  ascii_index += 1;
    9200:	e1a03006 	mov	r3, r6
                 * Adjust the sign
                 */

                if (signed_value < 0)
                {
                  ascii[ascii_index ++] = '-';
    9204:	b28dcf52 	addlt	ip, sp, #328	; 0x148
    9208:	b08c3006 	addlt	r3, ip, r6
    920c:	e59dc000 	ldr	ip, [sp]
    9210:	b5432120 	strblt	r2, [r3, #-288]	; 0x120
    9214:	b2866001 	addlt	r6, r6, #1
    9218:	e2492001 	sub	r2, r9, #1
    921c:	e08c2002 	add	r2, ip, r2
    9220:	e08a3006 	add	r3, sl, r6
                 * Echo the data into the buffer
                 */

                for (int32_t i = ascii_index - 1; i >= 0; i--)
                {
                  buffer[j] = ascii[i];
    9224:	e5731001 	ldrb	r1, [r3, #-1]!

                /*
                 * Echo the data into the buffer
                 */

                for (int32_t i = ascii_index - 1; i >= 0; i--)
    9228:	e153000a 	cmp	r3, sl
                {
                  buffer[j] = ascii[i];
    922c:	e5e21001 	strb	r1, [r2, #1]!

                /*
                 * Echo the data into the buffer
                 */

                for (int32_t i = ascii_index - 1; i >= 0; i--)
    9230:	1afffffb 	bne	9224 <dna_printf+0x698>
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    9234:	e5f83001 	ldrb	r3, [r8, #1]!
    9238:	e0899006 	add	r9, r9, r6
    923c:	e3530000 	cmp	r3, #0

                /*
                 * Return to NORMAL state
                 */

                state = NORMAL;
    9240:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    9244:	1afffe62 	bne	8bd4 <dna_printf+0x48>
    9248:	eafffeca 	b	8d78 <dna_printf+0x1ec>

                break;
              }
            case 'l' :
              {
                if (! is_long)
    924c:	e59dc008 	ldr	ip, [sp, #8]
    9250:	e35c0000 	cmp	ip, #0
                {
                  is_long = true;
    9254:	03a0c001 	moveq	ip, #1
    9258:	058dc008 	streq	ip, [sp, #8]

                break;
              }
            case 'l' :
              {
                if (! is_long)
    925c:	0afffec2 	beq	8d6c <dna_printf+0x1e0>
                {
                  is_long = true;
                }
                else if (! is_long_long)
    9260:	e59dc004 	ldr	ip, [sp, #4]
    9264:	e35c0000 	cmp	ip, #0
                {
                  is_long = false;
    9268:	03a03001 	moveq	r3, #1
    926c:	03a0c000 	moveq	ip, #0
    9270:	098d1008 	stmibeq	sp, {r3, ip}
    9274:	0afffebc 	beq	8d6c <dna_printf+0x1e0>
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    9278:	e5f83001 	ldrb	r3, [r8, #1]!
                {
                  buffer[j] = string_value[i];
                  j += 1;
                }

                state = NORMAL;
    927c:	e3a02000 	mov	r2, #0
  enum { NORMAL, ESCAPE, FORMAT } state = NORMAL;

  va_list arg;
  va_start (arg, format);

  for (int32_t i = 0; format[i] != '\0'; i += 1)
    9280:	e3530000 	cmp	r3, #0
    9284:	1afffe52 	bne	8bd4 <dna_printf+0x48>
    9288:	eafffeba 	b	8d78 <dna_printf+0x1ec>

                if (is_long_long)
                {
                  unsigned_value = va_arg (arg, unsigned long long int);
                }
                else if (is_long)
    928c:	e59dc008 	ldr	ip, [sp, #8]
    9290:	e35c0000 	cmp	ip, #0
    9294:	1a000034 	bne	936c <dna_printf+0x7e0>
                {
                  unsigned_value = va_arg (arg, unsigned long int);
                }
                else if (is_char)
    9298:	e35b0000 	cmp	fp, #0
    929c:	1a000050 	bne	93e4 <dna_printf+0x858>
                {
					 unsigned_value = (unsigned char)va_arg (arg, unsigned int);
                }
                else if (is_short)
    92a0:	e59dc00c 	ldr	ip, [sp, #12]
    92a4:	e35c0000 	cmp	ip, #0
    92a8:	0a00002f 	beq	936c <dna_printf+0x7e0>
                {
					 unsigned_value = (unsigned short)va_arg (arg, unsigned int);
    92ac:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    92b0:	e3a05000 	mov	r5, #0
    92b4:	e1d340b0 	ldrh	r4, [r3]
    92b8:	e2833004 	add	r3, r3, #4
    92bc:	e58d3024 	str	r3, [sp, #36]	; 0x24
    92c0:	eafffeeb 	b	8e74 <dna_printf+0x2e8>

                if (is_long_long)
                {
                  unsigned_value = va_arg (arg, unsigned long long int);
                }
                else if (is_long)
    92c4:	e59dc008 	ldr	ip, [sp, #8]
    92c8:	e35c0000 	cmp	ip, #0
    92cc:	1a000020 	bne	9354 <dna_printf+0x7c8>
                {
                  unsigned_value = va_arg (arg, unsigned long int);
                }
                else if (is_char)
    92d0:	e35b0000 	cmp	fp, #0
    92d4:	1a00003c 	bne	93cc <dna_printf+0x840>
                {
					 unsigned_value = (unsigned char)va_arg (arg, unsigned int);
                }
                else if (is_short)
    92d8:	e59dc00c 	ldr	ip, [sp, #12]
    92dc:	e35c0000 	cmp	ip, #0
    92e0:	0a00001b 	beq	9354 <dna_printf+0x7c8>
                {
					 unsigned_value = (unsigned short)va_arg (arg, unsigned int);
    92e4:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
    92e8:	e3a03000 	mov	r3, #0
    92ec:	e1d120b0 	ldrh	r2, [r1]
    92f0:	e2811004 	add	r1, r1, #4
    92f4:	e58d1024 	str	r1, [sp, #36]	; 0x24
    92f8:	eaffff51 	b	9044 <dna_printf+0x4b8>

                if (is_long_long)
                {
                  signed_value = va_arg (arg, long long int);
                }
                else if (is_long)
    92fc:	e59dc008 	ldr	ip, [sp, #8]
    9300:	e35c0000 	cmp	ip, #0
    9304:	1a00001e 	bne	9384 <dna_printf+0x7f8>
                {
                  signed_value = va_arg (arg, long int);
                }
                else if (is_char)
    9308:	e35b0000 	cmp	fp, #0
    930c:	1a000025 	bne	93a8 <dna_printf+0x81c>
                {
					 signed_value = (signed char)va_arg (arg, int);
                }
                else if (is_short)
    9310:	e59dc00c 	ldr	ip, [sp, #12]
    9314:	e35c0000 	cmp	ip, #0
    9318:	0a000019 	beq	9384 <dna_printf+0x7f8>
                {
					 signed_value = (short)va_arg (arg, int);
    931c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    9320:	e1d300f0 	ldrsh	r0, [r3]
    9324:	e2833004 	add	r3, r3, #4
    9328:	e1a01fc0 	asr	r1, r0, #31
    932c:	e58d3024 	str	r3, [sp, #36]	; 0x24
    9330:	e1cd01f0 	strd	r0, [sp, #16]
    9334:	e1a02000 	mov	r2, r0
    9338:	e1a03001 	mov	r3, r1
    933c:	eaffff8e 	b	917c <dna_printf+0x5f0>
    9340:	e28dc048 	add	ip, sp, #72	; 0x48

{
  bool is_long = false, is_long_long = false;
  bool is_short = false, is_char = false;
  char char_value, ascii[32], * string_value, buffer[256];
  int32_t ascii_index, string_length, j = 0;
    9344:	e1a09003 	mov	r9, r3
    9348:	e58dc000 	str	ip, [sp]
    934c:	e1a0000c 	mov	r0, ip
    9350:	eafffe89 	b	8d7c <dna_printf+0x1f0>
                {
                  unsigned_value = va_arg (arg, unsigned long long int);
                }
                else if (is_long)
                {
                  unsigned_value = va_arg (arg, unsigned long int);
    9354:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    9358:	e5932000 	ldr	r2, [r3]
    935c:	e2833004 	add	r3, r3, #4
    9360:	e58d3024 	str	r3, [sp, #36]	; 0x24
    9364:	e3a03000 	mov	r3, #0
    9368:	eaffff35 	b	9044 <dna_printf+0x4b8>
                {
                  unsigned_value = va_arg (arg, unsigned long long int);
                }
                else if (is_long)
                {
                  unsigned_value = va_arg (arg, unsigned long int);
    936c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    9370:	e3a05000 	mov	r5, #0
    9374:	e5934000 	ldr	r4, [r3]
    9378:	e2833004 	add	r3, r3, #4
    937c:	e58d3024 	str	r3, [sp, #36]	; 0x24
    9380:	eafffebb 	b	8e74 <dna_printf+0x2e8>
                {
                  signed_value = va_arg (arg, long long int);
                }
                else if (is_long)
                {
                  signed_value = va_arg (arg, long int);
    9384:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    9388:	e5932000 	ldr	r2, [r3]
    938c:	e2833004 	add	r3, r3, #4
    9390:	e1a00002 	mov	r0, r2
    9394:	e1a01fc2 	asr	r1, r2, #31
    9398:	e58d3024 	str	r3, [sp, #36]	; 0x24
    939c:	e1cd01f0 	strd	r0, [sp, #16]
    93a0:	e1a03001 	mov	r3, r1
    93a4:	eaffff74 	b	917c <dna_printf+0x5f0>
                }
                else if (is_char)
                {
					 signed_value = (signed char)va_arg (arg, int);
    93a8:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    93ac:	e1d300d0 	ldrsb	r0, [r3]
    93b0:	e2832004 	add	r2, r3, #4
    93b4:	e1a01fc0 	asr	r1, r0, #31
    93b8:	e58d2024 	str	r2, [sp, #36]	; 0x24
    93bc:	e1cd01f0 	strd	r0, [sp, #16]
    93c0:	e1a02000 	mov	r2, r0
    93c4:	e1a03001 	mov	r3, r1
    93c8:	eaffff6b 	b	917c <dna_printf+0x5f0>
                {
                  unsigned_value = va_arg (arg, unsigned long int);
                }
                else if (is_char)
                {
					 unsigned_value = (unsigned char)va_arg (arg, unsigned int);
    93cc:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    93d0:	e2832004 	add	r2, r3, #4
    93d4:	e58d2024 	str	r2, [sp, #36]	; 0x24
    93d8:	e5d32000 	ldrb	r2, [r3]
    93dc:	e3a03000 	mov	r3, #0
    93e0:	eaffff17 	b	9044 <dna_printf+0x4b8>
                {
                  unsigned_value = va_arg (arg, unsigned long int);
                }
                else if (is_char)
                {
					 unsigned_value = (unsigned char)va_arg (arg, unsigned int);
    93e4:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
    93e8:	e3a05000 	mov	r5, #0
    93ec:	e2832004 	add	r2, r3, #4
    93f0:	e58d2024 	str	r2, [sp, #36]	; 0x24
    93f4:	e5d34000 	ldrb	r4, [r3]
    93f8:	eafffe9d 	b	8e74 <dna_printf+0x2e8>

000093fc <extension_get>:

/*
 * SOURCE
 */

{
    93fc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  watch (status_t)
  {
    for (int32_t i = 0; i < OS_N_EXTENSIONS; i++)
    9400:	e59f606c 	ldr	r6, [pc, #108]	; 9474 <extension_get+0x78>
    9404:	e5963000 	ldr	r3, [r6]
    9408:	e3530000 	cmp	r3, #0
    940c:	da000016 	ble	946c <extension_get+0x70>
    9410:	e1a07000 	mov	r7, r0
    9414:	e1a08001 	mov	r8, r1
    9418:	e3a04000 	mov	r4, #0
    941c:	e59f5054 	ldr	r5, [pc, #84]	; 9478 <extension_get+0x7c>
    9420:	ea000003 	b	9434 <extension_get+0x38>
    9424:	e5963000 	ldr	r3, [r6]
    9428:	e2844001 	add	r4, r4, #1
    942c:	e1530004 	cmp	r3, r4
    9430:	da00000d 	ble	946c <extension_get+0x70>
    {
      if (dna_strcmp (OS_EXTENSIONS_LIST[i] -> name, name) == 0)
    9434:	e5b53004 	ldr	r3, [r5, #4]!
    9438:	e1a01007 	mov	r1, r7
    943c:	e5930000 	ldr	r0, [r3]
    9440:	eb00003a 	bl	9530 <dna_strcmp>
    9444:	e3500000 	cmp	r0, #0
    9448:	1afffff5 	bne	9424 <extension_get+0x28>
      {
        *p_ext = OS_EXTENSIONS_LIST[i];
    944c:	e59f3028 	ldr	r3, [pc, #40]	; 947c <extension_get+0x80>
    9450:	e7933104 	ldr	r3, [r3, r4, lsl #2]
    9454:	e5883000 	str	r3, [r8]
        ensure ((*p_ext) -> initialize != NULL, DNA_ERROR);
    9458:	e5933008 	ldr	r3, [r3, #8]
    945c:	e3530000 	cmp	r3, #0
    9460:	0a000001 	beq	946c <extension_get+0x70>
      }
    }

    return DNA_ERROR;
  }
}
    9464:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
      if (dna_strcmp (OS_EXTENSIONS_LIST[i] -> name, name) == 0)
      {
        *p_ext = OS_EXTENSIONS_LIST[i];
        ensure ((*p_ext) -> initialize != NULL, DNA_ERROR);

        return (*p_ext) -> initialize ();
    9468:	e12fff13 	bx	r3
      }
    }

    return DNA_ERROR;
  }
}
    946c:	e59f000c 	ldr	r0, [pc, #12]	; 9480 <extension_get+0x84>
    9470:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    9474:	000254e8 	.word	0x000254e8
    9478:	000254e8 	.word	0x000254e8
    947c:	000254ec 	.word	0x000254ec
    9480:	0000ffff 	.word	0x0000ffff

00009484 <queue_add>:

#include <DnaTools/DnaTools.h>
#include <Processor/Processor.h>

status_t queue_add (queue_t * queue, void * data)
{
    9484:	e92d4038 	push	{r3, r4, r5, lr}
    9488:	e1a04001 	mov	r4, r1
    948c:	e1a05000 	mov	r5, r0
  queue_link_t * item = data;

  watch (status_t)
  {
    cpu_dcache_invalidate((void*)&(item -> next),sizeof(struct _kernel_region*));
    9490:	e3a01004 	mov	r1, #4
    9494:	e1a00004 	mov	r0, r4
    9498:	eb000204 	bl	9cb0 <cpu_dcache_invalidate>
    check (queue_error, item -> next == NULL, DNA_ERROR);
    949c:	e5943000 	ldr	r3, [r4]
    94a0:	e3530000 	cmp	r3, #0
    94a4:	0a000001 	beq	94b0 <queue_add+0x2c>
  rescue (queue_error)
  {
dna_log(PANIC_LEVEL, "Q(0x%x): status %d, item 0x%x",
        queue, queue -> status, item);

    leave;
    94a8:	e59f0038 	ldr	r0, [pc, #56]	; 94e8 <queue_add+0x64>
  }

}
    94ac:	e8bd8038 	pop	{r3, r4, r5, pc}
  watch (status_t)
  {
    cpu_dcache_invalidate((void*)&(item -> next),sizeof(struct _kernel_region*));
    check (queue_error, item -> next == NULL, DNA_ERROR);

    cpu_dcache_invalidate((void*)&(queue->status),sizeof(uint32_t));
    94b0:	e285000c 	add	r0, r5, #12
    94b4:	e3a01004 	mov	r1, #4
    94b8:	eb0001fc 	bl	9cb0 <cpu_dcache_invalidate>
    if (queue -> status == 0)
    94bc:	e595300c 	ldr	r3, [r5, #12]
    {        
      queue -> tail -> next = item;
      queue -> tail = item;
    }

    queue -> status += 1;
    94c0:	e595200c 	ldr	r2, [r5, #12]
  {
    cpu_dcache_invalidate((void*)&(item -> next),sizeof(struct _kernel_region*));
    check (queue_error, item -> next == NULL, DNA_ERROR);

    cpu_dcache_invalidate((void*)&(queue->status),sizeof(uint32_t));
    if (queue -> status == 0)
    94c4:	e3530000 	cmp	r3, #0
      queue -> head = item;
      queue -> tail = item;
    }
    else
    {        
      queue -> tail -> next = item;
    94c8:	15953008 	ldrne	r3, [r5, #8]
      queue -> tail = item;
    }

    queue -> status += 1;
    94cc:	e2822001 	add	r2, r2, #1
      queue -> head = item;
      queue -> tail = item;
    }
    else
    {        
      queue -> tail -> next = item;
    94d0:	15834000 	strne	r4, [r3]
    check (queue_error, item -> next == NULL, DNA_ERROR);

    cpu_dcache_invalidate((void*)&(queue->status),sizeof(uint32_t));
    if (queue -> status == 0)
    {
      queue -> head = item;
    94d4:	05854004 	streq	r4, [r5, #4]
      queue -> tail = item;
    }
    else
    {        
      queue -> tail -> next = item;
      queue -> tail = item;
    94d8:	e5854008 	str	r4, [r5, #8]
    }

    queue -> status += 1;

    return DNA_OK;
    94dc:	e3a00000 	mov	r0, #0
    {        
      queue -> tail -> next = item;
      queue -> tail = item;
    }

    queue -> status += 1;
    94e0:	e585200c 	str	r2, [r5, #12]

    return DNA_OK;
    94e4:	e8bd8038 	pop	{r3, r4, r5, pc}
    94e8:	0000ffff 	.word	0x0000ffff

000094ec <dna_strcat>:
char * dna_strcat (char *  dest, const char *  src)
{
  char * s1 = dest;
  const char * s2 = src;

  for (; *s1 != '\0'; s1++);
    94ec:	e5d03000 	ldrb	r3, [r0]
    94f0:	e3530000 	cmp	r3, #0
    94f4:	e1a03000 	mov	r3, r0
    94f8:	0a000002 	beq	9508 <dna_strcat+0x1c>
    94fc:	e5f32001 	ldrb	r2, [r3, #1]!
    9500:	e3520000 	cmp	r2, #0
    9504:	1afffffc 	bne	94fc <dna_strcat+0x10>
  for (; *s2 != '\0'; s2++, s1++) *s1 = *s2;
    9508:	e5d12000 	ldrb	r2, [r1]
    950c:	e3520000 	cmp	r2, #0
    9510:	0a000003 	beq	9524 <dna_strcat+0x38>
    9514:	e4c32001 	strb	r2, [r3], #1
    9518:	e5f12001 	ldrb	r2, [r1, #1]!
    951c:	e3520000 	cmp	r2, #0
    9520:	1afffffb 	bne	9514 <dna_strcat+0x28>
  *s1 = '\0';
    9524:	e3a02000 	mov	r2, #0
    9528:	e5c32000 	strb	r2, [r3]

  return dest;
}
    952c:	e12fff1e 	bx	lr

00009530 <dna_strcmp>:

#include <stdint.h>
#include <DnaTools/DnaTools.h>

int32_t dna_strcmp (const char *s1, const char *s2)
{
    9530:	e2411001 	sub	r1, r1, #1
    9534:	ea000001 	b	9540 <dna_strcmp+0x10>
    if (*s1_ptr++ != *s2_ptr)
    {
      return -1;
    }
  }
  while (*s2_ptr++ != '\0');
    9538:	e3530000 	cmp	r3, #0
    953c:	0a000005 	beq	9558 <dna_strcmp+0x28>
{
  char *s1_ptr = (char *)s1, *s2_ptr = (char *)s2;

  do
  {
    if (*s1_ptr++ != *s2_ptr)
    9540:	e4d02001 	ldrb	r2, [r0], #1
    9544:	e5f13001 	ldrb	r3, [r1, #1]!
    9548:	e1530002 	cmp	r3, r2
    954c:	0afffff9 	beq	9538 <dna_strcmp+0x8>
    {
      return -1;
    9550:	e3e00000 	mvn	r0, #0
    9554:	e12fff1e 	bx	lr
    }
  }
  while (*s2_ptr++ != '\0');
  
  return 0;
    9558:	e1a00003 	mov	r0, r3
}
    955c:	e12fff1e 	bx	lr

00009560 <queue_lookup>:

#include <stdbool.h>
#include <DnaTools/DnaTools.h>

void * queue_lookup (queue_t * queue, queue_inspector_t inspector, ...)
{
    9560:	e92d000e 	push	{r1, r2, r3}
    9564:	e92d4030 	push	{r4, r5, lr}
  va_list list, list_copy;
  queue_link_t * item = NULL;

  va_start (list, inspector);

  if (queue -> status != 0)
    9568:	e590200c 	ldr	r2, [r0, #12]

#include <stdbool.h>
#include <DnaTools/DnaTools.h>

void * queue_lookup (queue_t * queue, queue_inspector_t inspector, ...)
{
    956c:	e24dd008 	sub	sp, sp, #8
  bool result;
  va_list list, list_copy;
  queue_link_t * item = NULL;

  va_start (list, inspector);
    9570:	e28d3018 	add	r3, sp, #24

  if (queue -> status != 0)
    9574:	e3520000 	cmp	r2, #0
{
  bool result;
  va_list list, list_copy;
  queue_link_t * item = NULL;

  va_start (list, inspector);
    9578:	e58d3000 	str	r3, [sp]

#include <stdbool.h>
#include <DnaTools/DnaTools.h>

void * queue_lookup (queue_t * queue, queue_inspector_t inspector, ...)
{
    957c:	e59d5014 	ldr	r5, [sp, #20]
  va_list list, list_copy;
  queue_link_t * item = NULL;

  va_start (list, inspector);

  if (queue -> status != 0)
    9580:	0a000012 	beq	95d0 <queue_lookup+0x70>
  {
    for (item = queue -> head; item != NULL; item = item -> next)
    9584:	e5904004 	ldr	r4, [r0, #4]
    9588:	e3540000 	cmp	r4, #0
    958c:	1a000003 	bne	95a0 <queue_lookup+0x40>
    9590:	ea00000e 	b	95d0 <queue_lookup+0x70>
    9594:	e5944000 	ldr	r4, [r4]
    9598:	e3540000 	cmp	r4, #0
    959c:	0a00000b 	beq	95d0 <queue_lookup+0x70>
    {
      result = false;

      va_copy (list_copy, list);
    95a0:	e59d3000 	ldr	r3, [sp]
      result = inspector (item, list_copy);
    95a4:	e1a00004 	mov	r0, r4
    95a8:	e1a01003 	mov	r1, r3
  {
    for (item = queue -> head; item != NULL; item = item -> next)
    {
      result = false;

      va_copy (list_copy, list);
    95ac:	e58d3004 	str	r3, [sp, #4]
      result = inspector (item, list_copy);
    95b0:	e12fff35 	blx	r5
      va_end (list_copy);

      if (result) break;
    95b4:	e3500000 	cmp	r0, #0
    95b8:	0afffff5 	beq	9594 <queue_lookup+0x34>
    }
  }

  va_end (list);
  return item;
}
    95bc:	e1a00004 	mov	r0, r4
    95c0:	e28dd008 	add	sp, sp, #8
    95c4:	e8bd4030 	pop	{r4, r5, lr}
    95c8:	e28dd00c 	add	sp, sp, #12
    95cc:	e12fff1e 	bx	lr

void * queue_lookup (queue_t * queue, queue_inspector_t inspector, ...)
{
  bool result;
  va_list list, list_copy;
  queue_link_t * item = NULL;
    95d0:	e3a04000 	mov	r4, #0
    95d4:	eafffff8 	b	95bc <queue_lookup+0x5c>

000095d8 <atomic_add>:
#include <stdbool.h>
#include <Processor/Processor.h>


int32_t atomic_add (int32_t * p_val, int32_t offset)
{
    95d8:	e92d4070 	push	{r4, r5, r6, lr}
    95dc:	e1a04000 	mov	r4, r0
    95e0:	e1a06001 	mov	r6, r1
  int32_t old_val = 0, new_val = 0, result = 0;

  do
  {
    cpu_dcache_invalidate((void*)p_val, sizeof(uint32_t));
    95e4:	e1a00004 	mov	r0, r4
    95e8:	e3a01004 	mov	r1, #4
    95ec:	eb0001af 	bl	9cb0 <cpu_dcache_invalidate>
    old_val = *p_val;
    95f0:	e5945000 	ldr	r5, [r4]
    new_val = old_val + offset;
    result = cpu_compare_and_swap(p_val, old_val, new_val);
    95f4:	e1a00004 	mov	r0, r4
    95f8:	e1a01005 	mov	r1, r5
    95fc:	e0852006 	add	r2, r5, r6
    9600:	eb0001a5 	bl	9c9c <cpu_compare_and_swap>
  }
  while (result != 0);
    9604:	e3500000 	cmp	r0, #0
    9608:	1afffff5 	bne	95e4 <atomic_add+0xc>

  return old_val;
}
    960c:	e1a00005 	mov	r0, r5
    9610:	e8bd8070 	pop	{r4, r5, r6, pc}

00009614 <dna_strlen>:

size_t dna_strlen (const char *s)
{
  size_t size = 0;

  while (s[size++] != '\0');
    9614:	e3a03000 	mov	r3, #0
    9618:	ea000000 	b	9620 <dna_strlen+0xc>
    961c:	e1a03001 	mov	r3, r1
    9620:	e7d02003 	ldrb	r2, [r0, r3]
    9624:	e2831001 	add	r1, r3, #1
    9628:	e3520000 	cmp	r2, #0
    962c:	1afffffa 	bne	961c <dna_strlen+0x8>
  return size - 1;
}
    9630:	e1a00003 	mov	r0, r3
    9634:	e12fff1e 	bx	lr

00009638 <path_split>:
  char * p_start = NULL, * p_end = NULL;
  int32_t token_size;

  watch (status_t)
  {
    ensure (path != NULL && token != NULL, DNA_ERROR);
    9638:	e3510000 	cmp	r1, #0
    963c:	13500000 	cmpne	r0, #0
 * RESULT
 *
 * SOURCE
 */

{
    9640:	e92d4038 	push	{r3, r4, r5, lr}
  char * p_start = NULL, * p_end = NULL;
  int32_t token_size;

  watch (status_t)
  {
    ensure (path != NULL && token != NULL, DNA_ERROR);
    9644:	e1a05001 	mov	r5, r1
    9648:	1a000001 	bne	9654 <path_split+0x1c>
    964c:	e59f008c 	ldr	r0, [pc, #140]	; 96e0 <path_split+0xa8>
    9650:	e8bd8038 	pop	{r3, r4, r5, pc}
    9654:	e1a04000 	mov	r4, r0
    /*
     * Compute the end of the token. If the path
     * ends with '/', add '.' so as to return a valid '.' entry.
     */

    p_end = path + dna_strlen (path);
    9658:	ebffffed 	bl	9614 <dna_strlen>

    if (*p_end == '/')
    965c:	e7d43000 	ldrb	r3, [r4, r0]
    /*
     * Compute the end of the token. If the path
     * ends with '/', add '.' so as to return a valid '.' entry.
     */

    p_end = path + dna_strlen (path);
    9660:	e0840000 	add	r0, r4, r0

    if (*p_end == '/')
    9664:	e353002f 	cmp	r3, #47	; 0x2f
    {
      *(p_end + 1) = '.';
    9668:	03a0302e 	moveq	r3, #46	; 0x2e
    966c:	05e03001 	strbeq	r3, [r0, #1]!
    /*
     * Look for the beginning of the token, that is to
     * say a '/' character.
     */

    while (*p_start != '/' && p_start != path)
    9670:	e3a03000 	mov	r3, #0
    9674:	e5d32000 	ldrb	r2, [r3]
    9678:	e352002f 	cmp	r2, #47	; 0x2f
    967c:	0a00000d 	beq	96b8 <path_split+0x80>
    9680:	e1a01003 	mov	r1, r3
    9684:	ea000001 	b	9690 <path_split+0x58>
    9688:	e1540001 	cmp	r4, r1
    968c:	0affffee 	beq	964c <path_split+0x14>
    9690:	e5712001 	ldrb	r2, [r1, #-1]!
    9694:	e352002f 	cmp	r2, #47	; 0x2f
    9698:	1afffffa 	bne	9688 <path_split+0x50>
    969c:	e1a04001 	mov	r4, r1

    /*
     * Copy the token.
     */

    token_size = p_end - p_start + 1;
    96a0:	e0644000 	rsb	r4, r4, r0
    96a4:	e2844001 	add	r4, r4, #1
    ensure (token_size <= DNA_FILENAME_LENGTH, DNA_NAME_TOO_LONG);
    96a8:	e3540c01 	cmp	r4, #256	; 0x100
    96ac:	da000004 	ble	96c4 <path_split+0x8c>
    96b0:	e59f002c 	ldr	r0, [pc, #44]	; 96e4 <path_split+0xac>
    96b4:	e8bd8038 	pop	{r3, r4, r5, pc}
    /*
     * Look for the beginning of the token, that is to
     * say a '/' character.
     */

    while (*p_start != '/' && p_start != path)
    96b8:	e1a04003 	mov	r4, r3
    96bc:	e1a01003 	mov	r1, r3
    96c0:	eafffff6 	b	96a0 <path_split+0x68>
     */

    token_size = p_end - p_start + 1;
    ensure (token_size <= DNA_FILENAME_LENGTH, DNA_NAME_TOO_LONG);

    dna_memcpy (token, p_start + 1, token_size);
    96c4:	e2811001 	add	r1, r1, #1
    96c8:	e1a00005 	mov	r0, r5
    96cc:	e1a02004 	mov	r2, r4
    96d0:	eb00000b 	bl	9704 <dna_memcpy>
    token[token_size] = '\0';
    96d4:	e3a00000 	mov	r0, #0
    96d8:	e7c50004 	strb	r0, [r5, r4]
    *(p_start + 1) = '\0';
#else
    *(p_start + 1) = '\0';
#endif

    return DNA_OK;
    96dc:	e8bd8038 	pop	{r3, r4, r5, pc}
    96e0:	0000ffff 	.word	0x0000ffff
    96e4:	0000fffa 	.word	0x0000fffa

000096e8 <dna_strcpy>:

#include <DnaTools/DnaTools.h>

char * dna_strcpy (char *  s1, const char *  s2)
{
  char *s1_ptr = s1, *s2_ptr = (char *)s2;
    96e8:	e1a03000 	mov	r3, r0
  
  do *s1_ptr++ = *s2_ptr;
    96ec:	e5d12000 	ldrb	r2, [r1]
    96f0:	e4c32001 	strb	r2, [r3], #1
  while (*s2_ptr++ != '\0');
    96f4:	e4d12001 	ldrb	r2, [r1], #1
    96f8:	e3520000 	cmp	r2, #0
    96fc:	1afffffa 	bne	96ec <dna_strcpy+0x4>
  
  return s1;
}
    9700:	e12fff1e 	bx	lr

00009704 <dna_memcpy>:
#include <DnaTools/DnaTools.h>
#include <Processor/Cache.h>


void * dna_memcpy (void *  s1, const void *  s2, size_t n)
{
    9704:	e92d4070 	push	{r4, r5, r6, lr}
    9708:	e1a04001 	mov	r4, r1
    970c:	e1a06002 	mov	r6, r2
    9710:	e1a05000 	mov	r5, r0
  cpu_dcache_invalidate((void*)s2, n);
    9714:	e1a01002 	mov	r1, r2
    9718:	e1a00004 	mov	r0, r4
    971c:	eb000163 	bl	9cb0 <cpu_dcache_invalidate>
  for (size_t idx = 0; idx < n; idx += 1)
    9720:	e3560000 	cmp	r6, #0
    9724:	0a000025 	beq	97c0 <dna_memcpy+0xbc>
    9728:	e2843004 	add	r3, r4, #4
    972c:	e2852004 	add	r2, r5, #4
    9730:	e1540002 	cmp	r4, r2
    9734:	31550003 	cmpcc	r5, r3
    9738:	23a03001 	movcs	r3, #1
    973c:	33a03000 	movcc	r3, #0
    9740:	e1842005 	orr	r2, r4, r5
    9744:	e3560009 	cmp	r6, #9
    9748:	93a03000 	movls	r3, #0
    974c:	82033001 	andhi	r3, r3, #1
    9750:	e3120003 	tst	r2, #3
    9754:	13a03000 	movne	r3, #0
    9758:	02033001 	andeq	r3, r3, #1
    975c:	e3530000 	cmp	r3, #0
    9760:	0a000018 	beq	97c8 <dna_memcpy+0xc4>
    9764:	e3a03000 	mov	r3, #0
    9768:	e1a02003 	mov	r2, r3
    976c:	e1a01126 	lsr	r1, r6, #2
    9770:	e1a00101 	lsl	r0, r1, #2
  {    
    ((uint8_t *)s1)[idx] = ((uint8_t *)s2)[idx];
    9774:	e794c003 	ldr	ip, [r4, r3]
    9778:	e2822001 	add	r2, r2, #1
    977c:	e1520001 	cmp	r2, r1
    9780:	e785c003 	str	ip, [r5, r3]
    9784:	e2833004 	add	r3, r3, #4
    9788:	3afffff9 	bcc	9774 <dna_memcpy+0x70>
    978c:	e1560000 	cmp	r6, r0
    9790:	0a00000a 	beq	97c0 <dna_memcpy+0xbc>
    9794:	e7d43101 	ldrb	r3, [r4, r1, lsl #2]


void * dna_memcpy (void *  s1, const void *  s2, size_t n)
{
  cpu_dcache_invalidate((void*)s2, n);
  for (size_t idx = 0; idx < n; idx += 1)
    9798:	e2802001 	add	r2, r0, #1
    979c:	e1560002 	cmp	r6, r2
  {    
    ((uint8_t *)s1)[idx] = ((uint8_t *)s2)[idx];
    97a0:	e7c53101 	strb	r3, [r5, r1, lsl #2]


void * dna_memcpy (void *  s1, const void *  s2, size_t n)
{
  cpu_dcache_invalidate((void*)s2, n);
  for (size_t idx = 0; idx < n; idx += 1)
    97a4:	9a000005 	bls	97c0 <dna_memcpy+0xbc>
    97a8:	e2803002 	add	r3, r0, #2
  {    
    ((uint8_t *)s1)[idx] = ((uint8_t *)s2)[idx];
    97ac:	e7d41002 	ldrb	r1, [r4, r2]


void * dna_memcpy (void *  s1, const void *  s2, size_t n)
{
  cpu_dcache_invalidate((void*)s2, n);
  for (size_t idx = 0; idx < n; idx += 1)
    97b0:	e1560003 	cmp	r6, r3
  {    
    ((uint8_t *)s1)[idx] = ((uint8_t *)s2)[idx];
    97b4:	e7c51002 	strb	r1, [r5, r2]
    97b8:	87d42003 	ldrbhi	r2, [r4, r3]
    97bc:	87c52003 	strbhi	r2, [r5, r3]
  }

  return s1;
}
    97c0:	e1a00005 	mov	r0, r5
    97c4:	e8bd8070 	pop	{r4, r5, r6, pc}
void * dna_memcpy (void *  s1, const void *  s2, size_t n)
{
  cpu_dcache_invalidate((void*)s2, n);
  for (size_t idx = 0; idx < n; idx += 1)
  {    
    ((uint8_t *)s1)[idx] = ((uint8_t *)s2)[idx];
    97c8:	e7d42003 	ldrb	r2, [r4, r3]
    97cc:	e7c52003 	strb	r2, [r5, r3]


void * dna_memcpy (void *  s1, const void *  s2, size_t n)
{
  cpu_dcache_invalidate((void*)s2, n);
  for (size_t idx = 0; idx < n; idx += 1)
    97d0:	e2833001 	add	r3, r3, #1
    97d4:	e1530006 	cmp	r3, r6
    97d8:	1afffffa 	bne	97c8 <dna_memcpy+0xc4>
    97dc:	eafffff7 	b	97c0 <dna_memcpy+0xbc>

000097e0 <dna_atoi>:

#include <stdint.h>
#include <DnaTools/DnaTools.h>

int32_t dna_atoi (char * alpha)
{
    97e0:	e92d4010 	push	{r4, lr}
    97e4:	e1a04000 	mov	r4, r0
  int32_t value = 0, c = 0, index = 0;
  uint32_t len = dna_strlen (alpha), coeff = 1;
    97e8:	ebffff89 	bl	9614 <dna_strlen>

  if (alpha == NULL) return -1;
    97ec:	e3540000 	cmp	r4, #0
    97f0:	0a000016 	beq	9850 <dna_atoi+0x70>
  if (len == 0) return -1;
    97f4:	e3500000 	cmp	r0, #0
    97f8:	0a000014 	beq	9850 <dna_atoi+0x70>
  
  for (index = len - 1; index >= 0; index -= 1)
    97fc:	e2503001 	subs	r3, r0, #1
    9800:	4a000014 	bmi	9858 <dna_atoi+0x78>
  {
    c = alpha[index] - '0';
    9804:	e7d41003 	ldrb	r1, [r4, r3]
    9808:	e2411030 	sub	r1, r1, #48	; 0x30
    if (c < 0 || c > 9) return -1;
    980c:	e3510009 	cmp	r1, #9
    9810:	8a00000e 	bhi	9850 <dna_atoi+0x70>
#include <DnaTools/DnaTools.h>

int32_t dna_atoi (char * alpha)
{
  int32_t value = 0, c = 0, index = 0;
  uint32_t len = dna_strlen (alpha), coeff = 1;
    9814:	e3a02001 	mov	r2, #1
#include <stdint.h>
#include <DnaTools/DnaTools.h>

int32_t dna_atoi (char * alpha)
{
  int32_t value = 0, c = 0, index = 0;
    9818:	e3a0c000 	mov	ip, #0
    981c:	ea000003 	b	9830 <dna_atoi+0x50>
  if (alpha == NULL) return -1;
  if (len == 0) return -1;
  
  for (index = len - 1; index >= 0; index -= 1)
  {
    c = alpha[index] - '0';
    9820:	e7d41003 	ldrb	r1, [r4, r3]
    9824:	e2411030 	sub	r1, r1, #48	; 0x30
    if (c < 0 || c > 9) return -1;
    9828:	e3510009 	cmp	r1, #9
    982c:	8a000007 	bhi	9850 <dna_atoi+0x70>
  uint32_t len = dna_strlen (alpha), coeff = 1;

  if (alpha == NULL) return -1;
  if (len == 0) return -1;
  
  for (index = len - 1; index >= 0; index -= 1)
    9830:	e2433001 	sub	r3, r3, #1
  {
    c = alpha[index] - '0';
    if (c < 0 || c > 9) return -1;

    value += c * coeff;
    coeff *= 10;
    9834:	e082e102 	add	lr, r2, r2, lsl #2
  uint32_t len = dna_strlen (alpha), coeff = 1;

  if (alpha == NULL) return -1;
  if (len == 0) return -1;
  
  for (index = len - 1; index >= 0; index -= 1)
    9838:	e3730001 	cmn	r3, #1
  {
    c = alpha[index] - '0';
    if (c < 0 || c > 9) return -1;

    value += c * coeff;
    983c:	e02cc192 	mla	ip, r2, r1, ip
    coeff *= 10;
    9840:	e1a0208e 	lsl	r2, lr, #1
  uint32_t len = dna_strlen (alpha), coeff = 1;

  if (alpha == NULL) return -1;
  if (len == 0) return -1;
  
  for (index = len - 1; index >= 0; index -= 1)
    9844:	1afffff5 	bne	9820 <dna_atoi+0x40>

    value += c * coeff;
    coeff *= 10;
  }

  return value;
    9848:	e1a0000c 	mov	r0, ip
    984c:	e8bd8010 	pop	{r4, pc}
int32_t dna_atoi (char * alpha)
{
  int32_t value = 0, c = 0, index = 0;
  uint32_t len = dna_strlen (alpha), coeff = 1;

  if (alpha == NULL) return -1;
    9850:	e3e00000 	mvn	r0, #0
    value += c * coeff;
    coeff *= 10;
  }

  return value;
}
    9854:	e8bd8010 	pop	{r4, pc}
#include <stdint.h>
#include <DnaTools/DnaTools.h>

int32_t dna_atoi (char * alpha)
{
  int32_t value = 0, c = 0, index = 0;
    9858:	e3a0c000 	mov	ip, #0
    985c:	eafffff9 	b	9848 <dna_atoi+0x68>

00009860 <queue_pushback>:
{
  queue_link_t * item = data;

  watch (status_t)
  {
    check (queue_error, item -> next == NULL, DNA_ERROR);
    9860:	e5913000 	ldr	r3, [r1]
    9864:	e3530000 	cmp	r3, #0
  rescue (queue_error)
  {
dna_log(PANIC_LEVEL, "Q(0x%x): status %d, item 0x%x",
        queue, queue -> status, item);

    leave;
    9868:	159f3038 	ldrne	r3, [pc, #56]	; 98a8 <queue_pushback+0x48>
{
  queue_link_t * item = data;

  watch (status_t)
  {
    check (queue_error, item -> next == NULL, DNA_ERROR);
    986c:	0a000001 	beq	9878 <queue_pushback+0x18>
        queue, queue -> status, item);

    leave;
  }

}
    9870:	e1a00003 	mov	r0, r3
    9874:	e12fff1e 	bx	lr

  watch (status_t)
  {
    check (queue_error, item -> next == NULL, DNA_ERROR);

    if (queue -> status == 0)
    9878:	e590300c 	ldr	r3, [r0, #12]
    {
      item -> next = queue -> head;
      queue -> head = item;
    }

    queue -> status += 1;
    987c:	e590200c 	ldr	r2, [r0, #12]

  watch (status_t)
  {
    check (queue_error, item -> next == NULL, DNA_ERROR);

    if (queue -> status == 0)
    9880:	e3530000 	cmp	r3, #0
      queue -> head = item;
      queue -> tail = item;
    }
    else
    {
      item -> next = queue -> head;
    9884:	15903004 	ldrne	r3, [r0, #4]
      queue -> head = item;
    }

    queue -> status += 1;
    9888:	e2822001 	add	r2, r2, #1
      queue -> head = item;
      queue -> tail = item;
    }
    else
    {
      item -> next = queue -> head;
    988c:	15813000 	strne	r3, [r1]
  {
    check (queue_error, item -> next == NULL, DNA_ERROR);

    if (queue -> status == 0)
    {
      queue -> head = item;
    9890:	05801004 	streq	r1, [r0, #4]
      queue -> tail = item;
    9894:	05801008 	streq	r1, [r0, #8]
    }
    else
    {
      item -> next = queue -> head;
      queue -> head = item;
    9898:	15801004 	strne	r1, [r0, #4]
    }

    queue -> status += 1;

    return DNA_OK;
    989c:	e3a03000 	mov	r3, #0
    {
      item -> next = queue -> head;
      queue -> head = item;
    }

    queue -> status += 1;
    98a0:	e580200c 	str	r2, [r0, #12]

    return DNA_OK;
    98a4:	eafffff1 	b	9870 <queue_pushback+0x10>
    98a8:	0000ffff 	.word	0x0000ffff

000098ac <dna_itoa>:
{
  char ascii[64];
  int32_t value = integer, index = 0, rem = 0;
  bool negative = false;

  if(value < 0)
    98ac:	e3500000 	cmp	r0, #0
#include <stdint.h>
#include <stdbool.h>
#include <DnaTools/DnaTools.h>

int32_t dna_itoa (int32_t integer, char * buffer)
{
    98b0:	e92d4070 	push	{r4, r5, r6, lr}
    98b4:	a1a02000 	movge	r2, r0
  bool negative = false;

  if(value < 0)
  {
    value = -1 * value;
    negative = true;
    98b8:	b3a06001 	movlt	r6, #1

int32_t dna_itoa (int32_t integer, char * buffer)
{
  char ascii[64];
  int32_t value = integer, index = 0, rem = 0;
  bool negative = false;
    98bc:	a3a06000 	movge	r6, #0

  if(value < 0)
  {
    value = -1 * value;
    negative = true;
    98c0:	e3a0e000 	mov	lr, #0
#include <stdint.h>
#include <stdbool.h>
#include <DnaTools/DnaTools.h>

int32_t dna_itoa (int32_t integer, char * buffer)
{
    98c4:	e24dd040 	sub	sp, sp, #64	; 0x40
    negative = true;
  }

  do
  {
    rem = value % 10;
    98c8:	e59f5078 	ldr	r5, [pc, #120]	; 9948 <dna_itoa+0x9c>
  int32_t value = integer, index = 0, rem = 0;
  bool negative = false;

  if(value < 0)
  {
    value = -1 * value;
    98cc:	b2602000 	rsblt	r2, r0, #0
    98d0:	e24d4001 	sub	r4, sp, #1
    negative = true;
  }

  do
  {
    rem = value % 10;
    98d4:	e0cc3295 	smull	r3, ip, r5, r2
    98d8:	e1a03fc2 	asr	r3, r2, #31
    98dc:	e063c14c 	rsb	ip, r3, ip, asr #2
    98e0:	e1a0300c 	mov	r3, ip
    98e4:	e08cc10c 	add	ip, ip, ip, lsl #2
    98e8:	e042c08c 	sub	ip, r2, ip, lsl #1
    value = value / 10;
    ascii[index ++] = rem + '0';
    98ec:	e28cc030 	add	ip, ip, #48	; 0x30
  }
  while(value > 0);
    98f0:	e2532000 	subs	r2, r3, #0

  do
  {
    rem = value % 10;
    value = value / 10;
    ascii[index ++] = rem + '0';
    98f4:	e28ee001 	add	lr, lr, #1
    98f8:	e5e4c001 	strb	ip, [r4, #1]!
  }
  while(value > 0);
    98fc:	1afffff4 	bne	98d4 <dna_itoa+0x28>

  if (negative) ascii[index ++] = '-';
    9900:	e3560000 	cmp	r6, #0

  do
  {
    rem = value % 10;
    value = value / 10;
    ascii[index ++] = rem + '0';
    9904:	e1a0300e 	mov	r3, lr
  }
  while(value > 0);

  if (negative) ascii[index ++] = '-';
    9908:	13a0202d 	movne	r2, #45	; 0x2d
    990c:	128dc040 	addne	ip, sp, #64	; 0x40
    9910:	108c300e 	addne	r3, ip, lr
    9914:	15432040 	strbne	r2, [r3, #-64]	; 0x40
    9918:	e1a0400d 	mov	r4, sp

  do
  {
    rem = value % 10;
    value = value / 10;
    ascii[index ++] = rem + '0';
    991c:	e1a02001 	mov	r2, r1
  }
  while(value > 0);

  if (negative) ascii[index ++] = '-';
    9920:	128ee001 	addne	lr, lr, #1
    9924:	e08d300e 	add	r3, sp, lr

  for(int32_t i = index - 1; i >= 0; i--) *buffer ++ = ascii[i];
    9928:	e573c001 	ldrb	ip, [r3, #-1]!
    992c:	e1530004 	cmp	r3, r4
    9930:	e4c2c001 	strb	ip, [r2], #1
    9934:	1afffffb 	bne	9928 <dna_itoa+0x7c>
  *buffer = '\0';
    9938:	e3a03000 	mov	r3, #0
    993c:	e7c1300e 	strb	r3, [r1, lr]

  return integer;
}
    9940:	e28dd040 	add	sp, sp, #64	; 0x40
    9944:	e8bd8070 	pop	{r4, r5, r6, pc}
    9948:	66666667 	.word	0x66666667

0000994c <queue_insert>:
 */

#include <DnaTools/DnaTools.h>

void queue_insert (queue_t * queue, queue_comparator_t comparator, void * data)
{
    994c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  queue_link_t * item = data, * current = NULL, * previous = NULL;

  item -> next = NULL;
    9950:	e3a08000 	mov	r8, #0

  if (queue -> status != 0)
    9954:	e590300c 	ldr	r3, [r0, #12]
 */

#include <DnaTools/DnaTools.h>

void queue_insert (queue_t * queue, queue_comparator_t comparator, void * data)
{
    9958:	e1a07000 	mov	r7, r0
  queue_link_t * item = data, * current = NULL, * previous = NULL;

  item -> next = NULL;

  if (queue -> status != 0)
    995c:	e1530008 	cmp	r3, r8

void queue_insert (queue_t * queue, queue_comparator_t comparator, void * data)
{
  queue_link_t * item = data, * current = NULL, * previous = NULL;

  item -> next = NULL;
    9960:	e5828000 	str	r8, [r2]
 */

#include <DnaTools/DnaTools.h>

void queue_insert (queue_t * queue, queue_comparator_t comparator, void * data)
{
    9964:	e1a05002 	mov	r5, r2
      queue -> tail = item;
    }
  }
  else
  {
    queue -> head = item;
    9968:	05802004 	streq	r2, [r0, #4]
    queue -> tail = item;
    996c:	05802008 	streq	r2, [r0, #8]
{
  queue_link_t * item = data, * current = NULL, * previous = NULL;

  item -> next = NULL;

  if (queue -> status != 0)
    9970:	0a000006 	beq	9990 <queue_insert+0x44>
  {
    current = queue -> head;
    9974:	e5904004 	ldr	r4, [r0, #4]
    9978:	e1a06001 	mov	r6, r1
    while (current != NULL)
    997c:	e1540008 	cmp	r4, r8
    9980:	1a00000b 	bne	99b4 <queue_insert+0x68>
      }
    }

    if (current == NULL)
    {
      queue -> tail -> next = item;
    9984:	e5973008 	ldr	r3, [r7, #8]
    9988:	e5835000 	str	r5, [r3]
      queue -> tail = item;
    998c:	e5875008 	str	r5, [r7, #8]
  {
    queue -> head = item;
    queue -> tail = item;
  }

  queue -> status += 1;
    9990:	e597300c 	ldr	r3, [r7, #12]
    9994:	e2833001 	add	r3, r3, #1
    9998:	e587300c 	str	r3, [r7, #12]
    999c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
        break;
      }
      else
      {
        previous = current;
        current = current -> next;
    99a0:	e5943000 	ldr	r3, [r4]
  item -> next = NULL;

  if (queue -> status != 0)
  {
    current = queue -> head;
    while (current != NULL)
    99a4:	e3530000 	cmp	r3, #0
    99a8:	0afffff5 	beq	9984 <queue_insert+0x38>
    99ac:	e1a08004 	mov	r8, r4
        break;
      }
      else
      {
        previous = current;
        current = current -> next;
    99b0:	e1a04003 	mov	r4, r3
    {
      /*
       * The comparator function is <
       */

      if (comparator (current, item))
    99b4:	e1a00004 	mov	r0, r4
    99b8:	e1a01005 	mov	r1, r5
    99bc:	e12fff36 	blx	r6
    99c0:	e3500000 	cmp	r0, #0
    99c4:	0afffff5 	beq	99a0 <queue_insert+0x54>
      {
        if (current == queue -> head)
    99c8:	e5973004 	ldr	r3, [r7, #4]
    99cc:	e1540003 	cmp	r4, r3
        {
          queue -> head = item;
    99d0:	05875004 	streq	r5, [r7, #4]
          item -> next = current;
        }
        else
        {
          previous -> next = item;
    99d4:	15885000 	strne	r5, [r8]
          item -> next = current;
    99d8:	e5854000 	str	r4, [r5]
    99dc:	eaffffeb 	b	9990 <queue_insert+0x44>

000099e0 <cpu_vector_transfer>:

.global cpu_vector_transfer

cpu_vector_transfer:
	@ Save registers for further use
	push		{r3-r12}
    99e0:	e92d1ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}

	@ Return directly if byte_count is 0
	cmp			r2, #0x0
    99e4:	e3520000 	cmp	r2, #0
	beq			_cpu_vector_xfer_end
    99e8:	0a000018 	beq	9a50 <_cpu_vector_xfer_end>

	@ Test if r0 and r1 are aligned on a word frontier
	orrs		r3, r0, #0x3
    99ec:	e3903003 	orrs	r3, r0, #3
	orrs		r3, r1, #0x3
    99f0:	e3913003 	orrs	r3, r1, #3

	@ If one of them is not aligned, switch to byte transfer
	mov			r11, #0x0
    99f4:	e3a0b000 	mov	fp, #0
	beq			_cpu_vector_xfer_byte
    99f8:	0a00000e 	beq	9a38 <_cpu_vector_xfer_byte>
	
	@ Compute the number of 8-word xfer to perform
	movs		r12, r2, lsr #0x5
    99fc:	e1b0c2a2 	lsrs	ip, r2, #5
	mov			r11, r12, lsl #0x5
    9a00:	e1a0b28c 	lsl	fp, ip, #5

	@ If no 8-words are available, jump to the byte copy
	beq			_cpu_vector_xfer_word
    9a04:	0a000004 	beq	9a1c <_cpu_vector_xfer_word>

00009a08 <_cpu_vector_xfer_do_lsm>:

	@ Perform the 8-words copy
_cpu_vector_xfer_do_lsm:
	ldmia		r0!, {r3 - r10}
    9a08:	e8b007f8 	ldm	r0!, {r3, r4, r5, r6, r7, r8, r9, sl}
	stmia		r1!, {r3 - r10}
    9a0c:	e8a107f8 	stmia	r1!, {r3, r4, r5, r6, r7, r8, r9, sl}
	subs		r12, r12, #1
    9a10:	e25cc001 	subs	ip, ip, #1
	bne			_cpu_vector_xfer_do_lsm
    9a14:	1afffffb 	bne	9a08 <_cpu_vector_xfer_do_lsm>

	@ Substract the written 8-words from r2
	sub		r2, r2, r11
    9a18:	e042200b 	sub	r2, r2, fp

00009a1c <_cpu_vector_xfer_word>:

	@ Compute the remaining number of words to copy
_cpu_vector_xfer_word:
	movs		r12, r2, lsr #0x2
    9a1c:	e1b0c122 	lsrs	ip, r2, #2
	mov			r11, r12, lsl #0x2
    9a20:	e1a0b10c 	lsl	fp, ip, #2

	@ If no words are available, jump to the byte copy
	beq			_cpu_vector_xfer_byte
    9a24:	0a000003 	beq	9a38 <_cpu_vector_xfer_byte>

00009a28 <_cpu_vector_xfer_do_word>:

	@ Perform the words copy
_cpu_vector_xfer_do_word:
	ldr			r3, [r0], #4
    9a28:	e4903004 	ldr	r3, [r0], #4
	str			r3, [r1], #4
    9a2c:	e4813004 	str	r3, [r1], #4
	subs		r12, r12, #1
    9a30:	e25cc001 	subs	ip, ip, #1
	bne			_cpu_vector_xfer_do_word
    9a34:	1afffffb 	bne	9a28 <_cpu_vector_xfer_do_word>

00009a38 <_cpu_vector_xfer_byte>:

	@ Compute the remaining number of bytes to copy
_cpu_vector_xfer_byte:
	subs		r12, r2, r11
    9a38:	e052c00b 	subs	ip, r2, fp

	@ If no bytes are available, jump to the end
	beq			_cpu_vector_xfer_end
    9a3c:	0a000003 	beq	9a50 <_cpu_vector_xfer_end>

00009a40 <_cpu_vector_xfer_do_byte>:

	@ Perform the byte copy
_cpu_vector_xfer_do_byte:
	ldrb		r3, [r0], #1
    9a40:	e4d03001 	ldrb	r3, [r0], #1
	strb		r3, [r1], #1
    9a44:	e4c13001 	strb	r3, [r1], #1
	subs		r12, r12, #1
    9a48:	e25cc001 	subs	ip, ip, #1
	bne  		_cpu_vector_xfer_do_byte
    9a4c:	1afffffb 	bne	9a40 <_cpu_vector_xfer_do_byte>

00009a50 <_cpu_vector_xfer_end>:

	@ Restore the registers and return
_cpu_vector_xfer_end:
	pop			{r3 - r12}
    9a50:	e8bd1ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
	mov pc, lr
    9a54:	e1a0f00e 	mov	pc, lr

  nop
    9a58:	e320f000 	nop	{0}
  nop
    9a5c:	e320f000 	nop	{0}

00009a60 <cpu_cache_invalidate>:
    void * address, int32_t words)
{
  register int32_t count = 0;
  register uint32_t adjusted_address = (uint32_t)address & 0xFFFFFFF0UL;

  switch (cache_type) 
    9a60:	e3500000 	cmp	r0, #0
    9a64:	0a000012 	beq	9ab4 <cpu_cache_invalidate+0x54>
    9a68:	e3500001 	cmp	r0, #1
    9a6c:	112fff1e 	bxne	lr
        break;
      }

     case CPU_CACHE_DATA :
      {
        if (words == CPU_CACHE_ALL)
    9a70:	e3720001 	cmn	r2, #1
    9a74:	0a00001c 	beq	9aec <cpu_cache_invalidate+0x8c>
        {
          __asm__ volatile ("mcr p15, 0, %0, c7, c6, 0" : : "r"(count));
        }
        else
        {
          count = words >> CPU_DCACHE_SIZE_LOG2;
    9a78:	e1a032c2 	asr	r3, r2, #5
          count += (words - (count << CPU_DCACHE_SIZE_LOG2) != 0) ? 1 : 0;
    9a7c:	e1a00283 	lsl	r0, r3, #5
    9a80:	e1500002 	cmp	r0, r2
    9a84:	01a02003 	moveq	r2, r3
    9a88:	12832001 	addne	r2, r3, #1

          for (register int32_t i = 0; i < count; i += 1)
    9a8c:	e3520000 	cmp	r2, #0
    9a90:	d12fff1e 	bxle	lr
    9a94:	e3a03000 	mov	r3, #0

void cpu_cache_invalidate (cpu_cache_t cache_type,
    void * address, int32_t words)
{
  register int32_t count = 0;
  register uint32_t adjusted_address = (uint32_t)address & 0xFFFFFFF0UL;
    9a98:	e3c1100f 	bic	r1, r1, #15
          count = words >> CPU_DCACHE_SIZE_LOG2;
          count += (words - (count << CPU_DCACHE_SIZE_LOG2) != 0) ? 1 : 0;

          for (register int32_t i = 0; i < count; i += 1)
          {
            __asm__ volatile ("mcr p15, 0, %0, c7, c6, 1"
    9a9c:	ee071f36 	mcr	15, 0, r1, cr7, cr6, {1}
        else
        {
          count = words >> CPU_DCACHE_SIZE_LOG2;
          count += (words - (count << CPU_DCACHE_SIZE_LOG2) != 0) ? 1 : 0;

          for (register int32_t i = 0; i < count; i += 1)
    9aa0:	e2833001 	add	r3, r3, #1
    9aa4:	e1530002 	cmp	r3, r2
          {
            __asm__ volatile ("mcr p15, 0, %0, c7, c6, 1"
                :
                : "r"(adjusted_address));

            adjusted_address += 4 << CPU_DCACHE_SIZE_LOG2;
    9aa8:	e2811080 	add	r1, r1, #128	; 0x80
        else
        {
          count = words >> CPU_DCACHE_SIZE_LOG2;
          count += (words - (count << CPU_DCACHE_SIZE_LOG2) != 0) ? 1 : 0;

          for (register int32_t i = 0; i < count; i += 1)
    9aac:	1afffffa 	bne	9a9c <cpu_cache_invalidate+0x3c>
    9ab0:	e12fff1e 	bx	lr

  switch (cache_type) 
  {
    case CPU_CACHE_INSTRUCTION :
      {
        if (words == CPU_CACHE_ALL)
    9ab4:	e3720001 	cmn	r2, #1
    9ab8:	0a00000e 	beq	9af8 <cpu_cache_invalidate+0x98>
        {
          __asm__ volatile ("mcr p15, 0, %0, c7, c5, 0" : : "r"(count));
        }
        else
        {
          count = words >> CPU_DCACHE_SIZE_LOG2;
    9abc:	e1a032c2 	asr	r3, r2, #5
          count += (words - (count << CPU_DCACHE_SIZE_LOG2) != 0) ? 1 : 0;
    9ac0:	e1a01283 	lsl	r1, r3, #5
    9ac4:	e1510002 	cmp	r1, r2
    9ac8:	01a02003 	moveq	r2, r3
    9acc:	12832001 	addne	r2, r3, #1

          for (register int32_t i = 0; i < count; i += 1)
    9ad0:	e3520000 	cmp	r2, #0
    9ad4:	d12fff1e 	bxle	lr
          {
            __asm__ volatile ("mcr p15, 0, %0, c7, c5, 1" : : "r"(count));
    9ad8:	ee072f35 	mcr	15, 0, r2, cr7, cr5, {1}
        else
        {
          count = words >> CPU_DCACHE_SIZE_LOG2;
          count += (words - (count << CPU_DCACHE_SIZE_LOG2) != 0) ? 1 : 0;

          for (register int32_t i = 0; i < count; i += 1)
    9adc:	e2800001 	add	r0, r0, #1
    9ae0:	e1500002 	cmp	r0, r2
    9ae4:	1afffffb 	bne	9ad8 <cpu_cache_invalidate+0x78>
    9ae8:	e12fff1e 	bx	lr

     case CPU_CACHE_DATA :
      {
        if (words == CPU_CACHE_ALL)
        {
          __asm__ volatile ("mcr p15, 0, %0, c7, c6, 0" : : "r"(count));
    9aec:	e3a03000 	mov	r3, #0
    9af0:	ee073f16 	mcr	15, 0, r3, cr7, cr6, {0}
    9af4:	e12fff1e 	bx	lr
  {
    case CPU_CACHE_INSTRUCTION :
      {
        if (words == CPU_CACHE_ALL)
        {
          __asm__ volatile ("mcr p15, 0, %0, c7, c5, 0" : : "r"(count));
    9af8:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
    9afc:	e12fff1e 	bx	lr

00009b00 <cpu_trap_mask_and_backup>:

interrupt_status_t cpu_trap_mask_and_backup (void)
{
  interrupt_status_t cpsr = 0;

  __asm__ volatile (
    9b00:	e10f0000 	mrs	r0, CPSR
    9b04:	e1a03000 	mov	r3, r0
    9b08:	e38000c0 	orr	r0, r0, #192	; 0xc0
    9b0c:	e129f000 	msr	CPSR_fc, r0
      :
      : "r0"
      );

  return cpsr;
}
    9b10:	e1a00003 	mov	r0, r3
    9b14:	e12fff1e 	bx	lr

00009b18 <cpu_trap_disable>:
#include <Processor/Processor.h>

void cpu_trap_disable (interrupt_id_t id)
{
    9b18:	e92d4010 	push	{r4, lr}
    9b1c:	e1a04000 	mov	r4, r0
  PLATFORM_AICU_BASE -> slot[cpu_mp_id ()] . mask &= ~(1 << id);
    9b20:	eb00004c 	bl	9c58 <cpu_mp_id>
    9b24:	e3a02001 	mov	r2, #1
    9b28:	e59f3014 	ldr	r3, [pc, #20]	; 9b44 <cpu_trap_disable+0x2c>
    9b2c:	e5933000 	ldr	r3, [r3]
    9b30:	e0830200 	add	r0, r3, r0, lsl #4
    9b34:	e5901104 	ldr	r1, [r0, #260]	; 0x104
    9b38:	e1c14412 	bic	r4, r1, r2, lsl r4
    9b3c:	e5804104 	str	r4, [r0, #260]	; 0x104
    9b40:	e8bd8010 	pop	{r4, pc}
    9b44:	0002551c 	.word	0x0002551c

00009b48 <cpu_mp_send_ipi>:
#include <Processor/Processor.h>
#include <Platform/Platform.h>

void cpu_mp_send_ipi (int32_t target, int32_t command, void * data)
{
  cpu_write (UINT32, & (PLATFORM_IPI_BASE[target] . data), ((uint32_t)data));
    9b48:	e59f3010 	ldr	r3, [pc, #16]	; 9b60 <cpu_mp_send_ipi+0x18>
    9b4c:	e5933000 	ldr	r3, [r3]
    9b50:	e083c200 	add	ip, r3, r0, lsl #4
    9b54:	e58c2004 	str	r2, [ip, #4]
  cpu_write (UINT32, & (PLATFORM_IPI_BASE[target] . command), command);
    9b58:	e7831200 	str	r1, [r3, r0, lsl #4]
    9b5c:	e12fff1e 	bx	lr
    9b60:	00025518 	.word	0x00025518

00009b64 <cpu_mp_proceed>:
#include <Processor/Processor.h>

void cpu_mp_proceed (void)
{
  cpu_mp_synchro = 0;
    9b64:	e3a02000 	mov	r2, #0
    9b68:	e59f3004 	ldr	r3, [pc, #4]	; 9b74 <cpu_mp_proceed+0x10>
    9b6c:	e5832000 	str	r2, [r3]
    9b70:	e12fff1e 	bx	lr
    9b74:	00024ba8 	.word	0x00024ba8

00009b78 <cpu_timer_cancel>:
#include <Platform/Platform.h>

void cpu_timer_cancel (int32_t id)
{
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[id];
  cpu_write(UINT32, & (timer -> mode), 1);
    9b78:	e3a03001 	mov	r3, #1
#include <Processor/Processor.h>
#include <Platform/Platform.h>

void cpu_timer_cancel (int32_t id)
{
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[id];
    9b7c:	e59f200c 	ldr	r2, [pc, #12]	; 9b90 <cpu_timer_cancel+0x18>
    9b80:	e5922000 	ldr	r2, [r2]
    9b84:	e0820200 	add	r0, r2, r0, lsl #4
  cpu_write(UINT32, & (timer -> mode), 1);
    9b88:	e5803004 	str	r3, [r0, #4]
    9b8c:	e12fff1e 	bx	lr
    9b90:	00025514 	.word	0x00025514

00009b94 <cpu_timer_get>:
{
  uint32_t local_value = 0;
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[id];

  cpu_read (UINT32, & (timer -> value), local_value);
  *value = (bigtime_t)local_value * PLATFORM_TIMER_RES;
    9b94:	e3a0300a 	mov	r3, #10
#include <Platform/Platform.h>

void cpu_timer_get (int32_t id, bigtime_t * value)
{
  uint32_t local_value = 0;
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[id];
    9b98:	e59f2010 	ldr	r2, [pc, #16]	; 9bb0 <cpu_timer_get+0x1c>
    9b9c:	e5922000 	ldr	r2, [r2]

  cpu_read (UINT32, & (timer -> value), local_value);
    9ba0:	e7922200 	ldr	r2, [r2, r0, lsl #4]
  *value = (bigtime_t)local_value * PLATFORM_TIMER_RES;
    9ba4:	e0832392 	umull	r2, r3, r2, r3
    9ba8:	e1c120f0 	strd	r2, [r1]
    9bac:	e12fff1e 	bx	lr
    9bb0:	00025514 	.word	0x00025514

00009bb4 <cpu_trap_enable>:
#include <Processor/Processor.h>

void cpu_trap_enable (interrupt_id_t id)
{
    9bb4:	e92d4010 	push	{r4, lr}
    9bb8:	e1a04000 	mov	r4, r0
  PLATFORM_AICU_BASE -> slot[cpu_mp_id ()] . mask |= 1 << id;
    9bbc:	eb000025 	bl	9c58 <cpu_mp_id>
    9bc0:	e3a02001 	mov	r2, #1
    9bc4:	e59f3014 	ldr	r3, [pc, #20]	; 9be0 <cpu_trap_enable+0x2c>
    9bc8:	e5933000 	ldr	r3, [r3]
    9bcc:	e0830200 	add	r0, r3, r0, lsl #4
    9bd0:	e5901104 	ldr	r1, [r0, #260]	; 0x104
    9bd4:	e1814412 	orr	r4, r1, r2, lsl r4
    9bd8:	e5804104 	str	r4, [r0, #260]	; 0x104
    9bdc:	e8bd8010 	pop	{r4, pc}
    9be0:	0002551c 	.word	0x0002551c

00009be4 <cpu_trap_restore>:
#include <Processor/Processor.h>

void cpu_trap_restore (interrupt_status_t backup)
{
  __asm__ volatile ("msr cpsr, %0" : : "r"(backup));
    9be4:	e129f000 	msr	CPSR_fc, r0
    9be8:	e12fff1e 	bx	lr

00009bec <cpu_power_wake_on_interrupt>:
#include <Processor/Processor.h>

void cpu_power_wake_on_interrupt (void)
{
    9bec:	e12fff1e 	bx	lr

00009bf0 <cpu_timer_set>:
#include <Platform/Platform.h>

void cpu_timer_set (int32_t id, bigtime_t deadline)
{
  bigtime_t local_deadline = 0;
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[id];
    9bf0:	e59f102c 	ldr	r1, [pc, #44]	; 9c24 <cpu_timer_set+0x34>

#include <Processor/Processor.h>
#include <Platform/Platform.h>

void cpu_timer_set (int32_t id, bigtime_t deadline)
{
    9bf4:	e92d4010 	push	{r4, lr}
  bigtime_t local_deadline = 0;
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[id];
    9bf8:	e5914000 	ldr	r4, [r1]

  local_deadline = deadline / PLATFORM_TIMER_RES;
    9bfc:	e1a01003 	mov	r1, r3
#include <Platform/Platform.h>

void cpu_timer_set (int32_t id, bigtime_t deadline)
{
  bigtime_t local_deadline = 0;
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[id];
    9c00:	e0844200 	add	r4, r4, r0, lsl #4

  local_deadline = deadline / PLATFORM_TIMER_RES;
    9c04:	e3a03000 	mov	r3, #0
    9c08:	e1a00002 	mov	r0, r2
    9c0c:	e3a0200a 	mov	r2, #10
    9c10:	eb00104c 	bl	dd48 <__aeabi_ldivmod>

  cpu_write(UINT32, & (timer -> period), (uint32_t)local_deadline);
  cpu_write(UINT32, & (timer -> mode), 3);
    9c14:	e3a03003 	mov	r3, #3
  bigtime_t local_deadline = 0;
  soclib_timer_port_t timer = & PLATFORM_TIMER_BASE[id];

  local_deadline = deadline / PLATFORM_TIMER_RES;

  cpu_write(UINT32, & (timer -> period), (uint32_t)local_deadline);
    9c18:	e5840008 	str	r0, [r4, #8]
  cpu_write(UINT32, & (timer -> mode), 3);
    9c1c:	e5843004 	str	r3, [r4, #4]
    9c20:	e8bd8010 	pop	{r4, pc}
    9c24:	00025514 	.word	0x00025514

00009c28 <cpu_mp_wait>:
#include <Processor/Processor.h>
#include <Processor/Cache.h>

void cpu_mp_wait (void)
{
  cpu_mp_synchro = 1;
    9c28:	e3a03001 	mov	r3, #1
#include <stdint.h>
#include <Processor/Processor.h>
#include <Processor/Cache.h>

void cpu_mp_wait (void)
{
    9c2c:	e92d4010 	push	{r4, lr}
  cpu_mp_synchro = 1;
    9c30:	e59f401c 	ldr	r4, [pc, #28]	; 9c54 <cpu_mp_wait+0x2c>
    9c34:	e5843000 	str	r3, [r4]

  /*
   * TODO: add WBFLUSH
   */
  do{
      cpu_dcache_invalidate((void*)&cpu_mp_synchro, sizeof(int32_t));
    9c38:	e59f0014 	ldr	r0, [pc, #20]	; 9c54 <cpu_mp_wait+0x2c>
    9c3c:	e3a01004 	mov	r1, #4
    9c40:	eb00001a 	bl	9cb0 <cpu_dcache_invalidate>
  }while ((volatile int32_t)cpu_mp_synchro);
    9c44:	e5943000 	ldr	r3, [r4]
    9c48:	e3530000 	cmp	r3, #0
    9c4c:	1afffff9 	bne	9c38 <cpu_mp_wait+0x10>
}
    9c50:	e8bd8010 	pop	{r4, pc}
    9c54:	00024ba8 	.word	0x00024ba8

00009c58 <cpu_mp_id>:

int32_t cpu_mp_id (void)
{
  register int32_t id = 0;

  __asm__ volatile (
    9c58:	ee100fb0 	mrc	15, 0, r0, cr0, cr0, {5}
      : "=r"(id)
      :
      );

  return id;
}
    9c5c:	e12fff1e 	bx	lr

00009c60 <cpu_trap_attach_isr>:
#include <Processor/Processor.h>

void cpu_trap_attach_isr (int32_t cpuid, interrupt_id_t id,
    uint32_t mode, interrupt_handler_t isr)
{
  PLATFORM_AICU_BASE -> handlers[id] = (uint32_t) isr;
    9c60:	e59f200c 	ldr	r2, [pc, #12]	; 9c74 <cpu_trap_attach_isr+0x14>
    9c64:	e2811004 	add	r1, r1, #4
    9c68:	e5922000 	ldr	r2, [r2]
    9c6c:	e7823101 	str	r3, [r2, r1, lsl #2]
    9c70:	e12fff1e 	bx	lr
    9c74:	0002551c 	.word	0x0002551c

00009c78 <cpu_test_and_set>:
#include<Processor/Cache.h>
long int cpu_test_and_set (volatile long int * spinlock)
{
    9c78:	e92d4010 	push	{r4, lr}
  register long int ret, temp = 1; 

  cpu_dcache_invalidate((void*)spinlock,sizeof(long int));
    9c7c:	e3a01004 	mov	r1, #4
#include<Processor/Cache.h>
long int cpu_test_and_set (volatile long int * spinlock)
{
    9c80:	e1a04000 	mov	r4, r0
  register long int ret, temp = 1; 

  cpu_dcache_invalidate((void*)spinlock,sizeof(long int));
    9c84:	eb000009 	bl	9cb0 <cpu_dcache_invalidate>
  __asm__ volatile
    9c88:	e3a03001 	mov	r3, #1

00009c8c <__start_tst>:
    9c8c:	e1940f9f 	ldrex	r0, [r4]
    9c90:	e3500000 	cmp	r0, #0
    9c94:	01840f93 	strexeq	r0, r3, [r4]
     : "=&r" (ret), "=m" (*spinlock)
     : "r" (temp), "m" (*spinlock), "r"(spinlock)
     : "memory");

  return ret;
}
    9c98:	e8bd8010 	pop	{r4, pc}

00009c9c <cpu_compare_and_swap>:
     : "=&r" (ret)
     : "r" (oldval), "r" (newval), "r" (p_val)
     : "memory");

  return ret;
}
    9c9c:	e1903f9f 	ldrex	r3, [r0]
    9ca0:	e1530001 	cmp	r3, r1
    9ca4:	01803f92 	strexeq	r3, r2, [r0]
    9ca8:	e1a00003 	mov	r0, r3
    9cac:	e12fff1e 	bx	lr

00009cb0 <cpu_dcache_invalidate>:
inline void cpu_dcache_invalidate(void * address, int32_t bytes)
{
    register int32_t count = 0;
    register uint32_t adjusted_address = (uint32_t)address & 0xFFFFFFE0UL; // Based on cache line size

    if (bytes == CPU_CACHE_ALL)
    9cb0:	e3710001 	cmn	r1, #1
    9cb4:	0a000015 	beq	9d10 <cpu_dcache_invalidate+0x60>
    {
        __asm__ volatile ("mcr p15, 0, %0, c7, c6, 0" : : "r"(count));
    }
    else
    {
        count = bytes >> CPU_DCACHE_SIZE_LOG2;
    9cb8:	e1a032c1 	asr	r3, r1, #5
#include <stdint.h>
#include <Processor/Processor.h>

inline void cpu_dcache_invalidate(void * address, int32_t bytes)
{
    9cbc:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
        __asm__ volatile ("mcr p15, 0, %0, c7, c6, 0" : : "r"(count));
    }
    else
    {
        count = bytes >> CPU_DCACHE_SIZE_LOG2;
        count += (bytes - (count << CPU_DCACHE_SIZE_LOG2) != 0) ? 1 : 0;
    9cc0:	e1a0e283 	lsl	lr, r3, #5

        if((((uint32_t)address + (bytes-1)) & 0x1F) < (bytes & 0x1FUL)){
    9cc4:	e241c001 	sub	ip, r1, #1
    9cc8:	e201201f 	and	r2, r1, #31
        __asm__ volatile ("mcr p15, 0, %0, c7, c6, 0" : : "r"(count));
    }
    else
    {
        count = bytes >> CPU_DCACHE_SIZE_LOG2;
        count += (bytes - (count << CPU_DCACHE_SIZE_LOG2) != 0) ? 1 : 0;
    9ccc:	e15e0001 	cmp	lr, r1
    9cd0:	01a01003 	moveq	r1, r3
    9cd4:	12831001 	addne	r1, r3, #1

        if((((uint32_t)address + (bytes-1)) & 0x1F) < (bytes & 0x1FUL)){
    9cd8:	e080c00c 	add	ip, r0, ip
    9cdc:	e20cc01f 	and	ip, ip, #31
    9ce0:	e15c0002 	cmp	ip, r2
            count++;
    9ce4:	32811001 	addcc	r1, r1, #1
        }


        for (register int32_t i = 0; i < count; i += 1)
    9ce8:	e3510000 	cmp	r1, #0
    9cec:	d49df004 	pople	{pc}		; (ldrle pc, [sp], #4)
    9cf0:	e3a03000 	mov	r3, #0
#include <Processor/Processor.h>

inline void cpu_dcache_invalidate(void * address, int32_t bytes)
{
    register int32_t count = 0;
    register uint32_t adjusted_address = (uint32_t)address & 0xFFFFFFE0UL; // Based on cache line size
    9cf4:	e3c0001f 	bic	r0, r0, #31
        }


        for (register int32_t i = 0; i < count; i += 1)
        {
            __asm__ volatile ("mcr p15, 0, %0, c7, c6, 1"
    9cf8:	ee070f36 	mcr	15, 0, r0, cr7, cr6, {1}
        if((((uint32_t)address + (bytes-1)) & 0x1F) < (bytes & 0x1FUL)){
            count++;
        }


        for (register int32_t i = 0; i < count; i += 1)
    9cfc:	e2833001 	add	r3, r3, #1
    9d00:	e1530001 	cmp	r3, r1
        {
            __asm__ volatile ("mcr p15, 0, %0, c7, c6, 1"
                    :
                    : "r"(adjusted_address));

            adjusted_address += 1 << CPU_DCACHE_SIZE_LOG2;
    9d04:	e2800020 	add	r0, r0, #32
        if((((uint32_t)address + (bytes-1)) & 0x1F) < (bytes & 0x1FUL)){
            count++;
        }


        for (register int32_t i = 0; i < count; i += 1)
    9d08:	1afffffa 	bne	9cf8 <cpu_dcache_invalidate+0x48>
    9d0c:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
    register int32_t count = 0;
    register uint32_t adjusted_address = (uint32_t)address & 0xFFFFFFE0UL; // Based on cache line size

    if (bytes == CPU_CACHE_ALL)
    {
        __asm__ volatile ("mcr p15, 0, %0, c7, c6, 0" : : "r"(count));
    9d10:	e3a03000 	mov	r3, #0
    9d14:	ee073f16 	mcr	15, 0, r3, cr7, cr6, {0}
    9d18:	e12fff1e 	bx	lr

00009d1c <cpu_destroy>:
 */

#include <Processor/Processor.h>

void cpu_destroy (void)
{
    9d1c:	e12fff1e 	bx	lr

00009d20 <cpu_trap_attach_esr>:
#include <Processor/Processor.h>

void cpu_trap_attach_esr (int32_t cpuid, exception_id_t id,
    exception_handler_t isr)
{
    9d20:	e12fff1e 	bx	lr

00009d24 <cpu_mp_count>:

extern int32_t CPU_ARMV6_COUNT;

int32_t cpu_mp_count (void)
{
  return CPU_ARMV6_COUNT;
    9d24:	e59f3004 	ldr	r3, [pc, #4]	; 9d30 <cpu_mp_count+0xc>
}
    9d28:	e5930000 	ldr	r0, [r3]
    9d2c:	e12fff1e 	bx	lr
    9d30:	00025508 	.word	0x00025508

00009d34 <cpu_stop>:
 */

#include <Processor/Processor.h>

void cpu_stop (void)
{
    9d34:	e12fff1e 	bx	lr

00009d38 <thread_wait>:

{
  status_t status = DNA_OK;
  uint32_t current_cpuid = 0;
  thread_t self = NULL;
  thread_t thread = NULL, target = NULL;
    9d38:	e3a03000 	mov	r3, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    9d3c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    9d40:	e1a02820 	lsr	r2, r0, #16
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    9d44:	e24dd01c 	sub	sp, sp, #28
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    9d48:	e31200ff 	tst	r2, #255	; 0xff
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    9d4c:	e1a04000 	mov	r4, r0
  status_t status = DNA_OK;
  uint32_t current_cpuid = 0;
  thread_t self = NULL;
  thread_t thread = NULL, target = NULL;
    9d50:	e58d3014 	str	r3, [sp, #20]
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    9d54:	0a000002 	beq	9d64 <thread_wait+0x2c>
    9d58:	e59f01b4 	ldr	r0, [pc, #436]	; 9f14 <thread_wait+0x1dc>
  {
    lock_release (& thread_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    9d5c:	e28dd01c 	add	sp, sp, #28
    9d60:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    ensure (tid . s . index >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . index < DNA_MAX_THREAD, DNA_BAD_ARGUMENT);
    9d64:	e1a06c20 	lsr	r6, r0, #24
    9d68:	e356003f 	cmp	r6, #63	; 0x3f
    9d6c:	8afffff9 	bhi	9d58 <thread_wait+0x20>
    9d70:	e1a05001 	mov	r5, r1

    /*
     * Get information about the current execution.
     */

    it_status = cpu_trap_mask_and_backup();
    9d74:	ebffff61 	bl	9b00 <cpu_trap_mask_and_backup>
     */

    lock_acquire (& thread_pool . lock);
    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
    9d78:	e3a0b0d0 	mov	fp, #208	; 0xd0

    /*
     * Get information about the current execution.
     */

    it_status = cpu_trap_mask_and_backup();
    9d7c:	e1a08000 	mov	r8, r0
    current_cpuid = cpu_mp_id ();
    9d80:	ebffffb4 	bl	9c58 <cpu_mp_id>
     */

    lock_acquire (& thread_pool . lock);
    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
    9d84:	e00b069b 	mul	fp, fp, r6

    /*
     * Get the thread corresponding to ID.
     */

    lock_acquire (& thread_pool . lock);
    9d88:	e59f7188 	ldr	r7, [pc, #392]	; 9f18 <thread_wait+0x1e0>
     * Get information about the current execution.
     */

    it_status = cpu_trap_mask_and_backup();
    current_cpuid = cpu_mp_id ();
    self = cpu_pool . cpu[current_cpuid] . current_thread;
    9d8c:	e59f3188 	ldr	r3, [pc, #392]	; 9f1c <thread_wait+0x1e4>
    9d90:	e0800180 	add	r0, r0, r0, lsl #3
    9d94:	e0833300 	add	r3, r3, r0, lsl #6

    /*
     * Get the thread corresponding to ID.
     */

    lock_acquire (& thread_pool . lock);
    9d98:	e1a00007 	mov	r0, r7
     * Get information about the current execution.
     */

    it_status = cpu_trap_mask_and_backup();
    current_cpuid = cpu_mp_id ();
    self = cpu_pool . cpu[current_cpuid] . current_thread;
    9d9c:	e593922c 	ldr	r9, [r3, #556]	; 0x22c

    /*
     * Get the thread corresponding to ID.
     */

    lock_acquire (& thread_pool . lock);
    9da0:	eb0000a2 	bl	a030 <lock_acquire>
    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
    9da4:	e087300b 	add	r3, r7, fp
    9da8:	e5931024 	ldr	r1, [r3, #36]	; 0x24
    9dac:	e2832020 	add	r2, r3, #32
    9db0:	e1540001 	cmp	r4, r1
    9db4:	159f4164 	ldrne	r4, [pc, #356]	; 9f20 <thread_wait+0x1e8>
    9db8:	0a000005 	beq	9dd4 <thread_wait+0x9c>
    leave;
  }

  rescue (bad_thread)
  {
    lock_release (& thread_pool . lock);
    9dbc:	e59f0154 	ldr	r0, [pc, #340]	; 9f18 <thread_wait+0x1e0>
    9dc0:	eb000b4b 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    9dc4:	e1a00008 	mov	r0, r8
    9dc8:	ebffff85 	bl	9be4 <cpu_trap_restore>
    leave;
    9dcc:	e1a00004 	mov	r0, r4
    9dd0:	eaffffe1 	b	9d5c <thread_wait+0x24>
    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
        thread -> id . raw == tid . raw, DNA_INVALID_THREAD_ID);

    lock_acquire (& thread -> lock);
    9dd4:	e283a01c 	add	sl, r3, #28
    9dd8:	e1a0000a 	mov	r0, sl
    9ddc:	e58d3004 	str	r3, [sp, #4]
    9de0:	e58d2008 	str	r2, [sp, #8]
    9de4:	eb000091 	bl	a030 <lock_acquire>
    lock_release (& thread_pool . lock);
    9de8:	e1a00007 	mov	r0, r7
    9dec:	eb000b40 	bl	caf4 <lock_release>

    /*
     * If the thread is already dead, it is not necessary to
     * go through all the rescheduling pain
     */
    cpu_dcache_invalidate((void*)&thread->info.status,sizeof(uint32_t));   
    9df0:	e28b0058 	add	r0, fp, #88	; 0x58
    9df4:	e3a01004 	mov	r1, #4
    9df8:	e0870000 	add	r0, r7, r0
    9dfc:	ebffffab 	bl	9cb0 <cpu_dcache_invalidate>
    if (thread -> info . status != DNA_THREAD_ENDED)
    9e00:	e59d3004 	ldr	r3, [sp, #4]
    9e04:	e59fc118 	ldr	ip, [pc, #280]	; 9f24 <thread_wait+0x1ec>
    9e08:	e1d315b8 	ldrh	r1, [r3, #88]	; 0x58
    9e0c:	e151000c 	cmp	r1, ip
    9e10:	0a000034 	beq	9ee8 <thread_wait+0x1b0>
    {
      lock_acquire (& thread -> wait . lock);
    9e14:	e087b00b 	add	fp, r7, fp
    9e18:	e28bb00c 	add	fp, fp, #12
    9e1c:	e1a0000b 	mov	r0, fp
    9e20:	e58dc00c 	str	ip, [sp, #12]
    9e24:	eb000081 	bl	a030 <lock_acquire>
      lock_release (& thread -> lock);
    9e28:	e1a0000a 	mov	r0, sl
    9e2c:	eb000b30 	bl	caf4 <lock_release>

      /*
       * If not, put ourselve in wait mode
       */

      lock_acquire (& self -> lock);
    9e30:	e2890014 	add	r0, r9, #20
    9e34:	eb00007d 	bl	a030 <lock_acquire>

      self -> resource_queue = & thread -> wait;
      self -> info . status = DNA_THREAD_WAITING;
      self -> info . resource = DNA_RESOURCE_THREAD;
    9e38:	e3a00002 	mov	r0, #2
       */

      lock_acquire (& self -> lock);

      self -> resource_queue = & thread -> wait;
      self -> info . status = DNA_THREAD_WAITING;
    9e3c:	e59f10e4 	ldr	r1, [pc, #228]	; 9f28 <thread_wait+0x1f0>
      self -> info . resource = DNA_RESOURCE_THREAD;
    9e40:	e5c90052 	strb	r0, [r9, #82]	; 0x52
       */

      lock_acquire (& self -> lock);

      self -> resource_queue = & thread -> wait;
      self -> info . status = DNA_THREAD_WAITING;
    9e44:	e1c915b0 	strh	r1, [r9, #80]	; 0x50
       * If not, put ourselve in wait mode
       */

      lock_acquire (& self -> lock);

      self -> resource_queue = & thread -> wait;
    9e48:	e589b018 	str	fp, [r9, #24]

      /*
       * Elect a potential target thread.
       */

      status = scheduler_elect (& target, true);
    9e4c:	e3a01001 	mov	r1, #1
      lock_acquire (& self -> lock);

      self -> resource_queue = & thread -> wait;
      self -> info . status = DNA_THREAD_WAITING;
      self -> info . resource = DNA_RESOURCE_THREAD;
      self -> info . resource_id = tid . raw;
    9e50:	e5894054 	str	r4, [r9, #84]	; 0x54

      /*
       * Elect a potential target thread.
       */

      status = scheduler_elect (& target, true);
    9e54:	e28d0014 	add	r0, sp, #20
    9e58:	eb000794 	bl	bcb0 <scheduler_elect>
      ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);
    9e5c:	e59fe0b0 	ldr	lr, [pc, #176]	; 9f14 <thread_wait+0x1dc>
    9e60:	e59f10c4 	ldr	r1, [pc, #196]	; 9f2c <thread_wait+0x1f4>
    9e64:	e1500001 	cmp	r0, r1
    9e68:	1150000e 	cmpne	r0, lr
    9e6c:	0affffba 	beq	9d5c <thread_wait+0x24>

      /*
       * Add self into the ready queue.
       */

      queue_add (& thread -> wait, self);
    9e70:	e1a01009 	mov	r1, r9
    9e74:	e1a0000b 	mov	r0, fp
    9e78:	ebfffd81 	bl	9484 <queue_add>

      /*
       * Reschedule self.
       */

      status = scheduler_switch (target, & thread -> wait);
    9e7c:	e1a0100b 	mov	r1, fp
    9e80:	e59d0014 	ldr	r0, [sp, #20]
    9e84:	eb00098f 	bl	c4c8 <scheduler_switch>
      ensure (status == DNA_OK, status);
    9e88:	e3500000 	cmp	r0, #0
    9e8c:	1affffb2 	bne	9d5c <thread_wait+0x24>

      /*
       * Check if the thread has not been destroyed.
       */

      lock_acquire (& thread_pool . lock);
    9e90:	e1a00007 	mov	r0, r7
    9e94:	eb000065 	bl	a030 <lock_acquire>
      thread = & thread_pool . data[tid . s . group][tid . s . index];

      check (bad_thread, thread != NULL &&
    9e98:	e59d2008 	ldr	r2, [sp, #8]
    9e9c:	e5922004 	ldr	r2, [r2, #4]
    9ea0:	e1540002 	cmp	r4, r2
    9ea4:	159f4084 	ldrne	r4, [pc, #132]	; 9f30 <thread_wait+0x1f8>
    9ea8:	1affffc3 	bne	9dbc <thread_wait+0x84>
        thread -> id . raw == tid . raw , DNA_THREAD_DESTROYED);

      lock_acquire (& thread -> lock);
    9eac:	e1a0000a 	mov	r0, sl
    9eb0:	eb00005e 	bl	a030 <lock_acquire>
      lock_release (& thread_pool . lock);
    9eb4:	e1a00007 	mov	r0, r7
    9eb8:	eb000b0d 	bl	caf4 <lock_release>

      /*
       * Check if we are here as a result of thread_suspend/thread_resume.
       */

      check (bad_status,
    9ebc:	e59d3004 	ldr	r3, [sp, #4]
    9ec0:	e59dc00c 	ldr	ip, [sp, #12]
    9ec4:	e1d335b8 	ldrh	r3, [r3, #88]	; 0x58
    9ec8:	e153000c 	cmp	r3, ip
    9ecc:	0a000005 	beq	9ee8 <thread_wait+0x1b0>
    return status;
  }

  rescue (bad_status)
  {
    lock_release (& thread -> lock);
    9ed0:	e1a0000a 	mov	r0, sl
    9ed4:	eb000b06 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    9ed8:	e1a00008 	mov	r0, r8
    9edc:	ebffff40 	bl	9be4 <cpu_trap_restore>
    leave;
    9ee0:	e59f004c 	ldr	r0, [pc, #76]	; 9f34 <thread_wait+0x1fc>
    9ee4:	eaffff9c 	b	9d5c <thread_wait+0x24>

      check (bad_status,
          thread -> info . status == DNA_THREAD_ENDED, DNA_INTERRUPTED);
    }
    
    if (value != NULL)
    9ee8:	e3550000 	cmp	r5, #0
    {
      *value = thread -> signature . return_value;
    9eec:	13a030d0 	movne	r3, #208	; 0xd0
    9ef0:	10267693 	mlane	r6, r3, r6, r7
    9ef4:	15963088 	ldrne	r3, [r6, #136]	; 0x88
    }

    lock_release (& thread -> lock);
    9ef8:	e1a0000a 	mov	r0, sl
          thread -> info . status == DNA_THREAD_ENDED, DNA_INTERRUPTED);
    }
    
    if (value != NULL)
    {
      *value = thread -> signature . return_value;
    9efc:	15853000 	strne	r3, [r5]
    }

    lock_release (& thread -> lock);
    9f00:	eb000afb 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    9f04:	e1a00008 	mov	r0, r8
    9f08:	ebffff35 	bl	9be4 <cpu_trap_restore>
    return status;
    9f0c:	e3a00000 	mov	r0, #0
    9f10:	eaffff91 	b	9d5c <thread_wait+0x24>
    9f14:	0000fffc 	.word	0x0000fffc
    9f18:	0007b040 	.word	0x0007b040
    9f1c:	0007e458 	.word	0x0007e458
    9f20:	0000fcfe 	.word	0x0000fcfe
    9f24:	0000dead 	.word	0x0000dead
    9f28:	ffffb10c 	.word	0xffffb10c
    9f2c:	0000ffff 	.word	0x0000ffff
    9f30:	0000fcfb 	.word	0x0000fcfb
    9f34:	0000fff9 	.word	0x0000fff9

00009f38 <core_stop>:
 * SOURCE
 */

{
  return DNA_NOT_IMPLEMENTED;
}
    9f38:	e59f0000 	ldr	r0, [pc]	; 9f40 <core_stop+0x8>
    9f3c:	e12fff1e 	bx	lr
    9f40:	0000fffe 	.word	0x0000fffe

00009f44 <thread_resume>:
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    9f44:	e1a03820 	lsr	r3, r0, #16
    9f48:	e31300ff 	tst	r3, #255	; 0xff
 * * DNA_OK: success, the thread has been rescheduled
 *
 * SOURCE
 */

{
    9f4c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
    9f50:	e1a04000 	mov	r4, r0
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    9f54:	0a000001 	beq	9f60 <thread_resume+0x1c>
    9f58:	e59f00b8 	ldr	r0, [pc, #184]	; a018 <thread_resume+0xd4>
  {
    cpu_trap_restore (it_status);
    lock_release (& thread_pool . lock);
    leave;
  }
}
    9f5c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    ensure (tid . s . index >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . index < DNA_MAX_THREAD, DNA_BAD_ARGUMENT);
    9f60:	e1a05c20 	lsr	r5, r0, #24
    9f64:	e355003f 	cmp	r5, #63	; 0x3f
    9f68:	8afffffa 	bhi	9f58 <thread_resume+0x14>
    /*
     * Get the thread corresponding to the current id
     * and check the thread's status.
     */

    it_status = cpu_trap_mask_and_backup();
    9f6c:	ebfffee3 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& thread_pool . lock);
    9f70:	e59f60a4 	ldr	r6, [pc, #164]	; a01c <thread_resume+0xd8>
    /*
     * Get the thread corresponding to the current id
     * and check the thread's status.
     */

    it_status = cpu_trap_mask_and_backup();
    9f74:	e1a08000 	mov	r8, r0
    lock_acquire (& thread_pool . lock);
    9f78:	e1a00006 	mov	r0, r6
    9f7c:	eb00002b 	bl	a030 <lock_acquire>

    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
    9f80:	e3a030d0 	mov	r3, #208	; 0xd0
    9f84:	e0050593 	mul	r5, r3, r5
    9f88:	e0867005 	add	r7, r6, r5
    9f8c:	e5973024 	ldr	r3, [r7, #36]	; 0x24
    9f90:	e1540003 	cmp	r4, r3
    9f94:	159f4084 	ldrne	r4, [pc, #132]	; a020 <thread_resume+0xdc>
    9f98:	0a000005 	beq	9fb4 <thread_resume+0x70>
    lock_release (& thread -> lock);
  }

  rescue (bad_thread)
  {
    cpu_trap_restore (it_status);
    9f9c:	e1a00008 	mov	r0, r8
    9fa0:	ebffff0f 	bl	9be4 <cpu_trap_restore>
    lock_release (& thread_pool . lock);
    9fa4:	e59f0070 	ldr	r0, [pc, #112]	; a01c <thread_resume+0xd8>
    9fa8:	eb000ad1 	bl	caf4 <lock_release>
    leave;
    9fac:	e1a00004 	mov	r0, r4
    9fb0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
        thread -> id . raw == tid . raw , DNA_INVALID_THREAD_ID);

    lock_acquire (& thread -> lock);
    9fb4:	e287401c 	add	r4, r7, #28
    9fb8:	e1a00004 	mov	r0, r4
    9fbc:	eb00001b 	bl	a030 <lock_acquire>
    lock_release (& thread_pool . lock);
    9fc0:	e1a00006 	mov	r0, r6
    9fc4:	eb000aca 	bl	caf4 <lock_release>

    check (bad_status,
    9fc8:	e1d725b8 	ldrh	r2, [r7, #88]	; 0x58
    9fcc:	e59f3050 	ldr	r3, [pc, #80]	; a024 <thread_resume+0xe0>
    9fd0:	e1520003 	cmp	r2, r3
    9fd4:	0a000003 	beq	9fe8 <thread_resume+0xa4>
    return status == DNA_INVOKE_SCHEDULER ? DNA_NO_ERROR : DNA_OK;
  }

  rescue (bad_status)
  {
    lock_release (& thread -> lock);
    9fd8:	e1a00004 	mov	r0, r4
    9fdc:	eb000ac4 	bl	caf4 <lock_release>
        thread -> id . raw == tid . raw , DNA_INVALID_THREAD_ID);

    lock_acquire (& thread -> lock);
    lock_release (& thread_pool . lock);

    check (bad_status,
    9fe0:	e59f4040 	ldr	r4, [pc, #64]	; a028 <thread_resume+0xe4>
    9fe4:	eaffffec 	b	9f9c <thread_resume+0x58>

    /*
     * Update the thread information and resume it.
     */

    thread -> info . status = DNA_THREAD_READY;
    9fe8:	e59f303c 	ldr	r3, [pc, #60]	; a02c <thread_resume+0xe8>
     */

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& thread_pool . lock);

    thread = & thread_pool . data[tid . s . group][tid . s . index];
    9fec:	e2850008 	add	r0, r5, #8

    /*
     * Update the thread information and resume it.
     */

    thread -> info . status = DNA_THREAD_READY;
    9ff0:	e1c735b8 	strh	r3, [r7, #88]	; 0x58
    status = scheduler_dispatch (thread);
    9ff4:	e0860000 	add	r0, r6, r0
    9ff8:	eb000766 	bl	bd98 <scheduler_dispatch>
    9ffc:	e1a04000 	mov	r4, r0
     * Latency should NOT appear on RR or RT scheduling methods.
     * We return the dispatch status anyway, so the user can adapt
     * its code accordingly, and call thread_yield himself.
     */

    cpu_trap_restore (it_status);
    a000:	e1a00008 	mov	r0, r8
    a004:	ebfffef6 	bl	9be4 <cpu_trap_restore>
    return status == DNA_INVOKE_SCHEDULER ? DNA_NO_ERROR : DNA_OK;
    a008:	e2440003 	sub	r0, r4, #3
    a00c:	e16f0f10 	clz	r0, r0
    a010:	e1a002a0 	lsr	r0, r0, #5
    a014:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    a018:	0000fffc 	.word	0x0000fffc
    a01c:	0007b040 	.word	0x0007b040
    a020:	0000fcfe 	.word	0x0000fcfe
    a024:	0000d15a 	.word	0x0000d15a
    a028:	0000ffff 	.word	0x0000ffff
    a02c:	ffffface 	.word	0xffffface

0000a030 <lock_acquire>:
 * Lock a spin lock using the cpu_test_and_set function from the HAL.
 *
 * SOURCE
 */

{
    a030:	e92d4010 	push	{r4, lr}
    a034:	e1a04000 	mov	r4, r0
    a038:	e24dd008 	sub	sp, sp, #8
  while (cpu_test_and_set (lock) == 1);
    a03c:	e1a00004 	mov	r0, r4
    a040:	ebffff0c 	bl	9c78 <cpu_test_and_set>
    a044:	e3500001 	cmp	r0, #1
    a048:	0afffffb 	beq	a03c <lock_acquire+0xc>
  cpu_cache_sync ();
    a04c:	e3a03000 	mov	r3, #0
    a050:	e58d3004 	str	r3, [sp, #4]
    a054:	e59d3004 	ldr	r3, [sp, #4]
    a058:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
}
    a05c:	e28dd008 	add	sp, sp, #8
    a060:	e8bd8010 	pop	{r4, pc}

0000a064 <thread_idle>:
 * Ignored.
 *
 * SOURCE
 */

{
    a064:	e92d4008 	push	{r3, lr}
  while (true)
  {
    cpu_power_wake_on_interrupt ();
    a068:	ebfffedf 	bl	9bec <cpu_power_wake_on_interrupt>
  }
    a06c:	eafffffd 	b	a068 <thread_idle+0x4>

0000a070 <semaphore_get_info>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    a070:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (info != NULL, DNA_BAD_ARGUMENT);
    a074:	e2516000 	subs	r6, r1, #0
    a078:	0a000005 	beq	a094 <semaphore_get_info+0x24>
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);
    a07c:	e1a05820 	lsr	r5, r0, #16
    a080:	e3550a01 	cmp	r5, #4096	; 0x1000
    a084:	e1a04000 	mov	r4, r0
    a088:	3a000003 	bcc	a09c <semaphore_get_info+0x2c>
    a08c:	e59f00a4 	ldr	r0, [pc, #164]	; a138 <semaphore_get_info+0xc8>
  {
    lock_release (& semaphore_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    a090:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (info != NULL, DNA_BAD_ARGUMENT);
    a094:	e59f00a0 	ldr	r0, [pc, #160]	; a13c <semaphore_get_info+0xcc>
    a098:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
    a09c:	ebfffe97 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& semaphore_pool . lock);
    a0a0:	e59f7098 	ldr	r7, [pc, #152]	; a140 <semaphore_get_info+0xd0>
     * Look for the semaphore with ID id
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
    a0a4:	e0855205 	add	r5, r5, r5, lsl #4
    a0a8:	e1a05105 	lsl	r5, r5, #2
  watch (status_t)
  {
    ensure (info != NULL, DNA_BAD_ARGUMENT);
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
    a0ac:	e1a08000 	mov	r8, r0
     * Look for the semaphore with ID id
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
    a0b0:	e0879005 	add	r9, r7, r5
  {
    ensure (info != NULL, DNA_BAD_ARGUMENT);
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& semaphore_pool . lock);
    a0b4:	e1a00007 	mov	r0, r7
    a0b8:	ebffffdc 	bl	a030 <lock_acquire>
     * Look for the semaphore with ID id
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
    a0bc:	e599300c 	ldr	r3, [r9, #12]
    a0c0:	e1540003 	cmp	r4, r3
    a0c4:	0a000005 	beq	a0e0 <semaphore_get_info+0x70>
    return status;
  }

  rescue (invalid_semaphore)
  {
    lock_release (& semaphore_pool . lock);
    a0c8:	e1a00007 	mov	r0, r7
    a0cc:	eb000a88 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    a0d0:	e1a00008 	mov	r0, r8
    a0d4:	ebfffec2 	bl	9be4 <cpu_trap_restore>
    leave;
    a0d8:	e59f0058 	ldr	r0, [pc, #88]	; a138 <semaphore_get_info+0xc8>
    a0dc:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);

    lock_acquire (& sem -> lock);
    a0e0:	e2854010 	add	r4, r5, #16
    a0e4:	e0844007 	add	r4, r4, r7
    a0e8:	e1a00004 	mov	r0, r4
    a0ec:	ebffffcf 	bl	a030 <lock_acquire>
    lock_release (& semaphore_pool . lock);
    a0f0:	e1a00007 	mov	r0, r7
    a0f4:	eb000a7e 	bl	caf4 <lock_release>
//    cpu_dcache_inv_addr(&sem -> info.tokens);

dna_log(VERBOSE_LEVEL, "ID(%d:%d) TOKEN(%d)",
        sem -> id . s . value, sem -> id . s . index, sem -> info . tokens);

    cpu_dcache_invalidate((void*)&sem->info, sizeof(port_info_t));
    a0f8:	e2890024 	add	r0, r9, #36	; 0x24
    a0fc:	e3a0102c 	mov	r1, #44	; 0x2c
    a100:	ebfffeea 	bl	9cb0 <cpu_dcache_invalidate>
    *info = sem -> info;
    a104:	e289c024 	add	ip, r9, #36	; 0x24
    a108:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
    a10c:	e8a6000f 	stmia	r6!, {r0, r1, r2, r3}
    a110:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
    a114:	e8a6000f 	stmia	r6!, {r0, r1, r2, r3}
    a118:	e89c0003 	ldm	ip, {r0, r1}
    a11c:	e8860003 	stm	r6, {r0, r1}

    lock_release (& sem -> lock);
    a120:	e1a00004 	mov	r0, r4
    a124:	eb000a72 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    a128:	e1a00008 	mov	r0, r8
    a12c:	ebfffeac 	bl	9be4 <cpu_trap_restore>

    return status;
    a130:	e3a00000 	mov	r0, #0
    a134:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
    a138:	0000fdff 	.word	0x0000fdff
    a13c:	0000fffc 	.word	0x0000fffc
    a140:	00035610 	.word	0x00035610

0000a144 <port_find>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    a144:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
  int32_t index;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (p_id != NULL, DNA_BAD_ARGUMENT);
    a148:	e2518000 	subs	r8, r1, #0
    a14c:	0a00001a 	beq	a1bc <port_find+0x78>
    a150:	e1a06000 	mov	r6, r0

    /*
     * Find the requested port.
     */

    it_status = cpu_trap_mask_and_backup();
    a154:	ebfffe69 	bl	9b00 <cpu_trap_mask_and_backup>
    a158:	e1a09000 	mov	r9, r0
    lock_acquire (& port_pool . lock);
    a15c:	e59f0078 	ldr	r0, [pc, #120]	; a1dc <port_find+0x98>
    a160:	ebffffb2 	bl	a030 <lock_acquire>

    for (index = 0; index < DNA_MAX_PORT; index += 1)
    a164:	e3a04000 	mov	r4, #0
    a168:	e59f5070 	ldr	r5, [pc, #112]	; a1e0 <port_find+0x9c>
    a16c:	ea000003 	b	a180 <port_find+0x3c>
    a170:	e2844001 	add	r4, r4, #1
    a174:	e3540040 	cmp	r4, #64	; 0x40
    a178:	e2855068 	add	r5, r5, #104	; 0x68
    a17c:	0a000010 	beq	a1c4 <port_find+0x80>
    {
      port = & port_pool . data[index];

      if (port != NULL && dna_strcmp (name, port -> info . name) == 0)
    a180:	e1a00006 	mov	r0, r6
    a184:	e1a01005 	mov	r1, r5
    a188:	ebfffce8 	bl	9530 <dna_strcmp>
    a18c:	e2507000 	subs	r7, r0, #0
    a190:	1afffff6 	bne	a170 <port_find+0x2c>
      {
        *p_id = port -> id . raw;
    a194:	e3a02068 	mov	r2, #104	; 0x68
    a198:	e59f003c 	ldr	r0, [pc, #60]	; a1dc <port_find+0x98>
    a19c:	e0240492 	mla	r4, r2, r4, r0
    a1a0:	e594200c 	ldr	r2, [r4, #12]
    a1a4:	e5882000 	str	r2, [r8]
        break;
      }
    }

    lock_release (& port_pool . lock);
    a1a8:	eb000a51 	bl	caf4 <lock_release>
    cpu_trap_restore (it_status);
    a1ac:	e1a00009 	mov	r0, r9
    a1b0:	ebfffe8b 	bl	9be4 <cpu_trap_restore>

    ensure (index != DNA_MAX_PORT, DNA_UNKNOWN_PORT);
    return DNA_OK;
    a1b4:	e1a00007 	mov	r0, r7
    a1b8:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  int32_t index;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (p_id != NULL, DNA_BAD_ARGUMENT);
    a1bc:	e59f0020 	ldr	r0, [pc, #32]	; a1e4 <port_find+0xa0>
    a1c0:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
        *p_id = port -> id . raw;
        break;
      }
    }

    lock_release (& port_pool . lock);
    a1c4:	e59f0010 	ldr	r0, [pc, #16]	; a1dc <port_find+0x98>
    a1c8:	eb000a49 	bl	caf4 <lock_release>
    cpu_trap_restore (it_status);
    a1cc:	e1a00009 	mov	r0, r9
    a1d0:	ebfffe83 	bl	9be4 <cpu_trap_restore>

    ensure (index != DNA_MAX_PORT, DNA_UNKNOWN_PORT);
    a1d4:	e59f000c 	ldr	r0, [pc, #12]	; a1e8 <port_find+0xa4>
    return DNA_OK;
  }
}
    a1d8:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
    a1dc:	00079628 	.word	0x00079628
    a1e0:	00079640 	.word	0x00079640
    a1e4:	0000fffc 	.word	0x0000fffc
    a1e8:	0000fafd 	.word	0x0000fafd

0000a1ec <lock_destroy>:
 *
 * SOURCE
 */

{
  *lock = -1;
    a1ec:	e3e03000 	mvn	r3, #0
    a1f0:	e5803000 	str	r3, [r0]
    a1f4:	e12fff1e 	bx	lr

0000a1f8 <interrupt_handler_inspector>:
  isr_t service = isr;
  interrupt_handler_t handler = va_arg (list, interrupt_handler_t);

  watch (bool)
  {
    ensure (isr != NULL, false);
    a1f8:	e3500000 	cmp	r0, #0
 * SOURCE
 */

{
  isr_t service = isr;
  interrupt_handler_t handler = va_arg (list, interrupt_handler_t);
    a1fc:	e5913000 	ldr	r3, [r1]

  watch (bool)
  {
    ensure (isr != NULL, false);
    a200:	012fff1e 	bxeq	lr
    ensure (handler != NULL, false);
    a204:	e3530000 	cmp	r3, #0

    return service -> handler == (interrupt_handler_t)handler;
    a208:	15900004 	ldrne	r0, [r0, #4]
    a20c:	10630000 	rsbne	r0, r3, r0
    a210:	116f0f10 	clzne	r0, r0
    a214:	11a002a0 	lsrne	r0, r0, #5
  isr_t service = isr;
  interrupt_handler_t handler = va_arg (list, interrupt_handler_t);

  watch (bool)
  {
    ensure (isr != NULL, false);
    a218:	01a00003 	moveq	r0, r3
    ensure (handler != NULL, false);

    return service -> handler == (interrupt_handler_t)handler;
  }
}
    a21c:	e12fff1e 	bx	lr

0000a220 <semaphore_destroy>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    a220:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  bool smart_to_reschedule = false;
  status_t status;

  watch (status_t)
  {
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);
    a224:	e1a04820 	lsr	r4, r0, #16
    a228:	e3540a01 	cmp	r4, #4096	; 0x1000
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    a22c:	e1a06000 	mov	r6, r0
    a230:	e24dd00c 	sub	sp, sp, #12
  bool smart_to_reschedule = false;
  status_t status;

  watch (status_t)
  {
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);
    a234:	259f012c 	ldrcs	r0, [pc, #300]	; a368 <semaphore_destroy+0x148>
    a238:	3a000001 	bcc	a244 <semaphore_destroy+0x24>
  {
    lock_release (& semaphore_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    a23c:	e28dd00c 	add	sp, sp, #12
    a240:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

  watch (status_t)
  {
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
    a244:	ebfffe2d 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& semaphore_pool . lock);
    a248:	e59f511c 	ldr	r5, [pc, #284]	; a36c <semaphore_destroy+0x14c>
     * remove its entry from the pool.
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
    a24c:	e1a08204 	lsl	r8, r4, #4
    a250:	e0887004 	add	r7, r8, r4

  watch (status_t)
  {
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
    a254:	e1a09000 	mov	r9, r0
     * remove its entry from the pool.
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
    a258:	e1a07107 	lsl	r7, r7, #2
  watch (status_t)
  {
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& semaphore_pool . lock);
    a25c:	e1a00005 	mov	r0, r5
    a260:	ebffff72 	bl	a030 <lock_acquire>
     * remove its entry from the pool.
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
    a264:	e0853007 	add	r3, r5, r7
    a268:	e593200c 	ldr	r2, [r3, #12]
    a26c:	e1560002 	cmp	r6, r2
    a270:	0a000006 	beq	a290 <semaphore_destroy+0x70>
    return smart_to_reschedule ? DNA_INVOKE_SCHEDULER : DNA_OK;
  }

  rescue (invalid_semaphore)
  {
    lock_release (& semaphore_pool . lock);
    a274:	e1a00005 	mov	r0, r5
    a278:	eb000a1d 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    a27c:	e1a00009 	mov	r0, r9
    a280:	ebfffe57 	bl	9be4 <cpu_trap_restore>
    leave;
    a284:	e59f00dc 	ldr	r0, [pc, #220]	; a368 <semaphore_destroy+0x148>
  }
}
    a288:	e28dd00c 	add	sp, sp, #12
    a28c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);

    semaphore_pool . data[sid . s . index] . id . s . value = 0;
    a290:	e3a02000 	mov	r2, #0

    lock_acquire (& sem -> waiting_queue . lock);
    a294:	e2837014 	add	r7, r3, #20
    a298:	e1a00007 	mov	r0, r7

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);

    semaphore_pool . data[sid . s . index] . id . s . value = 0;
    a29c:	e1c320bc 	strh	r2, [r3, #12]
{
  thread_t thread = NULL;
  semaphore_t sem = NULL;
  semaphore_id_t sid = { .raw = id };
  interrupt_status_t it_status = 0;
  bool smart_to_reschedule = false;
    a2a0:	e58d2004 	str	r2, [sp, #4]
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);

    semaphore_pool . data[sid . s . index] . id . s . value = 0;

    lock_acquire (& sem -> waiting_queue . lock);
    a2a4:	ebffff61 	bl	a030 <lock_acquire>
    lock_release (& semaphore_pool . lock);
    a2a8:	e1a00005 	mov	r0, r5

    while ((thread = queue_rem (& sem -> waiting_queue)) != NULL)
    {
      lock_acquire (& thread -> lock);

      thread -> info . sem_tokens = 0;
    a2ac:	e59d6004 	ldr	r6, [sp, #4]
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);

    semaphore_pool . data[sid . s . index] . id . s . value = 0;

    lock_acquire (& sem -> waiting_queue . lock);
    lock_release (& semaphore_pool . lock);
    a2b0:	eb000a0f 	bl	caf4 <lock_release>
    /*
     * Reschedule each waiting thread, and
     * reset its information.
     */

    while ((thread = queue_rem (& sem -> waiting_queue)) != NULL)
    a2b4:	ea000001 	b	a2c0 <semaphore_destroy+0xa0>

        smart_to_reschedule = smart_to_reschedule ||
          (status == DNA_INVOKE_SCHEDULER);
      }

      lock_release (& thread -> lock);
    a2b8:	e1a0000a 	mov	r0, sl
    a2bc:	eb000a0c 	bl	caf4 <lock_release>
    /*
     * Reschedule each waiting thread, and
     * reset its information.
     */

    while ((thread = queue_rem (& sem -> waiting_queue)) != NULL)
    a2c0:	e1a00007 	mov	r0, r7
    a2c4:	ebfff9a5 	bl	8960 <queue_rem>
    a2c8:	e250b000 	subs	fp, r0, #0
    {
      lock_acquire (& thread -> lock);
    a2cc:	e28ba014 	add	sl, fp, #20
    /*
     * Reschedule each waiting thread, and
     * reset its information.
     */

    while ((thread = queue_rem (& sem -> waiting_queue)) != NULL)
    a2d0:	0a000012 	beq	a320 <semaphore_destroy+0x100>
    {
      lock_acquire (& thread -> lock);
    a2d4:	e1a0000a 	mov	r0, sl
    a2d8:	ebffff54 	bl	a030 <lock_acquire>

      thread -> info . sem_tokens = 0;
      thread -> info . resource = DNA_NO_RESOURCE;
      thread -> info . resource_id = -1;

      if (thread -> info . status == DNA_THREAD_WAITING)
    a2dc:	e59f308c 	ldr	r3, [pc, #140]	; a370 <semaphore_destroy+0x150>
    a2e0:	e1db15b0 	ldrh	r1, [fp, #80]	; 0x50

    while ((thread = queue_rem (& sem -> waiting_queue)) != NULL)
    {
      lock_acquire (& thread -> lock);

      thread -> info . sem_tokens = 0;
    a2e4:	e58b604c 	str	r6, [fp, #76]	; 0x4c
      thread -> info . resource = DNA_NO_RESOURCE;
      thread -> info . resource_id = -1;

      if (thread -> info . status == DNA_THREAD_WAITING)
    a2e8:	e1510003 	cmp	r1, r3
    {
      lock_acquire (& thread -> lock);

      thread -> info . sem_tokens = 0;
      thread -> info . resource = DNA_NO_RESOURCE;
      thread -> info . resource_id = -1;
    a2ec:	e3e03000 	mvn	r3, #0
    while ((thread = queue_rem (& sem -> waiting_queue)) != NULL)
    {
      lock_acquire (& thread -> lock);

      thread -> info . sem_tokens = 0;
      thread -> info . resource = DNA_NO_RESOURCE;
    a2f0:	e5cb6052 	strb	r6, [fp, #82]	; 0x52
      thread -> info . resource_id = -1;
    a2f4:	e58b3054 	str	r3, [fp, #84]	; 0x54

      if (thread -> info . status == DNA_THREAD_WAITING)
    a2f8:	1affffee 	bne	a2b8 <semaphore_destroy+0x98>
      {
        thread -> info . status = DNA_THREAD_READY;
    a2fc:	e59f3070 	ldr	r3, [pc, #112]	; a374 <semaphore_destroy+0x154>
        status = scheduler_dispatch (thread);
    a300:	e1a0000b 	mov	r0, fp
      thread -> info . resource = DNA_NO_RESOURCE;
      thread -> info . resource_id = -1;

      if (thread -> info . status == DNA_THREAD_WAITING)
      {
        thread -> info . status = DNA_THREAD_READY;
    a304:	e1cb35b0 	strh	r3, [fp, #80]	; 0x50
        status = scheduler_dispatch (thread);
    a308:	eb0006a2 	bl	bd98 <scheduler_dispatch>

        smart_to_reschedule = smart_to_reschedule ||
    a30c:	e59d3004 	ldr	r3, [sp, #4]
    a310:	e3500003 	cmp	r0, #3
    a314:	03833001 	orreq	r3, r3, #1
    a318:	e58d3004 	str	r3, [sp, #4]
    a31c:	eaffffe5 	b	a2b8 <semaphore_destroy+0x98>
      }

      lock_release (& thread -> lock);
    }

    lock_acquire (& semaphore_pool . lock);
    a320:	e59f0044 	ldr	r0, [pc, #68]	; a36c <semaphore_destroy+0x14c>
    a324:	ebffff41 	bl	a030 <lock_acquire>
    lock_release (& sem -> waiting_queue . lock);
    a328:	e1a00007 	mov	r0, r7
    a32c:	eb0009f0 	bl	caf4 <lock_release>
    /*
     * Look for the semaphore with ID id. If found,
     * remove its entry from the pool.
     */

    sem = & semaphore_pool . data[sid . s . index];
    a330:	e0881004 	add	r1, r8, r4
    a334:	e0851101 	add	r1, r5, r1, lsl #2

    /*
     * Add the freed semaphore into the semaphore queue and return.
     */

    queue_add (& semaphore_pool . semaphore, sem);
    a338:	e2811008 	add	r1, r1, #8
    a33c:	e59f0034 	ldr	r0, [pc, #52]	; a378 <semaphore_destroy+0x158>
    a340:	ebfffc4f 	bl	9484 <queue_add>

    lock_release (& semaphore_pool . lock);
    a344:	e59f0020 	ldr	r0, [pc, #32]	; a36c <semaphore_destroy+0x14c>
    a348:	eb0009e9 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    a34c:	e1a00009 	mov	r0, r9
    a350:	ebfffe23 	bl	9be4 <cpu_trap_restore>

    return smart_to_reschedule ? DNA_INVOKE_SCHEDULER : DNA_OK;
    a354:	e59d3004 	ldr	r3, [sp, #4]
    a358:	e3530000 	cmp	r3, #0
    a35c:	13a00003 	movne	r0, #3
    a360:	03a00000 	moveq	r0, #0
    a364:	eaffffb4 	b	a23c <semaphore_destroy+0x1c>
    a368:	0000fdff 	.word	0x0000fdff
    a36c:	00035610 	.word	0x00035610
    a370:	0000b10c 	.word	0x0000b10c
    a374:	ffffface 	.word	0xffffface
    a378:	00079618 	.word	0x00079618

0000a37c <ipi_handler>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    a37c:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    a380:	e24dd00c 	sub	sp, sp, #12
    a384:	e1a08001 	mov	r8, r1
    a388:	e1a09000 	mov	r9, r0
  queue_t * queue;
  bool invoke_scheduler = false;
  thread_t target = (thread_t)cookie;
    a38c:	e58d1004 	str	r1, [sp, #4]
  int32_t cpuid = cpu_mp_id ();
    a390:	ebfffe30 	bl	9c58 <cpu_mp_id>
  status_t status = DNA_OK;
  thread_t self = cpu_pool . cpu[cpuid] . current_thread;
    a394:	e1a07180 	lsl	r7, r0, #3
    a398:	e0873000 	add	r3, r7, r0
    a39c:	e1a03303 	lsl	r3, r3, #6
    a3a0:	e59f4130 	ldr	r4, [pc, #304]	; a4d8 <ipi_handler+0x15c>

{
  queue_t * queue;
  bool invoke_scheduler = false;
  thread_t target = (thread_t)cookie;
  int32_t cpuid = cpu_mp_id ();
    a3a4:	e1a05000 	mov	r5, r0
  status_t status = DNA_OK;
  thread_t self = cpu_pool . cpu[cpuid] . current_thread;
  lock_release (& cpu_pool . cpu[cpuid] . ipi_lock);
    a3a8:	e2830018 	add	r0, r3, #24
    a3ac:	e0840000 	add	r0, r4, r0
  queue_t * queue;
  bool invoke_scheduler = false;
  thread_t target = (thread_t)cookie;
  int32_t cpuid = cpu_mp_id ();
  status_t status = DNA_OK;
  thread_t self = cpu_pool . cpu[cpuid] . current_thread;
    a3b0:	e0843003 	add	r3, r4, r3
    a3b4:	e593622c 	ldr	r6, [r3, #556]	; 0x22c
  lock_release (& cpu_pool . cpu[cpuid] . ipi_lock);
    a3b8:	eb0009cd 	bl	caf4 <lock_release>

  switch (command)
    a3bc:	e2493cff 	sub	r3, r9, #65280	; 0xff00
    a3c0:	e24330fc 	sub	r3, r3, #252	; 0xfc
    a3c4:	e3530003 	cmp	r3, #3
    a3c8:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
    a3cc:	ea00003f 	b	a4d0 <ipi_handler+0x154>
    a3d0:	0000a44c 	.word	0x0000a44c
    a3d4:	0000a438 	.word	0x0000a438
    a3d8:	0000a424 	.word	0x0000a424
    a3dc:	0000a3e0 	.word	0x0000a3e0
    case DNA_IPI_DISPATCH :
      {
dna_log(VERBOSE_LEVEL, "%d DISPATCH %s",
            cpu_mp_id (), target -> info . name);

        if (self == cpu_pool . cpu[cpuid] . idle_thread)
    a3e0:	e0873005 	add	r3, r7, r5
    a3e4:	e0843303 	add	r3, r4, r3, lsl #6
    a3e8:	e5933230 	ldr	r3, [r3, #560]	; 0x230
    a3ec:	e1530006 	cmp	r3, r6
    a3f0:	0a00001a 	beq	a460 <ipi_handler+0xe4>
        {
          invoke_scheduler = true;
        }
        else if (scheduler_dispatch (target) == DNA_INVOKE_SCHEDULER)
    a3f4:	e59d0004 	ldr	r0, [sp, #4]
    a3f8:	eb000666 	bl	bd98 <scheduler_dispatch>
    a3fc:	e3500003 	cmp	r0, #3
{
  queue_t * queue;
  bool invoke_scheduler = false;
  thread_t target = (thread_t)cookie;
  int32_t cpuid = cpu_mp_id ();
  status_t status = DNA_OK;
    a400:	13a00000 	movne	r0, #0

        if (self == cpu_pool . cpu[cpuid] . idle_thread)
        {
          invoke_scheduler = true;
        }
        else if (scheduler_dispatch (target) == DNA_INVOKE_SCHEDULER)
    a404:	1a000009 	bne	a430 <ipi_handler+0xb4>
        {
          status = scheduler_elect (& target, false);
    a408:	e28d0004 	add	r0, sp, #4
    a40c:	e3a01000 	mov	r1, #0
    a410:	eb000626 	bl	bcb0 <scheduler_elect>
dna_log(PANIC_LEVEL, "Unknown command: %d", command);
      status = DNA_ERROR;
      break;
  }

  if (invoke_scheduler && target != NULL)
    a414:	e59f30c0 	ldr	r3, [pc, #192]	; a4dc <ipi_handler+0x160>
    a418:	e1500003 	cmp	r0, r3
    a41c:	1a000010 	bne	a464 <ipi_handler+0xe8>
    a420:	ea000002 	b	a430 <ipi_handler+0xb4>
      {
        int32_t thread_id = (int32_t) cookie;

dna_log(VERBOSE_LEVEL, "%d SUSPEND %d", cpuid, thread_id);

        thread_suspend (thread_id);
    a424:	e1a00008 	mov	r0, r8
    a428:	eb000bac 	bl	d2e0 <thread_suspend>
{
  queue_t * queue;
  bool invoke_scheduler = false;
  thread_t target = (thread_t)cookie;
  int32_t cpuid = cpu_mp_id ();
  status_t status = DNA_OK;
    a42c:	e3a00000 	mov	r0, #0

    status = scheduler_switch (target, queue);
  }

  return status;
}
    a430:	e28dd00c 	add	sp, sp, #12
    a434:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
      {
        int32_t id = (int32_t) cookie;

dna_log(VERBOSE_LEVEL, "%d ENABLE %d", cpuid, id);

        cpu_trap_enable (id);
    a438:	e1a00008 	mov	r0, r8
    a43c:	ebfffddc 	bl	9bb4 <cpu_trap_enable>
{
  queue_t * queue;
  bool invoke_scheduler = false;
  thread_t target = (thread_t)cookie;
  int32_t cpuid = cpu_mp_id ();
  status_t status = DNA_OK;
    a440:	e3a00000 	mov	r0, #0

    status = scheduler_switch (target, queue);
  }

  return status;
}
    a444:	e28dd00c 	add	sp, sp, #12
    a448:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
      {
        int32_t id = (int32_t) cookie;

dna_log(VERBOSE_LEVEL, "%d DISABLE %d", cpuid, id);

        cpu_trap_disable (id);
    a44c:	e1a00008 	mov	r0, r8
    a450:	ebfffdb0 	bl	9b18 <cpu_trap_disable>
{
  queue_t * queue;
  bool invoke_scheduler = false;
  thread_t target = (thread_t)cookie;
  int32_t cpuid = cpu_mp_id ();
  status_t status = DNA_OK;
    a454:	e3a00000 	mov	r0, #0

    status = scheduler_switch (target, queue);
  }

  return status;
}
    a458:	e28dd00c 	add	sp, sp, #12
    a45c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
{
  queue_t * queue;
  bool invoke_scheduler = false;
  thread_t target = (thread_t)cookie;
  int32_t cpuid = cpu_mp_id ();
  status_t status = DNA_OK;
    a460:	e3a00000 	mov	r0, #0
dna_log(PANIC_LEVEL, "Unknown command: %d", command);
      status = DNA_ERROR;
      break;
  }

  if (invoke_scheduler && target != NULL)
    a464:	e59d3004 	ldr	r3, [sp, #4]
    a468:	e3530000 	cmp	r3, #0
    a46c:	0affffef 	beq	a430 <ipi_handler+0xb4>
  {
    lock_acquire (& self -> lock);
    self -> info . status = DNA_THREAD_READY;

    if (self != cpu_pool . cpu[cpuid] . idle_thread)
    a470:	e0875005 	add	r5, r7, r5
    a474:	e0844305 	add	r4, r4, r5, lsl #6
      break;
  }

  if (invoke_scheduler && target != NULL)
  {
    lock_acquire (& self -> lock);
    a478:	e2860014 	add	r0, r6, #20
    a47c:	ebfffeeb 	bl	a030 <lock_acquire>
    self -> info . status = DNA_THREAD_READY;

    if (self != cpu_pool . cpu[cpuid] . idle_thread)
    a480:	e5942230 	ldr	r2, [r4, #560]	; 0x230
  }

  if (invoke_scheduler && target != NULL)
  {
    lock_acquire (& self -> lock);
    self -> info . status = DNA_THREAD_READY;
    a484:	e59f3054 	ldr	r3, [pc, #84]	; a4e0 <ipi_handler+0x164>

    if (self != cpu_pool . cpu[cpuid] . idle_thread)
    a488:	e1520006 	cmp	r2, r6
  }

  if (invoke_scheduler && target != NULL)
  {
    lock_acquire (& self -> lock);
    self -> info . status = DNA_THREAD_READY;
    a48c:	e1c635b0 	strh	r3, [r6, #80]	; 0x50
      lock_acquire (& queue -> lock);
      queue_add (queue, self);
    }
    else
    {
      queue = NULL;
    a490:	03a04000 	moveq	r4, #0
  if (invoke_scheduler && target != NULL)
  {
    lock_acquire (& self -> lock);
    self -> info . status = DNA_THREAD_READY;

    if (self != cpu_pool . cpu[cpuid] . idle_thread)
    a494:	0a000008 	beq	a4bc <ipi_handler+0x140>
    {
      queue = & scheduler . queue[self -> info . affinity];
    a498:	e5964048 	ldr	r4, [r6, #72]	; 0x48
    a49c:	e59f3040 	ldr	r3, [pc, #64]	; a4e4 <ipi_handler+0x168>
    a4a0:	e0834204 	add	r4, r3, r4, lsl #4
    a4a4:	e2844004 	add	r4, r4, #4

      lock_acquire (& queue -> lock);
    a4a8:	e1a00004 	mov	r0, r4
    a4ac:	ebfffedf 	bl	a030 <lock_acquire>
      queue_add (queue, self);
    a4b0:	e1a00004 	mov	r0, r4
    a4b4:	e1a01006 	mov	r1, r6
    a4b8:	ebfffbf1 	bl	9484 <queue_add>
    else
    {
      queue = NULL;
    }

    status = scheduler_switch (target, queue);
    a4bc:	e1a01004 	mov	r1, r4
    a4c0:	e59d0004 	ldr	r0, [sp, #4]
    a4c4:	eb0007ff 	bl	c4c8 <scheduler_switch>
  }

  return status;
}
    a4c8:	e28dd00c 	add	sp, sp, #12
    a4cc:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
        break;
      }

    default :
dna_log(PANIC_LEVEL, "Unknown command: %d", command);
      status = DNA_ERROR;
    a4d0:	e59f0010 	ldr	r0, [pc, #16]	; a4e8 <ipi_handler+0x16c>
    a4d4:	eaffffd5 	b	a430 <ipi_handler+0xb4>
    a4d8:	0007e458 	.word	0x0007e458
    a4dc:	0000fcfd 	.word	0x0000fcfd
    a4e0:	ffffface 	.word	0xffffface
    a4e4:	00080870 	.word	0x00080870
    a4e8:	0000ffff 	.word	0x0000ffff

0000a4ec <thread_yield>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    a4ec:	e92d4070 	push	{r4, r5, r6, lr}
  status_t status = DNA_OK;
  thread_t thread = NULL, self = NULL;
    a4f0:	e3a05000 	mov	r5, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    a4f4:	e24dd008 	sub	sp, sp, #8
  status_t status = DNA_OK;
  thread_t thread = NULL, self = NULL;
    a4f8:	e28d4008 	add	r4, sp, #8
    a4fc:	e5245004 	str	r5, [r4, #-4]!
  queue_t * queue = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup();
    a500:	ebfffd7e 	bl	9b00 <cpu_trap_mask_and_backup>
    a504:	e1a06000 	mov	r6, r0
    self = cpu_pool . cpu[cpu_mp_id()] . current_thread;
    a508:	ebfffdd2 	bl	9c58 <cpu_mp_id>
    a50c:	e59f3094 	ldr	r3, [pc, #148]	; a5a8 <thread_yield+0xbc>
    a510:	e0802180 	add	r2, r0, r0, lsl #3
    a514:	e0833302 	add	r3, r3, r2, lsl #6

    status = scheduler_elect (& thread, false);
    a518:	e1a01005 	mov	r1, r5
    a51c:	e1a00004 	mov	r0, r4
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup();
    self = cpu_pool . cpu[cpu_mp_id()] . current_thread;
    a520:	e593522c 	ldr	r5, [r3, #556]	; 0x22c

    status = scheduler_elect (& thread, false);
    a524:	eb0005e1 	bl	bcb0 <scheduler_elect>
    ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);
    a528:	e59f207c 	ldr	r2, [pc, #124]	; a5ac <thread_yield+0xc0>
    a52c:	e59f307c 	ldr	r3, [pc, #124]	; a5b0 <thread_yield+0xc4>
  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup();
    self = cpu_pool . cpu[cpu_mp_id()] . current_thread;

    status = scheduler_elect (& thread, false);
    a530:	e1a04000 	mov	r4, r0
    ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);
    a534:	e1500003 	cmp	r0, r3
    a538:	11500002 	cmpne	r0, r2
    a53c:	0a000016 	beq	a59c <thread_yield+0xb0>

    if (status != DNA_NO_AVAILABLE_THREAD)
    a540:	e59f306c 	ldr	r3, [pc, #108]	; a5b4 <thread_yield+0xc8>
    a544:	e1500003 	cmp	r0, r3
    a548:	0a000011 	beq	a594 <thread_yield+0xa8>
    {
      lock_acquire (& self -> lock);
    a54c:	e2850014 	add	r0, r5, #20
    a550:	ebfffeb6 	bl	a030 <lock_acquire>
      self -> info . status = DNA_THREAD_READY;
      queue = & scheduler . queue[self -> info . affinity];
    a554:	e59f205c 	ldr	r2, [pc, #92]	; a5b8 <thread_yield+0xcc>
    a558:	e5954048 	ldr	r4, [r5, #72]	; 0x48
    ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);

    if (status != DNA_NO_AVAILABLE_THREAD)
    {
      lock_acquire (& self -> lock);
      self -> info . status = DNA_THREAD_READY;
    a55c:	e59f3058 	ldr	r3, [pc, #88]	; a5bc <thread_yield+0xd0>
      queue = & scheduler . queue[self -> info . affinity];
    a560:	e0824204 	add	r4, r2, r4, lsl #4
    a564:	e2844004 	add	r4, r4, #4

      lock_acquire (& queue -> lock);
    a568:	e1a00004 	mov	r0, r4
    ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);

    if (status != DNA_NO_AVAILABLE_THREAD)
    {
      lock_acquire (& self -> lock);
      self -> info . status = DNA_THREAD_READY;
    a56c:	e1c535b0 	strh	r3, [r5, #80]	; 0x50
      queue = & scheduler . queue[self -> info . affinity];

      lock_acquire (& queue -> lock);
    a570:	ebfffeae 	bl	a030 <lock_acquire>
      queue_add (queue, self);
    a574:	e1a00004 	mov	r0, r4
    a578:	e1a01005 	mov	r1, r5
    a57c:	ebfffbc0 	bl	9484 <queue_add>

      status = scheduler_switch (thread, queue);
    a580:	e1a01004 	mov	r1, r4
    a584:	e59d0004 	ldr	r0, [sp, #4]
    a588:	eb0007ce 	bl	c4c8 <scheduler_switch>
      ensure (status == DNA_OK, status);
    a58c:	e2504000 	subs	r4, r0, #0
    a590:	1a000001 	bne	a59c <thread_yield+0xb0>
    }

    cpu_trap_restore(it_status);
    a594:	e1a00006 	mov	r0, r6
    a598:	ebfffd91 	bl	9be4 <cpu_trap_restore>
    return status;
  }
}
    a59c:	e1a00004 	mov	r0, r4
    a5a0:	e28dd008 	add	sp, sp, #8
    a5a4:	e8bd8070 	pop	{r4, r5, r6, pc}
    a5a8:	0007e458 	.word	0x0007e458
    a5ac:	0000fffc 	.word	0x0000fffc
    a5b0:	0000ffff 	.word	0x0000ffff
    a5b4:	0000fcfd 	.word	0x0000fcfd
    a5b8:	00080870 	.word	0x00080870
    a5bc:	ffffface 	.word	0xffffface

0000a5c0 <core_create>:
 * * !DNA_OK: error creating something
 *
 * SOURCE
 */

{
    a5c0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

    thread_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_GROUP; i += 1)
    {
      for (int32_t j = 0; j < DNA_MAX_THREAD; j += 1)
    a5c4:	e3a05000 	mov	r5, #0
  {
    /*
     * Initialize the thread pool.
     */

    thread_pool . counter = 1;
    a5c8:	e3a03001 	mov	r3, #1
    {
      for (int32_t j = 0; j < DNA_MAX_THREAD; j += 1)
      {
        thread = & thread_pool . data[i][j];

        thread -> id . s . group = i;
    a5cc:	e1a06005 	mov	r6, r5
  {
    /*
     * Initialize the thread pool.
     */

    thread_pool . counter = 1;
    a5d0:	e59f7298 	ldr	r7, [pc, #664]	; a870 <core_create+0x2b0>
 * * !DNA_OK: error creating something
 *
 * SOURCE
 */

{
    a5d4:	e24dd0ac 	sub	sp, sp, #172	; 0xac
  {
    /*
     * Initialize the thread pool.
     */

    thread_pool . counter = 1;
    a5d8:	e1c730b4 	strh	r3, [r7, #4]
    a5dc:	e2874008 	add	r4, r7, #8
      for (int32_t j = 0; j < DNA_MAX_THREAD; j += 1)
      {
        thread = & thread_pool . data[i][j];

        thread -> id . s . group = i;
        thread -> id . s . index = j;
    a5e0:	e5c4501f 	strb	r5, [r4, #31]

        queue_add (& thread_pool . thread[i], thread);
    a5e4:	e1a01004 	mov	r1, r4
    {
      for (int32_t j = 0; j < DNA_MAX_THREAD; j += 1)
      {
        thread = & thread_pool . data[i][j];

        thread -> id . s . group = i;
    a5e8:	e5c4601e 	strb	r6, [r4, #30]
        thread -> id . s . index = j;

        queue_add (& thread_pool . thread[i], thread);
    a5ec:	e59f0280 	ldr	r0, [pc, #640]	; a874 <core_create+0x2b4>

    thread_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_GROUP; i += 1)
    {
      for (int32_t j = 0; j < DNA_MAX_THREAD; j += 1)
    a5f0:	e2855001 	add	r5, r5, #1
        thread = & thread_pool . data[i][j];

        thread -> id . s . group = i;
        thread -> id . s . index = j;

        queue_add (& thread_pool . thread[i], thread);
    a5f4:	ebfffba2 	bl	9484 <queue_add>

    thread_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_GROUP; i += 1)
    {
      for (int32_t j = 0; j < DNA_MAX_THREAD; j += 1)
    a5f8:	e3550040 	cmp	r5, #64	; 0x40
    a5fc:	e28440d0 	add	r4, r4, #208	; 0xd0
    a600:	1afffff6 	bne	a5e0 <core_create+0x20>

    /*
     * Initialize the alarm pool.
     */

    alarm_pool . counter = 1;
    a604:	e3a03001 	mov	r3, #1

    for (int32_t i = 0; i < DNA_MAX_ALARM; i += 1)
    a608:	e3a04000 	mov	r4, #0

    /*
     * Initialize the alarm pool.
     */

    alarm_pool . counter = 1;
    a60c:	e59f5264 	ldr	r5, [pc, #612]	; a878 <core_create+0x2b8>
    a610:	e1c530b4 	strh	r3, [r5, #4]
    a614:	e285500e 	add	r5, r5, #14

    for (int32_t i = 0; i < DNA_MAX_ALARM; i += 1)
    {
      alarm_pool . data[i] . id . s . index = i;
    a618:	e1a01005 	mov	r1, r5
      queue_add (& alarm_pool . alarm, & alarm_pool . data[i]);
    a61c:	e59f0258 	ldr	r0, [pc, #600]	; a87c <core_create+0x2bc>

    alarm_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_ALARM; i += 1)
    {
      alarm_pool . data[i] . id . s . index = i;
    a620:	e04140b6 	strh	r4, [r1], #-6
     * Initialize the alarm pool.
     */

    alarm_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_ALARM; i += 1)
    a624:	e2844001 	add	r4, r4, #1
    {
      alarm_pool . data[i] . id . s . index = i;
      queue_add (& alarm_pool . alarm, & alarm_pool . data[i]);
    a628:	ebfffb95 	bl	9484 <queue_add>
     * Initialize the alarm pool.
     */

    alarm_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_ALARM; i += 1)
    a62c:	e3540040 	cmp	r4, #64	; 0x40
    a630:	e2855040 	add	r5, r5, #64	; 0x40
    a634:	1afffff7 	bne	a618 <core_create+0x58>

    /*
     * Initialize the semaphore pool.
     */

    semaphore_pool . counter = 1;
    a638:	e3a03001 	mov	r3, #1

    for (int32_t i = 0; i < DNA_MAX_SEM; i += 1)
    a63c:	e3a04000 	mov	r4, #0

    /*
     * Initialize the semaphore pool.
     */

    semaphore_pool . counter = 1;
    a640:	e59f5238 	ldr	r5, [pc, #568]	; a880 <core_create+0x2c0>
    a644:	e1c530b4 	strh	r3, [r5, #4]
    a648:	e285500e 	add	r5, r5, #14

    for (int32_t i = 0; i < DNA_MAX_SEM; i += 1)
    {
      semaphore_pool . data[i] . id . s . index = i;
    a64c:	e1a01005 	mov	r1, r5
      queue_add (& semaphore_pool . semaphore, & semaphore_pool . data[i]);
    a650:	e59f022c 	ldr	r0, [pc, #556]	; a884 <core_create+0x2c4>

    semaphore_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_SEM; i += 1)
    {
      semaphore_pool . data[i] . id . s . index = i;
    a654:	e04140b6 	strh	r4, [r1], #-6
     * Initialize the semaphore pool.
     */

    semaphore_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_SEM; i += 1)
    a658:	e2844001 	add	r4, r4, #1
    {
      semaphore_pool . data[i] . id . s . index = i;
      queue_add (& semaphore_pool . semaphore, & semaphore_pool . data[i]);
    a65c:	ebfffb88 	bl	9484 <queue_add>
     * Initialize the semaphore pool.
     */

    semaphore_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_SEM; i += 1)
    a660:	e3540a01 	cmp	r4, #4096	; 0x1000
    a664:	e2855044 	add	r5, r5, #68	; 0x44
    a668:	1afffff7 	bne	a64c <core_create+0x8c>

    /*
     * Initialize the port pool.
     */

    port_pool . counter = 1;
    a66c:	e3a03001 	mov	r3, #1

    for (int32_t i = 0; i < DNA_MAX_PORT; i += 1)
    a670:	e3a04000 	mov	r4, #0

    /*
     * Initialize the port pool.
     */

    port_pool . counter = 1;
    a674:	e59f520c 	ldr	r5, [pc, #524]	; a888 <core_create+0x2c8>
    a678:	e1c530b4 	strh	r3, [r5, #4]
    a67c:	e285500e 	add	r5, r5, #14

    for (int32_t i = 0; i < DNA_MAX_PORT; i += 1)
    {
      port_pool . data[i] . id . s . index = i;
    a680:	e1a01005 	mov	r1, r5
      queue_add (& port_pool . port, & port_pool . data[i]);
    a684:	e59f0200 	ldr	r0, [pc, #512]	; a88c <core_create+0x2cc>

    port_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_PORT; i += 1)
    {
      port_pool . data[i] . id . s . index = i;
    a688:	e04140b6 	strh	r4, [r1], #-6
     * Initialize the port pool.
     */

    port_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_PORT; i += 1)
    a68c:	e2844001 	add	r4, r4, #1
    {
      port_pool . data[i] . id . s . index = i;
      queue_add (& port_pool . port, & port_pool . data[i]);
    a690:	ebfffb7b 	bl	9484 <queue_add>
     * Initialize the port pool.
     */

    port_pool . counter = 1;

    for (int32_t i = 0; i < DNA_MAX_PORT; i += 1)
    a694:	e3540040 	cmp	r4, #64	; 0x40
    a698:	e2855068 	add	r5, r5, #104	; 0x68
    a69c:	1afffff7 	bne	a680 <core_create+0xc0>

    /*
     * Initialize the CPUs
     */

    DNA_THREAD_SET_DEFAULTS (thread_info);
    a6a0:	e28d6058 	add	r6, sp, #88	; 0x58
    a6a4:	e59f11e4 	ldr	r1, [pc, #484]	; a890 <core_create+0x2d0>
    a6a8:	e1a00006 	mov	r0, r6
    a6ac:	ebfffc0d 	bl	96e8 <dna_strcpy>
    a6b0:	e3a09902 	mov	r9, #32768	; 0x8000
    a6b4:	e3a01000 	mov	r1, #0
    a6b8:	e3e00000 	mvn	r0, #0
    a6bc:	e3a02000 	mov	r2, #0
    a6c0:	e3a03000 	mov	r3, #0
    a6c4:	e59fc1c8 	ldr	ip, [pc, #456]	; a894 <core_create+0x2d4>
    a6c8:	e59f41c8 	ldr	r4, [pc, #456]	; a898 <core_create+0x2d8>

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
    a6cc:	e1a05001 	mov	r5, r1

    /*
     * Initialize the CPUs
     */

    DNA_THREAD_SET_DEFAULTS (thread_info);
    a6d0:	e58d1078 	str	r1, [sp, #120]	; 0x78
    a6d4:	e58d107c 	str	r1, [sp, #124]	; 0x7c
    a6d8:	e58d1084 	str	r1, [sp, #132]	; 0x84
    a6dc:	e5cd108a 	strb	r1, [sp, #138]	; 0x8a
    a6e0:	e58d10a0 	str	r1, [sp, #160]	; 0xa0
       * Create the Idle thread
       */

      dna_strcpy (thread_info . name, "IdleThread");
      thread_info . affinity = cpu_i;
      thread_info . stack_base = NULL;
    a6e4:	e1a0a001 	mov	sl, r1

    /*
     * Initialize the CPUs
     */

    DNA_THREAD_SET_DEFAULTS (thread_info);
    a6e8:	e58d0080 	str	r0, [sp, #128]	; 0x80
    a6ec:	e58d008c 	str	r0, [sp, #140]	; 0x8c
    a6f0:	e1cd29f0 	strd	r2, [sp, #144]	; 0x90
    a6f4:	e1cd29f8 	strd	r2, [sp, #152]	; 0x98
    a6f8:	e58d90a4 	str	r9, [sp, #164]	; 0xa4
    a6fc:	e1cdc8b8 	strh	ip, [sp, #136]	; 0x88

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
    a700:	e1a0b004 	mov	fp, r4
    a704:	e28d8054 	add	r8, sp, #84	; 0x54
    a708:	ea000020 	b	a790 <core_create+0x1d0>

      /*
       * Create the Idle thread
       */

      dna_strcpy (thread_info . name, "IdleThread");
    a70c:	ebfffbf5 	bl	96e8 <dna_strcpy>
      thread_info . affinity = cpu_i;
      thread_info . stack_base = NULL;
      thread_info . stack_size = DNA_IDLE_STACK_SIZE;

      status = thread_create (thread_idle, NULL, thread_info, & tid . raw);
    a710:	e28d1060 	add	r1, sp, #96	; 0x60
    a714:	e3a02048 	mov	r2, #72	; 0x48
    a718:	e1a0000d 	mov	r0, sp
      /*
       * Create the Idle thread
       */

      dna_strcpy (thread_info . name, "IdleThread");
      thread_info . affinity = cpu_i;
    a71c:	e58d5080 	str	r5, [sp, #128]	; 0x80
      thread_info . stack_base = NULL;
    a720:	e58da0a0 	str	sl, [sp, #160]	; 0xa0
      thread_info . stack_size = DNA_IDLE_STACK_SIZE;
    a724:	e58d90a4 	str	r9, [sp, #164]	; 0xa4

      status = thread_create (thread_idle, NULL, thread_info, & tid . raw);
    a728:	e58d8048 	str	r8, [sp, #72]	; 0x48
    a72c:	eb001507 	bl	fb50 <memcpy>
    a730:	e896000c 	ldm	r6, {r2, r3}
    a734:	e59f0160 	ldr	r0, [pc, #352]	; a89c <core_create+0x2dc>
    a738:	e3a01000 	mov	r1, #0
    a73c:	eb000213 	bl	af90 <thread_create>
      check (cpu_initialize, status == DNA_OK, DNA_ERROR);
    a740:	e3500000 	cmp	r0, #0
    a744:	1a00002b 	bne	a7f8 <core_create+0x238>

      thread = & thread_pool . data[tid . s . group][tid . s . index];
    a748:	e3a02b0d 	mov	r2, #13312	; 0x3400
    a74c:	e3a010d0 	mov	r1, #208	; 0xd0
    a750:	e5dd3056 	ldrb	r3, [sp, #86]	; 0x56
      /*
       * Deal with the new thread
       */

      cpu -> id = cpu_i;
      cpu -> status = DNA_CPU_DISABLED;
    a754:	e59f0144 	ldr	r0, [pc, #324]	; a8a0 <core_create+0x2e0>
      thread_info . stack_size = DNA_IDLE_STACK_SIZE;

      status = thread_create (thread_idle, NULL, thread_info, & tid . raw);
      check (cpu_initialize, status == DNA_OK, DNA_ERROR);

      thread = & thread_pool . data[tid . s . group][tid . s . index];
    a758:	e0030392 	mul	r3, r2, r3
    a75c:	e5dd2057 	ldrb	r2, [sp, #87]	; 0x57

      /*
       * Deal with the new thread
       */

      cpu -> id = cpu_i;
    a760:	e58b500c 	str	r5, [fp, #12]
      thread_info . stack_size = DNA_IDLE_STACK_SIZE;

      status = thread_create (thread_idle, NULL, thread_info, & tid . raw);
      check (cpu_initialize, status == DNA_OK, DNA_ERROR);

      thread = & thread_pool . data[tid . s . group][tid . s . index];
    a764:	e0223291 	mla	r2, r1, r2, r3
    a768:	e2823008 	add	r3, r2, #8
    a76c:	e0873003 	add	r3, r7, r3
       * Deal with the new thread
       */

      cpu -> id = cpu_i;
      cpu -> status = DNA_CPU_DISABLED;
      cpu -> idle_thread = thread;
    a770:	e58b3230 	str	r3, [fp, #560]	; 0x230
      cpu -> current_thread = thread;
    a774:	e58b322c 	str	r3, [fp, #556]	; 0x22c

      status = thread_create (thread_idle, NULL, thread_info, & tid . raw);
      check (cpu_initialize, status == DNA_OK, DNA_ERROR);

      thread = & thread_pool . data[tid . s . group][tid . s . index];
      thread -> info . status = DNA_THREAD_READY;
    a778:	e59f3124 	ldr	r3, [pc, #292]	; a8a4 <core_create+0x2e4>
    a77c:	e0872002 	add	r2, r7, r2
      /*
       * Deal with the new thread
       */

      cpu -> id = cpu_i;
      cpu -> status = DNA_CPU_DISABLED;
    a780:	e1cb01b0 	strh	r0, [fp, #16]
     * Initialize the CPUs
     */

    DNA_THREAD_SET_DEFAULTS (thread_info);

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
    a784:	e2855001 	add	r5, r5, #1

      status = thread_create (thread_idle, NULL, thread_info, & tid . raw);
      check (cpu_initialize, status == DNA_OK, DNA_ERROR);

      thread = & thread_pool . data[tid . s . group][tid . s . index];
      thread -> info . status = DNA_THREAD_READY;
    a788:	e1c235b8 	strh	r3, [r2, #88]	; 0x58
    a78c:	e28bbd09 	add	fp, fp, #576	; 0x240
     * Initialize the CPUs
     */

    DNA_THREAD_SET_DEFAULTS (thread_info);

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
    a790:	ebfffd63 	bl	9d24 <cpu_mp_count>
    a794:	e1550000 	cmp	r5, r0

      /*
       * Create the Idle thread
       */

      dna_strcpy (thread_info . name, "IdleThread");
    a798:	e59f1108 	ldr	r1, [pc, #264]	; a8a8 <core_create+0x2e8>
    a79c:	e1a00006 	mov	r0, r6
     * Initialize the CPUs
     */

    DNA_THREAD_SET_DEFAULTS (thread_info);

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
    a7a0:	baffffd9 	blt	a70c <core_create+0x14c>
    /*
     * Create the main application thread. For now,
     * the application resides in the kernel.
     */

    dna_strcpy (thread_info . name, "Main");
    a7a4:	e59f1100 	ldr	r1, [pc, #256]	; a8ac <core_create+0x2ec>
    a7a8:	ebfffbce 	bl	96e8 <dna_strcpy>
    thread_info . affinity = DNA_NO_AFFINITY;
    thread_info . stack_base = NULL;
    a7ac:	e3a05000 	mov	r5, #0
     * Create the main application thread. For now,
     * the application resides in the kernel.
     */

    dna_strcpy (thread_info . name, "Main");
    thread_info . affinity = DNA_NO_AFFINITY;
    a7b0:	e3e0c000 	mvn	ip, #0
    thread_info . stack_base = NULL;
    thread_info . stack_size = DNA_THREAD_STACK_SIZE;
    a7b4:	e3a03902 	mov	r3, #32768	; 0x8000

    status = thread_create (APP_ENTRY_POINT, NULL, thread_info, & tid . raw);
    a7b8:	e59f20f0 	ldr	r2, [pc, #240]	; a8b0 <core_create+0x2f0>
    a7bc:	e28d1060 	add	r1, sp, #96	; 0x60
    a7c0:	e5929000 	ldr	r9, [r2]
    a7c4:	e1a0000d 	mov	r0, sp
    a7c8:	e3a02048 	mov	r2, #72	; 0x48
     * Create the main application thread. For now,
     * the application resides in the kernel.
     */

    dna_strcpy (thread_info . name, "Main");
    thread_info . affinity = DNA_NO_AFFINITY;
    a7cc:	e58dc080 	str	ip, [sp, #128]	; 0x80
    thread_info . stack_base = NULL;
    thread_info . stack_size = DNA_THREAD_STACK_SIZE;
    a7d0:	e58d30a4 	str	r3, [sp, #164]	; 0xa4

    status = thread_create (APP_ENTRY_POINT, NULL, thread_info, & tid . raw);
    a7d4:	e58d8048 	str	r8, [sp, #72]	; 0x48
     * the application resides in the kernel.
     */

    dna_strcpy (thread_info . name, "Main");
    thread_info . affinity = DNA_NO_AFFINITY;
    thread_info . stack_base = NULL;
    a7d8:	e58d50a0 	str	r5, [sp, #160]	; 0xa0
    thread_info . stack_size = DNA_THREAD_STACK_SIZE;

    status = thread_create (APP_ENTRY_POINT, NULL, thread_info, & tid . raw);
    a7dc:	eb0014db 	bl	fb50 <memcpy>
    a7e0:	e896000c 	ldm	r6, {r2, r3}
    a7e4:	e1a00009 	mov	r0, r9
    a7e8:	e1a01005 	mov	r1, r5
    a7ec:	eb0001e7 	bl	af90 <thread_create>
    check (cpu_initialize, status == DNA_OK, DNA_ERROR);
    a7f0:	e3500000 	cmp	r0, #0
    a7f4:	0a000011 	beq	a840 <core_create+0x280>

  rescue(cpu_initialize)
  {
    thread_t idle_thread = NULL;

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
    a7f8:	e3a05000 	mov	r5, #0

      if (idle_thread != NULL)
      {
        thread_destroy (idle_thread -> id . raw);

        cpu_pool . cpu[cpu_i] . idle_thread = NULL;
    a7fc:	e1a06005 	mov	r6, r5

  rescue(cpu_initialize)
  {
    thread_t idle_thread = NULL;

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
    a800:	ea000008 	b	a828 <core_create+0x268>
    {
      idle_thread = cpu_pool . cpu[cpu_i] . idle_thread;
    a804:	e5943230 	ldr	r3, [r4, #560]	; 0x230

  rescue(cpu_initialize)
  {
    thread_t idle_thread = NULL;

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
    a808:	e2855001 	add	r5, r5, #1
    {
      idle_thread = cpu_pool . cpu[cpu_i] . idle_thread;

      if (idle_thread != NULL)
    a80c:	e3530000 	cmp	r3, #0
    a810:	0a000003 	beq	a824 <core_create+0x264>
      {
        thread_destroy (idle_thread -> id . raw);
    a814:	e593001c 	ldr	r0, [r3, #28]
    a818:	eb0007df 	bl	c79c <thread_destroy>

        cpu_pool . cpu[cpu_i] . idle_thread = NULL;
    a81c:	e5846230 	str	r6, [r4, #560]	; 0x230
        cpu_pool . cpu[cpu_i] . current_thread = NULL;
    a820:	e584622c 	str	r6, [r4, #556]	; 0x22c
    a824:	e2844d09 	add	r4, r4, #576	; 0x240

  rescue(cpu_initialize)
  {
    thread_t idle_thread = NULL;

    for (int32_t cpu_i = 0; cpu_i < cpu_mp_count (); cpu_i++)
    a828:	ebfffd3d 	bl	9d24 <cpu_mp_count>
    a82c:	e1550000 	cmp	r5, r0
    a830:	bafffff3 	blt	a804 <core_create+0x244>
        cpu_pool . cpu[cpu_i] . idle_thread = NULL;
        cpu_pool . cpu[cpu_i] . current_thread = NULL;
      }
    }

    leave;
    a834:	e59f0078 	ldr	r0, [pc, #120]	; a8b4 <core_create+0x2f4>
  }
}
    a838:	e28dd0ac 	add	sp, sp, #172	; 0xac
    a83c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    thread_info . stack_size = DNA_THREAD_STACK_SIZE;

    status = thread_create (APP_ENTRY_POINT, NULL, thread_info, & tid . raw);
    check (cpu_initialize, status == DNA_OK, DNA_ERROR);

    thread = & thread_pool . data[tid . s . group][tid . s . index];
    a840:	e3a0cb0d 	mov	ip, #13312	; 0x3400
    a844:	e3a010d0 	mov	r1, #208	; 0xd0
    a848:	e5dd2056 	ldrb	r2, [sp, #86]	; 0x56
    a84c:	e5dd3057 	ldrb	r3, [sp, #87]	; 0x57
    a850:	e002029c 	mul	r2, ip, r2
    a854:	e0232391 	mla	r3, r1, r3, r2
    a858:	e2833008 	add	r3, r3, #8
    a85c:	e0877003 	add	r7, r7, r3
    cpu_pool . cpu[0] . current_thread = thread;
    a860:	e59f3030 	ldr	r3, [pc, #48]	; a898 <core_create+0x2d8>
    a864:	e583722c 	str	r7, [r3, #556]	; 0x22c
      }
    }

    leave;
  }
}
    a868:	e28dd0ac 	add	sp, sp, #172	; 0xac
    a86c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a870:	0007b040 	.word	0x0007b040
    a874:	0007e448 	.word	0x0007e448
    a878:	00080988 	.word	0x00080988
    a87c:	00081990 	.word	0x00081990
    a880:	00035610 	.word	0x00035610
    a884:	00079618 	.word	0x00079618
    a888:	00079628 	.word	0x00079628
    a88c:	0007b030 	.word	0x0007b030
    a890:	000232fc 	.word	0x000232fc
    a894:	ffffd15a 	.word	0xffffd15a
    a898:	0007e458 	.word	0x0007e458
    a89c:	0000a064 	.word	0x0000a064
    a8a0:	ffffdead 	.word	0xffffdead
    a8a4:	ffffface 	.word	0xffffface
    a8a8:	00024678 	.word	0x00024678
    a8ac:	00024684 	.word	0x00024684
    a8b0:	00025504 	.word	0x00025504
    a8b4:	0000ffff 	.word	0x0000ffff

0000a8b8 <thread_snooze>:
 *
 * SOURCE
 */

{
  int32_t alarm_id = -1;
    a8b8:	e3e02000 	mvn	r2, #0
  uint32_t current_cpuid = 0;
  thread_t self = NULL;
  thread_t target = NULL;
    a8bc:	e3a03000 	mov	r3, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    a8c0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
    a8c4:	e24dd014 	sub	sp, sp, #20
    a8c8:	e1a04000 	mov	r4, r0
    a8cc:	e1a05001 	mov	r5, r1
  int32_t alarm_id = -1;
    a8d0:	e58d2008 	str	r2, [sp, #8]
  uint32_t current_cpuid = 0;
  thread_t self = NULL;
  thread_t target = NULL;
    a8d4:	e58d300c 	str	r3, [sp, #12]
  {
    /*
     * Disable interrupts and get current information
     */

    it_status = cpu_trap_mask_and_backup ();
    a8d8:	ebfffc88 	bl	9b00 <cpu_trap_mask_and_backup>
    a8dc:	e1a07000 	mov	r7, r0

    current_cpuid = cpu_mp_id();
    a8e0:	ebfffcdc 	bl	9c58 <cpu_mp_id>
    self = cpu_pool . cpu[current_cpuid] . current_thread;
    a8e4:	e59f30cc 	ldr	r3, [pc, #204]	; a9b8 <thread_snooze+0x100>
    a8e8:	e0800180 	add	r0, r0, r0, lsl #3
    a8ec:	e0833300 	add	r3, r3, r0, lsl #6
    a8f0:	e593622c 	ldr	r6, [r3, #556]	; 0x22c

    /*
     * Create the snooze alarm and elect a new thread.
     */

    status = alarm_create (value, DNA_ONE_SHOT_RELATIVE_ALARM,
    a8f4:	e28d3008 	add	r3, sp, #8
    a8f8:	e1a00004 	mov	r0, r4
    a8fc:	e58d3004 	str	r3, [sp, #4]
    a900:	e1a01005 	mov	r1, r5
    a904:	e58d6000 	str	r6, [sp]
    a908:	e3a02002 	mov	r2, #2
    a90c:	e59f30a8 	ldr	r3, [pc, #168]	; a9bc <thread_snooze+0x104>
    a910:	eb000036 	bl	a9f0 <alarm_create>
        thread_alarm, self, & alarm_id);
    check (alarm_error, status == DNA_OK, status);
    a914:	e2504000 	subs	r4, r0, #0
    a918:	1a000021 	bne	a9a4 <thread_snooze+0xec>

    status = scheduler_elect (& target, true);
    a91c:	e3a01001 	mov	r1, #1
    a920:	e28d000c 	add	r0, sp, #12
    a924:	eb0004e1 	bl	bcb0 <scheduler_elect>
    ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);
    a928:	e59f4090 	ldr	r4, [pc, #144]	; a9c0 <thread_snooze+0x108>
    a92c:	e59f1090 	ldr	r1, [pc, #144]	; a9c4 <thread_snooze+0x10c>
    a930:	e1500001 	cmp	r0, r1
    a934:	11500004 	cmpne	r0, r4
    a938:	03a05001 	moveq	r5, #1
    a93c:	13a05000 	movne	r5, #0
    a940:	1a000001 	bne	a94c <thread_snooze+0x94>
  rescue (alarm_error)
  {
    cpu_trap_restore (it_status);
    leave;
  }
}
    a944:	e28dd014 	add	sp, sp, #20
    a948:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

    /*
     * Update self information and switch context.
     */

    lock_acquire (& self -> lock);
    a94c:	e2860014 	add	r0, r6, #20
    a950:	ebfffdb6 	bl	a030 <lock_acquire>
    self -> info . status = DNA_THREAD_SLEEPING;
    a954:	e59f306c 	ldr	r3, [pc, #108]	; a9c8 <thread_snooze+0x110>

    status = scheduler_switch (target, NULL);
    a958:	e1a01005 	mov	r1, r5
    /*
     * Update self information and switch context.
     */

    lock_acquire (& self -> lock);
    self -> info . status = DNA_THREAD_SLEEPING;
    a95c:	e1c635b0 	strh	r3, [r6, #80]	; 0x50

    status = scheduler_switch (target, NULL);
    a960:	e59d000c 	ldr	r0, [sp, #12]
    a964:	eb0006d7 	bl	c4c8 <scheduler_switch>
    ensure (status == DNA_OK, status);
    a968:	e3500000 	cmp	r0, #0
    a96c:	1afffff4 	bne	a944 <thread_snooze+0x8c>
    /*
     * Cancel the alarm, just in case we came back from
     * sleeping after a thread_suspend/thread_resume combination.
     */

    status = alarm_destroy (alarm_id);
    a970:	e59d0008 	ldr	r0, [sp, #8]
    a974:	eb000765 	bl	c710 <alarm_destroy>
    ensure (status != DNA_NO_TIMER && status != DNA_BAD_ARGUMENT, status);
    a978:	e59f304c 	ldr	r3, [pc, #76]	; a9cc <thread_snooze+0x114>
    /*
     * Cancel the alarm, just in case we came back from
     * sleeping after a thread_suspend/thread_resume combination.
     */

    status = alarm_destroy (alarm_id);
    a97c:	e1a05000 	mov	r5, r0
    ensure (status != DNA_NO_TIMER && status != DNA_BAD_ARGUMENT, status);
    a980:	e1500003 	cmp	r0, r3
    a984:	11500004 	cmpne	r0, r4
    a988:	0affffed 	beq	a944 <thread_snooze+0x8c>

    cpu_trap_restore (it_status);
    a98c:	e1a00007 	mov	r0, r7
    a990:	ebfffc93 	bl	9be4 <cpu_trap_restore>
    return (status == DNA_OK) ? DNA_INTERRUPTED : DNA_OK;
    a994:	e3550000 	cmp	r5, #0
    a998:	e59f0030 	ldr	r0, [pc, #48]	; a9d0 <thread_snooze+0x118>
    a99c:	13a00000 	movne	r0, #0
    a9a0:	eaffffe7 	b	a944 <thread_snooze+0x8c>
  }

  rescue (alarm_error)
  {
    cpu_trap_restore (it_status);
    a9a4:	e1a00007 	mov	r0, r7
    a9a8:	ebfffc8d 	bl	9be4 <cpu_trap_restore>
    leave;
    a9ac:	e1a00004 	mov	r0, r4
  }
}
    a9b0:	e28dd014 	add	sp, sp, #20
    a9b4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
    a9b8:	0007e458 	.word	0x0007e458
    a9bc:	0000bff0 	.word	0x0000bff0
    a9c0:	0000fffc 	.word	0x0000fffc
    a9c4:	0000ffff 	.word	0x0000ffff
    a9c8:	ffffbedd 	.word	0xffffbedd
    a9cc:	0000fbff 	.word	0x0000fbff
    a9d0:	0000fff9 	.word	0x0000fff9

0000a9d4 <core_destroy>:
 * SOURCE
 */

{
  return DNA_NOT_IMPLEMENTED;
}
    a9d4:	e59f0000 	ldr	r0, [pc]	; a9dc <core_destroy+0x8>
    a9d8:	e12fff1e 	bx	lr
    a9dc:	0000fffe 	.word	0x0000fffe

0000a9e0 <lock_create>:
 *
 * SOURCE
 */

{
  *lock = 0;
    a9e0:	e3a03000 	mov	r3, #0
    a9e4:	e5803000 	str	r3, [r0]
  return DNA_OK;
}
    a9e8:	e1a00003 	mov	r0, r3
    a9ec:	e12fff1e 	bx	lr

0000a9f0 <alarm_create>:
 * * DNA_OK: alarm created
 *
 * SOURCE
 */

{
    a9f0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    a9f4:	e1a06000 	mov	r6, r0
    a9f8:	e1a07001 	mov	r7, r1
  cpu_t * cpu = NULL;
  int16_t index;
  int32_t current_cpuid = 0;
  interrupt_status_t it_status;
  alarm_t new_alarm = NULL, old_alarm = NULL;
  bigtime_t start_time = 0, updated_time = 0, updated_quantum = 0;
    a9fc:	e3a04000 	mov	r4, #0
    aa00:	e3a05000 	mov	r5, #0
 * * DNA_OK: alarm created
 *
 * SOURCE
 */

{
    aa04:	e24dd024 	sub	sp, sp, #36	; 0x24
  alarm_t new_alarm = NULL, old_alarm = NULL;
  bigtime_t start_time = 0, updated_time = 0, updated_quantum = 0;
  
  watch (status_t)
  {
    ensure (quantum != 0, DNA_BAD_ARGUMENT);
    aa08:	e1961007 	orrs	r1, r6, r7
  cpu_t * cpu = NULL;
  int16_t index;
  int32_t current_cpuid = 0;
  interrupt_status_t it_status;
  alarm_t new_alarm = NULL, old_alarm = NULL;
  bigtime_t start_time = 0, updated_time = 0, updated_quantum = 0;
    aa0c:	e1cd41f0 	strd	r4, [sp, #16]
    aa10:	e1cd41f8 	strd	r4, [sp, #24]
  
  watch (status_t)
  {
    ensure (quantum != 0, DNA_BAD_ARGUMENT);
    aa14:	059f0274 	ldreq	r0, [pc, #628]	; ac90 <alarm_create+0x2a0>
    aa18:	1a000001 	bne	aa24 <alarm_create+0x34>
  rescue (bad_quantum)
  {
    cpu_trap_restore(it_status);
    leave;
  }
}
    aa1c:	e28dd024 	add	sp, sp, #36	; 0x24
    aa20:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

    /*
     * Deactivate interrupts and get current information.
     */

    it_status = cpu_trap_mask_and_backup();
    aa24:	e58d3004 	str	r3, [sp, #4]
    aa28:	e1a0b002 	mov	fp, r2
    aa2c:	ebfffc33 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& alarm_pool . lock);
    aa30:	e59fa25c 	ldr	sl, [pc, #604]	; ac94 <alarm_create+0x2a4>

    /*
     * Deactivate interrupts and get current information.
     */

    it_status = cpu_trap_mask_and_backup();
    aa34:	e58d000c 	str	r0, [sp, #12]
    lock_acquire (& alarm_pool . lock);
    aa38:	e1a0000a 	mov	r0, sl
    aa3c:	ebfffd7b 	bl	a030 <lock_acquire>

    current_cpuid = cpu_mp_id ();
    aa40:	ebfffc84 	bl	9c58 <cpu_mp_id>
    aa44:	e1a09000 	mov	r9, r0
    cpu = & cpu_pool . cpu[current_cpuid];

    new_alarm = queue_rem (& alarm_pool . alarm);
    aa48:	e59f0248 	ldr	r0, [pc, #584]	; ac98 <alarm_create+0x2a8>
    aa4c:	ebfff7c3 	bl	8960 <queue_rem>
    check (no_alarm, new_alarm != NULL, DNA_NO_MORE_ALARM);
    aa50:	e2508000 	subs	r8, r0, #0
    aa54:	e59d3004 	ldr	r3, [sp, #4]
    aa58:	0a000062 	beq	abe8 <alarm_create+0x1f8>

    /*
     * Make the place clean.
     */

    index = new_alarm -> id . s . index;
    aa5c:	e1d8c0b6 	ldrh	ip, [r8, #6]
    dna_memset (new_alarm, 0, sizeof (struct _alarm));
    aa60:	e3a01000 	mov	r1, #0
    aa64:	e3a02040 	mov	r2, #64	; 0x40
    aa68:	e98d1008 	stmib	sp, {r3, ip}
    aa6c:	ebfff81c 	bl	8ae4 <dna_memset>
    /*
     * Fill in the information.
     */

    new_alarm -> id . s . index = index;
    new_alarm -> id . s . value = alarm_pool . counter;
    aa70:	e1da20b4 	ldrh	r2, [sl, #4]

    /*
     * Fill in the information.
     */

    new_alarm -> id . s . index = index;
    aa74:	e59dc008 	ldr	ip, [sp, #8]
    new_alarm -> id . s . value = alarm_pool . counter;

    alarm_pool . counter += 1;
    lock_release (& alarm_pool . lock);
    aa78:	e1a0000a 	mov	r0, sl
    /*
     * Fill in the information.
     */

    new_alarm -> id . s . index = index;
    new_alarm -> id . s . value = alarm_pool . counter;
    aa7c:	e1c820b4 	strh	r2, [r8, #4]

    /*
     * Fill in the information.
     */

    new_alarm -> id . s . index = index;
    aa80:	e1c8c0b6 	strh	ip, [r8, #6]
    new_alarm -> id . s . value = alarm_pool . counter;

    alarm_pool . counter += 1;
    aa84:	e2822001 	add	r2, r2, #1
    aa88:	e1ca20b4 	strh	r2, [sl, #4]
    lock_release (& alarm_pool . lock);
    aa8c:	eb000818 	bl	caf4 <lock_release>
     */

    new_alarm -> mode = mode;
    new_alarm -> thread_id = cpu -> current_thread -> id . raw;
    new_alarm -> cpu_id = current_cpuid;
    new_alarm -> is_invalid = false;
    aa90:	e3a01000 	mov	r1, #0
    /*
     * Set various information.
     */

    new_alarm -> mode = mode;
    new_alarm -> thread_id = cpu -> current_thread -> id . raw;
    aa94:	e59f2200 	ldr	r2, [pc, #512]	; ac9c <alarm_create+0x2ac>
    aa98:	e1a0a189 	lsl	sl, r9, #3
    aa9c:	e08a0009 	add	r0, sl, r9
    aaa0:	e0820300 	add	r0, r2, r0, lsl #6
    aaa4:	e590022c 	ldr	r0, [r0, #556]	; 0x22c
    new_alarm -> is_invalid = false;

    new_alarm -> lock = 0;
    new_alarm -> execution_time = 0;

    new_alarm -> callback = callback;
    aaa8:	e59d3004 	ldr	r3, [sp, #4]

    /*
     * Set various information.
     */

    new_alarm -> mode = mode;
    aaac:	e588b010 	str	fp, [r8, #16]
    new_alarm -> thread_id = cpu -> current_thread -> id . raw;
    aab0:	e590c01c 	ldr	ip, [r0, #28]
    new_alarm -> is_invalid = false;

    new_alarm -> lock = 0;
    new_alarm -> execution_time = 0;

    new_alarm -> callback = callback;
    aab4:	e5883038 	str	r3, [r8, #56]	; 0x38
    new_alarm -> data = data;
    aab8:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
     */

    new_alarm -> mode = mode;
    new_alarm -> thread_id = cpu -> current_thread -> id . raw;
    new_alarm -> cpu_id = current_cpuid;
    new_alarm -> is_invalid = false;
    aabc:	e5c81014 	strb	r1, [r8, #20]

    new_alarm -> lock = 0;
    aac0:	e5881018 	str	r1, [r8, #24]
    /*
     * Set various information.
     */

    new_alarm -> mode = mode;
    new_alarm -> thread_id = cpu -> current_thread -> id . raw;
    aac4:	e588c008 	str	ip, [r8, #8]
    new_alarm -> cpu_id = current_cpuid;
    aac8:	e588900c 	str	r9, [r8, #12]
    new_alarm -> is_invalid = false;

    new_alarm -> lock = 0;
    new_alarm -> execution_time = 0;
    aacc:	e1c843f0 	strd	r4, [r8, #48]	; 0x30

    new_alarm -> callback = callback;
    new_alarm -> data = data;
    aad0:	e588303c 	str	r3, [r8, #60]	; 0x3c
    /*
     * Check and compute the deadline according to the
     * alarm mode passed as parameter.
     */

    cpu_timer_get (current_cpuid, & start_time);
    aad4:	e1a00009 	mov	r0, r9
    aad8:	e28d1010 	add	r1, sp, #16
    aadc:	e58d2008 	str	r2, [sp, #8]
    aae0:	ebfffc2b 	bl	9b94 <cpu_timer_get>

    switch (mode)
    aae4:	e35b0001 	cmp	fp, #1
    aae8:	e59d2008 	ldr	r2, [sp, #8]
    aaec:	3a00000b 	bcc	ab20 <alarm_create+0x130>
    aaf0:	e35b0002 	cmp	fp, #2
    aaf4:	9a000041 	bls	ac00 <alarm_create+0x210>
    aaf8:	e35b0004 	cmp	fp, #4
    aafc:	1a000007 	bne	ab20 <alarm_create+0x130>
          break;
        }

      case DNA_ONE_SHOT_ABSOLUTE_ALARM :
        {
          check (bad_quantum, quantum > start_time, DNA_BAD_ARGUMENT);
    ab00:	e1cd01d0 	ldrd	r0, [sp, #16]
    ab04:	e1500006 	cmp	r0, r6
    ab08:	e0d13007 	sbcs	r3, r1, r7
    ab0c:	aa000048 	bge	ac34 <alarm_create+0x244>

          new_alarm -> quantum = quantum - start_time;
    ab10:	e0560000 	subs	r0, r6, r0
    ab14:	e0c71001 	sbc	r1, r7, r1
          new_alarm -> deadline = quantum;
    ab18:	e1c862f8 	strd	r6, [r8, #40]	; 0x28

      case DNA_ONE_SHOT_ABSOLUTE_ALARM :
        {
          check (bad_quantum, quantum > start_time, DNA_BAD_ARGUMENT);

          new_alarm -> quantum = quantum - start_time;
    ab1c:	e1c802f0 	strd	r0, [r8, #32]

    /*
     * Deal with the new alarm
     */

    lock_acquire (& cpu -> lock);
    ab20:	e08aa009 	add	sl, sl, r9
    ab24:	e1a0a30a 	lsl	sl, sl, #6
    ab28:	e082b00a 	add	fp, r2, sl
    ab2c:	e28bb014 	add	fp, fp, #20
    ab30:	e1a0000b 	mov	r0, fp
    ab34:	e58d2008 	str	r2, [sp, #8]
    ab38:	ebfffd3c 	bl	a030 <lock_acquire>
    old_alarm = cpu -> current_alarm;
    ab3c:	e59d2008 	ldr	r2, [sp, #8]
    ab40:	e082200a 	add	r2, r2, sl
    ab44:	e2826e23 	add	r6, r2, #560	; 0x230
    ab48:	e5967004 	ldr	r7, [r6, #4]

    if (cpu -> current_alarm == NULL ||
    ab4c:	e3570000 	cmp	r7, #0
    ab50:	0a000040 	beq	ac58 <alarm_create+0x268>
    ab54:	e1c742d8 	ldrd	r4, [r7, #40]	; 0x28
    ab58:	e1c822d8 	ldrd	r2, [r8, #40]	; 0x28
    ab5c:	e1520004 	cmp	r2, r4
    ab60:	e0d31005 	sbcs	r1, r3, r5
    ab64:	aa00002b 	bge	ac18 <alarm_create+0x228>
       * Check if we are still in the game, although
       * we spent time preparing the alarm. It should fail
       * on a 100Mhz RISC processos for an alarm < 20 usec.
       */

      cpu_timer_get (current_cpuid, & updated_time);
    ab68:	e1a00009 	mov	r0, r9
    ab6c:	e28d1018 	add	r1, sp, #24
    ab70:	ebfffc07 	bl	9b94 <cpu_timer_get>
      updated_quantum = new_alarm -> deadline - updated_time;
    ab74:	e1cd21d8 	ldrd	r2, [sp, #24]
    ab78:	e1c842d8 	ldrd	r4, [r8, #40]	; 0x28
    ab7c:	e0544002 	subs	r4, r4, r2
    ab80:	e0c55003 	sbc	r5, r5, r3
      check (short_quantum, updated_quantum > 0, DNA_ERROR);
    ab84:	e3540001 	cmp	r4, #1
    ab88:	e2d52000 	sbcs	r2, r5, #0
    ab8c:	ba00002d 	blt	ac48 <alarm_create+0x258>
       * alarm if this is necessary.
       */

      if (old_alarm != NULL)
      {
        cpu_timer_cancel (current_cpuid);
    ab90:	e1a00009 	mov	r0, r9
    ab94:	ebfffbf7 	bl	9b78 <cpu_timer_cancel>
      }

      cpu -> current_alarm = new_alarm;
      cpu_timer_set (current_cpuid, updated_quantum);
    ab98:	e1a00009 	mov	r0, r9
    ab9c:	e1a02004 	mov	r2, r4
    aba0:	e1a03005 	mov	r3, r5
      if (old_alarm != NULL)
      {
        cpu_timer_cancel (current_cpuid);
      }

      cpu -> current_alarm = new_alarm;
    aba4:	e5868004 	str	r8, [r6, #4]
      cpu_timer_set (current_cpuid, updated_quantum);
    aba8:	ebfffc10 	bl	9bf0 <cpu_timer_set>

      if (old_alarm != NULL)
      {
        queue_insert (& cpu -> alarm_queue, alarm_comparator, old_alarm);
    abac:	e59f20e8 	ldr	r2, [pc, #232]	; ac9c <alarm_create+0x2ac>
    abb0:	e28a0f8e 	add	r0, sl, #568	; 0x238
    abb4:	e0820000 	add	r0, r2, r0
    abb8:	e59f10e0 	ldr	r1, [pc, #224]	; aca0 <alarm_create+0x2b0>
    abbc:	e1a02007 	mov	r2, r7
    abc0:	ebfffb61 	bl	994c <queue_insert>

    /*
     * Unlock everything and return the alarm.
     */

    lock_release (& cpu -> lock);
    abc4:	e1a0000b 	mov	r0, fp
    abc8:	eb0007c9 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    abcc:	e59d000c 	ldr	r0, [sp, #12]
    abd0:	ebfffc03 	bl	9be4 <cpu_trap_restore>

    *aid = new_alarm -> id . raw;
    abd4:	e5983004 	ldr	r3, [r8, #4]
    abd8:	e59d104c 	ldr	r1, [sp, #76]	; 0x4c
    return DNA_OK;
    abdc:	e3a00000 	mov	r0, #0
     */

    lock_release (& cpu -> lock);
    cpu_trap_restore(it_status);

    *aid = new_alarm -> id . raw;
    abe0:	e5813000 	str	r3, [r1]
    return DNA_OK;
    abe4:	eaffff8c 	b	aa1c <alarm_create+0x2c>
  }

  rescue (no_alarm)
  {
    lock_release (& alarm_pool . lock);
    abe8:	e1a0000a 	mov	r0, sl
    abec:	eb0007c0 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    abf0:	e59d000c 	ldr	r0, [sp, #12]
    abf4:	ebfffbfa 	bl	9be4 <cpu_trap_restore>
    leave;
    abf8:	e59f00a4 	ldr	r0, [pc, #164]	; aca4 <alarm_create+0x2b4>
    abfc:	eaffff86 	b	aa1c <alarm_create+0x2c>
    {
      case DNA_PERIODIC_ALARM :
      case DNA_ONE_SHOT_RELATIVE_ALARM :
        {
          new_alarm -> quantum = quantum;
          new_alarm -> deadline = quantum + start_time;
    ac00:	e1cd01d0 	ldrd	r0, [sp, #16]
    ac04:	e0900006 	adds	r0, r0, r6
    ac08:	e0a11007 	adc	r1, r1, r7
    switch (mode)
    {
      case DNA_PERIODIC_ALARM :
      case DNA_ONE_SHOT_RELATIVE_ALARM :
        {
          new_alarm -> quantum = quantum;
    ac0c:	e1c862f0 	strd	r6, [r8, #32]
          new_alarm -> deadline = quantum + start_time;
    ac10:	e1c802f8 	strd	r0, [r8, #40]	; 0x28
          break;
    ac14:	eaffffc1 	b	ab20 <alarm_create+0x130>
    else
    {
dna_log(VERBOSE_LEVEL, "Enqueue alarm (%d:%d)",
          new_alarm -> id . s . value, new_alarm -> id . s . index);

      queue_insert (& cpu -> alarm_queue, alarm_comparator, new_alarm);
    ac18:	e59f307c 	ldr	r3, [pc, #124]	; ac9c <alarm_create+0x2ac>
    ac1c:	e28a0f8e 	add	r0, sl, #568	; 0x238
    ac20:	e0830000 	add	r0, r3, r0
    ac24:	e59f1074 	ldr	r1, [pc, #116]	; aca0 <alarm_create+0x2b0>
    ac28:	e1a02008 	mov	r2, r8
    ac2c:	ebfffb46 	bl	994c <queue_insert>
    ac30:	eaffffe3 	b	abc4 <alarm_create+0x1d4>
          break;
        }

      case DNA_ONE_SHOT_ABSOLUTE_ALARM :
        {
          check (bad_quantum, quantum > start_time, DNA_BAD_ARGUMENT);
    ac34:	e59f4054 	ldr	r4, [pc, #84]	; ac90 <alarm_create+0x2a0>
    lock_release (& cpu -> lock);
  }

  rescue (bad_quantum)
  {
    cpu_trap_restore(it_status);
    ac38:	e59d000c 	ldr	r0, [sp, #12]
    ac3c:	ebfffbe8 	bl	9be4 <cpu_trap_restore>
    leave;
    ac40:	e1a00004 	mov	r0, r4
    ac44:	eaffff74 	b	aa1c <alarm_create+0x2c>
    leave;
  }

  rescue (short_quantum)
  {
    lock_release (& cpu -> lock);
    ac48:	e1a0000b 	mov	r0, fp
    ac4c:	eb0007a8 	bl	caf4 <lock_release>
       * on a 100Mhz RISC processos for an alarm < 20 usec.
       */

      cpu_timer_get (current_cpuid, & updated_time);
      updated_quantum = new_alarm -> deadline - updated_time;
      check (short_quantum, updated_quantum > 0, DNA_ERROR);
    ac50:	e59f4050 	ldr	r4, [pc, #80]	; aca8 <alarm_create+0x2b8>
    ac54:	eafffff7 	b	ac38 <alarm_create+0x248>
       * Check if we are still in the game, although
       * we spent time preparing the alarm. It should fail
       * on a 100Mhz RISC processos for an alarm < 20 usec.
       */

      cpu_timer_get (current_cpuid, & updated_time);
    ac58:	e1a00009 	mov	r0, r9
    ac5c:	e28d1018 	add	r1, sp, #24
    ac60:	ebfffbcb 	bl	9b94 <cpu_timer_get>
      updated_quantum = new_alarm -> deadline - updated_time;
    ac64:	e1cd01d8 	ldrd	r0, [sp, #24]
    ac68:	e1c822d8 	ldrd	r2, [r8, #40]	; 0x28
    ac6c:	e0522000 	subs	r2, r2, r0
    ac70:	e0c33001 	sbc	r3, r3, r1
      check (short_quantum, updated_quantum > 0, DNA_ERROR);
    ac74:	e3520001 	cmp	r2, #1
    ac78:	e2d31000 	sbcs	r1, r3, #0
    ac7c:	bafffff1 	blt	ac48 <alarm_create+0x258>
      {
        cpu_timer_cancel (current_cpuid);
      }

      cpu -> current_alarm = new_alarm;
      cpu_timer_set (current_cpuid, updated_quantum);
    ac80:	e1a00009 	mov	r0, r9
      if (old_alarm != NULL)
      {
        cpu_timer_cancel (current_cpuid);
      }

      cpu -> current_alarm = new_alarm;
    ac84:	e5868004 	str	r8, [r6, #4]
      cpu_timer_set (current_cpuid, updated_quantum);
    ac88:	ebfffbd8 	bl	9bf0 <cpu_timer_set>
    ac8c:	eaffffcc 	b	abc4 <alarm_create+0x1d4>
    ac90:	0000fffc 	.word	0x0000fffc
    ac94:	00080988 	.word	0x00080988
    ac98:	00081990 	.word	0x00081990
    ac9c:	0007e458 	.word	0x0007e458
    aca0:	0000c27c 	.word	0x0000c27c
    aca4:	0000fbfd 	.word	0x0000fbfd
    aca8:	0000ffff 	.word	0x0000ffff

0000acac <lock_try>:
 * * DNA_OK: the lock has been taken
 *
 * SOURCE
 */

{
    acac:	e92d4030 	push	{r4, r5, lr}
    acb0:	e24dd00c 	sub	sp, sp, #12
    acb4:	e1a04001 	mov	r4, r1
    acb8:	e1a05000 	mov	r5, r0
  status_t status = DNA_OK;

  if (cpu_test_and_set (lock) == 1)
    acbc:	ebfffbed 	bl	9c78 <cpu_test_and_set>
    acc0:	e3500001 	cmp	r0, #1
    acc4:	0a000009 	beq	acf0 <lock_try+0x44>
    if (acquire) status = DNA_ERROR;
    else status = DNA_WOULD_BLOCK;
  }
  else 
  {
    if (! acquire) *lock = 0;
    acc8:	e3540000 	cmp	r4, #0
    status = DNA_OK;
    accc:	01a00004 	moveq	r0, r4
    acd0:	13a00000 	movne	r0, #0
    if (acquire) status = DNA_ERROR;
    else status = DNA_WOULD_BLOCK;
  }
  else 
  {
    if (! acquire) *lock = 0;
    acd4:	05854000 	streq	r4, [r5]
    status = DNA_OK;
  }

  cpu_cache_sync ();
    acd8:	e3a03000 	mov	r3, #0
    acdc:	e58d3004 	str	r3, [sp, #4]
    ace0:	e59d3004 	ldr	r3, [sp, #4]
    ace4:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
  return status;
}
    ace8:	e28dd00c 	add	sp, sp, #12
    acec:	e8bd8030 	pop	{r4, r5, pc}
  status_t status = DNA_OK;

  if (cpu_test_and_set (lock) == 1)
  {
    if (acquire) status = DNA_ERROR;
    else status = DNA_WOULD_BLOCK;
    acf0:	e59f300c 	ldr	r3, [pc, #12]	; ad04 <lock_try+0x58>
    acf4:	e3540000 	cmp	r4, #0
    acf8:	e59f0008 	ldr	r0, [pc, #8]	; ad08 <lock_try+0x5c>
    acfc:	01a00003 	moveq	r0, r3
    ad00:	eafffff4 	b	acd8 <lock_try+0x2c>
    ad04:	0000fdfd 	.word	0x0000fdfd
    ad08:	0000ffff 	.word	0x0000ffff

0000ad0c <port_write>:
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
    ad0c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  interrupt_status_t it_status = 0;
  int8_t * message_buffer = NULL;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
    ad10:	e1a06820 	lsr	r6, r0, #16
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
    ad14:	e24dd024 	sub	sp, sp, #36	; 0x24
  interrupt_status_t it_status = 0;
  int8_t * message_buffer = NULL;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
    ad18:	e356003f 	cmp	r6, #63	; 0x3f
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
    ad1c:	e1a08002 	mov	r8, r2
    ad20:	e1cd45d0 	ldrd	r4, [sp, #80]	; 0x50
    ad24:	e1a07000 	mov	r7, r0
    ad28:	e59d2048 	ldr	r2, [sp, #72]	; 0x48
  interrupt_status_t it_status = 0;
  int8_t * message_buffer = NULL;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
    ad2c:	9a000002 	bls	ad3c <port_write+0x30>
    if (message_buffer != NULL)
    {
      kernel_free (message_buffer);
    }

    leave;
    ad30:	e59f0248 	ldr	r0, [pc, #584]	; af80 <port_write+0x274>
  }
}
    ad34:	e28dd024 	add	sp, sp, #36	; 0x24
    ad38:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    ad3c:	e3a0b068 	mov	fp, #104	; 0x68
    ad40:	e1a0a001 	mov	sl, r1

    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
    ad44:	e58d200c 	str	r2, [sp, #12]
    ad48:	e58d3008 	str	r3, [sp, #8]
    ad4c:	ebfffb6b 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    ad50:	e00b069b 	mul	fp, fp, r6
    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);
    ad54:	e59f9228 	ldr	r9, [pc, #552]	; af84 <port_write+0x278>

    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
    ad58:	e58d0014 	str	r0, [sp, #20]
    lock_acquire (& port_pool . lock);
    ad5c:	e1a00009 	mov	r0, r9
    ad60:	ebfffcb2 	bl	a030 <lock_acquire>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    ad64:	e089100b 	add	r1, r9, fp
    ad68:	e591000c 	ldr	r0, [r1, #12]
    ad6c:	e1570000 	cmp	r7, r0
    ad70:	0a000004 	beq	ad88 <port_write+0x7c>
    leave;
  }

  rescue (bad_portid)
  {
    lock_release (& port_pool . lock);
    ad74:	e1a00009 	mov	r0, r9
    ad78:	eb00075d 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    ad7c:	e59d0014 	ldr	r0, [sp, #20]
    ad80:	ebfffb97 	bl	9be4 <cpu_trap_restore>
    ad84:	eaffffe9 	b	ad30 <port_write+0x24>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    lock_acquire (& port -> lock);
    ad88:	e28bb010 	add	fp, fp, #16
    ad8c:	e08bb009 	add	fp, fp, r9
    ad90:	e1a0000b 	mov	r0, fp
    ad94:	e58d1010 	str	r1, [sp, #16]
    ad98:	ebfffca4 	bl	a030 <lock_acquire>
    lock_release (& port_pool . lock);
    ad9c:	e1a00009 	mov	r0, r9
    ada0:	eb000753 	bl	caf4 <lock_release>

    read_sem = port -> read_sem;
    write_sem = port -> write_sem;
    ada4:	e59d1010 	ldr	r1, [sp, #16]

    lock_release (& port -> lock);
    ada8:	e1a0000b 	mov	r0, fp

    lock_acquire (& port -> lock);
    lock_release (& port_pool . lock);

    read_sem = port -> read_sem;
    write_sem = port -> write_sem;
    adac:	e591c048 	ldr	ip, [r1, #72]	; 0x48
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    lock_acquire (& port -> lock);
    lock_release (& port_pool . lock);

    read_sem = port -> read_sem;
    adb0:	e5911044 	ldr	r1, [r1, #68]	; 0x44
    write_sem = port -> write_sem;
    adb4:	e58dc018 	str	ip, [sp, #24]
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    lock_acquire (& port -> lock);
    lock_release (& port_pool . lock);

    read_sem = port -> read_sem;
    adb8:	e58d101c 	str	r1, [sp, #28]
    write_sem = port -> write_sem;

    lock_release (& port -> lock);
    adbc:	eb00074c 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    adc0:	e59d0014 	ldr	r0, [sp, #20]
    adc4:	ebfffb86 	bl	9be4 <cpu_trap_restore>

    /*
     * Acquire the write semaphore.
     */

    status = semaphore_acquire (write_sem, 1, flags, timeout);
    adc8:	e1cd40f0 	strd	r4, [sp]
    adcc:	e59d200c 	ldr	r2, [sp, #12]
    add0:	e59d0018 	ldr	r0, [sp, #24]
    add4:	e3a01001 	mov	r1, #1
    add8:	eb0001fb 	bl	b5cc <semaphore_acquire>
    ensure (status == DNA_OK, status);
    addc:	e2504000 	subs	r4, r0, #0
    ade0:	e59d3008 	ldr	r3, [sp, #8]
    ade4:	1a000028 	bne	ae8c <port_write+0x180>

    /*
     * Construct the message buffer, if necessary.
     */

    if (size != 0)
    ade8:	e3530000 	cmp	r3, #0
    adec:	0a000028 	beq	ae94 <port_write+0x188>
    {
      message_buffer = kernel_malloc (size, false);
    adf0:	e1a00003 	mov	r0, r3
    adf4:	e1a01004 	mov	r1, r4
    adf8:	eb000a3d 	bl	d6f4 <kernel_malloc>
      check (no_mem, message_buffer != NULL, DNA_OUT_OF_MEM);
    adfc:	e250c000 	subs	ip, r0, #0
    ae00:	e59d3008 	ldr	r3, [sp, #8]
    ae04:	0a000024 	beq	ae9c <port_write+0x190>

      dna_memcpy (message -> buffer, buffer, size);
    ae08:	e594000c 	ldr	r0, [r4, #12]
    ae0c:	e1a02003 	mov	r2, r3
    ae10:	e1a01008 	mov	r1, r8
    ae14:	e58d3008 	str	r3, [sp, #8]
    ae18:	e58dc010 	str	ip, [sp, #16]
    ae1c:	ebfffa38 	bl	9704 <dna_memcpy>
    ae20:	e59d3008 	ldr	r3, [sp, #8]
    ae24:	e59dc010 	ldr	ip, [sp, #16]
    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    ae28:	e3a08068 	mov	r8, #104	; 0x68
    /*
     * Get the port once again, just to make sure
     * it has not been destroyed in the meantime.
     */

    it_status = cpu_trap_mask_and_backup ();
    ae2c:	e58dc010 	str	ip, [sp, #16]
    ae30:	e58d3008 	str	r3, [sp, #8]
    ae34:	ebfffb31 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    ae38:	e0259698 	mla	r5, r8, r6, r9
     * Get the port once again, just to make sure
     * it has not been destroyed in the meantime.
     */

    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);
    ae3c:	e59f4140 	ldr	r4, [pc, #320]	; af84 <port_write+0x278>
    /*
     * Get the port once again, just to make sure
     * it has not been destroyed in the meantime.
     */

    it_status = cpu_trap_mask_and_backup ();
    ae40:	e58d0014 	str	r0, [sp, #20]
    lock_acquire (& port_pool . lock);
    ae44:	e1a00004 	mov	r0, r4
    ae48:	ebfffc78 	bl	a030 <lock_acquire>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    ae4c:	e595100c 	ldr	r1, [r5, #12]
    ae50:	e59dc010 	ldr	ip, [sp, #16]
    ae54:	e1570001 	cmp	r7, r1
    ae58:	0a000015 	beq	aeb4 <port_write+0x1a8>
    leave;
  }

  rescue (bad_portid)
  {
    lock_release (& port_pool . lock);
    ae5c:	e1a00004 	mov	r0, r4
    ae60:	e58dc010 	str	ip, [sp, #16]
    ae64:	eb000722 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    ae68:	e59d0014 	ldr	r0, [sp, #20]
    ae6c:	ebfffb5c 	bl	9be4 <cpu_trap_restore>

    if (message_buffer != NULL)
    ae70:	e59dc010 	ldr	ip, [sp, #16]
    ae74:	e35c0000 	cmp	ip, #0
    ae78:	0affffac 	beq	ad30 <port_write+0x24>
    {
      kernel_free (message_buffer);
    ae7c:	e1a0000c 	mov	r0, ip
    ae80:	eb000a50 	bl	d7c8 <kernel_free>
    }

    leave;
    ae84:	e59f00f4 	ldr	r0, [pc, #244]	; af80 <port_write+0x274>
    ae88:	eaffffa9 	b	ad34 <port_write+0x28>
    ae8c:	e1a00004 	mov	r0, r4
    ae90:	eaffffa7 	b	ad34 <port_write+0x28>
  port_t port = NULL;
  port_id_t pid = { .raw = id };
  message_t message = NULL;
  status_t status;
  interrupt_status_t it_status = 0;
  int8_t * message_buffer = NULL;
    ae94:	e1a0c003 	mov	ip, r3
    ae98:	eaffffe2 	b	ae28 <port_write+0x11c>
    return DNA_OK;
  }

  rescue (no_mem)
  {
    semaphore_release (write_sem, 1, 0);
    ae9c:	e59d0018 	ldr	r0, [sp, #24]
    aea0:	e1a0200c 	mov	r2, ip
    aea4:	e3a01001 	mov	r1, #1
    aea8:	eb000688 	bl	c8d0 <semaphore_release>
    leave;
    aeac:	e59f00d4 	ldr	r0, [pc, #212]	; af88 <port_write+0x27c>
    aeb0:	eaffff9f 	b	ad34 <port_write+0x28>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    lock_acquire (& port -> lock);
    aeb4:	e1a0000b 	mov	r0, fp
    aeb8:	ebfffc5c 	bl	a030 <lock_acquire>
    lock_release (& port_pool . lock);
    aebc:	e1a00004 	mov	r0, r4
    aec0:	eb00070b 	bl	caf4 <lock_release>

    check (bad_port, ! port -> closed ||
    aec4:	e5d52014 	ldrb	r2, [r5, #20]
    aec8:	e59d3008 	ldr	r3, [sp, #8]
    aecc:	e3520000 	cmp	r2, #0
    aed0:	e59dc010 	ldr	ip, [sp, #16]
    aed4:	0a000004 	beq	aeec <port_write+0x1e0>
    aed8:	e0288896 	mla	r8, r6, r8, r8
    aedc:	e0844008 	add	r4, r4, r8
    aee0:	e5942004 	ldr	r2, [r4, #4]
    aee4:	e3520000 	cmp	r2, #0
    aee8:	0a000019 	beq	af54 <port_write+0x248>
    /*
     * Get the message from the message queue, and put
     * it the the mailbox.
     */

    message = queue_rem (& port -> message);
    aeec:	e3a02068 	mov	r2, #104	; 0x68
    aef0:	e0060692 	mul	r6, r2, r6
    aef4:	e2860050 	add	r0, r6, #80	; 0x50
    aef8:	e0890000 	add	r0, r9, r0
    aefc:	e58d3008 	str	r3, [sp, #8]
    af00:	e58dc010 	str	ip, [sp, #16]
    af04:	ebfff695 	bl	8960 <queue_rem>
    af08:	e1a01000 	mov	r1, r0

    message -> code = code;
    message -> size = size;
    af0c:	e59d3008 	ldr	r3, [sp, #8]
    message -> buffer = message_buffer;
    af10:	e59dc010 	ldr	ip, [sp, #16]

    queue_add (& port -> mailbox, message);
    af14:	e2860060 	add	r0, r6, #96	; 0x60
     * it the the mailbox.
     */

    message = queue_rem (& port -> message);

    message -> code = code;
    af18:	e581a004 	str	sl, [r1, #4]
    message -> size = size;
    af1c:	e5813008 	str	r3, [r1, #8]
    message -> buffer = message_buffer;
    af20:	e581c00c 	str	ip, [r1, #12]

    queue_add (& port -> mailbox, message);
    af24:	e0890000 	add	r0, r9, r0
    af28:	ebfff955 	bl	9484 <queue_add>

    lock_release (& port -> lock);
    af2c:	e1a0000b 	mov	r0, fp
    af30:	eb0006ef 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    af34:	e59d0014 	ldr	r0, [sp, #20]
    af38:	ebfffb29 	bl	9be4 <cpu_trap_restore>

    /*
     * Release the read semaphore, and return.
     */

    status = semaphore_release (read_sem, 1, DNA_NO_RESCHEDULE);
    af3c:	e3a01001 	mov	r1, #1
    af40:	e1a02001 	mov	r2, r1
    af44:	e59d001c 	ldr	r0, [sp, #28]
      kernel_free (message_buffer);
    }

    leave;
  }
}
    af48:	e28dd024 	add	sp, sp, #36	; 0x24
    af4c:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

    /*
     * Release the read semaphore, and return.
     */

    status = semaphore_release (read_sem, 1, DNA_NO_RESCHEDULE);
    af50:	ea00065e 	b	c8d0 <semaphore_release>
    leave;
  }

  rescue (bad_port)
  {
    lock_release (& port -> lock);
    af54:	e1a0000b 	mov	r0, fp
    af58:	eb0006e5 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    af5c:	e59d0014 	ldr	r0, [sp, #20]
    af60:	ebfffb1f 	bl	9be4 <cpu_trap_restore>

    if (message_buffer != NULL)
    af64:	e59dc010 	ldr	ip, [sp, #16]
    af68:	e35c0000 	cmp	ip, #0
    af6c:	0a000001 	beq	af78 <port_write+0x26c>
    {
      kernel_free (message_buffer);
    af70:	e1a0000c 	mov	r0, ip
    af74:	eb000a13 	bl	d7c8 <kernel_free>
    }

    leave;
    af78:	e59f000c 	ldr	r0, [pc, #12]	; af8c <port_write+0x280>
    af7c:	eaffff6c 	b	ad34 <port_write+0x28>
    af80:	0000faff 	.word	0x0000faff
    af84:	00079628 	.word	0x00079628
    af88:	0000fffd 	.word	0x0000fffd
    af8c:	0000ffff 	.word	0x0000ffff

0000af90 <thread_create>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    af90:	e24dd008 	sub	sp, sp, #8
    af94:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  thread_t thread = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (handler != NULL && tid != NULL, DNA_BAD_ARGUMENT);
    af98:	e1a06000 	mov	r6, r0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    af9c:	e24dd014 	sub	sp, sp, #20
  thread_t thread = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (handler != NULL && tid != NULL, DNA_BAD_ARGUMENT);
    afa0:	e59d0088 	ldr	r0, [sp, #136]	; 0x88
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    afa4:	e28d4038 	add	r4, sp, #56	; 0x38
  thread_t thread = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (handler != NULL && tid != NULL, DNA_BAD_ARGUMENT);
    afa8:	e3500000 	cmp	r0, #0
    afac:	13560000 	cmpne	r6, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    afb0:	e884000c 	stm	r4, {r2, r3}
    afb4:	e59d305c 	ldr	r3, [sp, #92]	; 0x5c
    afb8:	e59d7060 	ldr	r7, [sp, #96]	; 0x60
  thread_t thread = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (handler != NULL && tid != NULL, DNA_BAD_ARGUMENT);
    afbc:	1a000004 	bne	afd4 <thread_create+0x44>
    afc0:	e59f0194 	ldr	r0, [pc, #404]	; b15c <thread_create+0x1cc>
  {
    cpu_trap_restore(it_status);
    lock_release (& thread_pool . lock);
    leave;
  }
}
    afc4:	e28dd014 	add	sp, sp, #20
    afc8:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    afcc:	e28dd008 	add	sp, sp, #8
    afd0:	e12fff1e 	bx	lr
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (handler != NULL && tid != NULL, DNA_BAD_ARGUMENT);
    ensure (info . group >= 0 && info . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    afd4:	e3530000 	cmp	r3, #0
    afd8:	1afffff8 	bne	afc0 <thread_create+0x30>

    /*
     * Check the content of the information structure.
     */

    ensure (info . affinity == DNA_NO_AFFINITY || (info . affinity >= 0
    afdc:	e3770001 	cmn	r7, #1
    afe0:	e1a08001 	mov	r8, r1
    afe4:	0a000004 	beq	affc <thread_create+0x6c>
    afe8:	e3570000 	cmp	r7, #0
    afec:	bafffff3 	blt	afc0 <thread_create+0x30>
    aff0:	ebfffb4b 	bl	9d24 <cpu_mp_count>
    aff4:	e1500007 	cmp	r0, r7
    aff8:	dafffff0 	ble	afc0 <thread_create+0x30>
          && info . affinity < cpu_mp_count ()), DNA_BAD_ARGUMENT);

    ensure (info . status == DNA_THREAD_SUSPENDED, DNA_BAD_ARGUMENT);
    affc:	e1dd26b8 	ldrh	r2, [sp, #104]	; 0x68
    b000:	e59f3158 	ldr	r3, [pc, #344]	; b160 <thread_create+0x1d0>
    b004:	e1520003 	cmp	r2, r3
    b008:	1affffec 	bne	afc0 <thread_create+0x30>
    ensure (info . resource == DNA_NO_RESOURCE, DNA_BAD_ARGUMENT);
    b00c:	e5dd506a 	ldrb	r5, [sp, #106]	; 0x6a
    b010:	e3550000 	cmp	r5, #0
    b014:	1affffe9 	bne	afc0 <thread_create+0x30>
    ensure (info . resource_id == -1, DNA_BAD_ARGUMENT);
    b018:	e59d206c 	ldr	r2, [sp, #108]	; 0x6c
    b01c:	e3720001 	cmn	r2, #1
    b020:	1affffe6 	bne	afc0 <thread_create+0x30>

    it_status = cpu_trap_mask_and_backup();
    b024:	ebfffab5 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& thread_pool . lock);
    b028:	e59fa134 	ldr	sl, [pc, #308]	; b164 <thread_create+0x1d4>

    ensure (info . status == DNA_THREAD_SUSPENDED, DNA_BAD_ARGUMENT);
    ensure (info . resource == DNA_NO_RESOURCE, DNA_BAD_ARGUMENT);
    ensure (info . resource_id == -1, DNA_BAD_ARGUMENT);

    it_status = cpu_trap_mask_and_backup();
    b02c:	e1a0b000 	mov	fp, r0
    lock_acquire (& thread_pool . lock);
    b030:	e1a0000a 	mov	r0, sl
    b034:	ebfffbfd 	bl	a030 <lock_acquire>

    /*
     * Get an empty thread slot.
     */

    thread = queue_rem (& thread_pool . thread[info . group]);
    b038:	e59f0128 	ldr	r0, [pc, #296]	; b168 <thread_create+0x1d8>
    b03c:	ebfff647 	bl	8960 <queue_rem>
    check (pool_error, thread != NULL, DNA_NO_MORE_SEM);
    b040:	e2509000 	subs	r9, r0, #0
    b044:	0a000028 	beq	b0ec <thread_create+0x15c>

    /*
     * Make the place clean.
     */

    index = thread -> id . s . index;
    b048:	e5d9c01f 	ldrb	ip, [r9, #31]
    dna_memset (thread, 0, sizeof (struct _thread));
    b04c:	e1a01005 	mov	r1, r5
    b050:	e3a020d0 	mov	r2, #208	; 0xd0
    b054:	e58dc00c 	str	ip, [sp, #12]
    b058:	ebfff6a1 	bl	8ae4 <dna_memset>

    thread -> id . s . index = index;
    b05c:	e59dc00c 	ldr	ip, [sp, #12]
    thread -> id . s . value = thread_pool . counter;
    b060:	e1da20b4 	ldrh	r2, [sl, #4]
     */

    index = thread -> id . s . index;
    dna_memset (thread, 0, sizeof (struct _thread));

    thread -> id . s . index = index;
    b064:	e5c9c01f 	strb	ip, [r9, #31]
    thread -> id . s . value = thread_pool . counter;
    b068:	e1c921bc 	strh	r2, [r9, #28]

    /*
     * Release the pool.
     */

    lock_release (& thread_pool . lock);
    b06c:	e1a0000a 	mov	r0, sl
    dna_memset (thread, 0, sizeof (struct _thread));

    thread -> id . s . index = index;
    thread -> id . s . value = thread_pool . counter;

    thread_pool . counter += 1;
    b070:	e2822001 	add	r2, r2, #1
    b074:	e1ca20b4 	strh	r2, [sl, #4]

    /*
     * Release the pool.
     */

    lock_release (& thread_pool . lock);
    b078:	eb00069d 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    b07c:	e1a0000b 	mov	r0, fp
    b080:	ebfffad7 	bl	9be4 <cpu_trap_restore>

    /*
     * Copy and adjust the information structure.
     */

    thread -> info = info;
    b084:	e1a01004 	mov	r1, r4
     * Deal with the thread group. In the future, only the kernel
     * and the application server will be able to create thread for
     * a different group than self.
     */

    thread -> id . s . group = info . group;
    b088:	e5c9501e 	strb	r5, [r9, #30]

    /*
     * Copy and adjust the information structure.
     */

    thread -> info = info;
    b08c:	e2890020 	add	r0, r9, #32
    b090:	e3a02050 	mov	r2, #80	; 0x50
    b094:	eb0012ad 	bl	fb50 <memcpy>

    if (info . stack_base == NULL)
    b098:	e59d1080 	ldr	r1, [sp, #128]	; 0x80
    b09c:	e3510000 	cmp	r1, #0
    b0a0:	0a00001b 	beq	b114 <thread_create+0x184>
      thread -> info . stack_base = kernel_malloc (info . stack_size, false);
      thread -> stack_allocated = true;
      check (no_mem, thread -> info . stack_base != NULL, DNA_OUT_OF_MEM);
    }

    if (info . affinity == DNA_NO_AFFINITY)
    b0a4:	e3770001 	cmn	r7, #1
    b0a8:	0a000016 	beq	b108 <thread_create+0x178>
     * Fill in the signature
     */

    thread -> signature . handler = handler;
    thread -> signature . arguments = arguments;
    thread -> signature . it_restore = CPU_DEFAULT_ITRESTORE;
    b0ac:	e3a02013 	mov	r2, #19
    /*
     * Initialize the context.
     */

    cpu_context_init (& thread -> context, thread -> info . stack_base,
        thread -> info . stack_size, thread_bootstrap, & thread -> signature);
    b0b0:	e2893074 	add	r3, r9, #116	; 0x74
     * Fill in the signature
     */

    thread -> signature . handler = handler;
    thread -> signature . arguments = arguments;
    thread -> signature . it_restore = CPU_DEFAULT_ITRESTORE;
    b0b4:	e5892078 	str	r2, [r9, #120]	; 0x78

    /*
     * Fill in the signature
     */

    thread -> signature . handler = handler;
    b0b8:	e5896074 	str	r6, [r9, #116]	; 0x74
    thread -> signature . arguments = arguments;
    b0bc:	e589807c 	str	r8, [r9, #124]	; 0x7c

    /*
     * Initialize the context.
     */

    cpu_context_init (& thread -> context, thread -> info . stack_base,
    b0c0:	e58d3000 	str	r3, [sp]
    b0c4:	e599206c 	ldr	r2, [r9, #108]	; 0x6c
    b0c8:	e2890084 	add	r0, r9, #132	; 0x84
    b0cc:	e59f3098 	ldr	r3, [pc, #152]	; b16c <thread_create+0x1dc>
    b0d0:	e5991068 	ldr	r1, [r9, #104]	; 0x68
    b0d4:	ebffd3f9 	bl	c0 <cpu_context_init>

    /*
     * Return the thread ID and success
     */

    *tid = thread -> id . raw;
    b0d8:	e599301c 	ldr	r3, [r9, #28]
    b0dc:	e59d2088 	ldr	r2, [sp, #136]	; 0x88
    return DNA_OK;
    b0e0:	e3a00000 	mov	r0, #0

    /*
     * Return the thread ID and success
     */

    *tid = thread -> id . raw;
    b0e4:	e5823000 	str	r3, [r2]
    return DNA_OK;
    b0e8:	eaffffb5 	b	afc4 <thread_create+0x34>
    /*
     * Get an empty thread slot.
     */

    thread = queue_rem (& thread_pool . thread[info . group]);
    check (pool_error, thread != NULL, DNA_NO_MORE_SEM);
    b0ec:	e59f407c 	ldr	r4, [pc, #124]	; b170 <thread_create+0x1e0>
    queue_add (& thread_pool . thread[info . group], thread);
  }

  rescue (pool_error)
  {
    cpu_trap_restore(it_status);
    b0f0:	e1a0000b 	mov	r0, fp
    b0f4:	ebfffaba 	bl	9be4 <cpu_trap_restore>
    lock_release (& thread_pool . lock);
    b0f8:	e59f0064 	ldr	r0, [pc, #100]	; b164 <thread_create+0x1d4>
    b0fc:	eb00067c 	bl	caf4 <lock_release>
    leave;
    b100:	e1a00004 	mov	r0, r4
    b104:	eaffffae 	b	afc4 <thread_create+0x34>
      check (no_mem, thread -> info . stack_base != NULL, DNA_OUT_OF_MEM);
    }

    if (info . affinity == DNA_NO_AFFINITY)
    {
      thread -> info . affinity = cpu_mp_count ();
    b108:	ebfffb05 	bl	9d24 <cpu_mp_count>
    b10c:	e5890048 	str	r0, [r9, #72]	; 0x48
    b110:	eaffffe5 	b	b0ac <thread_create+0x11c>

    thread -> info = info;

    if (info . stack_base == NULL)
    {
      thread -> info . stack_base = kernel_malloc (info . stack_size, false);
    b114:	e59d0084 	ldr	r0, [sp, #132]	; 0x84
    b118:	eb000975 	bl	d6f4 <kernel_malloc>
      thread -> stack_allocated = true;
    b11c:	e3a03001 	mov	r3, #1
      check (no_mem, thread -> info . stack_base != NULL, DNA_OUT_OF_MEM);
    b120:	e3500000 	cmp	r0, #0

    thread -> info = info;

    if (info . stack_base == NULL)
    {
      thread -> info . stack_base = kernel_malloc (info . stack_size, false);
    b124:	e1a04000 	mov	r4, r0
    b128:	e5890068 	str	r0, [r9, #104]	; 0x68
      thread -> stack_allocated = true;
    b12c:	e5c93070 	strb	r3, [r9, #112]	; 0x70
      check (no_mem, thread -> info . stack_base != NULL, DNA_OUT_OF_MEM);
    b130:	1affffdb 	bne	b0a4 <thread_create+0x114>
    return DNA_OK;
  }

  rescue (no_mem)
  {
    it_status = cpu_trap_mask_and_backup();
    b134:	ebfffa71 	bl	9b00 <cpu_trap_mask_and_backup>
    b138:	e1a0b000 	mov	fp, r0
    lock_acquire (& thread_pool . lock);
    b13c:	e1a0000a 	mov	r0, sl
    b140:	ebfffbba 	bl	a030 <lock_acquire>

    thread -> id . s . value = 0;
    b144:	e1c941bc 	strh	r4, [r9, #28]
    queue_add (& thread_pool . thread[info . group], thread);
    b148:	e1a01009 	mov	r1, r9
    b14c:	e59f0014 	ldr	r0, [pc, #20]	; b168 <thread_create+0x1d8>
    b150:	ebfff8cb 	bl	9484 <queue_add>

    if (info . stack_base == NULL)
    {
      thread -> info . stack_base = kernel_malloc (info . stack_size, false);
      thread -> stack_allocated = true;
      check (no_mem, thread -> info . stack_base != NULL, DNA_OUT_OF_MEM);
    b154:	e59f4018 	ldr	r4, [pc, #24]	; b174 <thread_create+0x1e4>
    b158:	eaffffe4 	b	b0f0 <thread_create+0x160>
    b15c:	0000fffc 	.word	0x0000fffc
    b160:	0000d15a 	.word	0x0000d15a
    b164:	0007b040 	.word	0x0007b040
    b168:	0007e448 	.word	0x0007e448
    b16c:	0000bc44 	.word	0x0000bc44
    b170:	0000fdfe 	.word	0x0000fdfe
    b174:	0000fffd 	.word	0x0000fffd

0000b178 <port_get_info>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    b178:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);
    b17c:	e2516000 	subs	r6, r1, #0
    b180:	0a000005 	beq	b19c <port_get_info+0x24>
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
    b184:	e1a05820 	lsr	r5, r0, #16
    b188:	e355003f 	cmp	r5, #63	; 0x3f
    b18c:	e1a04000 	mov	r4, r0
    b190:	9a000003 	bls	b1a4 <port_get_info+0x2c>
    b194:	e59f0098 	ldr	r0, [pc, #152]	; b234 <port_get_info+0xbc>
  {
    lock_release (& port_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    b198:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);
    b19c:	e59f0094 	ldr	r0, [pc, #148]	; b238 <port_get_info+0xc0>
    b1a0:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);

    it_status = cpu_trap_mask_and_backup();
    b1a4:	ebfffa55 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& port_pool . lock);
    b1a8:	e59f708c 	ldr	r7, [pc, #140]	; b23c <port_get_info+0xc4>
  watch (status_t)
  {
    ensure (p_info != NULL, DNA_BAD_ARGUMENT);
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);

    it_status = cpu_trap_mask_and_backup();
    b1ac:	e1a09000 	mov	r9, r0
    lock_acquire (& port_pool . lock);
    b1b0:	e1a00007 	mov	r0, r7
    b1b4:	ebfffb9d 	bl	a030 <lock_acquire>
     * Look for the port with ID id
     */

    port = & port_pool . data[pid . s . index];
    check (invalid_port, port != NULL, DNA_BAD_PORT_ID);
    check (invalid_port, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    b1b8:	e3a03068 	mov	r3, #104	; 0x68
    b1bc:	e0050593 	mul	r5, r3, r5
    b1c0:	e0878005 	add	r8, r7, r5
    b1c4:	e598300c 	ldr	r3, [r8, #12]
    b1c8:	e1540003 	cmp	r4, r3
    b1cc:	0a000005 	beq	b1e8 <port_get_info+0x70>
    return status;
  }

  rescue (invalid_port)
  {
    lock_release (& port_pool . lock);
    b1d0:	e1a00007 	mov	r0, r7
    b1d4:	eb000646 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    b1d8:	e1a00009 	mov	r0, r9
    b1dc:	ebfffa80 	bl	9be4 <cpu_trap_restore>
    leave;
    b1e0:	e59f004c 	ldr	r0, [pc, #76]	; b234 <port_get_info+0xbc>
    b1e4:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

    port = & port_pool . data[pid . s . index];
    check (invalid_port, port != NULL, DNA_BAD_PORT_ID);
    check (invalid_port, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    lock_acquire (& port -> lock);
    b1e8:	e2855010 	add	r5, r5, #16
    b1ec:	e0855007 	add	r5, r5, r7
    b1f0:	e1a00005 	mov	r0, r5
    b1f4:	ebfffb8d 	bl	a030 <lock_acquire>
    lock_release (& port_pool . lock);
    b1f8:	e1a00007 	mov	r0, r7
    b1fc:	eb00063c 	bl	caf4 <lock_release>

    /*
     * Copy the port information
     */

    *p_info = port -> info;
    b200:	e288c018 	add	ip, r8, #24
    b204:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
    b208:	e8a6000f 	stmia	r6!, {r0, r1, r2, r3}
    b20c:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
    b210:	e8a6000f 	stmia	r6!, {r0, r1, r2, r3}
    b214:	e89c0007 	ldm	ip, {r0, r1, r2}
    b218:	e8860007 	stm	r6, {r0, r1, r2}

    lock_release (& port -> lock);
    b21c:	e1a00005 	mov	r0, r5
    b220:	eb000633 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    b224:	e1a00009 	mov	r0, r9
    b228:	ebfffa6d 	bl	9be4 <cpu_trap_restore>

    return status;
    b22c:	e3a00000 	mov	r0, #0
    b230:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
    b234:	0000faff 	.word	0x0000faff
    b238:	0000fffc 	.word	0x0000fffc
    b23c:	00079628 	.word	0x00079628

0000b240 <alarm_handler>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    b240:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    b244:	e24dd04c 	sub	sp, sp, #76	; 0x4c
  queue_t alarm_garbage;
  alarm_t current_alarm = NULL, next_alarm = NULL;
  status_t status = DNA_OK;
  int32_t current_cpuid = cpu_mp_id (), liveness = 10;
    b248:	ebfffa82 	bl	9c58 <cpu_mp_id>
    b24c:	e3a0100a 	mov	r1, #10
  bigtime_t start_time, quantum, current_deadline = 0, timer_delay;
  bigtime_t delta_start, delta_end, expected_deadline, expected_delay;
  volatile bool reschedule = false;
    b250:	e3a03000 	mov	r3, #0
    b254:	e0800180 	add	r0, r0, r0, lsl #3
    b258:	e1a09300 	lsl	r9, r0, #6
    b25c:	e59f22a4 	ldr	r2, [pc, #676]	; b508 <alarm_handler+0x2c8>
    b260:	e2890f8e 	add	r0, r9, #568	; 0x238
    b264:	e082a009 	add	sl, r2, r9

{
  queue_t alarm_garbage;
  alarm_t current_alarm = NULL, next_alarm = NULL;
  status_t status = DNA_OK;
  int32_t current_cpuid = cpu_mp_id (), liveness = 10;
    b268:	e58d1010 	str	r1, [sp, #16]

      if (! current_alarm -> is_invalid
          && (current_alarm -> mode & DNA_PERIODIC_ALARM) != 0)
      {
        current_alarm -> deadline += current_alarm -> quantum;
        queue_insert (& cpu -> alarm_queue, alarm_comparator, current_alarm);
    b26c:	e0821000 	add	r1, r2, r0
  alarm_t current_alarm = NULL, next_alarm = NULL;
  status_t status = DNA_OK;
  int32_t current_cpuid = cpu_mp_id (), liveness = 10;
  bigtime_t start_time, quantum, current_deadline = 0, timer_delay;
  bigtime_t delta_start, delta_end, expected_deadline, expected_delay;
  volatile bool reschedule = false;
    b270:	e5cd301f 	strb	r3, [sp, #31]
 */

{
  queue_t alarm_garbage;
  alarm_t current_alarm = NULL, next_alarm = NULL;
  status_t status = DNA_OK;
    b274:	e58d300c 	str	r3, [sp, #12]
  bool process_next_alarm = true;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];

  watch (status_t)
  {
    DNA_QUEUE_SET_DEFAULTS (alarm_garbage);
    b278:	e58d3038 	str	r3, [sp, #56]	; 0x38
    b27c:	e58d0008 	str	r0, [sp, #8]
    b280:	e28aa014 	add	sl, sl, #20

    do
    {
      cpu_timer_get (cpu -> id, & start_time);
    b284:	e0829009 	add	r9, r2, r9

      if (! current_alarm -> is_invalid
          && (current_alarm -> mode & DNA_PERIODIC_ALARM) != 0)
      {
        current_alarm -> deadline += current_alarm -> quantum;
        queue_insert (& cpu -> alarm_queue, alarm_comparator, current_alarm);
    b288:	e58d1014 	str	r1, [sp, #20]
  bool process_next_alarm = true;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];

  watch (status_t)
  {
    DNA_QUEUE_SET_DEFAULTS (alarm_garbage);
    b28c:	e58d303c 	str	r3, [sp, #60]	; 0x3c
    b290:	e58d3040 	str	r3, [sp, #64]	; 0x40
    b294:	e58d3044 	str	r3, [sp, #68]	; 0x44

    do
    {
      cpu_timer_get (cpu -> id, & start_time);
    b298:	e599000c 	ldr	r0, [r9, #12]
    b29c:	e28d1020 	add	r1, sp, #32
    b2a0:	ebfffa3b 	bl	9b94 <cpu_timer_get>
      /*
       * Lock the processor to access its queue and
       * its current alarm.
       */

      lock_acquire (& cpu -> lock);
    b2a4:	e1a0000a 	mov	r0, sl
    b2a8:	ebfffb60 	bl	a030 <lock_acquire>
      current_alarm = cpu -> current_alarm;
    b2ac:	e5998234 	ldr	r8, [r9, #564]	; 0x234

      /*
       * Check if the current alarm is valid.
       */

      check (no_alarm, current_alarm != NULL, DNA_ERROR);
    b2b0:	e3580000 	cmp	r8, #0
    b2b4:	0a00008e 	beq	b4f4 <alarm_handler+0x2b4>
      lock_acquire (& current_alarm -> lock);
    b2b8:	e288b018 	add	fp, r8, #24
    b2bc:	e1a0000b 	mov	r0, fp
    b2c0:	ebfffb5a 	bl	a030 <lock_acquire>
dna_log(VERBOSE_LEVEL, "(%d:%d), %lld/%lld, of 0x%x @ %lld",
          current_alarm -> id . s . value, current_alarm -> id . s . index,
          current_alarm -> deadline, current_alarm -> quantum,
          current_alarm -> thread_id, start_time);

      current_deadline = current_alarm -> deadline;
    b2c4:	e1c822d8 	ldrd	r2, [r8, #40]	; 0x28
    b2c8:	e1cd20f0 	strd	r2, [sp]
      /*
       * Check if the alarm is valid. If so, check if
       * it is periodical and restart it if necessary.
       */

      if (! current_alarm -> is_invalid
    b2cc:	e5d83014 	ldrb	r3, [r8, #20]
    b2d0:	e3530000 	cmp	r3, #0
    b2d4:	1a000002 	bne	b2e4 <alarm_handler+0xa4>
          && (current_alarm -> mode & DNA_PERIODIC_ALARM) != 0)
    b2d8:	e5983010 	ldr	r3, [r8, #16]
    b2dc:	e3130001 	tst	r3, #1
    b2e0:	1a00006d 	bne	b49c <alarm_handler+0x25c>
        current_alarm -> deadline += current_alarm -> quantum;
        queue_insert (& cpu -> alarm_queue, alarm_comparator, current_alarm);
      }
      else
      {
        queue_add (& alarm_garbage, current_alarm);
    b2e4:	e1a01008 	mov	r1, r8
    b2e8:	e28d0038 	add	r0, sp, #56	; 0x38
    b2ec:	ebfff864 	bl	9484 <queue_add>
    b2f0:	e59f2210 	ldr	r2, [pc, #528]	; b508 <alarm_handler+0x2c8>
    b2f4:	e59d1008 	ldr	r1, [sp, #8]
    b2f8:	e0827001 	add	r7, r2, r1
      }

      lock_release (& current_alarm -> lock);
    b2fc:	e1a0000b 	mov	r0, fp
    b300:	eb0005fb 	bl	caf4 <lock_release>

      /*
       * Look through the next alarm if no reschedule is needed.
       */

      while ((next_alarm = queue_rem (& cpu -> alarm_queue)) != NULL)
    b304:	ea000009 	b	b330 <alarm_handler+0xf0>
      {
        lock_acquire (& next_alarm -> lock);
    b308:	e1a00006 	mov	r0, r6
    b30c:	ebfffb47 	bl	a030 <lock_acquire>

        if (! next_alarm -> is_invalid)
    b310:	e5d43014 	ldrb	r3, [r4, #20]
    b314:	e3530000 	cmp	r3, #0
    b318:	0a00002b 	beq	b3cc <alarm_handler+0x18c>
        {
          lock_release (& next_alarm -> lock);
          break;
        }

        queue_add (& alarm_garbage, next_alarm);
    b31c:	e1a01004 	mov	r1, r4
    b320:	e28d0038 	add	r0, sp, #56	; 0x38
    b324:	ebfff856 	bl	9484 <queue_add>
        lock_release (& next_alarm -> lock);
    b328:	e1a00006 	mov	r0, r6
    b32c:	eb0005f0 	bl	caf4 <lock_release>

      /*
       * Look through the next alarm if no reschedule is needed.
       */

      while ((next_alarm = queue_rem (& cpu -> alarm_queue)) != NULL)
    b330:	e1a00007 	mov	r0, r7
    b334:	ebfff589 	bl	8960 <queue_rem>
    b338:	e2504000 	subs	r4, r0, #0
      {
        lock_acquire (& next_alarm -> lock);
    b33c:	e2846018 	add	r6, r4, #24

      /*
       * Look through the next alarm if no reschedule is needed.
       */

      while ((next_alarm = queue_rem (& cpu -> alarm_queue)) != NULL)
    b340:	1afffff0 	bne	b308 <alarm_handler+0xc8>
       * Unlock the processor since we do not need its
       * data anymore.
       */
        
      cpu -> current_alarm = next_alarm;
      lock_release (& cpu -> lock);
    b344:	e1a0000a 	mov	r0, sl
      /*
       * Unlock the processor since we do not need its
       * data anymore.
       */
        
      cpu -> current_alarm = next_alarm;
    b348:	e5894234 	str	r4, [r9, #564]	; 0x234
      lock_release (& cpu -> lock);
    b34c:	eb0005e8 	bl	caf4 <lock_release>

      /*
       * Execute the alarm, and compute its WCET.
	   *    if and only if it is still valid.
       */
	  if (!current_alarm->is_invalid){
    b350:	e5d83014 	ldrb	r3, [r8, #20]
    b354:	e3530000 	cmp	r3, #0
    b358:	0a00003c 	beq	b450 <alarm_handler+0x210>

      /*
       * Update the reschedule flag.
       */

      reschedule = reschedule || status == DNA_INVOKE_SCHEDULER;
    b35c:	e5dd301f 	ldrb	r3, [sp, #31]
    b360:	e21330ff 	ands	r3, r3, #255	; 0xff
    b364:	059d000c 	ldreq	r0, [sp, #12]
    b368:	02403003 	subeq	r3, r0, #3
    b36c:	016f3f13 	clzeq	r3, r3
    b370:	01a032a3 	lsreq	r3, r3, #5
    }
    while (process_next_alarm);
    b374:	e3540000 	cmp	r4, #0

      /*
       * Update the reschedule flag.
       */

      reschedule = reschedule || status == DNA_INVOKE_SCHEDULER;
    b378:	e5cd301f 	strb	r3, [sp, #31]
    }
    while (process_next_alarm);
    b37c:	1affffc5 	bne	b298 <alarm_handler+0x58>
    b380:	ea000006 	b	b3a0 <alarm_handler+0x160>
     * Parse the garbage and delete its content.
     */

    while ((current_alarm = queue_rem (& alarm_garbage)) != NULL)
    {
      current_alarm -> id . s . value = 0;
    b384:	e1c540b4 	strh	r4, [r5, #4]

      lock_acquire (& alarm_pool . lock);
    b388:	ebfffb28 	bl	a030 <lock_acquire>
      queue_add (& alarm_pool . alarm, current_alarm);
    b38c:	e1a01005 	mov	r1, r5
    b390:	e59f0174 	ldr	r0, [pc, #372]	; b50c <alarm_handler+0x2cc>
    b394:	ebfff83a 	bl	9484 <queue_add>
      lock_release (& alarm_pool . lock);
    b398:	e59f0170 	ldr	r0, [pc, #368]	; b510 <alarm_handler+0x2d0>
    b39c:	eb0005d4 	bl	caf4 <lock_release>

    /*
     * Parse the garbage and delete its content.
     */

    while ((current_alarm = queue_rem (& alarm_garbage)) != NULL)
    b3a0:	e28d0038 	add	r0, sp, #56	; 0x38
    b3a4:	ebfff56d 	bl	8960 <queue_rem>
    b3a8:	e2505000 	subs	r5, r0, #0
    {
      current_alarm -> id . s . value = 0;

      lock_acquire (& alarm_pool . lock);
    b3ac:	e59f015c 	ldr	r0, [pc, #348]	; b510 <alarm_handler+0x2d0>

    /*
     * Parse the garbage and delete its content.
     */

    while ((current_alarm = queue_rem (& alarm_garbage)) != NULL)
    b3b0:	1afffff3 	bne	b384 <alarm_handler+0x144>
      lock_acquire (& alarm_pool . lock);
      queue_add (& alarm_pool . alarm, current_alarm);
      lock_release (& alarm_pool . lock);
    }

    return reschedule ? DNA_INVOKE_SCHEDULER : DNA_OK;
    b3b4:	e5dd001f 	ldrb	r0, [sp, #31]
    b3b8:	e3500000 	cmp	r0, #0
    b3bc:	13a00003 	movne	r0, #3
    b3c0:	03a00000 	moveq	r0, #0
  rescue (no_alarm)
  {
    lock_release (& cpu -> lock);
    leave;
  }
}
    b3c4:	e28dd04c 	add	sp, sp, #76	; 0x4c
    b3c8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
      {
        lock_acquire (& next_alarm -> lock);

        if (! next_alarm -> is_invalid)
        {
          lock_release (& next_alarm -> lock);
    b3cc:	e1a00006 	mov	r0, r6
    b3d0:	eb0005c7 	bl	caf4 <lock_release>
       * Unlock the processor since we do not need its
       * data anymore.
       */
        
      cpu -> current_alarm = next_alarm;
      lock_release (& cpu -> lock);
    b3d4:	e1a0000a 	mov	r0, sl
      /*
       * Unlock the processor since we do not need its
       * data anymore.
       */
        
      cpu -> current_alarm = next_alarm;
    b3d8:	e5894234 	str	r4, [r9, #564]	; 0x234
      lock_release (& cpu -> lock);
    b3dc:	eb0005c4 	bl	caf4 <lock_release>
        /*
         * If we are dealing with the same alarm as the current one,
         * we need to decrease the liveness counter.
         */

        liveness = current_alarm == next_alarm ? liveness - 1 : 10;
    b3e0:	e1580004 	cmp	r8, r4
    b3e4:	0a000037 	beq	b4c8 <alarm_handler+0x288>
    b3e8:	e3a0300a 	mov	r3, #10
    b3ec:	e58d3010 	str	r3, [sp, #16]

        /*
         * Compute the delays and the expected deadline.
         */

        timer_delay = start_time - current_deadline;
    b3f0:	e1cd22d0 	ldrd	r2, [sp, #32]
        expected_deadline = start_time + timer_delay
          + current_alarm -> execution_time;
        expected_delay = expected_deadline - next_alarm -> deadline;
    b3f4:	e1c402d8 	ldrd	r0, [r4, #40]	; 0x28

        /*
         * Compute the delays and the expected deadline.
         */

        timer_delay = start_time - current_deadline;
    b3f8:	e1cd40d0 	ldrd	r4, [sp]
    b3fc:	e0524004 	subs	r4, r2, r4
    b400:	e0c35005 	sbc	r5, r3, r5
        expected_deadline = start_time + timer_delay
    b404:	e0944002 	adds	r4, r4, r2
    b408:	e1c863d0 	ldrd	r6, [r8, #48]	; 0x30
    b40c:	e0a55003 	adc	r5, r5, r3
    b410:	e0942006 	adds	r2, r4, r6
    b414:	e0a53007 	adc	r3, r5, r7
          + current_alarm -> execution_time;
        expected_delay = expected_deadline - next_alarm -> deadline;
    b418:	e0522000 	subs	r2, r2, r0
    b41c:	e0c33001 	sbc	r3, r3, r1
        /*
         * If the deadline is way out of base, restart the loop,
         * otherwise program the timer.
         */

        if (expected_delay > 0)
    b420:	e3520001 	cmp	r2, #1
    b424:	e2d31000 	sbcs	r1, r3, #0
        {
dna_log(VERBOSE_LEVEL, "Over by %d ns, alarm (%d:%d) from thread 0x%x.",
              (int32_t) expected_delay, next_alarm -> id . s . value,
              next_alarm -> id . s . index, next_alarm -> thread_id);

          process_next_alarm = true;
    b428:	a3a04001 	movge	r4, #1
        /*
         * If the deadline is way out of base, restart the loop,
         * otherwise program the timer.
         */

        if (expected_delay > 0)
    b42c:	aaffffc7 	bge	b350 <alarm_handler+0x110>

          process_next_alarm = true;
        }
        else
        {
          cpu_timer_set (cpu -> id, -1 * expected_delay);
    b430:	e2722000 	rsbs	r2, r2, #0
    b434:	e2e33000 	rsc	r3, r3, #0
    b438:	e599000c 	ldr	r0, [r9, #12]
    b43c:	ebfff9eb 	bl	9bf0 <cpu_timer_set>

      /*
       * Execute the alarm, and compute its WCET.
	   *    if and only if it is still valid.
       */
	  if (!current_alarm->is_invalid){
    b440:	e5d83014 	ldrb	r3, [r8, #20]
      current_deadline = current_alarm -> deadline;

      check (false_alarm, process_next_alarm ||
          current_deadline < start_time, DNA_ERROR);

      process_next_alarm = false;
    b444:	e3a04000 	mov	r4, #0

      /*
       * Execute the alarm, and compute its WCET.
	   *    if and only if it is still valid.
       */
	  if (!current_alarm->is_invalid){
    b448:	e3530000 	cmp	r3, #0
    b44c:	1affffc2 	bne	b35c <alarm_handler+0x11c>
		   cpu_timer_get (cpu -> id, & delta_start);
    b450:	e28d1028 	add	r1, sp, #40	; 0x28
    b454:	e599000c 	ldr	r0, [r9, #12]
    b458:	ebfff9cd 	bl	9b94 <cpu_timer_get>
		   status = current_alarm -> callback (current_alarm -> data);
    b45c:	e5983038 	ldr	r3, [r8, #56]	; 0x38
    b460:	e598003c 	ldr	r0, [r8, #60]	; 0x3c
    b464:	e12fff33 	blx	r3
		   cpu_timer_get (cpu -> id, & delta_end);
    b468:	e28d1030 	add	r1, sp, #48	; 0x30
       * Execute the alarm, and compute its WCET.
	   *    if and only if it is still valid.
       */
	  if (!current_alarm->is_invalid){
		   cpu_timer_get (cpu -> id, & delta_start);
		   status = current_alarm -> callback (current_alarm -> data);
    b46c:	e58d000c 	str	r0, [sp, #12]
		   cpu_timer_get (cpu -> id, & delta_end);
    b470:	e599000c 	ldr	r0, [r9, #12]
    b474:	ebfff9c6 	bl	9b94 <cpu_timer_get>

		   quantum = delta_end - delta_start;
    b478:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
    b47c:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
		   if (quantum > current_alarm -> execution_time)
    b480:	e1c863d0 	ldrd	r6, [r8, #48]	; 0x30
	  if (!current_alarm->is_invalid){
		   cpu_timer_get (cpu -> id, & delta_start);
		   status = current_alarm -> callback (current_alarm -> data);
		   cpu_timer_get (cpu -> id, & delta_end);

		   quantum = delta_end - delta_start;
    b484:	e0500002 	subs	r0, r0, r2
    b488:	e0c11003 	sbc	r1, r1, r3
		   if (quantum > current_alarm -> execution_time)
    b48c:	e1560000 	cmp	r6, r0
    b490:	e0d72001 	sbcs	r2, r7, r1
		   {
				current_alarm -> execution_time = quantum;
    b494:	b1c803f0 	strdlt	r0, [r8, #48]	; 0x30
    b498:	eaffffaf 	b	b35c <alarm_handler+0x11c>
       */

      if (! current_alarm -> is_invalid
          && (current_alarm -> mode & DNA_PERIODIC_ALARM) != 0)
      {
        current_alarm -> deadline += current_alarm -> quantum;
    b49c:	e1cd00d0 	ldrd	r0, [sp]
    b4a0:	e1c822d0 	ldrd	r2, [r8, #32]
    b4a4:	e0922000 	adds	r2, r2, r0
    b4a8:	e0a33001 	adc	r3, r3, r1
        queue_insert (& cpu -> alarm_queue, alarm_comparator, current_alarm);
    b4ac:	e59d0014 	ldr	r0, [sp, #20]
       */

      if (! current_alarm -> is_invalid
          && (current_alarm -> mode & DNA_PERIODIC_ALARM) != 0)
      {
        current_alarm -> deadline += current_alarm -> quantum;
    b4b0:	e1c822f8 	strd	r2, [r8, #40]	; 0x28
        queue_insert (& cpu -> alarm_queue, alarm_comparator, current_alarm);
    b4b4:	e59f1058 	ldr	r1, [pc, #88]	; b514 <alarm_handler+0x2d4>
    b4b8:	e1a02008 	mov	r2, r8
    b4bc:	e1a07000 	mov	r7, r0
    b4c0:	ebfff921 	bl	994c <queue_insert>
    b4c4:	eaffff8c 	b	b2fc <alarm_handler+0xbc>
         * we need to decrease the liveness counter.
         */

        liveness = current_alarm == next_alarm ? liveness - 1 : 10;

        if (liveness == 0)
    b4c8:	e59d0010 	ldr	r0, [sp, #16]
    b4cc:	e2500001 	subs	r0, r0, #1
    b4d0:	e58d0010 	str	r0, [sp, #16]
    b4d4:	1affffc5 	bne	b3f0 <alarm_handler+0x1b0>
        {
dna_log(PANIC_LEVEL,
              "Can't stabilize alarm (%d:%d) after 10 cycle, abandon.",
              next_alarm -> id . s . value, next_alarm -> id . s . index);

          lock_acquire (& next_alarm -> lock);
    b4d8:	e1a0000b 	mov	r0, fp
    b4dc:	ebfffad3 	bl	a030 <lock_acquire>
          next_alarm -> is_invalid = next_alarm -> is_invalid || liveness == 0;
    b4e0:	e3a03001 	mov	r3, #1
          lock_release (& next_alarm -> lock);
    b4e4:	e1a0000b 	mov	r0, fp
dna_log(PANIC_LEVEL,
              "Can't stabilize alarm (%d:%d) after 10 cycle, abandon.",
              next_alarm -> id . s . value, next_alarm -> id . s . index);

          lock_acquire (& next_alarm -> lock);
          next_alarm -> is_invalid = next_alarm -> is_invalid || liveness == 0;
    b4e8:	e5c83014 	strb	r3, [r8, #20]
          lock_release (& next_alarm -> lock);
    b4ec:	eb000580 	bl	caf4 <lock_release>
    b4f0:	eaffffbe 	b	b3f0 <alarm_handler+0x1b0>
    cpu_timer_set (cpu -> id, quantum);
  }

  rescue (no_alarm)
  {
    lock_release (& cpu -> lock);
    b4f4:	e1a0000a 	mov	r0, sl
    b4f8:	eb00057d 	bl	caf4 <lock_release>
    leave;
    b4fc:	e59f0014 	ldr	r0, [pc, #20]	; b518 <alarm_handler+0x2d8>
  }
}
    b500:	e28dd04c 	add	sp, sp, #76	; 0x4c
    b504:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    b508:	0007e458 	.word	0x0007e458
    b50c:	00081990 	.word	0x00081990
    b510:	00080988 	.word	0x00080988
    b514:	0000c27c 	.word	0x0000c27c
    b518:	0000ffff 	.word	0x0000ffff

0000b51c <semaphore_alarm>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    b51c:	e92d4038 	push	{r3, r4, r5, lr}
  thread_t thread = data;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (thread != NULL, DNA_BAD_ARGUMENT);
    b520:	e2504000 	subs	r4, r0, #0
    b524:	0a000008 	beq	b54c <semaphore_alarm+0x30>
    ensure (thread -> resource_queue != NULL, DNA_ERROR);
    b528:	e5940018 	ldr	r0, [r4, #24]
    b52c:	e3500000 	cmp	r0, #0
    b530:	0a000003 	beq	b544 <semaphore_alarm+0x28>
    ensure (thread -> info . status == DNA_THREAD_WAITING, DNA_ERROR);
    b534:	e1d425b0 	ldrh	r2, [r4, #80]	; 0x50
    b538:	e59f307c 	ldr	r3, [pc, #124]	; b5bc <semaphore_alarm+0xa0>
    b53c:	e1520003 	cmp	r2, r3
    b540:	0a000003 	beq	b554 <semaphore_alarm+0x38>
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (thread != NULL, DNA_BAD_ARGUMENT);
    ensure (thread -> resource_queue != NULL, DNA_ERROR);
    b544:	e59f0074 	ldr	r0, [pc, #116]	; b5c0 <semaphore_alarm+0xa4>
    b548:	e8bd8038 	pop	{r3, r4, r5, pc}
  thread_t thread = data;
  status_t status = DNA_OK;

  watch (status_t)
  {
    ensure (thread != NULL, DNA_BAD_ARGUMENT);
    b54c:	e59f0070 	ldr	r0, [pc, #112]	; b5c4 <semaphore_alarm+0xa8>
    b550:	e8bd8038 	pop	{r3, r4, r5, pc}
    ensure (thread -> resource_queue != NULL, DNA_ERROR);
    ensure (thread -> info . status == DNA_THREAD_WAITING, DNA_ERROR);
    ensure (thread -> info . resource == DNA_RESOURCE_SEMAPHORE, DNA_ERROR);
    b554:	e5d43052 	ldrb	r3, [r4, #82]	; 0x52
    b558:	e3530001 	cmp	r3, #1
    b55c:	1afffff8 	bne	b544 <semaphore_alarm+0x28>
    /*
     * Lock the thread's resource queue.
     * Extract the thread from the waiting list.
     */

    lock_acquire (& thread -> resource_queue -> lock);
    b560:	ebfffab2 	bl	a030 <lock_acquire>
    status = queue_extract (thread -> resource_queue, thread);
    b564:	e1a01004 	mov	r1, r4
    b568:	e5940018 	ldr	r0, [r4, #24]
    b56c:	ebfff4bb 	bl	8860 <queue_extract>
    b570:	e1a05000 	mov	r5, r0
    lock_release (& thread -> resource_queue -> lock);
    b574:	e5940018 	ldr	r0, [r4, #24]
    b578:	eb00055d 	bl	caf4 <lock_release>

    /*
     * If the thread was waiting, we can dispatch it
     */

    if (status == DNA_OK)
    b57c:	e3550000 	cmp	r5, #0
    b580:	0a000001 	beq	b58c <semaphore_alarm+0x70>
    b584:	e1a00005 	mov	r0, r5
      status = scheduler_dispatch (thread);
    }

    return status;
  }
}
    b588:	e8bd8038 	pop	{r3, r4, r5, pc}
     * If the thread was waiting, we can dispatch it
     */

    if (status == DNA_OK)
    {
      lock_acquire (& thread -> lock);
    b58c:	e2840014 	add	r0, r4, #20
    b590:	ebfffaa6 	bl	a030 <lock_acquire>

      thread -> resource_queue = NULL;
      thread -> info . sem_tokens = 0;
      thread -> info . resource = DNA_NO_RESOURCE;
      thread -> info . resource_id = -1;
    b594:	e3e02000 	mvn	r2, #0

      thread -> info . status = DNA_THREAD_READY;
    b598:	e59f3028 	ldr	r3, [pc, #40]	; b5c8 <semaphore_alarm+0xac>

    if (status == DNA_OK)
    {
      lock_acquire (& thread -> lock);

      thread -> resource_queue = NULL;
    b59c:	e5845018 	str	r5, [r4, #24]
      thread -> info . sem_tokens = 0;
    b5a0:	e584504c 	str	r5, [r4, #76]	; 0x4c
      thread -> info . resource = DNA_NO_RESOURCE;
    b5a4:	e5c45052 	strb	r5, [r4, #82]	; 0x52
      thread -> info . resource_id = -1;
    b5a8:	e5842054 	str	r2, [r4, #84]	; 0x54

      thread -> info . status = DNA_THREAD_READY;
    b5ac:	e1c435b0 	strh	r3, [r4, #80]	; 0x50
      status = scheduler_dispatch (thread);
    b5b0:	e1a00004 	mov	r0, r4
    }

    return status;
  }
}
    b5b4:	e8bd4038 	pop	{r3, r4, r5, lr}
      thread -> info . sem_tokens = 0;
      thread -> info . resource = DNA_NO_RESOURCE;
      thread -> info . resource_id = -1;

      thread -> info . status = DNA_THREAD_READY;
      status = scheduler_dispatch (thread);
    b5b8:	ea0001f6 	b	bd98 <scheduler_dispatch>
    b5bc:	0000b10c 	.word	0x0000b10c
    b5c0:	0000ffff 	.word	0x0000ffff
    b5c4:	0000fffc 	.word	0x0000fffc
    b5c8:	ffffface 	.word	0xffffface

0000b5cc <semaphore_acquire>:
 * SOURCE
 */

{
  bool has_alarm = false, can_interrupt = false;
  thread_t self = NULL, thread = NULL;
    b5cc:	e3a03000 	mov	r3, #0
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
    b5d0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t current_cpuid = 0;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tokens > 0, DNA_BAD_ARGUMENT);
    b5d4:	e2516000 	subs	r6, r1, #0
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
    b5d8:	e24dd03c 	sub	sp, sp, #60	; 0x3c
  bool has_alarm = false, can_interrupt = false;
  thread_t self = NULL, thread = NULL;
    b5dc:	e58d3028 	str	r3, [sp, #40]	; 0x28
    b5e0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
  semaphore_t sem = NULL;
  semaphore_id_t sid = { .raw = id };
  status_t status = DNA_OK, alarm_status = DNA_OK;
    b5e4:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
  int32_t alarm, rem_tokens;
  alarm_mode_t alarm_mode = DNA_ONE_SHOT_RELATIVE_ALARM;;
  uint32_t current_cpuid = 0;
  interrupt_status_t it_status = 0;
    b5e8:	e58d3034 	str	r3, [sp, #52]	; 0x34

  watch (status_t)
  {
    ensure (tokens > 0, DNA_BAD_ARGUMENT);
    b5ec:	da00000c 	ble	b624 <semaphore_acquire+0x58>
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);
    b5f0:	e1a05820 	lsr	r5, r0, #16
    b5f4:	e3550a01 	cmp	r5, #4096	; 0x1000
    b5f8:	e1a04000 	mov	r4, r0
    b5fc:	259f0410 	ldrcs	r0, [pc, #1040]	; ba14 <semaphore_acquire+0x448>
    b600:	3a00000a 	bcc	b630 <semaphore_acquire+0x64>
    sem -> info . tokens = rem_tokens + tokens;
    lock_release (& sem -> lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    b604:	e28dd03c 	add	sp, sp, #60	; 0x3c
    b608:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
     */

    if ((flags & DNA_RELATIVE_TIMEOUT) != 0)
    {
      has_alarm = true;
      alarm_mode = DNA_ONE_SHOT_RELATIVE_ALARM;
    b60c:	e3a09002 	mov	r9, #2
    {
      has_alarm = true;
      alarm_mode = DNA_ONE_SHOT_ABSOLUTE_ALARM;
    }

    ensure (! has_alarm || (has_alarm && timeout >= 0), DNA_BAD_ARGUMENT);
    b610:	e1cd06d0 	ldrd	r0, [sp, #96]	; 0x60
    b614:	e3500000 	cmp	r0, #0
    b618:	e2d11000 	sbcs	r1, r1, #0
    b61c:	a3a0b001 	movge	fp, #1
    b620:	aa000008 	bge	b648 <semaphore_acquire+0x7c>
  uint32_t current_cpuid = 0;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tokens > 0, DNA_BAD_ARGUMENT);
    b624:	e59f03ec 	ldr	r0, [pc, #1004]	; ba18 <semaphore_acquire+0x44c>
    sem -> info . tokens = rem_tokens + tokens;
    lock_release (& sem -> lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    b628:	e28dd03c 	add	sp, sp, #60	; 0x3c
    b62c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

    /*
     * Check the flags for a timeout parameter.
     */

    if ((flags & DNA_RELATIVE_TIMEOUT) != 0)
    b630:	e3120002 	tst	r2, #2
    b634:	1afffff4 	bne	b60c <semaphore_acquire+0x40>
    {
      has_alarm = true;
      alarm_mode = DNA_ONE_SHOT_RELATIVE_ALARM;
    }
    else if ((flags & DNA_ABSOLUTE_TIMEOUT) != 0)
    b638:	e212b004 	ands	fp, r2, #4
    {
      has_alarm = true;
      alarm_mode = DNA_ONE_SHOT_ABSOLUTE_ALARM;
    b63c:	13a09004 	movne	r9, #4
    b640:	1afffff2 	bne	b610 <semaphore_acquire+0x44>
  thread_t self = NULL, thread = NULL;
  semaphore_t sem = NULL;
  semaphore_id_t sid = { .raw = id };
  status_t status = DNA_OK, alarm_status = DNA_OK;
  int32_t alarm, rem_tokens;
  alarm_mode_t alarm_mode = DNA_ONE_SHOT_RELATIVE_ALARM;;
    b644:	e3a09002 	mov	r9, #2
    /*
     * Disable the interrupts, and get the current
     * execution environment (cpuid, self_id).
     */

    it_status = cpu_trap_mask_and_backup();
    b648:	e58d200c 	str	r2, [sp, #12]
    b64c:	ebfff92b 	bl	9b00 <cpu_trap_mask_and_backup>
    b650:	e58d0034 	str	r0, [sp, #52]	; 0x34
    current_cpuid = cpu_mp_id();
    b654:	ebfff97f 	bl	9c58 <cpu_mp_id>
    self = cpu_pool . cpu[current_cpuid] . current_thread;
    b658:	e59f33bc 	ldr	r3, [pc, #956]	; ba1c <semaphore_acquire+0x450>
    b65c:	e0800180 	add	r0, r0, r0, lsl #3
    b660:	e0833300 	add	r3, r3, r0, lsl #6

    /*
     * Look for the semaphore with ID sid.
     */

    lock_acquire (& semaphore_pool . lock);
    b664:	e59f73b4 	ldr	r7, [pc, #948]	; ba20 <semaphore_acquire+0x454>
     * execution environment (cpuid, self_id).
     */

    it_status = cpu_trap_mask_and_backup();
    current_cpuid = cpu_mp_id();
    self = cpu_pool . cpu[current_cpuid] . current_thread;
    b668:	e593322c 	ldr	r3, [r3, #556]	; 0x22c

    /*
     * Look for the semaphore with ID sid.
     */

    lock_acquire (& semaphore_pool . lock);
    b66c:	e1a00007 	mov	r0, r7

    sem = & semaphore_pool . data[sid . s . index];
    check (bad_semid, sem != NULL, DNA_BAD_SEM_ID);
    check (bad_semid, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
    b670:	e1a08205 	lsl	r8, r5, #4
     * execution environment (cpuid, self_id).
     */

    it_status = cpu_trap_mask_and_backup();
    current_cpuid = cpu_mp_id();
    self = cpu_pool . cpu[current_cpuid] . current_thread;
    b674:	e58d3028 	str	r3, [sp, #40]	; 0x28

    /*
     * Look for the semaphore with ID sid.
     */

    lock_acquire (& semaphore_pool . lock);
    b678:	ebfffa6c 	bl	a030 <lock_acquire>

    sem = & semaphore_pool . data[sid . s . index];
    check (bad_semid, sem != NULL, DNA_BAD_SEM_ID);
    check (bad_semid, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
    b67c:	e0883005 	add	r3, r8, r5
    b680:	e1a03103 	lsl	r3, r3, #2
    b684:	e087c003 	add	ip, r7, r3
    b688:	e59c100c 	ldr	r1, [ip, #12]
    b68c:	e1540001 	cmp	r4, r1
    b690:	159f437c 	ldrne	r4, [pc, #892]	; ba14 <semaphore_acquire+0x448>
    b694:	0a000005 	beq	b6b0 <semaphore_acquire+0xe4>
    return status;
  }

  rescue (bad_semid)
  {
    lock_release (& semaphore_pool . lock);
    b698:	e59f0380 	ldr	r0, [pc, #896]	; ba20 <semaphore_acquire+0x454>
    b69c:	eb000514 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    b6a0:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
    b6a4:	ebfff94e 	bl	9be4 <cpu_trap_restore>
    leave;
    b6a8:	e1a00004 	mov	r0, r4
    b6ac:	eaffffd4 	b	b604 <semaphore_acquire+0x38>
    check (bad_semid, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);

dna_log(VERBOSE_LEVEL, "%s(#%d), %d:%d(#%d)", self -> info . name,
        tokens, sid . s . value, sid . s . index, sem -> info . tokens);

    lock_acquire (& sem -> lock);
    b6b0:	e283a010 	add	sl, r3, #16
    b6b4:	e08aa007 	add	sl, sl, r7
    b6b8:	e1a0000a 	mov	r0, sl
    b6bc:	e58dc010 	str	ip, [sp, #16]
    b6c0:	e58d3014 	str	r3, [sp, #20]
    b6c4:	ebfffa59 	bl	a030 <lock_acquire>
    lock_release (& semaphore_pool . lock);
    b6c8:	e1a00007 	mov	r0, r7
    b6cc:	eb000508 	bl	caf4 <lock_release>

    /*
     * Remove the necessary tokens and decide what
     * to do next depending on the result.
     */
    cpu_dcache_invalidate((void*)&(sem->info.tokens), sizeof(int32_t));
    b6d0:	e59d3014 	ldr	r3, [sp, #20]
    b6d4:	e3a01004 	mov	r1, #4
    b6d8:	e0870003 	add	r0, r7, r3
    b6dc:	e2800044 	add	r0, r0, #68	; 0x44
    b6e0:	ebfff972 	bl	9cb0 <cpu_dcache_invalidate>
    rem_tokens = sem -> info . tokens - tokens;
    b6e4:	e59dc010 	ldr	ip, [sp, #16]

    if (rem_tokens >= 0)
    b6e8:	e59d200c 	ldr	r2, [sp, #12]
    /*
     * Remove the necessary tokens and decide what
     * to do next depending on the result.
     */
    cpu_dcache_invalidate((void*)&(sem->info.tokens), sizeof(int32_t));
    rem_tokens = sem -> info . tokens - tokens;
    b6ec:	e59c0044 	ldr	r0, [ip, #68]	; 0x44

    if (rem_tokens >= 0)
    b6f0:	e0501006 	subs	r1, r0, r6
    /*
     * Remove the necessary tokens and decide what
     * to do next depending on the result.
     */
    cpu_dcache_invalidate((void*)&(sem->info.tokens), sizeof(int32_t));
    rem_tokens = sem -> info . tokens - tokens;
    b6f4:	e58d0018 	str	r0, [sp, #24]

    if (rem_tokens >= 0)
    b6f8:	e58d101c 	str	r1, [sp, #28]
    b6fc:	4a000011 	bmi	b748 <semaphore_acquire+0x17c>

    /*
     * If the acquire succeeded, set the latest holder as self.
     */
    
    if (status == DNA_OK)
    b700:	e1dd32b6 	ldrh	r3, [sp, #38]	; 0x26
    {
      /*
       * Everything is OK, take the requested tokens.
       */

      sem -> info . tokens -= tokens;
    b704:	e58c1044 	str	r1, [ip, #68]	; 0x44

    /*
     * If the acquire succeeded, set the latest holder as self.
     */
    
    if (status == DNA_OK)
    b708:	e3530000 	cmp	r3, #0
    b70c:	1a000004 	bne	b724 <semaphore_acquire+0x158>
    b710:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
    {
      sem -> info . latest_holder = self -> id . raw;
    b714:	e0885005 	add	r5, r8, r5
    b718:	e591301c 	ldr	r3, [r1, #28]
    b71c:	e0877105 	add	r7, r7, r5, lsl #2
    b720:	e5873048 	str	r3, [r7, #72]	; 0x48
    }

    lock_release (& sem -> lock);
    b724:	e1a0000a 	mov	r0, sl
    b728:	eb0004f1 	bl	caf4 <lock_release>
    cpu_dcache_invalidate((void*)&it_status,sizeof(interrupt_status_t));
    b72c:	e28d0034 	add	r0, sp, #52	; 0x34
    b730:	e3a01004 	mov	r1, #4
    b734:	ebfff95d 	bl	9cb0 <cpu_dcache_invalidate>
    cpu_trap_restore(it_status);
    b738:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
    b73c:	ebfff928 	bl	9be4 <cpu_trap_restore>
    return status;
    b740:	e1dd02b6 	ldrh	r0, [sp, #38]	; 0x26
    b744:	eaffffae 	b	b604 <semaphore_acquire+0x38>

      sem -> info . tokens -= tokens;
    }
    else
    {
      check (quick_abort, (! has_alarm) ||
    b748:	e35b0000 	cmp	fp, #0
    b74c:	0a000009 	beq	b778 <semaphore_acquire+0x1ac>
    b750:	e1cd26d0 	ldrd	r2, [sp, #96]	; 0x60
    b754:	e1923003 	orrs	r3, r2, r3
    b758:	1a000080 	bne	b960 <semaphore_acquire+0x394>
    b75c:	e59f42c0 	ldr	r4, [pc, #704]	; ba24 <semaphore_acquire+0x458>
    leave;
  }

  rescue (quick_abort)
  {
    lock_release (& sem -> lock);
    b760:	e1a0000a 	mov	r0, sl
    b764:	eb0004e2 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    b768:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
    b76c:	ebfff91c 	bl	9be4 <cpu_trap_restore>
    leave;
    b770:	e1a00004 	mov	r0, r4
    b774:	eaffffa2 	b	b604 <semaphore_acquire+0x38>

      /*
       * Update self information.
       */

      lock_acquire (& self -> lock);
    b778:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
      /*
       * Not enough tokens. Set the sem -> tokens to 0.
       * Create the alarm if necessary.
       */

      sem -> info . tokens = 0;
    b77c:	e58cb044 	str	fp, [ip, #68]	; 0x44

      /*
       * Update self information.
       */

      lock_acquire (& self -> lock);
    b780:	e2800014 	add	r0, r0, #20
    b784:	e58d200c 	str	r2, [sp, #12]
    b788:	ebfffa28 	bl	a030 <lock_acquire>

      if (can_interrupt || has_alarm)
    b78c:	e59d200c 	ldr	r2, [sp, #12]
    b790:	e3120008 	tst	r2, #8
    b794:	1a00006b 	bne	b948 <semaphore_acquire+0x37c>
      {
        self -> resource_queue = & sem -> waiting_queue;
      }
      else
      {
        self -> resource_queue = NULL;
    b798:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
    b79c:	e28a9004 	add	r9, sl, #4
    b7a0:	e583b018 	str	fp, [r3, #24]
      }

      self -> info . sem_tokens = -1 * rem_tokens;
      self -> info . status = DNA_THREAD_WAITING;
      self -> info . resource = DNA_RESOURCE_SEMAPHORE;
    b7a4:	e3a01001 	mov	r1, #1
      else
      {
        self -> resource_queue = NULL;
      }

      self -> info . sem_tokens = -1 * rem_tokens;
    b7a8:	e59d201c 	ldr	r2, [sp, #28]
      self -> info . status = DNA_THREAD_WAITING;
    b7ac:	e59f0274 	ldr	r0, [pc, #628]	; ba28 <semaphore_acquire+0x45c>
      else
      {
        self -> resource_queue = NULL;
      }

      self -> info . sem_tokens = -1 * rem_tokens;
    b7b0:	e262c000 	rsb	ip, r2, #0
      self -> info . status = DNA_THREAD_WAITING;
      self -> info . resource = DNA_RESOURCE_SEMAPHORE;
      self -> info . resource_id = sem -> id . raw;
    b7b4:	e0882005 	add	r2, r8, r5
        self -> resource_queue = NULL;
      }

      self -> info . sem_tokens = -1 * rem_tokens;
      self -> info . status = DNA_THREAD_WAITING;
      self -> info . resource = DNA_RESOURCE_SEMAPHORE;
    b7b8:	e5c31052 	strb	r1, [r3, #82]	; 0x52
      {
        self -> resource_queue = NULL;
      }

      self -> info . sem_tokens = -1 * rem_tokens;
      self -> info . status = DNA_THREAD_WAITING;
    b7bc:	e1c305b0 	strh	r0, [r3, #80]	; 0x50
      else
      {
        self -> resource_queue = NULL;
      }

      self -> info . sem_tokens = -1 * rem_tokens;
    b7c0:	e583c04c 	str	ip, [r3, #76]	; 0x4c
      self -> info . status = DNA_THREAD_WAITING;
      self -> info . resource = DNA_RESOURCE_SEMAPHORE;
      self -> info . resource_id = sem -> id . raw;
    b7c4:	e0872102 	add	r2, r7, r2, lsl #2
    b7c8:	e592200c 	ldr	r2, [r2, #12]

      /*
       * Look for a potential target thread.
       */

      lock_acquire (& sem -> waiting_queue . lock);
    b7cc:	e1a00009 	mov	r0, r9
      }

      self -> info . sem_tokens = -1 * rem_tokens;
      self -> info . status = DNA_THREAD_WAITING;
      self -> info . resource = DNA_RESOURCE_SEMAPHORE;
      self -> info . resource_id = sem -> id . raw;
    b7d0:	e5832054 	str	r2, [r3, #84]	; 0x54

      /*
       * Look for a potential target thread.
       */

      lock_acquire (& sem -> waiting_queue . lock);
    b7d4:	e58d1014 	str	r1, [sp, #20]
    b7d8:	ebfffa14 	bl	a030 <lock_acquire>
      lock_release (& sem -> lock);
    b7dc:	e1a0000a 	mov	r0, sl
    b7e0:	eb0004c3 	bl	caf4 <lock_release>

      status = scheduler_elect (& thread, true);
    b7e4:	e59d1014 	ldr	r1, [sp, #20]
    b7e8:	e28d002c 	add	r0, sp, #44	; 0x2c
    b7ec:	eb00012f 	bl	bcb0 <scheduler_elect>
      ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);
    b7f0:	e59f2234 	ldr	r2, [pc, #564]	; ba2c <semaphore_acquire+0x460>
    b7f4:	e59f321c 	ldr	r3, [pc, #540]	; ba18 <semaphore_acquire+0x44c>
       */

      lock_acquire (& sem -> waiting_queue . lock);
      lock_release (& sem -> lock);

      status = scheduler_elect (& thread, true);
    b7f8:	e1cd02b6 	strh	r0, [sp, #38]	; 0x26
      ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);
    b7fc:	e1500002 	cmp	r0, r2
    b800:	11500003 	cmpne	r0, r3
      }

      self -> info . sem_tokens = -1 * rem_tokens;
      self -> info . status = DNA_THREAD_WAITING;
      self -> info . resource = DNA_RESOURCE_SEMAPHORE;
      self -> info . resource_id = sem -> id . raw;
    b804:	e59f2214 	ldr	r2, [pc, #532]	; ba20 <semaphore_acquire+0x454>

      lock_acquire (& sem -> waiting_queue . lock);
      lock_release (& sem -> lock);

      status = scheduler_elect (& thread, true);
      ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);
    b808:	0affff7d 	beq	b604 <semaphore_acquire+0x38>

      /*
       * Add self in the ready queue.
       */

      queue_add (& sem -> waiting_queue, self);
    b80c:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
    b810:	e1a00009 	mov	r0, r9
    b814:	e58d200c 	str	r2, [sp, #12]
    b818:	e58d3014 	str	r3, [sp, #20]
    b81c:	ebfff718 	bl	9484 <queue_add>

      /*
       * Reschedule self.
       */
      cpu_dcache_invalidate((void*)&thread, sizeof(thread_t));
    b820:	e28d002c 	add	r0, sp, #44	; 0x2c
    b824:	e3a01004 	mov	r1, #4
    b828:	ebfff920 	bl	9cb0 <cpu_dcache_invalidate>
      cpu_dcache_invalidate((void*)&sem->waiting_queue, sizeof(queue_t));
    b82c:	e1a00009 	mov	r0, r9
    b830:	e3a01010 	mov	r1, #16
    b834:	ebfff91d 	bl	9cb0 <cpu_dcache_invalidate>
      status = scheduler_switch (thread, & sem -> waiting_queue);
    b838:	e1a01009 	mov	r1, r9
    b83c:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    b840:	eb000320 	bl	c4c8 <scheduler_switch>
    b844:	e28d1038 	add	r1, sp, #56	; 0x38
    b848:	e16101b2 	strh	r0, [r1, #-18]!	; 0xffffffee
      cpu_dcache_invalidate((void*)&status, sizeof(status_t));
    b84c:	e1a00001 	mov	r0, r1
    b850:	e3a01002 	mov	r1, #2
    b854:	ebfff915 	bl	9cb0 <cpu_dcache_invalidate>
      ensure (status == DNA_OK, status);
    b858:	e1dd02b6 	ldrh	r0, [sp, #38]	; 0x26
    b85c:	e59d200c 	ldr	r2, [sp, #12]
    b860:	e3500000 	cmp	r0, #0
    b864:	1affff66 	bne	b604 <semaphore_acquire+0x38>

      /*
       * Check if the semaphore still exist.
       */

      lock_acquire (& semaphore_pool . lock);
    b868:	e1a00002 	mov	r0, r2
    b86c:	ebfff9ef 	bl	a030 <lock_acquire>

      sem = & semaphore_pool . data[sid . s . index];
      check (bad_semid, sem != NULL, DNA_SEM_DESTROYED);
      check (bad_semid, sem -> id . raw == sid . raw, DNA_SEM_DESTROYED);
    b870:	e3a01044 	mov	r1, #68	; 0x44
    b874:	e59d200c 	ldr	r2, [sp, #12]
    b878:	e0212591 	mla	r1, r1, r5, r2
    b87c:	e591100c 	ldr	r1, [r1, #12]
    b880:	e1540001 	cmp	r4, r1
    b884:	159f41a4 	ldrne	r4, [pc, #420]	; ba30 <semaphore_acquire+0x464>
    b888:	1affff82 	bne	b698 <semaphore_acquire+0xcc>

      lock_acquire (& sem -> lock);
    b88c:	e1a0000a 	mov	r0, sl
    b890:	ebfff9e6 	bl	a030 <lock_acquire>
      lock_release (& semaphore_pool . lock);
    b894:	e59d200c 	ldr	r2, [sp, #12]
    b898:	e1a00002 	mov	r0, r2
    b89c:	eb000494 	bl	caf4 <lock_release>

      /*
       * If there is an alarm programmed, cancel it.
       */

      if (has_alarm)
    b8a0:	e35b0000 	cmp	fp, #0
    b8a4:	0a00003b 	beq	b998 <semaphore_acquire+0x3cc>
      {
        alarm_status = alarm_destroy (alarm);
    b8a8:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
    b8ac:	eb000397 	bl	c710 <alarm_destroy>
        check (quick_abort, status != DNA_NO_TIMER, status);
    b8b0:	e1dd22b6 	ldrh	r2, [sp, #38]	; 0x26
    b8b4:	e59f1178 	ldr	r1, [pc, #376]	; ba34 <semaphore_acquire+0x468>
       * If there is an alarm programmed, cancel it.
       */

      if (has_alarm)
      {
        alarm_status = alarm_destroy (alarm);
    b8b8:	e1a04000 	mov	r4, r0
        check (quick_abort, status != DNA_NO_TIMER, status);
    b8bc:	e1520001 	cmp	r2, r1
    b8c0:	e59d3014 	ldr	r3, [sp, #20]
    b8c4:	0a000050 	beq	ba0c <semaphore_acquire+0x440>
        check (quick_abort, status != DNA_BAD_ARGUMENT, status);
    b8c8:	e1520003 	cmp	r2, r3
    b8cc:	0a00004e 	beq	ba0c <semaphore_acquire+0x440>

      /*
       * Check if we have not been interrupted with a
       * thread_suspend/thread_resume combination.
       */
      cpu_dcache_invalidate((void*)&self,sizeof(thread_t*));
    b8d0:	e28d0028 	add	r0, sp, #40	; 0x28
    b8d4:	e3a01004 	mov	r1, #4
    b8d8:	ebfff8f4 	bl	9cb0 <cpu_dcache_invalidate>
      cpu_dcache_invalidate((void*)&self->info.resource,sizeof(thread_resource_t));
    b8dc:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    b8e0:	e3a01001 	mov	r1, #1
    b8e4:	e2800052 	add	r0, r0, #82	; 0x52
    b8e8:	ebfff8f0 	bl	9cb0 <cpu_dcache_invalidate>
      check (acquire_interrupted,
    b8ec:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
    b8f0:	e5d13052 	ldrb	r3, [r1, #82]	; 0x52
    b8f4:	e3530000 	cmp	r3, #0
    b8f8:	1a000028 	bne	b9a0 <semaphore_acquire+0x3d4>
       * Although a status equal to DNA_UNKNOWN_ALARM means that the alarm
       * has already been fired, the semaphore could perfectly have been
       * V()-ed in the meantime. Hence, we need to recheck the sem tokens.
       */

      if (has_alarm && alarm_status == DNA_UNKNOWN_ALARM)
    b8fc:	e59f3134 	ldr	r3, [pc, #308]	; ba38 <semaphore_acquire+0x46c>
    b900:	e1540003 	cmp	r4, r3
    b904:	13a04000 	movne	r4, #0
    b908:	020b4001 	andeq	r4, fp, #1
    b90c:	e3540000 	cmp	r4, #0
    b910:	0a000006 	beq	b930 <semaphore_acquire+0x364>
      {
        check (acquire_timed_out,
    b914:	e3a04044 	mov	r4, #68	; 0x44
    b918:	e0247594 	mla	r4, r4, r5, r7
    b91c:	e5943044 	ldr	r3, [r4, #68]	; 0x44
    b920:	e1560003 	cmp	r6, r3
            sem -> info . tokens >= tokens, DNA_TIMED_OUT);
        sem -> info . tokens -= tokens;
    b924:	d0663003 	rsble	r3, r6, r3
    b928:	d5843044 	strle	r3, [r4, #68]	; 0x44
       * V()-ed in the meantime. Hence, we need to recheck the sem tokens.
       */

      if (has_alarm && alarm_status == DNA_UNKNOWN_ALARM)
      {
        check (acquire_timed_out,
    b92c:	ca00002c 	bgt	b9e4 <semaphore_acquire+0x418>
            sem -> info . tokens >= tokens, DNA_TIMED_OUT);
        sem -> info . tokens -= tokens;
      }

      status = DNA_OK;
    b930:	e3a03000 	mov	r3, #0
    b934:	e1cd32b6 	strh	r3, [sp, #38]	; 0x26
    b938:	eaffff75 	b	b714 <semaphore_acquire+0x148>

      /*
       * Update self information.
       */

      lock_acquire (& self -> lock);
    b93c:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    b940:	e2800014 	add	r0, r0, #20
    b944:	ebfff9b9 	bl	a030 <lock_acquire>

      if (can_interrupt || has_alarm)
      {
        self -> resource_queue = & sem -> waiting_queue;
    b948:	e0889005 	add	r9, r8, r5
    b94c:	e0879109 	add	r9, r7, r9, lsl #2
    b950:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
    b954:	e2899014 	add	r9, r9, #20
    b958:	e5839018 	str	r9, [r3, #24]
    b95c:	eaffff90 	b	b7a4 <semaphore_acquire+0x1d8>
      /*
       * Not enough tokens. Set the sem -> tokens to 0.
       * Create the alarm if necessary.
       */

      sem -> info . tokens = 0;
    b960:	e3a01000 	mov	r1, #0

      if (has_alarm)
      {
        status = alarm_create (timeout, alarm_mode,
    b964:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    b968:	e28d3030 	add	r3, sp, #48	; 0x30
    b96c:	e88d0009 	stm	sp, {r0, r3}
    b970:	e1a02009 	mov	r2, r9
      /*
       * Not enough tokens. Set the sem -> tokens to 0.
       * Create the alarm if necessary.
       */

      sem -> info . tokens = 0;
    b974:	e58c1044 	str	r1, [ip, #68]	; 0x44

      if (has_alarm)
      {
        status = alarm_create (timeout, alarm_mode,
    b978:	e59f30bc 	ldr	r3, [pc, #188]	; ba3c <semaphore_acquire+0x470>
    b97c:	e1cd06d0 	ldrd	r0, [sp, #96]	; 0x60
    b980:	ebfffc1a 	bl	a9f0 <alarm_create>
            semaphore_alarm, self, & alarm);
        check (quick_abort, status == DNA_OK, status);
    b984:	e3500000 	cmp	r0, #0

      sem -> info . tokens = 0;

      if (has_alarm)
      {
        status = alarm_create (timeout, alarm_mode,
    b988:	e1cd02b6 	strh	r0, [sp, #38]	; 0x26
            semaphore_alarm, self, & alarm);
        check (quick_abort, status == DNA_OK, status);
    b98c:	0affffea 	beq	b93c <semaphore_acquire+0x370>
    b990:	e1a04000 	mov	r4, r0
    b994:	eaffff71 	b	b760 <semaphore_acquire+0x194>
{
  bool has_alarm = false, can_interrupt = false;
  thread_t self = NULL, thread = NULL;
  semaphore_t sem = NULL;
  semaphore_id_t sid = { .raw = id };
  status_t status = DNA_OK, alarm_status = DNA_OK;
    b998:	e1a0400b 	mov	r4, fp
    b99c:	eaffffcb 	b	b8d0 <semaphore_acquire+0x304>
    leave;
  }

  rescue (acquire_interrupted)
  {
    lock_acquire (& self -> lock);
    b9a0:	e2810014 	add	r0, r1, #20
    b9a4:	ebfff9a1 	bl	a030 <lock_acquire>
    self -> resource_queue = NULL;
    b9a8:	e3a03000 	mov	r3, #0
    self -> info . sem_tokens = 0;
    self -> info . resource = DNA_NO_RESOURCE;
    self -> info . resource_id = -1;
    b9ac:	e3e02000 	mvn	r2, #0
  }

  rescue (acquire_interrupted)
  {
    lock_acquire (& self -> lock);
    self -> resource_queue = NULL;
    b9b0:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
    b9b4:	e5803018 	str	r3, [r0, #24]
    self -> info . sem_tokens = 0;
    b9b8:	e580304c 	str	r3, [r0, #76]	; 0x4c
    self -> info . resource = DNA_NO_RESOURCE;
    b9bc:	e5c03052 	strb	r3, [r0, #82]	; 0x52
    self -> info . resource_id = -1;
    b9c0:	e5802054 	str	r2, [r0, #84]	; 0x54
    lock_release (& self -> lock);
    b9c4:	e2800014 	add	r0, r0, #20
    b9c8:	eb000449 	bl	caf4 <lock_release>

    lock_release (& sem -> lock);
    b9cc:	e1a0000a 	mov	r0, sl
    b9d0:	eb000447 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    b9d4:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
    b9d8:	ebfff881 	bl	9be4 <cpu_trap_restore>
    leave;
    b9dc:	e59f005c 	ldr	r0, [pc, #92]	; ba40 <semaphore_acquire+0x474>
    b9e0:	eaffff07 	b	b604 <semaphore_acquire+0x38>
  }

  rescue (acquire_timed_out)
  {
    queue_extract (& sem -> waiting_queue, self);
    b9e4:	e1a00009 	mov	r0, r9
    b9e8:	ebfff39c 	bl	8860 <queue_extract>
    sem -> info . tokens = rem_tokens + tokens;
    b9ec:	e59d5018 	ldr	r5, [sp, #24]
    lock_release (& sem -> lock);
    b9f0:	e1a0000a 	mov	r0, sl
  }

  rescue (acquire_timed_out)
  {
    queue_extract (& sem -> waiting_queue, self);
    sem -> info . tokens = rem_tokens + tokens;
    b9f4:	e5845044 	str	r5, [r4, #68]	; 0x44
    lock_release (& sem -> lock);
    b9f8:	eb00043d 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    b9fc:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
    ba00:	ebfff877 	bl	9be4 <cpu_trap_restore>
    leave;
    ba04:	e59f0038 	ldr	r0, [pc, #56]	; ba44 <semaphore_acquire+0x478>
    ba08:	eafffefd 	b	b604 <semaphore_acquire+0x38>
    ba0c:	e1a04002 	mov	r4, r2
    ba10:	eaffff52 	b	b760 <semaphore_acquire+0x194>
    ba14:	0000fdff 	.word	0x0000fdff
    ba18:	0000fffc 	.word	0x0000fffc
    ba1c:	0007e458 	.word	0x0007e458
    ba20:	00035610 	.word	0x00035610
    ba24:	0000fdfd 	.word	0x0000fdfd
    ba28:	ffffb10c 	.word	0xffffb10c
    ba2c:	0000ffff 	.word	0x0000ffff
    ba30:	0000fdfb 	.word	0x0000fdfb
    ba34:	0000fbff 	.word	0x0000fbff
    ba38:	0000fbfe 	.word	0x0000fbfe
    ba3c:	0000b51c 	.word	0x0000b51c
    ba40:	0000fff9 	.word	0x0000fff9
    ba44:	0000fdfc 	.word	0x0000fdfc

0000ba48 <thread_exit>:
 * * value : the thread's return value
 *
 * SOURCE
 */

{
    ba48:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  uint32_t current_cpuid = 0;
  thread_t self = NULL;
  thread_t target = NULL, p = NULL;
    ba4c:	e3a05000 	mov	r5, #0
 * * value : the thread's return value
 *
 * SOURCE
 */

{
    ba50:	e24dd008 	sub	sp, sp, #8
    ba54:	e1a08000 	mov	r8, r0
  uint32_t current_cpuid = 0;
  thread_t self = NULL;
  thread_t target = NULL, p = NULL;
    ba58:	e58d5004 	str	r5, [sp, #4]
   */

#if 0
  it_status = cpu_trap_mask_and_backup();
#endif
  cpu_trap_mask_and_backup();
    ba5c:	ebfff827 	bl	9b00 <cpu_trap_mask_and_backup>

  current_cpuid = cpu_mp_id();
    ba60:	ebfff87c 	bl	9c58 <cpu_mp_id>
  self = cpu_pool . cpu[current_cpuid] . current_thread;
    ba64:	e59f3098 	ldr	r3, [pc, #152]	; bb04 <thread_exit+0xbc>
    ba68:	e0800180 	add	r0, r0, r0, lsl #3
    ba6c:	e0833300 	add	r3, r3, r0, lsl #6
    ba70:	e593422c 	ldr	r4, [r3, #556]	; 0x22c

  /*
   * And we place the return value in our structure
   */

  lock_acquire (& self -> lock);
    ba74:	e2847014 	add	r7, r4, #20
    ba78:	e1a00007 	mov	r0, r7
    ba7c:	ebfff96b 	bl	a030 <lock_acquire>

  /*
   * Mark self as ended.
   */

  self -> info . status = DNA_THREAD_ENDED;
    ba80:	e59f3080 	ldr	r3, [pc, #128]	; bb08 <thread_exit+0xc0>

  lock_acquire (& self -> wait . lock);
    ba84:	e2846004 	add	r6, r4, #4
  /*
   * And we place the return value in our structure
   */

  lock_acquire (& self -> lock);
  self -> signature . return_value = value;
    ba88:	e5848080 	str	r8, [r4, #128]	; 0x80

  /*
   * Mark self as ended.
   */

  self -> info . status = DNA_THREAD_ENDED;
    ba8c:	e1c435b0 	strh	r3, [r4, #80]	; 0x50

  lock_acquire (& self -> wait . lock);
    ba90:	e1a00006 	mov	r0, r6
    ba94:	ebfff965 	bl	a030 <lock_acquire>
  lock_release (& self -> lock);
    ba98:	e1a00007 	mov	r0, r7
    ba9c:	eb000414 	bl	caf4 <lock_release>
  while ((p = queue_rem (& self -> wait)) != NULL)
  {
    lock_acquire (& p -> lock);

    p -> resource_queue = NULL;
    p -> info . status = DNA_THREAD_READY;
    baa0:	e59f8064 	ldr	r8, [pc, #100]	; bb0c <thread_exit+0xc4>
    p -> info . resource = DNA_NO_RESOURCE;
    p -> info . resource_id = -1;
    baa4:	e3e07000 	mvn	r7, #0

  /*
   * Then we can wake up the waiting threads
   */

  while ((p = queue_rem (& self -> wait)) != NULL)
    baa8:	ea000006 	b	bac8 <thread_exit+0x80>
  {
    lock_acquire (& p -> lock);
    baac:	ebfff95f 	bl	a030 <lock_acquire>

    p -> resource_queue = NULL;
    bab0:	e5845018 	str	r5, [r4, #24]
    p -> info . status = DNA_THREAD_READY;
    bab4:	e1c485b0 	strh	r8, [r4, #80]	; 0x50
    p -> info . resource = DNA_NO_RESOURCE;
    bab8:	e5c45052 	strb	r5, [r4, #82]	; 0x52
    p -> info . resource_id = -1;
    babc:	e5847054 	str	r7, [r4, #84]	; 0x54

    scheduler_dispatch (p);
    bac0:	e1a00004 	mov	r0, r4
    bac4:	eb0000b3 	bl	bd98 <scheduler_dispatch>

  /*
   * Then we can wake up the waiting threads
   */

  while ((p = queue_rem (& self -> wait)) != NULL)
    bac8:	e1a00006 	mov	r0, r6
    bacc:	ebfff3a3 	bl	8960 <queue_rem>
    bad0:	e2504000 	subs	r4, r0, #0
  {
    lock_acquire (& p -> lock);
    bad4:	e2840014 	add	r0, r4, #20

  /*
   * Then we can wake up the waiting threads
   */

  while ((p = queue_rem (& self -> wait)) != NULL)
    bad8:	1afffff3 	bne	baac <thread_exit+0x64>
    p -> info . resource_id = -1;

    scheduler_dispatch (p);
  }

  lock_release (& self -> wait . lock);
    badc:	e1a00006 	mov	r0, r6
    bae0:	eb000403 	bl	caf4 <lock_release>

  /*
   * Elect a the next thread and run it
   */

  scheduler_elect (& target, true);
    bae4:	e28d0004 	add	r0, sp, #4
    bae8:	e3a01001 	mov	r1, #1
    baec:	eb00006f 	bl	bcb0 <scheduler_elect>
  scheduler_switch (target, NULL);
    baf0:	e1a01004 	mov	r1, r4
    baf4:	e59d0004 	ldr	r0, [sp, #4]
    baf8:	eb000272 	bl	c4c8 <scheduler_switch>
}
    bafc:	e28dd008 	add	sp, sp, #8
    bb00:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    bb04:	0007e458 	.word	0x0007e458
    bb08:	ffffdead 	.word	0xffffdead
    bb0c:	ffffface 	.word	0xffffface

0000bb10 <port_destroy>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    bb10:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  interrupt_status_t it_status = 0;
  status_t status;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
    bb14:	e1a04820 	lsr	r4, r0, #16
    bb18:	e354003f 	cmp	r4, #63	; 0x3f
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    bb1c:	e1a05000 	mov	r5, r0
  interrupt_status_t it_status = 0;
  status_t status;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
    bb20:	9a000001 	bls	bb2c <port_destroy+0x1c>
    bb24:	e59f010c 	ldr	r0, [pc, #268]	; bc38 <port_destroy+0x128>
  {
    lock_release (& port_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    bb28:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
     * remove its entry from the pool.
     */

    port = & port_pool . data[pid . s . index];
    check (invalid_port, port != NULL, DNA_BAD_PORT_ID);
    check (invalid_port, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    bb2c:	e3a06068 	mov	r6, #104	; 0x68

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);

    it_status = cpu_trap_mask_and_backup();
    bb30:	ebfff7f2 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& port_pool . lock);
    bb34:	e59f7100 	ldr	r7, [pc, #256]	; bc3c <port_destroy+0x12c>

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);

    it_status = cpu_trap_mask_and_backup();
    bb38:	e1a08000 	mov	r8, r0
     * remove its entry from the pool.
     */

    port = & port_pool . data[pid . s . index];
    check (invalid_port, port != NULL, DNA_BAD_PORT_ID);
    check (invalid_port, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    bb3c:	e0267496 	mla	r6, r6, r4, r7
  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& port_pool . lock);
    bb40:	e1a00007 	mov	r0, r7
    bb44:	ebfff939 	bl	a030 <lock_acquire>
     * remove its entry from the pool.
     */

    port = & port_pool . data[pid . s . index];
    check (invalid_port, port != NULL, DNA_BAD_PORT_ID);
    check (invalid_port, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    bb48:	e596300c 	ldr	r3, [r6, #12]
    bb4c:	e1550003 	cmp	r5, r3
    bb50:	0a000005 	beq	bb6c <port_destroy+0x5c>
    return DNA_OK;
  }

  rescue (invalid_port)
  {
    lock_release (& port_pool . lock);
    bb54:	e1a00007 	mov	r0, r7
    bb58:	eb0003e5 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    bb5c:	e1a00008 	mov	r0, r8
    bb60:	ebfff81f 	bl	9be4 <cpu_trap_restore>
    leave;
    bb64:	e59f00cc 	ldr	r0, [pc, #204]	; bc38 <port_destroy+0x128>
    bb68:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

    port = & port_pool . data[pid . s . index];
    check (invalid_port, port != NULL, DNA_BAD_PORT_ID);
    check (invalid_port, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    port -> id . s . value = 0;
    bb6c:	e3a02000 	mov	r2, #0

    lock_release (& port_pool . lock);
    bb70:	e1a00007 	mov	r0, r7

    port = & port_pool . data[pid . s . index];
    check (invalid_port, port != NULL, DNA_BAD_PORT_ID);
    check (invalid_port, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    port -> id . s . value = 0;
    bb74:	e1c620bc 	strh	r2, [r6, #12]

    lock_release (& port_pool . lock);
    bb78:	eb0003dd 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    bb7c:	e1a00008 	mov	r0, r8
    bb80:	ebfff817 	bl	9be4 <cpu_trap_restore>

    /*
     * Destroy the port's semaphore.
     */

    status = semaphore_destroy (port -> read_sem);
    bb84:	e5960044 	ldr	r0, [r6, #68]	; 0x44
    bb88:	ebfff9a4 	bl	a220 <semaphore_destroy>
    panic (status != DNA_OK);
    bb8c:	e3500000 	cmp	r0, #0
    bb90:	0a000000 	beq	bb98 <port_destroy+0x88>
    bb94:	eafffffe 	b	bb94 <port_destroy+0x84>

    status = semaphore_destroy (port -> write_sem);
    bb98:	e5960048 	ldr	r0, [r6, #72]	; 0x48
    bb9c:	ebfff99f 	bl	a220 <semaphore_destroy>
    panic (status != DNA_OK);
    bba0:	e3500000 	cmp	r0, #0
    bba4:	1a000010 	bne	bbec <port_destroy+0xdc>

    /*
     * Delete the port's memory and its messages.
     */

    for (int32_t i = 0; i < port -> info . capacity; i += 1)
    bba8:	e5963038 	ldr	r3, [r6, #56]	; 0x38
    bbac:	e3530000 	cmp	r3, #0
    bbb0:	da00000e 	ble	bbf0 <port_destroy+0xe0>
    bbb4:	e1a05000 	mov	r5, r0
    bbb8:	e1a08006 	mov	r8, r6
    bbbc:	e596304c 	ldr	r3, [r6, #76]	; 0x4c
    {
      if (port -> data[i] . buffer != NULL)
    bbc0:	e0832205 	add	r2, r3, r5, lsl #4
    bbc4:	e592000c 	ldr	r0, [r2, #12]

    /*
     * Delete the port's memory and its messages.
     */

    for (int32_t i = 0; i < port -> info . capacity; i += 1)
    bbc8:	e2855001 	add	r5, r5, #1
    {
      if (port -> data[i] . buffer != NULL)
    bbcc:	e3500000 	cmp	r0, #0
    bbd0:	0a000001 	beq	bbdc <port_destroy+0xcc>
      {
        kernel_free (port -> data[i] . buffer);
    bbd4:	eb0006fb 	bl	d7c8 <kernel_free>
    bbd8:	e598304c 	ldr	r3, [r8, #76]	; 0x4c

    /*
     * Delete the port's memory and its messages.
     */

    for (int32_t i = 0; i < port -> info . capacity; i += 1)
    bbdc:	e5982038 	ldr	r2, [r8, #56]	; 0x38
    bbe0:	e1520005 	cmp	r2, r5
    bbe4:	cafffff5 	bgt	bbc0 <port_destroy+0xb0>
    bbe8:	ea000001 	b	bbf4 <port_destroy+0xe4>

    status = semaphore_destroy (port -> read_sem);
    panic (status != DNA_OK);

    status = semaphore_destroy (port -> write_sem);
    panic (status != DNA_OK);
    bbec:	eafffffe 	b	bbec <port_destroy+0xdc>
    bbf0:	e596304c 	ldr	r3, [r6, #76]	; 0x4c
      {
        kernel_free (port -> data[i] . buffer);
      }
    }

    kernel_free (port -> data);
    bbf4:	e1a00003 	mov	r0, r3
    bbf8:	eb0006f2 	bl	d7c8 <kernel_free>

    /*
     * Add the port back to the pool.
     */

    it_status = cpu_trap_mask_and_backup();
    bbfc:	ebfff7bf 	bl	9b00 <cpu_trap_mask_and_backup>
    bc00:	e1a05000 	mov	r5, r0
    lock_acquire (& port_pool . lock);
    bc04:	e59f0030 	ldr	r0, [pc, #48]	; bc3c <port_destroy+0x12c>
    bc08:	ebfff908 	bl	a030 <lock_acquire>
    /*
     * Look for the port with ID id. If found,
     * remove its entry from the pool.
     */

    port = & port_pool . data[pid . s . index];
    bc0c:	e3a01068 	mov	r1, #104	; 0x68
    bc10:	e0217491 	mla	r1, r1, r4, r7
     */

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& port_pool . lock);

    queue_add (& port_pool . port, port);
    bc14:	e59f0024 	ldr	r0, [pc, #36]	; bc40 <port_destroy+0x130>
    bc18:	e2811008 	add	r1, r1, #8
    bc1c:	ebfff618 	bl	9484 <queue_add>

    lock_release (& port_pool . lock);
    bc20:	e59f0014 	ldr	r0, [pc, #20]	; bc3c <port_destroy+0x12c>
    bc24:	eb0003b2 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    bc28:	e1a00005 	mov	r0, r5
    bc2c:	ebfff7ec 	bl	9be4 <cpu_trap_restore>

    return DNA_OK;
    bc30:	e3a00000 	mov	r0, #0
    bc34:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    bc38:	0000faff 	.word	0x0000faff
    bc3c:	00079628 	.word	0x00079628
    bc40:	0007b030 	.word	0x0007b030

0000bc44 <thread_bootstrap>:
 * Ignored.
 *
 * SOURCE
 */

{
    bc44:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
    bc48:	e1a04000 	mov	r4, r0
  thread_signature_t * signature = (thread_signature_t *) p_signature;

  /*
   * Unlock threads HERE
   */
  uint32_t current_cpuid = cpu_mp_id ();
    bc4c:	ebfff801 	bl	9c58 <cpu_mp_id>
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];

  if(cpu-> prev_thread)
    bc50:	e59f6054 	ldr	r6, [pc, #84]	; bcac <thread_bootstrap+0x68>
    bc54:	e1a07180 	lsl	r7, r0, #3
    bc58:	e0873000 	add	r3, r7, r0
    bc5c:	e0863303 	add	r3, r6, r3, lsl #6
  thread_signature_t * signature = (thread_signature_t *) p_signature;

  /*
   * Unlock threads HERE
   */
  uint32_t current_cpuid = cpu_mp_id ();
    bc60:	e1a05000 	mov	r5, r0
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];

  if(cpu-> prev_thread)
    bc64:	e5930228 	ldr	r0, [r3, #552]	; 0x228
    bc68:	e3500000 	cmp	r0, #0
    bc6c:	0a000001 	beq	bc78 <thread_bootstrap+0x34>
    lock_release (& (cpu-> prev_thread -> lock));
    bc70:	e2800014 	add	r0, r0, #20
    bc74:	eb00039e 	bl	caf4 <lock_release>
  lock_release (& (cpu-> current_thread -> lock));
    bc78:	e0875005 	add	r5, r7, r5
    bc7c:	e0866305 	add	r6, r6, r5, lsl #6
    bc80:	e596022c 	ldr	r0, [r6, #556]	; 0x22c
    bc84:	e2800014 	add	r0, r0, #20
    bc88:	eb000399 	bl	caf4 <lock_release>

  /*
   * Activate interruption
   */
  cpu_trap_restore(signature->it_restore);
    bc8c:	e5940004 	ldr	r0, [r4, #4]
    bc90:	ebfff7d3 	bl	9be4 <cpu_trap_restore>


  /*
   * Call handler, declared by thread_create
   */
  thread_exit (signature -> handler (signature -> arguments));
    bc94:	e5943000 	ldr	r3, [r4]
    bc98:	e5940008 	ldr	r0, [r4, #8]
    bc9c:	e12fff33 	blx	r3
    bca0:	ebffff68 	bl	ba48 <thread_exit>
  return 0;
}
    bca4:	e3a00000 	mov	r0, #0
    bca8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
    bcac:	0007e458 	.word	0x0007e458

0000bcb0 <scheduler_elect>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    bcb0:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
    bcb4:	e1a04000 	mov	r4, r0
    bcb8:	e1a09001 	mov	r9, r1
  queue_t * queue = NULL;
  thread_t thread = NULL;
  int32_t current_cpuid = cpu_mp_id();
    bcbc:	ebfff7e5 	bl	9c58 <cpu_mp_id>

  watch (status_t)
  {
    ensure (p_thread != NULL, DNA_BAD_ARGUMENT);
    bcc0:	e3540000 	cmp	r4, #0
    bcc4:	0a000010 	beq	bd0c <scheduler_elect+0x5c>

    /*
     * Check the local queue.
     */

    queue = & scheduler . queue[current_cpuid];
    bcc8:	e59f80b4 	ldr	r8, [pc, #180]	; bd84 <scheduler_elect+0xd4>
    bccc:	e1a07000 	mov	r7, r0
    bcd0:	e0885200 	add	r5, r8, r0, lsl #4
    bcd4:	e2855004 	add	r5, r5, #4

    lock_acquire (& queue -> lock);
    bcd8:	e1a00005 	mov	r0, r5
    bcdc:	ebfff8d3 	bl	a030 <lock_acquire>
    thread = queue_rem (queue);
    bce0:	e1a00005 	mov	r0, r5
    bce4:	ebfff31d 	bl	8960 <queue_rem>

    check (thread_found, thread == NULL, DNA_OK);
    bce8:	e2506000 	subs	r6, r0, #0
    bcec:	0a000008 	beq	bd14 <scheduler_elect+0x64>
    return DNA_ERROR;
  }

  rescue (thread_found)
  {
    lock_acquire (& thread -> lock);
    bcf0:	e2860014 	add	r0, r6, #20
    bcf4:	ebfff8cd 	bl	a030 <lock_acquire>
    if(queue) lock_release (& queue -> lock);
    bcf8:	e1a00005 	mov	r0, r5
    bcfc:	eb00037c 	bl	caf4 <lock_release>

    *p_thread = thread;
    bd00:	e5846000 	str	r6, [r4]
    leave;
    bd04:	e3a00000 	mov	r0, #0
    bd08:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  thread_t thread = NULL;
  int32_t current_cpuid = cpu_mp_id();

  watch (status_t)
  {
    ensure (p_thread != NULL, DNA_BAD_ARGUMENT);
    bd0c:	e59f0074 	ldr	r0, [pc, #116]	; bd88 <scheduler_elect+0xd8>
    bd10:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

    lock_acquire (& queue -> lock);
    thread = queue_rem (queue);

    check (thread_found, thread == NULL, DNA_OK);
    lock_release (& queue -> lock);
    bd14:	e1a00005 	mov	r0, r5
    bd18:	eb000375 	bl	caf4 <lock_release>

    /*
     * Check the global queue.
     */

    queue = & scheduler . queue[cpu_mp_count ()];
    bd1c:	ebfff800 	bl	9d24 <cpu_mp_count>
    bd20:	e0880200 	add	r0, r8, r0, lsl #4
    bd24:	e2805004 	add	r5, r0, #4

    lock_acquire (& queue -> lock);
    bd28:	e1a00005 	mov	r0, r5
    bd2c:	ebfff8bf 	bl	a030 <lock_acquire>
    thread = queue_rem (queue);
    bd30:	e1a00005 	mov	r0, r5
    bd34:	ebfff309 	bl	8960 <queue_rem>

    check (thread_found, thread == NULL, DNA_OK);
    bd38:	e2506000 	subs	r6, r0, #0
    bd3c:	1affffeb 	bne	bcf0 <scheduler_elect+0x40>
    lock_release (& queue -> lock);
    bd40:	e1a00005 	mov	r0, r5
    bd44:	eb00036a 	bl	caf4 <lock_release>

    /*
     * Return the IDLE thread if requested.
     */

    ensure (with_idle, DNA_NO_AVAILABLE_THREAD);
    bd48:	e3590000 	cmp	r9, #0
    bd4c:	1a000001 	bne	bd58 <scheduler_elect+0xa8>
    bd50:	e59f0034 	ldr	r0, [pc, #52]	; bd8c <scheduler_elect+0xdc>
    bd54:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}

    queue = NULL;

    thread = cpu_pool . cpu[current_cpuid] . idle_thread;
    bd58:	e59f3030 	ldr	r3, [pc, #48]	; bd90 <scheduler_elect+0xe0>
    bd5c:	e0877187 	add	r7, r7, r7, lsl #3
    bd60:	e0833307 	add	r3, r3, r7, lsl #6
    bd64:	e5936230 	ldr	r6, [r3, #560]	; 0x230
    check (thread_found, thread == NULL, DNA_OK);
    bd68:	e3560000 	cmp	r6, #0
    bd6c:	0a000002 	beq	bd7c <scheduler_elect+0xcc>
    return DNA_ERROR;
  }

  rescue (thread_found)
  {
    lock_acquire (& thread -> lock);
    bd70:	e2860014 	add	r0, r6, #20
    bd74:	ebfff8ad 	bl	a030 <lock_acquire>
    bd78:	eaffffe0 	b	bd00 <scheduler_elect+0x50>
    queue = NULL;

    thread = cpu_pool . cpu[current_cpuid] . idle_thread;
    check (thread_found, thread == NULL, DNA_OK);

    return DNA_ERROR;
    bd7c:	e59f0010 	ldr	r0, [pc, #16]	; bd94 <scheduler_elect+0xe4>
    bd80:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
    bd84:	00080870 	.word	0x00080870
    bd88:	0000fffc 	.word	0x0000fffc
    bd8c:	0000fcfd 	.word	0x0000fcfd
    bd90:	0007e458 	.word	0x0007e458
    bd94:	0000ffff 	.word	0x0000ffff

0000bd98 <scheduler_dispatch>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    bd98:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
    bd9c:	e1a05000 	mov	r5, r0

    /*
     * Look for an available processor.
     */

    lock_acquire (& cpu_pool . queue . lock);
    bda0:	e59f00ec 	ldr	r0, [pc, #236]	; be94 <scheduler_dispatch+0xfc>
 */

{
  cpu_t * cpu = NULL;
  status_t status = DNA_OK;
  int32_t affinity = thread -> info . affinity;
    bda4:	e5954048 	ldr	r4, [r5, #72]	; 0x48

    /*
     * Look for an available processor.
     */

    lock_acquire (& cpu_pool . queue . lock);
    bda8:	ebfff8a0 	bl	a030 <lock_acquire>

    if (affinity == cpu_mp_count ())
    bdac:	ebfff7dc 	bl	9d24 <cpu_mp_count>
    bdb0:	e1500004 	cmp	r0, r4
    bdb4:	0a00002b 	beq	be68 <scheduler_dispatch+0xd0>
    {
      cpu = queue_rem (& cpu_pool . queue);
    }
    else
    {
      status = queue_extract (& cpu_pool . queue, & cpu_pool . cpu[affinity]);
    bdb8:	e59f30d8 	ldr	r3, [pc, #216]	; be98 <scheduler_dispatch+0x100>
    bdbc:	e0846184 	add	r6, r4, r4, lsl #3
    bdc0:	e0836306 	add	r6, r3, r6, lsl #6
    bdc4:	e1a01006 	mov	r1, r6
    bdc8:	e2830b09 	add	r0, r3, #9216	; 0x2400
    bdcc:	ebfff2a3 	bl	8860 <queue_extract>
      cpu = status == DNA_OK ? & cpu_pool . cpu[affinity] : NULL;
    bdd0:	e2507000 	subs	r7, r0, #0
    bdd4:	1a00000d 	bne	be10 <scheduler_dispatch+0x78>
    }

    lock_release (& cpu_pool . queue . lock);
    bdd8:	e59f00b4 	ldr	r0, [pc, #180]	; be94 <scheduler_dispatch+0xfc>
    bddc:	eb000344 	bl	caf4 <lock_release>

    /*
     * Check if we can send the thread to a distant CPU.
     */

    if (cpu != NULL && cpu -> id != cpu_mp_id ())
    bde0:	e5967004 	ldr	r7, [r6, #4]
    bde4:	ebfff79b 	bl	9c58 <cpu_mp_id>
    bde8:	e1570000 	cmp	r7, r0
    bdec:	0a000024 	beq	be84 <scheduler_dispatch+0xec>
    {
dna_log(INFO_LEVEL, "(%d) %s => CPU(%d)", cpu_mp_id (),
          thread -> info . name, cpu -> id);

      lock_acquire (& cpu -> ipi_lock);
    bdf0:	e2860010 	add	r0, r6, #16
    bdf4:	ebfff88d 	bl	a030 <lock_acquire>
      cpu_mp_send_ipi (cpu -> id, DNA_IPI_DISPATCH, thread);
    bdf8:	e5960004 	ldr	r0, [r6, #4]
    bdfc:	e1a02005 	mov	r2, r5
    be00:	e59f1094 	ldr	r1, [pc, #148]	; be9c <scheduler_dispatch+0x104>
    be04:	ebfff74f 	bl	9b48 <cpu_mp_send_ipi>
    be08:	e3a00000 	mov	r0, #0
    be0c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
    {
      status = queue_extract (& cpu_pool . queue, & cpu_pool . cpu[affinity]);
      cpu = status == DNA_OK ? & cpu_pool . cpu[affinity] : NULL;
    }

    lock_release (& cpu_pool . queue . lock);
    be10:	e59f007c 	ldr	r0, [pc, #124]	; be94 <scheduler_dispatch+0xfc>
    be14:	eb000336 	bl	caf4 <lock_release>
      lock_acquire (& cpu -> ipi_lock);
      cpu_mp_send_ipi (cpu -> id, DNA_IPI_DISPATCH, thread);
    }
    else
    {
      lock_acquire (& scheduler . queue[affinity] . lock);
    be18:	e59f6080 	ldr	r6, [pc, #128]	; bea0 <scheduler_dispatch+0x108>
    be1c:	e0866204 	add	r6, r6, r4, lsl #4
    be20:	e2866004 	add	r6, r6, #4
    be24:	e1a00006 	mov	r0, r6
    be28:	ebfff880 	bl	a030 <lock_acquire>
      queue_add (& scheduler . queue[affinity], thread);
    be2c:	e1a01005 	mov	r1, r5
    be30:	e1a00006 	mov	r0, r6
    be34:	ebfff592 	bl	9484 <queue_add>

      lock_release (& scheduler . queue[affinity] . lock);
    be38:	e1a00006 	mov	r0, r6
    be3c:	eb00032c 	bl	caf4 <lock_release>
      lock_release (& thread -> lock);
    be40:	e2850014 	add	r0, r5, #20
    be44:	eb00032a 	bl	caf4 <lock_release>
      /*
       * If the thread is compatible with the current CPU,
       * we return DNA_INVOKE_SCHEDULER to indicate potential reschedule.
       */

      if (affinity == cpu_mp_count () || affinity == cpu_mp_id ())
    be48:	ebfff7b5 	bl	9d24 <cpu_mp_count>
    be4c:	e1500004 	cmp	r0, r4
    be50:	0a00000d 	beq	be8c <scheduler_dispatch+0xf4>
    be54:	ebfff77f 	bl	9c58 <cpu_mp_id>
      {
dna_log(INFO_LEVEL, "%s => Q(%d)", thread -> info . name, affinity);
        status = DNA_INVOKE_SCHEDULER;
    be58:	e1500004 	cmp	r0, r4
    be5c:	11a00007 	movne	r0, r7
    be60:	03a00003 	moveq	r0, #3
    be64:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

    lock_acquire (& cpu_pool . queue . lock);

    if (affinity == cpu_mp_count ())
    {
      cpu = queue_rem (& cpu_pool . queue);
    be68:	e59f0024 	ldr	r0, [pc, #36]	; be94 <scheduler_dispatch+0xfc>
    be6c:	ebfff2bb 	bl	8960 <queue_rem>
    be70:	e1a06000 	mov	r6, r0
    {
      status = queue_extract (& cpu_pool . queue, & cpu_pool . cpu[affinity]);
      cpu = status == DNA_OK ? & cpu_pool . cpu[affinity] : NULL;
    }

    lock_release (& cpu_pool . queue . lock);
    be74:	e59f0018 	ldr	r0, [pc, #24]	; be94 <scheduler_dispatch+0xfc>
    be78:	eb00031d 	bl	caf4 <lock_release>

    /*
     * Check if we can send the thread to a distant CPU.
     */

    if (cpu != NULL && cpu -> id != cpu_mp_id ())
    be7c:	e3560000 	cmp	r6, #0
    be80:	1affffd6 	bne	bde0 <scheduler_dispatch+0x48>
 * SOURCE
 */

{
  cpu_t * cpu = NULL;
  status_t status = DNA_OK;
    be84:	e3a07000 	mov	r7, #0
    be88:	eaffffe2 	b	be18 <scheduler_dispatch+0x80>
       */

      if (affinity == cpu_mp_count () || affinity == cpu_mp_id ())
      {
dna_log(INFO_LEVEL, "%s => Q(%d)", thread -> info . name, affinity);
        status = DNA_INVOKE_SCHEDULER;
    be8c:	e3a00003 	mov	r0, #3
    be90:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
    be94:	00080860 	.word	0x00080860
    be98:	0007e460 	.word	0x0007e460
    be9c:	0000ffff 	.word	0x0000ffff
    bea0:	00080870 	.word	0x00080870

0000bea4 <thread_get_info>:
 */

{
  thread_t thread = NULL;
  thread_id_t tid = { .raw = id };
  bigtime_t current_time = 0, delta = 0;
    bea4:	e3a02000 	mov	r2, #0
    bea8:	e3a03000 	mov	r3, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    beac:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    beb0:	e1a04000 	mov	r4, r0
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    beb4:	e1a00820 	lsr	r0, r0, #16
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    beb8:	e24dd008 	sub	sp, sp, #8
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    bebc:	e31000ff 	tst	r0, #255	; 0xff
 */

{
  thread_t thread = NULL;
  thread_id_t tid = { .raw = id };
  bigtime_t current_time = 0, delta = 0;
    bec0:	e1cd20f0 	strd	r2, [sp]
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    bec4:	0a000002 	beq	bed4 <thread_get_info+0x30>
    bec8:	e59f010c 	ldr	r0, [pc, #268]	; bfdc <thread_get_info+0x138>
  {
    cpu_trap_restore (it_status);
    lock_release (& thread_pool . lock);
    leave;
  }
}
    becc:	e28dd008 	add	sp, sp, #8
    bed0:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    ensure (tid . s . index >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . index < DNA_MAX_THREAD, DNA_BAD_ARGUMENT);
    bed4:	e1a05c24 	lsr	r5, r4, #24
    bed8:	e355003f 	cmp	r5, #63	; 0x3f
    bedc:	8afffff9 	bhi	bec8 <thread_get_info+0x24>
    ensure (info != NULL, DNA_BAD_ARGUMENT);
    bee0:	e3510000 	cmp	r1, #0
    bee4:	e1a06001 	mov	r6, r1
    bee8:	0afffff6 	beq	bec8 <thread_get_info+0x24>
    /*
     * Get the thread corresponding to the current id
     * and check if it is valid.
     */

    it_status = cpu_trap_mask_and_backup();
    beec:	ebfff703 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& thread_pool . lock);
    bef0:	e59f90e8 	ldr	r9, [pc, #232]	; bfe0 <thread_get_info+0x13c>
    /*
     * Get the thread corresponding to the current id
     * and check if it is valid.
     */

    it_status = cpu_trap_mask_and_backup();
    bef4:	e1a07000 	mov	r7, r0
    lock_acquire (& thread_pool . lock);
    bef8:	e1a00009 	mov	r0, r9
    befc:	ebfff84b 	bl	a030 <lock_acquire>

    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
    bf00:	e3a030d0 	mov	r3, #208	; 0xd0
    bf04:	e0030593 	mul	r3, r3, r5
    bf08:	e089a003 	add	sl, r9, r3
    bf0c:	e59a2024 	ldr	r2, [sl, #36]	; 0x24
    bf10:	e1540002 	cmp	r4, r2
    bf14:	0a000005 	beq	bf30 <thread_get_info+0x8c>
    return DNA_OK;
  }

  rescue (bad_thread)
  {
    cpu_trap_restore (it_status);
    bf18:	e1a00007 	mov	r0, r7
    bf1c:	ebfff730 	bl	9be4 <cpu_trap_restore>
    lock_release (& thread_pool . lock);
    bf20:	e1a00009 	mov	r0, r9
    bf24:	eb0002f2 	bl	caf4 <lock_release>
    leave;
    bf28:	e59f00b4 	ldr	r0, [pc, #180]	; bfe4 <thread_get_info+0x140>
    bf2c:	eaffffe6 	b	becc <thread_get_info+0x28>
    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
        thread -> id . raw == tid . raw , DNA_INVALID_THREAD_ID);

    lock_acquire (& thread -> lock);
    bf30:	e0893003 	add	r3, r9, r3
    bf34:	e283801c 	add	r8, r3, #28
    bf38:	e1a00008 	mov	r0, r8
    bf3c:	ebfff83b 	bl	a030 <lock_acquire>
    lock_release (& thread_pool . lock);
    bf40:	e1a00009 	mov	r0, r9
    bf44:	eb0002ea 	bl	caf4 <lock_release>

    /*
     * Copy the thread information
     */

    *info = thread -> info;
    bf48:	e3a02050 	mov	r2, #80	; 0x50
    bf4c:	e28a1028 	add	r1, sl, #40	; 0x28
    bf50:	e1a00006 	mov	r0, r6
    bf54:	eb000efd 	bl	fb50 <memcpy>

    if (thread -> info . affinity == cpu_mp_count ())
    bf58:	e59a4050 	ldr	r4, [sl, #80]	; 0x50
    bf5c:	ebfff770 	bl	9d24 <cpu_mp_count>
    bf60:	e1540000 	cmp	r4, r0
    {
      info -> affinity = DNA_NO_AFFINITY;
    bf64:	03e03000 	mvneq	r3, #0
    bf68:	05863028 	streq	r3, [r6, #40]	; 0x28

    /*
     * Update the time of the running thread
     */

    if (thread -> info . status == DNA_THREAD_RUNNING)
    bf6c:	e3a030d0 	mov	r3, #208	; 0xd0
    bf70:	e0299593 	mla	r9, r3, r5, r9
    bf74:	e59f306c 	ldr	r3, [pc, #108]	; bfe8 <thread_get_info+0x144>
    bf78:	e1d925b8 	ldrh	r2, [r9, #88]	; 0x58
    bf7c:	e1520003 	cmp	r2, r3
    bf80:	0a000005 	beq	bf9c <thread_get_info+0xf8>
      cpu_timer_get (thread -> info . cpu_id, & current_time);
      delta = current_time - cpu_pool . cpu[thread -> info . cpu_id] . lap_date;
      info -> kernel_time += delta;
    }

    lock_release (& thread -> lock);
    bf84:	e1a00008 	mov	r0, r8
    bf88:	eb0002d9 	bl	caf4 <lock_release>
    cpu_trap_restore (it_status);
    bf8c:	e1a00007 	mov	r0, r7
    bf90:	ebfff713 	bl	9be4 <cpu_trap_restore>

    return DNA_OK;
    bf94:	e3a00000 	mov	r0, #0
    bf98:	eaffffcb 	b	becc <thread_get_info+0x28>
     * Update the time of the running thread
     */

    if (thread -> info . status == DNA_THREAD_RUNNING)
    {
      cpu_timer_get (thread -> info . cpu_id, & current_time);
    bf9c:	e5990048 	ldr	r0, [r9, #72]	; 0x48
    bfa0:	e1a0100d 	mov	r1, sp
    bfa4:	ebfff6fa 	bl	9b94 <cpu_timer_get>
      delta = current_time - cpu_pool . cpu[thread -> info . cpu_id] . lap_date;
    bfa8:	e1cd20d0 	ldrd	r2, [sp]
      info -> kernel_time += delta;
    bfac:	e1c643d8 	ldrd	r4, [r6, #56]	; 0x38
     */

    if (thread -> info . status == DNA_THREAD_RUNNING)
    {
      cpu_timer_get (thread -> info . cpu_id, & current_time);
      delta = current_time - cpu_pool . cpu[thread -> info . cpu_id] . lap_date;
    bfb0:	e5991048 	ldr	r1, [r9, #72]	; 0x48
    bfb4:	e59f0030 	ldr	r0, [pc, #48]	; bfec <thread_get_info+0x148>
    bfb8:	e0811181 	add	r1, r1, r1, lsl #3
    bfbc:	e0801301 	add	r1, r0, r1, lsl #6
    bfc0:	e1c102d0 	ldrd	r0, [r1, #32]
    bfc4:	e0522000 	subs	r2, r2, r0
    bfc8:	e0c33001 	sbc	r3, r3, r1
      info -> kernel_time += delta;
    bfcc:	e0922004 	adds	r2, r2, r4
    bfd0:	e0a33005 	adc	r3, r3, r5
    bfd4:	e1c623f8 	strd	r2, [r6, #56]	; 0x38
    bfd8:	eaffffe9 	b	bf84 <thread_get_info+0xe0>
    bfdc:	0000fffc 	.word	0x0000fffc
    bfe0:	0007b040 	.word	0x0007b040
    bfe4:	0000fcfe 	.word	0x0000fcfe
    bfe8:	0000beef 	.word	0x0000beef
    bfec:	0007e458 	.word	0x0007e458

0000bff0 <thread_alarm>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    bff0:	e92d4038 	push	{r3, r4, r5, lr}
  status_t status = DNA_OK;
  thread_t thread = data;

  watch (status_t)
  {
    ensure (thread != NULL, DNA_BAD_ARGUMENT);
    bff4:	e2504000 	subs	r4, r0, #0
    bff8:	0a00000d 	beq	c034 <thread_alarm+0x44>

    lock_acquire (& thread -> lock);
    bffc:	e2845014 	add	r5, r4, #20
    c000:	e1a00005 	mov	r0, r5
    c004:	ebfff809 	bl	a030 <lock_acquire>

    switch (thread -> info . status)
    c008:	e1d435b0 	ldrh	r3, [r4, #80]	; 0x50
    c00c:	e59f2048 	ldr	r2, [pc, #72]	; c05c <thread_alarm+0x6c>
    c010:	e1530002 	cmp	r3, r2
    c014:	0a00000b 	beq	c048 <thread_alarm+0x58>
    c018:	e59f2040 	ldr	r2, [pc, #64]	; c060 <thread_alarm+0x70>
    {
      case DNA_THREAD_SUSPENDED :
        {
dna_log(VERBOSE_LEVEL, "thread 0x%x already supended", thread -> id);
          
          lock_release (& thread -> lock);
    c01c:	e1a00005 	mov	r0, r5
  {
    ensure (thread != NULL, DNA_BAD_ARGUMENT);

    lock_acquire (& thread -> lock);

    switch (thread -> info . status)
    c020:	e1530002 	cmp	r3, r2
    c024:	1a000004 	bne	c03c <thread_alarm+0x4c>
    {
      case DNA_THREAD_SUSPENDED :
        {
dna_log(VERBOSE_LEVEL, "thread 0x%x already supended", thread -> id);
          
          lock_release (& thread -> lock);
    c028:	eb0002b1 	bl	caf4 <lock_release>
 *
 * SOURCE
 */

{
  status_t status = DNA_OK;
    c02c:	e3a00000 	mov	r0, #0
      case DNA_THREAD_SUSPENDED :
        {
dna_log(VERBOSE_LEVEL, "thread 0x%x already supended", thread -> id);
          
          lock_release (& thread -> lock);
          break;
    c030:	e8bd8038 	pop	{r3, r4, r5, pc}
  status_t status = DNA_OK;
  thread_t thread = data;

  watch (status_t)
  {
    ensure (thread != NULL, DNA_BAD_ARGUMENT);
    c034:	e59f0028 	ldr	r0, [pc, #40]	; c064 <thread_alarm+0x74>
        }
    }

    return status;
  }
}
    c038:	e8bd8038 	pop	{r3, r4, r5, pc}
      default :
        {
dna_log(PANIC_LEVEL, "status %x not handled.",
              thread -> info . status);

          lock_release (& thread -> lock);
    c03c:	eb0002ac 	bl	caf4 <lock_release>
          status = DNA_ERROR;
    c040:	e59f0020 	ldr	r0, [pc, #32]	; c068 <thread_alarm+0x78>
          break;
    c044:	e8bd8038 	pop	{r3, r4, r5, pc}

      case DNA_THREAD_SLEEPING :
        {
dna_log(VERBOSE_LEVEL, "thread 0x%x sleeping, resuming", thread -> id);
 
          thread -> info . status = DNA_THREAD_READY;
    c048:	e59f301c 	ldr	r3, [pc, #28]	; c06c <thread_alarm+0x7c>
          status = scheduler_dispatch (thread);
    c04c:	e1a00004 	mov	r0, r4

      case DNA_THREAD_SLEEPING :
        {
dna_log(VERBOSE_LEVEL, "thread 0x%x sleeping, resuming", thread -> id);
 
          thread -> info . status = DNA_THREAD_READY;
    c050:	e1c435b0 	strh	r3, [r4, #80]	; 0x50
        }
    }

    return status;
  }
}
    c054:	e8bd4038 	pop	{r3, r4, r5, lr}
      case DNA_THREAD_SLEEPING :
        {
dna_log(VERBOSE_LEVEL, "thread 0x%x sleeping, resuming", thread -> id);
 
          thread -> info . status = DNA_THREAD_READY;
          status = scheduler_dispatch (thread);
    c058:	eaffff4e 	b	bd98 <scheduler_dispatch>
    c05c:	0000bedd 	.word	0x0000bedd
    c060:	0000d15a 	.word	0x0000d15a
    c064:	0000fffc 	.word	0x0000fffc
    c068:	0000ffff 	.word	0x0000ffff
    c06c:	ffffface 	.word	0xffffface

0000c070 <interrupt_demultiplexer>:
 * * DNA_OK: the operation is successfull
 *
 * SOURCE
 */

{
    c070:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
    c074:	e24dd00c 	sub	sp, sp, #12
    c078:	e1a06000 	mov	r6, r0
  queue_link_t * isr;
  status_t status;
  int32_t current_cpuid = cpu_mp_id (), itn = (int32_t) data;
    c07c:	ebfff6f5 	bl	9c58 <cpu_mp_id>
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
  queue_t * queue = & cpu -> isr[itn];
  thread_t thread, self = cpu -> current_thread;
    c080:	e59f713c 	ldr	r7, [pc, #316]	; c1c4 <interrupt_demultiplexer+0x154>
    c084:	e0800180 	add	r0, r0, r0, lsl #3
    c088:	e0873300 	add	r3, r7, r0, lsl #6

  watch (int32_t)
  {
    ensure (itn < CPU_TRAP_COUNT, DNA_BAD_ARGUMENT);
    c08c:	e356001f 	cmp	r6, #31
  queue_link_t * isr;
  status_t status;
  int32_t current_cpuid = cpu_mp_id (), itn = (int32_t) data;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
  queue_t * queue = & cpu -> isr[itn];
  thread_t thread, self = cpu -> current_thread;
    c090:	e593822c 	ldr	r8, [r3, #556]	; 0x22c

  watch (int32_t)
  {
    ensure (itn < CPU_TRAP_COUNT, DNA_BAD_ARGUMENT);
    c094:	c59f012c 	ldrgt	r0, [pc, #300]	; c1c8 <interrupt_demultiplexer+0x158>
    c098:	da000001 	ble	c0a4 <interrupt_demultiplexer+0x34>
      }
    }

    return DNA_OK;
  }
}
    c09c:	e28dd00c 	add	sp, sp, #12
    c0a0:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
{
  queue_link_t * isr;
  status_t status;
  int32_t current_cpuid = cpu_mp_id (), itn = (int32_t) data;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
  queue_t * queue = & cpu -> isr[itn];
    c0a4:	e0864100 	add	r4, r6, r0, lsl #2
    c0a8:	e2844002 	add	r4, r4, #2
    c0ac:	e1a04204 	lsl	r4, r4, #4
    c0b0:	e2849008 	add	r9, r4, #8
    c0b4:	e0899007 	add	r9, r9, r7

    /*
     * Look for the corresponding handler
     */

    lock_acquire (& queue -> lock);
    c0b8:	e1a00009 	mov	r0, r9
    status = DNA_UNHANDLED_INTERRUPT;

    for (isr = queue -> head; isr != NULL; isr = isr -> next)
    c0bc:	e0874004 	add	r4, r7, r4

    /*
     * Look for the corresponding handler
     */

    lock_acquire (& queue -> lock);
    c0c0:	ebfff7da 	bl	a030 <lock_acquire>
    status = DNA_UNHANDLED_INTERRUPT;

    for (isr = queue -> head; isr != NULL; isr = isr -> next)
    c0c4:	e594400c 	ldr	r4, [r4, #12]
    c0c8:	e3540000 	cmp	r4, #0
    c0cc:	1a000003 	bne	c0e0 <interrupt_demultiplexer+0x70>
    c0d0:	ea000037 	b	c1b4 <interrupt_demultiplexer+0x144>
    c0d4:	e5944000 	ldr	r4, [r4]
    c0d8:	e3540000 	cmp	r4, #0
    c0dc:	0a00000d 	beq	c118 <interrupt_demultiplexer+0xa8>
    {
      status = ((isr_t)isr) -> handler (data);
    c0e0:	e5943004 	ldr	r3, [r4, #4]
    c0e4:	e1a00006 	mov	r0, r6
    c0e8:	e12fff33 	blx	r3
    c0ec:	e6ff5070 	uxth	r5, r0

      if (status == DNA_INVOKE_SCHEDULER || status == DNA_HANDLED_INTERRUPT)
    c0f0:	e3550003 	cmp	r5, #3
    c0f4:	13550005 	cmpne	r5, #5
    c0f8:	1afffff5 	bne	c0d4 <interrupt_demultiplexer+0x64>
      {
        break;
      }
    }

    lock_release (& queue -> lock);
    c0fc:	e1a00009 	mov	r0, r9
    c100:	eb00027b 	bl	caf4 <lock_release>

    /*
     * If necessary, invoke the scheduler.
     */

    if (status == DNA_INVOKE_SCHEDULER)
    c104:	e3550003 	cmp	r5, #3
    c108:	0a000005 	beq	c124 <interrupt_demultiplexer+0xb4>
        status = scheduler_switch (thread, queue);
        ensure (status == DNA_OK, status);
      }
    }

    return DNA_OK;
    c10c:	e3a00000 	mov	r0, #0
  }
}
    c110:	e28dd00c 	add	sp, sp, #12
    c114:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
      {
        break;
      }
    }

    lock_release (& queue -> lock);
    c118:	e1a00009 	mov	r0, r9
    c11c:	eb000274 	bl	caf4 <lock_release>
    c120:	eafffff9 	b	c10c <interrupt_demultiplexer+0x9c>
     * If necessary, invoke the scheduler.
     */

    if (status == DNA_INVOKE_SCHEDULER)
    {
      status = scheduler_elect (& thread, false);
    c124:	e28d0004 	add	r0, sp, #4
    c128:	e3a01000 	mov	r1, #0
    c12c:	ebfffedf 	bl	bcb0 <scheduler_elect>
      ensure (status != DNA_ERROR && status != DNA_BAD_ARGUMENT, status);
    c130:	e59f2090 	ldr	r2, [pc, #144]	; c1c8 <interrupt_demultiplexer+0x158>
    c134:	e59f3090 	ldr	r3, [pc, #144]	; c1cc <interrupt_demultiplexer+0x15c>
    c138:	e1500003 	cmp	r0, r3
    c13c:	11500002 	cmpne	r0, r2
    c140:	0affffd5 	beq	c09c <interrupt_demultiplexer+0x2c>

      if (status != DNA_NO_AVAILABLE_THREAD)
    c144:	e59f3084 	ldr	r3, [pc, #132]	; c1d0 <interrupt_demultiplexer+0x160>
    c148:	e1500003 	cmp	r0, r3
    c14c:	0affffee 	beq	c10c <interrupt_demultiplexer+0x9c>
      {
        lock_acquire (& self -> lock);
    c150:	e2880014 	add	r0, r8, #20
    c154:	ebfff7b5 	bl	a030 <lock_acquire>
        self -> info . status = DNA_THREAD_READY;
    c158:	e59f3074 	ldr	r3, [pc, #116]	; c1d4 <interrupt_demultiplexer+0x164>
    c15c:	e1c835b0 	strh	r3, [r8, #80]	; 0x50

        if (self != cpu_pool . cpu[cpu_mp_id()] . idle_thread)
    c160:	ebfff6bc 	bl	9c58 <cpu_mp_id>
    c164:	e0800180 	add	r0, r0, r0, lsl #3
    c168:	e0877300 	add	r7, r7, r0, lsl #6
    c16c:	e5973230 	ldr	r3, [r7, #560]	; 0x230
    c170:	e1530008 	cmp	r3, r8
    c174:	0a000008 	beq	c19c <interrupt_demultiplexer+0x12c>
        {
          queue = & scheduler . queue[self -> info . affinity];
    c178:	e5989048 	ldr	r9, [r8, #72]	; 0x48
    c17c:	e59f3054 	ldr	r3, [pc, #84]	; c1d8 <interrupt_demultiplexer+0x168>
    c180:	e0839209 	add	r9, r3, r9, lsl #4
    c184:	e2899004 	add	r9, r9, #4
          lock_acquire (& queue -> lock);
    c188:	e1a00009 	mov	r0, r9
    c18c:	ebfff7a7 	bl	a030 <lock_acquire>
          queue_add (queue, self);
    c190:	e1a00009 	mov	r0, r9
    c194:	e1a01008 	mov	r1, r8
    c198:	ebfff4b9 	bl	9484 <queue_add>
        }

        status = scheduler_switch (thread, queue);
    c19c:	e1a01009 	mov	r1, r9
    c1a0:	e59d0004 	ldr	r0, [sp, #4]
    c1a4:	eb0000c7 	bl	c4c8 <scheduler_switch>
        ensure (status == DNA_OK, status);
    c1a8:	e3500000 	cmp	r0, #0
    c1ac:	1affffba 	bne	c09c <interrupt_demultiplexer+0x2c>
    c1b0:	eaffffd5 	b	c10c <interrupt_demultiplexer+0x9c>
      {
        break;
      }
    }

    lock_release (& queue -> lock);
    c1b4:	e1a00009 	mov	r0, r9
    c1b8:	eb00024d 	bl	caf4 <lock_release>
        status = scheduler_switch (thread, queue);
        ensure (status == DNA_OK, status);
      }
    }

    return DNA_OK;
    c1bc:	e1a00004 	mov	r0, r4
    c1c0:	eaffffb5 	b	c09c <interrupt_demultiplexer+0x2c>
    c1c4:	0007e458 	.word	0x0007e458
    c1c8:	0000fffc 	.word	0x0000fffc
    c1cc:	0000ffff 	.word	0x0000ffff
    c1d0:	0000fcfd 	.word	0x0000fcfd
    c1d4:	ffffface 	.word	0xffffface
    c1d8:	00080870 	.word	0x00080870

0000c1dc <core_start>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    c1dc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  uint32_t current_cpuid = cpu_mp_id ();
    c1e0:	ebfff69c 	bl	9c58 <cpu_mp_id>
  thread_t thread = cpu_pool . cpu[current_cpuid] . current_thread;
    c1e4:	e59f607c 	ldr	r6, [pc, #124]	; c268 <core_start+0x8c>
    c1e8:	e0807180 	add	r7, r0, r0, lsl #3
    c1ec:	e1a07307 	lsl	r7, r7, #6
    c1f0:	e0868007 	add	r8, r6, r7
    c1f4:	e598422c 	ldr	r4, [r8, #556]	; 0x22c
 *
 * SOURCE
 */

{
  uint32_t current_cpuid = cpu_mp_id ();
    c1f8:	e1a05000 	mov	r5, r0
  thread_t thread = cpu_pool . cpu[current_cpuid] . current_thread;

  watch (status_t)
  {
    ensure (thread != NULL, DNA_ERROR);
    c1fc:	e3540000 	cmp	r4, #0
    c200:	0a00000b 	beq	c234 <core_start+0x58>

    lock_acquire (& thread -> lock);
    c204:	e2840014 	add	r0, r4, #20
    c208:	ebfff788 	bl	a030 <lock_acquire>

    if (current_cpuid == 0)
    c20c:	e3550000 	cmp	r5, #0
    c210:	1a000009 	bne	c23c <core_start+0x60>
    {
      cpu_pool . cpu[current_cpuid] . status = DNA_CPU_RUNNING;
    c214:	e59f3050 	ldr	r3, [pc, #80]	; c26c <core_start+0x90>
    c218:	e1c631b0 	strh	r3, [r6, #16]
      lock_acquire (& cpu_pool . queue . lock);
      queue_add (& cpu_pool . queue, & cpu_pool . cpu[current_cpuid]);
      lock_release (& cpu_pool . queue . lock);
    }

    thread -> info . status = DNA_THREAD_RUNNING;
    c21c:	e59f3048 	ldr	r3, [pc, #72]	; c26c <core_start+0x90>
    cpu_context_load (& thread -> context);
    c220:	e2840084 	add	r0, r4, #132	; 0x84
      lock_acquire (& cpu_pool . queue . lock);
      queue_add (& cpu_pool . queue, & cpu_pool . cpu[current_cpuid]);
      lock_release (& cpu_pool . queue . lock);
    }

    thread -> info . status = DNA_THREAD_RUNNING;
    c224:	e1c435b0 	strh	r3, [r4, #80]	; 0x50
    cpu_context_load (& thread -> context);
    c228:	ebffcfb4 	bl	100 <cpu_context_load>

    return DNA_OK;
    c22c:	e3a00000 	mov	r0, #0
    c230:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
  uint32_t current_cpuid = cpu_mp_id ();
  thread_t thread = cpu_pool . cpu[current_cpuid] . current_thread;

  watch (status_t)
  {
    ensure (thread != NULL, DNA_ERROR);
    c234:	e59f0034 	ldr	r0, [pc, #52]	; c270 <core_start+0x94>
    thread -> info . status = DNA_THREAD_RUNNING;
    cpu_context_load (& thread -> context);

    return DNA_OK;
  }
}
    c238:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    {
      cpu_pool . cpu[current_cpuid] . status = DNA_CPU_RUNNING;
    }
    else
    {
      cpu_pool . cpu[current_cpuid] . status = DNA_CPU_READY;
    c23c:	e59f3030 	ldr	r3, [pc, #48]	; c274 <core_start+0x98>
      lock_acquire (& cpu_pool . queue . lock);
    c240:	e59f0030 	ldr	r0, [pc, #48]	; c278 <core_start+0x9c>
    {
      cpu_pool . cpu[current_cpuid] . status = DNA_CPU_RUNNING;
    }
    else
    {
      cpu_pool . cpu[current_cpuid] . status = DNA_CPU_READY;
    c244:	e1c831b0 	strh	r3, [r8, #16]
      lock_acquire (& cpu_pool . queue . lock);
    c248:	ebfff778 	bl	a030 <lock_acquire>
      queue_add (& cpu_pool . queue, & cpu_pool . cpu[current_cpuid]);
    c24c:	e2871008 	add	r1, r7, #8
    c250:	e0861001 	add	r1, r6, r1
    c254:	e59f001c 	ldr	r0, [pc, #28]	; c278 <core_start+0x9c>
    c258:	ebfff489 	bl	9484 <queue_add>
      lock_release (& cpu_pool . queue . lock);
    c25c:	e59f0014 	ldr	r0, [pc, #20]	; c278 <core_start+0x9c>
    c260:	eb000223 	bl	caf4 <lock_release>
    c264:	eaffffec 	b	c21c <core_start+0x40>
    c268:	0007e458 	.word	0x0007e458
    c26c:	ffffbeef 	.word	0xffffbeef
    c270:	0000ffff 	.word	0x0000ffff
    c274:	ffffface 	.word	0xffffface
    c278:	00080860 	.word	0x00080860

0000c27c <alarm_comparator>:
  alarm_t alarm1 = item1;
  alarm_t alarm2 = item2;
  
  watch (bool)
  {
    ensure (alarm1 != NULL && alarm2 != NULL, false);
    c27c:	e3510000 	cmp	r1, #0
    c280:	13500000 	cmpne	r0, #0
    c284:	0a000008 	beq	c2ac <alarm_comparator+0x30>
    return alarm2 -> deadline < alarm1 -> deadline;
    c288:	e1c022d8 	ldrd	r2, [r0, #40]	; 0x28
 * item2 < item1.
 *
 * SOURCE
 */

{
    c28c:	e92d0030 	push	{r4, r5}
  alarm_t alarm2 = item2;
  
  watch (bool)
  {
    ensure (alarm1 != NULL && alarm2 != NULL, false);
    return alarm2 -> deadline < alarm1 -> deadline;
    c290:	e1c142d8 	ldrd	r4, [r1, #40]	; 0x28
    c294:	e1540002 	cmp	r4, r2
    c298:	e0d51003 	sbcs	r1, r5, r3
    c29c:	b3a00001 	movlt	r0, #1
  }
}
    c2a0:	e8bd0030 	pop	{r4, r5}
  alarm_t alarm2 = item2;
  
  watch (bool)
  {
    ensure (alarm1 != NULL && alarm2 != NULL, false);
    return alarm2 -> deadline < alarm1 -> deadline;
    c2a4:	a3a00000 	movge	r0, #0
  }
}
    c2a8:	e12fff1e 	bx	lr
  alarm_t alarm1 = item1;
  alarm_t alarm2 = item2;
  
  watch (bool)
  {
    ensure (alarm1 != NULL && alarm2 != NULL, false);
    c2ac:	e3a00000 	mov	r0, #0
    c2b0:	e12fff1e 	bx	lr

0000c2b4 <port_read>:
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
    c2b4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  status_t status;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
    c2b8:	e1a06820 	lsr	r6, r0, #16
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
    c2bc:	e24dd024 	sub	sp, sp, #36	; 0x24
  status_t status;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
    c2c0:	e356003f 	cmp	r6, #63	; 0x3f
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
    c2c4:	e1a07000 	mov	r7, r0
    c2c8:	e1cd45d0 	ldrd	r4, [sp, #80]	; 0x50
    c2cc:	e1a0b002 	mov	fp, r2
  status_t status;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
    c2d0:	859f01e4 	ldrhi	r0, [pc, #484]	; c4bc <port_read+0x208>
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
    c2d4:	e59d2048 	ldr	r2, [sp, #72]	; 0x48
  status_t status;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
    c2d8:	9a000001 	bls	c2e4 <port_read+0x30>
  {
    lock_release (& port_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    c2dc:	e28dd024 	add	sp, sp, #36	; 0x24
    c2e0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c2e4:	e1a08001 	mov	r8, r1

    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
    c2e8:	e58d200c 	str	r2, [sp, #12]
    c2ec:	e58d3008 	str	r3, [sp, #8]
    c2f0:	ebfff602 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    c2f4:	e3a0a068 	mov	sl, #104	; 0x68
    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);
    c2f8:	e59f91c0 	ldr	r9, [pc, #448]	; c4c0 <port_read+0x20c>

    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
    c2fc:	e58d0014 	str	r0, [sp, #20]
    lock_acquire (& port_pool . lock);
    c300:	e1a00009 	mov	r0, r9
    c304:	ebfff749 	bl	a030 <lock_acquire>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    c308:	e000069a 	mul	r0, sl, r6
    c30c:	e0891000 	add	r1, r9, r0
    c310:	e591e00c 	ldr	lr, [r1, #12]
    c314:	e157000e 	cmp	r7, lr
    c318:	0a000006 	beq	c338 <port_read+0x84>
    leave;
  }

  rescue (bad_portid)
  {
    lock_release (& port_pool . lock);
    c31c:	e59f019c 	ldr	r0, [pc, #412]	; c4c0 <port_read+0x20c>
    c320:	eb0001f3 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    c324:	e59d0014 	ldr	r0, [sp, #20]
    c328:	ebfff62d 	bl	9be4 <cpu_trap_restore>
    leave;
    c32c:	e59f0188 	ldr	r0, [pc, #392]	; c4bc <port_read+0x208>
  }
}
    c330:	e28dd024 	add	sp, sp, #36	; 0x24
    c334:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    lock_acquire (& port -> lock);
    c338:	e2800010 	add	r0, r0, #16
    c33c:	e0800009 	add	r0, r0, r9
    c340:	e58d1010 	str	r1, [sp, #16]
    c344:	e58d0018 	str	r0, [sp, #24]
    c348:	ebfff738 	bl	a030 <lock_acquire>
    lock_release (& port_pool . lock);
    c34c:	e1a00009 	mov	r0, r9
    c350:	eb0001e7 	bl	caf4 <lock_release>

    check (bad_port, ! port -> closed ||
    c354:	e59d1010 	ldr	r1, [sp, #16]
    c358:	e59d200c 	ldr	r2, [sp, #12]
    c35c:	e5d11014 	ldrb	r1, [r1, #20]
    c360:	e59d3008 	ldr	r3, [sp, #8]
    c364:	e3510000 	cmp	r1, #0
    c368:	0a00000a 	beq	c398 <port_read+0xe4>
    c36c:	e02aaa96 	mla	sl, r6, sl, sl
    c370:	e089a00a 	add	sl, r9, sl
    c374:	e59a1004 	ldr	r1, [sl, #4]
    c378:	e3510000 	cmp	r1, #0
    c37c:	1a000005 	bne	c398 <port_read+0xe4>
    return DNA_OK;
  }

  rescue (bad_port)
  {
    lock_release (& port -> lock);
    c380:	e59d0018 	ldr	r0, [sp, #24]
    c384:	eb0001da 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    c388:	e59d0014 	ldr	r0, [sp, #20]
    c38c:	ebfff614 	bl	9be4 <cpu_trap_restore>
    leave;
    c390:	e59f012c 	ldr	r0, [pc, #300]	; c4c4 <port_read+0x210>
    c394:	eaffffd0 	b	c2dc <port_read+0x28>
    lock_release (& port_pool . lock);

    check (bad_port, ! port -> closed ||
        port -> mailbox . status != 0, DNA_ERROR);

    read_sem = port -> read_sem;
    c398:	e3a01068 	mov	r1, #104	; 0x68
    c39c:	e02a9691 	mla	sl, r1, r6, r9
    write_sem = port -> write_sem;
    c3a0:	e59ac048 	ldr	ip, [sl, #72]	; 0x48
    lock_release (& port_pool . lock);

    check (bad_port, ! port -> closed ||
        port -> mailbox . status != 0, DNA_ERROR);

    read_sem = port -> read_sem;
    c3a4:	e59a1044 	ldr	r1, [sl, #68]	; 0x44
    write_sem = port -> write_sem;

    lock_release (& port -> lock);
    c3a8:	e59d0018 	ldr	r0, [sp, #24]

    check (bad_port, ! port -> closed ||
        port -> mailbox . status != 0, DNA_ERROR);

    read_sem = port -> read_sem;
    write_sem = port -> write_sem;
    c3ac:	e58dc01c 	str	ip, [sp, #28]

    lock_release (& port -> lock);
    c3b0:	e58d1010 	str	r1, [sp, #16]
    c3b4:	e58d200c 	str	r2, [sp, #12]
    c3b8:	e58d3008 	str	r3, [sp, #8]
    c3bc:	eb0001cc 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    c3c0:	e59d0014 	ldr	r0, [sp, #20]
    c3c4:	ebfff606 	bl	9be4 <cpu_trap_restore>

    /*
     * Acquire the semaphore.
     */

    status = semaphore_acquire (read_sem, 1, flags, timeout);
    c3c8:	e59d1010 	ldr	r1, [sp, #16]
    c3cc:	e1cd40f0 	strd	r4, [sp]
    c3d0:	e1a00001 	mov	r0, r1
    c3d4:	e59d200c 	ldr	r2, [sp, #12]
    c3d8:	e3a01001 	mov	r1, #1
    c3dc:	ebfffc7a 	bl	b5cc <semaphore_acquire>
    ensure (status == DNA_OK, status);
    c3e0:	e3500000 	cmp	r0, #0
    lock_release (& port_pool . lock);

    check (bad_port, ! port -> closed ||
        port -> mailbox . status != 0, DNA_ERROR);

    read_sem = port -> read_sem;
    c3e4:	e59f40d4 	ldr	r4, [pc, #212]	; c4c0 <port_read+0x20c>
    /*
     * Acquire the semaphore.
     */

    status = semaphore_acquire (read_sem, 1, flags, timeout);
    ensure (status == DNA_OK, status);
    c3e8:	1affffbb 	bne	c2dc <port_read+0x28>
    /*
     * Get the port once again, just to make sure
     * it has not been destroyed in the meantime.
     */

    it_status = cpu_trap_mask_and_backup ();
    c3ec:	ebfff5c3 	bl	9b00 <cpu_trap_mask_and_backup>
    c3f0:	e58d0014 	str	r0, [sp, #20]
    lock_acquire (& port_pool . lock);
    c3f4:	e1a00004 	mov	r0, r4
    c3f8:	ebfff70c 	bl	a030 <lock_acquire>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    c3fc:	e59a200c 	ldr	r2, [sl, #12]
    c400:	e1570002 	cmp	r7, r2
    c404:	1affffc4 	bne	c31c <port_read+0x68>

    lock_acquire (& port -> lock);
    c408:	e59d0018 	ldr	r0, [sp, #24]
    c40c:	ebfff707 	bl	a030 <lock_acquire>
    lock_release (& port_pool . lock);
    c410:	e1a00004 	mov	r0, r4
    c414:	eb0001b6 	bl	caf4 <lock_release>

    check (bad_port, ! port -> closed ||
    c418:	e5da2014 	ldrb	r2, [sl, #20]
    c41c:	e59d3008 	ldr	r3, [sp, #8]
    c420:	e3520000 	cmp	r2, #0
    c424:	0a000005 	beq	c440 <port_read+0x18c>
    c428:	e3a01068 	mov	r1, #104	; 0x68
    c42c:	e2862001 	add	r2, r6, #1
    c430:	e0244291 	mla	r4, r1, r2, r4
    c434:	e5942004 	ldr	r2, [r4, #4]
    c438:	e3520000 	cmp	r2, #0
    c43c:	0affffcf 	beq	c380 <port_read+0xcc>
    /*
     * Get the message from the mailbox, and
     * put it back in the message queue.
     */

    message = queue_rem (& port -> mailbox);
    c440:	e3a02068 	mov	r2, #104	; 0x68
    c444:	e0060692 	mul	r6, r2, r6
    c448:	e2860060 	add	r0, r6, #96	; 0x60
    c44c:	e0890000 	add	r0, r9, r0
    c450:	e58d3008 	str	r3, [sp, #8]
    c454:	ebfff141 	bl	8960 <queue_rem>
    check (bad_port, message != NULL, DNA_ERROR);
    c458:	e2501000 	subs	r1, r0, #0
    /*
     * Get the message from the mailbox, and
     * put it back in the message queue.
     */

    message = queue_rem (& port -> mailbox);
    c45c:	e59f405c 	ldr	r4, [pc, #92]	; c4c0 <port_read+0x20c>
    check (bad_port, message != NULL, DNA_ERROR);
    c460:	e59d3008 	ldr	r3, [sp, #8]
    c464:	0affffc5 	beq	c380 <port_read+0xcc>

    *p_code = message -> code;
    c468:	e591e004 	ldr	lr, [r1, #4]
#if 0
    data_size = size >= message -> size ? message -> size : size;
#endif
    dna_memcpy (buffer, message -> buffer, size);
    c46c:	e1a02003 	mov	r2, r3
     */

    message = queue_rem (& port -> mailbox);
    check (bad_port, message != NULL, DNA_ERROR);

    *p_code = message -> code;
    c470:	e588e000 	str	lr, [r8]
#if 0
    data_size = size >= message -> size ? message -> size : size;
#endif
    dna_memcpy (buffer, message -> buffer, size);
    c474:	e1a0000b 	mov	r0, fp
    c478:	e591100c 	ldr	r1, [r1, #12]
    c47c:	ebfff4a0 	bl	9704 <dna_memcpy>

    queue_add (& port -> message, port);
    c480:	e2860050 	add	r0, r6, #80	; 0x50
     */

    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    c484:	e2861008 	add	r1, r6, #8
#if 0
    data_size = size >= message -> size ? message -> size : size;
#endif
    dna_memcpy (buffer, message -> buffer, size);

    queue_add (& port -> message, port);
    c488:	e0841001 	add	r1, r4, r1
    c48c:	e0840000 	add	r0, r4, r0
    c490:	ebfff3fb 	bl	9484 <queue_add>

    lock_release (& port -> lock);
    c494:	e59d0018 	ldr	r0, [sp, #24]
    c498:	eb000195 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    c49c:	e59d0014 	ldr	r0, [sp, #20]
    c4a0:	ebfff5cf 	bl	9be4 <cpu_trap_restore>

    /*
     * Delete the message, release the write semaphore, and return.
     */

    status = semaphore_release (write_sem, 1, DNA_NO_RESCHEDULE);
    c4a4:	e3a01001 	mov	r1, #1
    c4a8:	e1a02001 	mov	r2, r1
    c4ac:	e59d001c 	ldr	r0, [sp, #28]
  {
    lock_release (& port_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    c4b0:	e28dd024 	add	sp, sp, #36	; 0x24
    c4b4:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

    /*
     * Delete the message, release the write semaphore, and return.
     */

    status = semaphore_release (write_sem, 1, DNA_NO_RESCHEDULE);
    c4b8:	ea000104 	b	c8d0 <semaphore_release>
    c4bc:	0000faff 	.word	0x0000faff
    c4c0:	00079628 	.word	0x00079628
    c4c4:	0000ffff 	.word	0x0000ffff

0000c4c8 <scheduler_switch>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    c4c8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c4cc:	e24dd014 	sub	sp, sp, #20
    c4d0:	e1a08000 	mov	r8, r0
    c4d4:	e1a06001 	mov	r6, r1
  uint32_t current_cpuid = cpu_mp_id ();
    c4d8:	ebfff5de 	bl	9c58 <cpu_mp_id>
  bigtime_t current_time = 0, delta = 0;
    c4dc:	e3a02000 	mov	r2, #0
    c4e0:	e3a03000 	mov	r3, #0
  extern uint32_t __scheduler_switch_end;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
  thread_t self = cpu -> current_thread;
    c4e4:	e1a07180 	lsl	r7, r0, #3
    c4e8:	e0871000 	add	r1, r7, r0
    c4ec:	e59f4138 	ldr	r4, [pc, #312]	; c62c <__scheduler_switch_end+0x7c>
    c4f0:	e1a01301 	lsl	r1, r1, #6

  watch (status_t)
  {
    ensure (thread != NULL, DNA_BAD_ARGUMENT);
    c4f4:	e3580000 	cmp	r8, #0
{
  uint32_t current_cpuid = cpu_mp_id ();
  bigtime_t current_time = 0, delta = 0;
  extern uint32_t __scheduler_switch_end;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
  thread_t self = cpu -> current_thread;
    c4f8:	e084a001 	add	sl, r4, r1
 *
 * SOURCE
 */

{
  uint32_t current_cpuid = cpu_mp_id ();
    c4fc:	e1a09000 	mov	r9, r0
  bigtime_t current_time = 0, delta = 0;
  extern uint32_t __scheduler_switch_end;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
  thread_t self = cpu -> current_thread;
    c500:	e59ab22c 	ldr	fp, [sl, #556]	; 0x22c
 * SOURCE
 */

{
  uint32_t current_cpuid = cpu_mp_id ();
  bigtime_t current_time = 0, delta = 0;
    c504:	e1cd20f8 	strd	r2, [sp, #8]
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
  thread_t self = cpu -> current_thread;

  watch (status_t)
  {
    ensure (thread != NULL, DNA_BAD_ARGUMENT);
    c508:	059f0120 	ldreq	r0, [pc, #288]	; c630 <__scheduler_switch_end+0x80>
    c50c:	0a000031 	beq	c5d8 <__scheduler_switch_end+0x28>

{
  uint32_t current_cpuid = cpu_mp_id ();
  bigtime_t current_time = 0, delta = 0;
  extern uint32_t __scheduler_switch_end;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
    c510:	e2813008 	add	r3, r1, #8
    c514:	e0833004 	add	r3, r3, r4

    /*
     * Compute the correct times if necessary
     */

    cpu_timer_get (current_cpuid, & current_time);
    c518:	e28d1008 	add	r1, sp, #8

{
  uint32_t current_cpuid = cpu_mp_id ();
  bigtime_t current_time = 0, delta = 0;
  extern uint32_t __scheduler_switch_end;
  cpu_t * cpu = & cpu_pool . cpu[current_cpuid];
    c51c:	e58d3004 	str	r3, [sp, #4]

    /*
     * Compute the correct times if necessary
     */

    cpu_timer_get (current_cpuid, & current_time);
    c520:	ebfff59b 	bl	9b94 <cpu_timer_get>
    delta = current_time - cpu -> lap_date;
    c524:	e1ca02d0 	ldrd	r0, [sl, #32]
    c528:	e1cd20d8 	ldrd	r2, [sp, #8]
    c52c:	e0522000 	subs	r2, r2, r0
    c530:	e0c33001 	sbc	r3, r3, r1

    /*
     * Update the status of the target thread
     */

    thread -> info . status = DNA_THREAD_RUNNING;
    c534:	e59f50f8 	ldr	r5, [pc, #248]	; c634 <__scheduler_switch_end+0x84>
     * Compute the correct times if necessary
     */

    cpu_timer_get (current_cpuid, & current_time);
    delta = current_time - cpu -> lap_date;
    self -> info . kernel_time += delta;
    c538:	e1cb05d8 	ldrd	r0, [fp, #88]	; 0x58
    c53c:	e0922000 	adds	r2, r2, r0
    c540:	e0a33001 	adc	r3, r3, r1
    c544:	e1cb25f8 	strd	r2, [fp, #88]	; 0x58
    thread -> info . cpu_id = current_cpuid;

    /*
     * Save the current context
     */
    cpu_context_save (& self -> context, & __scheduler_switch_end);
    c548:	e28b0084 	add	r0, fp, #132	; 0x84
     */

    cpu_timer_get (current_cpuid, & current_time);
    delta = current_time - cpu -> lap_date;
    self -> info . kernel_time += delta;
    cpu->prev_thread = self;
    c54c:	e58ab228 	str	fp, [sl, #552]	; 0x228
    thread -> info . cpu_id = current_cpuid;

    /*
     * Save the current context
     */
    cpu_context_save (& self -> context, & __scheduler_switch_end);
    c550:	e59f10e0 	ldr	r1, [pc, #224]	; c638 <__scheduler_switch_end+0x88>
    /*
     * Update the status of the target thread
     */

    thread -> info . status = DNA_THREAD_RUNNING;
    thread -> info . cpu_id = current_cpuid;
    c554:	e5889040 	str	r9, [r8, #64]	; 0x40

    /*
     * Update the status of the target thread
     */

    thread -> info . status = DNA_THREAD_RUNNING;
    c558:	e1c855b0 	strh	r5, [r8, #80]	; 0x50
    thread -> info . cpu_id = current_cpuid;

    /*
     * Save the current context
     */
    cpu_context_save (& self -> context, & __scheduler_switch_end);
    c55c:	ebffcecb 	bl	90 <cpu_context_save>
    /*
     * Check if self is IDLE. In this case, remove CPU
     * from the available list. If target is IDLE, restore
     * the processor status to READY.
     */
    if (self == cpu -> idle_thread)
    c560:	e59a3230 	ldr	r3, [sl, #560]	; 0x230
    c564:	e153000b 	cmp	r3, fp
    c568:	0a00001c 	beq	c5e0 <__scheduler_switch_end+0x30>
      queue_extract (& cpu_pool . queue, cpu);
      lock_release (& cpu_pool . queue . lock);

      cpu -> status = DNA_CPU_RUNNING;
    }
    else if (thread == cpu -> idle_thread)
    c56c:	e1580003 	cmp	r8, r3
    c570:	0a000023 	beq	c604 <__scheduler_switch_end+0x54>

    /*
     * Update the processor's status
     */

    cpu -> lap_date = current_time;
    c574:	e1cd20d8 	ldrd	r2, [sp, #8]
    c578:	e0879009 	add	r9, r7, r9
    c57c:	e0849309 	add	r9, r4, r9, lsl #6

    /*
     * Release the queue's lock if queue is not NULL.
     */

    if (queue != NULL)
    c580:	e3560000 	cmp	r6, #0
    /*
     * Update the processor's status
     */

    cpu -> lap_date = current_time;
    cpu -> current_thread = thread;
    c584:	e589822c 	str	r8, [r9, #556]	; 0x22c

    /*
     * Update the processor's status
     */

    cpu -> lap_date = current_time;
    c588:	e1c922f0 	strd	r2, [r9, #32]

    /*
     * Release the queue's lock if queue is not NULL.
     */

    if (queue != NULL)
    c58c:	0a000001 	beq	c598 <scheduler_switch+0xd0>
    {
      lock_release (& queue -> lock);
    c590:	e1a00006 	mov	r0, r6
    c594:	eb000156 	bl	caf4 <lock_release>

    /*
     * Load the target context
     */

    cpu_dcache_invalidate((void*)&thread->context, CPU_CONTEXT_SIZE);
    c598:	e2888084 	add	r8, r8, #132	; 0x84
    c59c:	e1a00008 	mov	r0, r8
    c5a0:	e3a0104c 	mov	r1, #76	; 0x4c
    c5a4:	ebfff5c1 	bl	9cb0 <cpu_dcache_invalidate>
    cpu_context_load (& thread -> context);
    c5a8:	e1a00008 	mov	r0, r8
    c5ac:	ebffced3 	bl	100 <cpu_context_load>

0000c5b0 <__scheduler_switch_end>:
     */

    __asm__ volatile ("__scheduler_switch_end:");
//    cpu_dcache_invalidate(NULL, CPU_CACHE_ALL);

    cpu = & cpu_pool . cpu[cpu_mp_id()];
    c5b0:	ebfff5a8 	bl	9c58 <cpu_mp_id>

    /*
     * prev and current threads are necessarily set here
     */
    lock_release (& (cpu-> prev_thread -> lock));
    c5b4:	e0800180 	add	r0, r0, r0, lsl #3
    c5b8:	e0844300 	add	r4, r4, r0, lsl #6
    c5bc:	e5b40228 	ldr	r0, [r4, #552]!	; 0x228
    c5c0:	e2800014 	add	r0, r0, #20
    c5c4:	eb00014a 	bl	caf4 <lock_release>
    lock_release (& (cpu-> current_thread -> lock));
    c5c8:	e5940004 	ldr	r0, [r4, #4]
    c5cc:	e2800014 	add	r0, r0, #20
    c5d0:	eb000147 	bl	caf4 <lock_release>
     * Contrary to what I thought at first, we cannot 
     * check if self is running the IDLE thread here, because
     * in the case of the CPU0 (the boot CPU), swithching to IDLE
     * would not branch here but directly in the IDLE thread handler.
     */
    return DNA_OK;
    c5d4:	e3a00000 	mov	r0, #0
  }
}
    c5d8:	e28dd014 	add	sp, sp, #20
    c5dc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
     */
    if (self == cpu -> idle_thread)
    {
dna_log(VERBOSE_LEVEL, "CPU(%d) << RUNNING", cpu -> id);

      lock_acquire (& cpu_pool . queue . lock);
    c5e0:	e59f0054 	ldr	r0, [pc, #84]	; c63c <__scheduler_switch_end+0x8c>
    c5e4:	ebfff691 	bl	a030 <lock_acquire>
      queue_extract (& cpu_pool . queue, cpu);
    c5e8:	e59d1004 	ldr	r1, [sp, #4]
    c5ec:	e59f0048 	ldr	r0, [pc, #72]	; c63c <__scheduler_switch_end+0x8c>
    c5f0:	ebfff09a 	bl	8860 <queue_extract>
      lock_release (& cpu_pool . queue . lock);
    c5f4:	e59f0040 	ldr	r0, [pc, #64]	; c63c <__scheduler_switch_end+0x8c>
    c5f8:	eb00013d 	bl	caf4 <lock_release>

      cpu -> status = DNA_CPU_RUNNING;
    c5fc:	e1ca51b0 	strh	r5, [sl, #16]
    c600:	eaffffdb 	b	c574 <scheduler_switch+0xac>
    }
    else if (thread == cpu -> idle_thread)
    {
dna_log(VERBOSE_LEVEL, "CPU(%d) >> READY", cpu -> id);
      cpu -> status = DNA_CPU_READY;
    c604:	e59f3034 	ldr	r3, [pc, #52]	; c640 <__scheduler_switch_end+0x90>

      lock_acquire (& cpu_pool . queue . lock);
    c608:	e59f002c 	ldr	r0, [pc, #44]	; c63c <__scheduler_switch_end+0x8c>
      cpu -> status = DNA_CPU_RUNNING;
    }
    else if (thread == cpu -> idle_thread)
    {
dna_log(VERBOSE_LEVEL, "CPU(%d) >> READY", cpu -> id);
      cpu -> status = DNA_CPU_READY;
    c60c:	e1ca31b0 	strh	r3, [sl, #16]

      lock_acquire (& cpu_pool . queue . lock);
    c610:	ebfff686 	bl	a030 <lock_acquire>
      queue_add (& cpu_pool . queue, cpu);
    c614:	e59d1004 	ldr	r1, [sp, #4]
    c618:	e59f001c 	ldr	r0, [pc, #28]	; c63c <__scheduler_switch_end+0x8c>
    c61c:	ebfff398 	bl	9484 <queue_add>
      lock_release (& cpu_pool . queue . lock);
    c620:	e59f0014 	ldr	r0, [pc, #20]	; c63c <__scheduler_switch_end+0x8c>
    c624:	eb000132 	bl	caf4 <lock_release>
    c628:	eaffffd1 	b	c574 <scheduler_switch+0xac>
    c62c:	0007e458 	.word	0x0007e458
    c630:	0000fffc 	.word	0x0000fffc
    c634:	ffffbeef 	.word	0xffffbeef
    c638:	0000c5b0 	.word	0x0000c5b0
    c63c:	00080860 	.word	0x00080860
    c640:	ffffface 	.word	0xffffface

0000c644 <semaphore_create>:
  semaphore_t semaphore = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (name != NULL && id != NULL, DNA_BAD_ARGUMENT);
    c644:	e3520000 	cmp	r2, #0
    c648:	13500000 	cmpne	r0, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    c64c:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  semaphore_t semaphore = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (name != NULL && id != NULL, DNA_BAD_ARGUMENT);
    c650:	e1a05000 	mov	r5, r0
    c654:	e1a04002 	mov	r4, r2
    c658:	03a06001 	moveq	r6, #1
    c65c:	13a06000 	movne	r6, #0
    c660:	1a000001 	bne	c66c <semaphore_create+0x28>
    c664:	e59f0094 	ldr	r0, [pc, #148]	; c700 <semaphore_create+0xbc>
  {
    cpu_trap_restore(it_status);
    lock_release (& semaphore_pool . lock);
    leave;
  }
}
    c668:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c66c:	e1a07001 	mov	r7, r1

  watch (status_t)
  {
    ensure (name != NULL && id != NULL, DNA_BAD_ARGUMENT);

    it_status = cpu_trap_mask_and_backup();
    c670:	ebfff522 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& semaphore_pool . lock);
    c674:	e59f9088 	ldr	r9, [pc, #136]	; c704 <semaphore_create+0xc0>

  watch (status_t)
  {
    ensure (name != NULL && id != NULL, DNA_BAD_ARGUMENT);

    it_status = cpu_trap_mask_and_backup();
    c678:	e1a0a000 	mov	sl, r0
    lock_acquire (& semaphore_pool . lock);
    c67c:	e1a00009 	mov	r0, r9
    c680:	ebfff66a 	bl	a030 <lock_acquire>

    /*
     * Get an empty semaphore slot.
     */

    semaphore = queue_rem (& semaphore_pool . semaphore);
    c684:	e59f007c 	ldr	r0, [pc, #124]	; c708 <semaphore_create+0xc4>
    c688:	ebfff0b4 	bl	8960 <queue_rem>
    check (pool_error, semaphore != NULL, DNA_NO_MORE_SEM);
    c68c:	e2508000 	subs	r8, r0, #0
    c690:	0a000014 	beq	c6e8 <semaphore_create+0xa4>
    /*
     * Make the place clean.
     */

    index = semaphore -> id . s . index;
    dna_memset (semaphore, 0, sizeof (struct _semaphore));
    c694:	e1a01006 	mov	r1, r6
    c698:	e3a02044 	mov	r2, #68	; 0x44

    /*
     * Make the place clean.
     */

    index = semaphore -> id . s . index;
    c69c:	e1d8b0b6 	ldrh	fp, [r8, #6]
    dna_memset (semaphore, 0, sizeof (struct _semaphore));
    c6a0:	ebfff10f 	bl	8ae4 <dna_memset>

    semaphore -> id . s . index = index;
    semaphore -> id . s . value = semaphore_pool . counter;
    c6a4:	e1d930b4 	ldrh	r3, [r9, #4]

    /*
     * Release the pool.
     */

    lock_release (& semaphore_pool . lock);
    c6a8:	e1a00009 	mov	r0, r9

    index = semaphore -> id . s . index;
    dna_memset (semaphore, 0, sizeof (struct _semaphore));

    semaphore -> id . s . index = index;
    semaphore -> id . s . value = semaphore_pool . counter;
    c6ac:	e1c830b4 	strh	r3, [r8, #4]
     */

    index = semaphore -> id . s . index;
    dna_memset (semaphore, 0, sizeof (struct _semaphore));

    semaphore -> id . s . index = index;
    c6b0:	e1c8b0b6 	strh	fp, [r8, #6]
    semaphore -> id . s . value = semaphore_pool . counter;

    semaphore_pool . counter += 1;
    c6b4:	e2833001 	add	r3, r3, #1
    c6b8:	e1c930b4 	strh	r3, [r9, #4]

    /*
     * Release the pool.
     */

    lock_release (& semaphore_pool . lock);
    c6bc:	eb00010c 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    c6c0:	e1a0000a 	mov	r0, sl
    c6c4:	ebfff546 	bl	9be4 <cpu_trap_restore>

    /*
     * Fill in the information.
     */

    dna_strcpy (semaphore -> info . name, name);
    c6c8:	e1a01005 	mov	r1, r5
    c6cc:	e288001c 	add	r0, r8, #28
    c6d0:	ebfff404 	bl	96e8 <dna_strcpy>

dna_log(VERBOSE_LEVEL, "ID(%d:%d) TOKEN(%d)",
        semaphore -> id . s . value, semaphore -> id . s . index,
        semaphore -> info . tokens);

    *id = semaphore -> id . raw;
    c6d4:	e5983004 	ldr	r3, [r8, #4]
    /*
     * Fill in the information.
     */

    dna_strcpy (semaphore -> info . name, name);
    semaphore -> info . tokens = tokens;
    c6d8:	e588703c 	str	r7, [r8, #60]	; 0x3c
dna_log(VERBOSE_LEVEL, "ID(%d:%d) TOKEN(%d)",
        semaphore -> id . s . value, semaphore -> id . s . index,
        semaphore -> info . tokens);

    *id = semaphore -> id . raw;
    return DNA_OK;
    c6dc:	e1a00006 	mov	r0, r6

dna_log(VERBOSE_LEVEL, "ID(%d:%d) TOKEN(%d)",
        semaphore -> id . s . value, semaphore -> id . s . index,
        semaphore -> info . tokens);

    *id = semaphore -> id . raw;
    c6e0:	e5843000 	str	r3, [r4]
    return DNA_OK;
    c6e4:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  }

  rescue (pool_error)
  {
    cpu_trap_restore(it_status);
    c6e8:	e1a0000a 	mov	r0, sl
    c6ec:	ebfff53c 	bl	9be4 <cpu_trap_restore>
    lock_release (& semaphore_pool . lock);
    c6f0:	e1a00009 	mov	r0, r9
    c6f4:	eb0000fe 	bl	caf4 <lock_release>
    leave;
    c6f8:	e59f000c 	ldr	r0, [pc, #12]	; c70c <semaphore_create+0xc8>
    c6fc:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c700:	0000fffc 	.word	0x0000fffc
    c704:	00035610 	.word	0x00035610
    c708:	00079618 	.word	0x00079618
    c70c:	0000fdfe 	.word	0x0000fdfe

0000c710 <alarm_destroy>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    c710:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
    c714:	e1a05000 	mov	r5, r0
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup();
    c718:	ebfff4f8 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& alarm_pool . lock);
    c71c:	e59f4070 	ldr	r4, [pc, #112]	; c794 <alarm_destroy+0x84>
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    it_status = cpu_trap_mask_and_backup();
    c720:	e1a07000 	mov	r7, r0
    lock_acquire (& alarm_pool . lock);
    c724:	e1a00004 	mov	r0, r4
    c728:	ebfff640 	bl	a030 <lock_acquire>

    alarm = & alarm_pool . data[alarm_id . s . index];
    c72c:	e1a03825 	lsr	r3, r5, #16
    check (alarm_error, alarm != NULL, DNA_UNKNOWN_ALARM);
    check (alarm_error, alarm -> id . raw == alarm_id . raw, DNA_UNKNOWN_ALARM);
    c730:	e1a03303 	lsl	r3, r3, #6
    c734:	e0846003 	add	r6, r4, r3
    c738:	e596200c 	ldr	r2, [r6, #12]
    c73c:	e1550002 	cmp	r5, r2
    c740:	0a000005 	beq	c75c <alarm_destroy+0x4c>
    return status;
  }

  rescue (alarm_error)
  {
    lock_release (& alarm_pool . lock);
    c744:	e1a00004 	mov	r0, r4
    c748:	eb0000e9 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    c74c:	e1a00007 	mov	r0, r7
    c750:	ebfff523 	bl	9be4 <cpu_trap_restore>
    leave;
    c754:	e59f003c 	ldr	r0, [pc, #60]	; c798 <alarm_destroy+0x88>
  }
}
    c758:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

    alarm = & alarm_pool . data[alarm_id . s . index];
    check (alarm_error, alarm != NULL, DNA_UNKNOWN_ALARM);
    check (alarm_error, alarm -> id . raw == alarm_id . raw, DNA_UNKNOWN_ALARM);

    lock_acquire (& alarm -> lock);
    c75c:	e2833020 	add	r3, r3, #32
    c760:	e0835004 	add	r5, r3, r4
    c764:	e1a00005 	mov	r0, r5
    c768:	ebfff630 	bl	a030 <lock_acquire>
    lock_release (& alarm_pool . lock);
    c76c:	e1a00004 	mov	r0, r4
    c770:	eb0000df 	bl	caf4 <lock_release>

    alarm -> is_invalid = true;
    c774:	e3a03001 	mov	r3, #1
    lock_release (& alarm -> lock);
    c778:	e1a00005 	mov	r0, r5
    check (alarm_error, alarm -> id . raw == alarm_id . raw, DNA_UNKNOWN_ALARM);

    lock_acquire (& alarm -> lock);
    lock_release (& alarm_pool . lock);

    alarm -> is_invalid = true;
    c77c:	e5c6301c 	strb	r3, [r6, #28]
    lock_release (& alarm -> lock);
    c780:	eb0000db 	bl	caf4 <lock_release>

    cpu_trap_restore(it_status);
    c784:	e1a00007 	mov	r0, r7
    c788:	ebfff515 	bl	9be4 <cpu_trap_restore>
    return status;
    c78c:	e3a00000 	mov	r0, #0
    c790:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
    c794:	00080988 	.word	0x00080988
    c798:	0000fbfe 	.word	0x0000fbfe

0000c79c <thread_destroy>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    c79c:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    c7a0:	e1a03820 	lsr	r3, r0, #16
    c7a4:	e31300ff 	tst	r3, #255	; 0xff
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    c7a8:	e1a04000 	mov	r4, r0
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    c7ac:	0a000001 	beq	c7b8 <thread_destroy+0x1c>
    c7b0:	e59f00fc 	ldr	r0, [pc, #252]	; c8b4 <thread_destroy+0x118>
  {
    lock_release (& thread_pool . lock);
    cpu_trap_restore (it_status);
    leave;
  }
}
    c7b4:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    ensure (tid . s . index >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . index < DNA_MAX_THREAD, DNA_BAD_ARGUMENT);
    c7b8:	e1a05c20 	lsr	r5, r0, #24
    c7bc:	e355003f 	cmp	r5, #63	; 0x3f
    c7c0:	8afffffa 	bhi	c7b0 <thread_destroy+0x14>

    /*
     * Get some information about the execution.
     */

    it_status = cpu_trap_mask_and_backup ();
    c7c4:	ebfff4cd 	bl	9b00 <cpu_trap_mask_and_backup>

    /*
     * Get the thread corresponding to ID and check the thread's status.
     */

    lock_acquire (& thread_pool . lock);
    c7c8:	e59f60e8 	ldr	r6, [pc, #232]	; c8b8 <thread_destroy+0x11c>

    /*
     * Get some information about the execution.
     */

    it_status = cpu_trap_mask_and_backup ();
    c7cc:	e1a09000 	mov	r9, r0

    /*
     * Get the thread corresponding to ID and check the thread's status.
     */

    lock_acquire (& thread_pool . lock);
    c7d0:	e1a00006 	mov	r0, r6
    c7d4:	ebfff615 	bl	a030 <lock_acquire>
    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
    c7d8:	e3a030d0 	mov	r3, #208	; 0xd0
    c7dc:	e0030593 	mul	r3, r3, r5
    c7e0:	e0867003 	add	r7, r6, r3
    c7e4:	e2878020 	add	r8, r7, #32
    c7e8:	e5982004 	ldr	r2, [r8, #4]
    c7ec:	e1540002 	cmp	r4, r2
    c7f0:	159f40c4 	ldrne	r4, [pc, #196]	; c8bc <thread_destroy+0x120>
    c7f4:	0a000005 	beq	c810 <thread_destroy+0x74>
    lock_release (& thread -> lock);
  }

  rescue (bad_thread)
  {
    lock_release (& thread_pool . lock);
    c7f8:	e59f00b8 	ldr	r0, [pc, #184]	; c8b8 <thread_destroy+0x11c>
    c7fc:	eb0000bc 	bl	caf4 <lock_release>
    cpu_trap_restore (it_status);
    c800:	e1a00009 	mov	r0, r9
    c804:	ebfff4f6 	bl	9be4 <cpu_trap_restore>
    leave;
    c808:	e1a00004 	mov	r0, r4
    c80c:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
    thread = & thread_pool . data[tid . s . group][tid . s . index];

    check (bad_thread, thread != NULL &&
        thread -> id . raw == tid . raw , DNA_INVALID_THREAD_ID);

    lock_acquire (& thread -> lock);
    c810:	e287401c 	add	r4, r7, #28
    c814:	e1a00004 	mov	r0, r4
    c818:	ebfff604 	bl	a030 <lock_acquire>

    check (bad_status,
    c81c:	e1d735b8 	ldrh	r3, [r7, #88]	; 0x58
    c820:	e59f1098 	ldr	r1, [pc, #152]	; c8c0 <thread_destroy+0x124>
    c824:	e59f2098 	ldr	r2, [pc, #152]	; c8c4 <thread_destroy+0x128>
    return DNA_OK;
  }

  rescue (bad_status)
  {
    lock_release (& thread -> lock);
    c828:	e1a00004 	mov	r0, r4
    check (bad_thread, thread != NULL &&
        thread -> id . raw == tid . raw , DNA_INVALID_THREAD_ID);

    lock_acquire (& thread -> lock);

    check (bad_status,
    c82c:	e1530001 	cmp	r3, r1
    c830:	11530002 	cmpne	r3, r2
    c834:	13a03001 	movne	r3, #1
    c838:	03a03000 	moveq	r3, #0
    c83c:	0a000002 	beq	c84c <thread_destroy+0xb0>
    return DNA_OK;
  }

  rescue (bad_status)
  {
    lock_release (& thread -> lock);
    c840:	eb0000ab 	bl	caf4 <lock_release>
    check (bad_thread, thread != NULL &&
        thread -> id . raw == tid . raw , DNA_INVALID_THREAD_ID);

    lock_acquire (& thread -> lock);

    check (bad_status,
    c844:	e59f407c 	ldr	r4, [pc, #124]	; c8c8 <thread_destroy+0x12c>
    c848:	eaffffea 	b	c7f8 <thread_destroy+0x5c>
    /*
     * Erase the thread's entry in the thread pool
     * and free its memory. Do an early unlock of the pool.
     */

    thread -> id . s . value = 0;
    c84c:	e1c830b4 	strh	r3, [r8, #4]
    lock_release (& thread -> lock);
    c850:	eb0000a7 	bl	caf4 <lock_release>

    lock_release (& thread_pool . lock);
    c854:	e1a00006 	mov	r0, r6
    c858:	eb0000a5 	bl	caf4 <lock_release>
    cpu_trap_restore (it_status);
    c85c:	e1a00009 	mov	r0, r9
    c860:	ebfff4df 	bl	9be4 <cpu_trap_restore>

    if (thread -> stack_allocated)
    c864:	e5d73078 	ldrb	r3, [r7, #120]	; 0x78
    c868:	e3530000 	cmp	r3, #0
    c86c:	0a000001 	beq	c878 <thread_destroy+0xdc>
    {
      kernel_free (thread -> info . stack_base);
    c870:	e5970070 	ldr	r0, [r7, #112]	; 0x70
    c874:	eb0003d3 	bl	d7c8 <kernel_free>

    /*
     * Add the freed thread into the thread queue and return.
     */

    it_status = cpu_trap_mask_and_backup ();
    c878:	ebfff4a0 	bl	9b00 <cpu_trap_mask_and_backup>
    c87c:	e1a04000 	mov	r4, r0
    lock_acquire (& thread_pool . lock);
    c880:	e59f0030 	ldr	r0, [pc, #48]	; c8b8 <thread_destroy+0x11c>
    c884:	ebfff5e9 	bl	a030 <lock_acquire>
    /*
     * Get the thread corresponding to ID and check the thread's status.
     */

    lock_acquire (& thread_pool . lock);
    thread = & thread_pool . data[tid . s . group][tid . s . index];
    c888:	e3a010d0 	mov	r1, #208	; 0xd0
    c88c:	e0216591 	mla	r1, r1, r5, r6
     */

    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& thread_pool . lock);

    queue_add (& thread_pool . thread[tid . s . group], thread);
    c890:	e59f0034 	ldr	r0, [pc, #52]	; c8cc <thread_destroy+0x130>
    c894:	e2811008 	add	r1, r1, #8
    c898:	ebfff2f9 	bl	9484 <queue_add>

    lock_release (& thread_pool . lock);
    c89c:	e59f0014 	ldr	r0, [pc, #20]	; c8b8 <thread_destroy+0x11c>
    c8a0:	eb000093 	bl	caf4 <lock_release>
    cpu_trap_restore (it_status);
    c8a4:	e1a00004 	mov	r0, r4
    c8a8:	ebfff4cd 	bl	9be4 <cpu_trap_restore>

    return DNA_OK;
    c8ac:	e3a00000 	mov	r0, #0
    c8b0:	e8bd83f8 	pop	{r3, r4, r5, r6, r7, r8, r9, pc}
    c8b4:	0000fffc 	.word	0x0000fffc
    c8b8:	0007b040 	.word	0x0007b040
    c8bc:	0000fcfe 	.word	0x0000fcfe
    c8c0:	0000d15a 	.word	0x0000d15a
    c8c4:	0000dead 	.word	0x0000dead
    c8c8:	0000ffff 	.word	0x0000ffff
    c8cc:	0007e448 	.word	0x0007e448

0000c8d0 <semaphore_release>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    c8d0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  status_t status = DNA_OK;
  bool smart_to_reschedule = false;

  watch (status_t)
  {
    ensure (tokens > 0, DNA_BAD_ARGUMENT);
    c8d4:	e251b000 	subs	fp, r1, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    c8d8:	e24dd01c 	sub	sp, sp, #28
  status_t status = DNA_OK;
  bool smart_to_reschedule = false;

  watch (status_t)
  {
    ensure (tokens > 0, DNA_BAD_ARGUMENT);
    c8dc:	d59f01f8 	ldrle	r0, [pc, #504]	; cadc <semaphore_release+0x20c>
    c8e0:	da000004 	ble	c8f8 <semaphore_release+0x28>
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);
    c8e4:	e1a04820 	lsr	r4, r0, #16
    c8e8:	e3540a01 	cmp	r4, #4096	; 0x1000
    c8ec:	e1a06000 	mov	r6, r0
    c8f0:	259f01e8 	ldrcs	r0, [pc, #488]	; cae0 <semaphore_release+0x210>
    c8f4:	3a000001 	bcc	c900 <semaphore_release+0x30>
  {
    lock_release (& semaphore_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    c8f8:	e28dd01c 	add	sp, sp, #28
    c8fc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c900:	e1a05002 	mov	r5, r2
  watch (status_t)
  {
    ensure (tokens > 0, DNA_BAD_ARGUMENT);
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
    c904:	ebfff47d 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& semaphore_pool . lock);
    c908:	e59f71d4 	ldr	r7, [pc, #468]	; cae4 <semaphore_release+0x214>
     * Look for the semaphore with ID id
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
    c90c:	e1a02204 	lsl	r2, r4, #4
  watch (status_t)
  {
    ensure (tokens > 0, DNA_BAD_ARGUMENT);
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
    c910:	e58d0008 	str	r0, [sp, #8]
    lock_acquire (& semaphore_pool . lock);
    c914:	e1a00007 	mov	r0, r7
     * Look for the semaphore with ID id
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
    c918:	e58d2004 	str	r2, [sp, #4]
  {
    ensure (tokens > 0, DNA_BAD_ARGUMENT);
    ensure (sid . s . index < DNA_MAX_SEM, DNA_BAD_SEM_ID);

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& semaphore_pool . lock);
    c91c:	ebfff5c3 	bl	a030 <lock_acquire>
     * Look for the semaphore with ID id
     */

    sem = & semaphore_pool . data[sid . s . index];
    check (invalid_semaphore, sem != NULL, DNA_BAD_SEM_ID);
    check (invalid_semaphore, sem -> id . raw == sid . raw, DNA_BAD_SEM_ID);
    c920:	e59d2004 	ldr	r2, [sp, #4]
    c924:	e0823004 	add	r3, r2, r4
    c928:	e1a03103 	lsl	r3, r3, #2
    c92c:	e0872003 	add	r2, r7, r3
    c930:	e592200c 	ldr	r2, [r2, #12]
    c934:	e1560002 	cmp	r6, r2
    c938:	0a000005 	beq	c954 <semaphore_release+0x84>
    leave;
  }

  rescue (invalid_semaphore)
  {
    lock_release (& semaphore_pool . lock);
    c93c:	e1a00007 	mov	r0, r7
    c940:	eb00006b 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    c944:	e59d0008 	ldr	r0, [sp, #8]
    c948:	ebfff4a5 	bl	9be4 <cpu_trap_restore>
    leave;
    c94c:	e59f018c 	ldr	r0, [pc, #396]	; cae0 <semaphore_release+0x210>
    c950:	eaffffe8 	b	c8f8 <semaphore_release+0x28>
  thread_t thread = NULL;
  semaphore_t sem = NULL;
  semaphore_id_t sid = { .raw = id };
  interrupt_status_t it_status = 0;
  status_t status = DNA_OK;
  bool smart_to_reschedule = false;
    c954:	e3a08000 	mov	r8, #0
      cpu_dcache_invalidate((void*)&thread->info.sem_tokens, sizeof(uint32_t));
      if (thread -> info . sem_tokens <= tokens)
      {
       tokens -= thread -> info . sem_tokens;

        thread -> resource_queue = NULL;
    c958:	e1a06008 	mov	r6, r8

dna_log(VERBOSE_LEVEL, "%d tokens on ID(%d:%d) TOKEN(%d)",
        tokens, sid . s . value,
        sid . s . index, sem -> info . tokens);

    lock_acquire (& sem -> lock);
    c95c:	e2833010 	add	r3, r3, #16
    c960:	e0833007 	add	r3, r3, r7
    c964:	e1a00003 	mov	r0, r3
    c968:	e58d3010 	str	r3, [sp, #16]
    c96c:	ebfff5af 	bl	a030 <lock_acquire>
    /*
     * Decide what to do according to the number
     * of tokens required by a potential waiting thread
     */

    lock_acquire (& sem -> waiting_queue . lock);
    c970:	e59d3010 	ldr	r3, [sp, #16]
dna_log(VERBOSE_LEVEL, "%d tokens on ID(%d:%d) TOKEN(%d)",
        tokens, sid . s . value,
        sid . s . index, sem -> info . tokens);

    lock_acquire (& sem -> lock);
    lock_release (& semaphore_pool . lock);
    c974:	e1a00007 	mov	r0, r7
    /*
     * Decide what to do according to the number
     * of tokens required by a potential waiting thread
     */

    lock_acquire (& sem -> waiting_queue . lock);
    c978:	e2833004 	add	r3, r3, #4
    c97c:	e58d300c 	str	r3, [sp, #12]
dna_log(VERBOSE_LEVEL, "%d tokens on ID(%d:%d) TOKEN(%d)",
        tokens, sid . s . value,
        sid . s . index, sem -> info . tokens);

    lock_acquire (& sem -> lock);
    lock_release (& semaphore_pool . lock);
    c980:	eb00005b 	bl	caf4 <lock_release>
    /*
     * Decide what to do according to the number
     * of tokens required by a potential waiting thread
     */

    lock_acquire (& sem -> waiting_queue . lock);
    c984:	e59d000c 	ldr	r0, [sp, #12]
    c988:	ebfff5a8 	bl	a030 <lock_acquire>
        thread -> resource_queue = NULL;
        thread -> info . sem_tokens = 0;
        thread -> info . resource = DNA_NO_RESOURCE;
        thread -> info . resource_id = -1;

        thread -> info . status = DNA_THREAD_READY;
    c98c:	e59da00c 	ldr	sl, [sp, #12]
    c990:	e58d4014 	str	r4, [sp, #20]
    {
      /*
       * Check if a thread is available.
       */

      if ((thread = queue_rem (& sem -> waiting_queue)) == NULL)
    c994:	e1a0000a 	mov	r0, sl
    c998:	ebffeff0 	bl	8960 <queue_rem>
    c99c:	e2504000 	subs	r4, r0, #0
      }

      /*
       * Lock the thread and check its status.
       */
      lock_acquire (& thread -> lock);
    c9a0:	e2849014 	add	r9, r4, #20
    {
      /*
       * Check if a thread is available.
       */

      if ((thread = queue_rem (& sem -> waiting_queue)) == NULL)
    c9a4:	0a00001c 	beq	ca1c <semaphore_release+0x14c>
      }

      /*
       * Lock the thread and check its status.
       */
      lock_acquire (& thread -> lock);
    c9a8:	e1a00009 	mov	r0, r9
    c9ac:	ebfff59f 	bl	a030 <lock_acquire>

      cpu_dcache_invalidate((void*)(&thread->info.status),sizeof(uint32_t));    
    c9b0:	e2840050 	add	r0, r4, #80	; 0x50
    c9b4:	e3a01004 	mov	r1, #4
    c9b8:	ebfff4bc 	bl	9cb0 <cpu_dcache_invalidate>
      check (invalid_thread_status,
    c9bc:	e1d425b0 	ldrh	r2, [r4, #80]	; 0x50
    c9c0:	e59f3120 	ldr	r3, [pc, #288]	; cae8 <semaphore_release+0x218>
          DNA_ERROR);

      /*
       * Check the number of tokens it requests.
       */
      cpu_dcache_invalidate((void*)&thread->info.sem_tokens, sizeof(uint32_t));
    c9c4:	e284004c 	add	r0, r4, #76	; 0x4c
       * Lock the thread and check its status.
       */
      lock_acquire (& thread -> lock);

      cpu_dcache_invalidate((void*)(&thread->info.status),sizeof(uint32_t));    
      check (invalid_thread_status,
    c9c8:	e1520003 	cmp	r2, r3
    c9cc:	1a00002d 	bne	ca88 <semaphore_release+0x1b8>
          DNA_ERROR);

      /*
       * Check the number of tokens it requests.
       */
      cpu_dcache_invalidate((void*)&thread->info.sem_tokens, sizeof(uint32_t));
    c9d0:	e3a01004 	mov	r1, #4
    c9d4:	ebfff4b5 	bl	9cb0 <cpu_dcache_invalidate>
      if (thread -> info . sem_tokens <= tokens)
    c9d8:	e594204c 	ldr	r2, [r4, #76]	; 0x4c
    c9dc:	e152000b 	cmp	r2, fp
    c9e0:	ca000032 	bgt	cab0 <semaphore_release+0x1e0>
       tokens -= thread -> info . sem_tokens;

        thread -> resource_queue = NULL;
        thread -> info . sem_tokens = 0;
        thread -> info . resource = DNA_NO_RESOURCE;
        thread -> info . resource_id = -1;
    c9e4:	e3e03000 	mvn	r3, #0
    c9e8:	e5843054 	str	r3, [r4, #84]	; 0x54

        thread -> info . status = DNA_THREAD_READY;
    c9ec:	e59f30f8 	ldr	r3, [pc, #248]	; caec <semaphore_release+0x21c>
      cpu_dcache_invalidate((void*)&thread->info.sem_tokens, sizeof(uint32_t));
      if (thread -> info . sem_tokens <= tokens)
      {
       tokens -= thread -> info . sem_tokens;

        thread -> resource_queue = NULL;
    c9f0:	e5846018 	str	r6, [r4, #24]
        thread -> info . sem_tokens = 0;
    c9f4:	e584604c 	str	r6, [r4, #76]	; 0x4c
        thread -> info . resource = DNA_NO_RESOURCE;
    c9f8:	e5c46052 	strb	r6, [r4, #82]	; 0x52
        thread -> info . resource_id = -1;

        thread -> info . status = DNA_THREAD_READY;
    c9fc:	e1c435b0 	strh	r3, [r4, #80]	; 0x50
        status = scheduler_dispatch (thread);
    ca00:	e1a00004 	mov	r0, r4
       * Check the number of tokens it requests.
       */
      cpu_dcache_invalidate((void*)&thread->info.sem_tokens, sizeof(uint32_t));
      if (thread -> info . sem_tokens <= tokens)
      {
       tokens -= thread -> info . sem_tokens;
    ca04:	e062b00b 	rsb	fp, r2, fp
        thread -> info . sem_tokens = 0;
        thread -> info . resource = DNA_NO_RESOURCE;
        thread -> info . resource_id = -1;

        thread -> info . status = DNA_THREAD_READY;
        status = scheduler_dispatch (thread);
    ca08:	ebfffce2 	bl	bd98 <scheduler_dispatch>

        smart_to_reschedule = smart_to_reschedule ||
    ca0c:	e3500003 	cmp	r0, #3
    ca10:	03888001 	orreq	r8, r8, #1
     * of tokens required by a potential waiting thread
     */

    lock_acquire (& sem -> waiting_queue . lock);

    while (tokens != 0)
    ca14:	e35b0000 	cmp	fp, #0
    ca18:	1affffdd 	bne	c994 <semaphore_release+0xc4>
    ca1c:	e59d4014 	ldr	r4, [sp, #20]

        break;
      }
    }

    lock_release (& sem -> waiting_queue . lock);
    ca20:	e59d000c 	ldr	r0, [sp, #12]
    ca24:	eb000032 	bl	caf4 <lock_release>
    /*
     * Add the remaining number of token
     * and release the sem lock
     */
    {
    cpu_dcache_invalidate((void*)& sem -> info . tokens, sizeof(uint32_t));
    ca28:	e59d2004 	ldr	r2, [sp, #4]
    ca2c:	e3a01004 	mov	r1, #4
    ca30:	e0824004 	add	r4, r2, r4
    ca34:	e1a04104 	lsl	r4, r4, #2
    ca38:	e0870004 	add	r0, r7, r4
    ca3c:	e2800044 	add	r0, r0, #68	; 0x44
    sem -> info . tokens += tokens;
    ca40:	e0874004 	add	r4, r7, r4
    /*
     * Add the remaining number of token
     * and release the sem lock
     */
    {
    cpu_dcache_invalidate((void*)& sem -> info . tokens, sizeof(uint32_t));
    ca44:	ebfff499 	bl	9cb0 <cpu_dcache_invalidate>
    sem -> info . tokens += tokens;
    ca48:	e5943044 	ldr	r3, [r4, #68]	; 0x44
    }

    lock_release (& sem -> lock);
    ca4c:	e59d0010 	ldr	r0, [sp, #16]
     * Add the remaining number of token
     * and release the sem lock
     */
    {
    cpu_dcache_invalidate((void*)& sem -> info . tokens, sizeof(uint32_t));
    sem -> info . tokens += tokens;
    ca50:	e083c00b 	add	ip, r3, fp
    ca54:	e584c044 	str	ip, [r4, #68]	; 0x44
    }

    lock_release (& sem -> lock);
    ca58:	eb000025 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    ca5c:	e59d0008 	ldr	r0, [sp, #8]
    ca60:	ebfff45f 	bl	9be4 <cpu_trap_restore>

    /*
     * Now we deal with the reschedule
     */

    if ((flags & DNA_NO_RESCHEDULE) == 0 && smart_to_reschedule)
    ca64:	e2155001 	ands	r5, r5, #1
    {
      thread_yield ();
    }

    return DNA_OK;
    ca68:	13a00000 	movne	r0, #0

    /*
     * Now we deal with the reschedule
     */

    if ((flags & DNA_NO_RESCHEDULE) == 0 && smart_to_reschedule)
    ca6c:	1affffa1 	bne	c8f8 <semaphore_release+0x28>
    ca70:	e3580000 	cmp	r8, #0
    {
      thread_yield ();
    }

    return DNA_OK;
    ca74:	01a00008 	moveq	r0, r8

    /*
     * Now we deal with the reschedule
     */

    if ((flags & DNA_NO_RESCHEDULE) == 0 && smart_to_reschedule)
    ca78:	0affff9e 	beq	c8f8 <semaphore_release+0x28>
    {
      thread_yield ();
    ca7c:	ebfff69a 	bl	a4ec <thread_yield>
    }

    return DNA_OK;
    ca80:	e1a00005 	mov	r0, r5
    ca84:	eaffff9b 	b	c8f8 <semaphore_release+0x28>
  }

  rescue (invalid_thread_status)
  {
    lock_release (& thread -> lock);
    ca88:	e1a00009 	mov	r0, r9
    ca8c:	eb000018 	bl	caf4 <lock_release>
    lock_release (& sem -> waiting_queue . lock);
    ca90:	e59d000c 	ldr	r0, [sp, #12]
    ca94:	eb000016 	bl	caf4 <lock_release>
    lock_release (& sem -> lock);
    ca98:	e59d0010 	ldr	r0, [sp, #16]
    ca9c:	eb000014 	bl	caf4 <lock_release>

    cpu_trap_restore(it_status);
    caa0:	e59d0008 	ldr	r0, [sp, #8]
    caa4:	ebfff44e 	bl	9be4 <cpu_trap_restore>
    leave;
    caa8:	e59f0040 	ldr	r0, [pc, #64]	; caf0 <semaphore_release+0x220>
    caac:	eaffff91 	b	c8f8 <semaphore_release+0x28>
    cab0:	e1a0a004 	mov	sl, r4
        smart_to_reschedule = smart_to_reschedule ||
          (status == DNA_INVOKE_SCHEDULER);
      }
      else
      {
        thread -> info . sem_tokens -= tokens;
    cab4:	e06b2002 	rsb	r2, fp, r2
    cab8:	e58a204c 	str	r2, [sl, #76]	; 0x4c
        lock_release (& thread -> lock);
    cabc:	e1a00009 	mov	r0, r9
    cac0:	e59d4014 	ldr	r4, [sp, #20]
    cac4:	eb00000a 	bl	caf4 <lock_release>

        tokens = 0;
        queue_pushback (& sem -> waiting_queue, thread);
    cac8:	e59d000c 	ldr	r0, [sp, #12]
    cacc:	e1a0100a 	mov	r1, sl
    cad0:	ebfff362 	bl	9860 <queue_pushback>
      else
      {
        thread -> info . sem_tokens -= tokens;
        lock_release (& thread -> lock);

        tokens = 0;
    cad4:	e3a0b000 	mov	fp, #0
        queue_pushback (& sem -> waiting_queue, thread);

        break;
    cad8:	eaffffd0 	b	ca20 <semaphore_release+0x150>
    cadc:	0000fffc 	.word	0x0000fffc
    cae0:	0000fdff 	.word	0x0000fdff
    cae4:	00035610 	.word	0x00035610
    cae8:	0000b10c 	.word	0x0000b10c
    caec:	ffffface 	.word	0xffffface
    caf0:	0000ffff 	.word	0x0000ffff

0000caf4 <lock_release>:
 *
 * SOURCE
 */

{
  *lock = 0;
    caf4:	e3a03000 	mov	r3, #0
 * Set the lock value to 0.
 *
 * SOURCE
 */

{
    caf8:	e24dd008 	sub	sp, sp, #8
  *lock = 0;
    cafc:	e5803000 	str	r3, [r0]
  cpu_cache_sync ();
    cb00:	e58d3004 	str	r3, [sp, #4]
    cb04:	e59d3004 	ldr	r3, [sp, #4]
    cb08:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
}
    cb0c:	e28dd008 	add	sp, sp, #8
    cb10:	e12fff1e 	bx	lr

0000cb14 <interrupt_attach>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    cb14:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  queue_t * queue = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (id < CPU_TRAP_COUNT, DNA_BAD_ARGUMENT);
    cb18:	e351001f 	cmp	r1, #31
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    cb1c:	e24dd014 	sub	sp, sp, #20
    cb20:	e1a04001 	mov	r4, r1
    cb24:	e5dd7038 	ldrb	r7, [sp, #56]	; 0x38
  queue_t * queue = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (id < CPU_TRAP_COUNT, DNA_BAD_ARGUMENT);
    cb28:	9a000002 	bls	cb38 <interrupt_attach+0x24>
    cb2c:	e59f017c 	ldr	r0, [pc, #380]	; ccb0 <interrupt_attach+0x19c>
    cpu_trap_restore(it_status);

    kernel_free (isr);
    leave;
  }
}
    cb30:	e28dd014 	add	sp, sp, #20
    cb34:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cb38:	e1a05000 	mov	r5, r0
    cb3c:	e1a08002 	mov	r8, r2
    cb40:	e1a06003 	mov	r6, r3
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (id < CPU_TRAP_COUNT, DNA_BAD_ARGUMENT);
    ensure (cpuid < cpu_mp_count (), DNA_BAD_ARGUMENT);
    cb44:	ebfff476 	bl	9d24 <cpu_mp_count>
    cb48:	e1500005 	cmp	r0, r5
    cb4c:	dafffff6 	ble	cb2c <interrupt_attach+0x18>

    /*
     * Create the new ISR
     */

    isr = kernel_malloc (sizeof (struct _isr), true);
    cb50:	e3a00008 	mov	r0, #8
    cb54:	e3a01001 	mov	r1, #1
    cb58:	eb0002e5 	bl	d6f4 <kernel_malloc>
    ensure (isr != NULL, DNA_OUT_OF_MEM);
    cb5c:	e250a000 	subs	sl, r0, #0
    cb60:	059f014c 	ldreq	r0, [pc, #332]	; ccb4 <interrupt_attach+0x1a0>
    cb64:	0afffff1 	beq	cb30 <interrupt_attach+0x1c>
    /*
     * Add the new ISR in the appropriate queue
     */

    it_status = cpu_trap_mask_and_backup();
    queue = & cpu_pool . cpu[cpuid] . isr[id];
    cb68:	e1a03185 	lsl	r3, r5, #3
     */

    isr = kernel_malloc (sizeof (struct _isr), true);
    ensure (isr != NULL, DNA_OUT_OF_MEM);

    isr -> handler = handler;
    cb6c:	e58a6004 	str	r6, [sl, #4]
    /*
     * Add the new ISR in the appropriate queue
     */

    it_status = cpu_trap_mask_and_backup();
    queue = & cpu_pool . cpu[cpuid] . isr[id];
    cb70:	e58d3008 	str	r3, [sp, #8]

    /*
     * Add the new ISR in the appropriate queue
     */

    it_status = cpu_trap_mask_and_backup();
    cb74:	ebfff3e1 	bl	9b00 <cpu_trap_mask_and_backup>
    queue = & cpu_pool . cpu[cpuid] . isr[id];
    cb78:	e59d3008 	ldr	r3, [sp, #8]
    cb7c:	e59fb134 	ldr	fp, [pc, #308]	; ccb8 <interrupt_attach+0x1a4>
    cb80:	e0832005 	add	r2, r3, r5
    cb84:	e0842102 	add	r2, r4, r2, lsl #2
    cb88:	e1a09202 	lsl	r9, r2, #4
    cb8c:	e2899028 	add	r9, r9, #40	; 0x28
    cb90:	e08b9009 	add	r9, fp, r9

    /*
     * Add the new ISR in the appropriate queue
     */

    it_status = cpu_trap_mask_and_backup();
    cb94:	e58d000c 	str	r0, [sp, #12]
    queue = & cpu_pool . cpu[cpuid] . isr[id];

    lock_acquire (& queue -> lock);
    cb98:	e1a00009 	mov	r0, r9
    cb9c:	e58d2004 	str	r2, [sp, #4]
    cba0:	ebfff522 	bl	a030 <lock_acquire>
    queue_add (queue, isr);
    cba4:	e1a00009 	mov	r0, r9
    cba8:	e1a0100a 	mov	r1, sl
    cbac:	ebfff234 	bl	9484 <queue_add>

    check (not_alone, ! bypass_demux ||
    cbb0:	e3570000 	cmp	r7, #0
    cbb4:	e59d2004 	ldr	r2, [sp, #4]
    cbb8:	0a00000f 	beq	cbfc <interrupt_attach+0xe8>
    cbbc:	e2822003 	add	r2, r2, #3
    cbc0:	e08b2202 	add	r2, fp, r2, lsl #4
    cbc4:	e5922004 	ldr	r2, [r2, #4]
    cbc8:	e3520001 	cmp	r2, #1
    cbcc:	0a000027 	beq	cc70 <interrupt_attach+0x15c>
    return DNA_OK;
  }

  rescue (not_alone)
  {
    queue_extract (queue, isr);
    cbd0:	e1a0100a 	mov	r1, sl
    cbd4:	e1a00009 	mov	r0, r9
    cbd8:	ebffef20 	bl	8860 <queue_extract>
    lock_release (& queue -> lock);
    cbdc:	e1a00009 	mov	r0, r9
    cbe0:	ebffffc3 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    cbe4:	e59d000c 	ldr	r0, [sp, #12]
    cbe8:	ebfff3fd 	bl	9be4 <cpu_trap_restore>

    kernel_free (isr);
    cbec:	e1a0000a 	mov	r0, sl
    cbf0:	eb0002f4 	bl	d7c8 <kernel_free>
    leave;
    cbf4:	e59f00c0 	ldr	r0, [pc, #192]	; ccbc <interrupt_attach+0x1a8>
    cbf8:	eaffffcc 	b	cb30 <interrupt_attach+0x1c>
    queue_add (queue, isr);

    check (not_alone, ! bypass_demux ||
        (bypass_demux && queue -> status == 1), DNA_ERROR);

    if (queue -> status == 1)
    cbfc:	e2823003 	add	r3, r2, #3
    cc00:	e08b3203 	add	r3, fp, r3, lsl #4
    cc04:	e5933004 	ldr	r3, [r3, #4]
    cc08:	e3530001 	cmp	r3, #1
    cc0c:	0a000005 	beq	cc28 <interrupt_attach+0x114>
        lock_acquire (& cpu_pool . cpu[cpuid] . ipi_lock);
        cpu_mp_send_ipi (cpuid, DNA_IPI_TRAP_ENABLE, (void *) id);
      }
    }

    lock_release (& queue -> lock);
    cc10:	e1a00009 	mov	r0, r9
    cc14:	ebffffb6 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    cc18:	e59d000c 	ldr	r0, [sp, #12]
    cc1c:	ebfff3f0 	bl	9be4 <cpu_trap_restore>

    return DNA_OK;
    cc20:	e3a00000 	mov	r0, #0
    cc24:	eaffffc1 	b	cb30 <interrupt_attach+0x1c>
      {
        cpu_trap_attach_isr (cpuid, id, mode, handler);
      }
      else
      {
        cpu_trap_attach_isr (cpuid, id, mode, interrupt_demultiplexer);
    cc28:	e1a02008 	mov	r2, r8
    cc2c:	e1a00005 	mov	r0, r5
    cc30:	e1a01004 	mov	r1, r4
    cc34:	e59f3084 	ldr	r3, [pc, #132]	; ccc0 <interrupt_attach+0x1ac>
    cc38:	ebfff408 	bl	9c60 <cpu_trap_attach_isr>
      }

      if (cpuid == cpu_mp_id ())
    cc3c:	ebfff405 	bl	9c58 <cpu_mp_id>
    cc40:	e1500005 	cmp	r0, r5
    cc44:	0a000016 	beq	cca4 <interrupt_attach+0x190>
      {
        cpu_trap_enable (id);
      }
      else
      {
        lock_acquire (& cpu_pool . cpu[cpuid] . ipi_lock);
    cc48:	e59d3008 	ldr	r3, [sp, #8]
    cc4c:	e0830005 	add	r0, r3, r5
    cc50:	e08b0300 	add	r0, fp, r0, lsl #6
    cc54:	e2800018 	add	r0, r0, #24
    cc58:	ebfff4f4 	bl	a030 <lock_acquire>
        cpu_mp_send_ipi (cpuid, DNA_IPI_TRAP_ENABLE, (void *) id);
    cc5c:	e1a00005 	mov	r0, r5
    cc60:	e1a02004 	mov	r2, r4
    cc64:	e59f1048 	ldr	r1, [pc, #72]	; ccb4 <interrupt_attach+0x1a0>
    cc68:	ebfff3b6 	bl	9b48 <cpu_mp_send_ipi>
    cc6c:	eaffffe7 	b	cc10 <interrupt_attach+0xfc>
    queue_add (queue, isr);

    check (not_alone, ! bypass_demux ||
        (bypass_demux && queue -> status == 1), DNA_ERROR);

    if (queue -> status == 1)
    cc70:	e3a03024 	mov	r3, #36	; 0x24
    cc74:	e0234593 	mla	r3, r3, r5, r4
    cc78:	e2833003 	add	r3, r3, #3
    cc7c:	e08b3203 	add	r3, fp, r3, lsl #4
    cc80:	e5933004 	ldr	r3, [r3, #4]
    cc84:	e3530001 	cmp	r3, #1
    cc88:	1affffe0 	bne	cc10 <interrupt_attach+0xfc>
    {
      if (bypass_demux)
      {
        cpu_trap_attach_isr (cpuid, id, mode, handler);
    cc8c:	e1a02008 	mov	r2, r8
    cc90:	e1a03006 	mov	r3, r6
    cc94:	e1a00005 	mov	r0, r5
    cc98:	e1a01004 	mov	r1, r4
    cc9c:	ebfff3ef 	bl	9c60 <cpu_trap_attach_isr>
    cca0:	eaffffe5 	b	cc3c <interrupt_attach+0x128>
        cpu_trap_attach_isr (cpuid, id, mode, interrupt_demultiplexer);
      }

      if (cpuid == cpu_mp_id ())
      {
        cpu_trap_enable (id);
    cca4:	e1a00004 	mov	r0, r4
    cca8:	ebfff3c1 	bl	9bb4 <cpu_trap_enable>
    ccac:	eaffffd7 	b	cc10 <interrupt_attach+0xfc>
    ccb0:	0000fffc 	.word	0x0000fffc
    ccb4:	0000fffd 	.word	0x0000fffd
    ccb8:	0007e458 	.word	0x0007e458
    ccbc:	0000ffff 	.word	0x0000ffff
    ccc0:	0000c070 	.word	0x0000c070

0000ccc4 <port_close>:
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
    ccc4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  port_id_t pid = { .raw = id };
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
    ccc8:	e1a05820 	lsr	r5, r0, #16
    cccc:	e355003f 	cmp	r5, #63	; 0x3f
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
    ccd0:	e1a04000 	mov	r4, r0
  port_id_t pid = { .raw = id };
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
    ccd4:	9a000001 	bls	cce0 <port_close+0x1c>
    ccd8:	e59f007c 	ldr	r0, [pc, #124]	; cd5c <port_close+0x98>
  {
    lock_release (& port_pool . lock);
    cpu_trap_restore(it_status);
    leave;
  }
}
    ccdc:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup();
    cce0:	ebfff386 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& port_pool . lock);
    cce4:	e59f6074 	ldr	r6, [pc, #116]	; cd60 <port_close+0x9c>

    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup();
    cce8:	e1a08000 	mov	r8, r0
    lock_acquire (& port_pool . lock);
    ccec:	e1a00006 	mov	r0, r6
    ccf0:	ebfff4ce 	bl	a030 <lock_acquire>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    ccf4:	e3a03068 	mov	r3, #104	; 0x68
    ccf8:	e0050593 	mul	r5, r3, r5
    ccfc:	e0867005 	add	r7, r6, r5
    cd00:	e597300c 	ldr	r3, [r7, #12]
    cd04:	e1540003 	cmp	r4, r3
    cd08:	0a000005 	beq	cd24 <port_close+0x60>
    return DNA_OK;
  }

  rescue (bad_portid)
  {
    lock_release (& port_pool . lock);
    cd0c:	e1a00006 	mov	r0, r6
    cd10:	ebffff77 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    cd14:	e1a00008 	mov	r0, r8
    cd18:	ebfff3b1 	bl	9be4 <cpu_trap_restore>
    leave;
    cd1c:	e59f0038 	ldr	r0, [pc, #56]	; cd5c <port_close+0x98>
    cd20:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    lock_acquire (& port -> lock);
    cd24:	e2855010 	add	r5, r5, #16
    cd28:	e0855006 	add	r5, r5, r6
    cd2c:	e1a00005 	mov	r0, r5
    cd30:	ebfff4be 	bl	a030 <lock_acquire>
    lock_release (& port_pool . lock);
    cd34:	e1a00006 	mov	r0, r6
    cd38:	ebffff6d 	bl	caf4 <lock_release>

    /*
     * Close the port and return.
     */

    port -> closed = true;
    cd3c:	e3a03001 	mov	r3, #1

    lock_release (& port -> lock);
    cd40:	e1a00005 	mov	r0, r5

    /*
     * Close the port and return.
     */

    port -> closed = true;
    cd44:	e5c73014 	strb	r3, [r7, #20]

    lock_release (& port -> lock);
    cd48:	ebffff69 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    cd4c:	e1a00008 	mov	r0, r8
    cd50:	ebfff3a3 	bl	9be4 <cpu_trap_restore>

    return DNA_OK;
    cd54:	e3a00000 	mov	r0, #0
    cd58:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    cd5c:	0000faff 	.word	0x0000faff
    cd60:	00079628 	.word	0x00079628

0000cd64 <interrupt_detach>:
 * * DNA_OK: the operation is successful
 *
 * SOURCE
 */

{
    cd64:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  queue_t * queue = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (id < CPU_TRAP_COUNT, DNA_BAD_ARGUMENT);
    cd68:	e351001f 	cmp	r1, #31
 * * DNA_OK: the operation is successful
 *
 * SOURCE
 */

{
    cd6c:	e24dd00c 	sub	sp, sp, #12
    cd70:	e1a04001 	mov	r4, r1
  queue_t * queue = NULL;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (id < CPU_TRAP_COUNT, DNA_BAD_ARGUMENT);
    cd74:	9a000002 	bls	cd84 <interrupt_detach+0x20>

  rescue (no_isr)
  {
    lock_release (& queue -> lock);
    cpu_trap_restore(it_status);
    leave;
    cd78:	e59f00e0 	ldr	r0, [pc, #224]	; ce60 <interrupt_detach+0xfc>
  }
}
    cd7c:	e28dd00c 	add	sp, sp, #12
    cd80:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    cd84:	e1a05000 	mov	r5, r0
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (id < CPU_TRAP_COUNT, DNA_BAD_ARGUMENT);
    ensure (cpuid < cpu_mp_count (), DNA_BAD_ARGUMENT);
    cd88:	e58d2004 	str	r2, [sp, #4]
    cd8c:	ebfff3e4 	bl	9d24 <cpu_mp_count>
    cd90:	e1500005 	cmp	r0, r5
    cd94:	dafffff7 	ble	cd78 <interrupt_detach+0x14>

    /*
     * Remove the ISR from the appropriate queue.
     */

    it_status = cpu_trap_mask_and_backup();
    cd98:	ebfff358 	bl	9b00 <cpu_trap_mask_and_backup>
    queue = & cpu_pool . cpu[cpuid] . isr[id];
    cd9c:	e0859185 	add	r9, r5, r5, lsl #3
    cda0:	e0848109 	add	r8, r4, r9, lsl #2
    cda4:	e1a06208 	lsl	r6, r8, #4
    cda8:	e59f70b4 	ldr	r7, [pc, #180]	; ce64 <interrupt_detach+0x100>
    cdac:	e2866028 	add	r6, r6, #40	; 0x28
    cdb0:	e0866007 	add	r6, r6, r7

    /*
     * Remove the ISR from the appropriate queue.
     */

    it_status = cpu_trap_mask_and_backup();
    cdb4:	e1a0a000 	mov	sl, r0
    queue = & cpu_pool . cpu[cpuid] . isr[id];
    lock_acquire (& queue -> lock);
    cdb8:	e1a00006 	mov	r0, r6
    cdbc:	ebfff49b 	bl	a030 <lock_acquire>

    isr = queue_lookup (queue, interrupt_handler_inspector, handler);
    cdc0:	e1a00006 	mov	r0, r6
    cdc4:	e59d2004 	ldr	r2, [sp, #4]
    cdc8:	e59f1098 	ldr	r1, [pc, #152]	; ce68 <interrupt_detach+0x104>
    cdcc:	ebfff1e3 	bl	9560 <queue_lookup>
    check (no_isr, isr != NULL, DNA_BAD_ARGUMENT);
    cdd0:	e250b000 	subs	fp, r0, #0
    return DNA_OK;
  }

  rescue (no_isr)
  {
    lock_release (& queue -> lock);
    cdd4:	e1a00006 	mov	r0, r6
    it_status = cpu_trap_mask_and_backup();
    queue = & cpu_pool . cpu[cpuid] . isr[id];
    lock_acquire (& queue -> lock);

    isr = queue_lookup (queue, interrupt_handler_inspector, handler);
    check (no_isr, isr != NULL, DNA_BAD_ARGUMENT);
    cdd8:	0a00000e 	beq	ce18 <interrupt_detach+0xb4>
    /*
     * If there is no more handler for the specified
     * interrupt, disable it.
     */

    if (queue -> status == 0)
    cddc:	e2888003 	add	r8, r8, #3
    lock_acquire (& queue -> lock);

    isr = queue_lookup (queue, interrupt_handler_inspector, handler);
    check (no_isr, isr != NULL, DNA_BAD_ARGUMENT);

    queue_extract (queue, isr);
    cde0:	e1a0100b 	mov	r1, fp
    /*
     * If there is no more handler for the specified
     * interrupt, disable it.
     */

    if (queue -> status == 0)
    cde4:	e0878208 	add	r8, r7, r8, lsl #4
    lock_acquire (& queue -> lock);

    isr = queue_lookup (queue, interrupt_handler_inspector, handler);
    check (no_isr, isr != NULL, DNA_BAD_ARGUMENT);

    queue_extract (queue, isr);
    cde8:	ebffee9c 	bl	8860 <queue_extract>
    /*
     * If there is no more handler for the specified
     * interrupt, disable it.
     */

    if (queue -> status == 0)
    cdec:	e5983004 	ldr	r3, [r8, #4]
    cdf0:	e3530000 	cmp	r3, #0
    cdf4:	0a00000b 	beq	ce28 <interrupt_detach+0xc4>
        lock_acquire (& cpu_pool . cpu[cpuid] . ipi_lock);
        cpu_mp_send_ipi (cpuid, DNA_IPI_TRAP_DISABLE, (void *) id);
      }
    }

    lock_release (& queue -> lock);
    cdf8:	e1a00006 	mov	r0, r6
    cdfc:	ebffff3c 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    ce00:	e1a0000a 	mov	r0, sl
    ce04:	ebfff376 	bl	9be4 <cpu_trap_restore>

    kernel_free (isr);
    ce08:	e1a0000b 	mov	r0, fp
    ce0c:	eb00026d 	bl	d7c8 <kernel_free>
    return DNA_OK;
    ce10:	e3a00000 	mov	r0, #0
    ce14:	eaffffd8 	b	cd7c <interrupt_detach+0x18>
  }

  rescue (no_isr)
  {
    lock_release (& queue -> lock);
    ce18:	ebffff35 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    ce1c:	e1a0000a 	mov	r0, sl
    ce20:	ebfff36f 	bl	9be4 <cpu_trap_restore>
    ce24:	eaffffd3 	b	cd78 <interrupt_detach+0x14>
     * interrupt, disable it.
     */

    if (queue -> status == 0)
    {
      if (cpuid == cpu_mp_id ())
    ce28:	ebfff38a 	bl	9c58 <cpu_mp_id>
    ce2c:	e1500005 	cmp	r0, r5
    ce30:	0a000007 	beq	ce54 <interrupt_detach+0xf0>
      {
        cpu_trap_disable (id);
      }
      else
      {
        lock_acquire (& cpu_pool . cpu[cpuid] . ipi_lock);
    ce34:	e0870309 	add	r0, r7, r9, lsl #6
    ce38:	e2800018 	add	r0, r0, #24
    ce3c:	ebfff47b 	bl	a030 <lock_acquire>
        cpu_mp_send_ipi (cpuid, DNA_IPI_TRAP_DISABLE, (void *) id);
    ce40:	e1a00005 	mov	r0, r5
    ce44:	e1a02004 	mov	r2, r4
    ce48:	e59f1010 	ldr	r1, [pc, #16]	; ce60 <interrupt_detach+0xfc>
    ce4c:	ebfff33d 	bl	9b48 <cpu_mp_send_ipi>
    ce50:	eaffffe8 	b	cdf8 <interrupt_detach+0x94>

    if (queue -> status == 0)
    {
      if (cpuid == cpu_mp_id ())
      {
        cpu_trap_disable (id);
    ce54:	e1a00004 	mov	r0, r4
    ce58:	ebfff32e 	bl	9b18 <cpu_trap_disable>
    ce5c:	eaffffe5 	b	cdf8 <interrupt_detach+0x94>
    ce60:	0000fffc 	.word	0x0000fffc
    ce64:	0007e458 	.word	0x0007e458
    ce68:	0000a1f8 	.word	0x0000a1f8

0000ce6c <port_create>:
  status_t status;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (name != NULL && p_id != NULL, DNA_BAD_ARGUMENT);
    ce6c:	e3520000 	cmp	r2, #0
    ce70:	13500000 	cmpne	r0, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    ce74:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  status_t status;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (name != NULL && p_id != NULL, DNA_BAD_ARGUMENT);
    ce78:	e1a05000 	mov	r5, r0
    ce7c:	e1a06002 	mov	r6, r2
    ce80:	03a04001 	moveq	r4, #1
    ce84:	13a04000 	movne	r4, #0
    ce88:	1a000001 	bne	ce94 <port_create+0x28>
    ce8c:	e59f0154 	ldr	r0, [pc, #340]	; cfe8 <port_create+0x17c>
    ce90:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    ensure (queue_length > 0, DNA_BAD_ARGUMENT);
    ce94:	e3510000 	cmp	r1, #0
    ce98:	e1a07001 	mov	r7, r1
    ce9c:	dafffffa 	ble	ce8c <port_create+0x20>

    it_status = cpu_trap_mask_and_backup();
    cea0:	ebfff316 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& port_pool . lock);
    cea4:	e59f9140 	ldr	r9, [pc, #320]	; cfec <port_create+0x180>
  watch (status_t)
  {
    ensure (name != NULL && p_id != NULL, DNA_BAD_ARGUMENT);
    ensure (queue_length > 0, DNA_BAD_ARGUMENT);

    it_status = cpu_trap_mask_and_backup();
    cea8:	e1a0a000 	mov	sl, r0
    lock_acquire (& port_pool . lock);
    ceac:	e1a00009 	mov	r0, r9
    ceb0:	ebfff45e 	bl	a030 <lock_acquire>

    /*
     * Get an empty port slot.
     */

    port = queue_rem (& port_pool . port);
    ceb4:	e59f0134 	ldr	r0, [pc, #308]	; cff0 <port_create+0x184>
    ceb8:	ebffeea8 	bl	8960 <queue_rem>
    check (pool_error, port != NULL, DNA_NO_MORE_PORT);
    cebc:	e2508000 	subs	r8, r0, #0
    cec0:	0a000044 	beq	cfd8 <port_create+0x16c>
    /*
     * Make the place clean.
     */

    index = port -> id . s . index;
    dna_memset (port, 0, sizeof (struct _port));
    cec4:	e1a01004 	mov	r1, r4
    cec8:	e3a02068 	mov	r2, #104	; 0x68

    /*
     * Make the place clean.
     */

    index = port -> id . s . index;
    cecc:	e1d8b0b6 	ldrh	fp, [r8, #6]
    dna_memset (port, 0, sizeof (struct _port));
    ced0:	ebffef03 	bl	8ae4 <dna_memset>

    port -> id . s . index = index;
    port -> id . s . value = port_pool . counter;
    ced4:	e1d920b4 	ldrh	r2, [r9, #4]

    semaphore_pool . counter += 1;
    ced8:	e59f3114 	ldr	r3, [pc, #276]	; cff4 <port_create+0x188>

    index = port -> id . s . index;
    dna_memset (port, 0, sizeof (struct _port));

    port -> id . s . index = index;
    port -> id . s . value = port_pool . counter;
    cedc:	e1c820b4 	strh	r2, [r8, #4]

    semaphore_pool . counter += 1;
    cee0:	e1d320b4 	ldrh	r2, [r3, #4]

    lock_release (& port_pool . lock);
    cee4:	e1a00009 	mov	r0, r9
    dna_memset (port, 0, sizeof (struct _port));

    port -> id . s . index = index;
    port -> id . s . value = port_pool . counter;

    semaphore_pool . counter += 1;
    cee8:	e2822001 	add	r2, r2, #1
     */

    index = port -> id . s . index;
    dna_memset (port, 0, sizeof (struct _port));

    port -> id . s . index = index;
    ceec:	e1c8b0b6 	strh	fp, [r8, #6]
    port -> id . s . value = port_pool . counter;

    semaphore_pool . counter += 1;
    cef0:	e1c320b4 	strh	r2, [r3, #4]

    lock_release (& port_pool . lock);
    cef4:	ebfffefe 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    cef8:	e1a0000a 	mov	r0, sl
    cefc:	ebfff338 	bl	9be4 <cpu_trap_restore>
    /*
     * Creating the messages.
     */

    port -> data = kernel_malloc
      (sizeof (struct _message) * queue_length, true);
    cf00:	e3a01001 	mov	r1, #1
    cf04:	e1a00207 	lsl	r0, r7, #4
    cf08:	eb0001f9 	bl	d6f4 <kernel_malloc>
    check (no_mem, port -> data != NULL, DNA_OUT_OF_MEM);
    cf0c:	e3500000 	cmp	r0, #0

    /*
     * Creating the messages.
     */

    port -> data = kernel_malloc
    cf10:	e5880044 	str	r0, [r8, #68]	; 0x44
      (sizeof (struct _message) * queue_length, true);
    check (no_mem, port -> data != NULL, DNA_OUT_OF_MEM);
    cf14:	11a01000 	movne	r1, r0
    cf18:	12889048 	addne	r9, r8, #72	; 0x48
    cf1c:	1a000001 	bne	cf28 <port_create+0xbc>
    cf20:	ea00002e 	b	cfe0 <port_create+0x174>
    cf24:	e5981044 	ldr	r1, [r8, #68]	; 0x44

    for (int32_t i = 0; i < queue_length; i += 1)
    {
      queue_add (& port -> message, & port -> data[i]);
    cf28:	e0811204 	add	r1, r1, r4, lsl #4
    cf2c:	e1a00009 	mov	r0, r9

    port -> data = kernel_malloc
      (sizeof (struct _message) * queue_length, true);
    check (no_mem, port -> data != NULL, DNA_OUT_OF_MEM);

    for (int32_t i = 0; i < queue_length; i += 1)
    cf30:	e2844001 	add	r4, r4, #1
    {
      queue_add (& port -> message, & port -> data[i]);
    cf34:	ebfff152 	bl	9484 <queue_add>

    port -> data = kernel_malloc
      (sizeof (struct _message) * queue_length, true);
    check (no_mem, port -> data != NULL, DNA_OUT_OF_MEM);

    for (int32_t i = 0; i < queue_length; i += 1)
    cf38:	e1540007 	cmp	r4, r7
    cf3c:	1afffff8 	bne	cf24 <port_create+0xb8>

    /*
     * Creating the semaphores.
     */

    status = semaphore_create (name, queue_length, & port -> write_sem);
    cf40:	e1a00005 	mov	r0, r5
    cf44:	e1a01004 	mov	r1, r4
    cf48:	e2882040 	add	r2, r8, #64	; 0x40
    cf4c:	ebfffdbc 	bl	c644 <semaphore_create>
    check (wsem_error, status == DNA_OK, status);
    cf50:	e2507000 	subs	r7, r0, #0
    cf54:	0a00000e 	beq	cf94 <port_create+0x128>
    semaphore_destroy (port -> write_sem);
  }

  rescue (wsem_error)
  {
    kernel_free (port -> data);
    cf58:	e5980044 	ldr	r0, [r8, #68]	; 0x44
    cf5c:	eb000219 	bl	d7c8 <kernel_free>
  }

  rescue (no_mem)
  {
    it_status = cpu_trap_mask_and_backup();
    cf60:	ebfff2e6 	bl	9b00 <cpu_trap_mask_and_backup>
    cf64:	e1a0a000 	mov	sl, r0
    lock_acquire (& port_pool . lock);
    cf68:	e59f007c 	ldr	r0, [pc, #124]	; cfec <port_create+0x180>
    cf6c:	ebfff42f 	bl	a030 <lock_acquire>

    queue_add (& port_pool . port, port);
    cf70:	e1a01008 	mov	r1, r8
    cf74:	e59f0074 	ldr	r0, [pc, #116]	; cff0 <port_create+0x184>
    cf78:	ebfff141 	bl	9484 <queue_add>
  }

  rescue (pool_error)
  {
    lock_release (& port_pool . lock);
    cf7c:	e59f0068 	ldr	r0, [pc, #104]	; cfec <port_create+0x180>
    cf80:	ebfffedb 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    cf84:	e1a0000a 	mov	r0, sl
    cf88:	ebfff315 	bl	9be4 <cpu_trap_restore>
    leave;
    cf8c:	e1a00007 	mov	r0, r7
    cf90:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
     */

    status = semaphore_create (name, queue_length, & port -> write_sem);
    check (wsem_error, status == DNA_OK, status);

    status = semaphore_create (name, 0, & port -> read_sem);
    cf94:	e1a01007 	mov	r1, r7
    cf98:	e1a00005 	mov	r0, r5
    cf9c:	e288203c 	add	r2, r8, #60	; 0x3c
    cfa0:	ebfffda7 	bl	c644 <semaphore_create>
    check (rsem_error, status == DNA_OK, status);
    cfa4:	e2507000 	subs	r7, r0, #0
    cfa8:	0a000002 	beq	cfb8 <port_create+0x14c>
    return DNA_OK;
  }

  rescue (rsem_error)
  {
    semaphore_destroy (port -> write_sem);
    cfac:	e5980040 	ldr	r0, [r8, #64]	; 0x40
    cfb0:	ebfff49a 	bl	a220 <semaphore_destroy>
    cfb4:	eaffffe7 	b	cf58 <port_create+0xec>
    check (wsem_error, status == DNA_OK, status);

    status = semaphore_create (name, 0, & port -> read_sem);
    check (rsem_error, status == DNA_OK, status);

    dna_strcpy (port -> info . name, name);
    cfb8:	e1a01005 	mov	r1, r5
    cfbc:	e2880010 	add	r0, r8, #16
    cfc0:	ebfff1c8 	bl	96e8 <dna_strcpy>

    /*
     * Return the port information.
     */

    *p_id = port -> id . raw;
    cfc4:	e5983004 	ldr	r3, [r8, #4]

    status = semaphore_create (name, 0, & port -> read_sem);
    check (rsem_error, status == DNA_OK, status);

    dna_strcpy (port -> info . name, name);
    port -> info . capacity = queue_length;
    cfc8:	e5884030 	str	r4, [r8, #48]	; 0x30
    /*
     * Return the port information.
     */

    *p_id = port -> id . raw;
    return DNA_OK;
    cfcc:	e1a00007 	mov	r0, r7

    /*
     * Return the port information.
     */

    *p_id = port -> id . raw;
    cfd0:	e5863000 	str	r3, [r6]
    return DNA_OK;
    cfd4:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    /*
     * Get an empty port slot.
     */

    port = queue_rem (& port_pool . port);
    check (pool_error, port != NULL, DNA_NO_MORE_PORT);
    cfd8:	e59f7018 	ldr	r7, [pc, #24]	; cff8 <port_create+0x18c>
    cfdc:	eaffffe6 	b	cf7c <port_create+0x110>
     * Creating the messages.
     */

    port -> data = kernel_malloc
      (sizeof (struct _message) * queue_length, true);
    check (no_mem, port -> data != NULL, DNA_OUT_OF_MEM);
    cfe0:	e59f7014 	ldr	r7, [pc, #20]	; cffc <port_create+0x190>
    cfe4:	eaffffdd 	b	cf60 <port_create+0xf4>
    cfe8:	0000fffc 	.word	0x0000fffc
    cfec:	00079628 	.word	0x00079628
    cff0:	0007b030 	.word	0x0007b030
    cff4:	00035610 	.word	0x00035610
    cff8:	0000fafe 	.word	0x0000fafe
    cffc:	0000fffd 	.word	0x0000fffd

0000d000 <thread_find>:
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    d000:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int32_t current_cpuid, index;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid != NULL, DNA_BAD_ARGUMENT);
    d004:	e3510000 	cmp	r1, #0
 * * DNA_OK: the operation succeeded
 *
 * SOURCE
 */

{
    d008:	e24dd014 	sub	sp, sp, #20
  int32_t current_cpuid, index;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid != NULL, DNA_BAD_ARGUMENT);
    d00c:	e58d1008 	str	r1, [sp, #8]
    d010:	059f00f4 	ldreq	r0, [pc, #244]	; d10c <thread_find+0x10c>
    d014:	0a00002c 	beq	d0cc <thread_find+0xcc>
    d018:	e1a07000 	mov	r7, r0

    /*
     * Gather information about the current execution.
     */

    it_status = cpu_trap_mask_and_backup();
    d01c:	ebfff2b7 	bl	9b00 <cpu_trap_mask_and_backup>
    d020:	e58d000c 	str	r0, [sp, #12]
    current_cpuid = cpu_mp_id ();
    d024:	ebfff30b 	bl	9c58 <cpu_mp_id>
    self = cpu_pool . cpu[current_cpuid] . current_thread;
    d028:	e59f30e0 	ldr	r3, [pc, #224]	; d110 <thread_find+0x110>
    d02c:	e0800180 	add	r0, r0, r0, lsl #3
    d030:	e0833300 	add	r3, r3, r0, lsl #6
    /*
     * Find the requested thread. It can be either self,
     * or a thread in self's group.
     */

    if (name == NULL)
    d034:	e3570000 	cmp	r7, #0
     * Gather information about the current execution.
     */

    it_status = cpu_trap_mask_and_backup();
    current_cpuid = cpu_mp_id ();
    self = cpu_pool . cpu[current_cpuid] . current_thread;
    d038:	e593b22c 	ldr	fp, [r3, #556]	; 0x22c
    /*
     * Find the requested thread. It can be either self,
     * or a thread in self's group.
     */

    if (name == NULL)
    d03c:	0a00002b 	beq	d0f0 <thread_find+0xf0>
    d040:	e59f60cc 	ldr	r6, [pc, #204]	; d114 <thread_find+0x114>
    }
    else
    {
      lock_acquire (& thread_pool . lock);

      for (index = 0; index < DNA_MAX_THREAD; index += 1)
    d044:	e3a04000 	mov	r4, #0
      *tid = self -> id . raw;
      cpu_trap_restore (it_status);
    }
    else
    {
      lock_acquire (& thread_pool . lock);
    d048:	e1a00006 	mov	r0, r6

      for (index = 0; index < DNA_MAX_THREAD; index += 1)
      {
        thread = & thread_pool . data[self -> id . s . group][index];

        if (thread -> id . s . value != 0 &&
    d04c:	e1a08006 	mov	r8, r6
      *tid = self -> id . raw;
      cpu_trap_restore (it_status);
    }
    else
    {
      lock_acquire (& thread_pool . lock);
    d050:	ebfff3f6 	bl	a030 <lock_acquire>

      for (index = 0; index < DNA_MAX_THREAD; index += 1)
      {
        thread = & thread_pool . data[self -> id . s . group][index];

        if (thread -> id . s . value != 0 &&
    d054:	e3a090d0 	mov	r9, #208	; 0xd0
    d058:	e3a0ab0d 	mov	sl, #13312	; 0x3400
    d05c:	ea000001 	b	d068 <thread_find+0x68>
    }
    else
    {
      lock_acquire (& thread_pool . lock);

      for (index = 0; index < DNA_MAX_THREAD; index += 1)
    d060:	e3540040 	cmp	r4, #64	; 0x40
    d064:	0a00001a 	beq	d0d4 <thread_find+0xd4>
      {
        thread = & thread_pool . data[self -> id . s . group][index];
    d068:	e5db301e 	ldrb	r3, [fp, #30]

        if (thread -> id . s . value != 0 &&
    d06c:	e003039a 	mul	r3, sl, r3
    d070:	e0233499 	mla	r3, r9, r4, r3
    d074:	e0865003 	add	r5, r6, r3
    d078:	e1d512b4 	ldrh	r1, [r5, #36]	; 0x24
    }
    else
    {
      lock_acquire (& thread_pool . lock);

      for (index = 0; index < DNA_MAX_THREAD; index += 1)
    d07c:	e2844001 	add	r4, r4, #1
      {
        thread = & thread_pool . data[self -> id . s . group][index];

        if (thread -> id . s . value != 0 &&
    d080:	e3510000 	cmp	r1, #0
    d084:	e2855020 	add	r5, r5, #32
    d088:	0afffff4 	beq	d060 <thread_find+0x60>
            dna_strcmp (name, thread -> info . name) == 0)
    d08c:	e2831028 	add	r1, r3, #40	; 0x28
    d090:	e0881001 	add	r1, r8, r1
    d094:	e1a00007 	mov	r0, r7
    d098:	ebfff124 	bl	9530 <dna_strcmp>

      for (index = 0; index < DNA_MAX_THREAD; index += 1)
      {
        thread = & thread_pool . data[self -> id . s . group][index];

        if (thread -> id . s . value != 0 &&
    d09c:	e2503000 	subs	r3, r0, #0
    d0a0:	1affffee 	bne	d060 <thread_find+0x60>
            dna_strcmp (name, thread -> info . name) == 0)
        {
          *tid = thread -> id . raw;
    d0a4:	e5952004 	ldr	r2, [r5, #4]
    d0a8:	e59d1008 	ldr	r1, [sp, #8]
          break;
        }
      }

      lock_release (& thread_pool . lock);
    d0ac:	e59f0060 	ldr	r0, [pc, #96]	; d114 <thread_find+0x114>
        thread = & thread_pool . data[self -> id . s . group][index];

        if (thread -> id . s . value != 0 &&
            dna_strcmp (name, thread -> info . name) == 0)
        {
          *tid = thread -> id . raw;
    d0b0:	e5812000 	str	r2, [r1]
          break;
        }
      }

      lock_release (& thread_pool . lock);
    d0b4:	e58d3004 	str	r3, [sp, #4]
    d0b8:	ebfffe8d 	bl	caf4 <lock_release>
      cpu_trap_restore (it_status);
    d0bc:	e59d000c 	ldr	r0, [sp, #12]
    d0c0:	ebfff2c7 	bl	9be4 <cpu_trap_restore>

      ensure (index != DNA_MAX_THREAD, DNA_UNKNOWN_THREAD);
    }

    return DNA_OK;
    d0c4:	e59d3004 	ldr	r3, [sp, #4]
    d0c8:	e1a00003 	mov	r0, r3
  }
}
    d0cc:	e28dd014 	add	sp, sp, #20
    d0d0:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
          *tid = thread -> id . raw;
          break;
        }
      }

      lock_release (& thread_pool . lock);
    d0d4:	e59f0038 	ldr	r0, [pc, #56]	; d114 <thread_find+0x114>
    d0d8:	ebfffe85 	bl	caf4 <lock_release>
      cpu_trap_restore (it_status);
    d0dc:	e59d000c 	ldr	r0, [sp, #12]
    d0e0:	ebfff2bf 	bl	9be4 <cpu_trap_restore>

      ensure (index != DNA_MAX_THREAD, DNA_UNKNOWN_THREAD);
    d0e4:	e59f002c 	ldr	r0, [pc, #44]	; d118 <thread_find+0x118>
    }

    return DNA_OK;
  }
}
    d0e8:	e28dd014 	add	sp, sp, #20
    d0ec:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
     * or a thread in self's group.
     */

    if (name == NULL)
    {
      *tid = self -> id . raw;
    d0f0:	e59b301c 	ldr	r3, [fp, #28]
    d0f4:	e59d2008 	ldr	r2, [sp, #8]
      cpu_trap_restore (it_status);
    d0f8:	e59d000c 	ldr	r0, [sp, #12]
     * or a thread in self's group.
     */

    if (name == NULL)
    {
      *tid = self -> id . raw;
    d0fc:	e5823000 	str	r3, [r2]
      cpu_trap_restore (it_status);
    d100:	ebfff2b7 	bl	9be4 <cpu_trap_restore>
      cpu_trap_restore (it_status);

      ensure (index != DNA_MAX_THREAD, DNA_UNKNOWN_THREAD);
    }

    return DNA_OK;
    d104:	e1a00007 	mov	r0, r7
    d108:	eaffffef 	b	d0cc <thread_find+0xcc>
    d10c:	0000fffc 	.word	0x0000fffc
    d110:	0007e458 	.word	0x0007e458
    d114:	0007b040 	.word	0x0007b040
    d118:	0000fcff 	.word	0x0000fcff

0000d11c <port_poll>:
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
    d11c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  status_t status;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
    d120:	e1a04820 	lsr	r4, r0, #16
    d124:	e354003f 	cmp	r4, #63	; 0x3f
 * * DNA_OK if the operation succeded.
 *
 * SOURCE
 */

{
    d128:	e1a0a000 	mov	sl, r0
    d12c:	e24dd014 	sub	sp, sp, #20
  status_t status;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (pid . s . index < DNA_MAX_PORT, DNA_BAD_PORT_ID);
    d130:	859f019c 	ldrhi	r0, [pc, #412]	; d2d4 <port_poll+0x1b8>
    d134:	9a000001 	bls	d140 <port_poll+0x24>
  {
    lock_release (& port_pool . lock);
    cpu_trap_restore (it_status);
    leave;
  }
}
    d138:	e28dd014 	add	sp, sp, #20
    d13c:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    d140:	e3a08068 	mov	r8, #104	; 0x68
    d144:	e1a0b001 	mov	fp, r1

    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
    d148:	e58d200c 	str	r2, [sp, #12]
    d14c:	e58d3008 	str	r3, [sp, #8]
    d150:	ebfff26a 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    d154:	e0070498 	mul	r7, r8, r4
    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);
    d158:	e59f5178 	ldr	r5, [pc, #376]	; d2d8 <port_poll+0x1bc>

    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
    d15c:	e1a06000 	mov	r6, r0
    lock_acquire (& port_pool . lock);

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    d160:	e0859007 	add	r9, r5, r7
    /*
     * Look for the port with ID pid.
     */

    it_status = cpu_trap_mask_and_backup ();
    lock_acquire (& port_pool . lock);
    d164:	e1a00005 	mov	r0, r5
    d168:	ebfff3b0 	bl	a030 <lock_acquire>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    d16c:	e599100c 	ldr	r1, [r9, #12]
    d170:	e15a0001 	cmp	sl, r1
    d174:	0a000006 	beq	d194 <port_poll+0x78>
    leave;
  }

  rescue (bad_portid)
  {
    lock_release (& port_pool . lock);
    d178:	e59f0158 	ldr	r0, [pc, #344]	; d2d8 <port_poll+0x1bc>
    d17c:	ebfffe5c 	bl	caf4 <lock_release>
    cpu_trap_restore (it_status);
    d180:	e1a00006 	mov	r0, r6
    d184:	ebfff296 	bl	9be4 <cpu_trap_restore>
    leave;
    d188:	e59f0144 	ldr	r0, [pc, #324]	; d2d4 <port_poll+0x1b8>
  }
}
    d18c:	e28dd014 	add	sp, sp, #20
    d190:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);

    lock_acquire (& port -> lock);
    d194:	e2877010 	add	r7, r7, #16
    d198:	e0877005 	add	r7, r7, r5
    d19c:	e1a00007 	mov	r0, r7
    d1a0:	ebfff3a2 	bl	a030 <lock_acquire>
    lock_release (& port_pool . lock);
    d1a4:	e1a00005 	mov	r0, r5
    d1a8:	ebfffe51 	bl	caf4 <lock_release>

    check (bad_port, ! port -> closed ||
    d1ac:	e5d91014 	ldrb	r1, [r9, #20]
    d1b0:	e59d200c 	ldr	r2, [sp, #12]
    d1b4:	e3510000 	cmp	r1, #0
    d1b8:	e59d3008 	ldr	r3, [sp, #8]
    d1bc:	0a00000a 	beq	d1ec <port_poll+0xd0>
    d1c0:	e0288894 	mla	r8, r4, r8, r8
    d1c4:	e0858008 	add	r8, r5, r8
    d1c8:	e5981004 	ldr	r1, [r8, #4]
    d1cc:	e3510000 	cmp	r1, #0
    d1d0:	1a000005 	bne	d1ec <port_poll+0xd0>
    return DNA_OK;
  }

  rescue (bad_port)
  {
    lock_release (& port -> lock);
    d1d4:	e1a00007 	mov	r0, r7
    d1d8:	ebfffe45 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    d1dc:	e1a00006 	mov	r0, r6
    d1e0:	ebfff27f 	bl	9be4 <cpu_trap_restore>
    leave;
    d1e4:	e59f00f0 	ldr	r0, [pc, #240]	; d2dc <port_poll+0x1c0>
    d1e8:	eaffffd2 	b	d138 <port_poll+0x1c>
    lock_release (& port_pool . lock);

    check (bad_port, ! port -> closed ||
        port -> mailbox . status != 0, DNA_ERROR);

    read_sem = port -> read_sem;
    d1ec:	e3a01068 	mov	r1, #104	; 0x68
    d1f0:	e0285491 	mla	r8, r1, r4, r5

    lock_release (& port -> lock);
    d1f4:	e1a00007 	mov	r0, r7
    lock_release (& port_pool . lock);

    check (bad_port, ! port -> closed ||
        port -> mailbox . status != 0, DNA_ERROR);

    read_sem = port -> read_sem;
    d1f8:	e5989044 	ldr	r9, [r8, #68]	; 0x44

    lock_release (& port -> lock);
    d1fc:	e58d200c 	str	r2, [sp, #12]
    d200:	e58d3008 	str	r3, [sp, #8]
    d204:	ebfffe3a 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    d208:	e1a00006 	mov	r0, r6
    d20c:	ebfff274 	bl	9be4 <cpu_trap_restore>

    /*
     * Acquire the semaphore.
     */

    status = semaphore_acquire (read_sem, 1, flags, timeout);
    d210:	e59d200c 	ldr	r2, [sp, #12]
    d214:	e59d3008 	ldr	r3, [sp, #8]
    d218:	e1a00009 	mov	r0, r9
    d21c:	e1cd20f0 	strd	r2, [sp]
    d220:	e3a01001 	mov	r1, #1
    d224:	e1a0200b 	mov	r2, fp
    d228:	ebfff8e7 	bl	b5cc <semaphore_acquire>
    ensure (status == DNA_OK, status);
    d22c:	e3500000 	cmp	r0, #0
    lock_release (& port_pool . lock);

    check (bad_port, ! port -> closed ||
        port -> mailbox . status != 0, DNA_ERROR);

    read_sem = port -> read_sem;
    d230:	e59fb0a0 	ldr	fp, [pc, #160]	; d2d8 <port_poll+0x1bc>
    /*
     * Acquire the semaphore.
     */

    status = semaphore_acquire (read_sem, 1, flags, timeout);
    ensure (status == DNA_OK, status);
    d234:	1affffbf 	bne	d138 <port_poll+0x1c>
    /*
     * Get the port once again, just to make sure
     * it has not been destroyed in the meantime.
     */

    it_status = cpu_trap_mask_and_backup ();
    d238:	ebfff230 	bl	9b00 <cpu_trap_mask_and_backup>
    d23c:	e1a06000 	mov	r6, r0
    lock_acquire (& port_pool . lock);
    d240:	e1a0000b 	mov	r0, fp
    d244:	ebfff379 	bl	a030 <lock_acquire>

    port = & port_pool . data[pid . s . index];
    check (bad_portid, port != NULL, DNA_BAD_PORT_ID);
    check (bad_portid, port -> id . raw == pid . raw, DNA_BAD_PORT_ID);
    d248:	e598300c 	ldr	r3, [r8, #12]
    d24c:	e15a0003 	cmp	sl, r3
    d250:	1affffc8 	bne	d178 <port_poll+0x5c>

    lock_acquire (& port -> lock);
    d254:	e1a00007 	mov	r0, r7
    d258:	ebfff374 	bl	a030 <lock_acquire>
    lock_release (& port_pool . lock);
    d25c:	e1a0000b 	mov	r0, fp
    d260:	ebfffe23 	bl	caf4 <lock_release>

    check (bad_port, ! port -> closed ||
    d264:	e5d83014 	ldrb	r3, [r8, #20]
    d268:	e3530000 	cmp	r3, #0
    d26c:	0a000005 	beq	d288 <port_poll+0x16c>
    d270:	e3a02068 	mov	r2, #104	; 0x68
    d274:	e2843001 	add	r3, r4, #1
    d278:	e02ab392 	mla	sl, r2, r3, fp
    d27c:	e59a3004 	ldr	r3, [sl, #4]
    d280:	e3530000 	cmp	r3, #0
    d284:	0affffd2 	beq	d1d4 <port_poll+0xb8>

    /*
     * Get the message size from the message queue.
     */

    message = queue_rem (& port -> mailbox);
    d288:	e3a03068 	mov	r3, #104	; 0x68
    d28c:	e0245493 	mla	r4, r3, r4, r5
    d290:	e2844060 	add	r4, r4, #96	; 0x60
    d294:	e1a00004 	mov	r0, r4
    d298:	ebffedb0 	bl	8960 <queue_rem>
    check (bad_port, message != NULL, DNA_ERROR);
    d29c:	e2501000 	subs	r1, r0, #0
    d2a0:	0affffcb 	beq	d1d4 <port_poll+0xb8>

#if 0
    data_size = message -> size;
#endif
    queue_pushback (& port -> mailbox, message);
    d2a4:	e1a00004 	mov	r0, r4
    d2a8:	ebfff16c 	bl	9860 <queue_pushback>

    lock_release (& port -> lock);
    d2ac:	e1a00007 	mov	r0, r7
    d2b0:	ebfffe0f 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    d2b4:	e1a00006 	mov	r0, r6
    d2b8:	ebfff249 	bl	9be4 <cpu_trap_restore>

    /*
     * Release the semaphore and return.
     */

    status = semaphore_release (read_sem, 1, DNA_NO_RESCHEDULE);
    d2bc:	e3a01001 	mov	r1, #1
    d2c0:	e1a00009 	mov	r0, r9
    d2c4:	e1a02001 	mov	r2, r1
  {
    lock_release (& port_pool . lock);
    cpu_trap_restore (it_status);
    leave;
  }
}
    d2c8:	e28dd014 	add	sp, sp, #20
    d2cc:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}

    /*
     * Release the semaphore and return.
     */

    status = semaphore_release (read_sem, 1, DNA_NO_RESCHEDULE);
    d2d0:	eafffd7e 	b	c8d0 <semaphore_release>
    d2d4:	0000faff 	.word	0x0000faff
    d2d8:	00079628 	.word	0x00079628
    d2dc:	0000ffff 	.word	0x0000ffff

0000d2e0 <thread_suspend>:
 */

{
  queue_t * queue = NULL;
  status_t status, result;
  thread_t target = NULL;
    d2e0:	e3a03000 	mov	r3, #0
 * * DNA_OK: the operation succeeded.
 *
 * SOURCE
 */

{
    d2e4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    d2e8:	e1a02820 	lsr	r2, r0, #16
 * * DNA_OK: the operation succeeded.
 *
 * SOURCE
 */

{
    d2ec:	e24dd014 	sub	sp, sp, #20
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    d2f0:	e31200ff 	tst	r2, #255	; 0xff
 * * DNA_OK: the operation succeeded.
 *
 * SOURCE
 */

{
    d2f4:	e1a04000 	mov	r4, r0
  queue_t * queue = NULL;
  status_t status, result;
  thread_t target = NULL;
    d2f8:	e58d300c 	str	r3, [sp, #12]
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    d2fc:	0a000002 	beq	d30c <thread_suspend+0x2c>
    d300:	e59f020c 	ldr	r0, [pc, #524]	; d514 <thread_suspend+0x234>
  {
    lock_release (& thread_pool . lock);
    cpu_trap_restore (it_status);
    leave;
  }
}
    d304:	e28dd014 	add	sp, sp, #20
    d308:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
  watch (status_t)
  {
    ensure (tid . s . group >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . group < DNA_MAX_GROUP, DNA_BAD_ARGUMENT);
    ensure (tid . s . index >= 0, DNA_BAD_ARGUMENT);
    ensure (tid . s . index < DNA_MAX_THREAD, DNA_BAD_ARGUMENT);
    d30c:	e1a05c20 	lsr	r5, r0, #24
    d310:	e355003f 	cmp	r5, #63	; 0x3f
    d314:	8afffff9 	bhi	d300 <thread_suspend+0x20>

    /*
     * Get some information about the execution.
     */

    it_status = cpu_trap_mask_and_backup ();
    d318:	ebfff1f8 	bl	9b00 <cpu_trap_mask_and_backup>
    d31c:	e58d0004 	str	r0, [sp, #4]
    current_cpuid = cpu_mp_id ();
    d320:	ebfff24c 	bl	9c58 <cpu_mp_id>
    d324:	e3a030d0 	mov	r3, #208	; 0xd0
    d328:	e0050593 	mul	r5, r3, r5
    do
    {
      lock_acquire (& thread_pool . lock);
      thread = & thread_pool . data[tid . s . group][tid . s . index];

      check (bad_thread, thread != NULL &&
    d32c:	e1a0a005 	mov	sl, r5
    d330:	e59f91e0 	ldr	r9, [pc, #480]	; d518 <thread_suspend+0x238>
    d334:	e2855008 	add	r5, r5, #8

      /*
       * Lock the thread and check its status.
       */

      lock_acquire (& thread -> lock);
    d338:	e089700a 	add	r7, r9, sl
    /*
     * Get some information about the execution.
     */

    it_status = cpu_trap_mask_and_backup ();
    current_cpuid = cpu_mp_id ();
    d33c:	e58d0000 	str	r0, [sp]
    d340:	e089b005 	add	fp, r9, r5

      /*
       * Lock the thread and check its status.
       */

      lock_acquire (& thread -> lock);
    d344:	e287701c 	add	r7, r7, #28
    do
    {
      lock_acquire (& thread_pool . lock);
      thread = & thread_pool . data[tid . s . group][tid . s . index];

      check (bad_thread, thread != NULL &&
    d348:	e089500a 	add	r5, r9, sl
    d34c:	e2856020 	add	r6, r5, #32
     * in several different ways.
     */

    do
    {
      lock_acquire (& thread_pool . lock);
    d350:	e59f01c0 	ldr	r0, [pc, #448]	; d518 <thread_suspend+0x238>
    d354:	ebfff335 	bl	a030 <lock_acquire>
      thread = & thread_pool . data[tid . s . group][tid . s . index];

      check (bad_thread, thread != NULL &&
    d358:	e5963004 	ldr	r3, [r6, #4]
    d35c:	e1540003 	cmp	r4, r3
    d360:	1a00005e 	bne	d4e0 <thread_suspend+0x200>

      /*
       * Lock the thread and check its status.
       */

      lock_acquire (& thread -> lock);
    d364:	e1a00007 	mov	r0, r7
    d368:	ebfff330 	bl	a030 <lock_acquire>
      lock_release (& thread_pool . lock);
    d36c:	e59f01a4 	ldr	r0, [pc, #420]	; d518 <thread_suspend+0x238>
    d370:	ebfffddf 	bl	caf4 <lock_release>

      check (thread_error,
    d374:	e59f81a0 	ldr	r8, [pc, #416]	; d51c <thread_suspend+0x23c>
    d378:	e1d535b8 	ldrh	r3, [r5, #88]	; 0x58
    d37c:	e59f219c 	ldr	r2, [pc, #412]	; d520 <thread_suspend+0x240>
    d380:	e285c058 	add	ip, r5, #88	; 0x58
    d384:	e1530002 	cmp	r3, r2
    d388:	11530008 	cmpne	r3, r8
    d38c:	03a08001 	moveq	r8, #1
    d390:	13a08000 	movne	r8, #0
    d394:	0a000048 	beq	d4bc <thread_suspend+0x1dc>

      /*
       * Discriminate in function of its status.
       */

      switch (thread -> info . status)
    d398:	e59f2184 	ldr	r2, [pc, #388]	; d524 <thread_suspend+0x244>
    d39c:	e1530002 	cmp	r3, r2
    d3a0:	0a000040 	beq	d4a8 <thread_suspend+0x1c8>
    d3a4:	9a00001b 	bls	d418 <thread_suspend+0x138>
    d3a8:	e59f2178 	ldr	r2, [pc, #376]	; d528 <thread_suspend+0x248>
    d3ac:	e1530002 	cmp	r3, r2
    d3b0:	0a000026 	beq	d450 <thread_suspend+0x170>
    d3b4:	e59f2170 	ldr	r2, [pc, #368]	; d52c <thread_suspend+0x24c>
    d3b8:	e1530002 	cmp	r3, r2
    d3bc:	1affffe1 	bne	d348 <thread_suspend+0x68>
            break;
          }

        case DNA_THREAD_READY :
          {
            queue = & scheduler . queue[thread -> info . affinity];
    d3c0:	e59f3168 	ldr	r3, [pc, #360]	; d530 <thread_suspend+0x250>
    d3c4:	e5956050 	ldr	r6, [r5, #80]	; 0x50
            /*
             * Apply the banker's algorithm to lock both the thread
             * and the ready queue.
             */

            result = lock_try (& queue -> lock, true);
    d3c8:	e3a01001 	mov	r1, #1
            break;
          }

        case DNA_THREAD_READY :
          {
            queue = & scheduler . queue[thread -> info . affinity];
    d3cc:	e0836206 	add	r6, r3, r6, lsl #4
    d3d0:	e2866004 	add	r6, r6, #4
            /*
             * Apply the banker's algorithm to lock both the thread
             * and the ready queue.
             */

            result = lock_try (& queue -> lock, true);
    d3d4:	e1a00006 	mov	r0, r6
    d3d8:	ebfff633 	bl	acac <lock_try>

            if (result != DNA_ERROR)
    d3dc:	e59f3150 	ldr	r3, [pc, #336]	; d534 <thread_suspend+0x254>
    d3e0:	e1500003 	cmp	r0, r3
    d3e4:	0a000017 	beq	d448 <thread_suspend+0x168>

            if (result != DNA_ERROR)
            {
dna_log(VERBOSE_LEVEL, "Local WAIT suspend %d.", thread -> id);

              queue_extract (queue, thread);
    d3e8:	e1a0100b 	mov	r1, fp
    d3ec:	e1a00006 	mov	r0, r6
    d3f0:	ebffed1a 	bl	8860 <queue_extract>
              lock_release (& queue -> lock);
    d3f4:	e1a00006 	mov	r0, r6
    d3f8:	ebfffdbd 	bl	caf4 <lock_release>

              thread -> info . status = DNA_THREAD_SUSPENDED;
    d3fc:	e59f3134 	ldr	r3, [pc, #308]	; d538 <thread_suspend+0x258>
    d400:	e1c535b8 	strh	r3, [r5, #88]	; 0x58
              restart_stabilization_loop = false;
            }

            lock_release (& thread -> lock);
    d404:	e1a00007 	mov	r0, r7
    d408:	ebfffdb9 	bl	caf4 <lock_release>
dna_log(PANIC_LEVEL, "Unknown thread status.");
            break;
          }
      }
    }
    while (restart_stabilization_loop);
    d40c:	e3580000 	cmp	r8, #0
    d410:	1affffcc 	bne	d348 <thread_suspend+0x68>
    d414:	ea00001f 	b	d498 <thread_suspend+0x1b8>

      /*
       * Discriminate in function of its status.
       */

      switch (thread -> info . status)
    d418:	e59f211c 	ldr	r2, [pc, #284]	; d53c <thread_suspend+0x25c>
    d41c:	e1530002 	cmp	r3, r2
    d420:	1affffc8 	bne	d348 <thread_suspend+0x68>
            break;
          }

        case DNA_THREAD_WAITING :
          {
            queue = thread -> resource_queue;
    d424:	e5956020 	ldr	r6, [r5, #32]
            /*
             * Apply the banker's algorithm to lock both the thread
             * and the resource queue.
             */

            check (thread_error, queue != NULL, DNA_ERROR);
    d428:	e3560000 	cmp	r6, #0
    d42c:	0a000022 	beq	d4bc <thread_suspend+0x1dc>
            result = lock_try (& queue -> lock, true);
    d430:	e1a00006 	mov	r0, r6
    d434:	e3a01001 	mov	r1, #1
    d438:	ebfff61b 	bl	acac <lock_try>

            if (result != DNA_ERROR)
    d43c:	e59f30f0 	ldr	r3, [pc, #240]	; d534 <thread_suspend+0x254>
    d440:	e1500003 	cmp	r0, r3
    d444:	1affffe7 	bne	d3e8 <thread_suspend+0x108>
    d448:	e3a08001 	mov	r8, #1
    d44c:	eaffffec 	b	d404 <thread_suspend+0x124>

      switch (thread -> info . status)
      {
        case DNA_THREAD_RUNNING :
          {
            if (thread -> info . cpu_id == current_cpuid)
    d450:	e5954048 	ldr	r4, [r5, #72]	; 0x48
    d454:	e59d3000 	ldr	r3, [sp]
    d458:	e1530004 	cmp	r3, r4
    d45c:	1a000021 	bne	d4e8 <thread_suspend+0x208>
            {
dna_log(VERBOSE_LEVEL, "Local RUN suspend 0x%x.", thread -> id);

              thread -> info . status = DNA_THREAD_SUSPENDED;
    d460:	e59f30d0 	ldr	r3, [pc, #208]	; d538 <thread_suspend+0x258>

              status = scheduler_elect (& target, true);
    d464:	e28d000c 	add	r0, sp, #12
          {
            if (thread -> info . cpu_id == current_cpuid)
            {
dna_log(VERBOSE_LEVEL, "Local RUN suspend 0x%x.", thread -> id);

              thread -> info . status = DNA_THREAD_SUSPENDED;
    d468:	e1cc30b0 	strh	r3, [ip]

              status = scheduler_elect (& target, true);
    d46c:	e3a01001 	mov	r1, #1
    d470:	ebfffa0e 	bl	bcb0 <scheduler_elect>
              check (thread_error, status != DNA_BAD_ARGUMENT, status);
    d474:	e59f3098 	ldr	r3, [pc, #152]	; d514 <thread_suspend+0x234>
            {
dna_log(VERBOSE_LEVEL, "Local RUN suspend 0x%x.", thread -> id);

              thread -> info . status = DNA_THREAD_SUSPENDED;

              status = scheduler_elect (& target, true);
    d478:	e1a04000 	mov	r4, r0
              check (thread_error, status != DNA_BAD_ARGUMENT, status);
    d47c:	e1500003 	cmp	r0, r3
    d480:	0a00000e 	beq	d4c0 <thread_suspend+0x1e0>

              status = scheduler_switch (target, NULL);
    d484:	e1a01008 	mov	r1, r8
    d488:	e59d000c 	ldr	r0, [sp, #12]
    d48c:	ebfffc0d 	bl	c4c8 <scheduler_switch>
              check (thread_error, status == DNA_OK, status);
    d490:	e2504000 	subs	r4, r0, #0
    d494:	1a000009 	bne	d4c0 <thread_suspend+0x1e0>
          }
      }
    }
    while (restart_stabilization_loop);

    cpu_trap_restore (it_status);
    d498:	e59d0004 	ldr	r0, [sp, #4]
    d49c:	ebfff1d0 	bl	9be4 <cpu_trap_restore>
    return DNA_OK;
    d4a0:	e3a00000 	mov	r0, #0
    d4a4:	eaffff96 	b	d304 <thread_suspend+0x24>
            /*
             * We don't cancel the alarm here, thread_snooze uses
             * alarm_destroy to check wether the alarm has fired or not.
             */

            thread -> info . status = DNA_THREAD_SUSPENDED;
    d4a8:	e59f3088 	ldr	r3, [pc, #136]	; d538 <thread_suspend+0x258>
            lock_release (& thread -> lock);
    d4ac:	e1a00007 	mov	r0, r7
            /*
             * We don't cancel the alarm here, thread_snooze uses
             * alarm_destroy to check wether the alarm has fired or not.
             */

            thread -> info . status = DNA_THREAD_SUSPENDED;
    d4b0:	e1cc30b0 	strh	r3, [ip]
            lock_release (& thread -> lock);
    d4b4:	ebfffd8e 	bl	caf4 <lock_release>

            restart_stabilization_loop = false;
            break;
    d4b8:	eafffff6 	b	d498 <thread_suspend+0x1b8>
       */

      lock_acquire (& thread -> lock);
      lock_release (& thread_pool . lock);

      check (thread_error,
    d4bc:	e59f4070 	ldr	r4, [pc, #112]	; d534 <thread_suspend+0x254>
    return DNA_OK;
  }

  rescue (thread_error)
  {
    lock_release (& thread -> lock);
    d4c0:	e1a00007 	mov	r0, r7
    d4c4:	ebfffd8a 	bl	caf4 <lock_release>
  }

  rescue (bad_thread)
  {
    lock_release (& thread_pool . lock);
    d4c8:	e59f0048 	ldr	r0, [pc, #72]	; d518 <thread_suspend+0x238>
    d4cc:	ebfffd88 	bl	caf4 <lock_release>
    cpu_trap_restore (it_status);
    d4d0:	e59d0004 	ldr	r0, [sp, #4]
    d4d4:	ebfff1c2 	bl	9be4 <cpu_trap_restore>
    leave;
    d4d8:	e1a00004 	mov	r0, r4
    d4dc:	eaffff88 	b	d304 <thread_suspend+0x24>
    do
    {
      lock_acquire (& thread_pool . lock);
      thread = & thread_pool . data[tid . s . group][tid . s . index];

      check (bad_thread, thread != NULL &&
    d4e0:	e59f4058 	ldr	r4, [pc, #88]	; d540 <thread_suspend+0x260>
    d4e4:	eafffff7 	b	d4c8 <thread_suspend+0x1e8>
            {
dna_log(VERBOSE_LEVEL, "Remote suspend %d on %d.",
                  thread -> id, thread -> info . cpu_id);

              next_cpuid = thread -> info . cpu_id;
              lock_release (& thread -> lock);
    d4e8:	e1a00007 	mov	r0, r7
    d4ec:	ebfffd80 	bl	caf4 <lock_release>

              lock_acquire (& cpu_pool . cpu[next_cpuid] . ipi_lock);
    d4f0:	e59f304c 	ldr	r3, [pc, #76]	; d544 <thread_suspend+0x264>
    d4f4:	e0840184 	add	r0, r4, r4, lsl #3
    d4f8:	e0830300 	add	r0, r3, r0, lsl #6
    d4fc:	ebfff2cb 	bl	a030 <lock_acquire>
              cpu_mp_send_ipi (next_cpuid, DNA_IPI_SUSPEND,
    d500:	e1a00004 	mov	r0, r4
    d504:	e5962004 	ldr	r2, [r6, #4]
    d508:	e59f1038 	ldr	r1, [pc, #56]	; d548 <thread_suspend+0x268>
    d50c:	ebfff18d 	bl	9b48 <cpu_mp_send_ipi>
    d510:	eaffffe0 	b	d498 <thread_suspend+0x1b8>
    d514:	0000fffc 	.word	0x0000fffc
    d518:	0007b040 	.word	0x0007b040
    d51c:	0000d15a 	.word	0x0000d15a
    d520:	0000dead 	.word	0x0000dead
    d524:	0000bedd 	.word	0x0000bedd
    d528:	0000beef 	.word	0x0000beef
    d52c:	0000face 	.word	0x0000face
    d530:	00080870 	.word	0x00080870
    d534:	0000ffff 	.word	0x0000ffff
    d538:	ffffd15a 	.word	0xffffd15a
    d53c:	0000b10c 	.word	0x0000b10c
    d540:	0000fcfe 	.word	0x0000fcfe
    d544:	0007e470 	.word	0x0007e470
    d548:	0000fffe 	.word	0x0000fffe

0000d54c <memory_stop>:
 */

{

  return DNA_NOT_IMPLEMENTED;
}
    d54c:	e59f0000 	ldr	r0, [pc]	; d554 <memory_stop+0x8>
    d550:	e12fff1e 	bx	lr
    d554:	0000fffe 	.word	0x0000fffe

0000d558 <kernel_region_destroy>:

  /*
   * Remove the region from the list of created regions
   */

  if (region -> next != NULL)
    d558:	e5903008 	ldr	r3, [r0, #8]
 * Always return DNA_OK.
 *
 * SOURCE
 */

{
    d55c:	e92d4030 	push	{r4, r5, lr}

  /*
   * Remove the region from the list of created regions
   */

  if (region -> next != NULL)
    d560:	e3530000 	cmp	r3, #0
  {
    region -> next -> prev = region -> prev;
    region -> next = NULL;
    d564:	13a02000 	movne	r2, #0
   * Remove the region from the list of created regions
   */

  if (region -> next != NULL)
  {
    region -> next -> prev = region -> prev;
    d568:	1590100c 	ldrne	r1, [r0, #12]
    d56c:	1583100c 	strne	r1, [r3, #12]
    region -> next = NULL;
  }

  if (region -> prev != NULL)
    d570:	e590300c 	ldr	r3, [r0, #12]
   */

  if (region -> next != NULL)
  {
    region -> next -> prev = region -> prev;
    region -> next = NULL;
    d574:	15802008 	strne	r2, [r0, #8]
  }

  if (region -> prev != NULL)
    d578:	e3530000 	cmp	r3, #0
  {
    region -> prev -> next = region -> next;
    d57c:	13a02000 	movne	r2, #0
    region -> prev = NULL;
  }
  else
  {
    kernel_allocator . next_created_region = region -> next;
    d580:	059f4168 	ldreq	r4, [pc, #360]	; d6f0 <kernel_region_destroy+0x198>
    d584:	159f4164 	ldrne	r4, [pc, #356]	; d6f0 <kernel_region_destroy+0x198>
    region -> next = NULL;
  }

  if (region -> prev != NULL)
  {
    region -> prev -> next = region -> next;
    d588:	15832008 	strne	r2, [r3, #8]
    region -> prev = NULL;
  }
  else
  {
    kernel_allocator . next_created_region = region -> next;
    d58c:	05843004 	streq	r3, [r4, #4]

  /*
   * Add the region as a free region
   */

  ptr = kernel_allocator . next_free_region;
    d590:	e5943008 	ldr	r3, [r4, #8]
  }

  if (region -> prev != NULL)
  {
    region -> prev -> next = region -> next;
    region -> prev = NULL;
    d594:	1580200c 	strne	r2, [r0, #12]

  /*
   * Add the region as a free region
   */

  ptr = kernel_allocator . next_free_region;
    d598:	e59f2150 	ldr	r2, [pc, #336]	; d6f0 <kernel_region_destroy+0x198>

  if (ptr == NULL) kernel_allocator . next_free_region = region;
    d59c:	e3530000 	cmp	r3, #0
    d5a0:	05820008 	streq	r0, [r2, #8]
    d5a4:	0a000020 	beq	d62c <kernel_region_destroy+0xd4>
  else {
    vregion = (uint32_t)region;
    d5a8:	e1a0e000 	mov	lr, r0
    vrsize = region -> nblocks * DNA_KERNEL_BLOCK_SIZE;
    d5ac:	e1a05003 	mov	r5, r3
    d5b0:	e590c000 	ldr	ip, [r0]

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
        else kernel_allocator . next_free_region = ptr -> next;
        if (ptr -> next != NULL) ptr -> next -> prev = ptr -> prev;
      }
      else if (vregion + vrsize == vptr) {
    d5b4:	e080c28c 	add	ip, r0, ip, lsl #5
     * with connexes regions
     */

    while (ptr != NULL) {
      vptr = (uint32_t)ptr;
      vpsize = ptr -> nblocks * DNA_KERNEL_BLOCK_SIZE;
    d5b8:	e5932000 	ldr	r2, [r3]

      if (vptr + vpsize == vregion) {
    d5bc:	e0831282 	add	r1, r3, r2, lsl #5
    d5c0:	e151000e 	cmp	r1, lr
    d5c4:	0a00001a 	beq	d634 <kernel_region_destroy+0xdc>

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
        else kernel_allocator . next_free_region = ptr -> next;
        if (ptr -> next != NULL) ptr -> next -> prev = ptr -> prev;
      }
      else if (vregion + vrsize == vptr) {
    d5c8:	e15c0003 	cmp	ip, r3
    d5cc:	0a000028 	beq	d674 <kernel_region_destroy+0x11c>
    d5d0:	e5933008 	ldr	r3, [r3, #8]
    /*
     * First, we increase the new region size
     * with connexes regions
     */

    while (ptr != NULL) {
    d5d4:	e3530000 	cmp	r3, #0
    d5d8:	1afffff6 	bne	d5b8 <kernel_region_destroy+0x60>
    d5dc:	e1a03000 	mov	r3, r0
    d5e0:	e1a02005 	mov	r2, r5
    d5e4:	e5845008 	str	r5, [r4, #8]
     * Then, we order it in term of worst fit.
     * This way, alloc only take the first in the list.
     */

    ptr = kernel_allocator . next_free_region;
    if (ptr == NULL) {
    d5e8:	e3520000 	cmp	r2, #0
    /*
     * Then, we order it in term of worst fit.
     * This way, alloc only take the first in the list.
     */

    ptr = kernel_allocator . next_free_region;
    d5ec:	e59f10fc 	ldr	r1, [pc, #252]	; d6f0 <kernel_region_destroy+0x198>
    if (ptr == NULL) {
    d5f0:	0a00003a 	beq	d6e0 <kernel_region_destroy+0x188>
    d5f4:	e593c000 	ldr	ip, [r3]
    d5f8:	ea000002 	b	d608 <kernel_region_destroy+0xb0>
      region -> next = NULL;
      kernel_allocator . next_free_region = region;
    }
    else {
      while (ptr -> next != NULL) {
        if (ptr -> nblocks <= region -> nblocks)  break;
    d5fc:	e150000c 	cmp	r0, ip
    d600:	da000029 	ble	d6ac <kernel_region_destroy+0x154>
        ptr = ptr -> next;
    d604:	e1a02001 	mov	r2, r1
      region -> prev = NULL;
      region -> next = NULL;
      kernel_allocator . next_free_region = region;
    }
    else {
      while (ptr -> next != NULL) {
    d608:	e5921008 	ldr	r1, [r2, #8]
        if (ptr -> nblocks <= region -> nblocks)  break;
    d60c:	e5920000 	ldr	r0, [r2]
      region -> prev = NULL;
      region -> next = NULL;
      kernel_allocator . next_free_region = region;
    }
    else {
      while (ptr -> next != NULL) {
    d610:	e3510000 	cmp	r1, #0
    d614:	1afffff8 	bne	d5fc <kernel_region_destroy+0xa4>
        if (ptr -> nblocks <= region -> nblocks)  break;
        ptr = ptr -> next;
      }
      
      if (ptr -> nblocks <= region -> nblocks) {
    d618:	e150000c 	cmp	r0, ip
        if (ptr -> prev != NULL) ptr -> prev -> next = region;
        else kernel_allocator . next_free_region = region;
        ptr -> prev = region;
      }
      else {
        ptr -> next = region;
    d61c:	c5823008 	strgt	r3, [r2, #8]
        region -> prev = ptr;
    d620:	c583200c 	strgt	r2, [r3, #12]
        region -> next = NULL;
    d624:	c5831008 	strgt	r1, [r3, #8]
      while (ptr -> next != NULL) {
        if (ptr -> nblocks <= region -> nblocks)  break;
        ptr = ptr -> next;
      }
      
      if (ptr -> nblocks <= region -> nblocks) {
    d628:	da00001f 	ble	d6ac <kernel_region_destroy+0x154>
      }
    }
  }  

  return DNA_OK;
}
    d62c:	e3a00000 	mov	r0, #0
    d630:	e8bd8030 	pop	{r4, r5, pc}

      if (vptr + vpsize == vregion) {
        ptr -> nblocks += region -> nblocks;
        region = ptr;

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
    d634:	e593100c 	ldr	r1, [r3, #12]
    while (ptr != NULL) {
      vptr = (uint32_t)ptr;
      vpsize = ptr -> nblocks * DNA_KERNEL_BLOCK_SIZE;

      if (vptr + vpsize == vregion) {
        ptr -> nblocks += region -> nblocks;
    d638:	e5900000 	ldr	r0, [r0]
        region = ptr;

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
    d63c:	e3510000 	cmp	r1, #0
        else kernel_allocator . next_free_region = ptr -> next;
    d640:	05935008 	ldreq	r5, [r3, #8]
    while (ptr != NULL) {
      vptr = (uint32_t)ptr;
      vpsize = ptr -> nblocks * DNA_KERNEL_BLOCK_SIZE;

      if (vptr + vpsize == vregion) {
        ptr -> nblocks += region -> nblocks;
    d644:	e0822000 	add	r2, r2, r0
    d648:	e5832000 	str	r2, [r3]
        region = ptr;

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
        else kernel_allocator . next_free_region = ptr -> next;
    d64c:	01a02005 	moveq	r2, r5

      if (vptr + vpsize == vregion) {
        ptr -> nblocks += region -> nblocks;
        region = ptr;

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
    d650:	15932008 	ldrne	r2, [r3, #8]
    d654:	15812008 	strne	r2, [r1, #8]
    d658:	15932008 	ldrne	r2, [r3, #8]
        else kernel_allocator . next_free_region = ptr -> next;
        if (ptr -> next != NULL) ptr -> next -> prev = ptr -> prev;
    d65c:	e3520000 	cmp	r2, #0
    d660:	0a00001b 	beq	d6d4 <kernel_region_destroy+0x17c>
    d664:	e1a00003 	mov	r0, r3
    d668:	e582100c 	str	r1, [r2, #12]
    d66c:	e1a03002 	mov	r3, r2
    d670:	eaffffd0 	b	d5b8 <kernel_region_destroy+0x60>
      }
      else if (vregion + vrsize == vptr) {
        region -> nblocks += ptr -> nblocks;

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
    d674:	e59c300c 	ldr	r3, [ip, #12]
        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
        else kernel_allocator . next_free_region = ptr -> next;
        if (ptr -> next != NULL) ptr -> next -> prev = ptr -> prev;
      }
      else if (vregion + vrsize == vptr) {
        region -> nblocks += ptr -> nblocks;
    d678:	e5901000 	ldr	r1, [r0]

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
    d67c:	e3530000 	cmp	r3, #0
        else kernel_allocator . next_free_region = ptr -> next;
    d680:	059c5008 	ldreq	r5, [ip, #8]
        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
        else kernel_allocator . next_free_region = ptr -> next;
        if (ptr -> next != NULL) ptr -> next -> prev = ptr -> prev;
      }
      else if (vregion + vrsize == vptr) {
        region -> nblocks += ptr -> nblocks;
    d684:	e0812002 	add	r2, r1, r2
    d688:	e5802000 	str	r2, [r0]

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
        else kernel_allocator . next_free_region = ptr -> next;
    d68c:	01a02005 	moveq	r2, r5
        if (ptr -> next != NULL) ptr -> next -> prev = ptr -> prev;
      }
      else if (vregion + vrsize == vptr) {
        region -> nblocks += ptr -> nblocks;

        if (ptr -> prev != NULL) ptr -> prev -> next = ptr -> next;
    d690:	159c2008 	ldrne	r2, [ip, #8]
    d694:	15832008 	strne	r2, [r3, #8]
    d698:	159c2008 	ldrne	r2, [ip, #8]
        else kernel_allocator . next_free_region = ptr -> next;
        if (ptr -> next != NULL) ptr -> next -> prev = ptr -> prev;
    d69c:	e3520000 	cmp	r2, #0
    d6a0:	0affffcd 	beq	d5dc <kernel_region_destroy+0x84>
    d6a4:	e582300c 	str	r3, [r2, #12]
    d6a8:	eaffffef 	b	d66c <kernel_region_destroy+0x114>
        if (ptr -> nblocks <= region -> nblocks)  break;
        ptr = ptr -> next;
      }
      
      if (ptr -> nblocks <= region -> nblocks) {
        region -> prev = ptr -> prev;
    d6ac:	e592100c 	ldr	r1, [r2, #12]
      }
    }
  }  

  return DNA_OK;
}
    d6b0:	e3a00000 	mov	r0, #0
        if (ptr -> nblocks <= region -> nblocks)  break;
        ptr = ptr -> next;
      }
      
      if (ptr -> nblocks <= region -> nblocks) {
        region -> prev = ptr -> prev;
    d6b4:	e583100c 	str	r1, [r3, #12]
        region -> next = ptr;

        if (ptr -> prev != NULL) ptr -> prev -> next = region;
    d6b8:	e592100c 	ldr	r1, [r2, #12]
        ptr = ptr -> next;
      }
      
      if (ptr -> nblocks <= region -> nblocks) {
        region -> prev = ptr -> prev;
        region -> next = ptr;
    d6bc:	e5832008 	str	r2, [r3, #8]

        if (ptr -> prev != NULL) ptr -> prev -> next = region;
    d6c0:	e3510000 	cmp	r1, #0
    d6c4:	15813008 	strne	r3, [r1, #8]
        else kernel_allocator . next_free_region = region;
    d6c8:	05843008 	streq	r3, [r4, #8]
        ptr -> prev = region;
    d6cc:	e582300c 	str	r3, [r2, #12]
      }
    }
  }  

  return DNA_OK;
}
    d6d0:	e8bd8030 	pop	{r4, r5, pc}
    d6d4:	e5845008 	str	r5, [r4, #8]
    d6d8:	e1a02005 	mov	r2, r5
    d6dc:	eaffffc1 	b	d5e8 <kernel_region_destroy+0x90>
     */

    ptr = kernel_allocator . next_free_region;
    if (ptr == NULL) {
      region -> prev = NULL;
      region -> next = NULL;
    d6e0:	e5832008 	str	r2, [r3, #8]
     * This way, alloc only take the first in the list.
     */

    ptr = kernel_allocator . next_free_region;
    if (ptr == NULL) {
      region -> prev = NULL;
    d6e4:	e583200c 	str	r2, [r3, #12]
      region -> next = NULL;
      kernel_allocator . next_free_region = region;
    d6e8:	e5813008 	str	r3, [r1, #8]
    d6ec:	eaffffce 	b	d62c <kernel_region_destroy+0xd4>
    d6f0:	000819a0 	.word	0x000819a0

0000d6f4 <kernel_malloc>:
 * * NULL in case of failure.
 *
 * SOURCE
 */

{
    d6f4:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
  uint8_t * area = NULL;
  kernel_region_t region = NULL;
    d6f8:	e3a05000 	mov	r5, #0
 * * NULL in case of failure.
 *
 * SOURCE
 */

{
    d6fc:	e24dd008 	sub	sp, sp, #8
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (void *)
  {
    check (invalid_argument, size != 0, NULL);
    d700:	e3500000 	cmp	r0, #0
 * SOURCE
 */

{
  uint8_t * area = NULL;
  kernel_region_t region = NULL;
    d704:	e58d5004 	str	r5, [sp, #4]
  status_t status = DNA_OK;
  interrupt_status_t it_status = 0;

  watch (void *)
  {
    check (invalid_argument, size != 0, NULL);
    d708:	0a00001b 	beq	d77c <kernel_malloc+0x88>

    nblocks = size / DNA_KERNEL_BLOCK_SIZE;
    d70c:	e1a032a0 	lsr	r3, r0, #5
    nblocks += (((size - nblocks * DNA_KERNEL_BLOCK_SIZE) != 0) ? 1 : 0) + 1;
    d710:	e1500283 	cmp	r0, r3, lsl #5
    d714:	13a08002 	movne	r8, #2
    d718:	03a08001 	moveq	r8, #1
    d71c:	e1a06001 	mov	r6, r1
    d720:	e0888003 	add	r8, r8, r3

    it_status = cpu_trap_mask_and_backup();
    d724:	ebfff0f5 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& kernel_allocator . lock);
    d728:	e59f4094 	ldr	r4, [pc, #148]	; d7c4 <kernel_malloc+0xd0>
    check (invalid_argument, size != 0, NULL);

    nblocks = size / DNA_KERNEL_BLOCK_SIZE;
    nblocks += (((size - nblocks * DNA_KERNEL_BLOCK_SIZE) != 0) ? 1 : 0) + 1;

    it_status = cpu_trap_mask_and_backup();
    d72c:	e1a07000 	mov	r7, r0
    lock_acquire (& kernel_allocator . lock);
    d730:	e1a00004 	mov	r0, r4
    d734:	ebfff23d 	bl	a030 <lock_acquire>

    status = kernel_region_create (nblocks, & region);
    d738:	e1a00008 	mov	r0, r8
    d73c:	e28d1004 	add	r1, sp, #4
    d740:	eb00005f 	bl	d8c4 <kernel_region_create>
    check (create_failed, status == DNA_OK, NULL);   
    d744:	e2508000 	subs	r8, r0, #0
    d748:	1a000017 	bne	d7ac <kernel_malloc+0xb8>

    kernel_allocator . nblocks -= region -> nblocks;
    d74c:	e59d5004 	ldr	r5, [sp, #4]
    d750:	e514200c 	ldr	r2, [r4, #-12]
    d754:	e4953020 	ldr	r3, [r5], #32
    area = (uint8_t *)(region) + DNA_KERNEL_BLOCK_SIZE;

    lock_release (& kernel_allocator . lock);
    d758:	e1a00004 	mov	r0, r4
    lock_acquire (& kernel_allocator . lock);

    status = kernel_region_create (nblocks, & region);
    check (create_failed, status == DNA_OK, NULL);   

    kernel_allocator . nblocks -= region -> nblocks;
    d75c:	e0633002 	rsb	r3, r3, r2
    d760:	e504300c 	str	r3, [r4, #-12]
    area = (uint8_t *)(region) + DNA_KERNEL_BLOCK_SIZE;

    lock_release (& kernel_allocator . lock);
    d764:	ebfffce2 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    d768:	e1a00007 	mov	r0, r7
    d76c:	ebfff11c 	bl	9be4 <cpu_trap_restore>

    if (erase) dna_memset (area, 0,
    d770:	e3560000 	cmp	r6, #0
        DNA_KERNEL_BLOCK_SIZE * (region -> nblocks - 1));

    return (void *)area;
    d774:	01a00005 	moveq	r0, r5
    area = (uint8_t *)(region) + DNA_KERNEL_BLOCK_SIZE;

    lock_release (& kernel_allocator . lock);
    cpu_trap_restore(it_status);

    if (erase) dna_memset (area, 0,
    d778:	1a000001 	bne	d784 <kernel_malloc+0x90>

  rescue (invalid_argument)
  {
    leave;
  }
}
    d77c:	e28dd008 	add	sp, sp, #8
    d780:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

    lock_release (& kernel_allocator . lock);
    cpu_trap_restore(it_status);

    if (erase) dna_memset (area, 0,
        DNA_KERNEL_BLOCK_SIZE * (region -> nblocks - 1));
    d784:	e59d3004 	ldr	r3, [sp, #4]
    area = (uint8_t *)(region) + DNA_KERNEL_BLOCK_SIZE;

    lock_release (& kernel_allocator . lock);
    cpu_trap_restore(it_status);

    if (erase) dna_memset (area, 0,
    d788:	e1a01008 	mov	r1, r8
        DNA_KERNEL_BLOCK_SIZE * (region -> nblocks - 1));
    d78c:	e5932000 	ldr	r2, [r3]
    area = (uint8_t *)(region) + DNA_KERNEL_BLOCK_SIZE;

    lock_release (& kernel_allocator . lock);
    cpu_trap_restore(it_status);

    if (erase) dna_memset (area, 0,
    d790:	e1a00005 	mov	r0, r5
        DNA_KERNEL_BLOCK_SIZE * (region -> nblocks - 1));
    d794:	e2422001 	sub	r2, r2, #1
    area = (uint8_t *)(region) + DNA_KERNEL_BLOCK_SIZE;

    lock_release (& kernel_allocator . lock);
    cpu_trap_restore(it_status);

    if (erase) dna_memset (area, 0,
    d798:	e1a02282 	lsl	r2, r2, #5
    d79c:	ebffecd0 	bl	8ae4 <dna_memset>
        DNA_KERNEL_BLOCK_SIZE * (region -> nblocks - 1));

    return (void *)area;
    d7a0:	e1a00005 	mov	r0, r5

  rescue (invalid_argument)
  {
    leave;
  }
}
    d7a4:	e28dd008 	add	sp, sp, #8
    d7a8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
    return (void *)area;
  }

  rescue (create_failed)
  {
    lock_release (& kernel_allocator . lock);
    d7ac:	e1a00004 	mov	r0, r4
    d7b0:	ebfffccf 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    d7b4:	e1a00007 	mov	r0, r7
    d7b8:	ebfff109 	bl	9be4 <cpu_trap_restore>
  }

  rescue (invalid_argument)
  {
    leave;
    d7bc:	e1a00005 	mov	r0, r5
    d7c0:	eaffffed 	b	d77c <kernel_malloc+0x88>
    d7c4:	000819ac 	.word	0x000819ac

0000d7c8 <kernel_free>:
  int32_t region_nblocks;
  interrupt_status_t it_status = 0;

  watch (status_t)
  {
    check (invalid_argument, area != NULL, DNA_ERROR);
    d7c8:	e3500000 	cmp	r0, #0
    d7cc:	0a000015 	beq	d828 <kernel_free+0x60>

    region = (kernel_region_t)((uint32_t)area - DNA_KERNEL_BLOCK_SIZE);
    region -> status = DNA_KERNEL_FREE_REGION;
    d7d0:	e59f2058 	ldr	r2, [pc, #88]	; d830 <kernel_free+0x68>
 * * DNA_OK if the operation succeeded.
 *
 * SOURCE
 */

{
    d7d4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
  watch (status_t)
  {
    check (invalid_argument, area != NULL, DNA_ERROR);

    region = (kernel_region_t)((uint32_t)area - DNA_KERNEL_BLOCK_SIZE);
    region -> status = DNA_KERNEL_FREE_REGION;
    d7d8:	e500201c 	str	r2, [r0, #-28]
    region_nblocks = region -> nblocks;
    d7dc:	e5107020 	ldr	r7, [r0, #-32]

  watch (status_t)
  {
    check (invalid_argument, area != NULL, DNA_ERROR);

    region = (kernel_region_t)((uint32_t)area - DNA_KERNEL_BLOCK_SIZE);
    d7e0:	e2405020 	sub	r5, r0, #32
    region -> status = DNA_KERNEL_FREE_REGION;
    region_nblocks = region -> nblocks;

    it_status = cpu_trap_mask_and_backup();
    d7e4:	ebfff0c5 	bl	9b00 <cpu_trap_mask_and_backup>
    lock_acquire (& kernel_allocator . lock);
    d7e8:	e59f4044 	ldr	r4, [pc, #68]	; d834 <kernel_free+0x6c>

    region = (kernel_region_t)((uint32_t)area - DNA_KERNEL_BLOCK_SIZE);
    region -> status = DNA_KERNEL_FREE_REGION;
    region_nblocks = region -> nblocks;

    it_status = cpu_trap_mask_and_backup();
    d7ec:	e1a06000 	mov	r6, r0
    lock_acquire (& kernel_allocator . lock);
    d7f0:	e1a00004 	mov	r0, r4
    d7f4:	ebfff20d 	bl	a030 <lock_acquire>

    status = kernel_region_destroy (region);
    d7f8:	e1a00005 	mov	r0, r5
    d7fc:	ebffff55 	bl	d558 <kernel_region_destroy>
    if (status == DNA_OK) kernel_allocator . nblocks += region_nblocks;
    d800:	e2505000 	subs	r5, r0, #0
    d804:	0514300c 	ldreq	r3, [r4, #-12]

    lock_release (& kernel_allocator . lock);
    d808:	e59f0024 	ldr	r0, [pc, #36]	; d834 <kernel_free+0x6c>

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& kernel_allocator . lock);

    status = kernel_region_destroy (region);
    if (status == DNA_OK) kernel_allocator . nblocks += region_nblocks;
    d80c:	00837007 	addeq	r7, r3, r7
    d810:	0504700c 	streq	r7, [r4, #-12]

    lock_release (& kernel_allocator . lock);
    d814:	ebfffcb6 	bl	caf4 <lock_release>
    cpu_trap_restore(it_status);
    d818:	e1a00006 	mov	r0, r6
    d81c:	ebfff0f0 	bl	9be4 <cpu_trap_restore>
    region_nblocks = region -> nblocks;

    it_status = cpu_trap_mask_and_backup();
    lock_acquire (& kernel_allocator . lock);

    status = kernel_region_destroy (region);
    d820:	e1a00005 	mov	r0, r5
    if (status == DNA_OK) kernel_allocator . nblocks += region_nblocks;

    lock_release (& kernel_allocator . lock);
    cpu_trap_restore(it_status);

    return status;
    d824:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
  }

  rescue (invalid_argument)
  {
    leave;
    d828:	e59f0008 	ldr	r0, [pc, #8]	; d838 <kernel_free+0x70>
    d82c:	e12fff1e 	bx	lr
    d830:	0000beef 	.word	0x0000beef
    d834:	000819ac 	.word	0x000819ac
    d838:	0000ffff 	.word	0x0000ffff

0000d83c <memory_destroy>:
 */

{

  return DNA_NOT_IMPLEMENTED;
}
    d83c:	e59f0000 	ldr	r0, [pc]	; d844 <memory_destroy+0x8>
    d840:	e12fff1e 	bx	lr
    d844:	0000fffe 	.word	0x0000fffe

0000d848 <memory_create>:
 * - Initializes the kernel allocator.
 *
 * SOURCE
 */

{
    d848:	e92d4008 	push	{r3, lr}

  /*
   * Initializes the BSS to 0
   */

  bss_size = (size_t) (CPU_BSS_END - CPU_BSS_START);
    d84c:	e59f2058 	ldr	r2, [pc, #88]	; d8ac <memory_create+0x64>
    d850:	e59f3058 	ldr	r3, [pc, #88]	; d8b0 <memory_create+0x68>
    d854:	e5920000 	ldr	r0, [r2]
    d858:	e5932000 	ldr	r2, [r3]
  dna_memset ((void *) CPU_BSS_START, 0, bss_size);
    d85c:	e3a01000 	mov	r1, #0
    d860:	e0602002 	rsb	r2, r0, r2
    d864:	ebffec9e 	bl	8ae4 <dna_memset>
   */

  heap_size = OS_KERNEL_HEAP_SIZE / DNA_KERNEL_BLOCK_SIZE;

  region = (kernel_region_t) OS_KERNEL_HEAP_ADDRESS;
  region -> next = NULL;
    d868:	e3a00000 	mov	r0, #0

  /*
   * Initializes the kernel allocator
   */

  heap_size = OS_KERNEL_HEAP_SIZE / DNA_KERNEL_BLOCK_SIZE;
    d86c:	e59f2040 	ldr	r2, [pc, #64]	; d8b4 <memory_create+0x6c>

  region = (kernel_region_t) OS_KERNEL_HEAP_ADDRESS;
    d870:	e59f3040 	ldr	r3, [pc, #64]	; d8b8 <memory_create+0x70>

  /*
   * Initializes the kernel allocator
   */

  heap_size = OS_KERNEL_HEAP_SIZE / DNA_KERNEL_BLOCK_SIZE;
    d874:	e5921000 	ldr	r1, [r2]

  region = (kernel_region_t) OS_KERNEL_HEAP_ADDRESS;
    d878:	e5933000 	ldr	r3, [r3]
  region -> next = NULL;
  region -> prev = NULL;
  region -> nblocks = heap_size - 1;
  region -> status = DNA_KERNEL_FREE_REGION;

  kernel_allocator . next_free_region = region;
    d87c:	e59f2038 	ldr	r2, [pc, #56]	; d8bc <memory_create+0x74>

  /*
   * Initializes the kernel allocator
   */

  heap_size = OS_KERNEL_HEAP_SIZE / DNA_KERNEL_BLOCK_SIZE;
    d880:	e1a012a1 	lsr	r1, r1, #5

  region = (kernel_region_t) OS_KERNEL_HEAP_ADDRESS;
  region -> next = NULL;
  region -> prev = NULL;
  region -> nblocks = heap_size - 1;
  region -> status = DNA_KERNEL_FREE_REGION;
    d884:	e59fc034 	ldr	ip, [pc, #52]	; d8c0 <memory_create+0x78>
  heap_size = OS_KERNEL_HEAP_SIZE / DNA_KERNEL_BLOCK_SIZE;

  region = (kernel_region_t) OS_KERNEL_HEAP_ADDRESS;
  region -> next = NULL;
  region -> prev = NULL;
  region -> nblocks = heap_size - 1;
    d888:	e241e001 	sub	lr, r1, #1
    d88c:	e583e000 	str	lr, [r3]
  region -> status = DNA_KERNEL_FREE_REGION;
    d890:	e583c004 	str	ip, [r3, #4]
   */

  heap_size = OS_KERNEL_HEAP_SIZE / DNA_KERNEL_BLOCK_SIZE;

  region = (kernel_region_t) OS_KERNEL_HEAP_ADDRESS;
  region -> next = NULL;
    d894:	e5830008 	str	r0, [r3, #8]
  region -> prev = NULL;
    d898:	e583000c 	str	r0, [r3, #12]
  region -> nblocks = heap_size - 1;
  region -> status = DNA_KERNEL_FREE_REGION;

  kernel_allocator . next_free_region = region;
  kernel_allocator . next_created_region = NULL;
  kernel_allocator . nblocks = heap_size;
    d89c:	e5821000 	str	r1, [r2]
  region -> prev = NULL;
  region -> nblocks = heap_size - 1;
  region -> status = DNA_KERNEL_FREE_REGION;

  kernel_allocator . next_free_region = region;
  kernel_allocator . next_created_region = NULL;
    d8a0:	e9820009 	stmib	r2, {r0, r3}
  kernel_allocator . nblocks = heap_size;
  kernel_allocator . lock = 0;
    d8a4:	e582000c 	str	r0, [r2, #12]

  return DNA_OK;
}
    d8a8:	e8bd8008 	pop	{r3, pc}
    d8ac:	0002550c 	.word	0x0002550c
    d8b0:	00025510 	.word	0x00025510
    d8b4:	000254f8 	.word	0x000254f8
    d8b8:	000254f0 	.word	0x000254f0
    d8bc:	000819a0 	.word	0x000819a0
    d8c0:	0000beef 	.word	0x0000beef

0000d8c4 <kernel_region_create>:
 * of the memory, NULL otherwise.
 *
 * SOURCE
 */

{
    d8c4:	e92d40f0 	push	{r4, r5, r6, r7, lr}
  kernel_region_t current_region = kernel_allocator . next_free_region;
    d8c8:	e59f413c 	ldr	r4, [pc, #316]	; da0c <kernel_region_create+0x148>
    d8cc:	e594c008 	ldr	ip, [r4, #8]
  kernel_region_t next_region = NULL, rptr = NULL, aptr = NULL;

  watch (status_t)
  {
    check (error_state, current_region != NULL, DNA_ERROR);
    d8d0:	e35c0000 	cmp	ip, #0
    d8d4:	0a000033 	beq	d9a8 <kernel_region_create+0xe4>
    check (error_state, p_region != NULL, DNA_ERROR);
    d8d8:	e3510000 	cmp	r1, #0
    d8dc:	0a000031 	beq	d9a8 <kernel_region_create+0xe4>
    check (error_state, current_region -> nblocks > required_nblocks,
    d8e0:	e59c2000 	ldr	r2, [ip]
    d8e4:	e1520000 	cmp	r2, r0
    d8e8:	9a00002c 	bls	d9a0 <kernel_region_create+0xdc>

    /*
     * Allocate the new region
     */

    if (current_region -> next != NULL) current_region -> next -> prev = NULL;
    d8ec:	e59c3008 	ldr	r3, [ip, #8]
    d8f0:	e3530000 	cmp	r3, #0
    d8f4:	0a000036 	beq	d9d4 <kernel_region_create+0x110>
    d8f8:	e3a0e000 	mov	lr, #0
    kernel_allocator . next_free_region = current_region -> next;

    next_region = (kernel_region_t)((uint8_t *)current_region +
        (required_nblocks * DNA_KERNEL_BLOCK_SIZE));

    next_region -> status = DNA_KERNEL_FREE_REGION;
    d8fc:	e59f710c 	ldr	r7, [pc, #268]	; da10 <kernel_region_create+0x14c>
    next_region -> nblocks = current_region -> nblocks - required_nblocks;
    d900:	e0602002 	rsb	r2, r0, r2
     */

    if (current_region -> next != NULL) current_region -> next -> prev = NULL;
    kernel_allocator . next_free_region = current_region -> next;

    next_region = (kernel_region_t)((uint8_t *)current_region +
    d904:	e08c5280 	add	r5, ip, r0, lsl #5
    next_region -> status = DNA_KERNEL_FREE_REGION;
    next_region -> nblocks = current_region -> nblocks - required_nblocks;

    current_region -> prev = NULL;
    current_region -> next = NULL;
    current_region -> status = DNA_KERNEL_ALLOCATED_REGION;
    d908:	e59f6104 	ldr	r6, [pc, #260]	; da14 <kernel_region_create+0x150>

    /*
     * Allocate the new region
     */

    if (current_region -> next != NULL) current_region -> next -> prev = NULL;
    d90c:	e583e00c 	str	lr, [r3, #12]
    kernel_allocator . next_free_region = current_region -> next;
    d910:	e5843008 	str	r3, [r4, #8]

    next_region = (kernel_region_t)((uint8_t *)current_region +
        (required_nblocks * DNA_KERNEL_BLOCK_SIZE));

    next_region -> status = DNA_KERNEL_FREE_REGION;
    d914:	e5857004 	str	r7, [r5, #4]
    next_region -> nblocks = current_region -> nblocks - required_nblocks;
    d918:	e78c2280 	str	r2, [ip, r0, lsl #5]

    current_region -> prev = NULL;
    current_region -> next = NULL;
    current_region -> status = DNA_KERNEL_ALLOCATED_REGION;
    current_region -> nblocks = required_nblocks;
    d91c:	e58c0000 	str	r0, [ip]
        (required_nblocks * DNA_KERNEL_BLOCK_SIZE));

    next_region -> status = DNA_KERNEL_FREE_REGION;
    next_region -> nblocks = current_region -> nblocks - required_nblocks;

    current_region -> prev = NULL;
    d920:	e58ce00c 	str	lr, [ip, #12]
    current_region -> next = NULL;
    d924:	e58ce008 	str	lr, [ip, #8]
    d928:	e79ce280 	ldr	lr, [ip, r0, lsl #5]
    current_region -> status = DNA_KERNEL_ALLOCATED_REGION;
    d92c:	e58c6004 	str	r6, [ip, #4]
    d930:	ea000002 	b	d940 <kernel_region_create+0x7c>
    }
    else
    {
      while (rptr -> next != NULL)
      {
        if (rptr -> nblocks <= next_region -> nblocks) break;
    d934:	e150000e 	cmp	r0, lr
    d938:	da00001c 	ble	d9b0 <kernel_region_create+0xec>
        rptr = rptr -> next;
    d93c:	e1a03002 	mov	r3, r2
      next_region -> prev = NULL;
      next_region -> next = NULL;
    }
    else
    {
      while (rptr -> next != NULL)
    d940:	e5932008 	ldr	r2, [r3, #8]
      {
        if (rptr -> nblocks <= next_region -> nblocks) break;
    d944:	e5930000 	ldr	r0, [r3]
      next_region -> prev = NULL;
      next_region -> next = NULL;
    }
    else
    {
      while (rptr -> next != NULL)
    d948:	e3520000 	cmp	r2, #0
    d94c:	1afffff8 	bne	d934 <kernel_region_create+0x70>
      {
        if (rptr -> nblocks <= next_region -> nblocks) break;
        rptr = rptr -> next;
      }

      if (rptr -> nblocks <= next_region -> nblocks)
    d950:	e150000e 	cmp	r0, lr
          kernel_allocator . next_free_region = next_region;
        }
      }
      else
      {
        next_region -> next = NULL;
    d954:	c5852008 	strgt	r2, [r5, #8]
        next_region -> prev = rptr;
    d958:	c585300c 	strgt	r3, [r5, #12]
        rptr -> next = next_region;
    d95c:	c5835008 	strgt	r5, [r3, #8]
      {
        if (rptr -> nblocks <= next_region -> nblocks) break;
        rptr = rptr -> next;
      }

      if (rptr -> nblocks <= next_region -> nblocks)
    d960:	da000012 	ble	d9b0 <kernel_region_create+0xec>

    /*
     * Add the allocated region to the list of created regions
     */

    aptr = kernel_allocator . next_created_region;
    d964:	e5942004 	ldr	r2, [r4, #4]
    d968:	e59f309c 	ldr	r3, [pc, #156]	; da0c <kernel_region_create+0x148>

    if (aptr == NULL)
    d96c:	e3520000 	cmp	r2, #0
    {
      kernel_allocator . next_created_region = current_region;
    d970:	0583c004 	streq	ip, [r3, #4]
     * Add the allocated region to the list of created regions
     */

    aptr = kernel_allocator . next_created_region;

    if (aptr == NULL)
    d974:	1a000001 	bne	d980 <kernel_region_create+0xbc>
    d978:	ea000005 	b	d994 <kernel_region_create+0xd0>
    {
      kernel_allocator . next_created_region = current_region;
    }
    else
    {
      while (aptr -> next != NULL) aptr = aptr -> next;
    d97c:	e1a02003 	mov	r2, r3
    d980:	e5923008 	ldr	r3, [r2, #8]
    d984:	e3530000 	cmp	r3, #0
    d988:	1afffffb 	bne	d97c <kernel_region_create+0xb8>
      aptr -> next = current_region;
    d98c:	e582c008 	str	ip, [r2, #8]
      current_region -> prev = aptr;
    d990:	e58c200c 	str	r2, [ip, #12]
    }

    *p_region = current_region;
    d994:	e581c000 	str	ip, [r1]
    return DNA_OK;
    d998:	e3a00000 	mov	r0, #0
    d99c:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

  watch (status_t)
  {
    check (error_state, current_region != NULL, DNA_ERROR);
    check (error_state, p_region != NULL, DNA_ERROR);
    check (error_state, current_region -> nblocks > required_nblocks,
    d9a0:	e59f0070 	ldr	r0, [pc, #112]	; da18 <kernel_region_create+0x154>
    d9a4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
  kernel_region_t current_region = kernel_allocator . next_free_region;
  kernel_region_t next_region = NULL, rptr = NULL, aptr = NULL;

  watch (status_t)
  {
    check (error_state, current_region != NULL, DNA_ERROR);
    d9a8:	e59f006c 	ldr	r0, [pc, #108]	; da1c <kernel_region_create+0x158>
    d9ac:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
        rptr = rptr -> next;
      }

      if (rptr -> nblocks <= next_region -> nblocks)
      {
        next_region -> prev = rptr -> prev;
    d9b0:	e593200c 	ldr	r2, [r3, #12]
    d9b4:	e585200c 	str	r2, [r5, #12]
        rptr -> prev = next_region;
    d9b8:	e583500c 	str	r5, [r3, #12]
        next_region -> next = rptr;

        if (next_region -> prev != NULL)
    d9bc:	e595200c 	ldr	r2, [r5, #12]

      if (rptr -> nblocks <= next_region -> nblocks)
      {
        next_region -> prev = rptr -> prev;
        rptr -> prev = next_region;
        next_region -> next = rptr;
    d9c0:	e5853008 	str	r3, [r5, #8]

        if (next_region -> prev != NULL)
    d9c4:	e3520000 	cmp	r2, #0
        {
          next_region -> prev -> next = next_region;
    d9c8:	15825008 	strne	r5, [r2, #8]
        }
        else
        {
          kernel_allocator . next_free_region = next_region;
    d9cc:	05845008 	streq	r5, [r4, #8]
    d9d0:	eaffffe3 	b	d964 <kernel_region_create+0xa0>
    kernel_allocator . next_free_region = current_region -> next;

    next_region = (kernel_region_t)((uint8_t *)current_region +
        (required_nblocks * DNA_KERNEL_BLOCK_SIZE));

    next_region -> status = DNA_KERNEL_FREE_REGION;
    d9d4:	e59f6034 	ldr	r6, [pc, #52]	; da10 <kernel_region_create+0x14c>
    next_region -> nblocks = current_region -> nblocks - required_nblocks;

    current_region -> prev = NULL;
    current_region -> next = NULL;
    current_region -> status = DNA_KERNEL_ALLOCATED_REGION;
    d9d8:	e59f5034 	ldr	r5, [pc, #52]	; da14 <kernel_region_create+0x150>
     */

    if (current_region -> next != NULL) current_region -> next -> prev = NULL;
    kernel_allocator . next_free_region = current_region -> next;

    next_region = (kernel_region_t)((uint8_t *)current_region +
    d9dc:	e08ce280 	add	lr, ip, r0, lsl #5
        (required_nblocks * DNA_KERNEL_BLOCK_SIZE));

    next_region -> status = DNA_KERNEL_FREE_REGION;
    next_region -> nblocks = current_region -> nblocks - required_nblocks;
    d9e0:	e0602002 	rsb	r2, r0, r2
    kernel_allocator . next_free_region = current_region -> next;

    next_region = (kernel_region_t)((uint8_t *)current_region +
        (required_nblocks * DNA_KERNEL_BLOCK_SIZE));

    next_region -> status = DNA_KERNEL_FREE_REGION;
    d9e4:	e58e6004 	str	r6, [lr, #4]
    next_region -> nblocks = current_region -> nblocks - required_nblocks;
    d9e8:	e78c2280 	str	r2, [ip, r0, lsl #5]

    current_region -> prev = NULL;
    current_region -> next = NULL;
    d9ec:	e58c3008 	str	r3, [ip, #8]
    current_region -> status = DNA_KERNEL_ALLOCATED_REGION;
    current_region -> nblocks = required_nblocks;
    d9f0:	e58c0000 	str	r0, [ip]
    next_region -> status = DNA_KERNEL_FREE_REGION;
    next_region -> nblocks = current_region -> nblocks - required_nblocks;

    current_region -> prev = NULL;
    current_region -> next = NULL;
    current_region -> status = DNA_KERNEL_ALLOCATED_REGION;
    d9f4:	e58c5004 	str	r5, [ip, #4]
        (required_nblocks * DNA_KERNEL_BLOCK_SIZE));

    next_region -> status = DNA_KERNEL_FREE_REGION;
    next_region -> nblocks = current_region -> nblocks - required_nblocks;

    current_region -> prev = NULL;
    d9f8:	e58c300c 	str	r3, [ip, #12]

    rptr = kernel_allocator . next_free_region;

    if (rptr == NULL)
    {
      kernel_allocator . next_free_region = next_region;
    d9fc:	e584e008 	str	lr, [r4, #8]
      next_region -> prev = NULL;
    da00:	e58e300c 	str	r3, [lr, #12]
      next_region -> next = NULL;
    da04:	e58e3008 	str	r3, [lr, #8]
    da08:	eaffffd5 	b	d964 <kernel_region_create+0xa0>
    da0c:	000819a0 	.word	0x000819a0
    da10:	0000beef 	.word	0x0000beef
    da14:	0000dead 	.word	0x0000dead
    da18:	0000fffd 	.word	0x0000fffd
    da1c:	0000ffff 	.word	0x0000ffff

0000da20 <memory_start>:
 */

{

  return DNA_OK;
}
    da20:	e3a00000 	mov	r0, #0
    da24:	e12fff1e 	bx	lr

0000da28 <platform_debug_puts>:

void platform_debug_puts (char * string)
{
  char * p = string;

  while (*p != '\0')
    da28:	e5d03000 	ldrb	r3, [r0]
    da2c:	e3530000 	cmp	r3, #0
    da30:	012fff1e 	bxeq	lr
    da34:	e59f1014 	ldr	r1, [pc, #20]	; da50 <platform_debug_puts+0x28>
  {
    cpu_write (UINT8, PLATFORM_DEBUG_CHARPORT, *p++);
    da38:	e5912000 	ldr	r2, [r1]
    da3c:	e5c23000 	strb	r3, [r2]

void platform_debug_puts (char * string)
{
  char * p = string;

  while (*p != '\0')
    da40:	e5f03001 	ldrb	r3, [r0, #1]!
    da44:	e3530000 	cmp	r3, #0
    da48:	1afffffa 	bne	da38 <platform_debug_puts+0x10>
    da4c:	e12fff1e 	bx	lr
    da50:	00025500 	.word	0x00025500

0000da54 <system_kickstart>:
 * FUNCTION
 *
 * SOURCE
 */

{
    da54:	e92d4070 	push	{r4, r5, r6, lr}
  watch (status_t)
  {
    if (cpu_mp_id() == 0)
    da58:	ebfff07e 	bl	9c58 <cpu_mp_id>
    da5c:	e3500000 	cmp	r0, #0
    da60:	1a000018 	bne	dac8 <system_kickstart+0x74>

      /*
       * Create the components
       */

      status = memory_component . create ();
    da64:	e59f5070 	ldr	r5, [pc, #112]	; dadc <system_kickstart+0x88>
    da68:	e5953004 	ldr	r3, [r5, #4]
    da6c:	e12fff33 	blx	r3
      ensure (status == DNA_OK, status);
    da70:	e3500000 	cmp	r0, #0
    da74:	18bd8070 	popne	{r4, r5, r6, pc}

      status = core_component . create ();
    da78:	e59f4060 	ldr	r4, [pc, #96]	; dae0 <system_kickstart+0x8c>
    da7c:	e5943004 	ldr	r3, [r4, #4]
    da80:	e12fff33 	blx	r3
      ensure (status == DNA_OK, status);
    da84:	e3500000 	cmp	r0, #0
    da88:	18bd8070 	popne	{r4, r5, r6, pc}

      status = vfs_component . create ();
    da8c:	e59f6050 	ldr	r6, [pc, #80]	; dae4 <system_kickstart+0x90>
    da90:	e5963004 	ldr	r3, [r6, #4]
    da94:	e12fff33 	blx	r3
      ensure (status == DNA_OK, status);
    da98:	e3500000 	cmp	r0, #0
    da9c:	18bd8070 	popne	{r4, r5, r6, pc}
       * be in IDLE state to proceed correclty. TODO we should
       * probably find a way to wait ...
       */

      dna_log(INFO_LEVEL, "Starting DNA Operating System");
      cpu_mp_proceed ();
    daa0:	ebfff02f 	bl	9b64 <cpu_mp_proceed>

      status = memory_component . start ();
    daa4:	e595300c 	ldr	r3, [r5, #12]
    daa8:	e12fff33 	blx	r3
      ensure (status == DNA_OK, status);
    daac:	e3500000 	cmp	r0, #0
    dab0:	18bd8070 	popne	{r4, r5, r6, pc}

      status = vfs_component . start ();
    dab4:	e596300c 	ldr	r3, [r6, #12]
    dab8:	e12fff33 	blx	r3
      ensure (status == DNA_OK, status);
    dabc:	e3500000 	cmp	r0, #0
    dac0:	0a000002 	beq	dad0 <system_kickstart+0x7c>
    dac4:	e8bd8070 	pop	{r4, r5, r6, pc}
    }
    else cpu_mp_wait();
    dac8:	ebfff056 	bl	9c28 <cpu_mp_wait>
    dacc:	e59f400c 	ldr	r4, [pc, #12]	; dae0 <system_kickstart+0x8c>

    return core_component . start ();
    dad0:	e594300c 	ldr	r3, [r4, #12]
  }
}
    dad4:	e8bd4070 	pop	{r4, r5, r6, lr}
      status = vfs_component . start ();
      ensure (status == DNA_OK, status);
    }
    else cpu_mp_wait();

    return core_component . start ();
    dad8:	e12fff13 	bx	r3
    dadc:	00024bc0 	.word	0x00024bc0
    dae0:	00024bac 	.word	0x00024bac
    dae4:	00024b94 	.word	0x00024b94

0000dae8 <__aeabi_uidiv>:
	ARM_FUNC_ALIAS aeabi_uidiv udivsi3

	/* Note: if called via udivsi3_skip_div0_test, this will unnecessarily
	   check for division-by-zero a second time.  */
LSYM(udivsi3_skip_div0_test):
	subs	r2, r1, #1
    dae8:	e2512001 	subs	r2, r1, #1
	do_it	eq
	RETc(eq)
    daec:	012fff1e 	bxeq	lr
	bcc	LSYM(Ldiv0)
    daf0:	3a000036 	bcc	dbd0 <__aeabi_uidiv+0xe8>
	cmp	r0, r1
    daf4:	e1500001 	cmp	r0, r1
	bls	11f
    daf8:	9a000022 	bls	db88 <__aeabi_uidiv+0xa0>
	tst	r1, r2
    dafc:	e1110002 	tst	r1, r2
	beq	12f
    db00:	0a000023 	beq	db94 <__aeabi_uidiv+0xac>
	mov	\divisor, \divisor, lsl \result
	mov	\curbit, \curbit, lsl \result
	mov	\result, #0
	
#else /* __ARM_ARCH__ < 5 */

    db04:	e311020e 	tst	r1, #-536870912	; 0xe0000000
    db08:	01a01181 	lsleq	r1, r1, #3
    db0c:	03a03008 	moveq	r3, #8
    db10:	13a03001 	movne	r3, #1
    db14:	e3510201 	cmp	r1, #268435456	; 0x10000000
    db18:	31510000 	cmpcc	r1, r0
    db1c:	31a01201 	lslcc	r1, r1, #4
    db20:	31a03203 	lslcc	r3, r3, #4
    db24:	3afffffa 	bcc	db14 <__aeabi_uidiv+0x2c>
    db28:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    db2c:	31510000 	cmpcc	r1, r0
    db30:	31a01081 	lslcc	r1, r1, #1
    db34:	31a03083 	lslcc	r3, r3, #1
    db38:	3afffffa 	bcc	db28 <__aeabi_uidiv+0x40>
    db3c:	e3a02000 	mov	r2, #0
    db40:	e1500001 	cmp	r0, r1
    db44:	20400001 	subcs	r0, r0, r1
    db48:	21822003 	orrcs	r2, r2, r3
    db4c:	e15000a1 	cmp	r0, r1, lsr #1
    db50:	204000a1 	subcs	r0, r0, r1, lsr #1
    db54:	218220a3 	orrcs	r2, r2, r3, lsr #1
    db58:	e1500121 	cmp	r0, r1, lsr #2
    db5c:	20400121 	subcs	r0, r0, r1, lsr #2
    db60:	21822123 	orrcs	r2, r2, r3, lsr #2
    db64:	e15001a1 	cmp	r0, r1, lsr #3
    db68:	204001a1 	subcs	r0, r0, r1, lsr #3
    db6c:	218221a3 	orrcs	r2, r2, r3, lsr #3
    db70:	e3500000 	cmp	r0, #0
    db74:	11b03223 	lsrsne	r3, r3, #4
    db78:	11a01221 	lsrne	r1, r1, #4
    db7c:	1affffef 	bne	db40 <__aeabi_uidiv+0x58>
	tst	r1, r2
	beq	12f
	
	ARM_DIV_BODY r0, r1, r2, r3
	
	mov	r0, r2
    db80:	e1a00002 	mov	r0, r2
	RET	
    db84:	e12fff1e 	bx	lr

11:	do_it	eq, e
	moveq	r0, #1
    db88:	03a00001 	moveq	r0, #1
	movne	r0, #0
    db8c:	13a00000 	movne	r0, #0
	RET
    db90:	e12fff1e 	bx	lr

	clz	\order, \divisor
	rsb	\order, \order, #31

#else

    db94:	e3510801 	cmp	r1, #65536	; 0x10000
    db98:	21a01821 	lsrcs	r1, r1, #16
    db9c:	23a02010 	movcs	r2, #16
    dba0:	33a02000 	movcc	r2, #0
    dba4:	e3510c01 	cmp	r1, #256	; 0x100
    dba8:	21a01421 	lsrcs	r1, r1, #8
    dbac:	22822008 	addcs	r2, r2, #8
    dbb0:	e3510010 	cmp	r1, #16
    dbb4:	21a01221 	lsrcs	r1, r1, #4
    dbb8:	22822004 	addcs	r2, r2, #4
    dbbc:	e3510004 	cmp	r1, #4
    dbc0:	82822003 	addhi	r2, r2, #3
    dbc4:	908220a1 	addls	r2, r2, r1, lsr #1
	movne	r0, #0
	RET

12:	ARM_DIV2_ORDER r1, r2

	mov	r0, r0, lsr r2
    dbc8:	e1a00230 	lsr	r0, r0, r2
	RET
    dbcc:	e12fff1e 	bx	lr

#endif /* ARM version */

	DIV_FUNC_END udivsi3 unsigned
    dbd0:	e3500000 	cmp	r0, #0
    dbd4:	13e00000 	mvnne	r0, #0
    dbd8:	ea000059 	b	dd44 <__aeabi_idiv0>

0000dbdc <__aeabi_uidivmod>:
	udiv	r0, r0, r1
	mls     r1, r0, r1, r2
	RET
#else
ARM_FUNC_START aeabi_uidivmod
	cmp	r1, #0
    dbdc:	e3510000 	cmp	r1, #0
	beq	LSYM(Ldiv0)
    dbe0:	0afffffa 	beq	dbd0 <__aeabi_uidiv+0xe8>
	stmfd	sp!, { r0, r1, lr }
    dbe4:	e92d4003 	push	{r0, r1, lr}
	bl	LSYM(udivsi3_skip_div0_test)
    dbe8:	ebffffbe 	bl	dae8 <__aeabi_uidiv>
	ldmfd	sp!, { r1, r2, lr }
    dbec:	e8bd4006 	pop	{r1, r2, lr}
	mul	r3, r2, r0
    dbf0:	e0030092 	mul	r3, r2, r0
	sub	r1, r1, r3
    dbf4:	e0411003 	sub	r1, r1, r3
	RET
    dbf8:	e12fff1e 	bx	lr

0000dbfc <__aeabi_idiv>:
#else /* ARM/Thumb-2 version.  */
	
	ARM_FUNC_START divsi3	
	ARM_FUNC_ALIAS aeabi_idiv divsi3

	cmp	r1, #0
    dbfc:	e3510000 	cmp	r1, #0
	beq	LSYM(Ldiv0)
    dc00:	0a000043 	beq	dd14 <.divsi3_skip_div0_test+0x110>

0000dc04 <.divsi3_skip_div0_test>:
LSYM(divsi3_skip_div0_test):
	eor	ip, r0, r1			@ save the sign of the result.
    dc04:	e020c001 	eor	ip, r0, r1
	do_it	mi
	rsbmi	r1, r1, #0			@ loops below use unsigned.
    dc08:	42611000 	rsbmi	r1, r1, #0
	subs	r2, r1, #1			@ division by 1 or -1 ?
    dc0c:	e2512001 	subs	r2, r1, #1
	beq	10f
    dc10:	0a000027 	beq	dcb4 <.divsi3_skip_div0_test+0xb0>
	movs	r3, r0
    dc14:	e1b03000 	movs	r3, r0
	do_it	mi
	rsbmi	r3, r0, #0			@ positive dividend value
    dc18:	42603000 	rsbmi	r3, r0, #0
	cmp	r3, r1
    dc1c:	e1530001 	cmp	r3, r1
	bls	11f
    dc20:	9a000026 	bls	dcc0 <.divsi3_skip_div0_test+0xbc>
	tst	r1, r2				@ divisor is power of 2 ?
    dc24:	e1110002 	tst	r1, r2
	beq	12f
    dc28:	0a000028 	beq	dcd0 <.divsi3_skip_div0_test+0xcc>
	mov	\divisor, \divisor, lsl \result
	mov	\curbit, \curbit, lsl \result
	mov	\result, #0
	
#else /* __ARM_ARCH__ < 5 */

    dc2c:	e311020e 	tst	r1, #-536870912	; 0xe0000000
    dc30:	01a01181 	lsleq	r1, r1, #3
    dc34:	03a02008 	moveq	r2, #8
    dc38:	13a02001 	movne	r2, #1
    dc3c:	e3510201 	cmp	r1, #268435456	; 0x10000000
    dc40:	31510003 	cmpcc	r1, r3
    dc44:	31a01201 	lslcc	r1, r1, #4
    dc48:	31a02202 	lslcc	r2, r2, #4
    dc4c:	3afffffa 	bcc	dc3c <.divsi3_skip_div0_test+0x38>
    dc50:	e3510102 	cmp	r1, #-2147483648	; 0x80000000
    dc54:	31510003 	cmpcc	r1, r3
    dc58:	31a01081 	lslcc	r1, r1, #1
    dc5c:	31a02082 	lslcc	r2, r2, #1
    dc60:	3afffffa 	bcc	dc50 <.divsi3_skip_div0_test+0x4c>
    dc64:	e3a00000 	mov	r0, #0
    dc68:	e1530001 	cmp	r3, r1
    dc6c:	20433001 	subcs	r3, r3, r1
    dc70:	21800002 	orrcs	r0, r0, r2
    dc74:	e15300a1 	cmp	r3, r1, lsr #1
    dc78:	204330a1 	subcs	r3, r3, r1, lsr #1
    dc7c:	218000a2 	orrcs	r0, r0, r2, lsr #1
    dc80:	e1530121 	cmp	r3, r1, lsr #2
    dc84:	20433121 	subcs	r3, r3, r1, lsr #2
    dc88:	21800122 	orrcs	r0, r0, r2, lsr #2
    dc8c:	e15301a1 	cmp	r3, r1, lsr #3
    dc90:	204331a1 	subcs	r3, r3, r1, lsr #3
    dc94:	218001a2 	orrcs	r0, r0, r2, lsr #3
    dc98:	e3530000 	cmp	r3, #0
    dc9c:	11b02222 	lsrsne	r2, r2, #4
    dca0:	11a01221 	lsrne	r1, r1, #4
    dca4:	1affffef 	bne	dc68 <.divsi3_skip_div0_test+0x64>
	tst	r1, r2				@ divisor is power of 2 ?
	beq	12f

	ARM_DIV_BODY r3, r1, r0, r2
	
	cmp	ip, #0
    dca8:	e35c0000 	cmp	ip, #0
	do_it	mi
	rsbmi	r0, r0, #0
    dcac:	42600000 	rsbmi	r0, r0, #0
	RET	
    dcb0:	e12fff1e 	bx	lr

10:	teq	ip, r0				@ same sign ?
    dcb4:	e13c0000 	teq	ip, r0
	do_it	mi
	rsbmi	r0, r0, #0
    dcb8:	42600000 	rsbmi	r0, r0, #0
	RET	
    dcbc:	e12fff1e 	bx	lr

11:	do_it	lo
	movlo	r0, #0
    dcc0:	33a00000 	movcc	r0, #0
	do_it	eq,t
	moveq	r0, ip, asr #31
    dcc4:	01a00fcc 	asreq	r0, ip, #31
	orreq	r0, r0, #1
    dcc8:	03800001 	orreq	r0, r0, #1
	RET
    dccc:	e12fff1e 	bx	lr

	clz	\order, \divisor
	rsb	\order, \order, #31

#else

    dcd0:	e3510801 	cmp	r1, #65536	; 0x10000
    dcd4:	21a01821 	lsrcs	r1, r1, #16
    dcd8:	23a02010 	movcs	r2, #16
    dcdc:	33a02000 	movcc	r2, #0
    dce0:	e3510c01 	cmp	r1, #256	; 0x100
    dce4:	21a01421 	lsrcs	r1, r1, #8
    dce8:	22822008 	addcs	r2, r2, #8
    dcec:	e3510010 	cmp	r1, #16
    dcf0:	21a01221 	lsrcs	r1, r1, #4
    dcf4:	22822004 	addcs	r2, r2, #4
    dcf8:	e3510004 	cmp	r1, #4
    dcfc:	82822003 	addhi	r2, r2, #3
    dd00:	908220a1 	addls	r2, r2, r1, lsr #1
	orreq	r0, r0, #1
	RET

12:	ARM_DIV2_ORDER r1, r2

	cmp	ip, #0
    dd04:	e35c0000 	cmp	ip, #0
	mov	r0, r3, lsr r2
    dd08:	e1a00233 	lsr	r0, r3, r2
	do_it	mi
	rsbmi	r0, r0, #0
    dd0c:	42600000 	rsbmi	r0, r0, #0
	RET
    dd10:	e12fff1e 	bx	lr

#endif /* ARM version */
	
	DIV_FUNC_END divsi3 signed
    dd14:	e3500000 	cmp	r0, #0
    dd18:	c3e00102 	mvngt	r0, #-2147483648	; 0x80000000
    dd1c:	b3a00102 	movlt	r0, #-2147483648	; 0x80000000
    dd20:	ea000007 	b	dd44 <__aeabi_idiv0>

0000dd24 <__aeabi_idivmod>:
	sdiv	r0, r0, r1
	mls     r1, r0, r1, r2
	RET
#else
ARM_FUNC_START aeabi_idivmod
	cmp	r1, #0
    dd24:	e3510000 	cmp	r1, #0
	beq	LSYM(Ldiv0)
    dd28:	0afffff9 	beq	dd14 <.divsi3_skip_div0_test+0x110>
	stmfd	sp!, { r0, r1, lr }
    dd2c:	e92d4003 	push	{r0, r1, lr}
	bl	LSYM(divsi3_skip_div0_test)
    dd30:	ebffffb3 	bl	dc04 <.divsi3_skip_div0_test>
	ldmfd	sp!, { r1, r2, lr }
    dd34:	e8bd4006 	pop	{r1, r2, lr}
	mul	r3, r2, r0
    dd38:	e0030092 	mul	r3, r2, r0
	sub	r1, r1, r3
    dd3c:	e0411003 	sub	r1, r1, r3
	RET
    dd40:	e12fff1e 	bx	lr

0000dd44 <__aeabi_idiv0>:
#ifdef __ARM_EABI__
	WEAK aeabi_idiv0
	WEAK aeabi_ldiv0
	FUNC_START aeabi_idiv0
	FUNC_START aeabi_ldiv0
	RET
    dd44:	e12fff1e 	bx	lr

0000dd48 <__aeabi_ldivmod>:
	.endif
	b	SYM (__aeabi_ldiv0) __PLT__
1:
#else
	/* Note: Thumb-1 code calls via an ARM shim on processors which
	   support ARM mode.  */
    dd48:	e3530000 	cmp	r3, #0
    dd4c:	03520000 	cmpeq	r2, #0
    dd50:	1a000006 	bne	dd70 <__aeabi_ldivmod+0x28>
    dd54:	e3510000 	cmp	r1, #0
    dd58:	03500000 	cmpeq	r0, #0
    dd5c:	b3a01102 	movlt	r1, #-2147483648	; 0x80000000
    dd60:	b3a00000 	movlt	r0, #0
    dd64:	c3e01102 	mvngt	r1, #-2147483648	; 0x80000000
    dd68:	c3e00000 	mvngt	r0, #0
    dd6c:	eafffff4 	b	dd44 <__aeabi_idiv0>
	cmp	yyh, #0
    dd70:	e24dd008 	sub	sp, sp, #8
	cmpeq	yyl, #0
	bne	2f
	cmp	xxh, #0
	cmpeq	xxl, #0
	.ifc \signed, unsigned
    dd74:	e92d6000 	push	{sp, lr}
	movne	xxh, #0xffffffff
	movne	xxl, #0xffffffff
	.else
    dd78:	eb000012 	bl	ddc8 <__gnu_ldivmod_helper>
	movlt	xxh, #0x80000000
    dd7c:	e59de004 	ldr	lr, [sp, #4]
	movlt	xxl, #0
    dd80:	e28dd008 	add	sp, sp, #8
	movgt	xxh, #0x7fffffff
    dd84:	e8bd000c 	pop	{r2, r3}
	movgt	xxl, #0xffffffff
    dd88:	e12fff1e 	bx	lr

0000dd8c <__aeabi_uldivmod>:
	.endif
	b	SYM (__aeabi_ldiv0) __PLT__
1:
#else
	/* Note: Thumb-1 code calls via an ARM shim on processors which
	   support ARM mode.  */
    dd8c:	e3530000 	cmp	r3, #0
    dd90:	03520000 	cmpeq	r2, #0
    dd94:	1a000004 	bne	ddac <__aeabi_uldivmod+0x20>
    dd98:	e3510000 	cmp	r1, #0
    dd9c:	03500000 	cmpeq	r0, #0
    dda0:	13e01000 	mvnne	r1, #0
    dda4:	13e00000 	mvnne	r0, #0
    dda8:	eaffffe5 	b	dd44 <__aeabi_idiv0>

ARM_FUNC_START aeabi_uldivmod
	cfi_start	__aeabi_uldivmod, LSYM(Lend_aeabi_uldivmod)
	test_div_by_zero unsigned

	sub sp, sp, #8
    ddac:	e24dd008 	sub	sp, sp, #8
#if defined(__thumb2__)
	mov ip, sp
	push {ip, lr}
#else
	do_push {sp, lr}
    ddb0:	e92d6000 	push	{sp, lr}
#endif
98:	cfi_push 98b - __aeabi_uldivmod, 0xe, -0xc, 0x10
	bl SYM(__gnu_uldivmod_helper) __PLT__
    ddb4:	eb000014 	bl	de0c <__gnu_uldivmod_helper>
	ldr lr, [sp, #4]
    ddb8:	e59de004 	ldr	lr, [sp, #4]
	add sp, sp, #8
    ddbc:	e28dd008 	add	sp, sp, #8
	do_pop {r2, r3}
    ddc0:	e8bd000c 	pop	{r2, r3}
	RET
    ddc4:	e12fff1e 	bx	lr

0000ddc8 <__gnu_ldivmod_helper>:

long long
__gnu_ldivmod_helper (long long a, 
		      long long b, 
		      long long *remainder)
{
    ddc8:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
    ddcc:	e59d9020 	ldr	r9, [sp, #32]
    ddd0:	e1a08002 	mov	r8, r2
    ddd4:	e1a0a003 	mov	sl, r3
    ddd8:	e1a06000 	mov	r6, r0
    dddc:	e1a07001 	mov	r7, r1
  long long quotient;

  quotient = __divdi3 (a, b);
    dde0:	eb000019 	bl	de4c <__divdi3>
    dde4:	e1a02000 	mov	r2, r0
  *remainder = a - b * quotient;
    dde8:	e0030198 	mul	r3, r8, r1
    ddec:	e0854098 	umull	r4, r5, r8, r0
    ddf0:	e022329a 	mla	r2, sl, r2, r3
    ddf4:	e0564004 	subs	r4, r6, r4
    ddf8:	e0825005 	add	r5, r2, r5
    ddfc:	e0c75005 	sbc	r5, r7, r5
    de00:	e8890030 	stm	r9, {r4, r5}
  return quotient;
}
    de04:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}
    de08:	e12fff1e 	bx	lr

0000de0c <__gnu_uldivmod_helper>:

unsigned long long
__gnu_uldivmod_helper (unsigned long long a, 
		       unsigned long long b,
		       unsigned long long *remainder)
{
    de0c:	e92d43f8 	push	{r3, r4, r5, r6, r7, r8, r9, lr}
    de10:	e59d9020 	ldr	r9, [sp, #32]
    de14:	e1a06000 	mov	r6, r0
    de18:	e1a07001 	mov	r7, r1
    de1c:	e1a08002 	mov	r8, r2
    de20:	e1a04003 	mov	r4, r3
  unsigned long long quotient;

  quotient = __udivdi3 (a, b);
    de24:	eb000139 	bl	e310 <__udivdi3>
  *remainder = a - b * quotient;
    de28:	e0030490 	mul	r3, r0, r4
    de2c:	e0854890 	umull	r4, r5, r0, r8
    de30:	e0283891 	mla	r8, r1, r8, r3
    de34:	e0564004 	subs	r4, r6, r4
    de38:	e0885005 	add	r5, r8, r5
    de3c:	e0c75005 	sbc	r5, r7, r5
    de40:	e8890030 	stm	r9, {r4, r5}
  return quotient;
}
    de44:	e8bd43f8 	pop	{r3, r4, r5, r6, r7, r8, r9, lr}
    de48:	e12fff1e 	bx	lr

0000de4c <__divdi3>:
#endif

#ifdef L_divdi3
DWtype
__divdi3 (DWtype u, DWtype v)
{
    de4c:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
  Wtype c = 0;
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    de50:	e3510000 	cmp	r1, #0
#endif

#ifdef L_divdi3
DWtype
__divdi3 (DWtype u, DWtype v)
{
    de54:	e24dd014 	sub	sp, sp, #20
    de58:	a1a04000 	movge	r4, r0
    de5c:	a1a05001 	movge	r5, r1
  Wtype c = 0;
    de60:	a3a06000 	movge	r6, #0
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    de64:	ba0000e1 	blt	e1f0 <__divdi3+0x3a4>
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    de68:	e3530000 	cmp	r3, #0
    de6c:	ba0000db 	blt	e1e0 <__divdi3+0x394>
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
    de70:	e3530000 	cmp	r3, #0
static inline __attribute__ ((__always_inline__))
#endif
UDWtype
__udivmoddi4 (UDWtype n, UDWtype d, UDWtype *rp)
{
  const DWunion nn = {.ll = n};
    de74:	e1a0c004 	mov	ip, r4
    de78:	e1a0b005 	mov	fp, r5
  const DWunion dd = {.ll = d};
    de7c:	e1a0a002 	mov	sl, r2
  DWunion rr;
  UWtype d0, d1, n0, n1, n2;
  UWtype q0, q1;
  UWtype b, bm;

  d0 = dd.s.low;
    de80:	e1a07002 	mov	r7, r2
  d1 = dd.s.high;
  n0 = nn.s.low;
    de84:	e1a08004 	mov	r8, r4
  n1 = nn.s.high;
    de88:	e1a09005 	mov	r9, r5
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
    de8c:	1a000040 	bne	df94 <__divdi3+0x148>
    {
      if (d0 > n1)
    de90:	e1520005 	cmp	r2, r5
    de94:	9a000096 	bls	e0f4 <__divdi3+0x2a8>
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
    de98:	e1a00002 	mov	r0, r2
    de9c:	eb000237 	bl	e780 <__clzsi2>

	  if (bm != 0)
    dea0:	e3500000 	cmp	r0, #0
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
    dea4:	12603020 	rsbne	r3, r0, #32
	  if (bm != 0)
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
    dea8:	11a0701a 	lslne	r7, sl, r0
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
    deac:	11a03334 	lsrne	r3, r4, r3
    deb0:	11839015 	orrne	r9, r3, r5, lsl r0
	      n0 = n0 << bm;
    deb4:	11a08014 	lslne	r8, r4, r0
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
    deb8:	e1a04827 	lsr	r4, r7, #16
    debc:	e1a01004 	mov	r1, r4
    dec0:	e1a00009 	mov	r0, r9
    dec4:	ebffff07 	bl	dae8 <__aeabi_uidiv>
    dec8:	e1a0a000 	mov	sl, r0
    decc:	e1a01004 	mov	r1, r4
    ded0:	e1a00009 	mov	r0, r9
    ded4:	ebffff40 	bl	dbdc <__aeabi_uidivmod>
    ded8:	e1a0b807 	lsl	fp, r7, #16
    dedc:	e1a0b82b 	lsr	fp, fp, #16
    dee0:	e0000a9b 	mul	r0, fp, sl
    dee4:	e1a03828 	lsr	r3, r8, #16
    dee8:	e1831801 	orr	r1, r3, r1, lsl #16
    deec:	e1500001 	cmp	r0, r1
    def0:	9a000007 	bls	df14 <__divdi3+0xc8>
    def4:	e0911007 	adds	r1, r1, r7
    def8:	e24a2001 	sub	r2, sl, #1
    defc:	2a000003 	bcs	df10 <__divdi3+0xc4>
    df00:	e1500001 	cmp	r0, r1
    df04:	824aa002 	subhi	sl, sl, #2
    df08:	80811007 	addhi	r1, r1, r7
    df0c:	8a000000 	bhi	df14 <__divdi3+0xc8>
    df10:	e1a0a002 	mov	sl, r2
    df14:	e0609001 	rsb	r9, r0, r1
    df18:	e1a00009 	mov	r0, r9
    df1c:	e1a01004 	mov	r1, r4
    df20:	ebfffef0 	bl	dae8 <__aeabi_uidiv>
    df24:	e1a05000 	mov	r5, r0
    df28:	e1a01004 	mov	r1, r4
    df2c:	e1a00009 	mov	r0, r9
    df30:	ebffff29 	bl	dbdc <__aeabi_uidivmod>
    df34:	e00b0b95 	mul	fp, r5, fp
    df38:	e1a08808 	lsl	r8, r8, #16
    df3c:	e1a08828 	lsr	r8, r8, #16
    df40:	e1881801 	orr	r1, r8, r1, lsl #16
    df44:	e15b0001 	cmp	fp, r1
    df48:	9a000006 	bls	df68 <__divdi3+0x11c>
    df4c:	e0917007 	adds	r7, r1, r7
    df50:	e2453001 	sub	r3, r5, #1
    df54:	2a000002 	bcs	df64 <__divdi3+0x118>
    df58:	e15b0007 	cmp	fp, r7
    df5c:	82455002 	subhi	r5, r5, #2
    df60:	8a000000 	bhi	df68 <__divdi3+0x11c>
    df64:	e1a05003 	mov	r5, r3
    df68:	e3a04000 	mov	r4, #0
    df6c:	e185a80a 	orr	sl, r5, sl, lsl #16
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;

  w = __udivmoddi4 (uu.ll, vv.ll, (UDWtype *) 0);
  if (c)
    df70:	e3560000 	cmp	r6, #0
	    }
	}
    }

  const DWunion ww = {{.low = q0, .high = q1}};
  return ww.ll;
    df74:	e1a0000a 	mov	r0, sl
    df78:	e1a01004 	mov	r1, r4
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;

  w = __udivmoddi4 (uu.ll, vv.ll, (UDWtype *) 0);
  if (c)
    df7c:	0a000001 	beq	df88 <__divdi3+0x13c>
    w = -w;
    df80:	e27a0000 	rsbs	r0, sl, #0
    df84:	e2e41000 	rsc	r1, r4, #0

  return w;
}
    df88:	e28dd014 	add	sp, sp, #20
    df8c:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    df90:	e12fff1e 	bx	lr
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
    df94:	e1530005 	cmp	r3, r5
    df98:	83a04000 	movhi	r4, #0
    df9c:	81a0a004 	movhi	sl, r4
    dfa0:	8afffff2 	bhi	df70 <__divdi3+0x124>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
    dfa4:	e1a00003 	mov	r0, r3
    dfa8:	e58dc008 	str	ip, [sp, #8]
    dfac:	e58d300c 	str	r3, [sp, #12]
    dfb0:	eb0001f2 	bl	e780 <__clzsi2>
	  if (bm == 0)
    dfb4:	e2504000 	subs	r4, r0, #0
    dfb8:	e59d100c 	ldr	r1, [sp, #12]
    dfbc:	e59dc008 	ldr	ip, [sp, #8]
    dfc0:	0a0000c5 	beq	e2dc <__divdi3+0x490>
	  else
	    {
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;
    dfc4:	e2643020 	rsb	r3, r4, #32

	      d1 = (d1 << bm) | (d0 >> b);
    dfc8:	e1a0533a 	lsr	r5, sl, r3
    dfcc:	e1855411 	orr	r5, r5, r1, lsl r4
	      d0 = d0 << bm;
	      n2 = n1 >> b;
    dfd0:	e1a0233b 	lsr	r2, fp, r3
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
    dfd4:	e1a07825 	lsr	r7, r5, #16
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
    dfd8:	e1a03338 	lsr	r3, r8, r3
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
    dfdc:	e1a01007 	mov	r1, r7
    dfe0:	e1a00002 	mov	r0, r2
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
    dfe4:	e183b41b 	orr	fp, r3, fp, lsl r4
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
    dfe8:	e58d200c 	str	r2, [sp, #12]
    dfec:	ebfffebd 	bl	dae8 <__aeabi_uidiv>
    dff0:	e1a03000 	mov	r3, r0
    dff4:	e59d200c 	ldr	r2, [sp, #12]
    dff8:	e1a01007 	mov	r1, r7
    dffc:	e1a00002 	mov	r0, r2
    e000:	e58d3004 	str	r3, [sp, #4]
    e004:	ebfffef4 	bl	dbdc <__aeabi_uidivmod>
    e008:	e1a09805 	lsl	r9, r5, #16
    e00c:	e59d3004 	ldr	r3, [sp, #4]
    e010:	e1a09829 	lsr	r9, r9, #16
    e014:	e0000399 	mul	r0, r9, r3
    e018:	e1a0282b 	lsr	r2, fp, #16
    e01c:	e1821801 	orr	r1, r2, r1, lsl #16
    e020:	e1500001 	cmp	r0, r1
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
    e024:	e1a0a41a 	lsl	sl, sl, r4
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
    e028:	9a000006 	bls	e048 <__divdi3+0x1fc>
    e02c:	e0911005 	adds	r1, r1, r5
    e030:	e2432001 	sub	r2, r3, #1
    e034:	2a0000b1 	bcs	e300 <__divdi3+0x4b4>
    e038:	e1500001 	cmp	r0, r1
    e03c:	82433002 	subhi	r3, r3, #2
    e040:	80811005 	addhi	r1, r1, r5
    e044:	9a0000ad 	bls	e300 <__divdi3+0x4b4>
    e048:	e0602001 	rsb	r2, r0, r1
    e04c:	e1a00002 	mov	r0, r2
    e050:	e1a01007 	mov	r1, r7
    e054:	e58d3004 	str	r3, [sp, #4]
    e058:	e58d200c 	str	r2, [sp, #12]
    e05c:	ebfffea1 	bl	dae8 <__aeabi_uidiv>
    e060:	e1a0c000 	mov	ip, r0
    e064:	e59d200c 	ldr	r2, [sp, #12]
    e068:	e1a01007 	mov	r1, r7
    e06c:	e1a00002 	mov	r0, r2
    e070:	e58dc008 	str	ip, [sp, #8]
    e074:	ebfffed8 	bl	dbdc <__aeabi_uidivmod>
    e078:	e59dc008 	ldr	ip, [sp, #8]
    e07c:	e009099c 	mul	r9, ip, r9
    e080:	e1a0b80b 	lsl	fp, fp, #16
    e084:	e1a0e82b 	lsr	lr, fp, #16
    e088:	e18e1801 	orr	r1, lr, r1, lsl #16
    e08c:	e1590001 	cmp	r9, r1
    e090:	e59d3004 	ldr	r3, [sp, #4]
    e094:	9a000006 	bls	e0b4 <__divdi3+0x268>
    e098:	e0911005 	adds	r1, r1, r5
    e09c:	e24c2001 	sub	r2, ip, #1
    e0a0:	2a000094 	bcs	e2f8 <__divdi3+0x4ac>
    e0a4:	e1590001 	cmp	r9, r1
    e0a8:	824cc002 	subhi	ip, ip, #2
    e0ac:	80811005 	addhi	r1, r1, r5
    e0b0:	9a000090 	bls	e2f8 <__divdi3+0x4ac>
    e0b4:	e18cc803 	orr	ip, ip, r3, lsl #16
	      umul_ppmm (m1, m0, q0, d0);
    e0b8:	e0832a9c 	umull	r2, r3, ip, sl
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
    e0bc:	e0699001 	rsb	r9, r9, r1
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
    e0c0:	e1590003 	cmp	r9, r3
    e0c4:	3a000007 	bcc	e0e8 <__divdi3+0x29c>
    e0c8:	03a03001 	moveq	r3, #1
    e0cc:	13a03000 	movne	r3, #0
    e0d0:	e1520418 	cmp	r2, r8, lsl r4
    e0d4:	93a04000 	movls	r4, #0
    e0d8:	82034001 	andhi	r4, r3, #1
    e0dc:	e3540000 	cmp	r4, #0
    e0e0:	01a0a00c 	moveq	sl, ip
    e0e4:	0affffa1 	beq	df70 <__divdi3+0x124>
		{
		  q0--;
    e0e8:	e24ca001 	sub	sl, ip, #1
		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
    e0ec:	e3a04000 	mov	r4, #0
    e0f0:	eaffff9e 	b	df70 <__divdi3+0x124>
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
    e0f4:	e3520000 	cmp	r2, #0
    e0f8:	1a000003 	bne	e10c <__divdi3+0x2c0>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
    e0fc:	e1a01002 	mov	r1, r2
    e100:	e3a00001 	mov	r0, #1
    e104:	ebfffe77 	bl	dae8 <__aeabi_uidiv>
    e108:	e1a07000 	mov	r7, r0

	  count_leading_zeros (bm, d0);
    e10c:	e1a00007 	mov	r0, r7
    e110:	eb00019a 	bl	e780 <__clzsi2>

	  if (bm == 0)
    e114:	e2503000 	subs	r3, r0, #0
    e118:	1a000038 	bne	e200 <__divdi3+0x3b4>
		 leading quotient digit q1 = 1).

		 This special case is necessary, not an optimization.
		 (Shifts counts of W_TYPE_SIZE are undefined.)  */

	      n1 -= d0;
    e11c:	e3a04001 	mov	r4, #1
    e120:	e1a0b807 	lsl	fp, r7, #16
    e124:	e0679009 	rsb	r9, r7, r9
    e128:	e1a0b82b 	lsr	fp, fp, #16
    e12c:	e1a05827 	lsr	r5, r7, #16
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
    e130:	e1a01005 	mov	r1, r5
    e134:	e1a00009 	mov	r0, r9
    e138:	ebfffe6a 	bl	dae8 <__aeabi_uidiv>
    e13c:	e1a0a000 	mov	sl, r0
    e140:	e1a01005 	mov	r1, r5
    e144:	e1a00009 	mov	r0, r9
    e148:	ebfffea3 	bl	dbdc <__aeabi_uidivmod>
    e14c:	e0000a9b 	mul	r0, fp, sl
    e150:	e1a03828 	lsr	r3, r8, #16
    e154:	e1831801 	orr	r1, r3, r1, lsl #16
    e158:	e1500001 	cmp	r0, r1
    e15c:	9a000006 	bls	e17c <__divdi3+0x330>
    e160:	e0911007 	adds	r1, r1, r7
    e164:	e24a2001 	sub	r2, sl, #1
    e168:	2a000060 	bcs	e2f0 <__divdi3+0x4a4>
    e16c:	e1500001 	cmp	r0, r1
    e170:	824aa002 	subhi	sl, sl, #2
    e174:	80811007 	addhi	r1, r1, r7
    e178:	9a00005c 	bls	e2f0 <__divdi3+0x4a4>
    e17c:	e0603001 	rsb	r3, r0, r1
    e180:	e1a00003 	mov	r0, r3
    e184:	e1a01005 	mov	r1, r5
    e188:	e58d3004 	str	r3, [sp, #4]
    e18c:	ebfffe55 	bl	dae8 <__aeabi_uidiv>
    e190:	e1a09000 	mov	r9, r0
    e194:	e59d3004 	ldr	r3, [sp, #4]
    e198:	e1a01005 	mov	r1, r5
    e19c:	e1a00003 	mov	r0, r3
    e1a0:	ebfffe8d 	bl	dbdc <__aeabi_uidivmod>
    e1a4:	e00b0b99 	mul	fp, r9, fp
    e1a8:	e1a08808 	lsl	r8, r8, #16
    e1ac:	e1a08828 	lsr	r8, r8, #16
    e1b0:	e1881801 	orr	r1, r8, r1, lsl #16
    e1b4:	e15b0001 	cmp	fp, r1
    e1b8:	9a000006 	bls	e1d8 <__divdi3+0x38c>
    e1bc:	e0917007 	adds	r7, r1, r7
    e1c0:	e2493001 	sub	r3, r9, #1
    e1c4:	2a000002 	bcs	e1d4 <__divdi3+0x388>
    e1c8:	e15b0007 	cmp	fp, r7
    e1cc:	82499002 	subhi	r9, r9, #2
    e1d0:	8a000000 	bhi	e1d8 <__divdi3+0x38c>
    e1d4:	e1a09003 	mov	r9, r3
    e1d8:	e189a80a 	orr	sl, r9, sl, lsl #16
    e1dc:	eaffff63 	b	df70 <__divdi3+0x124>
  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    c = ~c,
    vv.ll = -vv.ll;
    e1e0:	e2722000 	rsbs	r2, r2, #0

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
  if (vv.s.high < 0)
    c = ~c,
    e1e4:	e1e06006 	mvn	r6, r6
    vv.ll = -vv.ll;
    e1e8:	e2e33000 	rsc	r3, r3, #0
    e1ec:	eaffff1f 	b	de70 <__divdi3+0x24>
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    uu.ll = -uu.ll;
    e1f0:	e2704000 	rsbs	r4, r0, #0
    e1f4:	e2e15000 	rsc	r5, r1, #0
  DWunion uu = {.ll = u};
  DWunion vv = {.ll = v};
  DWtype w;

  if (uu.s.high < 0)
    c = ~c,
    e1f8:	e3e06000 	mvn	r6, #0
    e1fc:	eaffff19 	b	de68 <__divdi3+0x1c>
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
    e200:	e1a07317 	lsl	r7, r7, r3
	    }
	  else
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;
    e204:	e2632020 	rsb	r2, r3, #32

	      d0 = d0 << bm;
	      n2 = n1 >> b;
    e208:	e1a04239 	lsr	r4, r9, r2
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
    e20c:	e1a05827 	lsr	r5, r7, #16

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
    e210:	e1a02238 	lsr	r2, r8, r2
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
    e214:	e1a01005 	mov	r1, r5
    e218:	e1a00004 	mov	r0, r4

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
    e21c:	e1829319 	orr	r9, r2, r9, lsl r3
	      n0 = n0 << bm;
    e220:	e1a08318 	lsl	r8, r8, r3

	      udiv_qrnnd (q1, n1, n2, n1, d0);
    e224:	ebfffe2f 	bl	dae8 <__aeabi_uidiv>
    e228:	e1a0a000 	mov	sl, r0
    e22c:	e1a01005 	mov	r1, r5
    e230:	e1a00004 	mov	r0, r4
    e234:	ebfffe68 	bl	dbdc <__aeabi_uidivmod>
    e238:	e1a0b807 	lsl	fp, r7, #16
    e23c:	e1a0b82b 	lsr	fp, fp, #16
    e240:	e0000a9b 	mul	r0, fp, sl
    e244:	e1a03829 	lsr	r3, r9, #16
    e248:	e1831801 	orr	r1, r3, r1, lsl #16
    e24c:	e1500001 	cmp	r0, r1
    e250:	9a000006 	bls	e270 <__divdi3+0x424>
    e254:	e0911007 	adds	r1, r1, r7
    e258:	e24a3001 	sub	r3, sl, #1
    e25c:	2a000029 	bcs	e308 <__divdi3+0x4bc>
    e260:	e1500001 	cmp	r0, r1
    e264:	824aa002 	subhi	sl, sl, #2
    e268:	80811007 	addhi	r1, r1, r7
    e26c:	9a000025 	bls	e308 <__divdi3+0x4bc>
    e270:	e0603001 	rsb	r3, r0, r1
    e274:	e1a00003 	mov	r0, r3
    e278:	e1a01005 	mov	r1, r5
    e27c:	e58d3004 	str	r3, [sp, #4]
    e280:	ebfffe18 	bl	dae8 <__aeabi_uidiv>
    e284:	e1a04000 	mov	r4, r0
    e288:	e59d3004 	ldr	r3, [sp, #4]
    e28c:	e1a01005 	mov	r1, r5
    e290:	e1a00003 	mov	r0, r3
    e294:	ebfffe50 	bl	dbdc <__aeabi_uidivmod>
    e298:	e003049b 	mul	r3, fp, r4
    e29c:	e1a09809 	lsl	r9, r9, #16
    e2a0:	e1a09829 	lsr	r9, r9, #16
    e2a4:	e1891801 	orr	r1, r9, r1, lsl #16
    e2a8:	e1530001 	cmp	r3, r1
    e2ac:	9a000007 	bls	e2d0 <__divdi3+0x484>
    e2b0:	e0911007 	adds	r1, r1, r7
    e2b4:	e2442001 	sub	r2, r4, #1
    e2b8:	2a000003 	bcs	e2cc <__divdi3+0x480>
    e2bc:	e1530001 	cmp	r3, r1
    e2c0:	82444002 	subhi	r4, r4, #2
    e2c4:	80811007 	addhi	r1, r1, r7
    e2c8:	8a000000 	bhi	e2d0 <__divdi3+0x484>
    e2cc:	e1a04002 	mov	r4, r2
    e2d0:	e0639001 	rsb	r9, r3, r1
    e2d4:	e184480a 	orr	r4, r4, sl, lsl #16
    e2d8:	eaffff94 	b	e130 <__divdi3+0x2e4>
	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
    e2dc:	e1510005 	cmp	r1, r5
    e2e0:	215a000c 	cmpcs	sl, ip
    e2e4:	93a0a001 	movls	sl, #1
    e2e8:	83a0a000 	movhi	sl, #0
    e2ec:	eaffff1f 	b	df70 <__divdi3+0x124>
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
    e2f0:	e1a0a002 	mov	sl, r2
    e2f4:	eaffffa0 	b	e17c <__divdi3+0x330>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
    e2f8:	e1a0c002 	mov	ip, r2
    e2fc:	eaffff6c 	b	e0b4 <__divdi3+0x268>
    e300:	e1a03002 	mov	r3, r2
    e304:	eaffff4f 	b	e048 <__divdi3+0x1fc>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
    e308:	e1a0a003 	mov	sl, r3
    e30c:	eaffffd7 	b	e270 <__divdi3+0x424>

0000e310 <__udivdi3>:
#endif

#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
    e310:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
    e314:	e3530000 	cmp	r3, #0
#endif

#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
    e318:	e24dd00c 	sub	sp, sp, #12
    e31c:	e1a07003 	mov	r7, r3
    e320:	e1a09000 	mov	r9, r0
    e324:	e1a05001 	mov	r5, r1
    e328:	e1a06002 	mov	r6, r2
	}
    }

#else /* UDIV_NEEDS_NORMALIZATION */

  if (d1 == 0)
    e32c:	1a00003d 	bne	e428 <__udivdi3+0x118>
    {
      if (d0 > n1)
    e330:	e1520001 	cmp	r2, r1
    e334:	e1a04002 	mov	r4, r2
    e338:	e1a0a000 	mov	sl, r0
    e33c:	9a000085 	bls	e558 <__udivdi3+0x248>
	{
	  /* 0q = nn / 0D */

	  count_leading_zeros (bm, d0);
    e340:	e1a00002 	mov	r0, r2
    e344:	e1a08001 	mov	r8, r1
    e348:	eb00010c 	bl	e780 <__clzsi2>

	  if (bm != 0)
    e34c:	e3500000 	cmp	r0, #0
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
    e350:	12608020 	rsbne	r8, r0, #32
	  if (bm != 0)
	    {
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
    e354:	11a04016 	lslne	r4, r6, r0
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
    e358:	11a08839 	lsrne	r8, r9, r8
    e35c:	11888015 	orrne	r8, r8, r5, lsl r0
	      n0 = n0 << bm;
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
    e360:	e1a0b824 	lsr	fp, r4, #16
	      /* Normalize, i.e. make the most significant bit of the
		 denominator set.  */

	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
	      n0 = n0 << bm;
    e364:	11a0a019 	lslne	sl, r9, r0
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
    e368:	e1a0100b 	mov	r1, fp
    e36c:	e1a00008 	mov	r0, r8
    e370:	ebfffddc 	bl	dae8 <__aeabi_uidiv>
    e374:	e1a06000 	mov	r6, r0
    e378:	e1a0100b 	mov	r1, fp
    e37c:	e1a00008 	mov	r0, r8
    e380:	ebfffe15 	bl	dbdc <__aeabi_uidivmod>
    e384:	e1a07804 	lsl	r7, r4, #16
    e388:	e1a07827 	lsr	r7, r7, #16
    e38c:	e0000697 	mul	r0, r7, r6
    e390:	e1a0382a 	lsr	r3, sl, #16
    e394:	e1831801 	orr	r1, r3, r1, lsl #16
    e398:	e1500001 	cmp	r0, r1
    e39c:	9a000007 	bls	e3c0 <__udivdi3+0xb0>
    e3a0:	e0911004 	adds	r1, r1, r4
    e3a4:	e2462001 	sub	r2, r6, #1
    e3a8:	2a000003 	bcs	e3bc <__udivdi3+0xac>
    e3ac:	e1500001 	cmp	r0, r1
    e3b0:	82466002 	subhi	r6, r6, #2
    e3b4:	80811004 	addhi	r1, r1, r4
    e3b8:	8a000000 	bhi	e3c0 <__udivdi3+0xb0>
    e3bc:	e1a06002 	mov	r6, r2
    e3c0:	e0608001 	rsb	r8, r0, r1
    e3c4:	e1a00008 	mov	r0, r8
    e3c8:	e1a0100b 	mov	r1, fp
    e3cc:	ebfffdc5 	bl	dae8 <__aeabi_uidiv>
    e3d0:	e1a05000 	mov	r5, r0
    e3d4:	e1a0100b 	mov	r1, fp
    e3d8:	e1a00008 	mov	r0, r8
    e3dc:	ebfffdfe 	bl	dbdc <__aeabi_uidivmod>
    e3e0:	e0070795 	mul	r7, r5, r7
    e3e4:	e1a0a80a 	lsl	sl, sl, #16
    e3e8:	e1a0a82a 	lsr	sl, sl, #16
    e3ec:	e18a1801 	orr	r1, sl, r1, lsl #16
    e3f0:	e1570001 	cmp	r7, r1
    e3f4:	9a000005 	bls	e410 <__udivdi3+0x100>
    e3f8:	e0914004 	adds	r4, r1, r4
    e3fc:	e2453001 	sub	r3, r5, #1
    e400:	2a0000cc 	bcs	e738 <__udivdi3+0x428>
    e404:	e1570004 	cmp	r7, r4
    e408:	82455002 	subhi	r5, r5, #2
    e40c:	9a0000c9 	bls	e738 <__udivdi3+0x428>
    e410:	e3a08000 	mov	r8, #0
    e414:	e1850806 	orr	r0, r5, r6, lsl #16
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
    e418:	e1a01008 	mov	r1, r8
    e41c:	e28dd00c 	add	sp, sp, #12
    e420:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e424:	e12fff1e 	bx	lr
    }
#endif /* UDIV_NEEDS_NORMALIZATION */

  else
    {
      if (d1 > n1)
    e428:	e1530001 	cmp	r3, r1
    e42c:	83a08000 	movhi	r8, #0
    e430:	81a00008 	movhi	r0, r8
    e434:	8afffff7 	bhi	e418 <__udivdi3+0x108>
	}
      else
	{
	  /* 0q = NN / dd */

	  count_leading_zeros (bm, d1);
    e438:	e1a00003 	mov	r0, r3
    e43c:	eb0000cf 	bl	e780 <__clzsi2>
	  if (bm == 0)
    e440:	e2508000 	subs	r8, r0, #0
    e444:	0a00007e 	beq	e644 <__udivdi3+0x334>
	  else
	    {
	      UWtype m1, m0;
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;
    e448:	e2683020 	rsb	r3, r8, #32

	      d1 = (d1 << bm) | (d0 >> b);
    e44c:	e1a02336 	lsr	r2, r6, r3
    e450:	e1827817 	orr	r7, r2, r7, lsl r8
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
    e454:	e1a04827 	lsr	r4, r7, #16

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
    e458:	e1a02335 	lsr	r2, r5, r3
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
    e45c:	e1a01004 	mov	r1, r4
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
    e460:	e1a03339 	lsr	r3, r9, r3
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
    e464:	e1a00002 	mov	r0, r2
	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
    e468:	e1835815 	orr	r5, r3, r5, lsl r8
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
    e46c:	e58d2004 	str	r2, [sp, #4]
    e470:	ebfffd9c 	bl	dae8 <__aeabi_uidiv>
    e474:	e1a0b000 	mov	fp, r0
    e478:	e59d2004 	ldr	r2, [sp, #4]
    e47c:	e1a01004 	mov	r1, r4
    e480:	e1a00002 	mov	r0, r2
    e484:	ebfffdd4 	bl	dbdc <__aeabi_uidivmod>
    e488:	e1a0a807 	lsl	sl, r7, #16
    e48c:	e1a0a82a 	lsr	sl, sl, #16
    e490:	e0000b9a 	mul	r0, sl, fp
    e494:	e1a03825 	lsr	r3, r5, #16
    e498:	e1831801 	orr	r1, r3, r1, lsl #16
    e49c:	e1500001 	cmp	r0, r1
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d1 = (d1 << bm) | (d0 >> b);
	      d0 = d0 << bm;
    e4a0:	e1a06816 	lsl	r6, r6, r8
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
    e4a4:	9a000003 	bls	e4b8 <__udivdi3+0x1a8>
    e4a8:	e0911007 	adds	r1, r1, r7
    e4ac:	e24b2001 	sub	r2, fp, #1
    e4b0:	3a0000ab 	bcc	e764 <__udivdi3+0x454>
    e4b4:	e1a0b002 	mov	fp, r2
    e4b8:	e0603001 	rsb	r3, r0, r1
    e4bc:	e1a00003 	mov	r0, r3
    e4c0:	e1a01004 	mov	r1, r4
    e4c4:	e58d3004 	str	r3, [sp, #4]
    e4c8:	ebfffd86 	bl	dae8 <__aeabi_uidiv>
    e4cc:	e1a02000 	mov	r2, r0
    e4d0:	e59d3004 	ldr	r3, [sp, #4]
    e4d4:	e1a01004 	mov	r1, r4
    e4d8:	e1a00003 	mov	r0, r3
    e4dc:	e58d2004 	str	r2, [sp, #4]
    e4e0:	ebfffdbd 	bl	dbdc <__aeabi_uidivmod>
    e4e4:	e59d2004 	ldr	r2, [sp, #4]
    e4e8:	e00a0a92 	mul	sl, r2, sl
    e4ec:	e1a05805 	lsl	r5, r5, #16
    e4f0:	e1a05825 	lsr	r5, r5, #16
    e4f4:	e1851801 	orr	r1, r5, r1, lsl #16
    e4f8:	e15a0001 	cmp	sl, r1
    e4fc:	9a000003 	bls	e510 <__udivdi3+0x200>
    e500:	e0911007 	adds	r1, r1, r7
    e504:	e2423001 	sub	r3, r2, #1
    e508:	3a000090 	bcc	e750 <__udivdi3+0x440>
    e50c:	e1a02003 	mov	r2, r3
    e510:	e182080b 	orr	r0, r2, fp, lsl #16
	      umul_ppmm (m1, m0, q0, d0);
    e514:	e0854690 	umull	r4, r5, r0, r6
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
    e518:	e06aa001 	rsb	sl, sl, r1
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
    e51c:	e15a0005 	cmp	sl, r5
    e520:	3a000006 	bcc	e540 <__udivdi3+0x230>
    e524:	03a03001 	moveq	r3, #1
    e528:	13a03000 	movne	r3, #0
    e52c:	e1540819 	cmp	r4, r9, lsl r8
    e530:	93a08000 	movls	r8, #0
    e534:	82038001 	andhi	r8, r3, #1
    e538:	e3580000 	cmp	r8, #0
    e53c:	0affffb5 	beq	e418 <__udivdi3+0x108>
		{
		  q0--;
		  sub_ddmmss (m1, m0, m1, m0, d1, d0);
    e540:	e3a08000 	mov	r8, #0
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
    e544:	e1a01008 	mov	r1, r8
	      udiv_qrnnd (q0, n1, n2, n1, d1);
	      umul_ppmm (m1, m0, q0, d0);

	      if (m1 > n1 || (m1 == n1 && m0 > n0))
		{
		  q0--;
    e548:	e2400001 	sub	r0, r0, #1
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
    e54c:	e28dd00c 	add	sp, sp, #12
    e550:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e554:	e12fff1e 	bx	lr
	}
      else
	{
	  /* qq = NN / 0d */

	  if (d0 == 0)
    e558:	e3520000 	cmp	r2, #0
    e55c:	1a000003 	bne	e570 <__udivdi3+0x260>
	    d0 = 1 / d0;	/* Divide intentionally by zero.  */
    e560:	e1a01002 	mov	r1, r2
    e564:	e3a00001 	mov	r0, #1
    e568:	ebfffd5e 	bl	dae8 <__aeabi_uidiv>
    e56c:	e1a04000 	mov	r4, r0

	  count_leading_zeros (bm, d0);
    e570:	e1a00004 	mov	r0, r4
    e574:	eb000081 	bl	e780 <__clzsi2>

	  if (bm == 0)
    e578:	e2503000 	subs	r3, r0, #0
    e57c:	1a000038 	bne	e664 <__udivdi3+0x354>
		 leading quotient digit q1 = 1).

		 This special case is necessary, not an optimization.
		 (Shifts counts of W_TYPE_SIZE are undefined.)  */

	      n1 -= d0;
    e580:	e3a08001 	mov	r8, #1
    e584:	e1a07804 	lsl	r7, r4, #16
    e588:	e0645005 	rsb	r5, r4, r5
    e58c:	e1a07827 	lsr	r7, r7, #16
    e590:	e1a0b824 	lsr	fp, r4, #16
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
    e594:	e1a0100b 	mov	r1, fp
    e598:	e1a00005 	mov	r0, r5
    e59c:	ebfffd51 	bl	dae8 <__aeabi_uidiv>
    e5a0:	e1a06000 	mov	r6, r0
    e5a4:	e1a0100b 	mov	r1, fp
    e5a8:	e1a00005 	mov	r0, r5
    e5ac:	ebfffd8a 	bl	dbdc <__aeabi_uidivmod>
    e5b0:	e0000697 	mul	r0, r7, r6
    e5b4:	e1a0382a 	lsr	r3, sl, #16
    e5b8:	e1831801 	orr	r1, r3, r1, lsl #16
    e5bc:	e1500001 	cmp	r0, r1
    e5c0:	9a000006 	bls	e5e0 <__udivdi3+0x2d0>
    e5c4:	e0911004 	adds	r1, r1, r4
    e5c8:	e2462001 	sub	r2, r6, #1
    e5cc:	2a00005b 	bcs	e740 <__udivdi3+0x430>
    e5d0:	e1500001 	cmp	r0, r1
    e5d4:	82466002 	subhi	r6, r6, #2
    e5d8:	80811004 	addhi	r1, r1, r4
    e5dc:	9a000057 	bls	e740 <__udivdi3+0x430>
    e5e0:	e0609001 	rsb	r9, r0, r1
    e5e4:	e1a00009 	mov	r0, r9
    e5e8:	e1a0100b 	mov	r1, fp
    e5ec:	ebfffd3d 	bl	dae8 <__aeabi_uidiv>
    e5f0:	e1a05000 	mov	r5, r0
    e5f4:	e1a0100b 	mov	r1, fp
    e5f8:	e1a00009 	mov	r0, r9
    e5fc:	ebfffd76 	bl	dbdc <__aeabi_uidivmod>
    e600:	e0070795 	mul	r7, r5, r7
    e604:	e1a0a80a 	lsl	sl, sl, #16
    e608:	e1a0a82a 	lsr	sl, sl, #16
    e60c:	e18a1801 	orr	r1, sl, r1, lsl #16
    e610:	e1570001 	cmp	r7, r1
    e614:	9a000005 	bls	e630 <__udivdi3+0x320>
    e618:	e0914004 	adds	r4, r1, r4
    e61c:	e2453001 	sub	r3, r5, #1
    e620:	2a000048 	bcs	e748 <__udivdi3+0x438>
    e624:	e1570004 	cmp	r7, r4
    e628:	82455002 	subhi	r5, r5, #2
    e62c:	9a000045 	bls	e748 <__udivdi3+0x438>
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
    e630:	e1a01008 	mov	r1, r8
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
    e634:	e1850806 	orr	r0, r5, r6, lsl #16
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
    e638:	e28dd00c 	add	sp, sp, #12
    e63c:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e640:	e12fff1e 	bx	lr
	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
    e644:	e1570005 	cmp	r7, r5
    e648:	21560009 	cmpcs	r6, r9
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
    e64c:	e1a01008 	mov	r1, r8
	      /* The condition on the next line takes advantage of that
		 n1 >= d1 (true due to program flow).  */
	      if (n1 > d1 || n0 >= d0)
		{
		  q0 = 1;
		  sub_ddmmss (n1, n0, n1, n0, d1, d0);
    e650:	93a00001 	movls	r0, #1
    e654:	83a00000 	movhi	r0, #0
#ifdef L_udivdi3
UDWtype
__udivdi3 (UDWtype n, UDWtype d)
{
  return __udivmoddi4 (n, d, (UDWtype *) 0);
}
    e658:	e28dd00c 	add	sp, sp, #12
    e65c:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e660:	e12fff1e 	bx	lr
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
    e664:	e1a04314 	lsl	r4, r4, r3
	    }
	  else
	    {
	      /* Normalize.  */

	      b = W_TYPE_SIZE - bm;
    e668:	e2632020 	rsb	r2, r3, #32

	      d0 = d0 << bm;
	      n2 = n1 >> b;
    e66c:	e1a08235 	lsr	r8, r5, r2
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
    e670:	e1a0b824 	lsr	fp, r4, #16

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
    e674:	e1a02239 	lsr	r2, r9, r2
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
    e678:	e1a0100b 	mov	r1, fp
    e67c:	e1a00008 	mov	r0, r8

	      b = W_TYPE_SIZE - bm;

	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
    e680:	e1825315 	orr	r5, r2, r5, lsl r3
	      n0 = n0 << bm;
    e684:	e1a0a319 	lsl	sl, r9, r3

	      udiv_qrnnd (q1, n1, n2, n1, d0);
    e688:	ebfffd16 	bl	dae8 <__aeabi_uidiv>
    e68c:	e1a06000 	mov	r6, r0
    e690:	e1a0100b 	mov	r1, fp
    e694:	e1a00008 	mov	r0, r8
    e698:	ebfffd4f 	bl	dbdc <__aeabi_uidivmod>
    e69c:	e1a07804 	lsl	r7, r4, #16
    e6a0:	e1a07827 	lsr	r7, r7, #16
    e6a4:	e0000697 	mul	r0, r7, r6
    e6a8:	e1a03825 	lsr	r3, r5, #16
    e6ac:	e1831801 	orr	r1, r3, r1, lsl #16
    e6b0:	e1500001 	cmp	r0, r1
    e6b4:	9a000006 	bls	e6d4 <__udivdi3+0x3c4>
    e6b8:	e0911004 	adds	r1, r1, r4
    e6bc:	e2463001 	sub	r3, r6, #1
    e6c0:	2a00002c 	bcs	e778 <__udivdi3+0x468>
    e6c4:	e1500001 	cmp	r0, r1
    e6c8:	82466002 	subhi	r6, r6, #2
    e6cc:	80811004 	addhi	r1, r1, r4
    e6d0:	9a000028 	bls	e778 <__udivdi3+0x468>
    e6d4:	e0609001 	rsb	r9, r0, r1
    e6d8:	e1a00009 	mov	r0, r9
    e6dc:	e1a0100b 	mov	r1, fp
    e6e0:	ebfffd00 	bl	dae8 <__aeabi_uidiv>
    e6e4:	e1a08000 	mov	r8, r0
    e6e8:	e1a0100b 	mov	r1, fp
    e6ec:	e1a00009 	mov	r0, r9
    e6f0:	ebfffd39 	bl	dbdc <__aeabi_uidivmod>
    e6f4:	e0030897 	mul	r3, r7, r8
    e6f8:	e1a05805 	lsl	r5, r5, #16
    e6fc:	e1a05825 	lsr	r5, r5, #16
    e700:	e1851801 	orr	r1, r5, r1, lsl #16
    e704:	e1530001 	cmp	r3, r1
    e708:	9a000007 	bls	e72c <__udivdi3+0x41c>
    e70c:	e0911004 	adds	r1, r1, r4
    e710:	e2482001 	sub	r2, r8, #1
    e714:	2a000003 	bcs	e728 <__udivdi3+0x418>
    e718:	e1530001 	cmp	r3, r1
    e71c:	82488002 	subhi	r8, r8, #2
    e720:	80811004 	addhi	r1, r1, r4
    e724:	8a000000 	bhi	e72c <__udivdi3+0x41c>
    e728:	e1a08002 	mov	r8, r2
    e72c:	e0635001 	rsb	r5, r3, r1
    e730:	e1888806 	orr	r8, r8, r6, lsl #16
    e734:	eaffff96 	b	e594 <__udivdi3+0x284>
	      d0 = d0 << bm;
	      n1 = (n1 << bm) | (n0 >> (W_TYPE_SIZE - bm));
	      n0 = n0 << bm;
	    }

	  udiv_qrnnd (q0, n0, n1, n0, d0);
    e738:	e1a05003 	mov	r5, r3
    e73c:	eaffff33 	b	e410 <__udivdi3+0x100>
	      udiv_qrnnd (q1, n1, n2, n1, d0);
	    }

	  /* n1 != d0...  */

	  udiv_qrnnd (q0, n0, n1, n0, d0);
    e740:	e1a06002 	mov	r6, r2
    e744:	eaffffa5 	b	e5e0 <__udivdi3+0x2d0>
    e748:	e1a05003 	mov	r5, r3
    e74c:	eaffffb7 	b	e630 <__udivdi3+0x320>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q0, n1, n2, n1, d1);
    e750:	e15a0001 	cmp	sl, r1
    e754:	82422002 	subhi	r2, r2, #2
    e758:	80811007 	addhi	r1, r1, r7
    e75c:	8affff6b 	bhi	e510 <__udivdi3+0x200>
    e760:	eaffff69 	b	e50c <__udivdi3+0x1fc>
    e764:	e1500001 	cmp	r0, r1
    e768:	824bb002 	subhi	fp, fp, #2
    e76c:	80811007 	addhi	r1, r1, r7
    e770:	8affff50 	bhi	e4b8 <__udivdi3+0x1a8>
    e774:	eaffff4e 	b	e4b4 <__udivdi3+0x1a4>
	      d0 = d0 << bm;
	      n2 = n1 >> b;
	      n1 = (n1 << bm) | (n0 >> b);
	      n0 = n0 << bm;

	      udiv_qrnnd (q1, n1, n2, n1, d0);
    e778:	e1a06003 	mov	r6, r3
    e77c:	eaffffd4 	b	e6d4 <__udivdi3+0x3c4>

0000e780 <__clzsi2>:
ARM_FUNC_START clzsi2
# if defined(HAVE_ARM_CLZ)
	clz	r0, r0
	RET
# else
	mov	r1, #28
    e780:	e3a0101c 	mov	r1, #28
	cmp	r0, #0x10000
    e784:	e3500801 	cmp	r0, #65536	; 0x10000
	do_it	cs, t
	movcs	r0, r0, lsr #16
    e788:	21a00820 	lsrcs	r0, r0, #16
	subcs	r1, r1, #16
    e78c:	22411010 	subcs	r1, r1, #16
	cmp	r0, #0x100
    e790:	e3500c01 	cmp	r0, #256	; 0x100
	do_it	cs, t
	movcs	r0, r0, lsr #8
    e794:	21a00420 	lsrcs	r0, r0, #8
	subcs	r1, r1, #8
    e798:	22411008 	subcs	r1, r1, #8
	cmp	r0, #0x10
    e79c:	e3500010 	cmp	r0, #16
	do_it	cs, t
	movcs	r0, r0, lsr #4
    e7a0:	21a00220 	lsrcs	r0, r0, #4
	subcs	r1, r1, #4
    e7a4:	22411004 	subcs	r1, r1, #4
	adr	r2, 1f
    e7a8:	e28f2008 	add	r2, pc, #8
	ldrb	r0, [r2, r0]
    e7ac:	e7d20000 	ldrb	r0, [r2, r0]
	add	r0, r0, r1
    e7b0:	e0800001 	add	r0, r0, r1
	RET
    e7b4:	e12fff1e 	bx	lr
    e7b8:	02020304 	.word	0x02020304
    e7bc:	01010101 	.word	0x01010101
	...

0000e7c8 <abort>:
#include <unistd.h>
#include <signal.h>

_VOID
_DEFUN_VOID (abort)
{
    e7c8:	e92d4800 	push	{fp, lr}
    e7cc:	e28db004 	add	fp, sp, #4
  write (2, "Abort called\n", sizeof ("Abort called\n")-1);
#endif

  while (1)
    {
      raise (SIGABRT);
    e7d0:	e3a00006 	mov	r0, #6
    e7d4:	eb000799 	bl	10640 <raise>
      _exit (1);
    e7d8:	e3a00001 	mov	r0, #1
    e7dc:	eb000018 	bl	e844 <_exit>

0000e7e0 <close>:
#include <VirtualFileSystem/VirtualFileSystem.h>

int
_DEFUN (_close, (fildes),
        int fildes)
{
    e7e0:	e92d4800 	push	{fp, lr}
    e7e4:	e28db004 	add	fp, sp, #4
    e7e8:	e24dd010 	sub	sp, sp, #16
    e7ec:	e50b0010 	str	r0, [fp, #-16]
	status_t status = DNA_OK;
    e7f0:	e3a03000 	mov	r3, #0
    e7f4:	e14b30b6 	strh	r3, [fp, #-6]

  status = vfs_close (fildes);
    e7f8:	e51b3010 	ldr	r3, [fp, #-16]
    e7fc:	e1a03803 	lsl	r3, r3, #16
    e800:	e1a03823 	lsr	r3, r3, #16
    e804:	e1a03803 	lsl	r3, r3, #16
    e808:	e1a03843 	asr	r3, r3, #16
    e80c:	e1a00003 	mov	r0, r3
    e810:	ebffe5aa 	bl	7ec0 <vfs_close>
    e814:	e1a03000 	mov	r3, r0
    e818:	e14b30b6 	strh	r3, [fp, #-6]

	if (status == DNA_OK) return 0;
    e81c:	e15b30b6 	ldrh	r3, [fp, #-6]
    e820:	e3530000 	cmp	r3, #0
    e824:	1a000001 	bne	e830 <close+0x50>
    e828:	e3a03000 	mov	r3, #0
    e82c:	ea000000 	b	e834 <close+0x54>
	else return -1;
    e830:	e3e03000 	mvn	r3, #0
}
    e834:	e1a00003 	mov	r0, r3
    e838:	e24bd004 	sub	sp, fp, #4
    e83c:	e8bd4800 	pop	{fp, lr}
    e840:	e12fff1e 	bx	lr

0000e844 <_exit>:
#include <Core/Core.h>

_VOID
_DEFUN (_exit, (rc),
	int rc)
{
    e844:	e92d4800 	push	{fp, lr}
    e848:	e28db004 	add	fp, sp, #4
    e84c:	e24dd008 	sub	sp, sp, #8
    e850:	e50b0008 	str	r0, [fp, #-8]
	thread_exit (rc);
    e854:	e51b0008 	ldr	r0, [fp, #-8]
    e858:	ebfff47a 	bl	ba48 <thread_exit>

  /* Convince GCC that this function never returns.  */
  for (;;)
    ;
    e85c:	eafffffe 	b	e85c <_exit+0x18>

0000e860 <ioctl>:
#include <_syslist.h>
#include <stdarg.h>
#include <VirtualFileSystem/VirtualFileSystem.h>

int ioctl (int fd, int request,...)
{
    e860:	e92d000e 	push	{r1, r2, r3}
    e864:	e92d4800 	push	{fp, lr}
    e868:	e28db004 	add	fp, sp, #4
    e86c:	e24dd014 	sub	sp, sp, #20
    e870:	e50b0014 	str	r0, [fp, #-20]
    va_list ap;
    int32_t res;

    va_start (ap, request);
    e874:	e28b3008 	add	r3, fp, #8
    e878:	e50b300c 	str	r3, [fp, #-12]
    vfs_ioctl (fd, request, ap, & res);
    e87c:	e51b3014 	ldr	r3, [fp, #-20]
    e880:	e1a03803 	lsl	r3, r3, #16
    e884:	e1a03823 	lsr	r3, r3, #16
    e888:	e1a03803 	lsl	r3, r3, #16
    e88c:	e1a02843 	asr	r2, r3, #16
    e890:	e24b3010 	sub	r3, fp, #16
    e894:	e1a00002 	mov	r0, r2
    e898:	e59b1004 	ldr	r1, [fp, #4]
    e89c:	e51b200c 	ldr	r2, [fp, #-12]
    e8a0:	ebffe31c 	bl	7518 <vfs_ioctl>
    va_end (ap);

    return res;
    e8a4:	e51b3010 	ldr	r3, [fp, #-16]
}
    e8a8:	e1a00003 	mov	r0, r3
    e8ac:	e24bd004 	sub	sp, fp, #4
    e8b0:	e8bd4800 	pop	{fp, lr}
    e8b4:	e28dd00c 	add	sp, sp, #12
    e8b8:	e12fff1e 	bx	lr

0000e8bc <_dna_lock_init>:
volatile int32_t __sanity_sem = -1;

void
_DEFUN (_dna_lock_init, (lock),
        dna_lock_t * lock)
{
    e8bc:	e92d4810 	push	{r4, fp, lr}
    e8c0:	e28db008 	add	fp, sp, #8
    e8c4:	e24dd014 	sub	sp, sp, #20
    e8c8:	e50b0010 	str	r0, [fp, #-16]
//  cpu_dcache_inv_addr(&__sanity_sem);
  semaphore_acquire (__sanity_sem, 1, 0, -1);
    e8cc:	e59f308c 	ldr	r3, [pc, #140]	; e960 <_dna_lock_init+0xa4>
    e8d0:	e5932000 	ldr	r2, [r3]
    e8d4:	e3e03000 	mvn	r3, #0
    e8d8:	e3e04000 	mvn	r4, #0
    e8dc:	e88d0018 	stm	sp, {r3, r4}
    e8e0:	e1a00002 	mov	r0, r2
    e8e4:	e3a01001 	mov	r1, #1
    e8e8:	e3a02000 	mov	r2, #0
    e8ec:	ebfff336 	bl	b5cc <semaphore_acquire>

  if (lock -> id == -1 || lock -> id == 0) {
    e8f0:	e51b3010 	ldr	r3, [fp, #-16]
    e8f4:	e5933000 	ldr	r3, [r3]
    e8f8:	e3730001 	cmn	r3, #1
    e8fc:	0a000003 	beq	e910 <_dna_lock_init+0x54>
    e900:	e51b3010 	ldr	r3, [fp, #-16]
    e904:	e5933000 	ldr	r3, [r3]
    e908:	e3530000 	cmp	r3, #0
    e90c:	1a000008 	bne	e934 <_dna_lock_init+0x78>
    // TODO: comparing with 0 because impure_data structure is initialized with 0 ...
    semaphore_create ("libc_mutex", 1, & lock -> id);
    e910:	e51b3010 	ldr	r3, [fp, #-16]
    e914:	e59f0048 	ldr	r0, [pc, #72]	; e964 <_dna_lock_init+0xa8>
    e918:	e3a01001 	mov	r1, #1
    e91c:	e1a02003 	mov	r2, r3
    e920:	ebfff747 	bl	c644 <semaphore_create>
    lock -> count = 0;
    e924:	e51b3010 	ldr	r3, [fp, #-16]
    e928:	e3a02000 	mov	r2, #0
    e92c:	e5832004 	str	r2, [r3, #4]
    e930:	ea000001 	b	e93c <_dna_lock_init+0x80>
  }
  else {
    dna_printf("_dna_lock_init: warning, already initiliazed.\n");
    e934:	e59f002c 	ldr	r0, [pc, #44]	; e968 <_dna_lock_init+0xac>
    e938:	ebffe893 	bl	8b8c <dna_printf>
  }
//  cpu_dcache_inv_addr(&__sanity_sem);
  semaphore_release (__sanity_sem, 1, DNA_NO_RESCHEDULE);
    e93c:	e59f301c 	ldr	r3, [pc, #28]	; e960 <_dna_lock_init+0xa4>
    e940:	e5933000 	ldr	r3, [r3]
    e944:	e1a00003 	mov	r0, r3
    e948:	e3a01001 	mov	r1, #1
    e94c:	e3a02001 	mov	r2, #1
    e950:	ebfff7de 	bl	c8d0 <semaphore_release>
}
    e954:	e24bd008 	sub	sp, fp, #8
    e958:	e8bd4810 	pop	{r4, fp, lr}
    e95c:	e12fff1e 	bx	lr
    e960:	00024bd4 	.word	0x00024bd4
    e964:	000246a0 	.word	0x000246a0
    e968:	000246ac 	.word	0x000246ac

0000e96c <_dna_lock_close>:

void
_DEFUN (_dna_lock_close, (lock),
        dna_lock_t * lock)
{
    e96c:	e92d4810 	push	{r4, fp, lr}
    e970:	e28db008 	add	fp, sp, #8
    e974:	e24dd014 	sub	sp, sp, #20
    e978:	e50b0010 	str	r0, [fp, #-16]
//  cpu_dcache_inv_addr(&__sanity_sem);
  semaphore_acquire (__sanity_sem, 1, 0, -1);
    e97c:	e59f3078 	ldr	r3, [pc, #120]	; e9fc <_dna_lock_close+0x90>
    e980:	e5932000 	ldr	r2, [r3]
    e984:	e3e03000 	mvn	r3, #0
    e988:	e3e04000 	mvn	r4, #0
    e98c:	e88d0018 	stm	sp, {r3, r4}
    e990:	e1a00002 	mov	r0, r2
    e994:	e3a01001 	mov	r1, #1
    e998:	e3a02000 	mov	r2, #0
    e99c:	ebfff30a 	bl	b5cc <semaphore_acquire>

  if (lock -> id != -1)
    e9a0:	e51b3010 	ldr	r3, [fp, #-16]
    e9a4:	e5933000 	ldr	r3, [r3]
    e9a8:	e3730001 	cmn	r3, #1
    e9ac:	0a000009 	beq	e9d8 <_dna_lock_close+0x6c>
  {
    semaphore_destroy (lock -> id);
    e9b0:	e51b3010 	ldr	r3, [fp, #-16]
    e9b4:	e5933000 	ldr	r3, [r3]
    e9b8:	e1a00003 	mov	r0, r3
    e9bc:	ebffee17 	bl	a220 <semaphore_destroy>
    lock -> id = -1;
    e9c0:	e51b3010 	ldr	r3, [fp, #-16]
    e9c4:	e3e02000 	mvn	r2, #0
    e9c8:	e5832000 	str	r2, [r3]
    lock -> count = 0;
    e9cc:	e51b3010 	ldr	r3, [fp, #-16]
    e9d0:	e3a02000 	mov	r2, #0
    e9d4:	e5832004 	str	r2, [r3, #4]
  }
//  cpu_dcache_inv_addr(&__sanity_sem);
  semaphore_release (__sanity_sem, 1, DNA_NO_RESCHEDULE);
    e9d8:	e59f301c 	ldr	r3, [pc, #28]	; e9fc <_dna_lock_close+0x90>
    e9dc:	e5933000 	ldr	r3, [r3]
    e9e0:	e1a00003 	mov	r0, r3
    e9e4:	e3a01001 	mov	r1, #1
    e9e8:	e3a02001 	mov	r2, #1
    e9ec:	ebfff7b7 	bl	c8d0 <semaphore_release>
}
    e9f0:	e24bd008 	sub	sp, fp, #8
    e9f4:	e8bd4810 	pop	{r4, fp, lr}
    e9f8:	e12fff1e 	bx	lr
    e9fc:	00024bd4 	.word	0x00024bd4

0000ea00 <_dna_lock_acquire>:

void
_DEFUN (_dna_lock_acquire, (lock),
        dna_lock_t * lock)
{
    ea00:	e92d4810 	push	{r4, fp, lr}
    ea04:	e28db008 	add	fp, sp, #8
    ea08:	e24dd044 	sub	sp, sp, #68	; 0x44
    ea0c:	e50b0040 	str	r0, [fp, #-64]	; 0x40
  int32_t thread_id = -1;
    ea10:	e3e03000 	mvn	r3, #0
    ea14:	e50b3014 	str	r3, [fp, #-20]
  semaphore_info_t sem_info;
  status_t status = DNA_OK;
    ea18:	e3a03000 	mov	r3, #0
    ea1c:	e14b30be 	strh	r3, [fp, #-14]

  /*
   * We need to check the validity of the lock
   */
  cpu_dcache_invalidate((void*)&__sanity_sem, sizeof(volatile int32_t));
    ea20:	e59f0168 	ldr	r0, [pc, #360]	; eb90 <_dna_lock_acquire+0x190>
    ea24:	e3a01004 	mov	r1, #4
    ea28:	ebffeca0 	bl	9cb0 <cpu_dcache_invalidate>
  semaphore_acquire (__sanity_sem, 1, 0, -1);
    ea2c:	e59f315c 	ldr	r3, [pc, #348]	; eb90 <_dna_lock_acquire+0x190>
    ea30:	e5932000 	ldr	r2, [r3]
    ea34:	e3e03000 	mvn	r3, #0
    ea38:	e3e04000 	mvn	r4, #0
    ea3c:	e88d0018 	stm	sp, {r3, r4}
    ea40:	e1a00002 	mov	r0, r2
    ea44:	e3a01001 	mov	r1, #1
    ea48:	e3a02000 	mov	r2, #0
    ea4c:	ebfff2de 	bl	b5cc <semaphore_acquire>
//  cpu_dcache_inv_addr((void*)&lock->id);
  cpu_dcache_invalidate((void*)&lock->id,sizeof(int32_t));
    ea50:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
    ea54:	e1a00003 	mov	r0, r3
    ea58:	e3a01004 	mov	r1, #4
    ea5c:	ebffec93 	bl	9cb0 <cpu_dcache_invalidate>
  if (lock -> id == -1)
    ea60:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
    ea64:	e5933000 	ldr	r3, [r3]
    ea68:	e3730001 	cmn	r3, #1
    ea6c:	1a000007 	bne	ea90 <_dna_lock_acquire+0x90>
  {
    // TODO: semaphore should be initiliazed in a static way
    // (temporary solution for malloc)
    semaphore_create ("libc_mutex_static", 1, & lock -> id);
    ea70:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
    ea74:	e59f0118 	ldr	r0, [pc, #280]	; eb94 <_dna_lock_acquire+0x194>
    ea78:	e3a01001 	mov	r1, #1
    ea7c:	e1a02003 	mov	r2, r3
    ea80:	ebfff6ef 	bl	c644 <semaphore_create>
    lock -> count = 0;
    ea84:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
    ea88:	e3a02000 	mov	r2, #0
    ea8c:	e5832004 	str	r2, [r3, #4]
  }

  cpu_dcache_invalidate((void*)&__sanity_sem, sizeof(volatile int32_t));
    ea90:	e59f00f8 	ldr	r0, [pc, #248]	; eb90 <_dna_lock_acquire+0x190>
    ea94:	e3a01004 	mov	r1, #4
    ea98:	ebffec84 	bl	9cb0 <cpu_dcache_invalidate>
  semaphore_release (__sanity_sem, 1, DNA_NO_RESCHEDULE);
    ea9c:	e59f30ec 	ldr	r3, [pc, #236]	; eb90 <_dna_lock_acquire+0x190>
    eaa0:	e5933000 	ldr	r3, [r3]
    eaa4:	e1a00003 	mov	r0, r3
    eaa8:	e3a01001 	mov	r1, #1
    eaac:	e3a02001 	mov	r2, #1
    eab0:	ebfff786 	bl	c8d0 <semaphore_release>

  /*
   * And then we proceed
   */

  thread_find (NULL, & thread_id);
    eab4:	e24b3014 	sub	r3, fp, #20
    eab8:	e3a00000 	mov	r0, #0
    eabc:	e1a01003 	mov	r1, r3
    eac0:	ebfff94e 	bl	d000 <thread_find>

  status = semaphore_acquire (lock -> id, 1, DNA_RELATIVE_TIMEOUT, 0);
    eac4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
    eac8:	e5932000 	ldr	r2, [r3]
    eacc:	e3a03000 	mov	r3, #0
    ead0:	e3a04000 	mov	r4, #0
    ead4:	e88d0018 	stm	sp, {r3, r4}
    ead8:	e1a00002 	mov	r0, r2
    eadc:	e3a01001 	mov	r1, #1
    eae0:	e3a02002 	mov	r2, #2
    eae4:	ebfff2b8 	bl	b5cc <semaphore_acquire>
    eae8:	e1a03000 	mov	r3, r0
    eaec:	e14b30be 	strh	r3, [fp, #-14]
  semaphore_get_info (lock -> id, & sem_info);
    eaf0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
    eaf4:	e5932000 	ldr	r2, [r3]
    eaf8:	e24b303c 	sub	r3, fp, #60	; 0x3c
    eafc:	e1a00002 	mov	r0, r2
    eb00:	e1a01003 	mov	r1, r3
    eb04:	ebffed59 	bl	a070 <semaphore_get_info>
  
  if (status == DNA_WOULD_BLOCK)
    eb08:	e15b20be 	ldrh	r2, [fp, #-14]
    eb0c:	e59f3084 	ldr	r3, [pc, #132]	; eb98 <_dna_lock_acquire+0x198>
    eb10:	e1520003 	cmp	r2, r3
    eb14:	1a000010 	bne	eb5c <_dna_lock_acquire+0x15c>
  {
//    cpu_dcache_inv_addr((void*)&lock->count);
//    cpu_dcache_inv_addr((void*)&sem_info.latest_holder);
    if (sem_info . latest_holder != thread_id || lock -> count == 0)
    eb18:	e51b2018 	ldr	r2, [fp, #-24]
    eb1c:	e51b3014 	ldr	r3, [fp, #-20]
    eb20:	e1520003 	cmp	r2, r3
    eb24:	1a000003 	bne	eb38 <_dna_lock_acquire+0x138>
    eb28:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
    eb2c:	e5933004 	ldr	r3, [r3, #4]
    eb30:	e3530000 	cmp	r3, #0
    eb34:	1a000008 	bne	eb5c <_dna_lock_acquire+0x15c>
    {
//      cpu_dcache_inv_addr((void*)&lock->id);
      semaphore_acquire (lock -> id, 1, 0, -1);
    eb38:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
    eb3c:	e5932000 	ldr	r2, [r3]
    eb40:	e3e03000 	mvn	r3, #0
    eb44:	e3e04000 	mvn	r4, #0
    eb48:	e88d0018 	stm	sp, {r3, r4}
    eb4c:	e1a00002 	mov	r0, r2
    eb50:	e3a01001 	mov	r1, #1
    eb54:	e3a02000 	mov	r2, #0
    eb58:	ebfff29b 	bl	b5cc <semaphore_acquire>

  /*
   * Increase the usage counter.
   */
//  cpu_dcache_inv_addr(&lock->count);
  cpu_dcache_invalidate((void*)&(lock->count),sizeof(int32_t));
    eb5c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
    eb60:	e2833004 	add	r3, r3, #4
    eb64:	e1a00003 	mov	r0, r3
    eb68:	e3a01004 	mov	r1, #4
    eb6c:	ebffec4f 	bl	9cb0 <cpu_dcache_invalidate>

  lock -> count += 1;
    eb70:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
    eb74:	e5933004 	ldr	r3, [r3, #4]
    eb78:	e2832001 	add	r2, r3, #1
    eb7c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
    eb80:	e5832004 	str	r2, [r3, #4]
}
    eb84:	e24bd008 	sub	sp, fp, #8
    eb88:	e8bd4810 	pop	{r4, fp, lr}
    eb8c:	e12fff1e 	bx	lr
    eb90:	00024bd4 	.word	0x00024bd4
    eb94:	000246dc 	.word	0x000246dc
    eb98:	0000fdfd 	.word	0x0000fdfd

0000eb9c <_dna_lock_release>:

void
_DEFUN (_dna_lock_release, (lock),
        dna_lock_t * lock)
{
    eb9c:	e92d4800 	push	{fp, lr}
    eba0:	e28db004 	add	fp, sp, #4
    eba4:	e24dd008 	sub	sp, sp, #8
    eba8:	e50b0008 	str	r0, [fp, #-8]
  if (lock -> id != -1)
    ebac:	e51b3008 	ldr	r3, [fp, #-8]
    ebb0:	e5933000 	ldr	r3, [r3]
    ebb4:	e3730001 	cmn	r3, #1
    ebb8:	0a00000e 	beq	ebf8 <_dna_lock_release+0x5c>
  {
//    cpu_dcache_inv_addr((void*)&lock->count);
    lock -> count -= 1;
    ebbc:	e51b3008 	ldr	r3, [fp, #-8]
    ebc0:	e5933004 	ldr	r3, [r3, #4]
    ebc4:	e2432001 	sub	r2, r3, #1
    ebc8:	e51b3008 	ldr	r3, [fp, #-8]
    ebcc:	e5832004 	str	r2, [r3, #4]

    if (lock -> count == 0)
    ebd0:	e51b3008 	ldr	r3, [fp, #-8]
    ebd4:	e5933004 	ldr	r3, [r3, #4]
    ebd8:	e3530000 	cmp	r3, #0
    ebdc:	1a000005 	bne	ebf8 <_dna_lock_release+0x5c>
    {
      semaphore_release (lock -> id, 1, DNA_NO_RESCHEDULE);
    ebe0:	e51b3008 	ldr	r3, [fp, #-8]
    ebe4:	e5933000 	ldr	r3, [r3]
    ebe8:	e1a00003 	mov	r0, r3
    ebec:	e3a01001 	mov	r1, #1
    ebf0:	e3a02001 	mov	r2, #1
    ebf4:	ebfff735 	bl	c8d0 <semaphore_release>
    }
  }
}
    ebf8:	e24bd004 	sub	sp, fp, #4
    ebfc:	e8bd4800 	pop	{fp, lr}
    ec00:	e12fff1e 	bx	lr

0000ec04 <malloc>:
#ifndef _REENT_ONLY

_PTR
_DEFUN (malloc, (nbytes),
	size_t nbytes)		/* get a block */
{
    ec04:	e92d4800 	push	{fp, lr}
    ec08:	e28db004 	add	fp, sp, #4
    ec0c:	e24dd008 	sub	sp, sp, #8
    ec10:	e50b0008 	str	r0, [fp, #-8]
  return _malloc_r (_REENT, nbytes);
    ec14:	e59f3020 	ldr	r3, [pc, #32]	; ec3c <malloc+0x38>
    ec18:	e5933000 	ldr	r3, [r3]
    ec1c:	e1a00003 	mov	r0, r3
    ec20:	e51b1008 	ldr	r1, [fp, #-8]
    ec24:	eb000102 	bl	f034 <_malloc_r>
    ec28:	e1a03000 	mov	r3, r0
}
    ec2c:	e1a00003 	mov	r0, r3
    ec30:	e24bd004 	sub	sp, fp, #4
    ec34:	e8bd4800 	pop	{fp, lr}
    ec38:	e12fff1e 	bx	lr
    ec3c:	00025440 	.word	0x00025440

0000ec40 <free>:

void
_DEFUN (free, (aptr),
	_PTR aptr)
{
    ec40:	e92d4800 	push	{fp, lr}
    ec44:	e28db004 	add	fp, sp, #4
    ec48:	e24dd008 	sub	sp, sp, #8
    ec4c:	e50b0008 	str	r0, [fp, #-8]
  _free_r (_REENT, aptr);
    ec50:	e59f3018 	ldr	r3, [pc, #24]	; ec70 <free+0x30>
    ec54:	e5933000 	ldr	r3, [r3]
    ec58:	e1a00003 	mov	r0, r3
    ec5c:	e51b1008 	ldr	r1, [fp, #-8]
    ec60:	eb002b0d 	bl	1989c <_free_r>
}
    ec64:	e24bd004 	sub	sp, fp, #4
    ec68:	e8bd4800 	pop	{fp, lr}
    ec6c:	e12fff1e 	bx	lr
    ec70:	00025440 	.word	0x00025440

0000ec74 <malloc_extend_top>:
#if __STD_C
static void malloc_extend_top(RARG INTERNAL_SIZE_T nb)
#else
static void malloc_extend_top(RARG nb) RDECL INTERNAL_SIZE_T nb;
#endif
{
    ec74:	e92d4800 	push	{fp, lr}
    ec78:	e28db004 	add	fp, sp, #4
    ec7c:	e24dd038 	sub	sp, sp, #56	; 0x38
    ec80:	e50b0038 	str	r0, [fp, #-56]	; 0x38
    ec84:	e50b103c 	str	r1, [fp, #-60]	; 0x3c
  char*     brk;                  /* return value from sbrk */
  INTERNAL_SIZE_T front_misalign; /* unusable bytes at front of sbrked space */
  INTERNAL_SIZE_T correction;     /* bytes for 2nd sbrk call */
  int correction_failed = 0;      /* whether we should relax the assertion */
    ec88:	e3a03000 	mov	r3, #0
    ec8c:	e50b3018 	str	r3, [fp, #-24]
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
    ec90:	e59f3384 	ldr	r3, [pc, #900]	; f01c <malloc_extend_top+0x3a8>
    ec94:	e5933008 	ldr	r3, [r3, #8]
    ec98:	e50b301c 	str	r3, [fp, #-28]
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
    ec9c:	e51b301c 	ldr	r3, [fp, #-28]
    eca0:	e5933004 	ldr	r3, [r3, #4]
    eca4:	e3c33003 	bic	r3, r3, #3
    eca8:	e50b3020 	str	r3, [fp, #-32]
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
    ecac:	e51b201c 	ldr	r2, [fp, #-28]
    ecb0:	e51b3020 	ldr	r3, [fp, #-32]
    ecb4:	e0823003 	add	r3, r2, r3
    ecb8:	e50b3024 	str	r3, [fp, #-36]	; 0x24

  /* Pad request with top_pad plus minimal overhead */
  
  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
    ecbc:	e59f335c 	ldr	r3, [pc, #860]	; f020 <malloc_extend_top+0x3ac>
    ecc0:	e5932000 	ldr	r2, [r3]
    ecc4:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
    ecc8:	e0823003 	add	r3, r2, r3
    eccc:	e2833010 	add	r3, r3, #16
    ecd0:	e50b3014 	str	r3, [fp, #-20]
  unsigned long pagesz    = malloc_getpagesize;
    ecd4:	e3a03a01 	mov	r3, #4096	; 0x1000
    ecd8:	e50b3028 	str	r3, [fp, #-40]	; 0x28

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    ecdc:	e59f3340 	ldr	r3, [pc, #832]	; f024 <malloc_extend_top+0x3b0>
    ece0:	e5933000 	ldr	r3, [r3]
    ece4:	e3730001 	cmn	r3, #1
    ece8:	0a000007 	beq	ed0c <malloc_extend_top+0x98>
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
    ecec:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
    ecf0:	e51b3014 	ldr	r3, [fp, #-20]
    ecf4:	e0823003 	add	r3, r2, r3
    ecf8:	e2432001 	sub	r2, r3, #1
    ecfc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    ed00:	e2633000 	rsb	r3, r3, #0
    ed04:	e0033002 	and	r3, r3, r2
    ed08:	e50b3014 	str	r3, [fp, #-20]

  brk = (char*)(MORECORE (sbrk_size));
    ed0c:	e51b3014 	ldr	r3, [fp, #-20]
    ed10:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
    ed14:	e1a01003 	mov	r1, r3
    ed18:	eb00054f 	bl	1025c <_sbrk_r>
    ed1c:	e50b0008 	str	r0, [fp, #-8]

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) || 
    ed20:	e51b3008 	ldr	r3, [fp, #-8]
    ed24:	e3730001 	cmn	r3, #1
    ed28:	0a000007 	beq	ed4c <malloc_extend_top+0xd8>
    ed2c:	e51b2008 	ldr	r2, [fp, #-8]
    ed30:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    ed34:	e1520003 	cmp	r2, r3
    ed38:	2a000004 	bcs	ed50 <malloc_extend_top+0xdc>
      (brk < old_end && old_top != initial_top))
    ed3c:	e51b201c 	ldr	r2, [fp, #-28]
    ed40:	e59f32d4 	ldr	r3, [pc, #724]	; f01c <malloc_extend_top+0x3a8>
    ed44:	e1520003 	cmp	r2, r3
    ed48:	0a000000 	beq	ed50 <malloc_extend_top+0xdc>
    return;
    ed4c:	ea0000af 	b	f010 <malloc_extend_top+0x39c>

  sbrked_mem += sbrk_size;
    ed50:	e59f32d0 	ldr	r3, [pc, #720]	; f028 <malloc_extend_top+0x3b4>
    ed54:	e5933000 	ldr	r3, [r3]
    ed58:	e1a02003 	mov	r2, r3
    ed5c:	e51b3014 	ldr	r3, [fp, #-20]
    ed60:	e0823003 	add	r3, r2, r3
    ed64:	e1a02003 	mov	r2, r3
    ed68:	e59f32b8 	ldr	r3, [pc, #696]	; f028 <malloc_extend_top+0x3b4>
    ed6c:	e5832000 	str	r2, [r3]

  if (brk == old_end /* can just add bytes to current top, unless
    ed70:	e51b2008 	ldr	r2, [fp, #-8]
    ed74:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    ed78:	e1520003 	cmp	r2, r3
    ed7c:	1a00000f 	bne	edc0 <malloc_extend_top+0x14c>
			previous correction failed */
      && ((POINTER_UINT)old_end & (pagesz - 1)) == 0)
    ed80:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    ed84:	e2432001 	sub	r2, r3, #1
    ed88:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    ed8c:	e0033002 	and	r3, r3, r2
    ed90:	e3530000 	cmp	r3, #0
    ed94:	1a000009 	bne	edc0 <malloc_extend_top+0x14c>
  {
    top_size = sbrk_size + old_top_size;
    ed98:	e51b2014 	ldr	r2, [fp, #-20]
    ed9c:	e51b3020 	ldr	r3, [fp, #-32]
    eda0:	e0823003 	add	r3, r2, r3
    eda4:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    set_head(top, top_size | PREV_INUSE);
    eda8:	e59f326c 	ldr	r3, [pc, #620]	; f01c <malloc_extend_top+0x3a8>
    edac:	e5933008 	ldr	r3, [r3, #8]
    edb0:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
    edb4:	e3822001 	orr	r2, r2, #1
    edb8:	e5832004 	str	r2, [r3, #4]
    edbc:	ea00007b 	b	efb0 <malloc_extend_top+0x33c>
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
    edc0:	e59f325c 	ldr	r3, [pc, #604]	; f024 <malloc_extend_top+0x3b0>
    edc4:	e5933000 	ldr	r3, [r3]
    edc8:	e3730001 	cmn	r3, #1
    edcc:	1a000003 	bne	ede0 <malloc_extend_top+0x16c>
      sbrk_base = brk;
    edd0:	e59f324c 	ldr	r3, [pc, #588]	; f024 <malloc_extend_top+0x3b0>
    edd4:	e51b2008 	ldr	r2, [fp, #-8]
    edd8:	e5832000 	str	r2, [r3]
    eddc:	ea000007 	b	ee00 <malloc_extend_top+0x18c>
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
    ede0:	e59f3240 	ldr	r3, [pc, #576]	; f028 <malloc_extend_top+0x3b4>
    ede4:	e5932000 	ldr	r2, [r3]
    ede8:	e51b1008 	ldr	r1, [fp, #-8]
    edec:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    edf0:	e0633001 	rsb	r3, r3, r1
    edf4:	e0822003 	add	r2, r2, r3
    edf8:	e59f3228 	ldr	r3, [pc, #552]	; f028 <malloc_extend_top+0x3b4>
    edfc:	e5832000 	str	r2, [r3]

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (POINTER_UINT)chunk2mem(brk) & MALLOC_ALIGN_MASK;
    ee00:	e51b3008 	ldr	r3, [fp, #-8]
    ee04:	e2833008 	add	r3, r3, #8
    ee08:	e2033007 	and	r3, r3, #7
    ee0c:	e50b3030 	str	r3, [fp, #-48]	; 0x30
    if (front_misalign > 0) 
    ee10:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    ee14:	e3530000 	cmp	r3, #0
    ee18:	0a000007 	beq	ee3c <malloc_extend_top+0x1c8>
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
    ee1c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    ee20:	e2633008 	rsb	r3, r3, #8
    ee24:	e50b300c 	str	r3, [fp, #-12]
      brk += correction;
    ee28:	e51b2008 	ldr	r2, [fp, #-8]
    ee2c:	e51b300c 	ldr	r3, [fp, #-12]
    ee30:	e0823003 	add	r3, r2, r3
    ee34:	e50b3008 	str	r3, [fp, #-8]
    ee38:	ea000001 	b	ee44 <malloc_extend_top+0x1d0>
    }
    else
      correction = 0;
    ee3c:	e3a03000 	mov	r3, #0
    ee40:	e50b300c 	str	r3, [fp, #-12]

    /* Guarantee the next brk will be at a page boundary */
    correction += pagesz - ((POINTER_UINT)(brk + sbrk_size) & (pagesz - 1));
    ee44:	e51b2008 	ldr	r2, [fp, #-8]
    ee48:	e51b3014 	ldr	r3, [fp, #-20]
    ee4c:	e0823003 	add	r3, r2, r3
    ee50:	e1a02003 	mov	r2, r3
    ee54:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    ee58:	e2433001 	sub	r3, r3, #1
    ee5c:	e0033002 	and	r3, r3, r2
    ee60:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
    ee64:	e0633002 	rsb	r3, r3, r2
    ee68:	e51b200c 	ldr	r2, [fp, #-12]
    ee6c:	e0823003 	add	r3, r2, r3
    ee70:	e50b300c 	str	r3, [fp, #-12]

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    ee74:	e51b300c 	ldr	r3, [fp, #-12]
    ee78:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
    ee7c:	e1a01003 	mov	r1, r3
    ee80:	eb0004f5 	bl	1025c <_sbrk_r>
    ee84:	e50b0010 	str	r0, [fp, #-16]
    if (new_brk == (char*)(MORECORE_FAILURE))
    ee88:	e51b3010 	ldr	r3, [fp, #-16]
    ee8c:	e3730001 	cmn	r3, #1
    ee90:	1a000005 	bne	eeac <malloc_extend_top+0x238>
      {
	correction = 0;
    ee94:	e3a03000 	mov	r3, #0
    ee98:	e50b300c 	str	r3, [fp, #-12]
	correction_failed = 1;
    ee9c:	e3a03001 	mov	r3, #1
    eea0:	e50b3018 	str	r3, [fp, #-24]
	new_brk = brk;
    eea4:	e51b3008 	ldr	r3, [fp, #-8]
    eea8:	e50b3010 	str	r3, [fp, #-16]
      }

    sbrked_mem += correction;
    eeac:	e59f3174 	ldr	r3, [pc, #372]	; f028 <malloc_extend_top+0x3b4>
    eeb0:	e5933000 	ldr	r3, [r3]
    eeb4:	e1a02003 	mov	r2, r3
    eeb8:	e51b300c 	ldr	r3, [fp, #-12]
    eebc:	e0823003 	add	r3, r2, r3
    eec0:	e1a02003 	mov	r2, r3
    eec4:	e59f315c 	ldr	r3, [pc, #348]	; f028 <malloc_extend_top+0x3b4>
    eec8:	e5832000 	str	r2, [r3]

    top = (mchunkptr)brk;
    eecc:	e59f3148 	ldr	r3, [pc, #328]	; f01c <malloc_extend_top+0x3a8>
    eed0:	e51b2008 	ldr	r2, [fp, #-8]
    eed4:	e5832008 	str	r2, [r3, #8]
    top_size = new_brk - brk + correction;
    eed8:	e51b2010 	ldr	r2, [fp, #-16]
    eedc:	e51b3008 	ldr	r3, [fp, #-8]
    eee0:	e0633002 	rsb	r3, r3, r2
    eee4:	e1a02003 	mov	r2, r3
    eee8:	e51b300c 	ldr	r3, [fp, #-12]
    eeec:	e0823003 	add	r3, r2, r3
    eef0:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    set_head(top, top_size | PREV_INUSE);
    eef4:	e59f3120 	ldr	r3, [pc, #288]	; f01c <malloc_extend_top+0x3a8>
    eef8:	e5933008 	ldr	r3, [r3, #8]
    eefc:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
    ef00:	e3822001 	orr	r2, r2, #1
    ef04:	e5832004 	str	r2, [r3, #4]

    if (old_top != initial_top)
    ef08:	e51b201c 	ldr	r2, [fp, #-28]
    ef0c:	e59f3108 	ldr	r3, [pc, #264]	; f01c <malloc_extend_top+0x3a8>
    ef10:	e1520003 	cmp	r2, r3
    ef14:	0a000025 	beq	efb0 <malloc_extend_top+0x33c>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE) 
    ef18:	e51b3020 	ldr	r3, [fp, #-32]
    ef1c:	e353000f 	cmp	r3, #15
    ef20:	8a000004 	bhi	ef38 <malloc_extend_top+0x2c4>
      {
        set_head(top, PREV_INUSE); /* will force null return from malloc */
    ef24:	e59f30f0 	ldr	r3, [pc, #240]	; f01c <malloc_extend_top+0x3a8>
    ef28:	e5933008 	ldr	r3, [r3, #8]
    ef2c:	e3a02001 	mov	r2, #1
    ef30:	e5832004 	str	r2, [r3, #4]
        return;
    ef34:	ea000035 	b	f010 <malloc_extend_top+0x39c>
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
    ef38:	e51b3020 	ldr	r3, [fp, #-32]
    ef3c:	e243300c 	sub	r3, r3, #12
    ef40:	e3c33007 	bic	r3, r3, #7
    ef44:	e50b3020 	str	r3, [fp, #-32]
      set_head_size(old_top, old_top_size);
    ef48:	e51b301c 	ldr	r3, [fp, #-28]
    ef4c:	e5933004 	ldr	r3, [r3, #4]
    ef50:	e2032001 	and	r2, r3, #1
    ef54:	e51b3020 	ldr	r3, [fp, #-32]
    ef58:	e1822003 	orr	r2, r2, r3
    ef5c:	e51b301c 	ldr	r3, [fp, #-28]
    ef60:	e5832004 	str	r2, [r3, #4]
      chunk_at_offset(old_top, old_top_size          )->size =
    ef64:	e51b201c 	ldr	r2, [fp, #-28]
    ef68:	e51b3020 	ldr	r3, [fp, #-32]
    ef6c:	e0823003 	add	r3, r2, r3
    ef70:	e3a02005 	mov	r2, #5
    ef74:	e5832004 	str	r2, [r3, #4]
        SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
    ef78:	e51b3020 	ldr	r3, [fp, #-32]
    ef7c:	e2833004 	add	r3, r3, #4
    ef80:	e51b201c 	ldr	r2, [fp, #-28]
    ef84:	e0823003 	add	r3, r2, r3
    ef88:	e3a02005 	mov	r2, #5
    ef8c:	e5832004 	str	r2, [r3, #4]
        SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE) 
    ef90:	e51b3020 	ldr	r3, [fp, #-32]
    ef94:	e353000f 	cmp	r3, #15
    ef98:	9a000004 	bls	efb0 <malloc_extend_top+0x33c>
        fREe(RCALL chunk2mem(old_top));
    ef9c:	e51b301c 	ldr	r3, [fp, #-28]
    efa0:	e2833008 	add	r3, r3, #8
    efa4:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
    efa8:	e1a01003 	mov	r1, r3
    efac:	eb002a3a 	bl	1989c <_free_r>
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem) 
    efb0:	e59f3070 	ldr	r3, [pc, #112]	; f028 <malloc_extend_top+0x3b4>
    efb4:	e5933000 	ldr	r3, [r3]
    efb8:	e1a02003 	mov	r2, r3
    efbc:	e59f3068 	ldr	r3, [pc, #104]	; f02c <malloc_extend_top+0x3b8>
    efc0:	e5933000 	ldr	r3, [r3]
    efc4:	e1520003 	cmp	r2, r3
    efc8:	9a000004 	bls	efe0 <malloc_extend_top+0x36c>
    max_sbrked_mem = sbrked_mem;
    efcc:	e59f3054 	ldr	r3, [pc, #84]	; f028 <malloc_extend_top+0x3b4>
    efd0:	e5933000 	ldr	r3, [r3]
    efd4:	e1a02003 	mov	r2, r3
    efd8:	e59f304c 	ldr	r3, [pc, #76]	; f02c <malloc_extend_top+0x3b8>
    efdc:	e5832000 	str	r2, [r3]
#if HAVE_MMAP
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem) 
    max_total_mem = mmapped_mem + sbrked_mem;
#else
  if ((unsigned long)(sbrked_mem) > (unsigned long)max_total_mem) 
    efe0:	e59f3040 	ldr	r3, [pc, #64]	; f028 <malloc_extend_top+0x3b4>
    efe4:	e5933000 	ldr	r3, [r3]
    efe8:	e1a02003 	mov	r2, r3
    efec:	e59f303c 	ldr	r3, [pc, #60]	; f030 <malloc_extend_top+0x3bc>
    eff0:	e5933000 	ldr	r3, [r3]
    eff4:	e1520003 	cmp	r2, r3
    eff8:	9a000004 	bls	f010 <malloc_extend_top+0x39c>
    max_total_mem = sbrked_mem;
    effc:	e59f3024 	ldr	r3, [pc, #36]	; f028 <malloc_extend_top+0x3b4>
    f000:	e5933000 	ldr	r3, [r3]
    f004:	e1a02003 	mov	r2, r3
    f008:	e59f3020 	ldr	r3, [pc, #32]	; f030 <malloc_extend_top+0x3bc>
    f00c:	e5832000 	str	r2, [r3]
#endif

  /* We always land on a page boundary */
  assert(((unsigned long)((char*)top + top_size) & (pagesz - 1)) == 0
	 || correction_failed);
}
    f010:	e24bd004 	sub	sp, fp, #4
    f014:	e8bd4800 	pop	{fp, lr}
    f018:	e12fff1e 	bx	lr
    f01c:	00024bd8 	.word	0x00024bd8
    f020:	0003558c 	.word	0x0003558c
    f024:	00024fe4 	.word	0x00024fe4
    f028:	00035598 	.word	0x00035598
    f02c:	00035590 	.word	0x00035590
    f030:	00035594 	.word	0x00035594

0000f034 <_malloc_r>:
#if __STD_C
Void_t* mALLOc(RARG size_t bytes)
#else
Void_t* mALLOc(RARG bytes) RDECL size_t bytes;
#endif
{
    f034:	e92d4800 	push	{fp, lr}
    f038:	e28db004 	add	fp, sp, #4
    f03c:	e24dd040 	sub	sp, sp, #64	; 0x40
    f040:	e50b0040 	str	r0, [fp, #-64]	; 0x40
    f044:	e50b1044 	str	r1, [fp, #-68]	; 0x44
  int       startidx;                /* first bin of a traversed block */
  mchunkptr fwd;                     /* misc temp for linking */
  mchunkptr bck;                     /* misc temp for linking */
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb  = request2size(bytes);  /* padded request size; */
    f048:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
    f04c:	e283300b 	add	r3, r3, #11
    f050:	e3530016 	cmp	r3, #22
    f054:	9a000003 	bls	f068 <_malloc_r+0x34>
    f058:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
    f05c:	e283300b 	add	r3, r3, #11
    f060:	e3c33007 	bic	r3, r3, #7
    f064:	ea000000 	b	f06c <_malloc_r+0x38>
    f068:	e3a03010 	mov	r3, #16
    f06c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
    f070:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f074:	e3530000 	cmp	r3, #0
    f078:	ba000003 	blt	f08c <_malloc_r+0x58>
    f07c:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
    f080:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
    f084:	e1520003 	cmp	r2, r3
    f088:	2a000004 	bcs	f0a0 <_malloc_r+0x6c>
  {
    RERRNO = ENOMEM;
    f08c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
    f090:	e3a0200c 	mov	r2, #12
    f094:	e5832000 	str	r2, [r3]
    return 0;
    f098:	e3a03000 	mov	r3, #0
    f09c:	ea0002a4 	b	fb34 <_malloc_r+0xb00>
  }

  MALLOC_LOCK;
    f0a0:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
    f0a4:	eb000389 	bl	fed0 <__malloc_lock>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
    f0a8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f0ac:	e3530f7e 	cmp	r3, #504	; 0x1f8
    f0b0:	2a00003b 	bcs	f1a4 <_malloc_r+0x170>
  {
    idx = smallbin_index(nb); 
    f0b4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f0b8:	e1a031a3 	lsr	r3, r3, #3
    f0bc:	e50b300c 	str	r3, [fp, #-12]

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
    f0c0:	e51b300c 	ldr	r3, [fp, #-12]
    f0c4:	e1a03083 	lsl	r3, r3, #1
    f0c8:	e1a02103 	lsl	r2, r3, #2
    f0cc:	e59f3a70 	ldr	r3, [pc, #2672]	; fb44 <_malloc_r+0xb10>
    f0d0:	e0823003 	add	r3, r2, r3
    f0d4:	e50b3028 	str	r3, [fp, #-40]	; 0x28
    victim = last(q);
    f0d8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    f0dc:	e593300c 	ldr	r3, [r3, #12]
    f0e0:	e50b3008 	str	r3, [fp, #-8]

#if MALLOC_ALIGN != 16
    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
    f0e4:	e51b2008 	ldr	r2, [fp, #-8]
    f0e8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    f0ec:	e1520003 	cmp	r2, r3
    f0f0:	1a000005 	bne	f10c <_malloc_r+0xd8>
    {
      q = next_bin(q);
    f0f4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    f0f8:	e2833008 	add	r3, r3, #8
    f0fc:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      victim = last(q);
    f100:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    f104:	e593300c 	ldr	r3, [r3, #12]
    f108:	e50b3008 	str	r3, [fp, #-8]
    }
#endif
    if (victim != q)
    f10c:	e51b2008 	ldr	r2, [fp, #-8]
    f110:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    f114:	e1520003 	cmp	r2, r3
    f118:	0a00001d 	beq	f194 <_malloc_r+0x160>
    {
      victim_size = chunksize(victim);
    f11c:	e51b3008 	ldr	r3, [fp, #-8]
    f120:	e5933004 	ldr	r3, [r3, #4]
    f124:	e3c33003 	bic	r3, r3, #3
    f128:	e50b3030 	str	r3, [fp, #-48]	; 0x30
      unlink(victim, bck, fwd);
    f12c:	e51b3008 	ldr	r3, [fp, #-8]
    f130:	e593300c 	ldr	r3, [r3, #12]
    f134:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    f138:	e51b3008 	ldr	r3, [fp, #-8]
    f13c:	e5933008 	ldr	r3, [r3, #8]
    f140:	e50b3020 	str	r3, [fp, #-32]
    f144:	e51b3020 	ldr	r3, [fp, #-32]
    f148:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
    f14c:	e583200c 	str	r2, [r3, #12]
    f150:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    f154:	e51b2020 	ldr	r2, [fp, #-32]
    f158:	e5832008 	str	r2, [r3, #8]
      set_inuse_bit_at_offset(victim, victim_size);
    f15c:	e51b2008 	ldr	r2, [fp, #-8]
    f160:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f164:	e0823003 	add	r3, r2, r3
    f168:	e51b1008 	ldr	r1, [fp, #-8]
    f16c:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
    f170:	e0812002 	add	r2, r1, r2
    f174:	e5922004 	ldr	r2, [r2, #4]
    f178:	e3822001 	orr	r2, r2, #1
    f17c:	e5832004 	str	r2, [r3, #4]
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
    f180:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
    f184:	eb00035b 	bl	fef8 <__malloc_unlock>
      return chunk2mem(victim);
    f188:	e51b3008 	ldr	r3, [fp, #-8]
    f18c:	e2833008 	add	r3, r3, #8
    f190:	ea000267 	b	fb34 <_malloc_r+0xb00>
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
    f194:	e51b300c 	ldr	r3, [fp, #-12]
    f198:	e2833002 	add	r3, r3, #2
    f19c:	e50b300c 	str	r3, [fp, #-12]
    f1a0:	ea000071 	b	f36c <_malloc_r+0x338>

  }
  else
  {
    idx = bin_index(nb);
    f1a4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f1a8:	e1a034a3 	lsr	r3, r3, #9
    f1ac:	e3530000 	cmp	r3, #0
    f1b0:	1a000002 	bne	f1c0 <_malloc_r+0x18c>
    f1b4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f1b8:	e1a031a3 	lsr	r3, r3, #3
    f1bc:	ea000029 	b	f268 <_malloc_r+0x234>
    f1c0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f1c4:	e1a034a3 	lsr	r3, r3, #9
    f1c8:	e3530004 	cmp	r3, #4
    f1cc:	8a000003 	bhi	f1e0 <_malloc_r+0x1ac>
    f1d0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f1d4:	e1a03323 	lsr	r3, r3, #6
    f1d8:	e2833038 	add	r3, r3, #56	; 0x38
    f1dc:	ea000021 	b	f268 <_malloc_r+0x234>
    f1e0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f1e4:	e1a034a3 	lsr	r3, r3, #9
    f1e8:	e3530014 	cmp	r3, #20
    f1ec:	8a000003 	bhi	f200 <_malloc_r+0x1cc>
    f1f0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f1f4:	e1a034a3 	lsr	r3, r3, #9
    f1f8:	e283305b 	add	r3, r3, #91	; 0x5b
    f1fc:	ea000019 	b	f268 <_malloc_r+0x234>
    f200:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f204:	e1a034a3 	lsr	r3, r3, #9
    f208:	e3530054 	cmp	r3, #84	; 0x54
    f20c:	8a000003 	bhi	f220 <_malloc_r+0x1ec>
    f210:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f214:	e1a03623 	lsr	r3, r3, #12
    f218:	e283306e 	add	r3, r3, #110	; 0x6e
    f21c:	ea000011 	b	f268 <_malloc_r+0x234>
    f220:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f224:	e1a034a3 	lsr	r3, r3, #9
    f228:	e3530f55 	cmp	r3, #340	; 0x154
    f22c:	8a000003 	bhi	f240 <_malloc_r+0x20c>
    f230:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f234:	e1a037a3 	lsr	r3, r3, #15
    f238:	e2833077 	add	r3, r3, #119	; 0x77
    f23c:	ea000009 	b	f268 <_malloc_r+0x234>
    f240:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f244:	e1a024a3 	lsr	r2, r3, #9
    f248:	e59f38f8 	ldr	r3, [pc, #2296]	; fb48 <_malloc_r+0xb14>
    f24c:	e1520003 	cmp	r2, r3
    f250:	8a000003 	bhi	f264 <_malloc_r+0x230>
    f254:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f258:	e1a03923 	lsr	r3, r3, #18
    f25c:	e283307c 	add	r3, r3, #124	; 0x7c
    f260:	ea000000 	b	f268 <_malloc_r+0x234>
    f264:	e3a0307e 	mov	r3, #126	; 0x7e
    f268:	e50b300c 	str	r3, [fp, #-12]
    bin = bin_at(idx);
    f26c:	e51b300c 	ldr	r3, [fp, #-12]
    f270:	e1a03083 	lsl	r3, r3, #1
    f274:	e1a02103 	lsl	r2, r3, #2
    f278:	e59f38c4 	ldr	r3, [pc, #2244]	; fb44 <_malloc_r+0xb10>
    f27c:	e0823003 	add	r3, r2, r3
    f280:	e50b3010 	str	r3, [fp, #-16]

    for (victim = last(bin); victim != bin; victim = victim->bk)
    f284:	e51b3010 	ldr	r3, [fp, #-16]
    f288:	e593300c 	ldr	r3, [r3, #12]
    f28c:	e50b3008 	str	r3, [fp, #-8]
    f290:	ea00002e 	b	f350 <_malloc_r+0x31c>
    {
      victim_size = chunksize(victim);
    f294:	e51b3008 	ldr	r3, [fp, #-8]
    f298:	e5933004 	ldr	r3, [r3, #4]
    f29c:	e3c33003 	bic	r3, r3, #3
    f2a0:	e50b3030 	str	r3, [fp, #-48]	; 0x30
      remainder_size = long_sub_size_t(victim_size, nb);
    f2a4:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
    f2a8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f2ac:	e0633002 	rsb	r3, r3, r2
    f2b0:	e50b3014 	str	r3, [fp, #-20]
      
      if (remainder_size >= (long)MINSIZE) /* too big */
    f2b4:	e51b3014 	ldr	r3, [fp, #-20]
    f2b8:	e353000f 	cmp	r3, #15
    f2bc:	da000003 	ble	f2d0 <_malloc_r+0x29c>
      {
        --idx; /* adjust to rescan below after checking last remainder */
    f2c0:	e51b300c 	ldr	r3, [fp, #-12]
    f2c4:	e2433001 	sub	r3, r3, #1
    f2c8:	e50b300c 	str	r3, [fp, #-12]
        break;   
    f2cc:	ea000023 	b	f360 <_malloc_r+0x32c>
      }

      else if (remainder_size >= 0) /* exact fit */
    f2d0:	e51b3014 	ldr	r3, [fp, #-20]
    f2d4:	e3530000 	cmp	r3, #0
    f2d8:	ba000019 	blt	f344 <_malloc_r+0x310>
      {
        unlink(victim, bck, fwd);
    f2dc:	e51b3008 	ldr	r3, [fp, #-8]
    f2e0:	e593300c 	ldr	r3, [r3, #12]
    f2e4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    f2e8:	e51b3008 	ldr	r3, [fp, #-8]
    f2ec:	e5933008 	ldr	r3, [r3, #8]
    f2f0:	e50b3020 	str	r3, [fp, #-32]
    f2f4:	e51b3020 	ldr	r3, [fp, #-32]
    f2f8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
    f2fc:	e583200c 	str	r2, [r3, #12]
    f300:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    f304:	e51b2020 	ldr	r2, [fp, #-32]
    f308:	e5832008 	str	r2, [r3, #8]
        set_inuse_bit_at_offset(victim, victim_size);
    f30c:	e51b2008 	ldr	r2, [fp, #-8]
    f310:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f314:	e0823003 	add	r3, r2, r3
    f318:	e51b1008 	ldr	r1, [fp, #-8]
    f31c:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
    f320:	e0812002 	add	r2, r1, r2
    f324:	e5922004 	ldr	r2, [r2, #4]
    f328:	e3822001 	orr	r2, r2, #1
    f32c:	e5832004 	str	r2, [r3, #4]
        check_malloced_chunk(victim, nb);
	MALLOC_UNLOCK;
    f330:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
    f334:	eb0002ef 	bl	fef8 <__malloc_unlock>
        return chunk2mem(victim);
    f338:	e51b3008 	ldr	r3, [fp, #-8]
    f33c:	e2833008 	add	r3, r3, #8
    f340:	ea0001fb 	b	fb34 <_malloc_r+0xb00>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
    f344:	e51b3008 	ldr	r3, [fp, #-8]
    f348:	e593300c 	ldr	r3, [r3, #12]
    f34c:	e50b3008 	str	r3, [fp, #-8]
    f350:	e51b2008 	ldr	r2, [fp, #-8]
    f354:	e51b3010 	ldr	r3, [fp, #-16]
    f358:	e1520003 	cmp	r2, r3
    f35c:	1affffcc 	bne	f294 <_malloc_r+0x260>
	MALLOC_UNLOCK;
        return chunk2mem(victim);
      }
    }

    ++idx; 
    f360:	e51b300c 	ldr	r3, [fp, #-12]
    f364:	e2833001 	add	r3, r3, #1
    f368:	e50b300c 	str	r3, [fp, #-12]

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
    f36c:	e59f37d8 	ldr	r3, [pc, #2008]	; fb4c <_malloc_r+0xb18>
    f370:	e5933008 	ldr	r3, [r3, #8]
    f374:	e50b3008 	str	r3, [fp, #-8]
    f378:	e51b2008 	ldr	r2, [fp, #-8]
    f37c:	e59f37c8 	ldr	r3, [pc, #1992]	; fb4c <_malloc_r+0xb18>
    f380:	e1520003 	cmp	r2, r3
    f384:	0a0000da 	beq	f6f4 <_malloc_r+0x6c0>
  {
    victim_size = chunksize(victim);
    f388:	e51b3008 	ldr	r3, [fp, #-8]
    f38c:	e5933004 	ldr	r3, [r3, #4]
    f390:	e3c33003 	bic	r3, r3, #3
    f394:	e50b3030 	str	r3, [fp, #-48]	; 0x30
    remainder_size = long_sub_size_t(victim_size, nb);
    f398:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
    f39c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f3a0:	e0633002 	rsb	r3, r3, r2
    f3a4:	e50b3014 	str	r3, [fp, #-20]

    if (remainder_size >= (long)MINSIZE) /* re-split */
    f3a8:	e51b3014 	ldr	r3, [fp, #-20]
    f3ac:	e353000f 	cmp	r3, #15
    f3b0:	da000023 	ble	f444 <_malloc_r+0x410>
    {
      remainder = chunk_at_offset(victim, nb);
    f3b4:	e51b2008 	ldr	r2, [fp, #-8]
    f3b8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f3bc:	e0823003 	add	r3, r2, r3
    f3c0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
      set_head(victim, nb | PREV_INUSE);
    f3c4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f3c8:	e3832001 	orr	r2, r3, #1
    f3cc:	e51b3008 	ldr	r3, [fp, #-8]
    f3d0:	e5832004 	str	r2, [r3, #4]
      link_last_remainder(remainder);
    f3d4:	e59f2770 	ldr	r2, [pc, #1904]	; fb4c <_malloc_r+0xb18>
    f3d8:	e59f376c 	ldr	r3, [pc, #1900]	; fb4c <_malloc_r+0xb18>
    f3dc:	e51b1034 	ldr	r1, [fp, #-52]	; 0x34
    f3e0:	e583100c 	str	r1, [r3, #12]
    f3e4:	e593300c 	ldr	r3, [r3, #12]
    f3e8:	e5823008 	str	r3, [r2, #8]
    f3ec:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
    f3f0:	e59f2754 	ldr	r2, [pc, #1876]	; fb4c <_malloc_r+0xb18>
    f3f4:	e583200c 	str	r2, [r3, #12]
    f3f8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
    f3fc:	e593200c 	ldr	r2, [r3, #12]
    f400:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
    f404:	e5832008 	str	r2, [r3, #8]
      set_head(remainder, remainder_size | PREV_INUSE);
    f408:	e51b3014 	ldr	r3, [fp, #-20]
    f40c:	e3833001 	orr	r3, r3, #1
    f410:	e1a02003 	mov	r2, r3
    f414:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
    f418:	e5832004 	str	r2, [r3, #4]
      set_foot(remainder, remainder_size);
    f41c:	e51b3014 	ldr	r3, [fp, #-20]
    f420:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
    f424:	e0823003 	add	r3, r2, r3
    f428:	e51b2014 	ldr	r2, [fp, #-20]
    f42c:	e5832000 	str	r2, [r3]
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
    f430:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
    f434:	eb0002af 	bl	fef8 <__malloc_unlock>
      return chunk2mem(victim);
    f438:	e51b3008 	ldr	r3, [fp, #-8]
    f43c:	e2833008 	add	r3, r3, #8
    f440:	ea0001bb 	b	fb34 <_malloc_r+0xb00>
    }

    clear_last_remainder;
    f444:	e59f2700 	ldr	r2, [pc, #1792]	; fb4c <_malloc_r+0xb18>
    f448:	e59f36fc 	ldr	r3, [pc, #1788]	; fb4c <_malloc_r+0xb18>
    f44c:	e59f16f8 	ldr	r1, [pc, #1784]	; fb4c <_malloc_r+0xb18>
    f450:	e583100c 	str	r1, [r3, #12]
    f454:	e593300c 	ldr	r3, [r3, #12]
    f458:	e5823008 	str	r3, [r2, #8]

    if (remainder_size >= 0)  /* exhaust */
    f45c:	e51b3014 	ldr	r3, [fp, #-20]
    f460:	e3530000 	cmp	r3, #0
    f464:	ba00000d 	blt	f4a0 <_malloc_r+0x46c>
    {
      set_inuse_bit_at_offset(victim, victim_size);
    f468:	e51b2008 	ldr	r2, [fp, #-8]
    f46c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f470:	e0823003 	add	r3, r2, r3
    f474:	e51b1008 	ldr	r1, [fp, #-8]
    f478:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
    f47c:	e0812002 	add	r2, r1, r2
    f480:	e5922004 	ldr	r2, [r2, #4]
    f484:	e3822001 	orr	r2, r2, #1
    f488:	e5832004 	str	r2, [r3, #4]
      check_malloced_chunk(victim, nb);
      MALLOC_UNLOCK;
    f48c:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
    f490:	eb000298 	bl	fef8 <__malloc_unlock>
      return chunk2mem(victim);
    f494:	e51b3008 	ldr	r3, [fp, #-8]
    f498:	e2833008 	add	r3, r3, #8
    f49c:	ea0001a4 	b	fb34 <_malloc_r+0xb00>
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
    f4a0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f4a4:	e3530c02 	cmp	r3, #512	; 0x200
    f4a8:	2a000026 	bcs	f548 <_malloc_r+0x514>
    f4ac:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f4b0:	e1a031a3 	lsr	r3, r3, #3
    f4b4:	e50b3038 	str	r3, [fp, #-56]	; 0x38
    f4b8:	e59f2684 	ldr	r2, [pc, #1668]	; fb44 <_malloc_r+0xb10>
    f4bc:	e59f3680 	ldr	r3, [pc, #1664]	; fb44 <_malloc_r+0xb10>
    f4c0:	e5931004 	ldr	r1, [r3, #4]
    f4c4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
    f4c8:	e2830003 	add	r0, r3, #3
    f4cc:	e3530000 	cmp	r3, #0
    f4d0:	b1a03000 	movlt	r3, r0
    f4d4:	a1a03003 	movge	r3, r3
    f4d8:	e1a03143 	asr	r3, r3, #2
    f4dc:	e3a00001 	mov	r0, #1
    f4e0:	e1a03310 	lsl	r3, r0, r3
    f4e4:	e1813003 	orr	r3, r1, r3
    f4e8:	e5823004 	str	r3, [r2, #4]
    f4ec:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
    f4f0:	e1a03083 	lsl	r3, r3, #1
    f4f4:	e1a02103 	lsl	r2, r3, #2
    f4f8:	e59f3644 	ldr	r3, [pc, #1604]	; fb44 <_malloc_r+0xb10>
    f4fc:	e0823003 	add	r3, r2, r3
    f500:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    f504:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    f508:	e5933008 	ldr	r3, [r3, #8]
    f50c:	e50b3020 	str	r3, [fp, #-32]
    f510:	e51b3008 	ldr	r3, [fp, #-8]
    f514:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
    f518:	e583200c 	str	r2, [r3, #12]
    f51c:	e51b3008 	ldr	r3, [fp, #-8]
    f520:	e51b2020 	ldr	r2, [fp, #-32]
    f524:	e5832008 	str	r2, [r3, #8]
    f528:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    f52c:	e51b2008 	ldr	r2, [fp, #-8]
    f530:	e5832008 	str	r2, [r3, #8]
    f534:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    f538:	e5932008 	ldr	r2, [r3, #8]
    f53c:	e51b3020 	ldr	r3, [fp, #-32]
    f540:	e583200c 	str	r2, [r3, #12]
    f544:	ea00006a 	b	f6f4 <_malloc_r+0x6c0>
    f548:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f54c:	e1a034a3 	lsr	r3, r3, #9
    f550:	e3530000 	cmp	r3, #0
    f554:	1a000002 	bne	f564 <_malloc_r+0x530>
    f558:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f55c:	e1a031a3 	lsr	r3, r3, #3
    f560:	ea000029 	b	f60c <_malloc_r+0x5d8>
    f564:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f568:	e1a034a3 	lsr	r3, r3, #9
    f56c:	e3530004 	cmp	r3, #4
    f570:	8a000003 	bhi	f584 <_malloc_r+0x550>
    f574:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f578:	e1a03323 	lsr	r3, r3, #6
    f57c:	e2833038 	add	r3, r3, #56	; 0x38
    f580:	ea000021 	b	f60c <_malloc_r+0x5d8>
    f584:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f588:	e1a034a3 	lsr	r3, r3, #9
    f58c:	e3530014 	cmp	r3, #20
    f590:	8a000003 	bhi	f5a4 <_malloc_r+0x570>
    f594:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f598:	e1a034a3 	lsr	r3, r3, #9
    f59c:	e283305b 	add	r3, r3, #91	; 0x5b
    f5a0:	ea000019 	b	f60c <_malloc_r+0x5d8>
    f5a4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f5a8:	e1a034a3 	lsr	r3, r3, #9
    f5ac:	e3530054 	cmp	r3, #84	; 0x54
    f5b0:	8a000003 	bhi	f5c4 <_malloc_r+0x590>
    f5b4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f5b8:	e1a03623 	lsr	r3, r3, #12
    f5bc:	e283306e 	add	r3, r3, #110	; 0x6e
    f5c0:	ea000011 	b	f60c <_malloc_r+0x5d8>
    f5c4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f5c8:	e1a034a3 	lsr	r3, r3, #9
    f5cc:	e3530f55 	cmp	r3, #340	; 0x154
    f5d0:	8a000003 	bhi	f5e4 <_malloc_r+0x5b0>
    f5d4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f5d8:	e1a037a3 	lsr	r3, r3, #15
    f5dc:	e2833077 	add	r3, r3, #119	; 0x77
    f5e0:	ea000009 	b	f60c <_malloc_r+0x5d8>
    f5e4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f5e8:	e1a024a3 	lsr	r2, r3, #9
    f5ec:	e59f3554 	ldr	r3, [pc, #1364]	; fb48 <_malloc_r+0xb14>
    f5f0:	e1520003 	cmp	r2, r3
    f5f4:	8a000003 	bhi	f608 <_malloc_r+0x5d4>
    f5f8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f5fc:	e1a03923 	lsr	r3, r3, #18
    f600:	e283307c 	add	r3, r3, #124	; 0x7c
    f604:	ea000000 	b	f60c <_malloc_r+0x5d8>
    f608:	e3a0307e 	mov	r3, #126	; 0x7e
    f60c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
    f610:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
    f614:	e1a03083 	lsl	r3, r3, #1
    f618:	e1a02103 	lsl	r2, r3, #2
    f61c:	e59f3520 	ldr	r3, [pc, #1312]	; fb44 <_malloc_r+0xb10>
    f620:	e0823003 	add	r3, r2, r3
    f624:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    f628:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    f62c:	e5933008 	ldr	r3, [r3, #8]
    f630:	e50b3020 	str	r3, [fp, #-32]
    f634:	e51b2020 	ldr	r2, [fp, #-32]
    f638:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    f63c:	e1520003 	cmp	r2, r3
    f640:	1a00000d 	bne	f67c <_malloc_r+0x648>
    f644:	e59f24f8 	ldr	r2, [pc, #1272]	; fb44 <_malloc_r+0xb10>
    f648:	e59f34f4 	ldr	r3, [pc, #1268]	; fb44 <_malloc_r+0xb10>
    f64c:	e5931004 	ldr	r1, [r3, #4]
    f650:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
    f654:	e2830003 	add	r0, r3, #3
    f658:	e3530000 	cmp	r3, #0
    f65c:	b1a03000 	movlt	r3, r0
    f660:	a1a03003 	movge	r3, r3
    f664:	e1a03143 	asr	r3, r3, #2
    f668:	e3a00001 	mov	r0, #1
    f66c:	e1a03310 	lsl	r3, r0, r3
    f670:	e1813003 	orr	r3, r1, r3
    f674:	e5823004 	str	r3, [r2, #4]
    f678:	ea000010 	b	f6c0 <_malloc_r+0x68c>
    f67c:	ea000002 	b	f68c <_malloc_r+0x658>
    f680:	e51b3020 	ldr	r3, [fp, #-32]
    f684:	e5933008 	ldr	r3, [r3, #8]
    f688:	e50b3020 	str	r3, [fp, #-32]
    f68c:	e51b2020 	ldr	r2, [fp, #-32]
    f690:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    f694:	e1520003 	cmp	r2, r3
    f698:	0a000005 	beq	f6b4 <_malloc_r+0x680>
    f69c:	e51b3020 	ldr	r3, [fp, #-32]
    f6a0:	e5933004 	ldr	r3, [r3, #4]
    f6a4:	e3c32003 	bic	r2, r3, #3
    f6a8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f6ac:	e1520003 	cmp	r2, r3
    f6b0:	8afffff2 	bhi	f680 <_malloc_r+0x64c>
    f6b4:	e51b3020 	ldr	r3, [fp, #-32]
    f6b8:	e593300c 	ldr	r3, [r3, #12]
    f6bc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    f6c0:	e51b3008 	ldr	r3, [fp, #-8]
    f6c4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
    f6c8:	e583200c 	str	r2, [r3, #12]
    f6cc:	e51b3008 	ldr	r3, [fp, #-8]
    f6d0:	e51b2020 	ldr	r2, [fp, #-32]
    f6d4:	e5832008 	str	r2, [r3, #8]
    f6d8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    f6dc:	e51b2008 	ldr	r2, [fp, #-8]
    f6e0:	e5832008 	str	r2, [r3, #8]
    f6e4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    f6e8:	e5932008 	ldr	r2, [r3, #8]
    f6ec:	e51b3020 	ldr	r3, [fp, #-32]
    f6f0:	e583200c 	str	r2, [r3, #12]
  /* 
     If there are any possibly nonempty big-enough blocks, 
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks)  
    f6f4:	e51b300c 	ldr	r3, [fp, #-12]
    f6f8:	e2832003 	add	r2, r3, #3
    f6fc:	e3530000 	cmp	r3, #0
    f700:	b1a03002 	movlt	r3, r2
    f704:	a1a03003 	movge	r3, r3
    f708:	e1a03143 	asr	r3, r3, #2
    f70c:	e3a02001 	mov	r2, #1
    f710:	e1a03312 	lsl	r3, r2, r3
    f714:	e50b3018 	str	r3, [fp, #-24]
    f718:	e59f3424 	ldr	r3, [pc, #1060]	; fb44 <_malloc_r+0xb10>
    f71c:	e5933004 	ldr	r3, [r3, #4]
    f720:	e51b2018 	ldr	r2, [fp, #-24]
    f724:	e1520003 	cmp	r2, r3
    f728:	8a0000c0 	bhi	fa30 <_malloc_r+0x9fc>
  {

    /* Get to the first marked block */

    if ( (block & binblocks) == 0) 
    f72c:	e59f3410 	ldr	r3, [pc, #1040]	; fb44 <_malloc_r+0xb10>
    f730:	e5932004 	ldr	r2, [r3, #4]
    f734:	e51b3018 	ldr	r3, [fp, #-24]
    f738:	e0033002 	and	r3, r3, r2
    f73c:	e3530000 	cmp	r3, #0
    f740:	1a000013 	bne	f794 <_malloc_r+0x760>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
    f744:	e51b300c 	ldr	r3, [fp, #-12]
    f748:	e3c33003 	bic	r3, r3, #3
    f74c:	e2833004 	add	r3, r3, #4
    f750:	e50b300c 	str	r3, [fp, #-12]
      block <<= 1;
    f754:	e51b3018 	ldr	r3, [fp, #-24]
    f758:	e1a03083 	lsl	r3, r3, #1
    f75c:	e50b3018 	str	r3, [fp, #-24]
      while ((block & binblocks) == 0)
    f760:	ea000005 	b	f77c <_malloc_r+0x748>
      {
        idx += BINBLOCKWIDTH;
    f764:	e51b300c 	ldr	r3, [fp, #-12]
    f768:	e2833004 	add	r3, r3, #4
    f76c:	e50b300c 	str	r3, [fp, #-12]
        block <<= 1;
    f770:	e51b3018 	ldr	r3, [fp, #-24]
    f774:	e1a03083 	lsl	r3, r3, #1
    f778:	e50b3018 	str	r3, [fp, #-24]
    if ( (block & binblocks) == 0) 
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks) == 0)
    f77c:	e59f33c0 	ldr	r3, [pc, #960]	; fb44 <_malloc_r+0xb10>
    f780:	e5932004 	ldr	r2, [r3, #4]
    f784:	e51b3018 	ldr	r3, [fp, #-24]
    f788:	e0033002 	and	r3, r3, r2
    f78c:	e3530000 	cmp	r3, #0
    f790:	0afffff3 	beq	f764 <_malloc_r+0x730>
    }
      
    /* For each possibly nonempty block ... */
    for (;;)  
    {
      startidx = idx;          /* (track incomplete blocks) */
    f794:	e51b300c 	ldr	r3, [fp, #-12]
    f798:	e50b301c 	str	r3, [fp, #-28]
      q = bin = bin_at(idx);
    f79c:	e51b300c 	ldr	r3, [fp, #-12]
    f7a0:	e1a03083 	lsl	r3, r3, #1
    f7a4:	e1a02103 	lsl	r2, r3, #2
    f7a8:	e59f3394 	ldr	r3, [pc, #916]	; fb44 <_malloc_r+0xb10>
    f7ac:	e0823003 	add	r3, r2, r3
    f7b0:	e50b3010 	str	r3, [fp, #-16]
    f7b4:	e51b3010 	ldr	r3, [fp, #-16]
    f7b8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
    f7bc:	e51b3010 	ldr	r3, [fp, #-16]
    f7c0:	e593300c 	ldr	r3, [r3, #12]
    f7c4:	e50b3008 	str	r3, [fp, #-8]
    f7c8:	ea00005a 	b	f938 <_malloc_r+0x904>
        {
          victim_size = chunksize(victim);
    f7cc:	e51b3008 	ldr	r3, [fp, #-8]
    f7d0:	e5933004 	ldr	r3, [r3, #4]
    f7d4:	e3c33003 	bic	r3, r3, #3
    f7d8:	e50b3030 	str	r3, [fp, #-48]	; 0x30
          remainder_size = long_sub_size_t(victim_size, nb);
    f7dc:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
    f7e0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f7e4:	e0633002 	rsb	r3, r3, r2
    f7e8:	e50b3014 	str	r3, [fp, #-20]

          if (remainder_size >= (long)MINSIZE) /* split */
    f7ec:	e51b3014 	ldr	r3, [fp, #-20]
    f7f0:	e353000f 	cmp	r3, #15
    f7f4:	da00002f 	ble	f8b8 <_malloc_r+0x884>
          {
            remainder = chunk_at_offset(victim, nb);
    f7f8:	e51b2008 	ldr	r2, [fp, #-8]
    f7fc:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f800:	e0823003 	add	r3, r2, r3
    f804:	e50b3034 	str	r3, [fp, #-52]	; 0x34
            set_head(victim, nb | PREV_INUSE);
    f808:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    f80c:	e3832001 	orr	r2, r3, #1
    f810:	e51b3008 	ldr	r3, [fp, #-8]
    f814:	e5832004 	str	r2, [r3, #4]
            unlink(victim, bck, fwd);
    f818:	e51b3008 	ldr	r3, [fp, #-8]
    f81c:	e593300c 	ldr	r3, [r3, #12]
    f820:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    f824:	e51b3008 	ldr	r3, [fp, #-8]
    f828:	e5933008 	ldr	r3, [r3, #8]
    f82c:	e50b3020 	str	r3, [fp, #-32]
    f830:	e51b3020 	ldr	r3, [fp, #-32]
    f834:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
    f838:	e583200c 	str	r2, [r3, #12]
    f83c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    f840:	e51b2020 	ldr	r2, [fp, #-32]
    f844:	e5832008 	str	r2, [r3, #8]
            link_last_remainder(remainder);
    f848:	e59f22fc 	ldr	r2, [pc, #764]	; fb4c <_malloc_r+0xb18>
    f84c:	e59f32f8 	ldr	r3, [pc, #760]	; fb4c <_malloc_r+0xb18>
    f850:	e51b1034 	ldr	r1, [fp, #-52]	; 0x34
    f854:	e583100c 	str	r1, [r3, #12]
    f858:	e593300c 	ldr	r3, [r3, #12]
    f85c:	e5823008 	str	r3, [r2, #8]
    f860:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
    f864:	e59f22e0 	ldr	r2, [pc, #736]	; fb4c <_malloc_r+0xb18>
    f868:	e583200c 	str	r2, [r3, #12]
    f86c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
    f870:	e593200c 	ldr	r2, [r3, #12]
    f874:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
    f878:	e5832008 	str	r2, [r3, #8]
            set_head(remainder, remainder_size | PREV_INUSE);
    f87c:	e51b3014 	ldr	r3, [fp, #-20]
    f880:	e3833001 	orr	r3, r3, #1
    f884:	e1a02003 	mov	r2, r3
    f888:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
    f88c:	e5832004 	str	r2, [r3, #4]
            set_foot(remainder, remainder_size);
    f890:	e51b3014 	ldr	r3, [fp, #-20]
    f894:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
    f898:	e0823003 	add	r3, r2, r3
    f89c:	e51b2014 	ldr	r2, [fp, #-20]
    f8a0:	e5832000 	str	r2, [r3]
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
    f8a4:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
    f8a8:	eb000192 	bl	fef8 <__malloc_unlock>
            return chunk2mem(victim);
    f8ac:	e51b3008 	ldr	r3, [fp, #-8]
    f8b0:	e2833008 	add	r3, r3, #8
    f8b4:	ea00009e 	b	fb34 <_malloc_r+0xb00>
          }

          else if (remainder_size >= 0)  /* take */
    f8b8:	e51b3014 	ldr	r3, [fp, #-20]
    f8bc:	e3530000 	cmp	r3, #0
    f8c0:	ba000019 	blt	f92c <_malloc_r+0x8f8>
          {
            set_inuse_bit_at_offset(victim, victim_size);
    f8c4:	e51b2008 	ldr	r2, [fp, #-8]
    f8c8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
    f8cc:	e0823003 	add	r3, r2, r3
    f8d0:	e51b1008 	ldr	r1, [fp, #-8]
    f8d4:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
    f8d8:	e0812002 	add	r2, r1, r2
    f8dc:	e5922004 	ldr	r2, [r2, #4]
    f8e0:	e3822001 	orr	r2, r2, #1
    f8e4:	e5832004 	str	r2, [r3, #4]
            unlink(victim, bck, fwd);
    f8e8:	e51b3008 	ldr	r3, [fp, #-8]
    f8ec:	e593300c 	ldr	r3, [r3, #12]
    f8f0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    f8f4:	e51b3008 	ldr	r3, [fp, #-8]
    f8f8:	e5933008 	ldr	r3, [r3, #8]
    f8fc:	e50b3020 	str	r3, [fp, #-32]
    f900:	e51b3020 	ldr	r3, [fp, #-32]
    f904:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
    f908:	e583200c 	str	r2, [r3, #12]
    f90c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    f910:	e51b2020 	ldr	r2, [fp, #-32]
    f914:	e5832008 	str	r2, [r3, #8]
            check_malloced_chunk(victim, nb);
	    MALLOC_UNLOCK;
    f918:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
    f91c:	eb000175 	bl	fef8 <__malloc_unlock>
            return chunk2mem(victim);
    f920:	e51b3008 	ldr	r3, [fp, #-8]
    f924:	e2833008 	add	r3, r3, #8
    f928:	ea000081 	b	fb34 <_malloc_r+0xb00>
      /* For each bin in this block ... */
      do
      {
        /* Find and use first big enough chunk ... */

        for (victim = last(bin); victim != bin; victim = victim->bk)
    f92c:	e51b3008 	ldr	r3, [fp, #-8]
    f930:	e593300c 	ldr	r3, [r3, #12]
    f934:	e50b3008 	str	r3, [fp, #-8]
    f938:	e51b2008 	ldr	r2, [fp, #-8]
    f93c:	e51b3010 	ldr	r3, [fp, #-16]
    f940:	e1520003 	cmp	r2, r3
    f944:	1affffa0 	bne	f7cc <_malloc_r+0x798>
            return chunk2mem(victim);
          }

        }

       bin = next_bin(bin);
    f948:	e51b3010 	ldr	r3, [fp, #-16]
    f94c:	e2833008 	add	r3, r3, #8
    f950:	e50b3010 	str	r3, [fp, #-16]
         {
           bin = next_bin(bin);
           ++idx;
         }
#endif
      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
    f954:	e51b300c 	ldr	r3, [fp, #-12]
    f958:	e2833001 	add	r3, r3, #1
    f95c:	e50b300c 	str	r3, [fp, #-12]
    f960:	e51b300c 	ldr	r3, [fp, #-12]
    f964:	e2033003 	and	r3, r3, #3
    f968:	e3530000 	cmp	r3, #0
    f96c:	1affff92 	bne	f7bc <_malloc_r+0x788>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
        if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
    f970:	e51b301c 	ldr	r3, [fp, #-28]
    f974:	e2033003 	and	r3, r3, #3
    f978:	e3530000 	cmp	r3, #0
    f97c:	1a000007 	bne	f9a0 <_malloc_r+0x96c>
        {
          binblocks &= ~block;
    f980:	e59f31bc 	ldr	r3, [pc, #444]	; fb44 <_malloc_r+0xb10>
    f984:	e59f21b8 	ldr	r2, [pc, #440]	; fb44 <_malloc_r+0xb10>
    f988:	e5921004 	ldr	r1, [r2, #4]
    f98c:	e51b2018 	ldr	r2, [fp, #-24]
    f990:	e1e02002 	mvn	r2, r2
    f994:	e0022001 	and	r2, r2, r1
    f998:	e5832004 	str	r2, [r3, #4]
          break;
    f99c:	ea00000a 	b	f9cc <_malloc_r+0x998>
        }
        --startidx;
    f9a0:	e51b301c 	ldr	r3, [fp, #-28]
    f9a4:	e2433001 	sub	r3, r3, #1
    f9a8:	e50b301c 	str	r3, [fp, #-28]
       q = prev_bin(q);
    f9ac:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    f9b0:	e2433008 	sub	r3, r3, #8
    f9b4:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      } while (first(q) == q);
    f9b8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    f9bc:	e5932008 	ldr	r2, [r3, #8]
    f9c0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    f9c4:	e1520003 	cmp	r2, r3
    f9c8:	0affffe8 	beq	f970 <_malloc_r+0x93c>

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
    f9cc:	e51b3018 	ldr	r3, [fp, #-24]
    f9d0:	e1a03083 	lsl	r3, r3, #1
    f9d4:	e50b3018 	str	r3, [fp, #-24]
    f9d8:	e59f3164 	ldr	r3, [pc, #356]	; fb44 <_malloc_r+0xb10>
    f9dc:	e5933004 	ldr	r3, [r3, #4]
    f9e0:	e51b2018 	ldr	r2, [fp, #-24]
    f9e4:	e1520003 	cmp	r2, r3
    f9e8:	8a000010 	bhi	fa30 <_malloc_r+0x9fc>
    f9ec:	e51b3018 	ldr	r3, [fp, #-24]
    f9f0:	e3530000 	cmp	r3, #0
    f9f4:	0a00000d 	beq	fa30 <_malloc_r+0x9fc>
      {
        while ((block & binblocks) == 0)
    f9f8:	ea000005 	b	fa14 <_malloc_r+0x9e0>
        {
          idx += BINBLOCKWIDTH;
    f9fc:	e51b300c 	ldr	r3, [fp, #-12]
    fa00:	e2833004 	add	r3, r3, #4
    fa04:	e50b300c 	str	r3, [fp, #-12]
          block <<= 1;
    fa08:	e51b3018 	ldr	r3, [fp, #-24]
    fa0c:	e1a03083 	lsl	r3, r3, #1
    fa10:	e50b3018 	str	r3, [fp, #-24]

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks && (block != 0) ) 
      {
        while ((block & binblocks) == 0)
    fa14:	e59f3128 	ldr	r3, [pc, #296]	; fb44 <_malloc_r+0xb10>
    fa18:	e5932004 	ldr	r2, [r3, #4]
    fa1c:	e51b3018 	ldr	r3, [fp, #-24]
    fa20:	e0033002 	and	r3, r3, r2
    fa24:	e3530000 	cmp	r3, #0
    fa28:	0afffff3 	beq	f9fc <_malloc_r+0x9c8>
          block <<= 1;
        }
      }
      else
        break;
    }
    fa2c:	eaffff58 	b	f794 <_malloc_r+0x760>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  cpu_dcache_invalidate((void*)&top,sizeof(uint32_t*)); 
    fa30:	e59f0114 	ldr	r0, [pc, #276]	; fb4c <_malloc_r+0xb18>
    fa34:	e3a01004 	mov	r1, #4
    fa38:	ebffe89c 	bl	9cb0 <cpu_dcache_invalidate>
  remainder_size = long_sub_size_t(chunksize(top), nb);
    fa3c:	e59f3100 	ldr	r3, [pc, #256]	; fb44 <_malloc_r+0xb10>
    fa40:	e5933008 	ldr	r3, [r3, #8]
    fa44:	e5933004 	ldr	r3, [r3, #4]
    fa48:	e3c32003 	bic	r2, r3, #3
    fa4c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    fa50:	e0633002 	rsb	r3, r3, r2
    fa54:	e50b3014 	str	r3, [fp, #-20]
  if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
    fa58:	e59f30e4 	ldr	r3, [pc, #228]	; fb44 <_malloc_r+0xb10>
    fa5c:	e5933008 	ldr	r3, [r3, #8]
    fa60:	e5933004 	ldr	r3, [r3, #4]
    fa64:	e3c32003 	bic	r2, r3, #3
    fa68:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    fa6c:	e1520003 	cmp	r2, r3
    fa70:	3a000002 	bcc	fa80 <_malloc_r+0xa4c>
    fa74:	e51b3014 	ldr	r3, [fp, #-20]
    fa78:	e353000f 	cmp	r3, #15
    fa7c:	ca000017 	bgt	fae0 <_malloc_r+0xaac>
      return chunk2mem(victim);
    }
#endif

    /* Try to extend */
    malloc_extend_top(RCALL nb);
    fa80:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
    fa84:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
    fa88:	ebfffc79 	bl	ec74 <malloc_extend_top>
    remainder_size = long_sub_size_t(chunksize(top), nb);
    fa8c:	e59f30b0 	ldr	r3, [pc, #176]	; fb44 <_malloc_r+0xb10>
    fa90:	e5933008 	ldr	r3, [r3, #8]
    fa94:	e5933004 	ldr	r3, [r3, #4]
    fa98:	e3c32003 	bic	r2, r3, #3
    fa9c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    faa0:	e0633002 	rsb	r3, r3, r2
    faa4:	e50b3014 	str	r3, [fp, #-20]
    if (chunksize(top) < nb || remainder_size < (long)MINSIZE)
    faa8:	e59f3094 	ldr	r3, [pc, #148]	; fb44 <_malloc_r+0xb10>
    faac:	e5933008 	ldr	r3, [r3, #8]
    fab0:	e5933004 	ldr	r3, [r3, #4]
    fab4:	e3c32003 	bic	r2, r3, #3
    fab8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    fabc:	e1520003 	cmp	r2, r3
    fac0:	3a000002 	bcc	fad0 <_malloc_r+0xa9c>
    fac4:	e51b3014 	ldr	r3, [fp, #-20]
    fac8:	e353000f 	cmp	r3, #15
    facc:	ca000003 	bgt	fae0 <_malloc_r+0xaac>
    {
      MALLOC_UNLOCK;
    fad0:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
    fad4:	eb000107 	bl	fef8 <__malloc_unlock>
      return 0; /* propagate failure */
    fad8:	e3a03000 	mov	r3, #0
    fadc:	ea000014 	b	fb34 <_malloc_r+0xb00>
    }
  }

  victim = top;
    fae0:	e59f305c 	ldr	r3, [pc, #92]	; fb44 <_malloc_r+0xb10>
    fae4:	e5933008 	ldr	r3, [r3, #8]
    fae8:	e50b3008 	str	r3, [fp, #-8]
  set_head(victim, nb | PREV_INUSE);
    faec:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
    faf0:	e3832001 	orr	r2, r3, #1
    faf4:	e51b3008 	ldr	r3, [fp, #-8]
    faf8:	e5832004 	str	r2, [r3, #4]
  top = chunk_at_offset(victim, nb);
    fafc:	e59f3040 	ldr	r3, [pc, #64]	; fb44 <_malloc_r+0xb10>
    fb00:	e51b1008 	ldr	r1, [fp, #-8]
    fb04:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
    fb08:	e0812002 	add	r2, r1, r2
    fb0c:	e5832008 	str	r2, [r3, #8]
  set_head(top, remainder_size | PREV_INUSE);
    fb10:	e59f302c 	ldr	r3, [pc, #44]	; fb44 <_malloc_r+0xb10>
    fb14:	e5933008 	ldr	r3, [r3, #8]
    fb18:	e51b2014 	ldr	r2, [fp, #-20]
    fb1c:	e3822001 	orr	r2, r2, #1
    fb20:	e5832004 	str	r2, [r3, #4]
  check_malloced_chunk(victim, nb);
  MALLOC_UNLOCK;
    fb24:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
    fb28:	eb0000f2 	bl	fef8 <__malloc_unlock>
  return chunk2mem(victim);
    fb2c:	e51b3008 	ldr	r3, [fp, #-8]
    fb30:	e2833008 	add	r3, r3, #8

#endif /* MALLOC_PROVIDED */
}
    fb34:	e1a00003 	mov	r0, r3
    fb38:	e24bd004 	sub	sp, fp, #4
    fb3c:	e8bd4800 	pop	{fp, lr}
    fb40:	e12fff1e 	bx	lr
    fb44:	00024bd8 	.word	0x00024bd8
    fb48:	00000554 	.word	0x00000554
    fb4c:	00024be0 	.word	0x00024be0

0000fb50 <memcpy>:
_PTR
_DEFUN (memcpy, (dst0, src0, len0),
	_PTR __restrict dst0 _AND
	_CONST _PTR __restrict src0 _AND
	size_t len0)
{
    fb50:	e92d4800 	push	{fp, lr}
    fb54:	e28db004 	add	fp, sp, #4
    fb58:	e24dd020 	sub	sp, sp, #32
    fb5c:	e50b0018 	str	r0, [fp, #-24]
    fb60:	e50b101c 	str	r1, [fp, #-28]
    fb64:	e50b2020 	str	r2, [fp, #-32]
      *dst++ = *src++;
    }

  return save;
#else
  char *dst = dst0;
    fb68:	e51b3018 	ldr	r3, [fp, #-24]
    fb6c:	e50b3008 	str	r3, [fp, #-8]
  _CONST char *src = src0;
    fb70:	e51b301c 	ldr	r3, [fp, #-28]
    fb74:	e50b300c 	str	r3, [fp, #-12]
  long *aligned_dst;
  _CONST long *aligned_src;

  /* If the size is small, or either SRC or DST is unaligned,
     then punt into the byte copy loop.  This should be rare.  */
  if (!TOO_SMALL(len0) && !UNALIGNED (src, dst))
    fb78:	e51b3020 	ldr	r3, [fp, #-32]
    fb7c:	e353000f 	cmp	r3, #15
    fb80:	9a000046 	bls	fca0 <memcpy+0x150>
    fb84:	e51b200c 	ldr	r2, [fp, #-12]
    fb88:	e51b3008 	ldr	r3, [fp, #-8]
    fb8c:	e1823003 	orr	r3, r2, r3
    fb90:	e2033003 	and	r3, r3, #3
    fb94:	e3530000 	cmp	r3, #0
    fb98:	1a000040 	bne	fca0 <memcpy+0x150>
    {
      aligned_dst = (long*)dst;
    fb9c:	e51b3008 	ldr	r3, [fp, #-8]
    fba0:	e50b3010 	str	r3, [fp, #-16]
      aligned_src = (long*)src;
    fba4:	e51b300c 	ldr	r3, [fp, #-12]
    fba8:	e50b3014 	str	r3, [fp, #-20]

      /* Copy 4X long words at a time if possible.  */
      cpu_dcache_invalidate((void*)aligned_src,len0);
    fbac:	e51b0014 	ldr	r0, [fp, #-20]
    fbb0:	e51b1020 	ldr	r1, [fp, #-32]
    fbb4:	ebffe83d 	bl	9cb0 <cpu_dcache_invalidate>
      while (len0 >= BIGBLOCKSIZE)
    fbb8:	ea000022 	b	fc48 <memcpy+0xf8>
        {
          *aligned_dst++ = *aligned_src++;
    fbbc:	e51b3010 	ldr	r3, [fp, #-16]
    fbc0:	e2832004 	add	r2, r3, #4
    fbc4:	e50b2010 	str	r2, [fp, #-16]
    fbc8:	e51b2014 	ldr	r2, [fp, #-20]
    fbcc:	e2821004 	add	r1, r2, #4
    fbd0:	e50b1014 	str	r1, [fp, #-20]
    fbd4:	e5922000 	ldr	r2, [r2]
    fbd8:	e5832000 	str	r2, [r3]
          *aligned_dst++ = *aligned_src++;
    fbdc:	e51b3010 	ldr	r3, [fp, #-16]
    fbe0:	e2832004 	add	r2, r3, #4
    fbe4:	e50b2010 	str	r2, [fp, #-16]
    fbe8:	e51b2014 	ldr	r2, [fp, #-20]
    fbec:	e2821004 	add	r1, r2, #4
    fbf0:	e50b1014 	str	r1, [fp, #-20]
    fbf4:	e5922000 	ldr	r2, [r2]
    fbf8:	e5832000 	str	r2, [r3]
          *aligned_dst++ = *aligned_src++;
    fbfc:	e51b3010 	ldr	r3, [fp, #-16]
    fc00:	e2832004 	add	r2, r3, #4
    fc04:	e50b2010 	str	r2, [fp, #-16]
    fc08:	e51b2014 	ldr	r2, [fp, #-20]
    fc0c:	e2821004 	add	r1, r2, #4
    fc10:	e50b1014 	str	r1, [fp, #-20]
    fc14:	e5922000 	ldr	r2, [r2]
    fc18:	e5832000 	str	r2, [r3]
          *aligned_dst++ = *aligned_src++;
    fc1c:	e51b3010 	ldr	r3, [fp, #-16]
    fc20:	e2832004 	add	r2, r3, #4
    fc24:	e50b2010 	str	r2, [fp, #-16]
    fc28:	e51b2014 	ldr	r2, [fp, #-20]
    fc2c:	e2821004 	add	r1, r2, #4
    fc30:	e50b1014 	str	r1, [fp, #-20]
    fc34:	e5922000 	ldr	r2, [r2]
    fc38:	e5832000 	str	r2, [r3]
          len0 -= BIGBLOCKSIZE;
    fc3c:	e51b3020 	ldr	r3, [fp, #-32]
    fc40:	e2433010 	sub	r3, r3, #16
    fc44:	e50b3020 	str	r3, [fp, #-32]
      aligned_dst = (long*)dst;
      aligned_src = (long*)src;

      /* Copy 4X long words at a time if possible.  */
      cpu_dcache_invalidate((void*)aligned_src,len0);
      while (len0 >= BIGBLOCKSIZE)
    fc48:	e51b3020 	ldr	r3, [fp, #-32]
    fc4c:	e353000f 	cmp	r3, #15
    fc50:	8affffd9 	bhi	fbbc <memcpy+0x6c>
          *aligned_dst++ = *aligned_src++;
          len0 -= BIGBLOCKSIZE;
        }

      /* Copy one long word at a time if possible.  */
      while (len0 >= LITTLEBLOCKSIZE)
    fc54:	ea00000a 	b	fc84 <memcpy+0x134>
        {
          *aligned_dst++ = *aligned_src++;
    fc58:	e51b3010 	ldr	r3, [fp, #-16]
    fc5c:	e2832004 	add	r2, r3, #4
    fc60:	e50b2010 	str	r2, [fp, #-16]
    fc64:	e51b2014 	ldr	r2, [fp, #-20]
    fc68:	e2821004 	add	r1, r2, #4
    fc6c:	e50b1014 	str	r1, [fp, #-20]
    fc70:	e5922000 	ldr	r2, [r2]
    fc74:	e5832000 	str	r2, [r3]
          len0 -= LITTLEBLOCKSIZE;
    fc78:	e51b3020 	ldr	r3, [fp, #-32]
    fc7c:	e2433004 	sub	r3, r3, #4
    fc80:	e50b3020 	str	r3, [fp, #-32]
          *aligned_dst++ = *aligned_src++;
          len0 -= BIGBLOCKSIZE;
        }

      /* Copy one long word at a time if possible.  */
      while (len0 >= LITTLEBLOCKSIZE)
    fc84:	e51b3020 	ldr	r3, [fp, #-32]
    fc88:	e3530003 	cmp	r3, #3
    fc8c:	8afffff1 	bhi	fc58 <memcpy+0x108>
          *aligned_dst++ = *aligned_src++;
          len0 -= LITTLEBLOCKSIZE;
        }

       /* Pick up any residual with a byte copier.  */
      dst = (char*)aligned_dst;
    fc90:	e51b3010 	ldr	r3, [fp, #-16]
    fc94:	e50b3008 	str	r3, [fp, #-8]
      src = (char*)aligned_src;
    fc98:	e51b3014 	ldr	r3, [fp, #-20]
    fc9c:	e50b300c 	str	r3, [fp, #-12]
    }
  cpu_dcache_invalidate((void*)src, sizeof(char)*len0);
    fca0:	e51b000c 	ldr	r0, [fp, #-12]
    fca4:	e51b1020 	ldr	r1, [fp, #-32]
    fca8:	ebffe800 	bl	9cb0 <cpu_dcache_invalidate>
  while (len0--)
    fcac:	ea000007 	b	fcd0 <memcpy+0x180>
    *dst++ = *src++;
    fcb0:	e51b3008 	ldr	r3, [fp, #-8]
    fcb4:	e2832001 	add	r2, r3, #1
    fcb8:	e50b2008 	str	r2, [fp, #-8]
    fcbc:	e51b200c 	ldr	r2, [fp, #-12]
    fcc0:	e2821001 	add	r1, r2, #1
    fcc4:	e50b100c 	str	r1, [fp, #-12]
    fcc8:	e5d22000 	ldrb	r2, [r2]
    fccc:	e5c32000 	strb	r2, [r3]
       /* Pick up any residual with a byte copier.  */
      dst = (char*)aligned_dst;
      src = (char*)aligned_src;
    }
  cpu_dcache_invalidate((void*)src, sizeof(char)*len0);
  while (len0--)
    fcd0:	e51b3020 	ldr	r3, [fp, #-32]
    fcd4:	e2432001 	sub	r2, r3, #1
    fcd8:	e50b2020 	str	r2, [fp, #-32]
    fcdc:	e3530000 	cmp	r3, #0
    fce0:	1afffff2 	bne	fcb0 <memcpy+0x160>
    *dst++ = *src++;

  return dst0;
    fce4:	e51b3018 	ldr	r3, [fp, #-24]
#endif /* not PREFER_SIZE_OVER_SPEED */
}
    fce8:	e1a00003 	mov	r0, r3
    fcec:	e24bd004 	sub	sp, fp, #4
    fcf0:	e8bd4800 	pop	{fp, lr}
    fcf4:	e12fff1e 	bx	lr

0000fcf8 <memset>:
_PTR
_DEFUN (memset, (m, c, n),
	_PTR m _AND
	int c _AND
	size_t n)
{
    fcf8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
    fcfc:	e28db000 	add	fp, sp, #0
    fd00:	e24dd02c 	sub	sp, sp, #44	; 0x2c
    fd04:	e50b0020 	str	r0, [fp, #-32]
    fd08:	e50b1024 	str	r1, [fp, #-36]	; 0x24
    fd0c:	e50b2028 	str	r2, [fp, #-40]	; 0x28
  char *s = (char *) m;
    fd10:	e51b3020 	ldr	r3, [fp, #-32]
    fd14:	e50b3008 	str	r3, [fp, #-8]

#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  int i;
  unsigned long buffer;
  unsigned long *aligned_addr;
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
    fd18:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
    fd1c:	e20330ff 	and	r3, r3, #255	; 0xff
    fd20:	e50b3018 	str	r3, [fp, #-24]
				   unsigned variable.  */

  while (UNALIGNED (s))
    fd24:	ea00000d 	b	fd60 <memset+0x68>
    {
      if (n--)
    fd28:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    fd2c:	e2432001 	sub	r2, r3, #1
    fd30:	e50b2028 	str	r2, [fp, #-40]	; 0x28
    fd34:	e3530000 	cmp	r3, #0
    fd38:	0a000006 	beq	fd58 <memset+0x60>
        *s++ = (char) c;
    fd3c:	e51b3008 	ldr	r3, [fp, #-8]
    fd40:	e2832001 	add	r2, r3, #1
    fd44:	e50b2008 	str	r2, [fp, #-8]
    fd48:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
    fd4c:	e20220ff 	and	r2, r2, #255	; 0xff
    fd50:	e5c32000 	strb	r2, [r3]
    fd54:	ea000001 	b	fd60 <memset+0x68>
      else
        return m;
    fd58:	e51b3020 	ldr	r3, [fp, #-32]
    fd5c:	ea000057 	b	fec0 <memset+0x1c8>
  unsigned long buffer;
  unsigned long *aligned_addr;
  unsigned int d = c & 0xff;	/* To avoid sign extension, copy C to an
				   unsigned variable.  */

  while (UNALIGNED (s))
    fd60:	e51b3008 	ldr	r3, [fp, #-8]
    fd64:	e2033003 	and	r3, r3, #3
    fd68:	e3530000 	cmp	r3, #0
    fd6c:	1affffed 	bne	fd28 <memset+0x30>
        *s++ = (char) c;
      else
        return m;
    }

  if (!TOO_SMALL (n))
    fd70:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    fd74:	e3530003 	cmp	r3, #3
    fd78:	9a000043 	bls	fe8c <memset+0x194>
    {
      /* If we get this far, we know that n is large and s is word-aligned. */
      aligned_addr = (unsigned long *) s;
    fd7c:	e51b3008 	ldr	r3, [fp, #-8]
    fd80:	e50b3014 	str	r3, [fp, #-20]

      /* Store D into each char sized location in BUFFER so that
         we can set large blocks quickly.  */
      buffer = (d << 8) | d;
    fd84:	e51b3018 	ldr	r3, [fp, #-24]
    fd88:	e1a02403 	lsl	r2, r3, #8
    fd8c:	e51b3018 	ldr	r3, [fp, #-24]
    fd90:	e1823003 	orr	r3, r2, r3
    fd94:	e50b3010 	str	r3, [fp, #-16]
      buffer |= (buffer << 16);
    fd98:	e51b3010 	ldr	r3, [fp, #-16]
    fd9c:	e1a03803 	lsl	r3, r3, #16
    fda0:	e51b2010 	ldr	r2, [fp, #-16]
    fda4:	e1823003 	orr	r3, r2, r3
    fda8:	e50b3010 	str	r3, [fp, #-16]
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
    fdac:	e3a03020 	mov	r3, #32
    fdb0:	e50b300c 	str	r3, [fp, #-12]
    fdb4:	ea000008 	b	fddc <memset+0xe4>
        buffer = (buffer << i) | buffer;
    fdb8:	e51b2010 	ldr	r2, [fp, #-16]
    fdbc:	e51b300c 	ldr	r3, [fp, #-12]
    fdc0:	e1a03312 	lsl	r3, r2, r3
    fdc4:	e51b2010 	ldr	r2, [fp, #-16]
    fdc8:	e1823003 	orr	r3, r2, r3
    fdcc:	e50b3010 	str	r3, [fp, #-16]

      /* Store D into each char sized location in BUFFER so that
         we can set large blocks quickly.  */
      buffer = (d << 8) | d;
      buffer |= (buffer << 16);
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
    fdd0:	e51b300c 	ldr	r3, [fp, #-12]
    fdd4:	e1a03083 	lsl	r3, r3, #1
    fdd8:	e50b300c 	str	r3, [fp, #-12]
    fddc:	e51b300c 	ldr	r3, [fp, #-12]
    fde0:	e353001f 	cmp	r3, #31
    fde4:	9afffff3 	bls	fdb8 <memset+0xc0>
        buffer = (buffer << i) | buffer;

      /* Unroll the loop.  */
      while (n >= LBLOCKSIZE*4)
    fde8:	ea000016 	b	fe48 <memset+0x150>
        {
          *aligned_addr++ = buffer;
    fdec:	e51b3014 	ldr	r3, [fp, #-20]
    fdf0:	e2832004 	add	r2, r3, #4
    fdf4:	e50b2014 	str	r2, [fp, #-20]
    fdf8:	e51b2010 	ldr	r2, [fp, #-16]
    fdfc:	e5832000 	str	r2, [r3]
          *aligned_addr++ = buffer;
    fe00:	e51b3014 	ldr	r3, [fp, #-20]
    fe04:	e2832004 	add	r2, r3, #4
    fe08:	e50b2014 	str	r2, [fp, #-20]
    fe0c:	e51b2010 	ldr	r2, [fp, #-16]
    fe10:	e5832000 	str	r2, [r3]
          *aligned_addr++ = buffer;
    fe14:	e51b3014 	ldr	r3, [fp, #-20]
    fe18:	e2832004 	add	r2, r3, #4
    fe1c:	e50b2014 	str	r2, [fp, #-20]
    fe20:	e51b2010 	ldr	r2, [fp, #-16]
    fe24:	e5832000 	str	r2, [r3]
          *aligned_addr++ = buffer;
    fe28:	e51b3014 	ldr	r3, [fp, #-20]
    fe2c:	e2832004 	add	r2, r3, #4
    fe30:	e50b2014 	str	r2, [fp, #-20]
    fe34:	e51b2010 	ldr	r2, [fp, #-16]
    fe38:	e5832000 	str	r2, [r3]
          n -= 4*LBLOCKSIZE;
    fe3c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    fe40:	e2433010 	sub	r3, r3, #16
    fe44:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      buffer |= (buffer << 16);
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        buffer = (buffer << i) | buffer;

      /* Unroll the loop.  */
      while (n >= LBLOCKSIZE*4)
    fe48:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    fe4c:	e353000f 	cmp	r3, #15
    fe50:	8affffe5 	bhi	fdec <memset+0xf4>
          *aligned_addr++ = buffer;
          *aligned_addr++ = buffer;
          n -= 4*LBLOCKSIZE;
        }

      while (n >= LBLOCKSIZE)
    fe54:	ea000007 	b	fe78 <memset+0x180>
        {
          *aligned_addr++ = buffer;
    fe58:	e51b3014 	ldr	r3, [fp, #-20]
    fe5c:	e2832004 	add	r2, r3, #4
    fe60:	e50b2014 	str	r2, [fp, #-20]
    fe64:	e51b2010 	ldr	r2, [fp, #-16]
    fe68:	e5832000 	str	r2, [r3]
          n -= LBLOCKSIZE;
    fe6c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    fe70:	e2433004 	sub	r3, r3, #4
    fe74:	e50b3028 	str	r3, [fp, #-40]	; 0x28
          *aligned_addr++ = buffer;
          *aligned_addr++ = buffer;
          n -= 4*LBLOCKSIZE;
        }

      while (n >= LBLOCKSIZE)
    fe78:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    fe7c:	e3530003 	cmp	r3, #3
    fe80:	8afffff4 	bhi	fe58 <memset+0x160>
        {
          *aligned_addr++ = buffer;
          n -= LBLOCKSIZE;
        }
      /* Pick up the remainder with a bytewise loop.  */
      s = (char*)aligned_addr;
    fe84:	e51b3014 	ldr	r3, [fp, #-20]
    fe88:	e50b3008 	str	r3, [fp, #-8]
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
    fe8c:	ea000005 	b	fea8 <memset+0x1b0>
    *s++ = (char) c;
    fe90:	e51b3008 	ldr	r3, [fp, #-8]
    fe94:	e2832001 	add	r2, r3, #1
    fe98:	e50b2008 	str	r2, [fp, #-8]
    fe9c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
    fea0:	e20220ff 	and	r2, r2, #255	; 0xff
    fea4:	e5c32000 	strb	r2, [r3]
      s = (char*)aligned_addr;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (n--)
    fea8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
    feac:	e2432001 	sub	r2, r3, #1
    feb0:	e50b2028 	str	r2, [fp, #-40]	; 0x28
    feb4:	e3530000 	cmp	r3, #0
    feb8:	1afffff4 	bne	fe90 <memset+0x198>
    *s++ = (char) c;

  return m;
    febc:	e51b3020 	ldr	r3, [fp, #-32]
}
    fec0:	e1a00003 	mov	r0, r3
    fec4:	e24bd000 	sub	sp, fp, #0
    fec8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
    fecc:	e12fff1e 	bx	lr

0000fed0 <__malloc_lock>:
#endif

void
__malloc_lock (ptr)
     struct _reent *ptr;
{
    fed0:	e92d4800 	push	{fp, lr}
    fed4:	e28db004 	add	fp, sp, #4
    fed8:	e24dd008 	sub	sp, sp, #8
    fedc:	e50b0008 	str	r0, [fp, #-8]
#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive (__malloc_lock_object);
    fee0:	e59f000c 	ldr	r0, [pc, #12]	; fef4 <__malloc_lock+0x24>
    fee4:	ebfffac5 	bl	ea00 <_dna_lock_acquire>
#endif
}
    fee8:	e24bd004 	sub	sp, fp, #4
    feec:	e8bd4800 	pop	{fp, lr}
    fef0:	e12fff1e 	bx	lr
    fef4:	00024fe8 	.word	0x00024fe8

0000fef8 <__malloc_unlock>:

void
__malloc_unlock (ptr)
     struct _reent *ptr;
{
    fef8:	e92d4800 	push	{fp, lr}
    fefc:	e28db004 	add	fp, sp, #4
    ff00:	e24dd008 	sub	sp, sp, #8
    ff04:	e50b0008 	str	r0, [fp, #-8]
#ifndef __SINGLE_THREAD__
  __lock_release_recursive (__malloc_lock_object);
    ff08:	e59f000c 	ldr	r0, [pc, #12]	; ff1c <__malloc_unlock+0x24>
    ff0c:	ebfffb22 	bl	eb9c <_dna_lock_release>
#endif
}
    ff10:	e24bd004 	sub	sp, fp, #4
    ff14:	e8bd4800 	pop	{fp, lr}
    ff18:	e12fff1e 	bx	lr
    ff1c:	00024fe8 	.word	0x00024fe8

0000ff20 <open>:
int
_DEFUN (_open, (file, flags, mode),
        char *file  _AND
        int   flags _AND
        int   mode)
{
    ff20:	e92d4800 	push	{fp, lr}
    ff24:	e28db004 	add	fp, sp, #4
    ff28:	e24dd018 	sub	sp, sp, #24
    ff2c:	e50b0010 	str	r0, [fp, #-16]
    ff30:	e50b1014 	str	r1, [fp, #-20]
    ff34:	e50b2018 	str	r2, [fp, #-24]
	int16_t fd = -1;
    ff38:	e3e03000 	mvn	r3, #0
    ff3c:	e14b30b8 	strh	r3, [fp, #-8]
	status_t status = DNA_OK;
    ff40:	e3a03000 	mov	r3, #0
    ff44:	e14b30b6 	strh	r3, [fp, #-6]

	status = vfs_open (file, flags, mode, & fd);
    ff48:	e24b3008 	sub	r3, fp, #8
    ff4c:	e51b0010 	ldr	r0, [fp, #-16]
    ff50:	e51b1014 	ldr	r1, [fp, #-20]
    ff54:	e51b2018 	ldr	r2, [fp, #-24]
    ff58:	ebffddd9 	bl	76c4 <vfs_open>
    ff5c:	e1a03000 	mov	r3, r0
    ff60:	e14b30b6 	strh	r3, [fp, #-6]
	return fd;
    ff64:	e15b30b8 	ldrh	r3, [fp, #-8]
    ff68:	e1a03803 	lsl	r3, r3, #16
    ff6c:	e1a03843 	asr	r3, r3, #16
}
    ff70:	e1a00003 	mov	r0, r3
    ff74:	e24bd004 	sub	sp, fp, #4
    ff78:	e8bd4800 	pop	{fp, lr}
    ff7c:	e12fff1e 	bx	lr

0000ff80 <_printf_r>:

int
_DEFUN(_printf_r, (ptr, fmt),
       struct _reent *ptr _AND
       const char *fmt _DOTS)
{
    ff80:	e92d000e 	push	{r1, r2, r3}
    ff84:	e92d4800 	push	{fp, lr}
    ff88:	e28db004 	add	fp, sp, #4
    ff8c:	e24dd014 	sub	sp, sp, #20
    ff90:	e50b0014 	str	r0, [fp, #-20]
  int ret;
  va_list ap;

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
    ff94:	e28b3008 	add	r3, fp, #8
    ff98:	e50b3010 	str	r3, [fp, #-16]
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
    ff9c:	e51b3014 	ldr	r3, [fp, #-20]
    ffa0:	e5933008 	ldr	r3, [r3, #8]
    ffa4:	e51b0014 	ldr	r0, [fp, #-20]
    ffa8:	e1a01003 	mov	r1, r3
    ffac:	e59b2004 	ldr	r2, [fp, #4]
    ffb0:	e51b3010 	ldr	r3, [fp, #-16]
    ffb4:	eb000e97 	bl	13a18 <_vfprintf_r>
    ffb8:	e50b000c 	str	r0, [fp, #-12]
  va_end (ap);
  return ret;
    ffbc:	e51b300c 	ldr	r3, [fp, #-12]
}
    ffc0:	e1a00003 	mov	r0, r3
    ffc4:	e24bd004 	sub	sp, fp, #4
    ffc8:	e8bd4800 	pop	{fp, lr}
    ffcc:	e28dd00c 	add	sp, sp, #12
    ffd0:	e12fff1e 	bx	lr

0000ffd4 <printf>:
#ifndef _REENT_ONLY

int
_DEFUN(printf, (fmt),
       const char *fmt _DOTS)
{
    ffd4:	e92d000f 	push	{r0, r1, r2, r3}
    ffd8:	e92d4800 	push	{fp, lr}
    ffdc:	e28db004 	add	fp, sp, #4
    ffe0:	e24dd010 	sub	sp, sp, #16
  int ret;
  va_list ap;
  struct _reent *ptr = _REENT;
    ffe4:	e59f3044 	ldr	r3, [pc, #68]	; 10030 <SYSSTACK_SIZE+0x30>
    ffe8:	e5933000 	ldr	r3, [r3]
    ffec:	e50b3008 	str	r3, [fp, #-8]

  _REENT_SMALL_CHECK_INIT (ptr);
  va_start (ap, fmt);
    fff0:	e28b3008 	add	r3, fp, #8
    fff4:	e50b3010 	str	r3, [fp, #-16]
  ret = _vfprintf_r (ptr, _stdout_r (ptr), fmt, ap);
    fff8:	e51b3008 	ldr	r3, [fp, #-8]
    fffc:	e5933008 	ldr	r3, [r3, #8]
   10000:	e51b0008 	ldr	r0, [fp, #-8]
   10004:	e1a01003 	mov	r1, r3
   10008:	e59b2004 	ldr	r2, [fp, #4]
   1000c:	e51b3010 	ldr	r3, [fp, #-16]
   10010:	eb000e80 	bl	13a18 <_vfprintf_r>
   10014:	e50b000c 	str	r0, [fp, #-12]
  va_end (ap);
  return ret;
   10018:	e51b300c 	ldr	r3, [fp, #-12]
}
   1001c:	e1a00003 	mov	r0, r3
   10020:	e24bd004 	sub	sp, fp, #4
   10024:	e8bd4800 	pop	{fp, lr}
   10028:	e28dd010 	add	sp, sp, #16
   1002c:	e12fff1e 	bx	lr
   10030:	00025440 	.word	0x00025440

00010034 <_puts_r>:

int
_DEFUN(_puts_r, (ptr, s),
       struct _reent *ptr _AND
       _CONST char * s)
{
   10034:	e92d4800 	push	{fp, lr}
   10038:	e28db004 	add	fp, sp, #4
   1003c:	e24dd038 	sub	sp, sp, #56	; 0x38
   10040:	e50b0038 	str	r0, [fp, #-56]	; 0x38
   10044:	e50b103c 	str	r1, [fp, #-60]	; 0x3c
#ifdef _FVWRITE_IN_STREAMIO
  int result;
  size_t c = strlen (s);
   10048:	e51b003c 	ldr	r0, [fp, #-60]	; 0x3c
   1004c:	eb000266 	bl	109ec <strlen>
   10050:	e50b0008 	str	r0, [fp, #-8]
  struct __suio uio;
  struct __siov iov[2];
  FILE *fp;

  iov[0].iov_base = s;
   10054:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   10058:	e50b3030 	str	r3, [fp, #-48]	; 0x30
  iov[0].iov_len = c;
   1005c:	e51b3008 	ldr	r3, [fp, #-8]
   10060:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
  iov[1].iov_base = "\n";
   10064:	e59f3144 	ldr	r3, [pc, #324]	; 101b0 <_puts_r+0x17c>
   10068:	e50b3028 	str	r3, [fp, #-40]	; 0x28
  iov[1].iov_len = 1;
   1006c:	e3a03001 	mov	r3, #1
   10070:	e50b3024 	str	r3, [fp, #-36]	; 0x24
  uio.uio_resid = c + 1;
   10074:	e51b3008 	ldr	r3, [fp, #-8]
   10078:	e2833001 	add	r3, r3, #1
   1007c:	e50b3018 	str	r3, [fp, #-24]
  uio.uio_iov = &iov[0];
   10080:	e24b3030 	sub	r3, fp, #48	; 0x30
   10084:	e50b3020 	str	r3, [fp, #-32]
  uio.uio_iovcnt = 2;
   10088:	e3a03002 	mov	r3, #2
   1008c:	e50b301c 	str	r3, [fp, #-28]

  _REENT_SMALL_CHECK_INIT (ptr);
  fp = _stdout_r (ptr);
   10090:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   10094:	e5933008 	ldr	r3, [r3, #8]
   10098:	e50b300c 	str	r3, [fp, #-12]
  CHECK_INIT (ptr, fp);
   1009c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   100a0:	e50b3010 	str	r3, [fp, #-16]
   100a4:	e51b3010 	ldr	r3, [fp, #-16]
   100a8:	e3530000 	cmp	r3, #0
   100ac:	0a000005 	beq	100c8 <_puts_r+0x94>
   100b0:	e51b3010 	ldr	r3, [fp, #-16]
   100b4:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   100b8:	e3530000 	cmp	r3, #0
   100bc:	1a000001 	bne	100c8 <_puts_r+0x94>
   100c0:	e51b0010 	ldr	r0, [fp, #-16]
   100c4:	eb00255d 	bl	19640 <__sinit>
  _newlib_flockfile_start (fp);
   100c8:	e51b300c 	ldr	r3, [fp, #-12]
   100cc:	e1d330bc 	ldrh	r3, [r3, #12]
   100d0:	e1a03803 	lsl	r3, r3, #16
   100d4:	e1a03823 	lsr	r3, r3, #16
   100d8:	e2033c02 	and	r3, r3, #512	; 0x200
   100dc:	e3530000 	cmp	r3, #0
   100e0:	1a000003 	bne	100f4 <_puts_r+0xc0>
   100e4:	e51b300c 	ldr	r3, [fp, #-12]
   100e8:	e283305c 	add	r3, r3, #92	; 0x5c
   100ec:	e1a00003 	mov	r0, r3
   100f0:	ebfffa42 	bl	ea00 <_dna_lock_acquire>
  ORIENT (fp, -1);
   100f4:	e51b300c 	ldr	r3, [fp, #-12]
   100f8:	e1d330bc 	ldrh	r3, [r3, #12]
   100fc:	e1a03803 	lsl	r3, r3, #16
   10100:	e1a03823 	lsr	r3, r3, #16
   10104:	e2033a02 	and	r3, r3, #8192	; 0x2000
   10108:	e3530000 	cmp	r3, #0
   1010c:	1a00000b 	bne	10140 <_puts_r+0x10c>
   10110:	e51b300c 	ldr	r3, [fp, #-12]
   10114:	e1d330bc 	ldrh	r3, [r3, #12]
   10118:	e3833a02 	orr	r3, r3, #8192	; 0x2000
   1011c:	e1a03803 	lsl	r3, r3, #16
   10120:	e1a02823 	lsr	r2, r3, #16
   10124:	e51b300c 	ldr	r3, [fp, #-12]
   10128:	e1c320bc 	strh	r2, [r3, #12]
   1012c:	e51b300c 	ldr	r3, [fp, #-12]
   10130:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
   10134:	e3c32a02 	bic	r2, r3, #8192	; 0x2000
   10138:	e51b300c 	ldr	r3, [fp, #-12]
   1013c:	e583206c 	str	r2, [r3, #108]	; 0x6c
  result = (__sfvwrite_r (ptr, fp, &uio) ? EOF : '\n');
   10140:	e24b3020 	sub	r3, fp, #32
   10144:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
   10148:	e51b100c 	ldr	r1, [fp, #-12]
   1014c:	e1a02003 	mov	r2, r3
   10150:	eb002797 	bl	19fb4 <__sfvwrite_r>
   10154:	e1a03000 	mov	r3, r0
   10158:	e3530000 	cmp	r3, #0
   1015c:	0a000001 	beq	10168 <_puts_r+0x134>
   10160:	e3e03000 	mvn	r3, #0
   10164:	ea000000 	b	1016c <_puts_r+0x138>
   10168:	e3a0300a 	mov	r3, #10
   1016c:	e50b3014 	str	r3, [fp, #-20]
  _newlib_flockfile_end (fp);
   10170:	e51b300c 	ldr	r3, [fp, #-12]
   10174:	e1d330bc 	ldrh	r3, [r3, #12]
   10178:	e1a03803 	lsl	r3, r3, #16
   1017c:	e1a03823 	lsr	r3, r3, #16
   10180:	e2033c02 	and	r3, r3, #512	; 0x200
   10184:	e3530000 	cmp	r3, #0
   10188:	1a000003 	bne	1019c <_puts_r+0x168>
   1018c:	e51b300c 	ldr	r3, [fp, #-12]
   10190:	e283305c 	add	r3, r3, #92	; 0x5c
   10194:	e1a00003 	mov	r0, r3
   10198:	ebfffa7f 	bl	eb9c <_dna_lock_release>
  return result;
   1019c:	e51b3014 	ldr	r3, [fp, #-20]

err:
  _newlib_flockfile_end (fp);
  return result;
#endif
}
   101a0:	e1a00003 	mov	r0, r3
   101a4:	e24bd004 	sub	sp, fp, #4
   101a8:	e8bd4800 	pop	{fp, lr}
   101ac:	e12fff1e 	bx	lr
   101b0:	000246f0 	.word	0x000246f0

000101b4 <puts>:
#ifndef _REENT_ONLY

int
_DEFUN(puts, (s),
       char _CONST * s)
{
   101b4:	e92d4800 	push	{fp, lr}
   101b8:	e28db004 	add	fp, sp, #4
   101bc:	e24dd008 	sub	sp, sp, #8
   101c0:	e50b0008 	str	r0, [fp, #-8]
  return _puts_r (_REENT, s);
   101c4:	e59f3020 	ldr	r3, [pc, #32]	; 101ec <puts+0x38>
   101c8:	e5933000 	ldr	r3, [r3]
   101cc:	e1a00003 	mov	r0, r3
   101d0:	e51b1008 	ldr	r1, [fp, #-8]
   101d4:	ebffff96 	bl	10034 <_puts_r>
   101d8:	e1a03000 	mov	r3, r0
}
   101dc:	e1a00003 	mov	r0, r3
   101e0:	e24bd004 	sub	sp, fp, #4
   101e4:	e8bd4800 	pop	{fp, lr}
   101e8:	e12fff1e 	bx	lr
   101ec:	00025440 	.word	0x00025440

000101f0 <read>:
int
_DEFUN (_read, (file, ptr, len),
        int   file  _AND
        char *ptr   _AND
        int   len)
{
   101f0:	e92d4800 	push	{fp, lr}
   101f4:	e28db004 	add	fp, sp, #4
   101f8:	e24dd018 	sub	sp, sp, #24
   101fc:	e50b0010 	str	r0, [fp, #-16]
   10200:	e50b1014 	str	r1, [fp, #-20]
   10204:	e50b2018 	str	r2, [fp, #-24]
	status_t status = DNA_OK;
   10208:	e3a03000 	mov	r3, #0
   1020c:	e14b30b6 	strh	r3, [fp, #-6]
	int32_t res = -1;
   10210:	e3e03000 	mvn	r3, #0
   10214:	e50b300c 	str	r3, [fp, #-12]

	status = vfs_read (file, ptr, len, & res);
   10218:	e51b3010 	ldr	r3, [fp, #-16]
   1021c:	e1a03803 	lsl	r3, r3, #16
   10220:	e1a03823 	lsr	r3, r3, #16
   10224:	e1a03803 	lsl	r3, r3, #16
   10228:	e1a02843 	asr	r2, r3, #16
   1022c:	e24b300c 	sub	r3, fp, #12
   10230:	e1a00002 	mov	r0, r2
   10234:	e51b1014 	ldr	r1, [fp, #-20]
   10238:	e51b2018 	ldr	r2, [fp, #-24]
   1023c:	ebffdfb2 	bl	810c <vfs_read>
   10240:	e1a03000 	mov	r3, r0
   10244:	e14b30b6 	strh	r3, [fp, #-6]
	return res;
   10248:	e51b300c 	ldr	r3, [fp, #-12]
}
   1024c:	e1a00003 	mov	r0, r3
   10250:	e24bd004 	sub	sp, fp, #4
   10254:	e8bd4800 	pop	{fp, lr}
   10258:	e12fff1e 	bx	lr

0001025c <_sbrk_r>:

void *
_DEFUN (_sbrk_r, (ptr, incr),
     struct _reent *ptr _AND
     ptrdiff_t incr)
{
   1025c:	e92d4800 	push	{fp, lr}
   10260:	e28db004 	add	fp, sp, #4
   10264:	e24dd010 	sub	sp, sp, #16
   10268:	e50b0010 	str	r0, [fp, #-16]
   1026c:	e50b1014 	str	r1, [fp, #-20]
  char *ret;
  void *_sbrk(ptrdiff_t);

  errno = 0;
   10270:	e59f3050 	ldr	r3, [pc, #80]	; 102c8 <_sbrk_r+0x6c>
   10274:	e3a02000 	mov	r2, #0
   10278:	e5832000 	str	r2, [r3]
  if ((ret = (char *)(_sbrk (incr))) == (void *) -1 && errno != 0)
   1027c:	e51b0014 	ldr	r0, [fp, #-20]
   10280:	eb00357c 	bl	1d878 <sbrk>
   10284:	e50b0008 	str	r0, [fp, #-8]
   10288:	e51b3008 	ldr	r3, [fp, #-8]
   1028c:	e3730001 	cmn	r3, #1
   10290:	1a000007 	bne	102b4 <_sbrk_r+0x58>
   10294:	e59f302c 	ldr	r3, [pc, #44]	; 102c8 <_sbrk_r+0x6c>
   10298:	e5933000 	ldr	r3, [r3]
   1029c:	e3530000 	cmp	r3, #0
   102a0:	0a000003 	beq	102b4 <_sbrk_r+0x58>
    ptr->_errno = errno;
   102a4:	e59f301c 	ldr	r3, [pc, #28]	; 102c8 <_sbrk_r+0x6c>
   102a8:	e5932000 	ldr	r2, [r3]
   102ac:	e51b3010 	ldr	r3, [fp, #-16]
   102b0:	e5832000 	str	r2, [r3]
  return ret;
   102b4:	e51b3008 	ldr	r3, [fp, #-8]
}
   102b8:	e1a00003 	mov	r0, r3
   102bc:	e24bd004 	sub	sp, fp, #4
   102c0:	e8bd4800 	pop	{fp, lr}
   102c4:	e12fff1e 	bx	lr
   102c8:	000819b0 	.word	0x000819b0

000102cc <_init_signal_r>:
#include <_syslist.h>

int
_DEFUN (_init_signal_r, (ptr),
	struct _reent *ptr)
{
   102cc:	e92d4800 	push	{fp, lr}
   102d0:	e28db004 	add	fp, sp, #4
   102d4:	e24dd010 	sub	sp, sp, #16
   102d8:	e50b0010 	str	r0, [fp, #-16]
  int i;

  if (ptr->_sig_func == NULL)
   102dc:	e51b3010 	ldr	r3, [fp, #-16]
   102e0:	e59332dc 	ldr	r3, [r3, #732]	; 0x2dc
   102e4:	e3530000 	cmp	r3, #0
   102e8:	1a00001b 	bne	1035c <_init_signal_r+0x90>
    {
      ptr->_sig_func = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
   102ec:	e51b0010 	ldr	r0, [fp, #-16]
   102f0:	e3a01080 	mov	r1, #128	; 0x80
   102f4:	ebfffb4e 	bl	f034 <_malloc_r>
   102f8:	e1a02000 	mov	r2, r0
   102fc:	e51b3010 	ldr	r3, [fp, #-16]
   10300:	e58322dc 	str	r2, [r3, #732]	; 0x2dc
      if (ptr->_sig_func == NULL)
   10304:	e51b3010 	ldr	r3, [fp, #-16]
   10308:	e59332dc 	ldr	r3, [r3, #732]	; 0x2dc
   1030c:	e3530000 	cmp	r3, #0
   10310:	1a000001 	bne	1031c <_init_signal_r+0x50>
	return -1;
   10314:	e3e03000 	mvn	r3, #0
   10318:	ea000010 	b	10360 <_init_signal_r+0x94>

      for (i = 0; i < NSIG; i++)
   1031c:	e3a03000 	mov	r3, #0
   10320:	e50b3008 	str	r3, [fp, #-8]
   10324:	ea000009 	b	10350 <_init_signal_r+0x84>
	ptr->_sig_func[i] = SIG_DFL;
   10328:	e51b3010 	ldr	r3, [fp, #-16]
   1032c:	e59322dc 	ldr	r2, [r3, #732]	; 0x2dc
   10330:	e51b3008 	ldr	r3, [fp, #-8]
   10334:	e1a03103 	lsl	r3, r3, #2
   10338:	e0823003 	add	r3, r2, r3
   1033c:	e3a02000 	mov	r2, #0
   10340:	e5832000 	str	r2, [r3]
    {
      ptr->_sig_func = (_sig_func_ptr *)_malloc_r (ptr, sizeof (_sig_func_ptr) * NSIG);
      if (ptr->_sig_func == NULL)
	return -1;

      for (i = 0; i < NSIG; i++)
   10344:	e51b3008 	ldr	r3, [fp, #-8]
   10348:	e2833001 	add	r3, r3, #1
   1034c:	e50b3008 	str	r3, [fp, #-8]
   10350:	e51b3008 	ldr	r3, [fp, #-8]
   10354:	e353001f 	cmp	r3, #31
   10358:	dafffff2 	ble	10328 <_init_signal_r+0x5c>
	ptr->_sig_func[i] = SIG_DFL;
    }

  return 0;
   1035c:	e3a03000 	mov	r3, #0
}
   10360:	e1a00003 	mov	r0, r3
   10364:	e24bd004 	sub	sp, fp, #4
   10368:	e8bd4800 	pop	{fp, lr}
   1036c:	e12fff1e 	bx	lr

00010370 <_signal_r>:
_sig_func_ptr
_DEFUN (_signal_r, (ptr, sig, func),
	struct _reent *ptr _AND
	int sig _AND
	_sig_func_ptr func)
{
   10370:	e92d4800 	push	{fp, lr}
   10374:	e28db004 	add	fp, sp, #4
   10378:	e24dd018 	sub	sp, sp, #24
   1037c:	e50b0010 	str	r0, [fp, #-16]
   10380:	e50b1014 	str	r1, [fp, #-20]
   10384:	e50b2018 	str	r2, [fp, #-24]
  _sig_func_ptr old_func;

  if (sig < 0 || sig >= NSIG)
   10388:	e51b3014 	ldr	r3, [fp, #-20]
   1038c:	e3530000 	cmp	r3, #0
   10390:	ba000002 	blt	103a0 <_signal_r+0x30>
   10394:	e51b3014 	ldr	r3, [fp, #-20]
   10398:	e353001f 	cmp	r3, #31
   1039c:	da000004 	ble	103b4 <_signal_r+0x44>
    {
      ptr->_errno = EINVAL;
   103a0:	e51b3010 	ldr	r3, [fp, #-16]
   103a4:	e3a02016 	mov	r2, #22
   103a8:	e5832000 	str	r2, [r3]
      return SIG_ERR;
   103ac:	e3e03000 	mvn	r3, #0
   103b0:	ea000019 	b	1041c <_signal_r+0xac>
    }

  if (ptr->_sig_func == NULL && _init_signal_r (ptr) != 0)
   103b4:	e51b3010 	ldr	r3, [fp, #-16]
   103b8:	e59332dc 	ldr	r3, [r3, #732]	; 0x2dc
   103bc:	e3530000 	cmp	r3, #0
   103c0:	1a000006 	bne	103e0 <_signal_r+0x70>
   103c4:	e51b0010 	ldr	r0, [fp, #-16]
   103c8:	ebffffbf 	bl	102cc <_init_signal_r>
   103cc:	e1a03000 	mov	r3, r0
   103d0:	e3530000 	cmp	r3, #0
   103d4:	0a000001 	beq	103e0 <_signal_r+0x70>
    return SIG_ERR;
   103d8:	e3e03000 	mvn	r3, #0
   103dc:	ea00000e 	b	1041c <_signal_r+0xac>
  
  old_func = ptr->_sig_func[sig];
   103e0:	e51b3010 	ldr	r3, [fp, #-16]
   103e4:	e59322dc 	ldr	r2, [r3, #732]	; 0x2dc
   103e8:	e51b3014 	ldr	r3, [fp, #-20]
   103ec:	e1a03103 	lsl	r3, r3, #2
   103f0:	e0823003 	add	r3, r2, r3
   103f4:	e5933000 	ldr	r3, [r3]
   103f8:	e50b3008 	str	r3, [fp, #-8]
  ptr->_sig_func[sig] = func;
   103fc:	e51b3010 	ldr	r3, [fp, #-16]
   10400:	e59322dc 	ldr	r2, [r3, #732]	; 0x2dc
   10404:	e51b3014 	ldr	r3, [fp, #-20]
   10408:	e1a03103 	lsl	r3, r3, #2
   1040c:	e0823003 	add	r3, r2, r3
   10410:	e51b2018 	ldr	r2, [fp, #-24]
   10414:	e5832000 	str	r2, [r3]

  return old_func;
   10418:	e51b3008 	ldr	r3, [fp, #-8]
}
   1041c:	e1a00003 	mov	r0, r3
   10420:	e24bd004 	sub	sp, fp, #4
   10424:	e8bd4800 	pop	{fp, lr}
   10428:	e12fff1e 	bx	lr

0001042c <_raise_r>:

int 
_DEFUN (_raise_r, (ptr, sig),
     struct _reent *ptr _AND
     int sig)
{
   1042c:	e92d4800 	push	{fp, lr}
   10430:	e28db004 	add	fp, sp, #4
   10434:	e24dd010 	sub	sp, sp, #16
   10438:	e50b0010 	str	r0, [fp, #-16]
   1043c:	e50b1014 	str	r1, [fp, #-20]
  _sig_func_ptr func;

  if (sig < 0 || sig >= NSIG)
   10440:	e51b3014 	ldr	r3, [fp, #-20]
   10444:	e3530000 	cmp	r3, #0
   10448:	ba000002 	blt	10458 <_raise_r+0x2c>
   1044c:	e51b3014 	ldr	r3, [fp, #-20]
   10450:	e353001f 	cmp	r3, #31
   10454:	da000004 	ble	1046c <_raise_r+0x40>
    {
      ptr->_errno = EINVAL;
   10458:	e51b3010 	ldr	r3, [fp, #-16]
   1045c:	e3a02016 	mov	r2, #22
   10460:	e5832000 	str	r2, [r3]
      return -1;
   10464:	e3e03000 	mvn	r3, #0
   10468:	ea000032 	b	10538 <_raise_r+0x10c>
    }

  if (ptr->_sig_func == NULL)
   1046c:	e51b3010 	ldr	r3, [fp, #-16]
   10470:	e59332dc 	ldr	r3, [r3, #732]	; 0x2dc
   10474:	e3530000 	cmp	r3, #0
   10478:	1a000002 	bne	10488 <_raise_r+0x5c>
    func = SIG_DFL;
   1047c:	e3a03000 	mov	r3, #0
   10480:	e50b3008 	str	r3, [fp, #-8]
   10484:	ea000006 	b	104a4 <_raise_r+0x78>
  else
    func = ptr->_sig_func[sig];
   10488:	e51b3010 	ldr	r3, [fp, #-16]
   1048c:	e59322dc 	ldr	r2, [r3, #732]	; 0x2dc
   10490:	e51b3014 	ldr	r3, [fp, #-20]
   10494:	e1a03103 	lsl	r3, r3, #2
   10498:	e0823003 	add	r3, r2, r3
   1049c:	e5933000 	ldr	r3, [r3]
   104a0:	e50b3008 	str	r3, [fp, #-8]

  if (func == SIG_DFL)
   104a4:	e51b3008 	ldr	r3, [fp, #-8]
   104a8:	e3530000 	cmp	r3, #0
   104ac:	1a000008 	bne	104d4 <_raise_r+0xa8>
    return _kill_r (ptr, _getpid_r (ptr), sig);
   104b0:	e51b0010 	ldr	r0, [fp, #-16]
   104b4:	eb0000ba 	bl	107a4 <_getpid_r>
   104b8:	e1a03000 	mov	r3, r0
   104bc:	e51b0010 	ldr	r0, [fp, #-16]
   104c0:	e1a01003 	mov	r1, r3
   104c4:	e51b2014 	ldr	r2, [fp, #-20]
   104c8:	eb000097 	bl	1072c <_kill_r>
   104cc:	e1a03000 	mov	r3, r0
   104d0:	ea000018 	b	10538 <_raise_r+0x10c>
  else if (func == SIG_IGN)
   104d4:	e51b3008 	ldr	r3, [fp, #-8]
   104d8:	e3530001 	cmp	r3, #1
   104dc:	1a000001 	bne	104e8 <_raise_r+0xbc>
    return 0;
   104e0:	e3a03000 	mov	r3, #0
   104e4:	ea000013 	b	10538 <_raise_r+0x10c>
  else if (func == SIG_ERR)
   104e8:	e51b3008 	ldr	r3, [fp, #-8]
   104ec:	e3730001 	cmn	r3, #1
   104f0:	1a000004 	bne	10508 <_raise_r+0xdc>
    {
      ptr->_errno = EINVAL;
   104f4:	e51b3010 	ldr	r3, [fp, #-16]
   104f8:	e3a02016 	mov	r2, #22
   104fc:	e5832000 	str	r2, [r3]
      return 1;
   10500:	e3a03001 	mov	r3, #1
   10504:	ea00000b 	b	10538 <_raise_r+0x10c>
    }
  else
    {
      ptr->_sig_func[sig] = SIG_DFL;
   10508:	e51b3010 	ldr	r3, [fp, #-16]
   1050c:	e59322dc 	ldr	r2, [r3, #732]	; 0x2dc
   10510:	e51b3014 	ldr	r3, [fp, #-20]
   10514:	e1a03103 	lsl	r3, r3, #2
   10518:	e0823003 	add	r3, r2, r3
   1051c:	e3a02000 	mov	r2, #0
   10520:	e5832000 	str	r2, [r3]
      func (sig);
   10524:	e51b3008 	ldr	r3, [fp, #-8]
   10528:	e51b0014 	ldr	r0, [fp, #-20]
   1052c:	e1a0e00f 	mov	lr, pc
   10530:	e12fff13 	bx	r3
      return 0;
   10534:	e3a03000 	mov	r3, #0
    }
}
   10538:	e1a00003 	mov	r0, r3
   1053c:	e24bd004 	sub	sp, fp, #4
   10540:	e8bd4800 	pop	{fp, lr}
   10544:	e12fff1e 	bx	lr

00010548 <__sigtramp_r>:

int
_DEFUN (__sigtramp_r, (ptr, sig),
     struct _reent *ptr _AND
     int sig)
{
   10548:	e92d4800 	push	{fp, lr}
   1054c:	e28db004 	add	fp, sp, #4
   10550:	e24dd010 	sub	sp, sp, #16
   10554:	e50b0010 	str	r0, [fp, #-16]
   10558:	e50b1014 	str	r1, [fp, #-20]
  _sig_func_ptr func;

  if (sig < 0 || sig >= NSIG)
   1055c:	e51b3014 	ldr	r3, [fp, #-20]
   10560:	e3530000 	cmp	r3, #0
   10564:	ba000002 	blt	10574 <__sigtramp_r+0x2c>
   10568:	e51b3014 	ldr	r3, [fp, #-20]
   1056c:	e353001f 	cmp	r3, #31
   10570:	da000001 	ble	1057c <__sigtramp_r+0x34>
    {
      return -1;
   10574:	e3e03000 	mvn	r3, #0
   10578:	ea00002c 	b	10630 <__sigtramp_r+0xe8>
    }

  if (ptr->_sig_func == NULL && _init_signal_r (ptr) != 0)
   1057c:	e51b3010 	ldr	r3, [fp, #-16]
   10580:	e59332dc 	ldr	r3, [r3, #732]	; 0x2dc
   10584:	e3530000 	cmp	r3, #0
   10588:	1a000006 	bne	105a8 <__sigtramp_r+0x60>
   1058c:	e51b0010 	ldr	r0, [fp, #-16]
   10590:	ebffff4d 	bl	102cc <_init_signal_r>
   10594:	e1a03000 	mov	r3, r0
   10598:	e3530000 	cmp	r3, #0
   1059c:	0a000001 	beq	105a8 <__sigtramp_r+0x60>
    return -1;
   105a0:	e3e03000 	mvn	r3, #0
   105a4:	ea000021 	b	10630 <__sigtramp_r+0xe8>

  func = ptr->_sig_func[sig];
   105a8:	e51b3010 	ldr	r3, [fp, #-16]
   105ac:	e59322dc 	ldr	r2, [r3, #732]	; 0x2dc
   105b0:	e51b3014 	ldr	r3, [fp, #-20]
   105b4:	e1a03103 	lsl	r3, r3, #2
   105b8:	e0823003 	add	r3, r2, r3
   105bc:	e5933000 	ldr	r3, [r3]
   105c0:	e50b3008 	str	r3, [fp, #-8]
  if (func == SIG_DFL)
   105c4:	e51b3008 	ldr	r3, [fp, #-8]
   105c8:	e3530000 	cmp	r3, #0
   105cc:	1a000001 	bne	105d8 <__sigtramp_r+0x90>
    return 1;
   105d0:	e3a03001 	mov	r3, #1
   105d4:	ea000015 	b	10630 <__sigtramp_r+0xe8>
  else if (func == SIG_ERR)
   105d8:	e51b3008 	ldr	r3, [fp, #-8]
   105dc:	e3730001 	cmn	r3, #1
   105e0:	1a000001 	bne	105ec <__sigtramp_r+0xa4>
    return 2;
   105e4:	e3a03002 	mov	r3, #2
   105e8:	ea000010 	b	10630 <__sigtramp_r+0xe8>
  else if (func == SIG_IGN)
   105ec:	e51b3008 	ldr	r3, [fp, #-8]
   105f0:	e3530001 	cmp	r3, #1
   105f4:	1a000001 	bne	10600 <__sigtramp_r+0xb8>
    return 3;
   105f8:	e3a03003 	mov	r3, #3
   105fc:	ea00000b 	b	10630 <__sigtramp_r+0xe8>
  else
    {
      ptr->_sig_func[sig] = SIG_DFL;
   10600:	e51b3010 	ldr	r3, [fp, #-16]
   10604:	e59322dc 	ldr	r2, [r3, #732]	; 0x2dc
   10608:	e51b3014 	ldr	r3, [fp, #-20]
   1060c:	e1a03103 	lsl	r3, r3, #2
   10610:	e0823003 	add	r3, r2, r3
   10614:	e3a02000 	mov	r2, #0
   10618:	e5832000 	str	r2, [r3]
      func (sig);
   1061c:	e51b3008 	ldr	r3, [fp, #-8]
   10620:	e51b0014 	ldr	r0, [fp, #-20]
   10624:	e1a0e00f 	mov	lr, pc
   10628:	e12fff13 	bx	r3
      return 0;
   1062c:	e3a03000 	mov	r3, #0
    }
}
   10630:	e1a00003 	mov	r0, r3
   10634:	e24bd004 	sub	sp, fp, #4
   10638:	e8bd4800 	pop	{fp, lr}
   1063c:	e12fff1e 	bx	lr

00010640 <raise>:
#ifndef _REENT_ONLY

int 
_DEFUN (raise, (sig),
     int sig)
{
   10640:	e92d4800 	push	{fp, lr}
   10644:	e28db004 	add	fp, sp, #4
   10648:	e24dd008 	sub	sp, sp, #8
   1064c:	e50b0008 	str	r0, [fp, #-8]
  return _raise_r (_REENT, sig);
   10650:	e59f3020 	ldr	r3, [pc, #32]	; 10678 <raise+0x38>
   10654:	e5933000 	ldr	r3, [r3]
   10658:	e1a00003 	mov	r0, r3
   1065c:	e51b1008 	ldr	r1, [fp, #-8]
   10660:	ebffff71 	bl	1042c <_raise_r>
   10664:	e1a03000 	mov	r3, r0
}
   10668:	e1a00003 	mov	r0, r3
   1066c:	e24bd004 	sub	sp, fp, #4
   10670:	e8bd4800 	pop	{fp, lr}
   10674:	e12fff1e 	bx	lr
   10678:	00025440 	.word	0x00025440

0001067c <signal>:

_sig_func_ptr
_DEFUN (signal, (sig, func),
	int sig _AND
	_sig_func_ptr func)
{
   1067c:	e92d4800 	push	{fp, lr}
   10680:	e28db004 	add	fp, sp, #4
   10684:	e24dd008 	sub	sp, sp, #8
   10688:	e50b0008 	str	r0, [fp, #-8]
   1068c:	e50b100c 	str	r1, [fp, #-12]
  return _signal_r (_REENT, sig, func);
   10690:	e59f3024 	ldr	r3, [pc, #36]	; 106bc <signal+0x40>
   10694:	e5933000 	ldr	r3, [r3]
   10698:	e1a00003 	mov	r0, r3
   1069c:	e51b1008 	ldr	r1, [fp, #-8]
   106a0:	e51b200c 	ldr	r2, [fp, #-12]
   106a4:	ebffff31 	bl	10370 <_signal_r>
   106a8:	e1a03000 	mov	r3, r0
}
   106ac:	e1a00003 	mov	r0, r3
   106b0:	e24bd004 	sub	sp, fp, #4
   106b4:	e8bd4800 	pop	{fp, lr}
   106b8:	e12fff1e 	bx	lr
   106bc:	00025440 	.word	0x00025440

000106c0 <_init_signal>:

int 
_DEFUN_VOID (_init_signal)
{
   106c0:	e92d4800 	push	{fp, lr}
   106c4:	e28db004 	add	fp, sp, #4
  return _init_signal_r (_REENT);
   106c8:	e59f301c 	ldr	r3, [pc, #28]	; 106ec <_init_signal+0x2c>
   106cc:	e5933000 	ldr	r3, [r3]
   106d0:	e1a00003 	mov	r0, r3
   106d4:	ebfffefc 	bl	102cc <_init_signal_r>
   106d8:	e1a03000 	mov	r3, r0
}
   106dc:	e1a00003 	mov	r0, r3
   106e0:	e24bd004 	sub	sp, fp, #4
   106e4:	e8bd4800 	pop	{fp, lr}
   106e8:	e12fff1e 	bx	lr
   106ec:	00025440 	.word	0x00025440

000106f0 <__sigtramp>:

int
_DEFUN (__sigtramp, (sig), int sig)
{
   106f0:	e92d4800 	push	{fp, lr}
   106f4:	e28db004 	add	fp, sp, #4
   106f8:	e24dd008 	sub	sp, sp, #8
   106fc:	e50b0008 	str	r0, [fp, #-8]
  return __sigtramp_r (_REENT, sig);
   10700:	e59f3020 	ldr	r3, [pc, #32]	; 10728 <__sigtramp+0x38>
   10704:	e5933000 	ldr	r3, [r3]
   10708:	e1a00003 	mov	r0, r3
   1070c:	e51b1008 	ldr	r1, [fp, #-8]
   10710:	ebffff8c 	bl	10548 <__sigtramp_r>
   10714:	e1a03000 	mov	r3, r0
}
   10718:	e1a00003 	mov	r0, r3
   1071c:	e24bd004 	sub	sp, fp, #4
   10720:	e8bd4800 	pop	{fp, lr}
   10724:	e12fff1e 	bx	lr
   10728:	00025440 	.word	0x00025440

0001072c <_kill_r>:
int
_DEFUN (_kill_r, (ptr, pid, sig),
     struct _reent *ptr _AND
     int pid _AND
     int sig)
{
   1072c:	e92d4800 	push	{fp, lr}
   10730:	e28db004 	add	fp, sp, #4
   10734:	e24dd018 	sub	sp, sp, #24
   10738:	e50b0010 	str	r0, [fp, #-16]
   1073c:	e50b1014 	str	r1, [fp, #-20]
   10740:	e50b2018 	str	r2, [fp, #-24]
  int ret;

  errno = 0;
   10744:	e59f3054 	ldr	r3, [pc, #84]	; 107a0 <_kill_r+0x74>
   10748:	e3a02000 	mov	r2, #0
   1074c:	e5832000 	str	r2, [r3]
  if ((ret = _kill (pid, sig)) == -1 && errno != 0)
   10750:	e51b0014 	ldr	r0, [fp, #-20]
   10754:	e51b1018 	ldr	r1, [fp, #-24]
   10758:	eb002818 	bl	1a7c0 <kill>
   1075c:	e50b0008 	str	r0, [fp, #-8]
   10760:	e51b3008 	ldr	r3, [fp, #-8]
   10764:	e3730001 	cmn	r3, #1
   10768:	1a000007 	bne	1078c <_kill_r+0x60>
   1076c:	e59f302c 	ldr	r3, [pc, #44]	; 107a0 <_kill_r+0x74>
   10770:	e5933000 	ldr	r3, [r3]
   10774:	e3530000 	cmp	r3, #0
   10778:	0a000003 	beq	1078c <_kill_r+0x60>
    ptr->_errno = errno;
   1077c:	e59f301c 	ldr	r3, [pc, #28]	; 107a0 <_kill_r+0x74>
   10780:	e5932000 	ldr	r2, [r3]
   10784:	e51b3010 	ldr	r3, [fp, #-16]
   10788:	e5832000 	str	r2, [r3]
  return ret;
   1078c:	e51b3008 	ldr	r3, [fp, #-8]
}
   10790:	e1a00003 	mov	r0, r3
   10794:	e24bd004 	sub	sp, fp, #4
   10798:	e8bd4800 	pop	{fp, lr}
   1079c:	e12fff1e 	bx	lr
   107a0:	000819b0 	.word	0x000819b0

000107a4 <_getpid_r>:
*/

int
_DEFUN (_getpid_r, (ptr),
     struct _reent *ptr)
{
   107a4:	e92d4800 	push	{fp, lr}
   107a8:	e28db004 	add	fp, sp, #4
   107ac:	e24dd010 	sub	sp, sp, #16
   107b0:	e50b0010 	str	r0, [fp, #-16]
  int ret;
  ret = _getpid ();
   107b4:	eb0027f6 	bl	1a794 <getpid>
   107b8:	e50b0008 	str	r0, [fp, #-8]
  return ret;
   107bc:	e51b3008 	ldr	r3, [fp, #-8]
}
   107c0:	e1a00003 	mov	r0, r3
   107c4:	e24bd004 	sub	sp, fp, #4
   107c8:	e8bd4800 	pop	{fp, lr}
   107cc:	e12fff1e 	bx	lr

000107d0 <_sprintf_r>:
           struct _reent *ptr;
           char *str;
           _CONST char *fmt;
           va_dcl
#endif
{
   107d0:	e92d000c 	push	{r2, r3}
   107d4:	e92d4800 	push	{fp, lr}
   107d8:	e28db004 	add	fp, sp, #4
   107dc:	e24dd080 	sub	sp, sp, #128	; 0x80
   107e0:	e50b0080 	str	r0, [fp, #-128]	; 0x80
   107e4:	e50b1084 	str	r1, [fp, #-132]	; 0x84
  int ret;
  va_list ap;
  FILE f;

  f._flags = __SWR | __SSTR;
   107e8:	e3a03f82 	mov	r3, #520	; 0x208
   107ec:	e14b37b0 	strh	r3, [fp, #-112]	; 0xffffff90
  f._bf._base = f._p = (unsigned char *) str;
   107f0:	e51b3084 	ldr	r3, [fp, #-132]	; 0x84
   107f4:	e50b307c 	str	r3, [fp, #-124]	; 0x7c
   107f8:	e51b307c 	ldr	r3, [fp, #-124]	; 0x7c
   107fc:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
  f._bf._size = f._w = INT_MAX;
   10800:	e3e03102 	mvn	r3, #-2147483648	; 0x80000000
   10804:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   10808:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1080c:	e50b3068 	str	r3, [fp, #-104]	; 0x68
  f._file = -1;  /* No file. */
   10810:	e3e03000 	mvn	r3, #0
   10814:	e14b36be 	strh	r3, [fp, #-110]	; 0xffffff92
#ifdef _HAVE_STDC
  va_start (ap, fmt);
   10818:	e28b3008 	add	r3, fp, #8
   1081c:	e50b300c 	str	r3, [fp, #-12]
#else
  va_start (ap);
#endif
  ret = _svfprintf_r (ptr, &f, fmt, ap);
   10820:	e24b307c 	sub	r3, fp, #124	; 0x7c
   10824:	e51b0080 	ldr	r0, [fp, #-128]	; 0x80
   10828:	e1a01003 	mov	r1, r3
   1082c:	e59b2004 	ldr	r2, [fp, #4]
   10830:	e51b300c 	ldr	r3, [fp, #-12]
   10834:	eb000085 	bl	10a50 <_svfprintf_r>
   10838:	e50b0008 	str	r0, [fp, #-8]
  va_end (ap);
  *f._p = '\0';	/* terminate the string */
   1083c:	e51b307c 	ldr	r3, [fp, #-124]	; 0x7c
   10840:	e3a02000 	mov	r2, #0
   10844:	e5c32000 	strb	r2, [r3]
  return (ret);
   10848:	e51b3008 	ldr	r3, [fp, #-8]
}
   1084c:	e1a00003 	mov	r0, r3
   10850:	e24bd004 	sub	sp, fp, #4
   10854:	e8bd4800 	pop	{fp, lr}
   10858:	e28dd008 	add	sp, sp, #8
   1085c:	e12fff1e 	bx	lr

00010860 <sprintf>:
sprintf(str, fmt, va_alist)
        char *str;
        _CONST char *fmt;
        va_dcl
#endif
{
   10860:	e92d000e 	push	{r1, r2, r3}
   10864:	e92d4800 	push	{fp, lr}
   10868:	e28db004 	add	fp, sp, #4
   1086c:	e24dd084 	sub	sp, sp, #132	; 0x84
   10870:	e50b0084 	str	r0, [fp, #-132]	; 0x84
  int ret;
  va_list ap;
  FILE f;

  f._flags = __SWR | __SSTR;
   10874:	e3a03f82 	mov	r3, #520	; 0x208
   10878:	e14b37b4 	strh	r3, [fp, #-116]	; 0xffffff8c
  f._bf._base = f._p = (unsigned char *) str;
   1087c:	e51b3084 	ldr	r3, [fp, #-132]	; 0x84
   10880:	e50b3080 	str	r3, [fp, #-128]	; 0x80
   10884:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
   10888:	e50b3070 	str	r3, [fp, #-112]	; 0x70
  f._bf._size = f._w = INT_MAX;
   1088c:	e3e03102 	mvn	r3, #-2147483648	; 0x80000000
   10890:	e50b3078 	str	r3, [fp, #-120]	; 0x78
   10894:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   10898:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
  f._file = -1;  /* No file. */
   1089c:	e3e03000 	mvn	r3, #0
   108a0:	e14b37b2 	strh	r3, [fp, #-114]	; 0xffffff8e
#ifdef _HAVE_STDC
  va_start (ap, fmt);
   108a4:	e28b3008 	add	r3, fp, #8
   108a8:	e50b3010 	str	r3, [fp, #-16]
#else
  va_start (ap);
#endif
  ret = _svfprintf_r (_REENT, &f, fmt, ap);
   108ac:	e59f3040 	ldr	r3, [pc, #64]	; 108f4 <sprintf+0x94>
   108b0:	e5932000 	ldr	r2, [r3]
   108b4:	e24b3080 	sub	r3, fp, #128	; 0x80
   108b8:	e1a00002 	mov	r0, r2
   108bc:	e1a01003 	mov	r1, r3
   108c0:	e59b2004 	ldr	r2, [fp, #4]
   108c4:	e51b3010 	ldr	r3, [fp, #-16]
   108c8:	eb000060 	bl	10a50 <_svfprintf_r>
   108cc:	e50b000c 	str	r0, [fp, #-12]
  va_end (ap);
  *f._p = '\0';	/* terminate the string */
   108d0:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
   108d4:	e3a02000 	mov	r2, #0
   108d8:	e5c32000 	strb	r2, [r3]
  return (ret);
   108dc:	e51b300c 	ldr	r3, [fp, #-12]
}
   108e0:	e1a00003 	mov	r0, r3
   108e4:	e24bd004 	sub	sp, fp, #4
   108e8:	e8bd4800 	pop	{fp, lr}
   108ec:	e28dd00c 	add	sp, sp, #12
   108f0:	e12fff1e 	bx	lr
   108f4:	00025440 	.word	0x00025440

000108f8 <strcpy>:
#endif

char* __attribute__((naked))
strcpy (char* dst, const char* src)
{
  asm (
   108f8:	e0202001 	eor	r2, r0, r1
   108fc:	e1a0c000 	mov	ip, r0
   10900:	e3120003 	tst	r2, #3
   10904:	1a000032 	bne	109d4 <strcpy+0xdc>
   10908:	e3110003 	tst	r1, #3
   1090c:	1a000021 	bne	10998 <strcpy+0xa0>
   10910:	e52d5004 	push	{r5}		; (str r5, [sp, #-4]!)
   10914:	e3a05001 	mov	r5, #1
   10918:	e1855405 	orr	r5, r5, r5, lsl #8
   1091c:	e1855805 	orr	r5, r5, r5, lsl #16
   10920:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
   10924:	e3110004 	tst	r1, #4
   10928:	e4913004 	ldr	r3, [r1], #4
   1092c:	0a000005 	beq	10948 <strcpy+0x50>
   10930:	e0432005 	sub	r2, r3, r5
   10934:	e1d22003 	bics	r2, r2, r3
   10938:	e1120385 	tst	r2, r5, lsl #7
   1093c:	048c3004 	streq	r3, [ip], #4
   10940:	04913004 	ldreq	r3, [r1], #4
   10944:	1a00000c 	bne	1097c <strcpy+0x84>
   10948:	e4914004 	ldr	r4, [r1], #4
   1094c:	e0432005 	sub	r2, r3, r5
   10950:	e1d22003 	bics	r2, r2, r3
   10954:	e1120385 	tst	r2, r5, lsl #7
   10958:	e0442005 	sub	r2, r4, r5
   1095c:	1a000006 	bne	1097c <strcpy+0x84>
   10960:	e48c3004 	str	r3, [ip], #4
   10964:	e1d22004 	bics	r2, r2, r4
   10968:	e1120385 	tst	r2, r5, lsl #7
   1096c:	04913004 	ldreq	r3, [r1], #4
   10970:	048c4004 	streq	r4, [ip], #4
   10974:	0afffff3 	beq	10948 <strcpy+0x50>
   10978:	e1a03004 	mov	r3, r4
   1097c:	e4cc3001 	strb	r3, [ip], #1
   10980:	e31300ff 	tst	r3, #255	; 0xff
   10984:	e1a03463 	ror	r3, r3, #8
   10988:	1afffffb 	bne	1097c <strcpy+0x84>
   1098c:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
   10990:	e49d5004 	pop	{r5}		; (ldr r5, [sp], #4)
   10994:	e12fff1e 	bx	lr
   10998:	e3110001 	tst	r1, #1
   1099c:	0a000003 	beq	109b0 <strcpy+0xb8>
   109a0:	e4d12001 	ldrb	r2, [r1], #1
   109a4:	e4cc2001 	strb	r2, [ip], #1
   109a8:	e3520000 	cmp	r2, #0
   109ac:	012fff1e 	bxeq	lr
   109b0:	e3110002 	tst	r1, #2
   109b4:	0affffd5 	beq	10910 <strcpy+0x18>
   109b8:	e0d120b2 	ldrh	r2, [r1], #2
   109bc:	e31200ff 	tst	r2, #255	; 0xff
   109c0:	10cc20b2 	strhne	r2, [ip], #2
   109c4:	05cc2000 	strbeq	r2, [ip]
   109c8:	13120cff 	tstne	r2, #65280	; 0xff00
   109cc:	1affffcf 	bne	10910 <strcpy+0x18>
   109d0:	e12fff1e 	bx	lr
   109d4:	e4d12001 	ldrb	r2, [r1], #1
   109d8:	e4cc2001 	strb	r2, [ip], #1
   109dc:	e3520000 	cmp	r2, #0
   109e0:	1afffffb 	bne	109d4 <strcpy+0xdc>
   109e4:	e12fff1e 	bx	lr
       "cmp	r2, #0\n\t"
       "bne	1b\n\t"
       "RETURN"
#endif
       );
}
   109e8:	e1a00003 	mov	r0, r3

000109ec <strlen>:
#if !(defined(_ISA_ARM_7) || defined(__ARM_ARCH_6T2__))

size_t __attribute__((naked))
strlen (const char* str)
{
  asm ("len .req r0\n\t"
   109ec:	e3c01003 	bic	r1, r0, #3
   109f0:	e2100003 	ands	r0, r0, #3
   109f4:	e2600000 	rsb	r0, r0, #0
   109f8:	e4913004 	ldr	r3, [r1], #4
   109fc:	e280c004 	add	ip, r0, #4
   10a00:	e1a0c18c 	lsl	ip, ip, #3
   10a04:	e3e02000 	mvn	r2, #0
   10a08:	11833c32 	orrne	r3, r3, r2, lsr ip
   10a0c:	e3a0c001 	mov	ip, #1
   10a10:	e18cc40c 	orr	ip, ip, ip, lsl #8
   10a14:	e18cc80c 	orr	ip, ip, ip, lsl #16
   10a18:	e043200c 	sub	r2, r3, ip
   10a1c:	e1c22003 	bic	r2, r2, r3
   10a20:	e012238c 	ands	r2, r2, ip, lsl #7
   10a24:	04913004 	ldreq	r3, [r1], #4
   10a28:	02800004 	addeq	r0, r0, #4
   10a2c:	0afffff9 	beq	10a18 <strlen+0x2c>
   10a30:	e31300ff 	tst	r3, #255	; 0xff
   10a34:	12800001 	addne	r0, r0, #1
   10a38:	13130cff 	tstne	r3, #65280	; 0xff00
   10a3c:	12800001 	addne	r0, r0, #1
   10a40:	131308ff 	tstne	r3, #16711680	; 0xff0000
   10a44:	12800001 	addne	r0, r0, #1
   10a48:	e12fff1e 	bx	lr
       "it	ne\n\t"
       "addne	len, len, #1\n\t"
# endif
#endif
       "RETURN");
}
   10a4c:	e1a00003 	mov	r0, r3

00010a50 <_svfprintf_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
   10a50:	e92d4bf0 	push	{r4, r5, r6, r7, r8, r9, fp, lr}
   10a54:	e28db01c 	add	fp, sp, #28
   10a58:	e24ddd06 	sub	sp, sp, #384	; 0x180
   10a5c:	e50b0160 	str	r0, [fp, #-352]	; 0x160
   10a60:	e50b1164 	str	r1, [fp, #-356]	; 0x164
   10a64:	e50b2168 	str	r2, [fp, #-360]	; 0x168
   10a68:	e50b316c 	str	r3, [fp, #-364]	; 0x16c
	int width;		/* width from format (%8d), or 0 */
	int prec;		/* precision from format (%.3d), or -1 */
	char sign;		/* sign prefix (' ', '+', '-', or \0) */
#ifdef _WANT_IO_C99_FORMATS
				/* locale specific numeric grouping */
	char *thousands_sep = NULL;
   10a6c:	e3a03000 	mov	r3, #0
   10a70:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	size_t thsnd_len = 0;
   10a74:	e3a03000 	mov	r3, #0
   10a78:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	const char *grouping = NULL;
   10a7c:	e3a03000 	mov	r3, #0
   10a80:	e50b3034 	str	r3, [fp, #-52]	; 0x34
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
   10a84:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   10a88:	eb0027a1 	bl	1a914 <_localeconv_r>
   10a8c:	e1a03000 	mov	r3, r0
   10a90:	e5933000 	ldr	r3, [r3]
   10a94:	e50b3074 	str	r3, [fp, #-116]	; 0x74
	size_t decp_len = strlen (decimal_point);
   10a98:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
   10a9c:	ebffffd2 	bl	109ec <strlen>
   10aa0:	e50b0078 	str	r0, [fp, #-120]	; 0x78
	char softsign;		/* temporary negative sign for floats */
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
   10aa4:	e3a03000 	mov	r3, #0
   10aa8:	e3a04000 	mov	r4, #0
   10aac:	e50b3094 	str	r3, [fp, #-148]	; 0x94
   10ab0:	e50b4090 	str	r4, [fp, #-144]	; 0x90
# define _fpvalue (_double_.fp)
	int expt;		/* integer value of exponent */
	int expsize = 0;	/* character count for expstr */
   10ab4:	e3a03000 	mov	r3, #0
   10ab8:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	char expstr[MAXEXPLEN];	/* buffer for exponent string */
	int lead;		/* sig figs before decimal or group sep */
#endif /* FLOATING_POINT */
#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
	int ndig = 0;		/* actual number of digits returned by cvt */
   10abc:	e3a03000 	mov	r3, #0
   10ac0:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
   10ac4:	e3a03000 	mov	r3, #0
   10ac8:	e50b3060 	str	r3, [fp, #-96]	; 0x60
	char ox[2];		/* space for 0x hex-prefix */
#ifdef _MB_CAPABLE
	wchar_t wc;
	mbstate_t state;        /* mbtowc calls from library must not change state */
#endif
	char *malloc_buf = NULL;/* handy pointer for malloced buffers */
   10acc:	e3a03000 	mov	r3, #0
   10ad0:	e50b3064 	str	r3, [fp, #-100]	; 0x64
		return (__sbprintf (data, fp, fmt0, ap));
	}
#endif
#else /* STRING_ONLY */
        /* Create initial buffer if we are called by asprintf family.  */
        if (fp->_flags & __SMBF && !fp->_bf._base)
   10ad4:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   10ad8:	e1d330bc 	ldrh	r3, [r3, #12]
   10adc:	e1a03803 	lsl	r3, r3, #16
   10ae0:	e1a03823 	lsr	r3, r3, #16
   10ae4:	e2033080 	and	r3, r3, #128	; 0x80
   10ae8:	e3530000 	cmp	r3, #0
   10aec:	0a000019 	beq	10b58 <_svfprintf_r+0x108>
   10af0:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   10af4:	e5933010 	ldr	r3, [r3, #16]
   10af8:	e3530000 	cmp	r3, #0
   10afc:	1a000015 	bne	10b58 <_svfprintf_r+0x108>
        {
		fp->_bf._base = fp->_p = _malloc_r (data, 64);
   10b00:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   10b04:	e3a01040 	mov	r1, #64	; 0x40
   10b08:	ebfff949 	bl	f034 <_malloc_r>
   10b0c:	e1a02000 	mov	r2, r0
   10b10:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   10b14:	e5832000 	str	r2, [r3]
   10b18:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   10b1c:	e5932000 	ldr	r2, [r3]
   10b20:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   10b24:	e5832010 	str	r2, [r3, #16]
		if (!fp->_p)
   10b28:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   10b2c:	e5933000 	ldr	r3, [r3]
   10b30:	e3530000 	cmp	r3, #0
   10b34:	1a000004 	bne	10b4c <_svfprintf_r+0xfc>
		{
			data->_errno = ENOMEM;
   10b38:	e51b3160 	ldr	r3, [fp, #-352]	; 0x160
   10b3c:	e3a0200c 	mov	r2, #12
   10b40:	e5832000 	str	r2, [r3]
			return EOF;
   10b44:	e3e03000 	mvn	r3, #0
   10b48:	ea0009b4 	b	13220 <_svfprintf_r+0x27d0>
		}
		fp->_bf._size = 64;
   10b4c:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   10b50:	e3a02040 	mov	r2, #64	; 0x40
   10b54:	e5832014 	str	r2, [r3, #20]
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
   10b58:	e51b9168 	ldr	r9, [fp, #-360]	; 0x168
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   10b5c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   10b60:	e50b40b0 	str	r4, [fp, #-176]	; 0xb0
	uio.uio_resid = 0;
   10b64:	e3a03000 	mov	r3, #0
   10b68:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
	uio.uio_iovcnt = 0;
   10b6c:	e3a03000 	mov	r3, #0
   10b70:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
#endif
	ret = 0;
   10b74:	e3a03000 	mov	r3, #0
   10b78:	e50b3020 	str	r3, [fp, #-32]

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
	        cp = fmt;
   10b7c:	e1a07009 	mov	r7, r9
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   10b80:	ea000000 	b	10b88 <_svfprintf_r+0x138>
                    fmt += 1;
   10b84:	e2899001 	add	r9, r9, #1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   10b88:	e5d93000 	ldrb	r3, [r9]
   10b8c:	e3530000 	cmp	r3, #0
   10b90:	0a000002 	beq	10ba0 <_svfprintf_r+0x150>
   10b94:	e5d93000 	ldrb	r3, [r9]
   10b98:	e3530025 	cmp	r3, #37	; 0x25
   10b9c:	1afffff8 	bne	10b84 <_svfprintf_r+0x134>
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
   10ba0:	e1a02009 	mov	r2, r9
   10ba4:	e1a03007 	mov	r3, r7
   10ba8:	e0635002 	rsb	r5, r3, r2
   10bac:	e3550000 	cmp	r5, #0
   10bb0:	0a000019 	beq	10c1c <_svfprintf_r+0x1cc>
			PRINT (cp, m);
   10bb4:	e5847000 	str	r7, [r4]
   10bb8:	e1a03005 	mov	r3, r5
   10bbc:	e5843004 	str	r3, [r4, #4]
   10bc0:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   10bc4:	e0833005 	add	r3, r3, r5
   10bc8:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   10bcc:	e2844008 	add	r4, r4, #8
   10bd0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   10bd4:	e2833001 	add	r3, r3, #1
   10bd8:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   10bdc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   10be0:	e3530007 	cmp	r3, #7
   10be4:	da000009 	ble	10c10 <_svfprintf_r+0x1c0>
   10be8:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   10bec:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   10bf0:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   10bf4:	e1a02003 	mov	r2, r3
   10bf8:	eb003567 	bl	1e19c <__ssprint_r>
   10bfc:	e1a03000 	mov	r3, r0
   10c00:	e3530000 	cmp	r3, #0
   10c04:	0a000000 	beq	10c0c <_svfprintf_r+0x1bc>
   10c08:	ea000973 	b	131dc <_svfprintf_r+0x278c>
   10c0c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
			ret += m;
   10c10:	e51b3020 	ldr	r3, [fp, #-32]
   10c14:	e0833005 	add	r3, r3, r5
   10c18:	e50b3020 	str	r3, [fp, #-32]
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   10c1c:	e5d93000 	ldrb	r3, [r9]
   10c20:	e3530000 	cmp	r3, #0
   10c24:	1a000000 	bne	10c2c <_svfprintf_r+0x1dc>
                    goto done;
   10c28:	ea00095c 	b	131a0 <_svfprintf_r+0x2750>
#endif
		fmt_anchor = fmt;
   10c2c:	e50b907c 	str	r9, [fp, #-124]	; 0x7c
		fmt++;		/* skip over '%' */
   10c30:	e2899001 	add	r9, r9, #1

		flags = 0;
   10c34:	e3a06000 	mov	r6, #0
		dprec = 0;
   10c38:	e3a03000 	mov	r3, #0
   10c3c:	e50b3054 	str	r3, [fp, #-84]	; 0x54
		width = 0;
   10c40:	e3a03000 	mov	r3, #0
   10c44:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		prec = -1;
   10c48:	e3e03000 	mvn	r3, #0
   10c4c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		sign = '\0';
   10c50:	e3a03000 	mov	r3, #0
   10c54:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
#ifdef FLOATING_POINT
		lead = 0;
   10c58:	e3a03000 	mov	r3, #0
   10c5c:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
#ifdef _WANT_IO_C99_FORMATS
		nseps = nrepeats = 0;
   10c60:	e3a03000 	mov	r3, #0
   10c64:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   10c68:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   10c6c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   10c70:	e1a03009 	mov	r3, r9
   10c74:	e2839001 	add	r9, r3, #1
   10c78:	e5d33000 	ldrb	r3, [r3]
   10c7c:	e1a08003 	mov	r8, r3
reswitch:	switch (ch) {
   10c80:	e2483020 	sub	r3, r8, #32
   10c84:	e353005a 	cmp	r3, #90	; 0x5a
   10c88:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   10c8c:	ea000443 	b	11da0 <_svfprintf_r+0x1350>
   10c90:	00010e60 	.word	0x00010e60
   10c94:	00011da0 	.word	0x00011da0
   10c98:	00011da0 	.word	0x00011da0
   10c9c:	00010e78 	.word	0x00010e78
   10ca0:	00011da0 	.word	0x00011da0
   10ca4:	00011da0 	.word	0x00011da0
   10ca8:	00011da0 	.word	0x00011da0
   10cac:	00010dfc 	.word	0x00010dfc
   10cb0:	00011da0 	.word	0x00011da0
   10cb4:	00011da0 	.word	0x00011da0
   10cb8:	00010e80 	.word	0x00010e80
   10cbc:	00010eb8 	.word	0x00010eb8
   10cc0:	00011da0 	.word	0x00011da0
   10cc4:	00010eb0 	.word	0x00010eb0
   10cc8:	00010ec4 	.word	0x00010ec4
   10ccc:	00011da0 	.word	0x00011da0
   10cd0:	00010f60 	.word	0x00010f60
   10cd4:	00010f68 	.word	0x00010f68
   10cd8:	00010f68 	.word	0x00010f68
   10cdc:	00010f68 	.word	0x00010f68
   10ce0:	00010f68 	.word	0x00010f68
   10ce4:	00010f68 	.word	0x00010f68
   10ce8:	00010f68 	.word	0x00010f68
   10cec:	00010f68 	.word	0x00010f68
   10cf0:	00010f68 	.word	0x00010f68
   10cf4:	00010f68 	.word	0x00010f68
   10cf8:	00011da0 	.word	0x00011da0
   10cfc:	00011da0 	.word	0x00011da0
   10d00:	00011da0 	.word	0x00011da0
   10d04:	00011da0 	.word	0x00011da0
   10d08:	00011da0 	.word	0x00011da0
   10d0c:	00011da0 	.word	0x00011da0
   10d10:	00011da0 	.word	0x00011da0
   10d14:	00011154 	.word	0x00011154
   10d18:	00011da0 	.word	0x00011da0
   10d1c:	00011004 	.word	0x00011004
   10d20:	00011034 	.word	0x00011034
   10d24:	00011154 	.word	0x00011154
   10d28:	00011154 	.word	0x00011154
   10d2c:	00011154 	.word	0x00011154
   10d30:	00011da0 	.word	0x00011da0
   10d34:	00011da0 	.word	0x00011da0
   10d38:	00011da0 	.word	0x00011da0
   10d3c:	00011da0 	.word	0x00011da0
   10d40:	00010fac 	.word	0x00010fac
   10d44:	00011da0 	.word	0x00011da0
   10d48:	00011da0 	.word	0x00011da0
   10d4c:	000116c8 	.word	0x000116c8
   10d50:	00011da0 	.word	0x00011da0
   10d54:	00011da0 	.word	0x00011da0
   10d58:	00011da0 	.word	0x00011da0
   10d5c:	000117f8 	.word	0x000117f8
   10d60:	00011da0 	.word	0x00011da0
   10d64:	000118b8 	.word	0x000118b8
   10d68:	00011da0 	.word	0x00011da0
   10d6c:	00011da0 	.word	0x00011da0
   10d70:	00011998 	.word	0x00011998
   10d74:	00011da0 	.word	0x00011da0
   10d78:	00011da0 	.word	0x00011da0
   10d7c:	00011da0 	.word	0x00011da0
   10d80:	00011da0 	.word	0x00011da0
   10d84:	00011da0 	.word	0x00011da0
   10d88:	00011da0 	.word	0x00011da0
   10d8c:	00011da0 	.word	0x00011da0
   10d90:	00011da0 	.word	0x00011da0
   10d94:	00011154 	.word	0x00011154
   10d98:	00011da0 	.word	0x00011da0
   10d9c:	00011004 	.word	0x00011004
   10da0:	00011038 	.word	0x00011038
   10da4:	00011154 	.word	0x00011154
   10da8:	00011154 	.word	0x00011154
   10dac:	00011154 	.word	0x00011154
   10db0:	00010fb4 	.word	0x00010fb4
   10db4:	00011038 	.word	0x00011038
   10db8:	00010ffc 	.word	0x00010ffc
   10dbc:	00011da0 	.word	0x00011da0
   10dc0:	00010fd4 	.word	0x00010fd4
   10dc4:	00011da0 	.word	0x00011da0
   10dc8:	000115f4 	.word	0x000115f4
   10dcc:	000116cc 	.word	0x000116cc
   10dd0:	000117ac 	.word	0x000117ac
   10dd4:	00010ff4 	.word	0x00010ff4
   10dd8:	00011da0 	.word	0x00011da0
   10ddc:	000117f8 	.word	0x000117f8
   10de0:	00010c70 	.word	0x00010c70
   10de4:	000118bc 	.word	0x000118bc
   10de8:	00011da0 	.word	0x00011da0
   10dec:	00011da0 	.word	0x00011da0
   10df0:	000119a4 	.word	0x000119a4
   10df4:	00011da0 	.word	0x00011da0
   10df8:	00010c70 	.word	0x00010c70
#ifdef _WANT_IO_C99_FORMATS
		case '\'':
			thousands_sep = _localeconv_r (data)->thousands_sep;
   10dfc:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   10e00:	eb0026c3 	bl	1a914 <_localeconv_r>
   10e04:	e1a03000 	mov	r3, r0
   10e08:	e5933004 	ldr	r3, [r3, #4]
   10e0c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
			thsnd_len = strlen (thousands_sep);
   10e10:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
   10e14:	ebfffef4 	bl	109ec <strlen>
   10e18:	e50b0030 	str	r0, [fp, #-48]	; 0x30
			grouping = _localeconv_r (data)->grouping;
   10e1c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   10e20:	eb0026bb 	bl	1a914 <_localeconv_r>
   10e24:	e1a03000 	mov	r3, r0
   10e28:	e5933008 	ldr	r3, [r3, #8]
   10e2c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
			if (thsnd_len > 0 && grouping && *grouping)
   10e30:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   10e34:	e3530000 	cmp	r3, #0
   10e38:	0a000007 	beq	10e5c <_svfprintf_r+0x40c>
   10e3c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   10e40:	e3530000 	cmp	r3, #0
   10e44:	0a000004 	beq	10e5c <_svfprintf_r+0x40c>
   10e48:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   10e4c:	e5d33000 	ldrb	r3, [r3]
   10e50:	e3530000 	cmp	r3, #0
   10e54:	0a000000 	beq	10e5c <_svfprintf_r+0x40c>
			  flags |= GROUPING;
   10e58:	e3866b01 	orr	r6, r6, #1024	; 0x400
			goto rflag;
   10e5c:	eaffff83 	b	10c70 <_svfprintf_r+0x220>
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
   10e60:	e55b3085 	ldrb	r3, [fp, #-133]	; 0x85
   10e64:	e3530000 	cmp	r3, #0
   10e68:	1a000001 	bne	10e74 <_svfprintf_r+0x424>
				sign = ' ';
   10e6c:	e3a03020 	mov	r3, #32
   10e70:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
			goto rflag;
   10e74:	eaffff7d 	b	10c70 <_svfprintf_r+0x220>
		case '#':
			flags |= ALT;
   10e78:	e3866001 	orr	r6, r6, #1
			goto rflag;
   10e7c:	eaffff7b 	b	10c70 <_svfprintf_r+0x220>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   10e80:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   10e84:	e2832004 	add	r2, r3, #4
   10e88:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   10e8c:	e5933000 	ldr	r3, [r3]
   10e90:	e50b3024 	str	r3, [fp, #-36]	; 0x24
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
   10e94:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   10e98:	e3530000 	cmp	r3, #0
   10e9c:	ba000000 	blt	10ea4 <_svfprintf_r+0x454>
				goto rflag;
   10ea0:	eaffff72 	b	10c70 <_svfprintf_r+0x220>
			width = -width;
   10ea4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   10ea8:	e2633000 	rsb	r3, r3, #0
   10eac:	e50b3024 	str	r3, [fp, #-36]	; 0x24
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
   10eb0:	e3866004 	orr	r6, r6, #4
			goto rflag;
   10eb4:	eaffff6d 	b	10c70 <_svfprintf_r+0x220>
		case '+':
			sign = '+';
   10eb8:	e3a0302b 	mov	r3, #43	; 0x2b
   10ebc:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
			goto rflag;
   10ec0:	eaffff6a 	b	10c70 <_svfprintf_r+0x220>
		case '.':
			if ((ch = *fmt++) == '*') {
   10ec4:	e1a03009 	mov	r3, r9
   10ec8:	e2839001 	add	r9, r3, #1
   10ecc:	e5d33000 	ldrb	r3, [r3]
   10ed0:	e1a08003 	mov	r8, r3
   10ed4:	e358002a 	cmp	r8, #42	; 0x2a
   10ed8:	1a00000a 	bne	10f08 <_svfprintf_r+0x4b8>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   10edc:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   10ee0:	e2832004 	add	r2, r3, #4
   10ee4:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   10ee8:	e5933000 	ldr	r3, [r3]
   10eec:	e50b3028 	str	r3, [fp, #-40]	; 0x28
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   10ef0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   10ef4:	e3530000 	cmp	r3, #0
   10ef8:	aa000001 	bge	10f04 <_svfprintf_r+0x4b4>
					prec = -1;
   10efc:	e3e03000 	mvn	r3, #0
   10f00:	e50b3028 	str	r3, [fp, #-40]	; 0x28
				goto rflag;
   10f04:	eaffff59 	b	10c70 <_svfprintf_r+0x220>
			}
			n = 0;
   10f08:	e3a05000 	mov	r5, #0
			while (is_digit (ch)) {
   10f0c:	ea00000a 	b	10f3c <_svfprintf_r+0x4ec>
				n = 10 * n + to_digit (ch);
   10f10:	e1a03005 	mov	r3, r5
   10f14:	e1a03103 	lsl	r3, r3, #2
   10f18:	e0833005 	add	r3, r3, r5
   10f1c:	e1a03083 	lsl	r3, r3, #1
   10f20:	e1a02003 	mov	r2, r3
   10f24:	e2483030 	sub	r3, r8, #48	; 0x30
   10f28:	e0825003 	add	r5, r2, r3
				ch = *fmt++;
   10f2c:	e1a03009 	mov	r3, r9
   10f30:	e2839001 	add	r9, r3, #1
   10f34:	e5d33000 	ldrb	r3, [r3]
   10f38:	e1a08003 	mov	r8, r3
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   10f3c:	e2483030 	sub	r3, r8, #48	; 0x30
   10f40:	e3530009 	cmp	r3, #9
   10f44:	9afffff1 	bls	10f10 <_svfprintf_r+0x4c0>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
   10f48:	e3e03000 	mvn	r3, #0
   10f4c:	e1550003 	cmp	r5, r3
   10f50:	a1a03005 	movge	r3, r5
   10f54:	b1a03003 	movlt	r3, r3
   10f58:	e50b3028 	str	r3, [fp, #-40]	; 0x28
			goto reswitch;
   10f5c:	eaffff47 	b	10c80 <_svfprintf_r+0x230>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
   10f60:	e3866080 	orr	r6, r6, #128	; 0x80
			goto rflag;
   10f64:	eaffff41 	b	10c70 <_svfprintf_r+0x220>
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
   10f68:	e3a05000 	mov	r5, #0
			do {
				n = 10 * n + to_digit (ch);
   10f6c:	e1a03005 	mov	r3, r5
   10f70:	e1a03103 	lsl	r3, r3, #2
   10f74:	e0833005 	add	r3, r3, r5
   10f78:	e1a03083 	lsl	r3, r3, #1
   10f7c:	e1a02003 	mov	r2, r3
   10f80:	e2483030 	sub	r3, r8, #48	; 0x30
   10f84:	e0825003 	add	r5, r2, r3
				ch = *fmt++;
   10f88:	e1a03009 	mov	r3, r9
   10f8c:	e2839001 	add	r9, r3, #1
   10f90:	e5d33000 	ldrb	r3, [r3]
   10f94:	e1a08003 	mov	r8, r3
			} while (is_digit (ch));
   10f98:	e2483030 	sub	r3, r8, #48	; 0x30
   10f9c:	e3530009 	cmp	r3, #9
   10fa0:	9afffff1 	bls	10f6c <_svfprintf_r+0x51c>
				}
				else
					goto error;
			}
#endif /* !_NO_POS_ARGS */
			width = n;
   10fa4:	e50b5024 	str	r5, [fp, #-36]	; 0x24
			goto reswitch;
   10fa8:	eaffff34 	b	10c80 <_svfprintf_r+0x230>
#ifdef FLOATING_POINT
		case 'L':
			flags |= LONGDBL;
   10fac:	e3866008 	orr	r6, r6, #8
			goto rflag;
   10fb0:	eaffff2e 	b	10c70 <_svfprintf_r+0x220>
#endif
		case 'h':
#ifdef _WANT_IO_C99_FORMATS
			if (*fmt == 'h') {
   10fb4:	e5d93000 	ldrb	r3, [r9]
   10fb8:	e3530068 	cmp	r3, #104	; 0x68
   10fbc:	1a000002 	bne	10fcc <_svfprintf_r+0x57c>
				fmt++;
   10fc0:	e2899001 	add	r9, r9, #1
				flags |= CHARINT;
   10fc4:	e3866c02 	orr	r6, r6, #512	; 0x200
   10fc8:	ea000000 	b	10fd0 <_svfprintf_r+0x580>
			} else
#endif
				flags |= SHORTINT;
   10fcc:	e3866040 	orr	r6, r6, #64	; 0x40
			goto rflag;
   10fd0:	eaffff26 	b	10c70 <_svfprintf_r+0x220>
		case 'l':
#if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
			if (*fmt == 'l') {
   10fd4:	e5d93000 	ldrb	r3, [r9]
   10fd8:	e353006c 	cmp	r3, #108	; 0x6c
   10fdc:	1a000002 	bne	10fec <_svfprintf_r+0x59c>
				fmt++;
   10fe0:	e2899001 	add	r9, r9, #1
				flags |= QUADINT;
   10fe4:	e3866020 	orr	r6, r6, #32
   10fe8:	ea000000 	b	10ff0 <_svfprintf_r+0x5a0>
			} else
#endif
				flags |= LONGINT;
   10fec:	e3866010 	orr	r6, r6, #16
			goto rflag;
   10ff0:	eaffff1e 	b	10c70 <_svfprintf_r+0x220>
		case 'q': /* extension */
			flags |= QUADINT;
   10ff4:	e3866020 	orr	r6, r6, #32
			goto rflag;
   10ff8:	eaffff1c 	b	10c70 <_svfprintf_r+0x220>
#ifdef _WANT_IO_C99_FORMATS
		case 'j':
		  if (sizeof (intmax_t) == sizeof (long))
		    flags |= LONGINT;
		  else
		    flags |= QUADINT;
   10ffc:	e3866020 	orr	r6, r6, #32
		  goto rflag;
   11000:	eaffff1a 	b	10c70 <_svfprintf_r+0x220>
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
   11004:	e24b7f55 	sub	r7, fp, #340	; 0x154
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   11008:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1100c:	e2832004 	add	r2, r3, #4
   11010:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11014:	e5933000 	ldr	r3, [r3]
   11018:	e20330ff 	and	r3, r3, #255	; 0xff
   1101c:	e5c73000 	strb	r3, [r7]
				size = 1;
   11020:	e3a03001 	mov	r3, #1
   11024:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
			}
			sign = '\0';
   11028:	e3a03000 	mov	r3, #0
   1102c:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
			break;
   11030:	ea000365 	b	11dcc <_svfprintf_r+0x137c>
		case 'D':  /* extension */
			flags |= LONGINT;
   11034:	e3866010 	orr	r6, r6, #16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   11038:	e2063020 	and	r3, r6, #32
   1103c:	e3530000 	cmp	r3, #0
   11040:	0a000006 	beq	11060 <_svfprintf_r+0x610>
   11044:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   11048:	e2833007 	add	r3, r3, #7
   1104c:	e3c33007 	bic	r3, r3, #7
   11050:	e2832008 	add	r2, r3, #8
   11054:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11058:	e893000c 	ldm	r3, {r2, r3}
   1105c:	ea00002a 	b	1110c <_svfprintf_r+0x6bc>
   11060:	e2063010 	and	r3, r6, #16
   11064:	e3530000 	cmp	r3, #0
   11068:	0a000006 	beq	11088 <_svfprintf_r+0x638>
   1106c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   11070:	e2832004 	add	r2, r3, #4
   11074:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11078:	e5933000 	ldr	r3, [r3]
   1107c:	e1a02003 	mov	r2, r3
   11080:	e1a03fc2 	asr	r3, r2, #31
   11084:	ea000020 	b	1110c <_svfprintf_r+0x6bc>
   11088:	e2063040 	and	r3, r6, #64	; 0x40
   1108c:	e3530000 	cmp	r3, #0
   11090:	0a00000a 	beq	110c0 <_svfprintf_r+0x670>
   11094:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   11098:	e2832004 	add	r2, r3, #4
   1109c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   110a0:	e5933000 	ldr	r3, [r3]
   110a4:	e1a03803 	lsl	r3, r3, #16
   110a8:	e1a01823 	lsr	r1, r3, #16
   110ac:	e1a03801 	lsl	r3, r1, #16
   110b0:	e1a03843 	asr	r3, r3, #16
   110b4:	e1a02003 	mov	r2, r3
   110b8:	e1a03fc2 	asr	r3, r2, #31
   110bc:	ea000012 	b	1110c <_svfprintf_r+0x6bc>
   110c0:	e2063c02 	and	r3, r6, #512	; 0x200
   110c4:	e3530000 	cmp	r3, #0
   110c8:	0a000009 	beq	110f4 <_svfprintf_r+0x6a4>
   110cc:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   110d0:	e2832004 	add	r2, r3, #4
   110d4:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   110d8:	e5933000 	ldr	r3, [r3]
   110dc:	e20310ff 	and	r1, r3, #255	; 0xff
   110e0:	e1a03c01 	lsl	r3, r1, #24
   110e4:	e1a03c43 	asr	r3, r3, #24
   110e8:	e1a02003 	mov	r2, r3
   110ec:	e1a03fc2 	asr	r3, r2, #31
   110f0:	ea000005 	b	1110c <_svfprintf_r+0x6bc>
   110f4:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   110f8:	e2832004 	add	r2, r3, #4
   110fc:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11100:	e5933000 	ldr	r3, [r3]
   11104:	e1a02003 	mov	r2, r3
   11108:	e1a03fc2 	asr	r3, r2, #31
   1110c:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   11110:	e50b3048 	str	r3, [fp, #-72]	; 0x48
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
   11114:	e24b304c 	sub	r3, fp, #76	; 0x4c
   11118:	e893000c 	ldm	r3, {r2, r3}
   1111c:	e3520000 	cmp	r2, #0
   11120:	e2d31000 	sbcs	r1, r3, #0
   11124:	aa000007 	bge	11148 <_svfprintf_r+0x6f8>
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
   11128:	e24b304c 	sub	r3, fp, #76	; 0x4c
   1112c:	e893000c 	ldm	r3, {r2, r3}
   11130:	e2722000 	rsbs	r2, r2, #0
   11134:	e2e33000 	rsc	r3, r3, #0
   11138:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   1113c:	e50b3048 	str	r3, [fp, #-72]	; 0x48
				sign = '-';
   11140:	e3a0302d 	mov	r3, #45	; 0x2d
   11144:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
			}
			base = DEC;
   11148:	e3a03001 	mov	r3, #1
   1114c:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
			goto number;
   11150:	ea00025a 	b	11ac0 <_svfprintf_r+0x1070>
		case 'E':
		case 'f':
		case 'g':
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
   11154:	e2063008 	and	r3, r6, #8
   11158:	e3530000 	cmp	r3, #0
   1115c:	0a000008 	beq	11184 <_svfprintf_r+0x734>
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
   11160:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   11164:	e2833007 	add	r3, r3, #7
   11168:	e3c33007 	bic	r3, r3, #7
   1116c:	e2832008 	add	r2, r3, #8
   11170:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11174:	e893000c 	ldm	r3, {r2, r3}
   11178:	e50b2094 	str	r2, [fp, #-148]	; 0x94
   1117c:	e50b3090 	str	r3, [fp, #-144]	; 0x90
   11180:	ea000007 	b	111a4 <_svfprintf_r+0x754>
			} else {
				_fpvalue = GET_ARG (N, ap, double);
   11184:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   11188:	e2833007 	add	r3, r3, #7
   1118c:	e3c33007 	bic	r3, r3, #7
   11190:	e2832008 	add	r2, r3, #8
   11194:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11198:	e893000c 	ldm	r3, {r2, r3}
   1119c:	e50b2094 	str	r2, [fp, #-148]	; 0x94
   111a0:	e50b3090 	str	r3, [fp, #-144]	; 0x90

			   If the output is infinite or NaN, leading
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
   111a4:	e24b3094 	sub	r3, fp, #148	; 0x94
   111a8:	e893000c 	ldm	r3, {r2, r3}
   111ac:	e1a00002 	mov	r0, r2
   111b0:	e1a01003 	mov	r1, r3
   111b4:	eb0031c9 	bl	1d8e0 <__fpclassifyd>
   111b8:	e1a03000 	mov	r3, r0
   111bc:	e3530001 	cmp	r3, #1
   111c0:	1a000014 	bne	11218 <_svfprintf_r+0x7c8>
				if (_fpvalue < 0)
   111c4:	e24b3094 	sub	r3, fp, #148	; 0x94
   111c8:	e893000c 	ldm	r3, {r2, r3}
   111cc:	e1a00002 	mov	r0, r2
   111d0:	e1a01003 	mov	r1, r3
   111d4:	e3a02000 	mov	r2, #0
   111d8:	e3a03000 	mov	r3, #0
   111dc:	eb004689 	bl	22c08 <__aeabi_dcmplt>
   111e0:	e1a03000 	mov	r3, r0
   111e4:	e3530000 	cmp	r3, #0
   111e8:	0a000001 	beq	111f4 <_svfprintf_r+0x7a4>
					sign = '-';
   111ec:	e3a0302d 	mov	r3, #45	; 0x2d
   111f0:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
   111f4:	e3580047 	cmp	r8, #71	; 0x47
   111f8:	ca000001 	bgt	11204 <_svfprintf_r+0x7b4>
					cp = "INF";
   111fc:	e59f7fa8 	ldr	r7, [pc, #4008]	; 121ac <_svfprintf_r+0x175c>
   11200:	ea000000 	b	11208 <_svfprintf_r+0x7b8>
				else
					cp = "inf";
   11204:	e59f7fa4 	ldr	r7, [pc, #4004]	; 121b0 <_svfprintf_r+0x1760>
				size = 3;
   11208:	e3a03003 	mov	r3, #3
   1120c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
				flags &= ~ZEROPAD;
   11210:	e3c66080 	bic	r6, r6, #128	; 0x80
				break;
   11214:	ea0002ec 	b	11dcc <_svfprintf_r+0x137c>
			}
			if (isnan (_fpvalue)) {
   11218:	e24b3094 	sub	r3, fp, #148	; 0x94
   1121c:	e893000c 	ldm	r3, {r2, r3}
   11220:	e1a00002 	mov	r0, r2
   11224:	e1a01003 	mov	r1, r3
   11228:	eb0031ac 	bl	1d8e0 <__fpclassifyd>
   1122c:	e1a03000 	mov	r3, r0
   11230:	e3530000 	cmp	r3, #0
   11234:	1a000008 	bne	1125c <_svfprintf_r+0x80c>
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
   11238:	e3580047 	cmp	r8, #71	; 0x47
   1123c:	ca000001 	bgt	11248 <_svfprintf_r+0x7f8>
					cp = "NAN";
   11240:	e59f7f6c 	ldr	r7, [pc, #3948]	; 121b4 <_svfprintf_r+0x1764>
   11244:	ea000000 	b	1124c <_svfprintf_r+0x7fc>
				else
					cp = "nan";
   11248:	e59f7f68 	ldr	r7, [pc, #3944]	; 121b8 <_svfprintf_r+0x1768>
				size = 3;
   1124c:	e3a03003 	mov	r3, #3
   11250:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
				flags &= ~ZEROPAD;
   11254:	e3c66080 	bic	r6, r6, #128	; 0x80
				break;
   11258:	ea0002db 	b	11dcc <_svfprintf_r+0x137c>
				break;
			}
# endif /* !_NO_LONGDBL */

# ifdef _WANT_IO_C99_FORMATS
			if (ch == 'a' || ch == 'A') {
   1125c:	e3580061 	cmp	r8, #97	; 0x61
   11260:	0a000001 	beq	1126c <_svfprintf_r+0x81c>
   11264:	e3580041 	cmp	r8, #65	; 0x41
   11268:	1a000020 	bne	112f0 <_svfprintf_r+0x8a0>
				ox[0] = '0';
   1126c:	e3a03030 	mov	r3, #48	; 0x30
   11270:	e54b3158 	strb	r3, [fp, #-344]	; 0x158
				ox[1] = ch == 'a' ? 'x' : 'X';
   11274:	e3580061 	cmp	r8, #97	; 0x61
   11278:	1a000001 	bne	11284 <_svfprintf_r+0x834>
   1127c:	e3a03078 	mov	r3, #120	; 0x78
   11280:	ea000000 	b	11288 <_svfprintf_r+0x838>
   11284:	e3a03058 	mov	r3, #88	; 0x58
   11288:	e54b3157 	strb	r3, [fp, #-343]	; 0x157
				flags |= HEXPREFIX;
   1128c:	e3866002 	orr	r6, r6, #2
				if (prec >= BUF)
   11290:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   11294:	e3530063 	cmp	r3, #99	; 0x63
   11298:	da000012 	ble	112e8 <_svfprintf_r+0x898>
				  {
				    if ((malloc_buf =
					 (char *)_malloc_r (data, prec + 1))
   1129c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   112a0:	e2833001 	add	r3, r3, #1
				ox[0] = '0';
				ox[1] = ch == 'a' ? 'x' : 'X';
				flags |= HEXPREFIX;
				if (prec >= BUF)
				  {
				    if ((malloc_buf =
   112a4:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   112a8:	e1a01003 	mov	r1, r3
   112ac:	ebfff760 	bl	f034 <_malloc_r>
   112b0:	e50b0064 	str	r0, [fp, #-100]	; 0x64
   112b4:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   112b8:	e3530000 	cmp	r3, #0
   112bc:	1a000007 	bne	112e0 <_svfprintf_r+0x890>
					 (char *)_malloc_r (data, prec + 1))
					== NULL)
				      {
					fp->_flags |= __SERR;
   112c0:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   112c4:	e1d330bc 	ldrh	r3, [r3, #12]
   112c8:	e3833040 	orr	r3, r3, #64	; 0x40
   112cc:	e1a03803 	lsl	r3, r3, #16
   112d0:	e1a02823 	lsr	r2, r3, #16
   112d4:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   112d8:	e1c320bc 	strh	r2, [r3, #12]
					goto error;
   112dc:	ea0007be 	b	131dc <_svfprintf_r+0x278c>
				      }
				    cp = malloc_buf;
   112e0:	e51b7064 	ldr	r7, [fp, #-100]	; 0x64
# ifdef _WANT_IO_C99_FORMATS
			if (ch == 'a' || ch == 'A') {
				ox[0] = '0';
				ox[1] = ch == 'a' ? 'x' : 'X';
				flags |= HEXPREFIX;
				if (prec >= BUF)
   112e4:	ea000010 	b	1132c <_svfprintf_r+0x8dc>
					goto error;
				      }
				    cp = malloc_buf;
				  }
				else
				  cp = buf;
   112e8:	e24b7f55 	sub	r7, fp, #340	; 0x154
# ifdef _WANT_IO_C99_FORMATS
			if (ch == 'a' || ch == 'A') {
				ox[0] = '0';
				ox[1] = ch == 'a' ? 'x' : 'X';
				flags |= HEXPREFIX;
				if (prec >= BUF)
   112ec:	ea00000e 	b	1132c <_svfprintf_r+0x8dc>
				  }
				else
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
   112f0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   112f4:	e3730001 	cmn	r3, #1
   112f8:	1a000002 	bne	11308 <_svfprintf_r+0x8b8>
				prec = DEFPREC;
   112fc:	e3a03006 	mov	r3, #6
   11300:	e50b3028 	str	r3, [fp, #-40]	; 0x28
   11304:	ea000008 	b	1132c <_svfprintf_r+0x8dc>
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
   11308:	e3580067 	cmp	r8, #103	; 0x67
   1130c:	0a000001 	beq	11318 <_svfprintf_r+0x8c8>
   11310:	e3580047 	cmp	r8, #71	; 0x47
   11314:	1a000004 	bne	1132c <_svfprintf_r+0x8dc>
   11318:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1131c:	e3530000 	cmp	r3, #0
   11320:	1a000001 	bne	1132c <_svfprintf_r+0x8dc>
				prec = 1;
   11324:	e3a03001 	mov	r3, #1
   11328:	e50b3028 	str	r3, [fp, #-40]	; 0x28
			}

			flags |= FPT;
   1132c:	e3866c01 	orr	r6, r6, #256	; 0x100

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
   11330:	e24b3094 	sub	r3, fp, #148	; 0x94
   11334:	e893000c 	ldm	r3, {r2, r3}
   11338:	e51b1028 	ldr	r1, [fp, #-40]	; 0x28
   1133c:	e58d1000 	str	r1, [sp]
   11340:	e58d6004 	str	r6, [sp, #4]
   11344:	e24b1086 	sub	r1, fp, #134	; 0x86
   11348:	e58d1008 	str	r1, [sp, #8]
   1134c:	e24b1098 	sub	r1, fp, #152	; 0x98
   11350:	e58d100c 	str	r1, [sp, #12]
   11354:	e58d8010 	str	r8, [sp, #16]
   11358:	e24b10a4 	sub	r1, fp, #164	; 0xa4
   1135c:	e58d1014 	str	r1, [sp, #20]
   11360:	e58d7018 	str	r7, [sp, #24]
   11364:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   11368:	eb0007b0 	bl	13230 <cvt>
   1136c:	e1a07000 	mov	r7, r0
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
   11370:	e3580067 	cmp	r8, #103	; 0x67
   11374:	0a000001 	beq	11380 <_svfprintf_r+0x930>
   11378:	e3580047 	cmp	r8, #71	; 0x47
   1137c:	1a00000a 	bne	113ac <_svfprintf_r+0x95c>
				if (expt <= -4 || expt > prec)
   11380:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   11384:	e3730003 	cmn	r3, #3
   11388:	ba000003 	blt	1139c <_svfprintf_r+0x94c>
   1138c:	e51b2098 	ldr	r2, [fp, #-152]	; 0x98
   11390:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   11394:	e1520003 	cmp	r2, r3
   11398:	da000001 	ble	113a4 <_svfprintf_r+0x954>
					ch -= 2; /* 'e' or 'E' */
   1139c:	e2488002 	sub	r8, r8, #2

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
				if (expt <= -4 || expt > prec)
   113a0:	ea000004 	b	113b8 <_svfprintf_r+0x968>
					ch -= 2; /* 'e' or 'E' */
				else
					ch = 'g';
   113a4:	e3a08067 	mov	r8, #103	; 0x67

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
				if (expt <= -4 || expt > prec)
   113a8:	ea000002 	b	113b8 <_svfprintf_r+0x968>
					ch -= 2; /* 'e' or 'E' */
				else
					ch = 'g';
			}
# ifdef _WANT_IO_C99_FORMATS
			else if (ch == 'F')
   113ac:	e3580046 	cmp	r8, #70	; 0x46
   113b0:	1a000000 	bne	113b8 <_svfprintf_r+0x968>
				ch = 'f';
   113b4:	e3a08066 	mov	r8, #102	; 0x66
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
   113b8:	e3580065 	cmp	r8, #101	; 0x65
   113bc:	ca000018 	bgt	11424 <_svfprintf_r+0x9d4>
				--expt;
   113c0:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   113c4:	e2433001 	sub	r3, r3, #1
   113c8:	e50b3098 	str	r3, [fp, #-152]	; 0x98
				expsize = exponent (expstr, expt, ch);
   113cc:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   113d0:	e24b20a0 	sub	r2, fp, #160	; 0xa0
   113d4:	e1a00002 	mov	r0, r2
   113d8:	e1a01003 	mov	r1, r3
   113dc:	e1a02008 	mov	r2, r8
   113e0:	eb0008b8 	bl	136c8 <exponent>
   113e4:	e50b0038 	str	r0, [fp, #-56]	; 0x38
				size = expsize + ndig;
   113e8:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   113ec:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   113f0:	e0823003 	add	r3, r2, r3
   113f4:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
				if (ndig > 1 || flags & ALT)
   113f8:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   113fc:	e3530001 	cmp	r3, #1
   11400:	ca000002 	bgt	11410 <_svfprintf_r+0x9c0>
   11404:	e2063001 	and	r3, r6, #1
   11408:	e3530000 	cmp	r3, #0
   1140c:	0a000002 	beq	1141c <_svfprintf_r+0x9cc>
					++size;
   11410:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   11414:	e2833001 	add	r3, r3, #1
   11418:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
# ifdef _WANT_IO_C99_FORMATS
				flags &= ~GROUPING;
   1141c:	e3c66b01 	bic	r6, r6, #1024	; 0x400
   11420:	ea00006c 	b	115d8 <_svfprintf_r+0xb88>
# endif
			} else {
				if (ch == 'f') {		/* f fmt */
   11424:	e3580066 	cmp	r8, #102	; 0x66
   11428:	1a00001c 	bne	114a0 <_svfprintf_r+0xa50>
					if (expt > 0) {
   1142c:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   11430:	e3530000 	cmp	r3, #0
   11434:	da00000d 	ble	11470 <_svfprintf_r+0xa20>
						size = expt;
   11438:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1143c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
						if (prec || flags & ALT)
   11440:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   11444:	e3530000 	cmp	r3, #0
   11448:	1a000002 	bne	11458 <_svfprintf_r+0xa08>
   1144c:	e2063001 	and	r3, r6, #1
   11450:	e3530000 	cmp	r3, #0
   11454:	0a000028 	beq	114fc <_svfprintf_r+0xaac>
							size += prec + 1;
   11458:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1145c:	e2833001 	add	r3, r3, #1
   11460:	e51b205c 	ldr	r2, [fp, #-92]	; 0x5c
   11464:	e0823003 	add	r3, r2, r3
   11468:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   1146c:	ea000022 	b	114fc <_svfprintf_r+0xaac>
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
   11470:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   11474:	e3530000 	cmp	r3, #0
   11478:	1a000002 	bne	11488 <_svfprintf_r+0xa38>
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
   1147c:	e2063001 	and	r3, r6, #1
   11480:	e3530000 	cmp	r3, #0
   11484:	0a000002 	beq	11494 <_svfprintf_r+0xa44>
							  ? prec + 2
							  : 1;
   11488:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1148c:	e2833002 	add	r3, r3, #2
   11490:	ea000000 	b	11498 <_svfprintf_r+0xa48>
   11494:	e3a03001 	mov	r3, #1
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
   11498:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   1149c:	ea000016 	b	114fc <_svfprintf_r+0xaac>
							  ? prec + 2
							  : 1;
				} else if (expt >= ndig) { /* fixed g fmt */
   114a0:	e51b2098 	ldr	r2, [fp, #-152]	; 0x98
   114a4:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   114a8:	e1520003 	cmp	r2, r3
   114ac:	ba000008 	blt	114d4 <_svfprintf_r+0xa84>
					size = expt;
   114b0:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   114b4:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
					if (flags & ALT)
   114b8:	e2063001 	and	r3, r6, #1
   114bc:	e3530000 	cmp	r3, #0
   114c0:	0a00000d 	beq	114fc <_svfprintf_r+0xaac>
						++size;
   114c4:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   114c8:	e2833001 	add	r3, r3, #1
   114cc:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   114d0:	ea000009 	b	114fc <_svfprintf_r+0xaac>
				} else
					size = ndig + (expt > 0 ?
   114d4:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
						1 : 2 - expt);
   114d8:	e3530000 	cmp	r3, #0
   114dc:	ca000002 	bgt	114ec <_svfprintf_r+0xa9c>
   114e0:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   114e4:	e2633002 	rsb	r3, r3, #2
   114e8:	ea000000 	b	114f0 <_svfprintf_r+0xaa0>
   114ec:	e3a03001 	mov	r3, #1
				} else if (expt >= ndig) { /* fixed g fmt */
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
   114f0:	e51b20a4 	ldr	r2, [fp, #-164]	; 0xa4
   114f4:	e0833002 	add	r3, r3, r2
   114f8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
						1 : 2 - expt);
# ifdef _WANT_IO_C99_FORMATS
				if ((flags & GROUPING) && expt > 0) {
   114fc:	e2063b01 	and	r3, r6, #1024	; 0x400
   11500:	e3530000 	cmp	r3, #0
   11504:	0a000031 	beq	115d0 <_svfprintf_r+0xb80>
   11508:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1150c:	e3530000 	cmp	r3, #0
   11510:	da00002e 	ble	115d0 <_svfprintf_r+0xb80>
					/* space for thousands' grouping */
					nseps = nrepeats = 0;
   11514:	e3a03000 	mov	r3, #0
   11518:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   1151c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   11520:	e50b3040 	str	r3, [fp, #-64]	; 0x40
					lead = expt;
   11524:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   11528:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
					while (*grouping != CHAR_MAX) {
   1152c:	ea00001a 	b	1159c <_svfprintf_r+0xb4c>
						if (lead <= *grouping)
   11530:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   11534:	e5d33000 	ldrb	r3, [r3]
   11538:	e1a02003 	mov	r2, r3
   1153c:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   11540:	e1520003 	cmp	r2, r3
   11544:	ba000000 	blt	1154c <_svfprintf_r+0xafc>
							break;
   11548:	ea000017 	b	115ac <_svfprintf_r+0xb5c>
						lead -= *grouping;
   1154c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   11550:	e5d33000 	ldrb	r3, [r3]
   11554:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   11558:	e0633002 	rsb	r3, r3, r2
   1155c:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
						if (grouping[1]) {
   11560:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   11564:	e2833001 	add	r3, r3, #1
   11568:	e5d33000 	ldrb	r3, [r3]
   1156c:	e3530000 	cmp	r3, #0
   11570:	0a000006 	beq	11590 <_svfprintf_r+0xb40>
							nseps++;
   11574:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   11578:	e2833001 	add	r3, r3, #1
   1157c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
							grouping++;
   11580:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   11584:	e2833001 	add	r3, r3, #1
   11588:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   1158c:	ea000002 	b	1159c <_svfprintf_r+0xb4c>
						} else
							nrepeats++;
   11590:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   11594:	e2833001 	add	r3, r3, #1
   11598:	e50b3044 	str	r3, [fp, #-68]	; 0x44
# ifdef _WANT_IO_C99_FORMATS
				if ((flags & GROUPING) && expt > 0) {
					/* space for thousands' grouping */
					nseps = nrepeats = 0;
					lead = expt;
					while (*grouping != CHAR_MAX) {
   1159c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   115a0:	e5d33000 	ldrb	r3, [r3]
   115a4:	e35300ff 	cmp	r3, #255	; 0xff
   115a8:	1affffe0 	bne	11530 <_svfprintf_r+0xae0>
							nseps++;
							grouping++;
						} else
							nrepeats++;
					}
					size += (nseps + nrepeats) * thsnd_len;
   115ac:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   115b0:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   115b4:	e0823003 	add	r3, r2, r3
   115b8:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   115bc:	e0020293 	mul	r2, r3, r2
   115c0:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   115c4:	e0823003 	add	r3, r2, r3
   115c8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   115cc:	ea000001 	b	115d8 <_svfprintf_r+0xb88>
				} else
# endif
					lead = expt;
   115d0:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   115d4:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
			}

			if (softsign)
   115d8:	e55b3086 	ldrb	r3, [fp, #-134]	; 0x86
   115dc:	e3530000 	cmp	r3, #0
   115e0:	0a000002 	beq	115f0 <_svfprintf_r+0xba0>
				sign = '-';
   115e4:	e3a0302d 	mov	r3, #45	; 0x2d
   115e8:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
			break;
   115ec:	ea0001f6 	b	11dcc <_svfprintf_r+0x137c>
   115f0:	ea0001f5 	b	11dcc <_svfprintf_r+0x137c>
			flags &= ~LONGINT;
			goto string;
#endif
		case 'n':
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
   115f4:	e2063020 	and	r3, r6, #32
   115f8:	e3530000 	cmp	r3, #0
   115fc:	0a000008 	beq	11624 <_svfprintf_r+0xbd4>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
   11600:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   11604:	e2832004 	add	r2, r3, #4
   11608:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1160c:	e5931000 	ldr	r1, [r3]
   11610:	e51b3020 	ldr	r3, [fp, #-32]
   11614:	e1a02003 	mov	r2, r3
   11618:	e1a03fc2 	asr	r3, r2, #31
   1161c:	e881000c 	stm	r1, {r2, r3}
   11620:	ea000027 	b	116c4 <_svfprintf_r+0xc74>
			else
#endif
			if (flags & LONGINT)
   11624:	e2063010 	and	r3, r6, #16
   11628:	e3530000 	cmp	r3, #0
   1162c:	0a000006 	beq	1164c <_svfprintf_r+0xbfc>
				*GET_ARG (N, ap, long_ptr_t) = ret;
   11630:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   11634:	e2832004 	add	r2, r3, #4
   11638:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1163c:	e5933000 	ldr	r3, [r3]
   11640:	e51b2020 	ldr	r2, [fp, #-32]
   11644:	e5832000 	str	r2, [r3]
   11648:	ea00001d 	b	116c4 <_svfprintf_r+0xc74>
			else if (flags & SHORTINT)
   1164c:	e2063040 	and	r3, r6, #64	; 0x40
   11650:	e3530000 	cmp	r3, #0
   11654:	0a000008 	beq	1167c <_svfprintf_r+0xc2c>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   11658:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1165c:	e2832004 	add	r2, r3, #4
   11660:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11664:	e5933000 	ldr	r3, [r3]
   11668:	e51b2020 	ldr	r2, [fp, #-32]
   1166c:	e1a02802 	lsl	r2, r2, #16
   11670:	e1a02822 	lsr	r2, r2, #16
   11674:	e1c320b0 	strh	r2, [r3]
   11678:	ea000011 	b	116c4 <_svfprintf_r+0xc74>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
   1167c:	e2063c02 	and	r3, r6, #512	; 0x200
   11680:	e3530000 	cmp	r3, #0
   11684:	0a000007 	beq	116a8 <_svfprintf_r+0xc58>
				*GET_ARG (N, ap, char_ptr_t) = ret;
   11688:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1168c:	e2832004 	add	r2, r3, #4
   11690:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11694:	e5933000 	ldr	r3, [r3]
   11698:	e51b2020 	ldr	r2, [fp, #-32]
   1169c:	e20220ff 	and	r2, r2, #255	; 0xff
   116a0:	e5c32000 	strb	r2, [r3]
   116a4:	ea000006 	b	116c4 <_svfprintf_r+0xc74>
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
   116a8:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   116ac:	e2832004 	add	r2, r3, #4
   116b0:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   116b4:	e5933000 	ldr	r3, [r3]
   116b8:	e51b2020 	ldr	r2, [fp, #-32]
   116bc:	e5832000 	str	r2, [r3]
			continue;	/* no output */
   116c0:	ea0006b5 	b	1319c <_svfprintf_r+0x274c>
   116c4:	ea0006b4 	b	1319c <_svfprintf_r+0x274c>
		case 'O': /* extension */
			flags |= LONGINT;
   116c8:	e3866010 	orr	r6, r6, #16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   116cc:	e2063020 	and	r3, r6, #32
   116d0:	e3530000 	cmp	r3, #0
   116d4:	0a000006 	beq	116f4 <_svfprintf_r+0xca4>
   116d8:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   116dc:	e2833007 	add	r3, r3, #7
   116e0:	e3c33007 	bic	r3, r3, #7
   116e4:	e2832008 	add	r2, r3, #8
   116e8:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   116ec:	e893000c 	ldm	r3, {r2, r3}
   116f0:	ea000027 	b	11794 <_svfprintf_r+0xd44>
   116f4:	e2063010 	and	r3, r6, #16
   116f8:	e3530000 	cmp	r3, #0
   116fc:	0a000006 	beq	1171c <_svfprintf_r+0xccc>
   11700:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   11704:	e2832004 	add	r2, r3, #4
   11708:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1170c:	e5933000 	ldr	r3, [r3]
   11710:	e1a02003 	mov	r2, r3
   11714:	e3a03000 	mov	r3, #0
   11718:	ea00001d 	b	11794 <_svfprintf_r+0xd44>
   1171c:	e2063040 	and	r3, r6, #64	; 0x40
   11720:	e3530000 	cmp	r3, #0
   11724:	0a000009 	beq	11750 <_svfprintf_r+0xd00>
   11728:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1172c:	e2832004 	add	r2, r3, #4
   11730:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11734:	e5933000 	ldr	r3, [r3]
   11738:	e1a03803 	lsl	r3, r3, #16
   1173c:	e1a01823 	lsr	r1, r3, #16
   11740:	e1a03001 	mov	r3, r1
   11744:	e1a02003 	mov	r2, r3
   11748:	e3a03000 	mov	r3, #0
   1174c:	ea000010 	b	11794 <_svfprintf_r+0xd44>
   11750:	e2063c02 	and	r3, r6, #512	; 0x200
   11754:	e3530000 	cmp	r3, #0
   11758:	0a000007 	beq	1177c <_svfprintf_r+0xd2c>
   1175c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   11760:	e2832004 	add	r2, r3, #4
   11764:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11768:	e5933000 	ldr	r3, [r3]
   1176c:	e20330ff 	and	r3, r3, #255	; 0xff
   11770:	e20320ff 	and	r2, r3, #255	; 0xff
   11774:	e3a03000 	mov	r3, #0
   11778:	ea000005 	b	11794 <_svfprintf_r+0xd44>
   1177c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   11780:	e2832004 	add	r2, r3, #4
   11784:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11788:	e5933000 	ldr	r3, [r3]
   1178c:	e1a02003 	mov	r2, r3
   11790:	e3a03000 	mov	r3, #0
   11794:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   11798:	e50b3048 	str	r3, [fp, #-72]	; 0x48
			base = OCT;
   1179c:	e3a03000 	mov	r3, #0
   117a0:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
   117a4:	e3c66b01 	bic	r6, r6, #1024	; 0x400
#endif
			goto nosign;
   117a8:	ea0000c2 	b	11ab8 <_svfprintf_r+0x1068>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   117ac:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   117b0:	e2832004 	add	r2, r3, #4
   117b4:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   117b8:	e5933000 	ldr	r3, [r3]
   117bc:	e1a02003 	mov	r2, r3
   117c0:	e3a03000 	mov	r3, #0
   117c4:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   117c8:	e50b3048 	str	r3, [fp, #-72]	; 0x48
			base = HEX;
   117cc:	e3a03002 	mov	r3, #2
   117d0:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
			xdigs = "0123456789abcdef";
   117d4:	e59f39e0 	ldr	r3, [pc, #2528]	; 121bc <_svfprintf_r+0x176c>
   117d8:	e50b3060 	str	r3, [fp, #-96]	; 0x60
			flags |= HEXPREFIX;
   117dc:	e3866002 	orr	r6, r6, #2
			ox[0] = '0';
   117e0:	e3a03030 	mov	r3, #48	; 0x30
   117e4:	e54b3158 	strb	r3, [fp, #-344]	; 0x158
			ox[1] = ch = 'x';
   117e8:	e3a08078 	mov	r8, #120	; 0x78
   117ec:	e3a03078 	mov	r3, #120	; 0x78
   117f0:	e54b3157 	strb	r3, [fp, #-343]	; 0x157
			goto nosign;
   117f4:	ea0000af 	b	11ab8 <_svfprintf_r+0x1068>
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   117f8:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   117fc:	e2832004 	add	r2, r3, #4
   11800:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11804:	e5937000 	ldr	r7, [r3]
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
   11808:	e3a03000 	mov	r3, #0
   1180c:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
   11810:	e3570000 	cmp	r7, #0
   11814:	1a000006 	bne	11834 <_svfprintf_r+0xde4>
				cp = "(null)";
   11818:	e59f79a0 	ldr	r7, [pc, #2464]	; 121c0 <_svfprintf_r+0x1770>
				size = ((unsigned) prec > 6U) ? 6 : prec;
   1181c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   11820:	e3530006 	cmp	r3, #6
   11824:	31a03003 	movcc	r3, r3
   11828:	23a03006 	movcs	r3, #6
   1182c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   11830:	ea00001f 	b	118b4 <_svfprintf_r+0xe64>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
   11834:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   11838:	e3530000 	cmp	r3, #0
   1183c:	ba000017 	blt	118a0 <_svfprintf_r+0xe50>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
   11840:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   11844:	e1a00007 	mov	r0, r7
   11848:	e3a01000 	mov	r1, #0
   1184c:	e1a02003 	mov	r2, r3
   11850:	eb0024df 	bl	1abd4 <memchr>
   11854:	e50b0080 	str	r0, [fp, #-128]	; 0x80

				if (p != NULL) {
   11858:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
   1185c:	e3530000 	cmp	r3, #0
   11860:	0a00000a 	beq	11890 <_svfprintf_r+0xe40>
					size = p - cp;
   11864:	e51b2080 	ldr	r2, [fp, #-128]	; 0x80
   11868:	e1a03007 	mov	r3, r7
   1186c:	e0633002 	rsb	r3, r3, r2
   11870:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
					if (size > prec)
   11874:	e51b205c 	ldr	r2, [fp, #-92]	; 0x5c
   11878:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1187c:	e1520003 	cmp	r2, r3
   11880:	da000005 	ble	1189c <_svfprintf_r+0xe4c>
						size = prec;
   11884:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   11888:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   1188c:	ea000008 	b	118b4 <_svfprintf_r+0xe64>
				} else
					size = prec;
   11890:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   11894:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   11898:	ea000005 	b	118b4 <_svfprintf_r+0xe64>
   1189c:	ea000004 	b	118b4 <_svfprintf_r+0xe64>
			} else
				size = strlen (cp);
   118a0:	e1a00007 	mov	r0, r7
   118a4:	ebfffc50 	bl	109ec <strlen>
   118a8:	e1a03000 	mov	r3, r0
   118ac:	e50b305c 	str	r3, [fp, #-92]	; 0x5c

			break;
   118b0:	ea000145 	b	11dcc <_svfprintf_r+0x137c>
   118b4:	ea000144 	b	11dcc <_svfprintf_r+0x137c>
		case 'U': /* extension */
			flags |= LONGINT;
   118b8:	e3866010 	orr	r6, r6, #16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   118bc:	e2063020 	and	r3, r6, #32
   118c0:	e3530000 	cmp	r3, #0
   118c4:	0a000006 	beq	118e4 <_svfprintf_r+0xe94>
   118c8:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   118cc:	e2833007 	add	r3, r3, #7
   118d0:	e3c33007 	bic	r3, r3, #7
   118d4:	e2832008 	add	r2, r3, #8
   118d8:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   118dc:	e893000c 	ldm	r3, {r2, r3}
   118e0:	ea000027 	b	11984 <_svfprintf_r+0xf34>
   118e4:	e2063010 	and	r3, r6, #16
   118e8:	e3530000 	cmp	r3, #0
   118ec:	0a000006 	beq	1190c <_svfprintf_r+0xebc>
   118f0:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   118f4:	e2832004 	add	r2, r3, #4
   118f8:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   118fc:	e5933000 	ldr	r3, [r3]
   11900:	e1a02003 	mov	r2, r3
   11904:	e3a03000 	mov	r3, #0
   11908:	ea00001d 	b	11984 <_svfprintf_r+0xf34>
   1190c:	e2063040 	and	r3, r6, #64	; 0x40
   11910:	e3530000 	cmp	r3, #0
   11914:	0a000009 	beq	11940 <_svfprintf_r+0xef0>
   11918:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1191c:	e2832004 	add	r2, r3, #4
   11920:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11924:	e5933000 	ldr	r3, [r3]
   11928:	e1a03803 	lsl	r3, r3, #16
   1192c:	e1a01823 	lsr	r1, r3, #16
   11930:	e1a03001 	mov	r3, r1
   11934:	e1a02003 	mov	r2, r3
   11938:	e3a03000 	mov	r3, #0
   1193c:	ea000010 	b	11984 <_svfprintf_r+0xf34>
   11940:	e2063c02 	and	r3, r6, #512	; 0x200
   11944:	e3530000 	cmp	r3, #0
   11948:	0a000007 	beq	1196c <_svfprintf_r+0xf1c>
   1194c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   11950:	e2832004 	add	r2, r3, #4
   11954:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11958:	e5933000 	ldr	r3, [r3]
   1195c:	e20330ff 	and	r3, r3, #255	; 0xff
   11960:	e20320ff 	and	r2, r3, #255	; 0xff
   11964:	e3a03000 	mov	r3, #0
   11968:	ea000005 	b	11984 <_svfprintf_r+0xf34>
   1196c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   11970:	e2832004 	add	r2, r3, #4
   11974:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11978:	e5933000 	ldr	r3, [r3]
   1197c:	e1a02003 	mov	r2, r3
   11980:	e3a03000 	mov	r3, #0
   11984:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   11988:	e50b3048 	str	r3, [fp, #-72]	; 0x48
			base = DEC;
   1198c:	e3a03001 	mov	r3, #1
   11990:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
			goto nosign;
   11994:	ea000047 	b	11ab8 <_svfprintf_r+0x1068>
		case 'X':
			xdigs = "0123456789ABCDEF";
   11998:	e59f3824 	ldr	r3, [pc, #2084]	; 121c4 <_svfprintf_r+0x1774>
   1199c:	e50b3060 	str	r3, [fp, #-96]	; 0x60
			goto hex;
   119a0:	ea000001 	b	119ac <_svfprintf_r+0xf5c>
		case 'x':
			xdigs = "0123456789abcdef";
   119a4:	e59f3810 	ldr	r3, [pc, #2064]	; 121bc <_svfprintf_r+0x176c>
   119a8:	e50b3060 	str	r3, [fp, #-96]	; 0x60
hex:			_uquad = UARG ();
   119ac:	e2063020 	and	r3, r6, #32
   119b0:	e3530000 	cmp	r3, #0
   119b4:	0a000006 	beq	119d4 <_svfprintf_r+0xf84>
   119b8:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   119bc:	e2833007 	add	r3, r3, #7
   119c0:	e3c33007 	bic	r3, r3, #7
   119c4:	e2832008 	add	r2, r3, #8
   119c8:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   119cc:	e893000c 	ldm	r3, {r2, r3}
   119d0:	ea000027 	b	11a74 <_svfprintf_r+0x1024>
   119d4:	e2063010 	and	r3, r6, #16
   119d8:	e3530000 	cmp	r3, #0
   119dc:	0a000006 	beq	119fc <_svfprintf_r+0xfac>
   119e0:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   119e4:	e2832004 	add	r2, r3, #4
   119e8:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   119ec:	e5933000 	ldr	r3, [r3]
   119f0:	e1a02003 	mov	r2, r3
   119f4:	e3a03000 	mov	r3, #0
   119f8:	ea00001d 	b	11a74 <_svfprintf_r+0x1024>
   119fc:	e2063040 	and	r3, r6, #64	; 0x40
   11a00:	e3530000 	cmp	r3, #0
   11a04:	0a000009 	beq	11a30 <_svfprintf_r+0xfe0>
   11a08:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   11a0c:	e2832004 	add	r2, r3, #4
   11a10:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11a14:	e5933000 	ldr	r3, [r3]
   11a18:	e1a03803 	lsl	r3, r3, #16
   11a1c:	e1a01823 	lsr	r1, r3, #16
   11a20:	e1a03001 	mov	r3, r1
   11a24:	e1a02003 	mov	r2, r3
   11a28:	e3a03000 	mov	r3, #0
   11a2c:	ea000010 	b	11a74 <_svfprintf_r+0x1024>
   11a30:	e2063c02 	and	r3, r6, #512	; 0x200
   11a34:	e3530000 	cmp	r3, #0
   11a38:	0a000007 	beq	11a5c <_svfprintf_r+0x100c>
   11a3c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   11a40:	e2832004 	add	r2, r3, #4
   11a44:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11a48:	e5933000 	ldr	r3, [r3]
   11a4c:	e20330ff 	and	r3, r3, #255	; 0xff
   11a50:	e20320ff 	and	r2, r3, #255	; 0xff
   11a54:	e3a03000 	mov	r3, #0
   11a58:	ea000005 	b	11a74 <_svfprintf_r+0x1024>
   11a5c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   11a60:	e2832004 	add	r2, r3, #4
   11a64:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   11a68:	e5933000 	ldr	r3, [r3]
   11a6c:	e1a02003 	mov	r2, r3
   11a70:	e3a03000 	mov	r3, #0
   11a74:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   11a78:	e50b3048 	str	r3, [fp, #-72]	; 0x48
			base = HEX;
   11a7c:	e3a03002 	mov	r3, #2
   11a80:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
   11a84:	e2063001 	and	r3, r6, #1
   11a88:	e3530000 	cmp	r3, #0
   11a8c:	0a000008 	beq	11ab4 <_svfprintf_r+0x1064>
   11a90:	e24b304c 	sub	r3, fp, #76	; 0x4c
   11a94:	e893000c 	ldm	r3, {r2, r3}
   11a98:	e1921003 	orrs	r1, r2, r3
   11a9c:	0a000004 	beq	11ab4 <_svfprintf_r+0x1064>
				ox[0] = '0';
   11aa0:	e3a03030 	mov	r3, #48	; 0x30
   11aa4:	e54b3158 	strb	r3, [fp, #-344]	; 0x158
				ox[1] = ch;
   11aa8:	e20830ff 	and	r3, r8, #255	; 0xff
   11aac:	e54b3157 	strb	r3, [fp, #-343]	; 0x157
				flags |= HEXPREFIX;
   11ab0:	e3866002 	orr	r6, r6, #2
			}

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
   11ab4:	e3c66b01 	bic	r6, r6, #1024	; 0x400
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   11ab8:	e3a03000 	mov	r3, #0
   11abc:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   11ac0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   11ac4:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   11ac8:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   11acc:	e3530000 	cmp	r3, #0
   11ad0:	ba000000 	blt	11ad8 <_svfprintf_r+0x1088>
				flags &= ~ZEROPAD;
   11ad4:	e3c66080 	bic	r6, r6, #128	; 0x80
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   11ad8:	e24b7f55 	sub	r7, fp, #340	; 0x154
   11adc:	e2877064 	add	r7, r7, #100	; 0x64
			if (_uquad != 0 || prec != 0) {
   11ae0:	e24b304c 	sub	r3, fp, #76	; 0x4c
   11ae4:	e893000c 	ldm	r3, {r2, r3}
   11ae8:	e1921003 	orrs	r1, r2, r3
   11aec:	1a000002 	bne	11afc <_svfprintf_r+0x10ac>
   11af0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   11af4:	e3530000 	cmp	r3, #0
   11af8:	0a000099 	beq	11d64 <_svfprintf_r+0x1314>
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   11afc:	e55b304d 	ldrb	r3, [fp, #-77]	; 0x4d
   11b00:	e3530001 	cmp	r3, #1
   11b04:	0a000026 	beq	11ba4 <_svfprintf_r+0x1154>
   11b08:	e3530002 	cmp	r3, #2
   11b0c:	0a000073 	beq	11ce0 <_svfprintf_r+0x1290>
   11b10:	e3530000 	cmp	r3, #0
   11b14:	1a00008a 	bne	11d44 <_svfprintf_r+0x12f4>
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   11b18:	e2477001 	sub	r7, r7, #1
   11b1c:	e55b304c 	ldrb	r3, [fp, #-76]	; 0x4c
   11b20:	e2033007 	and	r3, r3, #7
   11b24:	e20330ff 	and	r3, r3, #255	; 0xff
   11b28:	e2833030 	add	r3, r3, #48	; 0x30
   11b2c:	e20330ff 	and	r3, r3, #255	; 0xff
   11b30:	e5c73000 	strb	r3, [r7]
						_uquad >>= 3;
   11b34:	e24b304c 	sub	r3, fp, #76	; 0x4c
   11b38:	e893000c 	ldm	r3, {r2, r3}
   11b3c:	e1a011a2 	lsr	r1, r2, #3
   11b40:	e50b1174 	str	r1, [fp, #-372]	; 0x174
   11b44:	e51b1174 	ldr	r1, [fp, #-372]	; 0x174
   11b48:	e1811e83 	orr	r1, r1, r3, lsl #29
   11b4c:	e50b1174 	str	r1, [fp, #-372]	; 0x174
   11b50:	e1a011a3 	lsr	r1, r3, #3
   11b54:	e50b1170 	str	r1, [fp, #-368]	; 0x170
   11b58:	e24b3f5d 	sub	r3, fp, #372	; 0x174
   11b5c:	e893000c 	ldm	r3, {r2, r3}
   11b60:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   11b64:	e50b3048 	str	r3, [fp, #-72]	; 0x48
					} while (_uquad);
   11b68:	e24b304c 	sub	r3, fp, #76	; 0x4c
   11b6c:	e893000c 	ldm	r3, {r2, r3}
   11b70:	e1921003 	orrs	r1, r2, r3
   11b74:	1affffe7 	bne	11b18 <_svfprintf_r+0x10c8>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
   11b78:	e2063001 	and	r3, r6, #1
   11b7c:	e3530000 	cmp	r3, #0
   11b80:	0a000006 	beq	11ba0 <_svfprintf_r+0x1150>
   11b84:	e5d73000 	ldrb	r3, [r7]
   11b88:	e3530030 	cmp	r3, #48	; 0x30
   11b8c:	0a000003 	beq	11ba0 <_svfprintf_r+0x1150>
						*--cp = '0';
   11b90:	e2477001 	sub	r7, r7, #1
   11b94:	e3a03030 	mov	r3, #48	; 0x30
   11b98:	e5c73000 	strb	r3, [r7]
					break;
   11b9c:	ea00006f 	b	11d60 <_svfprintf_r+0x1310>
   11ba0:	ea00006e 	b	11d60 <_svfprintf_r+0x1310>

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   11ba4:	e24b304c 	sub	r3, fp, #76	; 0x4c
   11ba8:	e893000c 	ldm	r3, {r2, r3}
   11bac:	e3530000 	cmp	r3, #0
   11bb0:	03520009 	cmpeq	r2, #9
   11bb4:	8a000005 	bhi	11bd0 <_svfprintf_r+0x1180>
						*--cp = to_char(_uquad);
   11bb8:	e2477001 	sub	r7, r7, #1
   11bbc:	e55b304c 	ldrb	r3, [fp, #-76]	; 0x4c
   11bc0:	e2833030 	add	r3, r3, #48	; 0x30
   11bc4:	e20330ff 	and	r3, r3, #255	; 0xff
   11bc8:	e5c73000 	strb	r3, [r7]
						break;
   11bcc:	ea000063 	b	11d60 <_svfprintf_r+0x1310>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
   11bd0:	e3a03000 	mov	r3, #0
   11bd4:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   11bd8:	e2477001 	sub	r7, r7, #1
   11bdc:	e24b304c 	sub	r3, fp, #76	; 0x4c
   11be0:	e893000c 	ldm	r3, {r2, r3}
   11be4:	e1a00002 	mov	r0, r2
   11be8:	e1a01003 	mov	r1, r3
   11bec:	e3a0200a 	mov	r2, #10
   11bf0:	e3a03000 	mov	r3, #0
   11bf4:	ebfff064 	bl	dd8c <__aeabi_uldivmod>
   11bf8:	e20230ff 	and	r3, r2, #255	; 0xff
   11bfc:	e2833030 	add	r3, r3, #48	; 0x30
   11c00:	e20330ff 	and	r3, r3, #255	; 0xff
   11c04:	e5c73000 	strb	r3, [r7]
#ifdef _WANT_IO_C99_FORMATS
					  ndig++;
   11c08:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   11c0c:	e2833001 	add	r3, r3, #1
   11c10:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
					  /* If (*grouping == CHAR_MAX) then no
					     more grouping */
					  if ((flags & GROUPING)
   11c14:	e2063b01 	and	r3, r6, #1024	; 0x400
   11c18:	e3530000 	cmp	r3, #0
   11c1c:	0a00001f 	beq	11ca0 <_svfprintf_r+0x1250>
					      && ndig == *grouping
   11c20:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   11c24:	e5d33000 	ldrb	r3, [r3]
   11c28:	e1a02003 	mov	r2, r3
   11c2c:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   11c30:	e1520003 	cmp	r2, r3
   11c34:	1a000019 	bne	11ca0 <_svfprintf_r+0x1250>
					      && *grouping != CHAR_MAX
   11c38:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   11c3c:	e5d33000 	ldrb	r3, [r3]
   11c40:	e35300ff 	cmp	r3, #255	; 0xff
   11c44:	0a000015 	beq	11ca0 <_svfprintf_r+0x1250>
					      && _uquad > 9) {
   11c48:	e24b304c 	sub	r3, fp, #76	; 0x4c
   11c4c:	e893000c 	ldm	r3, {r2, r3}
   11c50:	e3530000 	cmp	r3, #0
   11c54:	03520009 	cmpeq	r2, #9
   11c58:	9a000010 	bls	11ca0 <_svfprintf_r+0x1250>
					    cp -= thsnd_len;
   11c5c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   11c60:	e2633000 	rsb	r3, r3, #0
   11c64:	e0877003 	add	r7, r7, r3
					    strncpy (cp, thousands_sep,
   11c68:	e1a00007 	mov	r0, r7
   11c6c:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
   11c70:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   11c74:	eb0030ec 	bl	1e02c <strncpy>
						     thsnd_len);
					    ndig = 0;
   11c78:	e3a03000 	mov	r3, #0
   11c7c:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
					    /* If (grouping[1] == '\0') then we
					       have to use *grouping character
					       (last grouping rule) for all
					       next cases. */
					    if (grouping[1] != '\0')
   11c80:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   11c84:	e2833001 	add	r3, r3, #1
   11c88:	e5d33000 	ldrb	r3, [r3]
   11c8c:	e3530000 	cmp	r3, #0
   11c90:	0a000002 	beq	11ca0 <_svfprintf_r+0x1250>
					      grouping++;
   11c94:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   11c98:	e2833001 	add	r3, r3, #1
   11c9c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
					  }
#endif
					  _uquad /= 10;
   11ca0:	e24b304c 	sub	r3, fp, #76	; 0x4c
   11ca4:	e893000c 	ldm	r3, {r2, r3}
   11ca8:	e1a00002 	mov	r0, r2
   11cac:	e1a01003 	mov	r1, r3
   11cb0:	e3a0200a 	mov	r2, #10
   11cb4:	e3a03000 	mov	r3, #0
   11cb8:	ebfff033 	bl	dd8c <__aeabi_uldivmod>
   11cbc:	e1a02000 	mov	r2, r0
   11cc0:	e1a03001 	mov	r3, r1
   11cc4:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   11cc8:	e50b3048 	str	r3, [fp, #-72]	; 0x48
					} while (_uquad != 0);
   11ccc:	e24b304c 	sub	r3, fp, #76	; 0x4c
   11cd0:	e893000c 	ldm	r3, {r2, r3}
   11cd4:	e1921003 	orrs	r1, r2, r3
   11cd8:	1affffbe 	bne	11bd8 <_svfprintf_r+0x1188>
					break;
   11cdc:	ea00001f 	b	11d60 <_svfprintf_r+0x1310>

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   11ce0:	e2477001 	sub	r7, r7, #1
   11ce4:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   11ce8:	e203300f 	and	r3, r3, #15
   11cec:	e51b2060 	ldr	r2, [fp, #-96]	; 0x60
   11cf0:	e0823003 	add	r3, r2, r3
   11cf4:	e5d33000 	ldrb	r3, [r3]
   11cf8:	e5c73000 	strb	r3, [r7]
						_uquad >>= 4;
   11cfc:	e24b304c 	sub	r3, fp, #76	; 0x4c
   11d00:	e893000c 	ldm	r3, {r2, r3}
   11d04:	e1a01222 	lsr	r1, r2, #4
   11d08:	e50b117c 	str	r1, [fp, #-380]	; 0x17c
   11d0c:	e51b117c 	ldr	r1, [fp, #-380]	; 0x17c
   11d10:	e1811e03 	orr	r1, r1, r3, lsl #28
   11d14:	e50b117c 	str	r1, [fp, #-380]	; 0x17c
   11d18:	e1a01223 	lsr	r1, r3, #4
   11d1c:	e50b1178 	str	r1, [fp, #-376]	; 0x178
   11d20:	e24b3f5f 	sub	r3, fp, #380	; 0x17c
   11d24:	e893000c 	ldm	r3, {r2, r3}
   11d28:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   11d2c:	e50b3048 	str	r3, [fp, #-72]	; 0x48
					} while (_uquad);
   11d30:	e24b304c 	sub	r3, fp, #76	; 0x4c
   11d34:	e893000c 	ldm	r3, {r2, r3}
   11d38:	e1921003 	orrs	r1, r2, r3
   11d3c:	1affffe7 	bne	11ce0 <_svfprintf_r+0x1290>
					break;
   11d40:	ea000006 	b	11d60 <_svfprintf_r+0x1310>

				default:
					cp = "bug in vfprintf: bad base";
   11d44:	e59f747c 	ldr	r7, [pc, #1148]	; 121c8 <_svfprintf_r+0x1778>
					size = strlen (cp);
   11d48:	e1a00007 	mov	r0, r7
   11d4c:	ebfffb26 	bl	109ec <strlen>
   11d50:	e1a03000 	mov	r3, r0
   11d54:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
					goto skipsize;
   11d58:	e1a00000 	nop			; (mov r0, r0)
                       else if (base == OCT && (flags & ALT))
                         *--cp = '0';

			size = buf + BUF - cp;
		skipsize:
			break;
   11d5c:	ea00001a 	b	11dcc <_svfprintf_r+0x137c>
				default:
					cp = "bug in vfprintf: bad base";
					size = strlen (cp);
					goto skipsize;
				}
			}
   11d60:	ea000008 	b	11d88 <_svfprintf_r+0x1338>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   11d64:	e55b304d 	ldrb	r3, [fp, #-77]	; 0x4d
   11d68:	e3530000 	cmp	r3, #0
   11d6c:	1a000005 	bne	11d88 <_svfprintf_r+0x1338>
   11d70:	e2063001 	and	r3, r6, #1
   11d74:	e3530000 	cmp	r3, #0
   11d78:	0a000002 	beq	11d88 <_svfprintf_r+0x1338>
                         *--cp = '0';
   11d7c:	e2477001 	sub	r7, r7, #1
   11d80:	e3a03030 	mov	r3, #48	; 0x30
   11d84:	e5c73000 	strb	r3, [r7]

			size = buf + BUF - cp;
   11d88:	e24b3f55 	sub	r3, fp, #340	; 0x154
   11d8c:	e2833064 	add	r3, r3, #100	; 0x64
   11d90:	e1a02007 	mov	r2, r7
   11d94:	e0623003 	rsb	r3, r2, r3
   11d98:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
		skipsize:
			break;
   11d9c:	ea00000a 	b	11dcc <_svfprintf_r+0x137c>
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
   11da0:	e3580000 	cmp	r8, #0
   11da4:	1a000000 	bne	11dac <_svfprintf_r+0x135c>
				goto done;
   11da8:	ea0004fc 	b	131a0 <_svfprintf_r+0x2750>
			/* pretend it was %c with argument ch */
			cp = buf;
   11dac:	e24b7f55 	sub	r7, fp, #340	; 0x154
			*cp = ch;
   11db0:	e20830ff 	and	r3, r8, #255	; 0xff
   11db4:	e5c73000 	strb	r3, [r7]
			size = 1;
   11db8:	e3a03001 	mov	r3, #1
   11dbc:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
			sign = '\0';
   11dc0:	e3a03000 	mov	r3, #0
   11dc4:	e54b3085 	strb	r3, [fp, #-133]	; 0x85
			break;
   11dc8:	e1a00000 	nop			; (mov r0, r0)
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
   11dcc:	e51b205c 	ldr	r2, [fp, #-92]	; 0x5c
   11dd0:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   11dd4:	e1520003 	cmp	r2, r3
   11dd8:	a1a03002 	movge	r3, r2
   11ddc:	b1a03003 	movlt	r3, r3
   11de0:	e50b3058 	str	r3, [fp, #-88]	; 0x58
		if (sign)
   11de4:	e55b3085 	ldrb	r3, [fp, #-133]	; 0x85
   11de8:	e3530000 	cmp	r3, #0
   11dec:	0a000002 	beq	11dfc <_svfprintf_r+0x13ac>
			realsz++;
   11df0:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   11df4:	e2833001 	add	r3, r3, #1
   11df8:	e50b3058 	str	r3, [fp, #-88]	; 0x58
		if (flags & HEXPREFIX)
   11dfc:	e2063002 	and	r3, r6, #2
   11e00:	e3530000 	cmp	r3, #0
   11e04:	0a000002 	beq	11e14 <_svfprintf_r+0x13c4>
			realsz+= 2;
   11e08:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   11e0c:	e2833002 	add	r3, r3, #2
   11e10:	e50b3058 	str	r3, [fp, #-88]	; 0x58

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   11e14:	e2063084 	and	r3, r6, #132	; 0x84
   11e18:	e3530000 	cmp	r3, #0
   11e1c:	1a000038 	bne	11f04 <_svfprintf_r+0x14b4>
			PAD (width - realsz, blanks);
   11e20:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   11e24:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   11e28:	e0635002 	rsb	r5, r3, r2
   11e2c:	e3550000 	cmp	r5, #0
   11e30:	da000033 	ble	11f04 <_svfprintf_r+0x14b4>
   11e34:	ea000018 	b	11e9c <_svfprintf_r+0x144c>
   11e38:	e59f3394 	ldr	r3, [pc, #916]	; 121d4 <_svfprintf_r+0x1784>
   11e3c:	e5843000 	str	r3, [r4]
   11e40:	e3a03010 	mov	r3, #16
   11e44:	e5843004 	str	r3, [r4, #4]
   11e48:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   11e4c:	e2833010 	add	r3, r3, #16
   11e50:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   11e54:	e2844008 	add	r4, r4, #8
   11e58:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   11e5c:	e2833001 	add	r3, r3, #1
   11e60:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   11e64:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   11e68:	e3530007 	cmp	r3, #7
   11e6c:	da000009 	ble	11e98 <_svfprintf_r+0x1448>
   11e70:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   11e74:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   11e78:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   11e7c:	e1a02003 	mov	r2, r3
   11e80:	eb0030c5 	bl	1e19c <__ssprint_r>
   11e84:	e1a03000 	mov	r3, r0
   11e88:	e3530000 	cmp	r3, #0
   11e8c:	0a000000 	beq	11e94 <_svfprintf_r+0x1444>
   11e90:	ea0004d1 	b	131dc <_svfprintf_r+0x278c>
   11e94:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   11e98:	e2455010 	sub	r5, r5, #16
   11e9c:	e3550010 	cmp	r5, #16
   11ea0:	caffffe4 	bgt	11e38 <_svfprintf_r+0x13e8>
   11ea4:	e59f3328 	ldr	r3, [pc, #808]	; 121d4 <_svfprintf_r+0x1784>
   11ea8:	e5843000 	str	r3, [r4]
   11eac:	e1a03005 	mov	r3, r5
   11eb0:	e5843004 	str	r3, [r4, #4]
   11eb4:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   11eb8:	e0833005 	add	r3, r3, r5
   11ebc:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   11ec0:	e2844008 	add	r4, r4, #8
   11ec4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   11ec8:	e2833001 	add	r3, r3, #1
   11ecc:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   11ed0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   11ed4:	e3530007 	cmp	r3, #7
   11ed8:	da000009 	ble	11f04 <_svfprintf_r+0x14b4>
   11edc:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   11ee0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   11ee4:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   11ee8:	e1a02003 	mov	r2, r3
   11eec:	eb0030aa 	bl	1e19c <__ssprint_r>
   11ef0:	e1a03000 	mov	r3, r0
   11ef4:	e3530000 	cmp	r3, #0
   11ef8:	0a000000 	beq	11f00 <_svfprintf_r+0x14b0>
   11efc:	ea0004b6 	b	131dc <_svfprintf_r+0x278c>
   11f00:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* prefix */
		if (sign)
   11f04:	e55b3085 	ldrb	r3, [fp, #-133]	; 0x85
   11f08:	e3530000 	cmp	r3, #0
   11f0c:	0a000017 	beq	11f70 <_svfprintf_r+0x1520>
			PRINT (&sign, 1);
   11f10:	e24b3085 	sub	r3, fp, #133	; 0x85
   11f14:	e5843000 	str	r3, [r4]
   11f18:	e3a03001 	mov	r3, #1
   11f1c:	e5843004 	str	r3, [r4, #4]
   11f20:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   11f24:	e2833001 	add	r3, r3, #1
   11f28:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   11f2c:	e2844008 	add	r4, r4, #8
   11f30:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   11f34:	e2833001 	add	r3, r3, #1
   11f38:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   11f3c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   11f40:	e3530007 	cmp	r3, #7
   11f44:	da000009 	ble	11f70 <_svfprintf_r+0x1520>
   11f48:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   11f4c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   11f50:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   11f54:	e1a02003 	mov	r2, r3
   11f58:	eb00308f 	bl	1e19c <__ssprint_r>
   11f5c:	e1a03000 	mov	r3, r0
   11f60:	e3530000 	cmp	r3, #0
   11f64:	0a000000 	beq	11f6c <_svfprintf_r+0x151c>
   11f68:	ea00049b 	b	131dc <_svfprintf_r+0x278c>
   11f6c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
		if (flags & HEXPREFIX)
   11f70:	e2063002 	and	r3, r6, #2
   11f74:	e3530000 	cmp	r3, #0
   11f78:	0a000017 	beq	11fdc <_svfprintf_r+0x158c>
			PRINT (ox, 2);
   11f7c:	e24b3f56 	sub	r3, fp, #344	; 0x158
   11f80:	e5843000 	str	r3, [r4]
   11f84:	e3a03002 	mov	r3, #2
   11f88:	e5843004 	str	r3, [r4, #4]
   11f8c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   11f90:	e2833002 	add	r3, r3, #2
   11f94:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   11f98:	e2844008 	add	r4, r4, #8
   11f9c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   11fa0:	e2833001 	add	r3, r3, #1
   11fa4:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   11fa8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   11fac:	e3530007 	cmp	r3, #7
   11fb0:	da000009 	ble	11fdc <_svfprintf_r+0x158c>
   11fb4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   11fb8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   11fbc:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   11fc0:	e1a02003 	mov	r2, r3
   11fc4:	eb003074 	bl	1e19c <__ssprint_r>
   11fc8:	e1a03000 	mov	r3, r0
   11fcc:	e3530000 	cmp	r3, #0
   11fd0:	0a000000 	beq	11fd8 <_svfprintf_r+0x1588>
   11fd4:	ea000480 	b	131dc <_svfprintf_r+0x278c>
   11fd8:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   11fdc:	e2063084 	and	r3, r6, #132	; 0x84
   11fe0:	e3530080 	cmp	r3, #128	; 0x80
   11fe4:	1a000038 	bne	120cc <_svfprintf_r+0x167c>
			PAD (width - realsz, zeroes);
   11fe8:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   11fec:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   11ff0:	e0635002 	rsb	r5, r3, r2
   11ff4:	e3550000 	cmp	r5, #0
   11ff8:	da000033 	ble	120cc <_svfprintf_r+0x167c>
   11ffc:	ea000018 	b	12064 <_svfprintf_r+0x1614>
   12000:	e59f31c8 	ldr	r3, [pc, #456]	; 121d0 <_svfprintf_r+0x1780>
   12004:	e5843000 	str	r3, [r4]
   12008:	e3a03010 	mov	r3, #16
   1200c:	e5843004 	str	r3, [r4, #4]
   12010:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   12014:	e2833010 	add	r3, r3, #16
   12018:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1201c:	e2844008 	add	r4, r4, #8
   12020:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12024:	e2833001 	add	r3, r3, #1
   12028:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1202c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12030:	e3530007 	cmp	r3, #7
   12034:	da000009 	ble	12060 <_svfprintf_r+0x1610>
   12038:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1203c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12040:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12044:	e1a02003 	mov	r2, r3
   12048:	eb003053 	bl	1e19c <__ssprint_r>
   1204c:	e1a03000 	mov	r3, r0
   12050:	e3530000 	cmp	r3, #0
   12054:	0a000000 	beq	1205c <_svfprintf_r+0x160c>
   12058:	ea00045f 	b	131dc <_svfprintf_r+0x278c>
   1205c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   12060:	e2455010 	sub	r5, r5, #16
   12064:	e3550010 	cmp	r5, #16
   12068:	caffffe4 	bgt	12000 <_svfprintf_r+0x15b0>
   1206c:	e59f315c 	ldr	r3, [pc, #348]	; 121d0 <_svfprintf_r+0x1780>
   12070:	e5843000 	str	r3, [r4]
   12074:	e1a03005 	mov	r3, r5
   12078:	e5843004 	str	r3, [r4, #4]
   1207c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   12080:	e0833005 	add	r3, r3, r5
   12084:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12088:	e2844008 	add	r4, r4, #8
   1208c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12090:	e2833001 	add	r3, r3, #1
   12094:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12098:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1209c:	e3530007 	cmp	r3, #7
   120a0:	da000009 	ble	120cc <_svfprintf_r+0x167c>
   120a4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   120a8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   120ac:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   120b0:	e1a02003 	mov	r2, r3
   120b4:	eb003038 	bl	1e19c <__ssprint_r>
   120b8:	e1a03000 	mov	r3, r0
   120bc:	e3530000 	cmp	r3, #0
   120c0:	0a000000 	beq	120c8 <_svfprintf_r+0x1678>
   120c4:	ea000444 	b	131dc <_svfprintf_r+0x278c>
   120c8:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   120cc:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   120d0:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   120d4:	e0635002 	rsb	r5, r3, r2
   120d8:	e3550000 	cmp	r5, #0
   120dc:	da00003e 	ble	121dc <_svfprintf_r+0x178c>
   120e0:	ea000018 	b	12148 <_svfprintf_r+0x16f8>
   120e4:	e59f30e4 	ldr	r3, [pc, #228]	; 121d0 <_svfprintf_r+0x1780>
   120e8:	e5843000 	str	r3, [r4]
   120ec:	e3a03010 	mov	r3, #16
   120f0:	e5843004 	str	r3, [r4, #4]
   120f4:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   120f8:	e2833010 	add	r3, r3, #16
   120fc:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12100:	e2844008 	add	r4, r4, #8
   12104:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12108:	e2833001 	add	r3, r3, #1
   1210c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12110:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12114:	e3530007 	cmp	r3, #7
   12118:	da000009 	ble	12144 <_svfprintf_r+0x16f4>
   1211c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12120:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12124:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12128:	e1a02003 	mov	r2, r3
   1212c:	eb00301a 	bl	1e19c <__ssprint_r>
   12130:	e1a03000 	mov	r3, r0
   12134:	e3530000 	cmp	r3, #0
   12138:	0a000000 	beq	12140 <_svfprintf_r+0x16f0>
   1213c:	ea000426 	b	131dc <_svfprintf_r+0x278c>
   12140:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   12144:	e2455010 	sub	r5, r5, #16
   12148:	e3550010 	cmp	r5, #16
   1214c:	caffffe4 	bgt	120e4 <_svfprintf_r+0x1694>
   12150:	e59f3078 	ldr	r3, [pc, #120]	; 121d0 <_svfprintf_r+0x1780>
   12154:	e5843000 	str	r3, [r4]
   12158:	e1a03005 	mov	r3, r5
   1215c:	e5843004 	str	r3, [r4, #4]
   12160:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   12164:	e0833005 	add	r3, r3, r5
   12168:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1216c:	e2844008 	add	r4, r4, #8
   12170:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12174:	e2833001 	add	r3, r3, #1
   12178:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1217c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12180:	e3530007 	cmp	r3, #7
   12184:	da000014 	ble	121dc <_svfprintf_r+0x178c>
   12188:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1218c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12190:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12194:	e1a02003 	mov	r2, r3
   12198:	eb002fff 	bl	1e19c <__ssprint_r>
   1219c:	e1a03000 	mov	r3, r0
   121a0:	e3530000 	cmp	r3, #0
   121a4:	0a00000b 	beq	121d8 <_svfprintf_r+0x1788>
   121a8:	ea00040b 	b	131dc <_svfprintf_r+0x278c>
   121ac:	000246f4 	.word	0x000246f4
   121b0:	000246f8 	.word	0x000246f8
   121b4:	000246fc 	.word	0x000246fc
   121b8:	00024700 	.word	0x00024700
   121bc:	00024704 	.word	0x00024704
   121c0:	00024718 	.word	0x00024718
   121c4:	00024720 	.word	0x00024720
   121c8:	00024734 	.word	0x00024734
   121cc:	00024750 	.word	0x00024750
   121d0:	00024764 	.word	0x00024764
   121d4:	00024754 	.word	0x00024754
   121d8:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
   121dc:	e2063c01 	and	r3, r6, #256	; 0x100
   121e0:	e3530000 	cmp	r3, #0
   121e4:	1a000018 	bne	1224c <_svfprintf_r+0x17fc>
			PRINT (cp, size);
   121e8:	e5847000 	str	r7, [r4]
   121ec:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   121f0:	e5843004 	str	r3, [r4, #4]
   121f4:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   121f8:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   121fc:	e0823003 	add	r3, r2, r3
   12200:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12204:	e2844008 	add	r4, r4, #8
   12208:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1220c:	e2833001 	add	r3, r3, #1
   12210:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12214:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12218:	e3530007 	cmp	r3, #7
   1221c:	da000383 	ble	13030 <_svfprintf_r+0x25e0>
   12220:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12224:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12228:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1222c:	e1a02003 	mov	r2, r3
   12230:	eb002fd9 	bl	1e19c <__ssprint_r>
   12234:	e1a03000 	mov	r3, r0
   12238:	e3530000 	cmp	r3, #0
   1223c:	0a000000 	beq	12244 <_svfprintf_r+0x17f4>
   12240:	ea0003e5 	b	131dc <_svfprintf_r+0x278c>
   12244:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   12248:	ea000378 	b	13030 <_svfprintf_r+0x25e0>
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
   1224c:	e3580065 	cmp	r8, #101	; 0x65
   12250:	da0002af 	ble	12d14 <_svfprintf_r+0x22c4>
				if (_fpvalue == 0) {
   12254:	e24b3094 	sub	r3, fp, #148	; 0x94
   12258:	e893000c 	ldm	r3, {r2, r3}
   1225c:	e1a00002 	mov	r0, r2
   12260:	e1a01003 	mov	r1, r3
   12264:	e3a02000 	mov	r2, #0
   12268:	e3a03000 	mov	r3, #0
   1226c:	eb00425f 	bl	22bf0 <__aeabi_dcmpeq>
   12270:	e1a03000 	mov	r3, r0
   12274:	e3530000 	cmp	r3, #0
   12278:	0a000071 	beq	12444 <_svfprintf_r+0x19f4>
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
   1227c:	e51f30b8 	ldr	r3, [pc, #-184]	; 121cc <_svfprintf_r+0x177c>
   12280:	e5843000 	str	r3, [r4]
   12284:	e3a03001 	mov	r3, #1
   12288:	e5843004 	str	r3, [r4, #4]
   1228c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   12290:	e2833001 	add	r3, r3, #1
   12294:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12298:	e2844008 	add	r4, r4, #8
   1229c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   122a0:	e2833001 	add	r3, r3, #1
   122a4:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   122a8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   122ac:	e3530007 	cmp	r3, #7
   122b0:	da000009 	ble	122dc <_svfprintf_r+0x188c>
   122b4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   122b8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   122bc:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   122c0:	e1a02003 	mov	r2, r3
   122c4:	eb002fb4 	bl	1e19c <__ssprint_r>
   122c8:	e1a03000 	mov	r3, r0
   122cc:	e3530000 	cmp	r3, #0
   122d0:	0a000000 	beq	122d8 <_svfprintf_r+0x1888>
   122d4:	ea0003c0 	b	131dc <_svfprintf_r+0x278c>
   122d8:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					if (expt < ndig || flags & ALT) {
   122dc:	e51b2098 	ldr	r2, [fp, #-152]	; 0x98
   122e0:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   122e4:	e1520003 	cmp	r2, r3
   122e8:	ba000002 	blt	122f8 <_svfprintf_r+0x18a8>
   122ec:	e2063001 	and	r3, r6, #1
   122f0:	e3530000 	cmp	r3, #0
   122f4:	0a00034d 	beq	13030 <_svfprintf_r+0x25e0>
						PRINT (decimal_point, decp_len);
   122f8:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   122fc:	e5843000 	str	r3, [r4]
   12300:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   12304:	e5843004 	str	r3, [r4, #4]
   12308:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1230c:	e1a02003 	mov	r2, r3
   12310:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   12314:	e0823003 	add	r3, r2, r3
   12318:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1231c:	e2844008 	add	r4, r4, #8
   12320:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12324:	e2833001 	add	r3, r3, #1
   12328:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1232c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12330:	e3530007 	cmp	r3, #7
   12334:	da000009 	ble	12360 <_svfprintf_r+0x1910>
   12338:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1233c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12340:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12344:	e1a02003 	mov	r2, r3
   12348:	eb002f93 	bl	1e19c <__ssprint_r>
   1234c:	e1a03000 	mov	r3, r0
   12350:	e3530000 	cmp	r3, #0
   12354:	0a000000 	beq	1235c <_svfprintf_r+0x190c>
   12358:	ea00039f 	b	131dc <_svfprintf_r+0x278c>
   1235c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						PAD (ndig - 1, zeroes);
   12360:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   12364:	e2435001 	sub	r5, r3, #1
   12368:	e3550000 	cmp	r5, #0
   1236c:	da00032f 	ble	13030 <_svfprintf_r+0x25e0>
   12370:	ea000018 	b	123d8 <_svfprintf_r+0x1988>
   12374:	e51f31ac 	ldr	r3, [pc, #-428]	; 121d0 <_svfprintf_r+0x1780>
   12378:	e5843000 	str	r3, [r4]
   1237c:	e3a03010 	mov	r3, #16
   12380:	e5843004 	str	r3, [r4, #4]
   12384:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   12388:	e2833010 	add	r3, r3, #16
   1238c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12390:	e2844008 	add	r4, r4, #8
   12394:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12398:	e2833001 	add	r3, r3, #1
   1239c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   123a0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   123a4:	e3530007 	cmp	r3, #7
   123a8:	da000009 	ble	123d4 <_svfprintf_r+0x1984>
   123ac:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   123b0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   123b4:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   123b8:	e1a02003 	mov	r2, r3
   123bc:	eb002f76 	bl	1e19c <__ssprint_r>
   123c0:	e1a03000 	mov	r3, r0
   123c4:	e3530000 	cmp	r3, #0
   123c8:	0a000000 	beq	123d0 <_svfprintf_r+0x1980>
   123cc:	ea000382 	b	131dc <_svfprintf_r+0x278c>
   123d0:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   123d4:	e2455010 	sub	r5, r5, #16
   123d8:	e3550010 	cmp	r5, #16
   123dc:	caffffe4 	bgt	12374 <_svfprintf_r+0x1924>
   123e0:	e51f3218 	ldr	r3, [pc, #-536]	; 121d0 <_svfprintf_r+0x1780>
   123e4:	e5843000 	str	r3, [r4]
   123e8:	e1a03005 	mov	r3, r5
   123ec:	e5843004 	str	r3, [r4, #4]
   123f0:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   123f4:	e0833005 	add	r3, r3, r5
   123f8:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   123fc:	e2844008 	add	r4, r4, #8
   12400:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12404:	e2833001 	add	r3, r3, #1
   12408:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1240c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12410:	e3530007 	cmp	r3, #7
   12414:	da000305 	ble	13030 <_svfprintf_r+0x25e0>
   12418:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1241c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12420:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12424:	e1a02003 	mov	r2, r3
   12428:	eb002f5b 	bl	1e19c <__ssprint_r>
   1242c:	e1a03000 	mov	r3, r0
   12430:	e3530000 	cmp	r3, #0
   12434:	0a000000 	beq	1243c <_svfprintf_r+0x19ec>
   12438:	ea000367 	b	131dc <_svfprintf_r+0x278c>
   1243c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   12440:	ea0002fa 	b	13030 <_svfprintf_r+0x25e0>
					}
				} else if (expt <= 0) {
   12444:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   12448:	e3530000 	cmp	r3, #0
   1244c:	ca00008b 	bgt	12680 <_svfprintf_r+0x1c30>
					PRINT ("0", 1);
   12450:	e51f328c 	ldr	r3, [pc, #-652]	; 121cc <_svfprintf_r+0x177c>
   12454:	e5843000 	str	r3, [r4]
   12458:	e3a03001 	mov	r3, #1
   1245c:	e5843004 	str	r3, [r4, #4]
   12460:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   12464:	e2833001 	add	r3, r3, #1
   12468:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1246c:	e2844008 	add	r4, r4, #8
   12470:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12474:	e2833001 	add	r3, r3, #1
   12478:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1247c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12480:	e3530007 	cmp	r3, #7
   12484:	da000009 	ble	124b0 <_svfprintf_r+0x1a60>
   12488:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1248c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12490:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12494:	e1a02003 	mov	r2, r3
   12498:	eb002f3f 	bl	1e19c <__ssprint_r>
   1249c:	e1a03000 	mov	r3, r0
   124a0:	e3530000 	cmp	r3, #0
   124a4:	0a000000 	beq	124ac <_svfprintf_r+0x1a5c>
   124a8:	ea00034b 	b	131dc <_svfprintf_r+0x278c>
   124ac:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					if (expt || ndig || flags & ALT) {
   124b0:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   124b4:	e3530000 	cmp	r3, #0
   124b8:	1a000005 	bne	124d4 <_svfprintf_r+0x1a84>
   124bc:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   124c0:	e3530000 	cmp	r3, #0
   124c4:	1a000002 	bne	124d4 <_svfprintf_r+0x1a84>
   124c8:	e2063001 	and	r3, r6, #1
   124cc:	e3530000 	cmp	r3, #0
   124d0:	0a0002d6 	beq	13030 <_svfprintf_r+0x25e0>
						PRINT (decimal_point, decp_len);
   124d4:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   124d8:	e5843000 	str	r3, [r4]
   124dc:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   124e0:	e5843004 	str	r3, [r4, #4]
   124e4:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   124e8:	e1a02003 	mov	r2, r3
   124ec:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   124f0:	e0823003 	add	r3, r2, r3
   124f4:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   124f8:	e2844008 	add	r4, r4, #8
   124fc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12500:	e2833001 	add	r3, r3, #1
   12504:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12508:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1250c:	e3530007 	cmp	r3, #7
   12510:	da000009 	ble	1253c <_svfprintf_r+0x1aec>
   12514:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12518:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1251c:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12520:	e1a02003 	mov	r2, r3
   12524:	eb002f1c 	bl	1e19c <__ssprint_r>
   12528:	e1a03000 	mov	r3, r0
   1252c:	e3530000 	cmp	r3, #0
   12530:	0a000000 	beq	12538 <_svfprintf_r+0x1ae8>
   12534:	ea000328 	b	131dc <_svfprintf_r+0x278c>
   12538:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						PAD (-expt, zeroes);
   1253c:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   12540:	e2635000 	rsb	r5, r3, #0
   12544:	e3550000 	cmp	r5, #0
   12548:	da000033 	ble	1261c <_svfprintf_r+0x1bcc>
   1254c:	ea000018 	b	125b4 <_svfprintf_r+0x1b64>
   12550:	e51f3388 	ldr	r3, [pc, #-904]	; 121d0 <_svfprintf_r+0x1780>
   12554:	e5843000 	str	r3, [r4]
   12558:	e3a03010 	mov	r3, #16
   1255c:	e5843004 	str	r3, [r4, #4]
   12560:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   12564:	e2833010 	add	r3, r3, #16
   12568:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1256c:	e2844008 	add	r4, r4, #8
   12570:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12574:	e2833001 	add	r3, r3, #1
   12578:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1257c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12580:	e3530007 	cmp	r3, #7
   12584:	da000009 	ble	125b0 <_svfprintf_r+0x1b60>
   12588:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1258c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12590:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12594:	e1a02003 	mov	r2, r3
   12598:	eb002eff 	bl	1e19c <__ssprint_r>
   1259c:	e1a03000 	mov	r3, r0
   125a0:	e3530000 	cmp	r3, #0
   125a4:	0a000000 	beq	125ac <_svfprintf_r+0x1b5c>
   125a8:	ea00030b 	b	131dc <_svfprintf_r+0x278c>
   125ac:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   125b0:	e2455010 	sub	r5, r5, #16
   125b4:	e3550010 	cmp	r5, #16
   125b8:	caffffe4 	bgt	12550 <_svfprintf_r+0x1b00>
   125bc:	e51f33f4 	ldr	r3, [pc, #-1012]	; 121d0 <_svfprintf_r+0x1780>
   125c0:	e5843000 	str	r3, [r4]
   125c4:	e1a03005 	mov	r3, r5
   125c8:	e5843004 	str	r3, [r4, #4]
   125cc:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   125d0:	e0833005 	add	r3, r3, r5
   125d4:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   125d8:	e2844008 	add	r4, r4, #8
   125dc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   125e0:	e2833001 	add	r3, r3, #1
   125e4:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   125e8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   125ec:	e3530007 	cmp	r3, #7
   125f0:	da000009 	ble	1261c <_svfprintf_r+0x1bcc>
   125f4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   125f8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   125fc:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12600:	e1a02003 	mov	r2, r3
   12604:	eb002ee4 	bl	1e19c <__ssprint_r>
   12608:	e1a03000 	mov	r3, r0
   1260c:	e3530000 	cmp	r3, #0
   12610:	0a000000 	beq	12618 <_svfprintf_r+0x1bc8>
   12614:	ea0002f0 	b	131dc <_svfprintf_r+0x278c>
   12618:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						PRINT (cp, ndig);
   1261c:	e5847000 	str	r7, [r4]
   12620:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   12624:	e5843004 	str	r3, [r4, #4]
   12628:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1262c:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   12630:	e0823003 	add	r3, r2, r3
   12634:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12638:	e2844008 	add	r4, r4, #8
   1263c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12640:	e2833001 	add	r3, r3, #1
   12644:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12648:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1264c:	e3530007 	cmp	r3, #7
   12650:	da000276 	ble	13030 <_svfprintf_r+0x25e0>
   12654:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12658:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1265c:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12660:	e1a02003 	mov	r2, r3
   12664:	eb002ecc 	bl	1e19c <__ssprint_r>
   12668:	e1a03000 	mov	r3, r0
   1266c:	e3530000 	cmp	r3, #0
   12670:	0a000000 	beq	12678 <_svfprintf_r+0x1c28>
   12674:	ea0002d8 	b	131dc <_svfprintf_r+0x278c>
   12678:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1267c:	ea00026b 	b	13030 <_svfprintf_r+0x25e0>
					}
				} else {
					char *convbuf = cp;
   12680:	e50b7084 	str	r7, [fp, #-132]	; 0x84
					PRINTANDPAD(cp, convbuf + ndig,
   12684:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   12688:	e51b2084 	ldr	r2, [fp, #-132]	; 0x84
   1268c:	e0823003 	add	r3, r2, r3
   12690:	e1a02003 	mov	r2, r3
   12694:	e1a03007 	mov	r3, r7
   12698:	e0633002 	rsb	r3, r3, r2
   1269c:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   126a0:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   126a4:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   126a8:	e1520003 	cmp	r2, r3
   126ac:	da000001 	ble	126b8 <_svfprintf_r+0x1c68>
   126b0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   126b4:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   126b8:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   126bc:	e3530000 	cmp	r3, #0
   126c0:	da000017 	ble	12724 <_svfprintf_r+0x1cd4>
   126c4:	e5847000 	str	r7, [r4]
   126c8:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   126cc:	e5843004 	str	r3, [r4, #4]
   126d0:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   126d4:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   126d8:	e0823003 	add	r3, r2, r3
   126dc:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   126e0:	e2844008 	add	r4, r4, #8
   126e4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   126e8:	e2833001 	add	r3, r3, #1
   126ec:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   126f0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   126f4:	e3530007 	cmp	r3, #7
   126f8:	da000009 	ble	12724 <_svfprintf_r+0x1cd4>
   126fc:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12700:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12704:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12708:	e1a02003 	mov	r2, r3
   1270c:	eb002ea2 	bl	1e19c <__ssprint_r>
   12710:	e1a03000 	mov	r3, r0
   12714:	e3530000 	cmp	r3, #0
   12718:	0a000000 	beq	12720 <_svfprintf_r+0x1cd0>
   1271c:	ea0002ae 	b	131dc <_svfprintf_r+0x278c>
   12720:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   12724:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   12728:	e1c33fc3 	bic	r3, r3, r3, asr #31
   1272c:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   12730:	e0633002 	rsb	r3, r3, r2
   12734:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   12738:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1273c:	e3530000 	cmp	r3, #0
   12740:	da000037 	ble	12824 <_svfprintf_r+0x1dd4>
   12744:	ea00001a 	b	127b4 <_svfprintf_r+0x1d64>
   12748:	e51f3580 	ldr	r3, [pc, #-1408]	; 121d0 <_svfprintf_r+0x1780>
   1274c:	e5843000 	str	r3, [r4]
   12750:	e3a03010 	mov	r3, #16
   12754:	e5843004 	str	r3, [r4, #4]
   12758:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1275c:	e2833010 	add	r3, r3, #16
   12760:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12764:	e2844008 	add	r4, r4, #8
   12768:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1276c:	e2833001 	add	r3, r3, #1
   12770:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12774:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12778:	e3530007 	cmp	r3, #7
   1277c:	da000009 	ble	127a8 <_svfprintf_r+0x1d58>
   12780:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12784:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12788:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   1278c:	e1a02003 	mov	r2, r3
   12790:	eb002e81 	bl	1e19c <__ssprint_r>
   12794:	e1a03000 	mov	r3, r0
   12798:	e3530000 	cmp	r3, #0
   1279c:	0a000000 	beq	127a4 <_svfprintf_r+0x1d54>
   127a0:	ea00028d 	b	131dc <_svfprintf_r+0x278c>
   127a4:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   127a8:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   127ac:	e2433010 	sub	r3, r3, #16
   127b0:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   127b4:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   127b8:	e3530010 	cmp	r3, #16
   127bc:	caffffe1 	bgt	12748 <_svfprintf_r+0x1cf8>
   127c0:	e51f35f8 	ldr	r3, [pc, #-1528]	; 121d0 <_svfprintf_r+0x1780>
   127c4:	e5843000 	str	r3, [r4]
   127c8:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   127cc:	e5843004 	str	r3, [r4, #4]
   127d0:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   127d4:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   127d8:	e0823003 	add	r3, r2, r3
   127dc:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   127e0:	e2844008 	add	r4, r4, #8
   127e4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   127e8:	e2833001 	add	r3, r3, #1
   127ec:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   127f0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   127f4:	e3530007 	cmp	r3, #7
   127f8:	da000009 	ble	12824 <_svfprintf_r+0x1dd4>
   127fc:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12800:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12804:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12808:	e1a02003 	mov	r2, r3
   1280c:	eb002e62 	bl	1e19c <__ssprint_r>
   12810:	e1a03000 	mov	r3, r0
   12814:	e3530000 	cmp	r3, #0
   12818:	0a000000 	beq	12820 <_svfprintf_r+0x1dd0>
   1281c:	ea00026e 	b	131dc <_svfprintf_r+0x278c>
   12820:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						    lead, zeroes);
					cp += lead;
   12824:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   12828:	e0877003 	add	r7, r7, r3
#ifdef _WANT_IO_C99_FORMATS
					if (flags & GROUPING) {
   1282c:	e2063b01 	and	r3, r6, #1024	; 0x400
   12830:	e3530000 	cmp	r3, #0
   12834:	0a0000a5 	beq	12ad0 <_svfprintf_r+0x2080>
					    while (nseps > 0 || nrepeats > 0) {
   12838:	ea000096 	b	12a98 <_svfprintf_r+0x2048>
						if (nrepeats > 0)
   1283c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   12840:	e3530000 	cmp	r3, #0
   12844:	da000003 	ble	12858 <_svfprintf_r+0x1e08>
						    nrepeats--;
   12848:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1284c:	e2433001 	sub	r3, r3, #1
   12850:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   12854:	ea000005 	b	12870 <_svfprintf_r+0x1e20>
						else {
						    grouping--;
   12858:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1285c:	e2433001 	sub	r3, r3, #1
   12860:	e50b3034 	str	r3, [fp, #-52]	; 0x34
						    nseps--;
   12864:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   12868:	e2433001 	sub	r3, r3, #1
   1286c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
						}
						PRINT(thousands_sep, thsnd_len);
   12870:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   12874:	e5843000 	str	r3, [r4]
   12878:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1287c:	e5843004 	str	r3, [r4, #4]
   12880:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   12884:	e1a02003 	mov	r2, r3
   12888:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1288c:	e0823003 	add	r3, r2, r3
   12890:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12894:	e2844008 	add	r4, r4, #8
   12898:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1289c:	e2833001 	add	r3, r3, #1
   128a0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   128a4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   128a8:	e3530007 	cmp	r3, #7
   128ac:	da000009 	ble	128d8 <_svfprintf_r+0x1e88>
   128b0:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   128b4:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   128b8:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   128bc:	e1a02003 	mov	r2, r3
   128c0:	eb002e35 	bl	1e19c <__ssprint_r>
   128c4:	e1a03000 	mov	r3, r0
   128c8:	e3530000 	cmp	r3, #0
   128cc:	0a000000 	beq	128d4 <_svfprintf_r+0x1e84>
   128d0:	ea000241 	b	131dc <_svfprintf_r+0x278c>
   128d4:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						PRINTANDPAD (cp, convbuf + ndig,
   128d8:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   128dc:	e51b2084 	ldr	r2, [fp, #-132]	; 0x84
   128e0:	e0823003 	add	r3, r2, r3
   128e4:	e1a02003 	mov	r2, r3
   128e8:	e1a03007 	mov	r3, r7
   128ec:	e0633002 	rsb	r3, r3, r2
   128f0:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   128f4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   128f8:	e5d33000 	ldrb	r3, [r3]
   128fc:	e1a02003 	mov	r2, r3
   12900:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   12904:	e1520003 	cmp	r2, r3
   12908:	aa000002 	bge	12918 <_svfprintf_r+0x1ec8>
   1290c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   12910:	e5d33000 	ldrb	r3, [r3]
   12914:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   12918:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1291c:	e3530000 	cmp	r3, #0
   12920:	da000017 	ble	12984 <_svfprintf_r+0x1f34>
   12924:	e5847000 	str	r7, [r4]
   12928:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1292c:	e5843004 	str	r3, [r4, #4]
   12930:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   12934:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   12938:	e0823003 	add	r3, r2, r3
   1293c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12940:	e2844008 	add	r4, r4, #8
   12944:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12948:	e2833001 	add	r3, r3, #1
   1294c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12950:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12954:	e3530007 	cmp	r3, #7
   12958:	da000009 	ble	12984 <_svfprintf_r+0x1f34>
   1295c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12960:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12964:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12968:	e1a02003 	mov	r2, r3
   1296c:	eb002e0a 	bl	1e19c <__ssprint_r>
   12970:	e1a03000 	mov	r3, r0
   12974:	e3530000 	cmp	r3, #0
   12978:	0a000000 	beq	12980 <_svfprintf_r+0x1f30>
   1297c:	ea000216 	b	131dc <_svfprintf_r+0x278c>
   12980:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   12984:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   12988:	e5d33000 	ldrb	r3, [r3]
   1298c:	e1a02003 	mov	r2, r3
   12990:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   12994:	e1c33fc3 	bic	r3, r3, r3, asr #31
   12998:	e0633002 	rsb	r3, r3, r2
   1299c:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   129a0:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   129a4:	e3530000 	cmp	r3, #0
   129a8:	da000037 	ble	12a8c <_svfprintf_r+0x203c>
   129ac:	ea00001a 	b	12a1c <_svfprintf_r+0x1fcc>
   129b0:	e51f37e8 	ldr	r3, [pc, #-2024]	; 121d0 <_svfprintf_r+0x1780>
   129b4:	e5843000 	str	r3, [r4]
   129b8:	e3a03010 	mov	r3, #16
   129bc:	e5843004 	str	r3, [r4, #4]
   129c0:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   129c4:	e2833010 	add	r3, r3, #16
   129c8:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   129cc:	e2844008 	add	r4, r4, #8
   129d0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   129d4:	e2833001 	add	r3, r3, #1
   129d8:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   129dc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   129e0:	e3530007 	cmp	r3, #7
   129e4:	da000009 	ble	12a10 <_svfprintf_r+0x1fc0>
   129e8:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   129ec:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   129f0:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   129f4:	e1a02003 	mov	r2, r3
   129f8:	eb002de7 	bl	1e19c <__ssprint_r>
   129fc:	e1a03000 	mov	r3, r0
   12a00:	e3530000 	cmp	r3, #0
   12a04:	0a000000 	beq	12a0c <_svfprintf_r+0x1fbc>
   12a08:	ea0001f3 	b	131dc <_svfprintf_r+0x278c>
   12a0c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   12a10:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   12a14:	e2433010 	sub	r3, r3, #16
   12a18:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   12a1c:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   12a20:	e3530010 	cmp	r3, #16
   12a24:	caffffe1 	bgt	129b0 <_svfprintf_r+0x1f60>
   12a28:	e51f3860 	ldr	r3, [pc, #-2144]	; 121d0 <_svfprintf_r+0x1780>
   12a2c:	e5843000 	str	r3, [r4]
   12a30:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   12a34:	e5843004 	str	r3, [r4, #4]
   12a38:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   12a3c:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   12a40:	e0823003 	add	r3, r2, r3
   12a44:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12a48:	e2844008 	add	r4, r4, #8
   12a4c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12a50:	e2833001 	add	r3, r3, #1
   12a54:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12a58:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12a5c:	e3530007 	cmp	r3, #7
   12a60:	da000009 	ble	12a8c <_svfprintf_r+0x203c>
   12a64:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12a68:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12a6c:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12a70:	e1a02003 	mov	r2, r3
   12a74:	eb002dc8 	bl	1e19c <__ssprint_r>
   12a78:	e1a03000 	mov	r3, r0
   12a7c:	e3530000 	cmp	r3, #0
   12a80:	0a000000 	beq	12a88 <_svfprintf_r+0x2038>
   12a84:	ea0001d4 	b	131dc <_svfprintf_r+0x278c>
   12a88:	e24b40f0 	sub	r4, fp, #240	; 0xf0
							     *grouping, zeroes);
						cp += *grouping;
   12a8c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   12a90:	e5d33000 	ldrb	r3, [r3]
   12a94:	e0877003 	add	r7, r7, r3
					PRINTANDPAD(cp, convbuf + ndig,
						    lead, zeroes);
					cp += lead;
#ifdef _WANT_IO_C99_FORMATS
					if (flags & GROUPING) {
					    while (nseps > 0 || nrepeats > 0) {
   12a98:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   12a9c:	e3530000 	cmp	r3, #0
   12aa0:	caffff65 	bgt	1283c <_svfprintf_r+0x1dec>
   12aa4:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   12aa8:	e3530000 	cmp	r3, #0
   12aac:	caffff62 	bgt	1283c <_svfprintf_r+0x1dec>
						PRINT(thousands_sep, thsnd_len);
						PRINTANDPAD (cp, convbuf + ndig,
							     *grouping, zeroes);
						cp += *grouping;
					    }
					    if (cp > convbuf + ndig)
   12ab0:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   12ab4:	e51b2084 	ldr	r2, [fp, #-132]	; 0x84
   12ab8:	e0823003 	add	r3, r2, r3
   12abc:	e1530007 	cmp	r3, r7
   12ac0:	2a000002 	bcs	12ad0 <_svfprintf_r+0x2080>
						cp = convbuf + ndig;
   12ac4:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   12ac8:	e51b2084 	ldr	r2, [fp, #-132]	; 0x84
   12acc:	e0827003 	add	r7, r2, r3
					}
#endif
					if (expt < ndig || flags & ALT)
   12ad0:	e51b2098 	ldr	r2, [fp, #-152]	; 0x98
   12ad4:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   12ad8:	e1520003 	cmp	r2, r3
   12adc:	ba000002 	blt	12aec <_svfprintf_r+0x209c>
   12ae0:	e2063001 	and	r3, r6, #1
   12ae4:	e3530000 	cmp	r3, #0
   12ae8:	0a000019 	beq	12b54 <_svfprintf_r+0x2104>
					    PRINT (decimal_point, decp_len);
   12aec:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   12af0:	e5843000 	str	r3, [r4]
   12af4:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   12af8:	e5843004 	str	r3, [r4, #4]
   12afc:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   12b00:	e1a02003 	mov	r2, r3
   12b04:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   12b08:	e0823003 	add	r3, r2, r3
   12b0c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12b10:	e2844008 	add	r4, r4, #8
   12b14:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12b18:	e2833001 	add	r3, r3, #1
   12b1c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12b20:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12b24:	e3530007 	cmp	r3, #7
   12b28:	da000009 	ble	12b54 <_svfprintf_r+0x2104>
   12b2c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12b30:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12b34:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12b38:	e1a02003 	mov	r2, r3
   12b3c:	eb002d96 	bl	1e19c <__ssprint_r>
   12b40:	e1a03000 	mov	r3, r0
   12b44:	e3530000 	cmp	r3, #0
   12b48:	0a000000 	beq	12b50 <_svfprintf_r+0x2100>
   12b4c:	ea0001a2 	b	131dc <_svfprintf_r+0x278c>
   12b50:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					PRINTANDPAD (cp, convbuf + ndig,
   12b54:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   12b58:	e51b2084 	ldr	r2, [fp, #-132]	; 0x84
   12b5c:	e0823003 	add	r3, r2, r3
   12b60:	e1a02003 	mov	r2, r3
   12b64:	e1a03007 	mov	r3, r7
   12b68:	e0633002 	rsb	r3, r3, r2
   12b6c:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   12b70:	e51b20a4 	ldr	r2, [fp, #-164]	; 0xa4
   12b74:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   12b78:	e0632002 	rsb	r2, r3, r2
   12b7c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   12b80:	e1520003 	cmp	r2, r3
   12b84:	aa000003 	bge	12b98 <_svfprintf_r+0x2148>
   12b88:	e51b20a4 	ldr	r2, [fp, #-164]	; 0xa4
   12b8c:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   12b90:	e0633002 	rsb	r3, r3, r2
   12b94:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   12b98:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   12b9c:	e3530000 	cmp	r3, #0
   12ba0:	da000017 	ble	12c04 <_svfprintf_r+0x21b4>
   12ba4:	e5847000 	str	r7, [r4]
   12ba8:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   12bac:	e5843004 	str	r3, [r4, #4]
   12bb0:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   12bb4:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   12bb8:	e0823003 	add	r3, r2, r3
   12bbc:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12bc0:	e2844008 	add	r4, r4, #8
   12bc4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12bc8:	e2833001 	add	r3, r3, #1
   12bcc:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12bd0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12bd4:	e3530007 	cmp	r3, #7
   12bd8:	da000009 	ble	12c04 <_svfprintf_r+0x21b4>
   12bdc:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12be0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12be4:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12be8:	e1a02003 	mov	r2, r3
   12bec:	eb002d6a 	bl	1e19c <__ssprint_r>
   12bf0:	e1a03000 	mov	r3, r0
   12bf4:	e3530000 	cmp	r3, #0
   12bf8:	0a000000 	beq	12c00 <_svfprintf_r+0x21b0>
   12bfc:	ea000176 	b	131dc <_svfprintf_r+0x278c>
   12c00:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   12c04:	e51b20a4 	ldr	r2, [fp, #-164]	; 0xa4
   12c08:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   12c0c:	e0632002 	rsb	r2, r3, r2
   12c10:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   12c14:	e1c33fc3 	bic	r3, r3, r3, asr #31
   12c18:	e0633002 	rsb	r3, r3, r2
   12c1c:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   12c20:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   12c24:	e3530000 	cmp	r3, #0
   12c28:	da000038 	ble	12d10 <_svfprintf_r+0x22c0>
   12c2c:	ea00001a 	b	12c9c <_svfprintf_r+0x224c>
   12c30:	e51f3a68 	ldr	r3, [pc, #-2664]	; 121d0 <_svfprintf_r+0x1780>
   12c34:	e5843000 	str	r3, [r4]
   12c38:	e3a03010 	mov	r3, #16
   12c3c:	e5843004 	str	r3, [r4, #4]
   12c40:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   12c44:	e2833010 	add	r3, r3, #16
   12c48:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12c4c:	e2844008 	add	r4, r4, #8
   12c50:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12c54:	e2833001 	add	r3, r3, #1
   12c58:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12c5c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12c60:	e3530007 	cmp	r3, #7
   12c64:	da000009 	ble	12c90 <_svfprintf_r+0x2240>
   12c68:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12c6c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12c70:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12c74:	e1a02003 	mov	r2, r3
   12c78:	eb002d47 	bl	1e19c <__ssprint_r>
   12c7c:	e1a03000 	mov	r3, r0
   12c80:	e3530000 	cmp	r3, #0
   12c84:	0a000000 	beq	12c8c <_svfprintf_r+0x223c>
   12c88:	ea000153 	b	131dc <_svfprintf_r+0x278c>
   12c8c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   12c90:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   12c94:	e2433010 	sub	r3, r3, #16
   12c98:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   12c9c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   12ca0:	e3530010 	cmp	r3, #16
   12ca4:	caffffe1 	bgt	12c30 <_svfprintf_r+0x21e0>
   12ca8:	e51f3ae0 	ldr	r3, [pc, #-2784]	; 121d0 <_svfprintf_r+0x1780>
   12cac:	e5843000 	str	r3, [r4]
   12cb0:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   12cb4:	e5843004 	str	r3, [r4, #4]
   12cb8:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   12cbc:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   12cc0:	e0823003 	add	r3, r2, r3
   12cc4:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12cc8:	e2844008 	add	r4, r4, #8
   12ccc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12cd0:	e2833001 	add	r3, r3, #1
   12cd4:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12cd8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12cdc:	e3530007 	cmp	r3, #7
   12ce0:	da00000a 	ble	12d10 <_svfprintf_r+0x22c0>
   12ce4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12ce8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12cec:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12cf0:	e1a02003 	mov	r2, r3
   12cf4:	eb002d28 	bl	1e19c <__ssprint_r>
   12cf8:	e1a03000 	mov	r3, r0
   12cfc:	e3530000 	cmp	r3, #0
   12d00:	0a000000 	beq	12d08 <_svfprintf_r+0x22b8>
   12d04:	ea000134 	b	131dc <_svfprintf_r+0x278c>
   12d08:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   12d0c:	ea0000c7 	b	13030 <_svfprintf_r+0x25e0>
   12d10:	ea0000c6 	b	13030 <_svfprintf_r+0x25e0>
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
   12d14:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   12d18:	e3530001 	cmp	r3, #1
   12d1c:	ca000002 	bgt	12d2c <_svfprintf_r+0x22dc>
   12d20:	e2063001 	and	r3, r6, #1
   12d24:	e3530000 	cmp	r3, #0
   12d28:	0a000090 	beq	12f70 <_svfprintf_r+0x2520>
					PRINT (cp, 1);
   12d2c:	e5847000 	str	r7, [r4]
   12d30:	e3a03001 	mov	r3, #1
   12d34:	e5843004 	str	r3, [r4, #4]
   12d38:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   12d3c:	e2833001 	add	r3, r3, #1
   12d40:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12d44:	e2844008 	add	r4, r4, #8
   12d48:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12d4c:	e2833001 	add	r3, r3, #1
   12d50:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12d54:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12d58:	e3530007 	cmp	r3, #7
   12d5c:	da000009 	ble	12d88 <_svfprintf_r+0x2338>
   12d60:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12d64:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12d68:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12d6c:	e1a02003 	mov	r2, r3
   12d70:	eb002d09 	bl	1e19c <__ssprint_r>
   12d74:	e1a03000 	mov	r3, r0
   12d78:	e3530000 	cmp	r3, #0
   12d7c:	0a000000 	beq	12d84 <_svfprintf_r+0x2334>
   12d80:	ea000115 	b	131dc <_svfprintf_r+0x278c>
   12d84:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					cp++;
   12d88:	e2877001 	add	r7, r7, #1
					PRINT (decimal_point, decp_len);
   12d8c:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   12d90:	e5843000 	str	r3, [r4]
   12d94:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   12d98:	e5843004 	str	r3, [r4, #4]
   12d9c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   12da0:	e1a02003 	mov	r2, r3
   12da4:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   12da8:	e0823003 	add	r3, r2, r3
   12dac:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12db0:	e2844008 	add	r4, r4, #8
   12db4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12db8:	e2833001 	add	r3, r3, #1
   12dbc:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12dc0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12dc4:	e3530007 	cmp	r3, #7
   12dc8:	da000009 	ble	12df4 <_svfprintf_r+0x23a4>
   12dcc:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12dd0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12dd4:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12dd8:	e1a02003 	mov	r2, r3
   12ddc:	eb002cee 	bl	1e19c <__ssprint_r>
   12de0:	e1a03000 	mov	r3, r0
   12de4:	e3530000 	cmp	r3, #0
   12de8:	0a000000 	beq	12df0 <_svfprintf_r+0x23a0>
   12dec:	ea0000fa 	b	131dc <_svfprintf_r+0x278c>
   12df0:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					if (_fpvalue) {
   12df4:	e24b3094 	sub	r3, fp, #148	; 0x94
   12df8:	e893000c 	ldm	r3, {r2, r3}
   12dfc:	e1a00002 	mov	r0, r2
   12e00:	e1a01003 	mov	r1, r3
   12e04:	e3a02000 	mov	r2, #0
   12e08:	e3a03000 	mov	r3, #0
   12e0c:	eb003f77 	bl	22bf0 <__aeabi_dcmpeq>
   12e10:	e1a03000 	mov	r3, r0
   12e14:	e3530000 	cmp	r3, #0
   12e18:	1a00001a 	bne	12e88 <_svfprintf_r+0x2438>
						PRINT (cp, ndig - 1);
   12e1c:	e5847000 	str	r7, [r4]
   12e20:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   12e24:	e2433001 	sub	r3, r3, #1
   12e28:	e5843004 	str	r3, [r4, #4]
   12e2c:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   12e30:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   12e34:	e2433001 	sub	r3, r3, #1
   12e38:	e0823003 	add	r3, r2, r3
   12e3c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12e40:	e2844008 	add	r4, r4, #8
   12e44:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12e48:	e2833001 	add	r3, r3, #1
   12e4c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12e50:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12e54:	e3530007 	cmp	r3, #7
   12e58:	da000043 	ble	12f6c <_svfprintf_r+0x251c>
   12e5c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12e60:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12e64:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12e68:	e1a02003 	mov	r2, r3
   12e6c:	eb002cca 	bl	1e19c <__ssprint_r>
   12e70:	e1a03000 	mov	r3, r0
   12e74:	e3530000 	cmp	r3, #0
   12e78:	0a000000 	beq	12e80 <_svfprintf_r+0x2430>
   12e7c:	ea0000d6 	b	131dc <_svfprintf_r+0x278c>
   12e80:	e24b40f0 	sub	r4, fp, #240	; 0xf0
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
					cp++;
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
   12e84:	ea000050 	b	12fcc <_svfprintf_r+0x257c>
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
   12e88:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   12e8c:	e2435001 	sub	r5, r3, #1
   12e90:	e3550000 	cmp	r5, #0
   12e94:	da000034 	ble	12f6c <_svfprintf_r+0x251c>
   12e98:	ea000018 	b	12f00 <_svfprintf_r+0x24b0>
   12e9c:	e51f3cd4 	ldr	r3, [pc, #-3284]	; 121d0 <_svfprintf_r+0x1780>
   12ea0:	e5843000 	str	r3, [r4]
   12ea4:	e3a03010 	mov	r3, #16
   12ea8:	e5843004 	str	r3, [r4, #4]
   12eac:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   12eb0:	e2833010 	add	r3, r3, #16
   12eb4:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12eb8:	e2844008 	add	r4, r4, #8
   12ebc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12ec0:	e2833001 	add	r3, r3, #1
   12ec4:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12ec8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12ecc:	e3530007 	cmp	r3, #7
   12ed0:	da000009 	ble	12efc <_svfprintf_r+0x24ac>
   12ed4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12ed8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12edc:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12ee0:	e1a02003 	mov	r2, r3
   12ee4:	eb002cac 	bl	1e19c <__ssprint_r>
   12ee8:	e1a03000 	mov	r3, r0
   12eec:	e3530000 	cmp	r3, #0
   12ef0:	0a000000 	beq	12ef8 <_svfprintf_r+0x24a8>
   12ef4:	ea0000b8 	b	131dc <_svfprintf_r+0x278c>
   12ef8:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   12efc:	e2455010 	sub	r5, r5, #16
   12f00:	e3550010 	cmp	r5, #16
   12f04:	caffffe4 	bgt	12e9c <_svfprintf_r+0x244c>
   12f08:	e51f3d40 	ldr	r3, [pc, #-3392]	; 121d0 <_svfprintf_r+0x1780>
   12f0c:	e5843000 	str	r3, [r4]
   12f10:	e1a03005 	mov	r3, r5
   12f14:	e5843004 	str	r3, [r4, #4]
   12f18:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   12f1c:	e0833005 	add	r3, r3, r5
   12f20:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12f24:	e2844008 	add	r4, r4, #8
   12f28:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12f2c:	e2833001 	add	r3, r3, #1
   12f30:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12f34:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12f38:	e3530007 	cmp	r3, #7
   12f3c:	da00000a 	ble	12f6c <_svfprintf_r+0x251c>
   12f40:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12f44:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12f48:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12f4c:	e1a02003 	mov	r2, r3
   12f50:	eb002c91 	bl	1e19c <__ssprint_r>
   12f54:	e1a03000 	mov	r3, r0
   12f58:	e3530000 	cmp	r3, #0
   12f5c:	0a000000 	beq	12f64 <_svfprintf_r+0x2514>
   12f60:	ea00009d 	b	131dc <_svfprintf_r+0x278c>
   12f64:	e24b40f0 	sub	r4, fp, #240	; 0xf0
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
					cp++;
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
   12f68:	ea000017 	b	12fcc <_svfprintf_r+0x257c>
   12f6c:	ea000016 	b	12fcc <_svfprintf_r+0x257c>
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
				} else	/* XeYYY */
					PRINT (cp, 1);
   12f70:	e5847000 	str	r7, [r4]
   12f74:	e3a03001 	mov	r3, #1
   12f78:	e5843004 	str	r3, [r4, #4]
   12f7c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   12f80:	e2833001 	add	r3, r3, #1
   12f84:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12f88:	e2844008 	add	r4, r4, #8
   12f8c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12f90:	e2833001 	add	r3, r3, #1
   12f94:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12f98:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12f9c:	e3530007 	cmp	r3, #7
   12fa0:	da000009 	ble	12fcc <_svfprintf_r+0x257c>
   12fa4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   12fa8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   12fac:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   12fb0:	e1a02003 	mov	r2, r3
   12fb4:	eb002c78 	bl	1e19c <__ssprint_r>
   12fb8:	e1a03000 	mov	r3, r0
   12fbc:	e3530000 	cmp	r3, #0
   12fc0:	0a000000 	beq	12fc8 <_svfprintf_r+0x2578>
   12fc4:	ea000084 	b	131dc <_svfprintf_r+0x278c>
   12fc8:	e24b40f0 	sub	r4, fp, #240	; 0xf0
				PRINT (expstr, expsize);
   12fcc:	e24b30a0 	sub	r3, fp, #160	; 0xa0
   12fd0:	e5843000 	str	r3, [r4]
   12fd4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   12fd8:	e5843004 	str	r3, [r4, #4]
   12fdc:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   12fe0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   12fe4:	e0823003 	add	r3, r2, r3
   12fe8:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   12fec:	e2844008 	add	r4, r4, #8
   12ff0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   12ff4:	e2833001 	add	r3, r3, #1
   12ff8:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   12ffc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   13000:	e3530007 	cmp	r3, #7
   13004:	da000009 	ble	13030 <_svfprintf_r+0x25e0>
   13008:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1300c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   13010:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   13014:	e1a02003 	mov	r2, r3
   13018:	eb002c5f 	bl	1e19c <__ssprint_r>
   1301c:	e1a03000 	mov	r3, r0
   13020:	e3530000 	cmp	r3, #0
   13024:	0a000000 	beq	1302c <_svfprintf_r+0x25dc>
   13028:	ea00006b 	b	131dc <_svfprintf_r+0x278c>
   1302c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   13030:	e2063004 	and	r3, r6, #4
   13034:	e3530000 	cmp	r3, #0
   13038:	0a000038 	beq	13120 <_svfprintf_r+0x26d0>
			PAD (width - realsz, blanks);
   1303c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   13040:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   13044:	e0635002 	rsb	r5, r3, r2
   13048:	e3550000 	cmp	r5, #0
   1304c:	da000033 	ble	13120 <_svfprintf_r+0x26d0>
   13050:	ea000018 	b	130b8 <_svfprintf_r+0x2668>
   13054:	e51f3e88 	ldr	r3, [pc, #-3720]	; 121d4 <_svfprintf_r+0x1784>
   13058:	e5843000 	str	r3, [r4]
   1305c:	e3a03010 	mov	r3, #16
   13060:	e5843004 	str	r3, [r4, #4]
   13064:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   13068:	e2833010 	add	r3, r3, #16
   1306c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   13070:	e2844008 	add	r4, r4, #8
   13074:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   13078:	e2833001 	add	r3, r3, #1
   1307c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   13080:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   13084:	e3530007 	cmp	r3, #7
   13088:	da000009 	ble	130b4 <_svfprintf_r+0x2664>
   1308c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   13090:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   13094:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   13098:	e1a02003 	mov	r2, r3
   1309c:	eb002c3e 	bl	1e19c <__ssprint_r>
   130a0:	e1a03000 	mov	r3, r0
   130a4:	e3530000 	cmp	r3, #0
   130a8:	0a000000 	beq	130b0 <_svfprintf_r+0x2660>
   130ac:	ea00004a 	b	131dc <_svfprintf_r+0x278c>
   130b0:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   130b4:	e2455010 	sub	r5, r5, #16
   130b8:	e3550010 	cmp	r5, #16
   130bc:	caffffe4 	bgt	13054 <_svfprintf_r+0x2604>
   130c0:	e51f3ef4 	ldr	r3, [pc, #-3828]	; 121d4 <_svfprintf_r+0x1784>
   130c4:	e5843000 	str	r3, [r4]
   130c8:	e1a03005 	mov	r3, r5
   130cc:	e5843004 	str	r3, [r4, #4]
   130d0:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   130d4:	e0833005 	add	r3, r3, r5
   130d8:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   130dc:	e2844008 	add	r4, r4, #8
   130e0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   130e4:	e2833001 	add	r3, r3, #1
   130e8:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   130ec:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   130f0:	e3530007 	cmp	r3, #7
   130f4:	da000009 	ble	13120 <_svfprintf_r+0x26d0>
   130f8:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   130fc:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   13100:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   13104:	e1a02003 	mov	r2, r3
   13108:	eb002c23 	bl	1e19c <__ssprint_r>
   1310c:	e1a03000 	mov	r3, r0
   13110:	e3530000 	cmp	r3, #0
   13114:	0a000000 	beq	1311c <_svfprintf_r+0x26cc>
   13118:	ea00002f 	b	131dc <_svfprintf_r+0x278c>
   1311c:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   13120:	e51b2058 	ldr	r2, [fp, #-88]	; 0x58
   13124:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   13128:	e1520003 	cmp	r2, r3
   1312c:	a1a03002 	movge	r3, r2
   13130:	b1a03003 	movlt	r3, r3
   13134:	e51b2020 	ldr	r2, [fp, #-32]
   13138:	e0823003 	add	r3, r2, r3
   1313c:	e50b3020 	str	r3, [fp, #-32]

		FLUSH ();	/* copy out the I/O vectors */
   13140:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   13144:	e3530000 	cmp	r3, #0
   13148:	0a000008 	beq	13170 <_svfprintf_r+0x2720>
   1314c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   13150:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   13154:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   13158:	e1a02003 	mov	r2, r3
   1315c:	eb002c0e 	bl	1e19c <__ssprint_r>
   13160:	e1a03000 	mov	r3, r0
   13164:	e3530000 	cmp	r3, #0
   13168:	0a000000 	beq	13170 <_svfprintf_r+0x2720>
   1316c:	ea00001a 	b	131dc <_svfprintf_r+0x278c>
   13170:	e3a03000 	mov	r3, #0
   13174:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   13178:	e24b40f0 	sub	r4, fp, #240	; 0xf0

                if (malloc_buf != NULL) {
   1317c:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   13180:	e3530000 	cmp	r3, #0
   13184:	0a000004 	beq	1319c <_svfprintf_r+0x274c>
			_free_r (data, malloc_buf);
   13188:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1318c:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
   13190:	eb0019c1 	bl	1989c <_free_r>
			malloc_buf = NULL;
   13194:	e3a03000 	mov	r3, #0
   13198:	e50b3064 	str	r3, [fp, #-100]	; 0x64
		}
	}
   1319c:	eafff676 	b	10b7c <_svfprintf_r+0x12c>
done:
	FLUSH ();
   131a0:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   131a4:	e3530000 	cmp	r3, #0
   131a8:	0a000008 	beq	131d0 <_svfprintf_r+0x2780>
   131ac:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   131b0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   131b4:	e51b1164 	ldr	r1, [fp, #-356]	; 0x164
   131b8:	e1a02003 	mov	r2, r3
   131bc:	eb002bf6 	bl	1e19c <__ssprint_r>
   131c0:	e1a03000 	mov	r3, r0
   131c4:	e3530000 	cmp	r3, #0
   131c8:	0a000000 	beq	131d0 <_svfprintf_r+0x2780>
   131cc:	ea000002 	b	131dc <_svfprintf_r+0x278c>
   131d0:	e3a03000 	mov	r3, #0
   131d4:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   131d8:	e24b40f0 	sub	r4, fp, #240	; 0xf0
error:
	if (malloc_buf != NULL)
   131dc:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   131e0:	e3530000 	cmp	r3, #0
   131e4:	0a000002 	beq	131f4 <_svfprintf_r+0x27a4>
		_free_r (data, malloc_buf);
   131e8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   131ec:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
   131f0:	eb0019a9 	bl	1989c <_free_r>
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
   131f4:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   131f8:	e1d330bc 	ldrh	r3, [r3, #12]
   131fc:	e1a03803 	lsl	r3, r3, #16
   13200:	e1a03823 	lsr	r3, r3, #16
   13204:	e2033040 	and	r3, r3, #64	; 0x40
   13208:	e3530000 	cmp	r3, #0
   1320c:	1a000001 	bne	13218 <_svfprintf_r+0x27c8>
   13210:	e51b3020 	ldr	r3, [fp, #-32]
   13214:	ea000000 	b	1321c <_svfprintf_r+0x27cc>
   13218:	e3e03000 	mvn	r3, #0
   1321c:	e1a00000 	nop			; (mov r0, r0)
	/* NOTREACHED */
}
   13220:	e1a00003 	mov	r0, r3
   13224:	e24bd01c 	sub	sp, fp, #28
   13228:	e8bd4bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, lr}
   1322c:	e12fff1e 	bx	lr

00013230 <cvt>:
   [aAeEfFgG]; if it is [aA], then the return string lives in BUF,
   otherwise the return value shares the mprec reentrant storage.  */
static char *
cvt(struct _reent *data, _PRINTF_FLOAT_TYPE value, int ndigits, int flags,
    char *sign, int *decpt, int ch, int *length, char *buf)
{
   13230:	e92d4810 	push	{r4, fp, lr}
   13234:	e28db008 	add	fp, sp, #8
   13238:	e24dd04c 	sub	sp, sp, #76	; 0x4c
   1323c:	e50b0030 	str	r0, [fp, #-48]	; 0x30
   13240:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
   13244:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	int mode, dsgn;
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
   13248:	e24b403c 	sub	r4, fp, #60	; 0x3c
   1324c:	e8940018 	ldm	r4, {r3, r4}
   13250:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   13254:	e50b4028 	str	r4, [fp, #-40]	; 0x28
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   13258:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1325c:	e3530000 	cmp	r3, #0
   13260:	aa000008 	bge	13288 <cvt+0x58>
		value = -value;
   13264:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   13268:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   1326c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   13270:	e2233102 	eor	r3, r3, #-2147483648	; 0x80000000
   13274:	e50b3038 	str	r3, [fp, #-56]	; 0x38
		*sign = '-';
   13278:	e59b300c 	ldr	r3, [fp, #12]
   1327c:	e3a0202d 	mov	r2, #45	; 0x2d
   13280:	e5c32000 	strb	r2, [r3]
   13284:	ea000002 	b	13294 <cvt+0x64>
	} else
		*sign = '\000';
   13288:	e59b300c 	ldr	r3, [fp, #12]
   1328c:	e3a02000 	mov	r2, #0
   13290:	e5c32000 	strb	r2, [r3]
	} else
		*sign = '\000';
# endif /* !_NO_LONGDBL */

# ifdef _WANT_IO_C99_FORMATS
	if (ch == 'a' || ch == 'A') {
   13294:	e59b3014 	ldr	r3, [fp, #20]
   13298:	e3530061 	cmp	r3, #97	; 0x61
   1329c:	0a000002 	beq	132ac <cvt+0x7c>
   132a0:	e59b3014 	ldr	r3, [fp, #20]
   132a4:	e3530041 	cmp	r3, #65	; 0x41
   132a8:	1a000096 	bne	13508 <cvt+0x2d8>
		/* This code assumes FLT_RADIX is a power of 2.  The initial
		   division ensures the digit before the decimal will be less
		   than FLT_RADIX (unless it is rounded later).	 There is no
		   loss of precision in these calculations.  */
		value = FREXP (value, decpt) / 8;
   132ac:	e24b103c 	sub	r1, fp, #60	; 0x3c
   132b0:	e8910003 	ldm	r1, {r0, r1}
   132b4:	e59b2010 	ldr	r2, [fp, #16]
   132b8:	eb0029d6 	bl	1da18 <frexp>
   132bc:	e1a03000 	mov	r3, r0
   132c0:	e1a04001 	mov	r4, r1
   132c4:	e1a00003 	mov	r0, r3
   132c8:	e1a01004 	mov	r1, r4
   132cc:	e3a02000 	mov	r2, #0
   132d0:	e59f33dc 	ldr	r3, [pc, #988]	; 136b4 <cvt+0x484>
   132d4:	eb003d8f 	bl	22918 <__aeabi_ddiv>
   132d8:	e1a03000 	mov	r3, r0
   132dc:	e1a04001 	mov	r4, r1
   132e0:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   132e4:	e50b4038 	str	r4, [fp, #-56]	; 0x38
		if (!value)
   132e8:	e24b103c 	sub	r1, fp, #60	; 0x3c
   132ec:	e8910003 	ldm	r1, {r0, r1}
   132f0:	e3a02000 	mov	r2, #0
   132f4:	e3a03000 	mov	r3, #0
   132f8:	eb003e3c 	bl	22bf0 <__aeabi_dcmpeq>
   132fc:	e1a03000 	mov	r3, r0
   13300:	e3530000 	cmp	r3, #0
   13304:	0a000002 	beq	13314 <cvt+0xe4>
			*decpt = 1;
   13308:	e59b3010 	ldr	r3, [fp, #16]
   1330c:	e3a02001 	mov	r2, #1
   13310:	e5832000 	str	r2, [r3]
		digits = ch == 'a' ? "0123456789abcdef" : "0123456789ABCDEF";
   13314:	e59b3014 	ldr	r3, [fp, #20]
   13318:	e3530061 	cmp	r3, #97	; 0x61
   1331c:	1a000001 	bne	13328 <cvt+0xf8>
   13320:	e59f3390 	ldr	r3, [pc, #912]	; 136b8 <cvt+0x488>
   13324:	ea000000 	b	1332c <cvt+0xfc>
   13328:	e59f338c 	ldr	r3, [pc, #908]	; 136bc <cvt+0x48c>
   1332c:	e50b3018 	str	r3, [fp, #-24]
		bp = buf;
   13330:	e59b301c 	ldr	r3, [fp, #28]
   13334:	e50b3014 	str	r3, [fp, #-20]
		do {
			value *= 16;
   13338:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1333c:	e8910003 	ldm	r1, {r0, r1}
   13340:	e3a02000 	mov	r2, #0
   13344:	e59f3374 	ldr	r3, [pc, #884]	; 136c0 <cvt+0x490>
   13348:	eb003cce 	bl	22688 <__aeabi_dmul>
   1334c:	e1a03000 	mov	r3, r0
   13350:	e1a04001 	mov	r4, r1
   13354:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   13358:	e50b4038 	str	r4, [fp, #-56]	; 0x38
			mode = (int) value;
   1335c:	e24b103c 	sub	r1, fp, #60	; 0x3c
   13360:	e8910003 	ldm	r1, {r0, r1}
   13364:	eb003e3f 	bl	22c68 <__aeabi_d2iz>
   13368:	e1a03000 	mov	r3, r0
   1336c:	e50b3010 	str	r3, [fp, #-16]
			value -= mode;
   13370:	e51b0010 	ldr	r0, [fp, #-16]
   13374:	eb003c8c 	bl	225ac <__aeabi_i2d>
   13378:	e1a03000 	mov	r3, r0
   1337c:	e1a04001 	mov	r4, r1
   13380:	e24b103c 	sub	r1, fp, #60	; 0x3c
   13384:	e8910003 	ldm	r1, {r0, r1}
   13388:	e1a02003 	mov	r2, r3
   1338c:	e1a03004 	mov	r3, r4
   13390:	eb003bb7 	bl	22274 <__aeabi_dsub>
   13394:	e1a03000 	mov	r3, r0
   13398:	e1a04001 	mov	r4, r1
   1339c:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   133a0:	e50b4038 	str	r4, [fp, #-56]	; 0x38
			*bp++ = digits[mode];
   133a4:	e51b3014 	ldr	r3, [fp, #-20]
   133a8:	e2832001 	add	r2, r3, #1
   133ac:	e50b2014 	str	r2, [fp, #-20]
   133b0:	e51b2010 	ldr	r2, [fp, #-16]
   133b4:	e51b1018 	ldr	r1, [fp, #-24]
   133b8:	e0812002 	add	r2, r1, r2
   133bc:	e5d22000 	ldrb	r2, [r2]
   133c0:	e5c32000 	strb	r2, [r3]
		} while (ndigits-- && value);
   133c4:	e59b3004 	ldr	r3, [fp, #4]
   133c8:	e2432001 	sub	r2, r3, #1
   133cc:	e58b2004 	str	r2, [fp, #4]
   133d0:	e3530000 	cmp	r3, #0
   133d4:	0a000007 	beq	133f8 <cvt+0x1c8>
   133d8:	e24b103c 	sub	r1, fp, #60	; 0x3c
   133dc:	e8910003 	ldm	r1, {r0, r1}
   133e0:	e3a02000 	mov	r2, #0
   133e4:	e3a03000 	mov	r3, #0
   133e8:	eb003e00 	bl	22bf0 <__aeabi_dcmpeq>
   133ec:	e1a03000 	mov	r3, r0
   133f0:	e3530000 	cmp	r3, #0
   133f4:	0affffcf 	beq	13338 <cvt+0x108>
		if (value > 0.5 || (value == 0.5 && mode & 1)) {
   133f8:	e24b103c 	sub	r1, fp, #60	; 0x3c
   133fc:	e8910003 	ldm	r1, {r0, r1}
   13400:	e3a02000 	mov	r2, #0
   13404:	e59f32b8 	ldr	r3, [pc, #696]	; 136c4 <cvt+0x494>
   13408:	eb003e10 	bl	22c50 <__aeabi_dcmpgt>
   1340c:	e1a03000 	mov	r3, r0
   13410:	e3530000 	cmp	r3, #0
   13414:	1a00000b 	bne	13448 <cvt+0x218>
   13418:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1341c:	e8910003 	ldm	r1, {r0, r1}
   13420:	e3a02000 	mov	r2, #0
   13424:	e59f3298 	ldr	r3, [pc, #664]	; 136c4 <cvt+0x494>
   13428:	eb003df0 	bl	22bf0 <__aeabi_dcmpeq>
   1342c:	e1a03000 	mov	r3, r0
   13430:	e3530000 	cmp	r3, #0
   13434:	0a000021 	beq	134c0 <cvt+0x290>
   13438:	e51b3010 	ldr	r3, [fp, #-16]
   1343c:	e2033001 	and	r3, r3, #1
   13440:	e3530000 	cmp	r3, #0
   13444:	0a00001d 	beq	134c0 <cvt+0x290>
			/* round to even */
			rve = bp;
   13448:	e51b3014 	ldr	r3, [fp, #-20]
   1344c:	e50b3020 	str	r3, [fp, #-32]
			while (*--rve == digits[0xf]) {
   13450:	ea000002 	b	13460 <cvt+0x230>
				*rve = '0';
   13454:	e51b3020 	ldr	r3, [fp, #-32]
   13458:	e3a02030 	mov	r2, #48	; 0x30
   1345c:	e5c32000 	strb	r2, [r3]
			*bp++ = digits[mode];
		} while (ndigits-- && value);
		if (value > 0.5 || (value == 0.5 && mode & 1)) {
			/* round to even */
			rve = bp;
			while (*--rve == digits[0xf]) {
   13460:	e51b3020 	ldr	r3, [fp, #-32]
   13464:	e2433001 	sub	r3, r3, #1
   13468:	e50b3020 	str	r3, [fp, #-32]
   1346c:	e51b3020 	ldr	r3, [fp, #-32]
   13470:	e5d32000 	ldrb	r2, [r3]
   13474:	e51b3018 	ldr	r3, [fp, #-24]
   13478:	e283300f 	add	r3, r3, #15
   1347c:	e5d33000 	ldrb	r3, [r3]
   13480:	e1520003 	cmp	r2, r3
   13484:	0afffff2 	beq	13454 <cvt+0x224>
				*rve = '0';
			}
			*rve = *rve == '9' ? digits[0xa] : *rve + 1;
   13488:	e51b2020 	ldr	r2, [fp, #-32]
   1348c:	e51b3020 	ldr	r3, [fp, #-32]
   13490:	e5d33000 	ldrb	r3, [r3]
   13494:	e3530039 	cmp	r3, #57	; 0x39
   13498:	1a000002 	bne	134a8 <cvt+0x278>
   1349c:	e51b3018 	ldr	r3, [fp, #-24]
   134a0:	e5d3300a 	ldrb	r3, [r3, #10]
   134a4:	ea000003 	b	134b8 <cvt+0x288>
   134a8:	e51b3020 	ldr	r3, [fp, #-32]
   134ac:	e5d33000 	ldrb	r3, [r3]
   134b0:	e2833001 	add	r3, r3, #1
   134b4:	e20330ff 	and	r3, r3, #255	; 0xff
   134b8:	e5c23000 	strb	r3, [r2]
   134bc:	ea00000a 	b	134ec <cvt+0x2bc>
		} else {
			while (ndigits-- >= 0) {
   134c0:	ea000004 	b	134d8 <cvt+0x2a8>
				*bp++ = '0';
   134c4:	e51b3014 	ldr	r3, [fp, #-20]
   134c8:	e2832001 	add	r2, r3, #1
   134cc:	e50b2014 	str	r2, [fp, #-20]
   134d0:	e3a02030 	mov	r2, #48	; 0x30
   134d4:	e5c32000 	strb	r2, [r3]
			while (*--rve == digits[0xf]) {
				*rve = '0';
			}
			*rve = *rve == '9' ? digits[0xa] : *rve + 1;
		} else {
			while (ndigits-- >= 0) {
   134d8:	e59b3004 	ldr	r3, [fp, #4]
   134dc:	e2432001 	sub	r2, r3, #1
   134e0:	e58b2004 	str	r2, [fp, #4]
   134e4:	e3530000 	cmp	r3, #0
   134e8:	aafffff5 	bge	134c4 <cvt+0x294>
				*bp++ = '0';
			}
		}
		*length = bp - buf;
   134ec:	e51b2014 	ldr	r2, [fp, #-20]
   134f0:	e59b301c 	ldr	r3, [fp, #28]
   134f4:	e0632002 	rsb	r2, r3, r2
   134f8:	e59b3018 	ldr	r3, [fp, #24]
   134fc:	e5832000 	str	r2, [r3]
		return buf;
   13500:	e59b301c 	ldr	r3, [fp, #28]
   13504:	ea000066 	b	136a4 <cvt+0x474>
	}
# endif /* _WANT_IO_C99_FORMATS */
	if (ch == 'f' || ch == 'F') {
   13508:	e59b3014 	ldr	r3, [fp, #20]
   1350c:	e3530066 	cmp	r3, #102	; 0x66
   13510:	0a000002 	beq	13520 <cvt+0x2f0>
   13514:	e59b3014 	ldr	r3, [fp, #20]
   13518:	e3530046 	cmp	r3, #70	; 0x46
   1351c:	1a000002 	bne	1352c <cvt+0x2fc>
		mode = 3;		/* ndigits after the decimal point */
   13520:	e3a03003 	mov	r3, #3
   13524:	e50b3010 	str	r3, [fp, #-16]
   13528:	ea00000a 	b	13558 <cvt+0x328>
	} else {
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
   1352c:	e59b3014 	ldr	r3, [fp, #20]
   13530:	e3530065 	cmp	r3, #101	; 0x65
   13534:	0a000002 	beq	13544 <cvt+0x314>
   13538:	e59b3014 	ldr	r3, [fp, #20]
   1353c:	e3530045 	cmp	r3, #69	; 0x45
   13540:	1a000002 	bne	13550 <cvt+0x320>
			ndigits++;
   13544:	e59b3004 	ldr	r3, [fp, #4]
   13548:	e2833001 	add	r3, r3, #1
   1354c:	e58b3004 	str	r3, [fp, #4]
		}
		mode = 2;		/* ndigits significant digits */
   13550:	e3a03002 	mov	r3, #2
   13554:	e50b3010 	str	r3, [fp, #-16]
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   13558:	e51b3010 	ldr	r3, [fp, #-16]
   1355c:	e58d3000 	str	r3, [sp]
   13560:	e59b3004 	ldr	r3, [fp, #4]
   13564:	e58d3004 	str	r3, [sp, #4]
   13568:	e59b3010 	ldr	r3, [fp, #16]
   1356c:	e58d3008 	str	r3, [sp, #8]
   13570:	e24b301c 	sub	r3, fp, #28
   13574:	e58d300c 	str	r3, [sp, #12]
   13578:	e24b3020 	sub	r3, fp, #32
   1357c:	e58d3010 	str	r3, [sp, #16]
   13580:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   13584:	e24b303c 	sub	r3, fp, #60	; 0x3c
   13588:	e893000c 	ldm	r3, {r2, r3}
   1358c:	eb000ee7 	bl	17130 <_dtoa_r>
   13590:	e50b0018 	str	r0, [fp, #-24]

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   13594:	e59b3014 	ldr	r3, [fp, #20]
   13598:	e3530067 	cmp	r3, #103	; 0x67
   1359c:	0a000002 	beq	135ac <cvt+0x37c>
   135a0:	e59b3014 	ldr	r3, [fp, #20]
   135a4:	e3530047 	cmp	r3, #71	; 0x47
   135a8:	1a000003 	bne	135bc <cvt+0x38c>
   135ac:	e59b3008 	ldr	r3, [fp, #8]
   135b0:	e2033001 	and	r3, r3, #1
   135b4:	e3530000 	cmp	r3, #0
   135b8:	0a000032 	beq	13688 <cvt+0x458>
		bp = digits + ndigits;
   135bc:	e59b3004 	ldr	r3, [fp, #4]
   135c0:	e51b2018 	ldr	r2, [fp, #-24]
   135c4:	e0823003 	add	r3, r2, r3
   135c8:	e50b3014 	str	r3, [fp, #-20]
		if (ch == 'f' || ch == 'F') {
   135cc:	e59b3014 	ldr	r3, [fp, #20]
   135d0:	e3530066 	cmp	r3, #102	; 0x66
   135d4:	0a000002 	beq	135e4 <cvt+0x3b4>
   135d8:	e59b3014 	ldr	r3, [fp, #20]
   135dc:	e3530046 	cmp	r3, #70	; 0x46
   135e0:	1a000014 	bne	13638 <cvt+0x408>
			if (*digits == '0' && value)
   135e4:	e51b3018 	ldr	r3, [fp, #-24]
   135e8:	e5d33000 	ldrb	r3, [r3]
   135ec:	e3530030 	cmp	r3, #48	; 0x30
   135f0:	1a00000b 	bne	13624 <cvt+0x3f4>
   135f4:	e24b103c 	sub	r1, fp, #60	; 0x3c
   135f8:	e8910003 	ldm	r1, {r0, r1}
   135fc:	e3a02000 	mov	r2, #0
   13600:	e3a03000 	mov	r3, #0
   13604:	eb003d79 	bl	22bf0 <__aeabi_dcmpeq>
   13608:	e1a03000 	mov	r3, r0
   1360c:	e3530000 	cmp	r3, #0
   13610:	1a000003 	bne	13624 <cvt+0x3f4>
				*decpt = -ndigits + 1;
   13614:	e59b3004 	ldr	r3, [fp, #4]
   13618:	e2632001 	rsb	r2, r3, #1
   1361c:	e59b3010 	ldr	r3, [fp, #16]
   13620:	e5832000 	str	r2, [r3]
			bp += *decpt;
   13624:	e59b3010 	ldr	r3, [fp, #16]
   13628:	e5933000 	ldr	r3, [r3]
   1362c:	e51b2014 	ldr	r2, [fp, #-20]
   13630:	e0823003 	add	r3, r2, r3
   13634:	e50b3014 	str	r3, [fp, #-20]
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
   13638:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1363c:	e8910003 	ldm	r1, {r0, r1}
   13640:	e3a02000 	mov	r2, #0
   13644:	e3a03000 	mov	r3, #0
   13648:	eb003d68 	bl	22bf0 <__aeabi_dcmpeq>
   1364c:	e1a03000 	mov	r3, r0
   13650:	e3530000 	cmp	r3, #0
   13654:	0a000001 	beq	13660 <cvt+0x430>
			rve = bp;
   13658:	e51b3014 	ldr	r3, [fp, #-20]
   1365c:	e50b3020 	str	r3, [fp, #-32]
		while (rve < bp)
   13660:	ea000004 	b	13678 <cvt+0x448>
			*rve++ = '0';
   13664:	e51b3020 	ldr	r3, [fp, #-32]
   13668:	e2832001 	add	r2, r3, #1
   1366c:	e50b2020 	str	r2, [fp, #-32]
   13670:	e3a02030 	mov	r2, #48	; 0x30
   13674:	e5c32000 	strb	r2, [r3]
				*decpt = -ndigits + 1;
			bp += *decpt;
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
   13678:	e51b2020 	ldr	r2, [fp, #-32]
   1367c:	e51b3014 	ldr	r3, [fp, #-20]
   13680:	e1520003 	cmp	r2, r3
   13684:	3afffff6 	bcc	13664 <cvt+0x434>
			*rve++ = '0';
	}
	*length = rve - digits;
   13688:	e51b3020 	ldr	r3, [fp, #-32]
   1368c:	e1a02003 	mov	r2, r3
   13690:	e51b3018 	ldr	r3, [fp, #-24]
   13694:	e0632002 	rsb	r2, r3, r2
   13698:	e59b3018 	ldr	r3, [fp, #24]
   1369c:	e5832000 	str	r2, [r3]
	return (digits);
   136a0:	e51b3018 	ldr	r3, [fp, #-24]
}
   136a4:	e1a00003 	mov	r0, r3
   136a8:	e24bd008 	sub	sp, fp, #8
   136ac:	e8bd4810 	pop	{r4, fp, lr}
   136b0:	e12fff1e 	bx	lr
   136b4:	40200000 	.word	0x40200000
   136b8:	00024704 	.word	0x00024704
   136bc:	00024720 	.word	0x00024720
   136c0:	40300000 	.word	0x40300000
   136c4:	3fe00000 	.word	0x3fe00000

000136c8 <exponent>:

static int
exponent(char *p0, int exp, int fmtch)
{
   136c8:	e92d0830 	push	{r4, r5, fp}
   136cc:	e28db008 	add	fp, sp, #8
   136d0:	e24dd024 	sub	sp, sp, #36	; 0x24
   136d4:	e50b0020 	str	r0, [fp, #-32]
   136d8:	e50b1024 	str	r1, [fp, #-36]	; 0x24
   136dc:	e50b2028 	str	r2, [fp, #-40]	; 0x28
	register char *p, *t;
	char expbuf[MAXEXPLEN];
# ifdef _WANT_IO_C99_FORMATS
	int isa = fmtch == 'a' || fmtch == 'A';
   136e0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   136e4:	e3530061 	cmp	r3, #97	; 0x61
   136e8:	0a000002 	beq	136f8 <exponent+0x30>
   136ec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   136f0:	e3530041 	cmp	r3, #65	; 0x41
   136f4:	1a000001 	bne	13700 <exponent+0x38>
   136f8:	e3a03001 	mov	r3, #1
   136fc:	ea000000 	b	13704 <exponent+0x3c>
   13700:	e3a03000 	mov	r3, #0
   13704:	e50b3010 	str	r3, [fp, #-16]
# else
#  define isa 0
# endif

	p = p0;
   13708:	e51b4020 	ldr	r4, [fp, #-32]
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   1370c:	e1a03004 	mov	r3, r4
   13710:	e2834001 	add	r4, r3, #1
   13714:	e51b2010 	ldr	r2, [fp, #-16]
   13718:	e3520000 	cmp	r2, #0
   1371c:	0a000004 	beq	13734 <exponent+0x6c>
   13720:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   13724:	e20220ff 	and	r2, r2, #255	; 0xff
   13728:	e282200f 	add	r2, r2, #15
   1372c:	e20220ff 	and	r2, r2, #255	; 0xff
   13730:	ea000001 	b	1373c <exponent+0x74>
   13734:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   13738:	e20220ff 	and	r2, r2, #255	; 0xff
   1373c:	e5c32000 	strb	r2, [r3]
	if (exp < 0) {
   13740:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   13744:	e3530000 	cmp	r3, #0
   13748:	aa000007 	bge	1376c <exponent+0xa4>
		exp = -exp;
   1374c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   13750:	e2633000 	rsb	r3, r3, #0
   13754:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		*p++ = '-';
   13758:	e1a03004 	mov	r3, r4
   1375c:	e2834001 	add	r4, r3, #1
   13760:	e3a0202d 	mov	r2, #45	; 0x2d
   13764:	e5c32000 	strb	r2, [r3]
   13768:	ea000003 	b	1377c <exponent+0xb4>
	}
	else
		*p++ = '+';
   1376c:	e1a03004 	mov	r3, r4
   13770:	e2834001 	add	r4, r3, #1
   13774:	e3a0202b 	mov	r2, #43	; 0x2b
   13778:	e5c32000 	strb	r2, [r3]
	t = expbuf + MAXEXPLEN;
   1377c:	e24b5018 	sub	r5, fp, #24
   13780:	e2855007 	add	r5, r5, #7
	if (exp > 9) {
   13784:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   13788:	e3530009 	cmp	r3, #9
   1378c:	da00002b 	ble	13840 <exponent+0x178>
		do {
			*--t = to_char (exp % 10);
   13790:	e2455001 	sub	r5, r5, #1
   13794:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
   13798:	e59f30f4 	ldr	r3, [pc, #244]	; 13894 <exponent+0x1cc>
   1379c:	e0c32391 	smull	r2, r3, r1, r3
   137a0:	e1a02143 	asr	r2, r3, #2
   137a4:	e1a03fc1 	asr	r3, r1, #31
   137a8:	e0632002 	rsb	r2, r3, r2
   137ac:	e1a03002 	mov	r3, r2
   137b0:	e1a03103 	lsl	r3, r3, #2
   137b4:	e0833002 	add	r3, r3, r2
   137b8:	e1a03083 	lsl	r3, r3, #1
   137bc:	e0632001 	rsb	r2, r3, r1
   137c0:	e20230ff 	and	r3, r2, #255	; 0xff
   137c4:	e2833030 	add	r3, r3, #48	; 0x30
   137c8:	e20330ff 	and	r3, r3, #255	; 0xff
   137cc:	e5c53000 	strb	r3, [r5]
		} while ((exp /= 10) > 9);
   137d0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   137d4:	e59f20b8 	ldr	r2, [pc, #184]	; 13894 <exponent+0x1cc>
   137d8:	e0c21293 	smull	r1, r2, r3, r2
   137dc:	e1a02142 	asr	r2, r2, #2
   137e0:	e1a03fc3 	asr	r3, r3, #31
   137e4:	e0633002 	rsb	r3, r3, r2
   137e8:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   137ec:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   137f0:	e3530009 	cmp	r3, #9
   137f4:	caffffe5 	bgt	13790 <exponent+0xc8>
		*--t = to_char (exp);
   137f8:	e2455001 	sub	r5, r5, #1
   137fc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   13800:	e20330ff 	and	r3, r3, #255	; 0xff
   13804:	e2833030 	add	r3, r3, #48	; 0x30
   13808:	e20330ff 	and	r3, r3, #255	; 0xff
   1380c:	e5c53000 	strb	r3, [r5]
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
   13810:	ea000005 	b	1382c <exponent+0x164>
   13814:	e1a03004 	mov	r3, r4
   13818:	e2834001 	add	r4, r3, #1
   1381c:	e1a02005 	mov	r2, r5
   13820:	e2825001 	add	r5, r2, #1
   13824:	e5d22000 	ldrb	r2, [r2]
   13828:	e5c32000 	strb	r2, [r3]
   1382c:	e24b3018 	sub	r3, fp, #24
   13830:	e2833007 	add	r3, r3, #7
   13834:	e1550003 	cmp	r5, r3
   13838:	3afffff5 	bcc	13814 <exponent+0x14c>
   1383c:	ea00000d 	b	13878 <exponent+0x1b0>
	}
	else {
		if (!isa)
   13840:	e51b3010 	ldr	r3, [fp, #-16]
   13844:	e3530000 	cmp	r3, #0
   13848:	1a000003 	bne	1385c <exponent+0x194>
			*p++ = '0';
   1384c:	e1a03004 	mov	r3, r4
   13850:	e2834001 	add	r4, r3, #1
   13854:	e3a02030 	mov	r2, #48	; 0x30
   13858:	e5c32000 	strb	r2, [r3]
		*p++ = to_char (exp);
   1385c:	e1a03004 	mov	r3, r4
   13860:	e2834001 	add	r4, r3, #1
   13864:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   13868:	e20220ff 	and	r2, r2, #255	; 0xff
   1386c:	e2822030 	add	r2, r2, #48	; 0x30
   13870:	e20220ff 	and	r2, r2, #255	; 0xff
   13874:	e5c32000 	strb	r2, [r3]
	}
	return (p - p0);
   13878:	e1a02004 	mov	r2, r4
   1387c:	e51b3020 	ldr	r3, [fp, #-32]
   13880:	e0633002 	rsb	r3, r3, r2
}
   13884:	e1a00003 	mov	r0, r3
   13888:	e24bd008 	sub	sp, fp, #8
   1388c:	e8bd0830 	pop	{r4, r5, fp}
   13890:	e12fff1e 	bx	lr
   13894:	66666667 	.word	0x66666667

00013898 <__sbprintf>:
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   13898:	e92d4810 	push	{r4, fp, lr}
   1389c:	e28db008 	add	fp, sp, #8
   138a0:	e24ddd12 	sub	sp, sp, #1152	; 0x480
   138a4:	e24dd00c 	sub	sp, sp, #12
   138a8:	e50b0488 	str	r0, [fp, #-1160]	; 0x488
   138ac:	e1a04001 	mov	r4, r1
   138b0:	e50b248c 	str	r2, [fp, #-1164]	; 0x48c
   138b4:	e50b3490 	str	r3, [fp, #-1168]	; 0x490
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   138b8:	e1d430bc 	ldrh	r3, [r4, #12]
   138bc:	e3c33002 	bic	r3, r3, #2
   138c0:	e1a03803 	lsl	r3, r3, #16
   138c4:	e1a03823 	lsr	r3, r3, #16
   138c8:	e14b37b8 	strh	r3, [fp, #-120]	; 0xffffff88
	fake._flags2 = fp->_flags2;
   138cc:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
   138d0:	e50b3018 	str	r3, [fp, #-24]
	fake._file = fp->_file;
   138d4:	e1d430be 	ldrh	r3, [r4, #14]
   138d8:	e14b37b6 	strh	r3, [fp, #-118]	; 0xffffff8a
	fake._cookie = fp->_cookie;
   138dc:	e594301c 	ldr	r3, [r4, #28]
   138e0:	e50b3068 	str	r3, [fp, #-104]	; 0x68
	fake._write = fp->_write;
   138e4:	e5943024 	ldr	r3, [r4, #36]	; 0x24
   138e8:	e50b3060 	str	r3, [fp, #-96]	; 0x60

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   138ec:	e24b3e47 	sub	r3, fp, #1136	; 0x470
   138f0:	e243300c 	sub	r3, r3, #12
   138f4:	e2433008 	sub	r3, r3, #8
   138f8:	e50b3084 	str	r3, [fp, #-132]	; 0x84
   138fc:	e51b3084 	ldr	r3, [fp, #-132]	; 0x84
   13900:	e50b3074 	str	r3, [fp, #-116]	; 0x74
	fake._bf._size = fake._w = sizeof (buf);
   13904:	e3a03b01 	mov	r3, #1024	; 0x400
   13908:	e50b307c 	str	r3, [fp, #-124]	; 0x7c
   1390c:	e51b307c 	ldr	r3, [fp, #-124]	; 0x7c
   13910:	e50b3070 	str	r3, [fp, #-112]	; 0x70
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
   13914:	e3a03000 	mov	r3, #0
   13918:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
   1391c:	e24b3084 	sub	r3, fp, #132	; 0x84
   13920:	e283305c 	add	r3, r3, #92	; 0x5c
   13924:	e1a00003 	mov	r0, r3
   13928:	ebffebe3 	bl	e8bc <_dna_lock_init>
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   1392c:	e24b3084 	sub	r3, fp, #132	; 0x84
   13930:	e51b0488 	ldr	r0, [fp, #-1160]	; 0x488
   13934:	e1a01003 	mov	r1, r3
   13938:	e51b248c 	ldr	r2, [fp, #-1164]	; 0x48c
   1393c:	e51b3490 	ldr	r3, [fp, #-1168]	; 0x490
   13940:	eb000034 	bl	13a18 <_vfprintf_r>
   13944:	e50b0010 	str	r0, [fp, #-16]
	if (ret >= 0 && _fflush_r (rptr, &fake))
   13948:	e51b3010 	ldr	r3, [fp, #-16]
   1394c:	e3530000 	cmp	r3, #0
   13950:	ba000008 	blt	13978 <__sbprintf+0xe0>
   13954:	e24b3084 	sub	r3, fp, #132	; 0x84
   13958:	e51b0488 	ldr	r0, [fp, #-1160]	; 0x488
   1395c:	e1a01003 	mov	r1, r3
   13960:	eb0015eb 	bl	19114 <_fflush_r>
   13964:	e1a03000 	mov	r3, r0
   13968:	e3530000 	cmp	r3, #0
   1396c:	0a000001 	beq	13978 <__sbprintf+0xe0>
		ret = EOF;
   13970:	e3e03000 	mvn	r3, #0
   13974:	e50b3010 	str	r3, [fp, #-16]
	if (fake._flags & __SERR)
   13978:	e15b37b8 	ldrh	r3, [fp, #-120]	; 0xffffff88
   1397c:	e1a03803 	lsl	r3, r3, #16
   13980:	e1a03823 	lsr	r3, r3, #16
   13984:	e2033040 	and	r3, r3, #64	; 0x40
   13988:	e3530000 	cmp	r3, #0
   1398c:	0a000004 	beq	139a4 <__sbprintf+0x10c>
		fp->_flags |= __SERR;
   13990:	e1d430bc 	ldrh	r3, [r4, #12]
   13994:	e3833040 	orr	r3, r3, #64	; 0x40
   13998:	e1a03803 	lsl	r3, r3, #16
   1399c:	e1a03823 	lsr	r3, r3, #16
   139a0:	e1c430bc 	strh	r3, [r4, #12]

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
   139a4:	e24b3084 	sub	r3, fp, #132	; 0x84
   139a8:	e283305c 	add	r3, r3, #92	; 0x5c
   139ac:	e1a00003 	mov	r0, r3
   139b0:	ebffebed 	bl	e96c <_dna_lock_close>
#endif
	return (ret);
   139b4:	e51b3010 	ldr	r3, [fp, #-16]
}
   139b8:	e1a00003 	mov	r0, r3
   139bc:	e24bd008 	sub	sp, fp, #8
   139c0:	e8bd4810 	pop	{r4, fp, lr}
   139c4:	e12fff1e 	bx	lr

000139c8 <vfprintf>:
int
_DEFUN(VFPRINTF, (fp, fmt0, ap),
       FILE * fp         _AND
       _CONST char *fmt0 _AND
       va_list ap)
{
   139c8:	e92d4800 	push	{fp, lr}
   139cc:	e28db004 	add	fp, sp, #4
   139d0:	e24dd018 	sub	sp, sp, #24
   139d4:	e50b0010 	str	r0, [fp, #-16]
   139d8:	e50b1014 	str	r1, [fp, #-20]
   139dc:	e50b2018 	str	r2, [fp, #-24]
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   139e0:	e59f302c 	ldr	r3, [pc, #44]	; 13a14 <vfprintf+0x4c>
   139e4:	e5933000 	ldr	r3, [r3]
   139e8:	e1a00003 	mov	r0, r3
   139ec:	e51b1010 	ldr	r1, [fp, #-16]
   139f0:	e51b2014 	ldr	r2, [fp, #-20]
   139f4:	e51b3018 	ldr	r3, [fp, #-24]
   139f8:	eb000006 	bl	13a18 <_vfprintf_r>
   139fc:	e50b0008 	str	r0, [fp, #-8]
  return result;
   13a00:	e51b3008 	ldr	r3, [fp, #-8]
}
   13a04:	e1a00003 	mov	r0, r3
   13a08:	e24bd004 	sub	sp, fp, #4
   13a0c:	e8bd4800 	pop	{fp, lr}
   13a10:	e12fff1e 	bx	lr
   13a14:	00025440 	.word	0x00025440

00013a18 <_vfprintf_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
   13a18:	e92d4bf0 	push	{r4, r5, r6, r7, r8, r9, fp, lr}
   13a1c:	e28db01c 	add	fp, sp, #28
   13a20:	e24ddd06 	sub	sp, sp, #384	; 0x180
   13a24:	e50b0160 	str	r0, [fp, #-352]	; 0x160
   13a28:	e50b1164 	str	r1, [fp, #-356]	; 0x164
   13a2c:	e50b2168 	str	r2, [fp, #-360]	; 0x168
   13a30:	e50b316c 	str	r3, [fp, #-364]	; 0x16c
	int width;		/* width from format (%8d), or 0 */
	int prec;		/* precision from format (%.3d), or -1 */
	char sign;		/* sign prefix (' ', '+', '-', or \0) */
#ifdef _WANT_IO_C99_FORMATS
				/* locale specific numeric grouping */
	char *thousands_sep = NULL;
   13a34:	e3a03000 	mov	r3, #0
   13a38:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	size_t thsnd_len = 0;
   13a3c:	e3a03000 	mov	r3, #0
   13a40:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	const char *grouping = NULL;
   13a44:	e3a03000 	mov	r3, #0
   13a48:	e50b3034 	str	r3, [fp, #-52]	; 0x34
#endif
#ifdef FLOATING_POINT
	char *decimal_point = _localeconv_r (data)->decimal_point;
   13a4c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   13a50:	eb001baf 	bl	1a914 <_localeconv_r>
   13a54:	e1a03000 	mov	r3, r0
   13a58:	e5933000 	ldr	r3, [r3]
   13a5c:	e50b3074 	str	r3, [fp, #-116]	; 0x74
	size_t decp_len = strlen (decimal_point);
   13a60:	e51b0074 	ldr	r0, [fp, #-116]	; 0x74
   13a64:	ebfff3e0 	bl	109ec <strlen>
   13a68:	e50b0078 	str	r0, [fp, #-120]	; 0x78
	char softsign;		/* temporary negative sign for floats */
	union { int i; _PRINTF_FLOAT_TYPE fp; } _double_ = {0};
   13a6c:	e3a03000 	mov	r3, #0
   13a70:	e3a04000 	mov	r4, #0
   13a74:	e50b3094 	str	r3, [fp, #-148]	; 0x94
   13a78:	e50b4090 	str	r4, [fp, #-144]	; 0x90
# define _fpvalue (_double_.fp)
	int expt;		/* integer value of exponent */
	int expsize = 0;	/* character count for expstr */
   13a7c:	e3a03000 	mov	r3, #0
   13a80:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	char expstr[MAXEXPLEN];	/* buffer for exponent string */
	int lead;		/* sig figs before decimal or group sep */
#endif /* FLOATING_POINT */
#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
	int ndig = 0;		/* actual number of digits returned by cvt */
   13a84:	e3a03000 	mov	r3, #0
   13a88:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
   13a8c:	e3a03000 	mov	r3, #0
   13a90:	e50b3060 	str	r3, [fp, #-96]	; 0x60
	char ox[2];		/* space for 0x hex-prefix */
#ifdef _MB_CAPABLE
	wchar_t wc;
	mbstate_t state;        /* mbtowc calls from library must not change state */
#endif
	char *malloc_buf = NULL;/* handy pointer for malloced buffers */
   13a94:	e3a03000 	mov	r3, #0
   13a98:	e50b3064 	str	r3, [fp, #-100]	; 0x64
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
    CHECK_INIT (data, fp);
   13a9c:	e51b3160 	ldr	r3, [fp, #-352]	; 0x160
   13aa0:	e50b307c 	str	r3, [fp, #-124]	; 0x7c
   13aa4:	e51b307c 	ldr	r3, [fp, #-124]	; 0x7c
   13aa8:	e3530000 	cmp	r3, #0
   13aac:	0a000005 	beq	13ac8 <_vfprintf_r+0xb0>
   13ab0:	e51b307c 	ldr	r3, [fp, #-124]	; 0x7c
   13ab4:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   13ab8:	e3530000 	cmp	r3, #0
   13abc:	1a000001 	bne	13ac8 <_vfprintf_r+0xb0>
   13ac0:	e51b007c 	ldr	r0, [fp, #-124]	; 0x7c
   13ac4:	eb0016dd 	bl	19640 <__sinit>
    cpu_dcache_invalidate((void*)&(fp->_flags), sizeof(short));
   13ac8:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13acc:	e283300c 	add	r3, r3, #12
   13ad0:	e1a00003 	mov	r0, r3
   13ad4:	e3a01002 	mov	r1, #2
   13ad8:	ebffd874 	bl	9cb0 <cpu_dcache_invalidate>
    cpu_dcache_invalidate((void*)&(fp->_lock) , sizeof(_flock_t));
   13adc:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13ae0:	e283305c 	add	r3, r3, #92	; 0x5c
   13ae4:	e1a00003 	mov	r0, r3
   13ae8:	e3a01008 	mov	r1, #8
   13aec:	ebffd86f 	bl	9cb0 <cpu_dcache_invalidate>
	_newlib_flockfile_start (fp);
   13af0:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13af4:	e1d330bc 	ldrh	r3, [r3, #12]
   13af8:	e1a03803 	lsl	r3, r3, #16
   13afc:	e1a03823 	lsr	r3, r3, #16
   13b00:	e2033c02 	and	r3, r3, #512	; 0x200
   13b04:	e3530000 	cmp	r3, #0
   13b08:	1a000003 	bne	13b1c <_vfprintf_r+0x104>
   13b0c:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13b10:	e283305c 	add	r3, r3, #92	; 0x5c
   13b14:	e1a00003 	mov	r0, r3
   13b18:	ebffebb8 	bl	ea00 <_dna_lock_acquire>

    cpu_dcache_invalidate((void*)&(fp), sizeof(struct __sFILE));
   13b1c:	e24b3f59 	sub	r3, fp, #356	; 0x164
   13b20:	e1a00003 	mov	r0, r3
   13b24:	e3a01070 	mov	r1, #112	; 0x70
   13b28:	ebffd860 	bl	9cb0 <cpu_dcache_invalidate>
    cpu_dcache_invalidate((void*)&(fp->_flags) ,sizeof(short));
   13b2c:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13b30:	e283300c 	add	r3, r3, #12
   13b34:	e1a00003 	mov	r0, r3
   13b38:	e3a01002 	mov	r1, #2
   13b3c:	ebffd85b 	bl	9cb0 <cpu_dcache_invalidate>
    cpu_dcache_invalidate((void*)&(fp->_flags2), sizeof(int));
   13b40:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13b44:	e283306c 	add	r3, r3, #108	; 0x6c
   13b48:	e1a00003 	mov	r0, r3
   13b4c:	e3a01004 	mov	r1, #4
   13b50:	ebffd856 	bl	9cb0 <cpu_dcache_invalidate>
    ORIENT(fp, -1);
   13b54:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13b58:	e1d330bc 	ldrh	r3, [r3, #12]
   13b5c:	e1a03803 	lsl	r3, r3, #16
   13b60:	e1a03823 	lsr	r3, r3, #16
   13b64:	e2033a02 	and	r3, r3, #8192	; 0x2000
   13b68:	e3530000 	cmp	r3, #0
   13b6c:	1a00000b 	bne	13ba0 <_vfprintf_r+0x188>
   13b70:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13b74:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   13b78:	e1d220bc 	ldrh	r2, [r2, #12]
   13b7c:	e3822a02 	orr	r2, r2, #8192	; 0x2000
   13b80:	e1a02802 	lsl	r2, r2, #16
   13b84:	e1a02822 	lsr	r2, r2, #16
   13b88:	e1c320bc 	strh	r2, [r3, #12]
   13b8c:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13b90:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   13b94:	e592206c 	ldr	r2, [r2, #108]	; 0x6c
   13b98:	e3c22a02 	bic	r2, r2, #8192	; 0x2000
   13b9c:	e583206c 	str	r2, [r3, #108]	; 0x6c

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   13ba0:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13ba4:	e1d330bc 	ldrh	r3, [r3, #12]
   13ba8:	e1a03803 	lsl	r3, r3, #16
   13bac:	e1a03823 	lsr	r3, r3, #16
   13bb0:	e2033008 	and	r3, r3, #8
   13bb4:	e3530000 	cmp	r3, #0
   13bb8:	0a000003 	beq	13bcc <_vfprintf_r+0x1b4>
   13bbc:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13bc0:	e5933010 	ldr	r3, [r3, #16]
   13bc4:	e3530000 	cmp	r3, #0
   13bc8:	1a000013 	bne	13c1c <_vfprintf_r+0x204>
   13bcc:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13bd0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   13bd4:	e1a01003 	mov	r1, r3
   13bd8:	eb000bce 	bl	16b18 <__swsetup_r>
   13bdc:	e1a03000 	mov	r3, r0
   13be0:	e3530000 	cmp	r3, #0
   13be4:	0a00000c 	beq	13c1c <_vfprintf_r+0x204>
		_newlib_flockfile_exit (fp);
   13be8:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13bec:	e1d330bc 	ldrh	r3, [r3, #12]
   13bf0:	e1a03803 	lsl	r3, r3, #16
   13bf4:	e1a03823 	lsr	r3, r3, #16
   13bf8:	e2033c02 	and	r3, r3, #512	; 0x200
   13bfc:	e3530000 	cmp	r3, #0
   13c00:	1a000003 	bne	13c14 <_vfprintf_r+0x1fc>
   13c04:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13c08:	e283305c 	add	r3, r3, #92	; 0x5c
   13c0c:	e1a00003 	mov	r0, r3
   13c10:	ebffebe1 	bl	eb9c <_dna_lock_release>
		return (EOF);
   13c14:	e3e03000 	mvn	r3, #0
   13c18:	ea000a05 	b	16434 <_vfprintf_r+0x2a1c>
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   13c1c:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13c20:	e1d330bc 	ldrh	r3, [r3, #12]
   13c24:	e1a03803 	lsl	r3, r3, #16
   13c28:	e1a03823 	lsr	r3, r3, #16
   13c2c:	e203301a 	and	r3, r3, #26
   13c30:	e353000a 	cmp	r3, #10
   13c34:	1a000018 	bne	13c9c <_vfprintf_r+0x284>
	    fp->_file >= 0) {
   13c38:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13c3c:	e1d330be 	ldrh	r3, [r3, #14]
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   13c40:	e1a03803 	lsl	r3, r3, #16
   13c44:	e1a03843 	asr	r3, r3, #16
   13c48:	e3530000 	cmp	r3, #0
   13c4c:	ba000012 	blt	13c9c <_vfprintf_r+0x284>
	    fp->_file >= 0) {
		_newlib_flockfile_exit (fp);
   13c50:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13c54:	e1d330bc 	ldrh	r3, [r3, #12]
   13c58:	e1a03803 	lsl	r3, r3, #16
   13c5c:	e1a03823 	lsr	r3, r3, #16
   13c60:	e2033c02 	and	r3, r3, #512	; 0x200
   13c64:	e3530000 	cmp	r3, #0
   13c68:	1a000003 	bne	13c7c <_vfprintf_r+0x264>
   13c6c:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13c70:	e283305c 	add	r3, r3, #92	; 0x5c
   13c74:	e1a00003 	mov	r0, r3
   13c78:	ebffebc7 	bl	eb9c <_dna_lock_release>
		return (__sbprintf (data, fp, fmt0, ap));
   13c7c:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   13c80:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   13c84:	e1a01003 	mov	r1, r3
   13c88:	e51b2168 	ldr	r2, [fp, #-360]	; 0x168
   13c8c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   13c90:	ebffff00 	bl	13898 <__sbprintf>
   13c94:	e1a03000 	mov	r3, r0
   13c98:	ea0009e5 	b	16434 <_vfprintf_r+0x2a1c>
		}
		fp->_bf._size = 64;
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
   13c9c:	e51b9168 	ldr	r9, [fp, #-360]	; 0x168
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   13ca0:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   13ca4:	e50b40b0 	str	r4, [fp, #-176]	; 0xb0
	uio.uio_resid = 0;
   13ca8:	e3a03000 	mov	r3, #0
   13cac:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
	uio.uio_iovcnt = 0;
   13cb0:	e3a03000 	mov	r3, #0
   13cb4:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
#endif
	ret = 0;
   13cb8:	e3a03000 	mov	r3, #0
   13cbc:	e50b3020 	str	r3, [fp, #-32]

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
	        cp = fmt;
   13cc0:	e1a07009 	mov	r7, r9
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   13cc4:	ea000000 	b	13ccc <_vfprintf_r+0x2b4>
                    fmt += 1;
   13cc8:	e2899001 	add	r9, r9, #1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   13ccc:	e5d93000 	ldrb	r3, [r9]
   13cd0:	e3530000 	cmp	r3, #0
   13cd4:	0a000002 	beq	13ce4 <_vfprintf_r+0x2cc>
   13cd8:	e5d93000 	ldrb	r3, [r9]
   13cdc:	e3530025 	cmp	r3, #37	; 0x25
   13ce0:	1afffff8 	bne	13cc8 <_vfprintf_r+0x2b0>
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
   13ce4:	e1a02009 	mov	r2, r9
   13ce8:	e1a03007 	mov	r3, r7
   13cec:	e0635002 	rsb	r5, r3, r2
   13cf0:	e3550000 	cmp	r5, #0
   13cf4:	0a00001a 	beq	13d64 <_vfprintf_r+0x34c>
			PRINT (cp, m);
   13cf8:	e5847000 	str	r7, [r4]
   13cfc:	e1a03005 	mov	r3, r5
   13d00:	e5843004 	str	r3, [r4, #4]
   13d04:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   13d08:	e0833005 	add	r3, r3, r5
   13d0c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   13d10:	e2844008 	add	r4, r4, #8
   13d14:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   13d18:	e2833001 	add	r3, r3, #1
   13d1c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   13d20:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   13d24:	e3530007 	cmp	r3, #7
   13d28:	da00000a 	ble	13d58 <_vfprintf_r+0x340>
   13d2c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   13d30:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   13d34:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   13d38:	e1a01002 	mov	r1, r2
   13d3c:	e1a02003 	mov	r2, r3
   13d40:	eb002f09 	bl	1f96c <__sprint_r>
   13d44:	e1a03000 	mov	r3, r0
   13d48:	e3530000 	cmp	r3, #0
   13d4c:	0a000000 	beq	13d54 <_vfprintf_r+0x33c>
   13d50:	ea00099b 	b	163c4 <_vfprintf_r+0x29ac>
   13d54:	e24b40f0 	sub	r4, fp, #240	; 0xf0
			ret += m;
   13d58:	e51b3020 	ldr	r3, [fp, #-32]
   13d5c:	e0833005 	add	r3, r3, r5
   13d60:	e50b3020 	str	r3, [fp, #-32]
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   13d64:	e5d93000 	ldrb	r3, [r9]
   13d68:	e3530000 	cmp	r3, #0
   13d6c:	1a000000 	bne	13d74 <_vfprintf_r+0x35c>
                    goto done;
   13d70:	ea000983 	b	16384 <_vfprintf_r+0x296c>
#endif
		fmt_anchor = fmt;
   13d74:	e50b9080 	str	r9, [fp, #-128]	; 0x80
		fmt++;		/* skip over '%' */
   13d78:	e2899001 	add	r9, r9, #1

		flags = 0;
   13d7c:	e3a06000 	mov	r6, #0
		dprec = 0;
   13d80:	e3a03000 	mov	r3, #0
   13d84:	e50b3054 	str	r3, [fp, #-84]	; 0x54
		width = 0;
   13d88:	e3a03000 	mov	r3, #0
   13d8c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		prec = -1;
   13d90:	e3e03000 	mvn	r3, #0
   13d94:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		sign = '\0';
   13d98:	e3a03000 	mov	r3, #0
   13d9c:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
#ifdef FLOATING_POINT
		lead = 0;
   13da0:	e3a03000 	mov	r3, #0
   13da4:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
#ifdef _WANT_IO_C99_FORMATS
		nseps = nrepeats = 0;
   13da8:	e3a03000 	mov	r3, #0
   13dac:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   13db0:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   13db4:	e50b3040 	str	r3, [fp, #-64]	; 0x40
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   13db8:	e1a03009 	mov	r3, r9
   13dbc:	e2839001 	add	r9, r3, #1
   13dc0:	e5d33000 	ldrb	r3, [r3]
   13dc4:	e1a08003 	mov	r8, r3
reswitch:	switch (ch) {
   13dc8:	e2483020 	sub	r3, r8, #32
   13dcc:	e353005a 	cmp	r3, #90	; 0x5a
   13dd0:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   13dd4:	ea000443 	b	14ee8 <_vfprintf_r+0x14d0>
   13dd8:	00013fa8 	.word	0x00013fa8
   13ddc:	00014ee8 	.word	0x00014ee8
   13de0:	00014ee8 	.word	0x00014ee8
   13de4:	00013fc0 	.word	0x00013fc0
   13de8:	00014ee8 	.word	0x00014ee8
   13dec:	00014ee8 	.word	0x00014ee8
   13df0:	00014ee8 	.word	0x00014ee8
   13df4:	00013f44 	.word	0x00013f44
   13df8:	00014ee8 	.word	0x00014ee8
   13dfc:	00014ee8 	.word	0x00014ee8
   13e00:	00013fc8 	.word	0x00013fc8
   13e04:	00014000 	.word	0x00014000
   13e08:	00014ee8 	.word	0x00014ee8
   13e0c:	00013ff8 	.word	0x00013ff8
   13e10:	0001400c 	.word	0x0001400c
   13e14:	00014ee8 	.word	0x00014ee8
   13e18:	000140a8 	.word	0x000140a8
   13e1c:	000140b0 	.word	0x000140b0
   13e20:	000140b0 	.word	0x000140b0
   13e24:	000140b0 	.word	0x000140b0
   13e28:	000140b0 	.word	0x000140b0
   13e2c:	000140b0 	.word	0x000140b0
   13e30:	000140b0 	.word	0x000140b0
   13e34:	000140b0 	.word	0x000140b0
   13e38:	000140b0 	.word	0x000140b0
   13e3c:	000140b0 	.word	0x000140b0
   13e40:	00014ee8 	.word	0x00014ee8
   13e44:	00014ee8 	.word	0x00014ee8
   13e48:	00014ee8 	.word	0x00014ee8
   13e4c:	00014ee8 	.word	0x00014ee8
   13e50:	00014ee8 	.word	0x00014ee8
   13e54:	00014ee8 	.word	0x00014ee8
   13e58:	00014ee8 	.word	0x00014ee8
   13e5c:	0001429c 	.word	0x0001429c
   13e60:	00014ee8 	.word	0x00014ee8
   13e64:	0001414c 	.word	0x0001414c
   13e68:	0001417c 	.word	0x0001417c
   13e6c:	0001429c 	.word	0x0001429c
   13e70:	0001429c 	.word	0x0001429c
   13e74:	0001429c 	.word	0x0001429c
   13e78:	00014ee8 	.word	0x00014ee8
   13e7c:	00014ee8 	.word	0x00014ee8
   13e80:	00014ee8 	.word	0x00014ee8
   13e84:	00014ee8 	.word	0x00014ee8
   13e88:	000140f4 	.word	0x000140f4
   13e8c:	00014ee8 	.word	0x00014ee8
   13e90:	00014ee8 	.word	0x00014ee8
   13e94:	00014810 	.word	0x00014810
   13e98:	00014ee8 	.word	0x00014ee8
   13e9c:	00014ee8 	.word	0x00014ee8
   13ea0:	00014ee8 	.word	0x00014ee8
   13ea4:	00014940 	.word	0x00014940
   13ea8:	00014ee8 	.word	0x00014ee8
   13eac:	00014a00 	.word	0x00014a00
   13eb0:	00014ee8 	.word	0x00014ee8
   13eb4:	00014ee8 	.word	0x00014ee8
   13eb8:	00014ae0 	.word	0x00014ae0
   13ebc:	00014ee8 	.word	0x00014ee8
   13ec0:	00014ee8 	.word	0x00014ee8
   13ec4:	00014ee8 	.word	0x00014ee8
   13ec8:	00014ee8 	.word	0x00014ee8
   13ecc:	00014ee8 	.word	0x00014ee8
   13ed0:	00014ee8 	.word	0x00014ee8
   13ed4:	00014ee8 	.word	0x00014ee8
   13ed8:	00014ee8 	.word	0x00014ee8
   13edc:	0001429c 	.word	0x0001429c
   13ee0:	00014ee8 	.word	0x00014ee8
   13ee4:	0001414c 	.word	0x0001414c
   13ee8:	00014180 	.word	0x00014180
   13eec:	0001429c 	.word	0x0001429c
   13ef0:	0001429c 	.word	0x0001429c
   13ef4:	0001429c 	.word	0x0001429c
   13ef8:	000140fc 	.word	0x000140fc
   13efc:	00014180 	.word	0x00014180
   13f00:	00014144 	.word	0x00014144
   13f04:	00014ee8 	.word	0x00014ee8
   13f08:	0001411c 	.word	0x0001411c
   13f0c:	00014ee8 	.word	0x00014ee8
   13f10:	0001473c 	.word	0x0001473c
   13f14:	00014814 	.word	0x00014814
   13f18:	000148f4 	.word	0x000148f4
   13f1c:	0001413c 	.word	0x0001413c
   13f20:	00014ee8 	.word	0x00014ee8
   13f24:	00014940 	.word	0x00014940
   13f28:	00013db8 	.word	0x00013db8
   13f2c:	00014a04 	.word	0x00014a04
   13f30:	00014ee8 	.word	0x00014ee8
   13f34:	00014ee8 	.word	0x00014ee8
   13f38:	00014aec 	.word	0x00014aec
   13f3c:	00014ee8 	.word	0x00014ee8
   13f40:	00013db8 	.word	0x00013db8
#ifdef _WANT_IO_C99_FORMATS
		case '\'':
			thousands_sep = _localeconv_r (data)->thousands_sep;
   13f44:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   13f48:	eb001a71 	bl	1a914 <_localeconv_r>
   13f4c:	e1a03000 	mov	r3, r0
   13f50:	e5933004 	ldr	r3, [r3, #4]
   13f54:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
			thsnd_len = strlen (thousands_sep);
   13f58:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
   13f5c:	ebfff2a2 	bl	109ec <strlen>
   13f60:	e50b0030 	str	r0, [fp, #-48]	; 0x30
			grouping = _localeconv_r (data)->grouping;
   13f64:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   13f68:	eb001a69 	bl	1a914 <_localeconv_r>
   13f6c:	e1a03000 	mov	r3, r0
   13f70:	e5933008 	ldr	r3, [r3, #8]
   13f74:	e50b3034 	str	r3, [fp, #-52]	; 0x34
			if (thsnd_len > 0 && grouping && *grouping)
   13f78:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   13f7c:	e3530000 	cmp	r3, #0
   13f80:	0a000007 	beq	13fa4 <_vfprintf_r+0x58c>
   13f84:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   13f88:	e3530000 	cmp	r3, #0
   13f8c:	0a000004 	beq	13fa4 <_vfprintf_r+0x58c>
   13f90:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   13f94:	e5d33000 	ldrb	r3, [r3]
   13f98:	e3530000 	cmp	r3, #0
   13f9c:	0a000000 	beq	13fa4 <_vfprintf_r+0x58c>
			  flags |= GROUPING;
   13fa0:	e3866b01 	orr	r6, r6, #1024	; 0x400
			goto rflag;
   13fa4:	eaffff83 	b	13db8 <_vfprintf_r+0x3a0>
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
   13fa8:	e55b3089 	ldrb	r3, [fp, #-137]	; 0x89
   13fac:	e3530000 	cmp	r3, #0
   13fb0:	1a000001 	bne	13fbc <_vfprintf_r+0x5a4>
				sign = ' ';
   13fb4:	e3a03020 	mov	r3, #32
   13fb8:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
			goto rflag;
   13fbc:	eaffff7d 	b	13db8 <_vfprintf_r+0x3a0>
		case '#':
			flags |= ALT;
   13fc0:	e3866001 	orr	r6, r6, #1
			goto rflag;
   13fc4:	eaffff7b 	b	13db8 <_vfprintf_r+0x3a0>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   13fc8:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   13fcc:	e2832004 	add	r2, r3, #4
   13fd0:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   13fd4:	e5933000 	ldr	r3, [r3]
   13fd8:	e50b3024 	str	r3, [fp, #-36]	; 0x24
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
   13fdc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   13fe0:	e3530000 	cmp	r3, #0
   13fe4:	ba000000 	blt	13fec <_vfprintf_r+0x5d4>
				goto rflag;
   13fe8:	eaffff72 	b	13db8 <_vfprintf_r+0x3a0>
			width = -width;
   13fec:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   13ff0:	e2633000 	rsb	r3, r3, #0
   13ff4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
   13ff8:	e3866004 	orr	r6, r6, #4
			goto rflag;
   13ffc:	eaffff6d 	b	13db8 <_vfprintf_r+0x3a0>
		case '+':
			sign = '+';
   14000:	e3a0302b 	mov	r3, #43	; 0x2b
   14004:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
			goto rflag;
   14008:	eaffff6a 	b	13db8 <_vfprintf_r+0x3a0>
		case '.':
			if ((ch = *fmt++) == '*') {
   1400c:	e1a03009 	mov	r3, r9
   14010:	e2839001 	add	r9, r3, #1
   14014:	e5d33000 	ldrb	r3, [r3]
   14018:	e1a08003 	mov	r8, r3
   1401c:	e358002a 	cmp	r8, #42	; 0x2a
   14020:	1a00000a 	bne	14050 <_vfprintf_r+0x638>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   14024:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14028:	e2832004 	add	r2, r3, #4
   1402c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14030:	e5933000 	ldr	r3, [r3]
   14034:	e50b3028 	str	r3, [fp, #-40]	; 0x28
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   14038:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1403c:	e3530000 	cmp	r3, #0
   14040:	aa000001 	bge	1404c <_vfprintf_r+0x634>
					prec = -1;
   14044:	e3e03000 	mvn	r3, #0
   14048:	e50b3028 	str	r3, [fp, #-40]	; 0x28
				goto rflag;
   1404c:	eaffff59 	b	13db8 <_vfprintf_r+0x3a0>
			}
			n = 0;
   14050:	e3a05000 	mov	r5, #0
			while (is_digit (ch)) {
   14054:	ea00000a 	b	14084 <_vfprintf_r+0x66c>
				n = 10 * n + to_digit (ch);
   14058:	e1a03005 	mov	r3, r5
   1405c:	e1a03103 	lsl	r3, r3, #2
   14060:	e0833005 	add	r3, r3, r5
   14064:	e1a03083 	lsl	r3, r3, #1
   14068:	e1a02003 	mov	r2, r3
   1406c:	e2483030 	sub	r3, r8, #48	; 0x30
   14070:	e0825003 	add	r5, r2, r3
				ch = *fmt++;
   14074:	e1a03009 	mov	r3, r9
   14078:	e2839001 	add	r9, r3, #1
   1407c:	e5d33000 	ldrb	r3, [r3]
   14080:	e1a08003 	mov	r8, r3
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   14084:	e2483030 	sub	r3, r8, #48	; 0x30
   14088:	e3530009 	cmp	r3, #9
   1408c:	9afffff1 	bls	14058 <_vfprintf_r+0x640>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
   14090:	e3e03000 	mvn	r3, #0
   14094:	e1550003 	cmp	r5, r3
   14098:	a1a03005 	movge	r3, r5
   1409c:	b1a03003 	movlt	r3, r3
   140a0:	e50b3028 	str	r3, [fp, #-40]	; 0x28
			goto reswitch;
   140a4:	eaffff47 	b	13dc8 <_vfprintf_r+0x3b0>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
   140a8:	e3866080 	orr	r6, r6, #128	; 0x80
			goto rflag;
   140ac:	eaffff41 	b	13db8 <_vfprintf_r+0x3a0>
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
   140b0:	e3a05000 	mov	r5, #0
			do {
				n = 10 * n + to_digit (ch);
   140b4:	e1a03005 	mov	r3, r5
   140b8:	e1a03103 	lsl	r3, r3, #2
   140bc:	e0833005 	add	r3, r3, r5
   140c0:	e1a03083 	lsl	r3, r3, #1
   140c4:	e1a02003 	mov	r2, r3
   140c8:	e2483030 	sub	r3, r8, #48	; 0x30
   140cc:	e0825003 	add	r5, r2, r3
				ch = *fmt++;
   140d0:	e1a03009 	mov	r3, r9
   140d4:	e2839001 	add	r9, r3, #1
   140d8:	e5d33000 	ldrb	r3, [r3]
   140dc:	e1a08003 	mov	r8, r3
			} while (is_digit (ch));
   140e0:	e2483030 	sub	r3, r8, #48	; 0x30
   140e4:	e3530009 	cmp	r3, #9
   140e8:	9afffff1 	bls	140b4 <_vfprintf_r+0x69c>
				}
				else
					goto error;
			}
#endif /* !_NO_POS_ARGS */
			width = n;
   140ec:	e50b5024 	str	r5, [fp, #-36]	; 0x24
			goto reswitch;
   140f0:	eaffff34 	b	13dc8 <_vfprintf_r+0x3b0>
#ifdef FLOATING_POINT
		case 'L':
			flags |= LONGDBL;
   140f4:	e3866008 	orr	r6, r6, #8
			goto rflag;
   140f8:	eaffff2e 	b	13db8 <_vfprintf_r+0x3a0>
#endif
		case 'h':
#ifdef _WANT_IO_C99_FORMATS
			if (*fmt == 'h') {
   140fc:	e5d93000 	ldrb	r3, [r9]
   14100:	e3530068 	cmp	r3, #104	; 0x68
   14104:	1a000002 	bne	14114 <_vfprintf_r+0x6fc>
				fmt++;
   14108:	e2899001 	add	r9, r9, #1
				flags |= CHARINT;
   1410c:	e3866c02 	orr	r6, r6, #512	; 0x200
   14110:	ea000000 	b	14118 <_vfprintf_r+0x700>
			} else
#endif
				flags |= SHORTINT;
   14114:	e3866040 	orr	r6, r6, #64	; 0x40
			goto rflag;
   14118:	eaffff26 	b	13db8 <_vfprintf_r+0x3a0>
		case 'l':
#if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
			if (*fmt == 'l') {
   1411c:	e5d93000 	ldrb	r3, [r9]
   14120:	e353006c 	cmp	r3, #108	; 0x6c
   14124:	1a000002 	bne	14134 <_vfprintf_r+0x71c>
				fmt++;
   14128:	e2899001 	add	r9, r9, #1
				flags |= QUADINT;
   1412c:	e3866020 	orr	r6, r6, #32
   14130:	ea000000 	b	14138 <_vfprintf_r+0x720>
			} else
#endif
				flags |= LONGINT;
   14134:	e3866010 	orr	r6, r6, #16
			goto rflag;
   14138:	eaffff1e 	b	13db8 <_vfprintf_r+0x3a0>
		case 'q': /* extension */
			flags |= QUADINT;
   1413c:	e3866020 	orr	r6, r6, #32
			goto rflag;
   14140:	eaffff1c 	b	13db8 <_vfprintf_r+0x3a0>
#ifdef _WANT_IO_C99_FORMATS
		case 'j':
		  if (sizeof (intmax_t) == sizeof (long))
		    flags |= LONGINT;
		  else
		    flags |= QUADINT;
   14144:	e3866020 	orr	r6, r6, #32
		  goto rflag;
   14148:	eaffff1a 	b	13db8 <_vfprintf_r+0x3a0>
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
   1414c:	e24b7f55 	sub	r7, fp, #340	; 0x154
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   14150:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14154:	e2832004 	add	r2, r3, #4
   14158:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1415c:	e5933000 	ldr	r3, [r3]
   14160:	e20330ff 	and	r3, r3, #255	; 0xff
   14164:	e5c73000 	strb	r3, [r7]
				size = 1;
   14168:	e3a03001 	mov	r3, #1
   1416c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
			}
			sign = '\0';
   14170:	e3a03000 	mov	r3, #0
   14174:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
			break;
   14178:	ea000365 	b	14f14 <_vfprintf_r+0x14fc>
		case 'D':  /* extension */
			flags |= LONGINT;
   1417c:	e3866010 	orr	r6, r6, #16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   14180:	e2063020 	and	r3, r6, #32
   14184:	e3530000 	cmp	r3, #0
   14188:	0a000006 	beq	141a8 <_vfprintf_r+0x790>
   1418c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14190:	e2833007 	add	r3, r3, #7
   14194:	e3c33007 	bic	r3, r3, #7
   14198:	e2832008 	add	r2, r3, #8
   1419c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   141a0:	e893000c 	ldm	r3, {r2, r3}
   141a4:	ea00002a 	b	14254 <_vfprintf_r+0x83c>
   141a8:	e2063010 	and	r3, r6, #16
   141ac:	e3530000 	cmp	r3, #0
   141b0:	0a000006 	beq	141d0 <_vfprintf_r+0x7b8>
   141b4:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   141b8:	e2832004 	add	r2, r3, #4
   141bc:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   141c0:	e5933000 	ldr	r3, [r3]
   141c4:	e1a02003 	mov	r2, r3
   141c8:	e1a03fc2 	asr	r3, r2, #31
   141cc:	ea000020 	b	14254 <_vfprintf_r+0x83c>
   141d0:	e2063040 	and	r3, r6, #64	; 0x40
   141d4:	e3530000 	cmp	r3, #0
   141d8:	0a00000a 	beq	14208 <_vfprintf_r+0x7f0>
   141dc:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   141e0:	e2832004 	add	r2, r3, #4
   141e4:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   141e8:	e5933000 	ldr	r3, [r3]
   141ec:	e1a03803 	lsl	r3, r3, #16
   141f0:	e1a01823 	lsr	r1, r3, #16
   141f4:	e1a03801 	lsl	r3, r1, #16
   141f8:	e1a03843 	asr	r3, r3, #16
   141fc:	e1a02003 	mov	r2, r3
   14200:	e1a03fc2 	asr	r3, r2, #31
   14204:	ea000012 	b	14254 <_vfprintf_r+0x83c>
   14208:	e2063c02 	and	r3, r6, #512	; 0x200
   1420c:	e3530000 	cmp	r3, #0
   14210:	0a000009 	beq	1423c <_vfprintf_r+0x824>
   14214:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14218:	e2832004 	add	r2, r3, #4
   1421c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14220:	e5933000 	ldr	r3, [r3]
   14224:	e20310ff 	and	r1, r3, #255	; 0xff
   14228:	e1a03c01 	lsl	r3, r1, #24
   1422c:	e1a03c43 	asr	r3, r3, #24
   14230:	e1a02003 	mov	r2, r3
   14234:	e1a03fc2 	asr	r3, r2, #31
   14238:	ea000005 	b	14254 <_vfprintf_r+0x83c>
   1423c:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14240:	e2832004 	add	r2, r3, #4
   14244:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14248:	e5933000 	ldr	r3, [r3]
   1424c:	e1a02003 	mov	r2, r3
   14250:	e1a03fc2 	asr	r3, r2, #31
   14254:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   14258:	e50b3048 	str	r3, [fp, #-72]	; 0x48
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
   1425c:	e24b304c 	sub	r3, fp, #76	; 0x4c
   14260:	e893000c 	ldm	r3, {r2, r3}
   14264:	e3520000 	cmp	r2, #0
   14268:	e2d31000 	sbcs	r1, r3, #0
   1426c:	aa000007 	bge	14290 <_vfprintf_r+0x878>
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
   14270:	e24b304c 	sub	r3, fp, #76	; 0x4c
   14274:	e893000c 	ldm	r3, {r2, r3}
   14278:	e2722000 	rsbs	r2, r2, #0
   1427c:	e2e33000 	rsc	r3, r3, #0
   14280:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   14284:	e50b3048 	str	r3, [fp, #-72]	; 0x48
				sign = '-';
   14288:	e3a0302d 	mov	r3, #45	; 0x2d
   1428c:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
			}
			base = DEC;
   14290:	e3a03001 	mov	r3, #1
   14294:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
			goto number;
   14298:	ea00025a 	b	14c08 <_vfprintf_r+0x11f0>
		case 'E':
		case 'f':
		case 'g':
		case 'G':
# ifdef _NO_LONGDBL
			if (flags & LONGDBL) {
   1429c:	e2063008 	and	r3, r6, #8
   142a0:	e3530000 	cmp	r3, #0
   142a4:	0a000008 	beq	142cc <_vfprintf_r+0x8b4>
				_fpvalue = (double) GET_ARG (N, ap, _LONG_DOUBLE);
   142a8:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   142ac:	e2833007 	add	r3, r3, #7
   142b0:	e3c33007 	bic	r3, r3, #7
   142b4:	e2832008 	add	r2, r3, #8
   142b8:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   142bc:	e893000c 	ldm	r3, {r2, r3}
   142c0:	e50b2094 	str	r2, [fp, #-148]	; 0x94
   142c4:	e50b3090 	str	r3, [fp, #-144]	; 0x90
   142c8:	ea000007 	b	142ec <_vfprintf_r+0x8d4>
			} else {
				_fpvalue = GET_ARG (N, ap, double);
   142cc:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   142d0:	e2833007 	add	r3, r3, #7
   142d4:	e3c33007 	bic	r3, r3, #7
   142d8:	e2832008 	add	r2, r3, #8
   142dc:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   142e0:	e893000c 	ldm	r3, {r2, r3}
   142e4:	e50b2094 	str	r2, [fp, #-148]	; 0x94
   142e8:	e50b3090 	str	r3, [fp, #-144]	; 0x90

			   If the output is infinite or NaN, leading
			   zeros are not permitted.  Otherwise, scanf
			   could not read what printf wrote.
			 */
			if (isinf (_fpvalue)) {
   142ec:	e24b3094 	sub	r3, fp, #148	; 0x94
   142f0:	e893000c 	ldm	r3, {r2, r3}
   142f4:	e1a00002 	mov	r0, r2
   142f8:	e1a01003 	mov	r1, r3
   142fc:	eb002577 	bl	1d8e0 <__fpclassifyd>
   14300:	e1a03000 	mov	r3, r0
   14304:	e3530001 	cmp	r3, #1
   14308:	1a000014 	bne	14360 <_vfprintf_r+0x948>
				if (_fpvalue < 0)
   1430c:	e24b3094 	sub	r3, fp, #148	; 0x94
   14310:	e893000c 	ldm	r3, {r2, r3}
   14314:	e1a00002 	mov	r0, r2
   14318:	e1a01003 	mov	r1, r3
   1431c:	e3a02000 	mov	r2, #0
   14320:	e3a03000 	mov	r3, #0
   14324:	eb003a37 	bl	22c08 <__aeabi_dcmplt>
   14328:	e1a03000 	mov	r3, r0
   1432c:	e3530000 	cmp	r3, #0
   14330:	0a000001 	beq	1433c <_vfprintf_r+0x924>
					sign = '-';
   14334:	e3a0302d 	mov	r3, #45	; 0x2d
   14338:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
   1433c:	e3580047 	cmp	r8, #71	; 0x47
   14340:	ca000001 	bgt	1434c <_vfprintf_r+0x934>
					cp = "INF";
   14344:	e59f7fc8 	ldr	r7, [pc, #4040]	; 15314 <_vfprintf_r+0x18fc>
   14348:	ea000000 	b	14350 <_vfprintf_r+0x938>
				else
					cp = "inf";
   1434c:	e59f7fc4 	ldr	r7, [pc, #4036]	; 15318 <_vfprintf_r+0x1900>
				size = 3;
   14350:	e3a03003 	mov	r3, #3
   14354:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
				flags &= ~ZEROPAD;
   14358:	e3c66080 	bic	r6, r6, #128	; 0x80
				break;
   1435c:	ea0002ec 	b	14f14 <_vfprintf_r+0x14fc>
			}
			if (isnan (_fpvalue)) {
   14360:	e24b3094 	sub	r3, fp, #148	; 0x94
   14364:	e893000c 	ldm	r3, {r2, r3}
   14368:	e1a00002 	mov	r0, r2
   1436c:	e1a01003 	mov	r1, r3
   14370:	eb00255a 	bl	1d8e0 <__fpclassifyd>
   14374:	e1a03000 	mov	r3, r0
   14378:	e3530000 	cmp	r3, #0
   1437c:	1a000008 	bne	143a4 <_vfprintf_r+0x98c>
				if (ch <= 'G') /* 'A', 'E', 'F', or 'G' */
   14380:	e3580047 	cmp	r8, #71	; 0x47
   14384:	ca000001 	bgt	14390 <_vfprintf_r+0x978>
					cp = "NAN";
   14388:	e59f7f8c 	ldr	r7, [pc, #3980]	; 1531c <_vfprintf_r+0x1904>
   1438c:	ea000000 	b	14394 <_vfprintf_r+0x97c>
				else
					cp = "nan";
   14390:	e59f7f88 	ldr	r7, [pc, #3976]	; 15320 <_vfprintf_r+0x1908>
				size = 3;
   14394:	e3a03003 	mov	r3, #3
   14398:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
				flags &= ~ZEROPAD;
   1439c:	e3c66080 	bic	r6, r6, #128	; 0x80
				break;
   143a0:	ea0002db 	b	14f14 <_vfprintf_r+0x14fc>
				break;
			}
# endif /* !_NO_LONGDBL */

# ifdef _WANT_IO_C99_FORMATS
			if (ch == 'a' || ch == 'A') {
   143a4:	e3580061 	cmp	r8, #97	; 0x61
   143a8:	0a000001 	beq	143b4 <_vfprintf_r+0x99c>
   143ac:	e3580041 	cmp	r8, #65	; 0x41
   143b0:	1a000020 	bne	14438 <_vfprintf_r+0xa20>
				ox[0] = '0';
   143b4:	e3a03030 	mov	r3, #48	; 0x30
   143b8:	e54b3158 	strb	r3, [fp, #-344]	; 0x158
				ox[1] = ch == 'a' ? 'x' : 'X';
   143bc:	e3580061 	cmp	r8, #97	; 0x61
   143c0:	1a000001 	bne	143cc <_vfprintf_r+0x9b4>
   143c4:	e3a03078 	mov	r3, #120	; 0x78
   143c8:	ea000000 	b	143d0 <_vfprintf_r+0x9b8>
   143cc:	e3a03058 	mov	r3, #88	; 0x58
   143d0:	e54b3157 	strb	r3, [fp, #-343]	; 0x157
				flags |= HEXPREFIX;
   143d4:	e3866002 	orr	r6, r6, #2
				if (prec >= BUF)
   143d8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   143dc:	e3530063 	cmp	r3, #99	; 0x63
   143e0:	da000012 	ble	14430 <_vfprintf_r+0xa18>
				  {
				    if ((malloc_buf =
					 (char *)_malloc_r (data, prec + 1))
   143e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   143e8:	e2833001 	add	r3, r3, #1
				ox[0] = '0';
				ox[1] = ch == 'a' ? 'x' : 'X';
				flags |= HEXPREFIX;
				if (prec >= BUF)
				  {
				    if ((malloc_buf =
   143ec:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   143f0:	e1a01003 	mov	r1, r3
   143f4:	ebffeb0e 	bl	f034 <_malloc_r>
   143f8:	e50b0064 	str	r0, [fp, #-100]	; 0x64
   143fc:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   14400:	e3530000 	cmp	r3, #0
   14404:	1a000007 	bne	14428 <_vfprintf_r+0xa10>
					 (char *)_malloc_r (data, prec + 1))
					== NULL)
				      {
					fp->_flags |= __SERR;
   14408:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1440c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   14410:	e1d220bc 	ldrh	r2, [r2, #12]
   14414:	e3822040 	orr	r2, r2, #64	; 0x40
   14418:	e1a02802 	lsl	r2, r2, #16
   1441c:	e1a02822 	lsr	r2, r2, #16
   14420:	e1c320bc 	strh	r2, [r3, #12]
					goto error;
   14424:	ea0007e6 	b	163c4 <_vfprintf_r+0x29ac>
				      }
				    cp = malloc_buf;
   14428:	e51b7064 	ldr	r7, [fp, #-100]	; 0x64
# ifdef _WANT_IO_C99_FORMATS
			if (ch == 'a' || ch == 'A') {
				ox[0] = '0';
				ox[1] = ch == 'a' ? 'x' : 'X';
				flags |= HEXPREFIX;
				if (prec >= BUF)
   1442c:	ea000010 	b	14474 <_vfprintf_r+0xa5c>
					goto error;
				      }
				    cp = malloc_buf;
				  }
				else
				  cp = buf;
   14430:	e24b7f55 	sub	r7, fp, #340	; 0x154
# ifdef _WANT_IO_C99_FORMATS
			if (ch == 'a' || ch == 'A') {
				ox[0] = '0';
				ox[1] = ch == 'a' ? 'x' : 'X';
				flags |= HEXPREFIX;
				if (prec >= BUF)
   14434:	ea00000e 	b	14474 <_vfprintf_r+0xa5c>
				  }
				else
				  cp = buf;
			} else
# endif /* _WANT_IO_C99_FORMATS */
			if (prec == -1) {
   14438:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1443c:	e3730001 	cmn	r3, #1
   14440:	1a000002 	bne	14450 <_vfprintf_r+0xa38>
				prec = DEFPREC;
   14444:	e3a03006 	mov	r3, #6
   14448:	e50b3028 	str	r3, [fp, #-40]	; 0x28
   1444c:	ea000008 	b	14474 <_vfprintf_r+0xa5c>
			} else if ((ch == 'g' || ch == 'G') && prec == 0) {
   14450:	e3580067 	cmp	r8, #103	; 0x67
   14454:	0a000001 	beq	14460 <_vfprintf_r+0xa48>
   14458:	e3580047 	cmp	r8, #71	; 0x47
   1445c:	1a000004 	bne	14474 <_vfprintf_r+0xa5c>
   14460:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   14464:	e3530000 	cmp	r3, #0
   14468:	1a000001 	bne	14474 <_vfprintf_r+0xa5c>
				prec = 1;
   1446c:	e3a03001 	mov	r3, #1
   14470:	e50b3028 	str	r3, [fp, #-40]	; 0x28
			}

			flags |= FPT;
   14474:	e3866c01 	orr	r6, r6, #256	; 0x100

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
   14478:	e24b3094 	sub	r3, fp, #148	; 0x94
   1447c:	e893000c 	ldm	r3, {r2, r3}
   14480:	e51b1028 	ldr	r1, [fp, #-40]	; 0x28
   14484:	e58d1000 	str	r1, [sp]
   14488:	e58d6004 	str	r6, [sp, #4]
   1448c:	e24b108a 	sub	r1, fp, #138	; 0x8a
   14490:	e58d1008 	str	r1, [sp, #8]
   14494:	e24b1098 	sub	r1, fp, #152	; 0x98
   14498:	e58d100c 	str	r1, [sp, #12]
   1449c:	e58d8010 	str	r8, [sp, #16]
   144a0:	e24b10a4 	sub	r1, fp, #164	; 0xa4
   144a4:	e58d1014 	str	r1, [sp, #20]
   144a8:	e58d7018 	str	r7, [sp, #24]
   144ac:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   144b0:	eb0007e3 	bl	16444 <cvt>
   144b4:	e1a07000 	mov	r7, r0
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
   144b8:	e3580067 	cmp	r8, #103	; 0x67
   144bc:	0a000001 	beq	144c8 <_vfprintf_r+0xab0>
   144c0:	e3580047 	cmp	r8, #71	; 0x47
   144c4:	1a00000a 	bne	144f4 <_vfprintf_r+0xadc>
				if (expt <= -4 || expt > prec)
   144c8:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   144cc:	e3730003 	cmn	r3, #3
   144d0:	ba000003 	blt	144e4 <_vfprintf_r+0xacc>
   144d4:	e51b2098 	ldr	r2, [fp, #-152]	; 0x98
   144d8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   144dc:	e1520003 	cmp	r2, r3
   144e0:	da000001 	ble	144ec <_vfprintf_r+0xad4>
					ch -= 2; /* 'e' or 'E' */
   144e4:	e2488002 	sub	r8, r8, #2

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
				if (expt <= -4 || expt > prec)
   144e8:	ea000004 	b	14500 <_vfprintf_r+0xae8>
					ch -= 2; /* 'e' or 'E' */
				else
					ch = 'g';
   144ec:	e3a08067 	mov	r8, #103	; 0x67

			cp = cvt (data, _fpvalue, prec, flags, &softsign,
				  &expt, ch, &ndig, cp);

			if (ch == 'g' || ch == 'G') {
				if (expt <= -4 || expt > prec)
   144f0:	ea000002 	b	14500 <_vfprintf_r+0xae8>
					ch -= 2; /* 'e' or 'E' */
				else
					ch = 'g';
			}
# ifdef _WANT_IO_C99_FORMATS
			else if (ch == 'F')
   144f4:	e3580046 	cmp	r8, #70	; 0x46
   144f8:	1a000000 	bne	14500 <_vfprintf_r+0xae8>
				ch = 'f';
   144fc:	e3a08066 	mov	r8, #102	; 0x66
# endif
			if (ch <= 'e') {	/* 'a', 'A', 'e', or 'E' fmt */
   14500:	e3580065 	cmp	r8, #101	; 0x65
   14504:	ca000018 	bgt	1456c <_vfprintf_r+0xb54>
				--expt;
   14508:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1450c:	e2433001 	sub	r3, r3, #1
   14510:	e50b3098 	str	r3, [fp, #-152]	; 0x98
				expsize = exponent (expstr, expt, ch);
   14514:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   14518:	e24b20a0 	sub	r2, fp, #160	; 0xa0
   1451c:	e1a00002 	mov	r0, r2
   14520:	e1a01003 	mov	r1, r3
   14524:	e1a02008 	mov	r2, r8
   14528:	eb0008eb 	bl	168dc <exponent>
   1452c:	e50b0038 	str	r0, [fp, #-56]	; 0x38
				size = expsize + ndig;
   14530:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   14534:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   14538:	e0823003 	add	r3, r2, r3
   1453c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
				if (ndig > 1 || flags & ALT)
   14540:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   14544:	e3530001 	cmp	r3, #1
   14548:	ca000002 	bgt	14558 <_vfprintf_r+0xb40>
   1454c:	e2063001 	and	r3, r6, #1
   14550:	e3530000 	cmp	r3, #0
   14554:	0a000002 	beq	14564 <_vfprintf_r+0xb4c>
					++size;
   14558:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1455c:	e2833001 	add	r3, r3, #1
   14560:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
# ifdef _WANT_IO_C99_FORMATS
				flags &= ~GROUPING;
   14564:	e3c66b01 	bic	r6, r6, #1024	; 0x400
   14568:	ea00006c 	b	14720 <_vfprintf_r+0xd08>
# endif
			} else {
				if (ch == 'f') {		/* f fmt */
   1456c:	e3580066 	cmp	r8, #102	; 0x66
   14570:	1a00001c 	bne	145e8 <_vfprintf_r+0xbd0>
					if (expt > 0) {
   14574:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   14578:	e3530000 	cmp	r3, #0
   1457c:	da00000d 	ble	145b8 <_vfprintf_r+0xba0>
						size = expt;
   14580:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   14584:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
						if (prec || flags & ALT)
   14588:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1458c:	e3530000 	cmp	r3, #0
   14590:	1a000002 	bne	145a0 <_vfprintf_r+0xb88>
   14594:	e2063001 	and	r3, r6, #1
   14598:	e3530000 	cmp	r3, #0
   1459c:	0a000028 	beq	14644 <_vfprintf_r+0xc2c>
							size += prec + 1;
   145a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   145a4:	e2833001 	add	r3, r3, #1
   145a8:	e51b205c 	ldr	r2, [fp, #-92]	; 0x5c
   145ac:	e0823003 	add	r3, r2, r3
   145b0:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   145b4:	ea000022 	b	14644 <_vfprintf_r+0xc2c>
					} else	/* "0.X" */
						size = (prec || flags & ALT)
							  ? prec + 2
							  : 1;
   145b8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   145bc:	e3530000 	cmp	r3, #0
   145c0:	1a000002 	bne	145d0 <_vfprintf_r+0xbb8>
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
   145c4:	e2063001 	and	r3, r6, #1
   145c8:	e3530000 	cmp	r3, #0
   145cc:	0a000002 	beq	145dc <_vfprintf_r+0xbc4>
							  ? prec + 2
							  : 1;
   145d0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   145d4:	e2833002 	add	r3, r3, #2
   145d8:	ea000000 	b	145e0 <_vfprintf_r+0xbc8>
   145dc:	e3a03001 	mov	r3, #1
					if (expt > 0) {
						size = expt;
						if (prec || flags & ALT)
							size += prec + 1;
					} else	/* "0.X" */
						size = (prec || flags & ALT)
   145e0:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   145e4:	ea000016 	b	14644 <_vfprintf_r+0xc2c>
							  ? prec + 2
							  : 1;
				} else if (expt >= ndig) { /* fixed g fmt */
   145e8:	e51b2098 	ldr	r2, [fp, #-152]	; 0x98
   145ec:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   145f0:	e1520003 	cmp	r2, r3
   145f4:	ba000008 	blt	1461c <_vfprintf_r+0xc04>
					size = expt;
   145f8:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   145fc:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
					if (flags & ALT)
   14600:	e2063001 	and	r3, r6, #1
   14604:	e3530000 	cmp	r3, #0
   14608:	0a00000d 	beq	14644 <_vfprintf_r+0xc2c>
						++size;
   1460c:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   14610:	e2833001 	add	r3, r3, #1
   14614:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   14618:	ea000009 	b	14644 <_vfprintf_r+0xc2c>
				} else
					size = ndig + (expt > 0 ?
   1461c:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
						1 : 2 - expt);
   14620:	e3530000 	cmp	r3, #0
   14624:	ca000002 	bgt	14634 <_vfprintf_r+0xc1c>
   14628:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1462c:	e2633002 	rsb	r3, r3, #2
   14630:	ea000000 	b	14638 <_vfprintf_r+0xc20>
   14634:	e3a03001 	mov	r3, #1
				} else if (expt >= ndig) { /* fixed g fmt */
					size = expt;
					if (flags & ALT)
						++size;
				} else
					size = ndig + (expt > 0 ?
   14638:	e51b20a4 	ldr	r2, [fp, #-164]	; 0xa4
   1463c:	e0833002 	add	r3, r3, r2
   14640:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
						1 : 2 - expt);
# ifdef _WANT_IO_C99_FORMATS
				if ((flags & GROUPING) && expt > 0) {
   14644:	e2063b01 	and	r3, r6, #1024	; 0x400
   14648:	e3530000 	cmp	r3, #0
   1464c:	0a000031 	beq	14718 <_vfprintf_r+0xd00>
   14650:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   14654:	e3530000 	cmp	r3, #0
   14658:	da00002e 	ble	14718 <_vfprintf_r+0xd00>
					/* space for thousands' grouping */
					nseps = nrepeats = 0;
   1465c:	e3a03000 	mov	r3, #0
   14660:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   14664:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   14668:	e50b3040 	str	r3, [fp, #-64]	; 0x40
					lead = expt;
   1466c:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   14670:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
					while (*grouping != CHAR_MAX) {
   14674:	ea00001a 	b	146e4 <_vfprintf_r+0xccc>
						if (lead <= *grouping)
   14678:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1467c:	e5d33000 	ldrb	r3, [r3]
   14680:	e1a02003 	mov	r2, r3
   14684:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   14688:	e1520003 	cmp	r2, r3
   1468c:	ba000000 	blt	14694 <_vfprintf_r+0xc7c>
							break;
   14690:	ea000017 	b	146f4 <_vfprintf_r+0xcdc>
						lead -= *grouping;
   14694:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   14698:	e5d33000 	ldrb	r3, [r3]
   1469c:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   146a0:	e0633002 	rsb	r3, r3, r2
   146a4:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
						if (grouping[1]) {
   146a8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   146ac:	e2833001 	add	r3, r3, #1
   146b0:	e5d33000 	ldrb	r3, [r3]
   146b4:	e3530000 	cmp	r3, #0
   146b8:	0a000006 	beq	146d8 <_vfprintf_r+0xcc0>
							nseps++;
   146bc:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   146c0:	e2833001 	add	r3, r3, #1
   146c4:	e50b3040 	str	r3, [fp, #-64]	; 0x40
							grouping++;
   146c8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   146cc:	e2833001 	add	r3, r3, #1
   146d0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   146d4:	ea000002 	b	146e4 <_vfprintf_r+0xccc>
						} else
							nrepeats++;
   146d8:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   146dc:	e2833001 	add	r3, r3, #1
   146e0:	e50b3044 	str	r3, [fp, #-68]	; 0x44
# ifdef _WANT_IO_C99_FORMATS
				if ((flags & GROUPING) && expt > 0) {
					/* space for thousands' grouping */
					nseps = nrepeats = 0;
					lead = expt;
					while (*grouping != CHAR_MAX) {
   146e4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   146e8:	e5d33000 	ldrb	r3, [r3]
   146ec:	e35300ff 	cmp	r3, #255	; 0xff
   146f0:	1affffe0 	bne	14678 <_vfprintf_r+0xc60>
							nseps++;
							grouping++;
						} else
							nrepeats++;
					}
					size += (nseps + nrepeats) * thsnd_len;
   146f4:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   146f8:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   146fc:	e0823003 	add	r3, r2, r3
   14700:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   14704:	e0020293 	mul	r2, r3, r2
   14708:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1470c:	e0823003 	add	r3, r2, r3
   14710:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   14714:	ea000001 	b	14720 <_vfprintf_r+0xd08>
				} else
# endif
					lead = expt;
   14718:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   1471c:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
			}

			if (softsign)
   14720:	e55b308a 	ldrb	r3, [fp, #-138]	; 0x8a
   14724:	e3530000 	cmp	r3, #0
   14728:	0a000002 	beq	14738 <_vfprintf_r+0xd20>
				sign = '-';
   1472c:	e3a0302d 	mov	r3, #45	; 0x2d
   14730:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
			break;
   14734:	ea0001f6 	b	14f14 <_vfprintf_r+0x14fc>
   14738:	ea0001f5 	b	14f14 <_vfprintf_r+0x14fc>
			flags &= ~LONGINT;
			goto string;
#endif
		case 'n':
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
   1473c:	e2063020 	and	r3, r6, #32
   14740:	e3530000 	cmp	r3, #0
   14744:	0a000008 	beq	1476c <_vfprintf_r+0xd54>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
   14748:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1474c:	e2832004 	add	r2, r3, #4
   14750:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14754:	e5931000 	ldr	r1, [r3]
   14758:	e51b3020 	ldr	r3, [fp, #-32]
   1475c:	e1a02003 	mov	r2, r3
   14760:	e1a03fc2 	asr	r3, r2, #31
   14764:	e881000c 	stm	r1, {r2, r3}
   14768:	ea000027 	b	1480c <_vfprintf_r+0xdf4>
			else
#endif
			if (flags & LONGINT)
   1476c:	e2063010 	and	r3, r6, #16
   14770:	e3530000 	cmp	r3, #0
   14774:	0a000006 	beq	14794 <_vfprintf_r+0xd7c>
				*GET_ARG (N, ap, long_ptr_t) = ret;
   14778:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1477c:	e2832004 	add	r2, r3, #4
   14780:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14784:	e5933000 	ldr	r3, [r3]
   14788:	e51b2020 	ldr	r2, [fp, #-32]
   1478c:	e5832000 	str	r2, [r3]
   14790:	ea00001d 	b	1480c <_vfprintf_r+0xdf4>
			else if (flags & SHORTINT)
   14794:	e2063040 	and	r3, r6, #64	; 0x40
   14798:	e3530000 	cmp	r3, #0
   1479c:	0a000008 	beq	147c4 <_vfprintf_r+0xdac>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   147a0:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   147a4:	e2832004 	add	r2, r3, #4
   147a8:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   147ac:	e5933000 	ldr	r3, [r3]
   147b0:	e51b2020 	ldr	r2, [fp, #-32]
   147b4:	e1a02802 	lsl	r2, r2, #16
   147b8:	e1a02822 	lsr	r2, r2, #16
   147bc:	e1c320b0 	strh	r2, [r3]
   147c0:	ea000011 	b	1480c <_vfprintf_r+0xdf4>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
   147c4:	e2063c02 	and	r3, r6, #512	; 0x200
   147c8:	e3530000 	cmp	r3, #0
   147cc:	0a000007 	beq	147f0 <_vfprintf_r+0xdd8>
				*GET_ARG (N, ap, char_ptr_t) = ret;
   147d0:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   147d4:	e2832004 	add	r2, r3, #4
   147d8:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   147dc:	e5933000 	ldr	r3, [r3]
   147e0:	e51b2020 	ldr	r2, [fp, #-32]
   147e4:	e20220ff 	and	r2, r2, #255	; 0xff
   147e8:	e5c32000 	strb	r2, [r3]
   147ec:	ea000006 	b	1480c <_vfprintf_r+0xdf4>
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
   147f0:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   147f4:	e2832004 	add	r2, r3, #4
   147f8:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   147fc:	e5933000 	ldr	r3, [r3]
   14800:	e51b2020 	ldr	r2, [fp, #-32]
   14804:	e5832000 	str	r2, [r3]
			continue;	/* no output */
   14808:	ea0006dc 	b	16380 <_vfprintf_r+0x2968>
   1480c:	ea0006db 	b	16380 <_vfprintf_r+0x2968>
		case 'O': /* extension */
			flags |= LONGINT;
   14810:	e3866010 	orr	r6, r6, #16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   14814:	e2063020 	and	r3, r6, #32
   14818:	e3530000 	cmp	r3, #0
   1481c:	0a000006 	beq	1483c <_vfprintf_r+0xe24>
   14820:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14824:	e2833007 	add	r3, r3, #7
   14828:	e3c33007 	bic	r3, r3, #7
   1482c:	e2832008 	add	r2, r3, #8
   14830:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14834:	e893000c 	ldm	r3, {r2, r3}
   14838:	ea000027 	b	148dc <_vfprintf_r+0xec4>
   1483c:	e2063010 	and	r3, r6, #16
   14840:	e3530000 	cmp	r3, #0
   14844:	0a000006 	beq	14864 <_vfprintf_r+0xe4c>
   14848:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   1484c:	e2832004 	add	r2, r3, #4
   14850:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14854:	e5933000 	ldr	r3, [r3]
   14858:	e1a02003 	mov	r2, r3
   1485c:	e3a03000 	mov	r3, #0
   14860:	ea00001d 	b	148dc <_vfprintf_r+0xec4>
   14864:	e2063040 	and	r3, r6, #64	; 0x40
   14868:	e3530000 	cmp	r3, #0
   1486c:	0a000009 	beq	14898 <_vfprintf_r+0xe80>
   14870:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14874:	e2832004 	add	r2, r3, #4
   14878:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1487c:	e5933000 	ldr	r3, [r3]
   14880:	e1a03803 	lsl	r3, r3, #16
   14884:	e1a01823 	lsr	r1, r3, #16
   14888:	e1a03001 	mov	r3, r1
   1488c:	e1a02003 	mov	r2, r3
   14890:	e3a03000 	mov	r3, #0
   14894:	ea000010 	b	148dc <_vfprintf_r+0xec4>
   14898:	e2063c02 	and	r3, r6, #512	; 0x200
   1489c:	e3530000 	cmp	r3, #0
   148a0:	0a000007 	beq	148c4 <_vfprintf_r+0xeac>
   148a4:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   148a8:	e2832004 	add	r2, r3, #4
   148ac:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   148b0:	e5933000 	ldr	r3, [r3]
   148b4:	e20330ff 	and	r3, r3, #255	; 0xff
   148b8:	e20320ff 	and	r2, r3, #255	; 0xff
   148bc:	e3a03000 	mov	r3, #0
   148c0:	ea000005 	b	148dc <_vfprintf_r+0xec4>
   148c4:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   148c8:	e2832004 	add	r2, r3, #4
   148cc:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   148d0:	e5933000 	ldr	r3, [r3]
   148d4:	e1a02003 	mov	r2, r3
   148d8:	e3a03000 	mov	r3, #0
   148dc:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   148e0:	e50b3048 	str	r3, [fp, #-72]	; 0x48
			base = OCT;
   148e4:	e3a03000 	mov	r3, #0
   148e8:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
   148ec:	e3c66b01 	bic	r6, r6, #1024	; 0x400
#endif
			goto nosign;
   148f0:	ea0000c2 	b	14c00 <_vfprintf_r+0x11e8>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   148f4:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   148f8:	e2832004 	add	r2, r3, #4
   148fc:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14900:	e5933000 	ldr	r3, [r3]
   14904:	e1a02003 	mov	r2, r3
   14908:	e3a03000 	mov	r3, #0
   1490c:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   14910:	e50b3048 	str	r3, [fp, #-72]	; 0x48
			base = HEX;
   14914:	e3a03002 	mov	r3, #2
   14918:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
			xdigs = "0123456789abcdef";
   1491c:	e59f3a00 	ldr	r3, [pc, #2560]	; 15324 <_vfprintf_r+0x190c>
   14920:	e50b3060 	str	r3, [fp, #-96]	; 0x60
			flags |= HEXPREFIX;
   14924:	e3866002 	orr	r6, r6, #2
			ox[0] = '0';
   14928:	e3a03030 	mov	r3, #48	; 0x30
   1492c:	e54b3158 	strb	r3, [fp, #-344]	; 0x158
			ox[1] = ch = 'x';
   14930:	e3a08078 	mov	r8, #120	; 0x78
   14934:	e3a03078 	mov	r3, #120	; 0x78
   14938:	e54b3157 	strb	r3, [fp, #-343]	; 0x157
			goto nosign;
   1493c:	ea0000af 	b	14c00 <_vfprintf_r+0x11e8>
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   14940:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14944:	e2832004 	add	r2, r3, #4
   14948:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   1494c:	e5937000 	ldr	r7, [r3]
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
   14950:	e3a03000 	mov	r3, #0
   14954:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
   14958:	e3570000 	cmp	r7, #0
   1495c:	1a000006 	bne	1497c <_vfprintf_r+0xf64>
				cp = "(null)";
   14960:	e59f79c0 	ldr	r7, [pc, #2496]	; 15328 <_vfprintf_r+0x1910>
				size = ((unsigned) prec > 6U) ? 6 : prec;
   14964:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   14968:	e3530006 	cmp	r3, #6
   1496c:	31a03003 	movcc	r3, r3
   14970:	23a03006 	movcs	r3, #6
   14974:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   14978:	ea00001f 	b	149fc <_vfprintf_r+0xfe4>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
   1497c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   14980:	e3530000 	cmp	r3, #0
   14984:	ba000017 	blt	149e8 <_vfprintf_r+0xfd0>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
   14988:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1498c:	e1a00007 	mov	r0, r7
   14990:	e3a01000 	mov	r1, #0
   14994:	e1a02003 	mov	r2, r3
   14998:	eb00188d 	bl	1abd4 <memchr>
   1499c:	e50b0084 	str	r0, [fp, #-132]	; 0x84

				if (p != NULL) {
   149a0:	e51b3084 	ldr	r3, [fp, #-132]	; 0x84
   149a4:	e3530000 	cmp	r3, #0
   149a8:	0a00000a 	beq	149d8 <_vfprintf_r+0xfc0>
					size = p - cp;
   149ac:	e51b2084 	ldr	r2, [fp, #-132]	; 0x84
   149b0:	e1a03007 	mov	r3, r7
   149b4:	e0633002 	rsb	r3, r3, r2
   149b8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
					if (size > prec)
   149bc:	e51b205c 	ldr	r2, [fp, #-92]	; 0x5c
   149c0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   149c4:	e1520003 	cmp	r2, r3
   149c8:	da000005 	ble	149e4 <_vfprintf_r+0xfcc>
						size = prec;
   149cc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   149d0:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   149d4:	ea000008 	b	149fc <_vfprintf_r+0xfe4>
				} else
					size = prec;
   149d8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   149dc:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   149e0:	ea000005 	b	149fc <_vfprintf_r+0xfe4>
   149e4:	ea000004 	b	149fc <_vfprintf_r+0xfe4>
			} else
				size = strlen (cp);
   149e8:	e1a00007 	mov	r0, r7
   149ec:	ebffeffe 	bl	109ec <strlen>
   149f0:	e1a03000 	mov	r3, r0
   149f4:	e50b305c 	str	r3, [fp, #-92]	; 0x5c

			break;
   149f8:	ea000145 	b	14f14 <_vfprintf_r+0x14fc>
   149fc:	ea000144 	b	14f14 <_vfprintf_r+0x14fc>
		case 'U': /* extension */
			flags |= LONGINT;
   14a00:	e3866010 	orr	r6, r6, #16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   14a04:	e2063020 	and	r3, r6, #32
   14a08:	e3530000 	cmp	r3, #0
   14a0c:	0a000006 	beq	14a2c <_vfprintf_r+0x1014>
   14a10:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14a14:	e2833007 	add	r3, r3, #7
   14a18:	e3c33007 	bic	r3, r3, #7
   14a1c:	e2832008 	add	r2, r3, #8
   14a20:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14a24:	e893000c 	ldm	r3, {r2, r3}
   14a28:	ea000027 	b	14acc <_vfprintf_r+0x10b4>
   14a2c:	e2063010 	and	r3, r6, #16
   14a30:	e3530000 	cmp	r3, #0
   14a34:	0a000006 	beq	14a54 <_vfprintf_r+0x103c>
   14a38:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14a3c:	e2832004 	add	r2, r3, #4
   14a40:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14a44:	e5933000 	ldr	r3, [r3]
   14a48:	e1a02003 	mov	r2, r3
   14a4c:	e3a03000 	mov	r3, #0
   14a50:	ea00001d 	b	14acc <_vfprintf_r+0x10b4>
   14a54:	e2063040 	and	r3, r6, #64	; 0x40
   14a58:	e3530000 	cmp	r3, #0
   14a5c:	0a000009 	beq	14a88 <_vfprintf_r+0x1070>
   14a60:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14a64:	e2832004 	add	r2, r3, #4
   14a68:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14a6c:	e5933000 	ldr	r3, [r3]
   14a70:	e1a03803 	lsl	r3, r3, #16
   14a74:	e1a01823 	lsr	r1, r3, #16
   14a78:	e1a03001 	mov	r3, r1
   14a7c:	e1a02003 	mov	r2, r3
   14a80:	e3a03000 	mov	r3, #0
   14a84:	ea000010 	b	14acc <_vfprintf_r+0x10b4>
   14a88:	e2063c02 	and	r3, r6, #512	; 0x200
   14a8c:	e3530000 	cmp	r3, #0
   14a90:	0a000007 	beq	14ab4 <_vfprintf_r+0x109c>
   14a94:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14a98:	e2832004 	add	r2, r3, #4
   14a9c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14aa0:	e5933000 	ldr	r3, [r3]
   14aa4:	e20330ff 	and	r3, r3, #255	; 0xff
   14aa8:	e20320ff 	and	r2, r3, #255	; 0xff
   14aac:	e3a03000 	mov	r3, #0
   14ab0:	ea000005 	b	14acc <_vfprintf_r+0x10b4>
   14ab4:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14ab8:	e2832004 	add	r2, r3, #4
   14abc:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14ac0:	e5933000 	ldr	r3, [r3]
   14ac4:	e1a02003 	mov	r2, r3
   14ac8:	e3a03000 	mov	r3, #0
   14acc:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   14ad0:	e50b3048 	str	r3, [fp, #-72]	; 0x48
			base = DEC;
   14ad4:	e3a03001 	mov	r3, #1
   14ad8:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
			goto nosign;
   14adc:	ea000047 	b	14c00 <_vfprintf_r+0x11e8>
		case 'X':
			xdigs = "0123456789ABCDEF";
   14ae0:	e59f3844 	ldr	r3, [pc, #2116]	; 1532c <_vfprintf_r+0x1914>
   14ae4:	e50b3060 	str	r3, [fp, #-96]	; 0x60
			goto hex;
   14ae8:	ea000001 	b	14af4 <_vfprintf_r+0x10dc>
		case 'x':
			xdigs = "0123456789abcdef";
   14aec:	e59f3830 	ldr	r3, [pc, #2096]	; 15324 <_vfprintf_r+0x190c>
   14af0:	e50b3060 	str	r3, [fp, #-96]	; 0x60
hex:			_uquad = UARG ();
   14af4:	e2063020 	and	r3, r6, #32
   14af8:	e3530000 	cmp	r3, #0
   14afc:	0a000006 	beq	14b1c <_vfprintf_r+0x1104>
   14b00:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14b04:	e2833007 	add	r3, r3, #7
   14b08:	e3c33007 	bic	r3, r3, #7
   14b0c:	e2832008 	add	r2, r3, #8
   14b10:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14b14:	e893000c 	ldm	r3, {r2, r3}
   14b18:	ea000027 	b	14bbc <_vfprintf_r+0x11a4>
   14b1c:	e2063010 	and	r3, r6, #16
   14b20:	e3530000 	cmp	r3, #0
   14b24:	0a000006 	beq	14b44 <_vfprintf_r+0x112c>
   14b28:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14b2c:	e2832004 	add	r2, r3, #4
   14b30:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14b34:	e5933000 	ldr	r3, [r3]
   14b38:	e1a02003 	mov	r2, r3
   14b3c:	e3a03000 	mov	r3, #0
   14b40:	ea00001d 	b	14bbc <_vfprintf_r+0x11a4>
   14b44:	e2063040 	and	r3, r6, #64	; 0x40
   14b48:	e3530000 	cmp	r3, #0
   14b4c:	0a000009 	beq	14b78 <_vfprintf_r+0x1160>
   14b50:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14b54:	e2832004 	add	r2, r3, #4
   14b58:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14b5c:	e5933000 	ldr	r3, [r3]
   14b60:	e1a03803 	lsl	r3, r3, #16
   14b64:	e1a01823 	lsr	r1, r3, #16
   14b68:	e1a03001 	mov	r3, r1
   14b6c:	e1a02003 	mov	r2, r3
   14b70:	e3a03000 	mov	r3, #0
   14b74:	ea000010 	b	14bbc <_vfprintf_r+0x11a4>
   14b78:	e2063c02 	and	r3, r6, #512	; 0x200
   14b7c:	e3530000 	cmp	r3, #0
   14b80:	0a000007 	beq	14ba4 <_vfprintf_r+0x118c>
   14b84:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14b88:	e2832004 	add	r2, r3, #4
   14b8c:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14b90:	e5933000 	ldr	r3, [r3]
   14b94:	e20330ff 	and	r3, r3, #255	; 0xff
   14b98:	e20320ff 	and	r2, r3, #255	; 0xff
   14b9c:	e3a03000 	mov	r3, #0
   14ba0:	ea000005 	b	14bbc <_vfprintf_r+0x11a4>
   14ba4:	e51b316c 	ldr	r3, [fp, #-364]	; 0x16c
   14ba8:	e2832004 	add	r2, r3, #4
   14bac:	e50b216c 	str	r2, [fp, #-364]	; 0x16c
   14bb0:	e5933000 	ldr	r3, [r3]
   14bb4:	e1a02003 	mov	r2, r3
   14bb8:	e3a03000 	mov	r3, #0
   14bbc:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   14bc0:	e50b3048 	str	r3, [fp, #-72]	; 0x48
			base = HEX;
   14bc4:	e3a03002 	mov	r3, #2
   14bc8:	e54b304d 	strb	r3, [fp, #-77]	; 0x4d
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
   14bcc:	e2063001 	and	r3, r6, #1
   14bd0:	e3530000 	cmp	r3, #0
   14bd4:	0a000008 	beq	14bfc <_vfprintf_r+0x11e4>
   14bd8:	e24b304c 	sub	r3, fp, #76	; 0x4c
   14bdc:	e893000c 	ldm	r3, {r2, r3}
   14be0:	e1921003 	orrs	r1, r2, r3
   14be4:	0a000004 	beq	14bfc <_vfprintf_r+0x11e4>
				ox[0] = '0';
   14be8:	e3a03030 	mov	r3, #48	; 0x30
   14bec:	e54b3158 	strb	r3, [fp, #-344]	; 0x158
				ox[1] = ch;
   14bf0:	e20830ff 	and	r3, r8, #255	; 0xff
   14bf4:	e54b3157 	strb	r3, [fp, #-343]	; 0x157
				flags |= HEXPREFIX;
   14bf8:	e3866002 	orr	r6, r6, #2
			}

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
   14bfc:	e3c66b01 	bic	r6, r6, #1024	; 0x400
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   14c00:	e3a03000 	mov	r3, #0
   14c04:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   14c08:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   14c0c:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   14c10:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   14c14:	e3530000 	cmp	r3, #0
   14c18:	ba000000 	blt	14c20 <_vfprintf_r+0x1208>
				flags &= ~ZEROPAD;
   14c1c:	e3c66080 	bic	r6, r6, #128	; 0x80
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   14c20:	e24b7f55 	sub	r7, fp, #340	; 0x154
   14c24:	e2877064 	add	r7, r7, #100	; 0x64
			if (_uquad != 0 || prec != 0) {
   14c28:	e24b304c 	sub	r3, fp, #76	; 0x4c
   14c2c:	e893000c 	ldm	r3, {r2, r3}
   14c30:	e1921003 	orrs	r1, r2, r3
   14c34:	1a000002 	bne	14c44 <_vfprintf_r+0x122c>
   14c38:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   14c3c:	e3530000 	cmp	r3, #0
   14c40:	0a000099 	beq	14eac <_vfprintf_r+0x1494>
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   14c44:	e55b304d 	ldrb	r3, [fp, #-77]	; 0x4d
   14c48:	e3530001 	cmp	r3, #1
   14c4c:	0a000026 	beq	14cec <_vfprintf_r+0x12d4>
   14c50:	e3530002 	cmp	r3, #2
   14c54:	0a000073 	beq	14e28 <_vfprintf_r+0x1410>
   14c58:	e3530000 	cmp	r3, #0
   14c5c:	1a00008a 	bne	14e8c <_vfprintf_r+0x1474>
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   14c60:	e2477001 	sub	r7, r7, #1
   14c64:	e55b304c 	ldrb	r3, [fp, #-76]	; 0x4c
   14c68:	e2033007 	and	r3, r3, #7
   14c6c:	e20330ff 	and	r3, r3, #255	; 0xff
   14c70:	e2833030 	add	r3, r3, #48	; 0x30
   14c74:	e20330ff 	and	r3, r3, #255	; 0xff
   14c78:	e5c73000 	strb	r3, [r7]
						_uquad >>= 3;
   14c7c:	e24b304c 	sub	r3, fp, #76	; 0x4c
   14c80:	e893000c 	ldm	r3, {r2, r3}
   14c84:	e1a011a2 	lsr	r1, r2, #3
   14c88:	e50b1174 	str	r1, [fp, #-372]	; 0x174
   14c8c:	e51b1174 	ldr	r1, [fp, #-372]	; 0x174
   14c90:	e1811e83 	orr	r1, r1, r3, lsl #29
   14c94:	e50b1174 	str	r1, [fp, #-372]	; 0x174
   14c98:	e1a011a3 	lsr	r1, r3, #3
   14c9c:	e50b1170 	str	r1, [fp, #-368]	; 0x170
   14ca0:	e24b3f5d 	sub	r3, fp, #372	; 0x174
   14ca4:	e893000c 	ldm	r3, {r2, r3}
   14ca8:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   14cac:	e50b3048 	str	r3, [fp, #-72]	; 0x48
					} while (_uquad);
   14cb0:	e24b304c 	sub	r3, fp, #76	; 0x4c
   14cb4:	e893000c 	ldm	r3, {r2, r3}
   14cb8:	e1921003 	orrs	r1, r2, r3
   14cbc:	1affffe7 	bne	14c60 <_vfprintf_r+0x1248>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
   14cc0:	e2063001 	and	r3, r6, #1
   14cc4:	e3530000 	cmp	r3, #0
   14cc8:	0a000006 	beq	14ce8 <_vfprintf_r+0x12d0>
   14ccc:	e5d73000 	ldrb	r3, [r7]
   14cd0:	e3530030 	cmp	r3, #48	; 0x30
   14cd4:	0a000003 	beq	14ce8 <_vfprintf_r+0x12d0>
						*--cp = '0';
   14cd8:	e2477001 	sub	r7, r7, #1
   14cdc:	e3a03030 	mov	r3, #48	; 0x30
   14ce0:	e5c73000 	strb	r3, [r7]
					break;
   14ce4:	ea00006f 	b	14ea8 <_vfprintf_r+0x1490>
   14ce8:	ea00006e 	b	14ea8 <_vfprintf_r+0x1490>

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   14cec:	e24b304c 	sub	r3, fp, #76	; 0x4c
   14cf0:	e893000c 	ldm	r3, {r2, r3}
   14cf4:	e3530000 	cmp	r3, #0
   14cf8:	03520009 	cmpeq	r2, #9
   14cfc:	8a000005 	bhi	14d18 <_vfprintf_r+0x1300>
						*--cp = to_char(_uquad);
   14d00:	e2477001 	sub	r7, r7, #1
   14d04:	e55b304c 	ldrb	r3, [fp, #-76]	; 0x4c
   14d08:	e2833030 	add	r3, r3, #48	; 0x30
   14d0c:	e20330ff 	and	r3, r3, #255	; 0xff
   14d10:	e5c73000 	strb	r3, [r7]
						break;
   14d14:	ea000063 	b	14ea8 <_vfprintf_r+0x1490>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
   14d18:	e3a03000 	mov	r3, #0
   14d1c:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   14d20:	e2477001 	sub	r7, r7, #1
   14d24:	e24b304c 	sub	r3, fp, #76	; 0x4c
   14d28:	e893000c 	ldm	r3, {r2, r3}
   14d2c:	e1a00002 	mov	r0, r2
   14d30:	e1a01003 	mov	r1, r3
   14d34:	e3a0200a 	mov	r2, #10
   14d38:	e3a03000 	mov	r3, #0
   14d3c:	ebffe412 	bl	dd8c <__aeabi_uldivmod>
   14d40:	e20230ff 	and	r3, r2, #255	; 0xff
   14d44:	e2833030 	add	r3, r3, #48	; 0x30
   14d48:	e20330ff 	and	r3, r3, #255	; 0xff
   14d4c:	e5c73000 	strb	r3, [r7]
#ifdef _WANT_IO_C99_FORMATS
					  ndig++;
   14d50:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   14d54:	e2833001 	add	r3, r3, #1
   14d58:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
					  /* If (*grouping == CHAR_MAX) then no
					     more grouping */
					  if ((flags & GROUPING)
   14d5c:	e2063b01 	and	r3, r6, #1024	; 0x400
   14d60:	e3530000 	cmp	r3, #0
   14d64:	0a00001f 	beq	14de8 <_vfprintf_r+0x13d0>
					      && ndig == *grouping
   14d68:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   14d6c:	e5d33000 	ldrb	r3, [r3]
   14d70:	e1a02003 	mov	r2, r3
   14d74:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   14d78:	e1520003 	cmp	r2, r3
   14d7c:	1a000019 	bne	14de8 <_vfprintf_r+0x13d0>
					      && *grouping != CHAR_MAX
   14d80:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   14d84:	e5d33000 	ldrb	r3, [r3]
   14d88:	e35300ff 	cmp	r3, #255	; 0xff
   14d8c:	0a000015 	beq	14de8 <_vfprintf_r+0x13d0>
					      && _uquad > 9) {
   14d90:	e24b304c 	sub	r3, fp, #76	; 0x4c
   14d94:	e893000c 	ldm	r3, {r2, r3}
   14d98:	e3530000 	cmp	r3, #0
   14d9c:	03520009 	cmpeq	r2, #9
   14da0:	9a000010 	bls	14de8 <_vfprintf_r+0x13d0>
					    cp -= thsnd_len;
   14da4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   14da8:	e2633000 	rsb	r3, r3, #0
   14dac:	e0877003 	add	r7, r7, r3
					    strncpy (cp, thousands_sep,
   14db0:	e1a00007 	mov	r0, r7
   14db4:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
   14db8:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   14dbc:	eb00249a 	bl	1e02c <strncpy>
						     thsnd_len);
					    ndig = 0;
   14dc0:	e3a03000 	mov	r3, #0
   14dc4:	e50b30a4 	str	r3, [fp, #-164]	; 0xa4
					    /* If (grouping[1] == '\0') then we
					       have to use *grouping character
					       (last grouping rule) for all
					       next cases. */
					    if (grouping[1] != '\0')
   14dc8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   14dcc:	e2833001 	add	r3, r3, #1
   14dd0:	e5d33000 	ldrb	r3, [r3]
   14dd4:	e3530000 	cmp	r3, #0
   14dd8:	0a000002 	beq	14de8 <_vfprintf_r+0x13d0>
					      grouping++;
   14ddc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   14de0:	e2833001 	add	r3, r3, #1
   14de4:	e50b3034 	str	r3, [fp, #-52]	; 0x34
					  }
#endif
					  _uquad /= 10;
   14de8:	e24b304c 	sub	r3, fp, #76	; 0x4c
   14dec:	e893000c 	ldm	r3, {r2, r3}
   14df0:	e1a00002 	mov	r0, r2
   14df4:	e1a01003 	mov	r1, r3
   14df8:	e3a0200a 	mov	r2, #10
   14dfc:	e3a03000 	mov	r3, #0
   14e00:	ebffe3e1 	bl	dd8c <__aeabi_uldivmod>
   14e04:	e1a02000 	mov	r2, r0
   14e08:	e1a03001 	mov	r3, r1
   14e0c:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   14e10:	e50b3048 	str	r3, [fp, #-72]	; 0x48
					} while (_uquad != 0);
   14e14:	e24b304c 	sub	r3, fp, #76	; 0x4c
   14e18:	e893000c 	ldm	r3, {r2, r3}
   14e1c:	e1921003 	orrs	r1, r2, r3
   14e20:	1affffbe 	bne	14d20 <_vfprintf_r+0x1308>
					break;
   14e24:	ea00001f 	b	14ea8 <_vfprintf_r+0x1490>

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   14e28:	e2477001 	sub	r7, r7, #1
   14e2c:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   14e30:	e203300f 	and	r3, r3, #15
   14e34:	e51b2060 	ldr	r2, [fp, #-96]	; 0x60
   14e38:	e0823003 	add	r3, r2, r3
   14e3c:	e5d33000 	ldrb	r3, [r3]
   14e40:	e5c73000 	strb	r3, [r7]
						_uquad >>= 4;
   14e44:	e24b304c 	sub	r3, fp, #76	; 0x4c
   14e48:	e893000c 	ldm	r3, {r2, r3}
   14e4c:	e1a01222 	lsr	r1, r2, #4
   14e50:	e50b117c 	str	r1, [fp, #-380]	; 0x17c
   14e54:	e51b117c 	ldr	r1, [fp, #-380]	; 0x17c
   14e58:	e1811e03 	orr	r1, r1, r3, lsl #28
   14e5c:	e50b117c 	str	r1, [fp, #-380]	; 0x17c
   14e60:	e1a01223 	lsr	r1, r3, #4
   14e64:	e50b1178 	str	r1, [fp, #-376]	; 0x178
   14e68:	e24b3f5f 	sub	r3, fp, #380	; 0x17c
   14e6c:	e893000c 	ldm	r3, {r2, r3}
   14e70:	e50b204c 	str	r2, [fp, #-76]	; 0x4c
   14e74:	e50b3048 	str	r3, [fp, #-72]	; 0x48
					} while (_uquad);
   14e78:	e24b304c 	sub	r3, fp, #76	; 0x4c
   14e7c:	e893000c 	ldm	r3, {r2, r3}
   14e80:	e1921003 	orrs	r1, r2, r3
   14e84:	1affffe7 	bne	14e28 <_vfprintf_r+0x1410>
					break;
   14e88:	ea000006 	b	14ea8 <_vfprintf_r+0x1490>

				default:
					cp = "bug in vfprintf: bad base";
   14e8c:	e59f749c 	ldr	r7, [pc, #1180]	; 15330 <_vfprintf_r+0x1918>
					size = strlen (cp);
   14e90:	e1a00007 	mov	r0, r7
   14e94:	ebffeed4 	bl	109ec <strlen>
   14e98:	e1a03000 	mov	r3, r0
   14e9c:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
					goto skipsize;
   14ea0:	e1a00000 	nop			; (mov r0, r0)
                       else if (base == OCT && (flags & ALT))
                         *--cp = '0';

			size = buf + BUF - cp;
		skipsize:
			break;
   14ea4:	ea00001a 	b	14f14 <_vfprintf_r+0x14fc>
				default:
					cp = "bug in vfprintf: bad base";
					size = strlen (cp);
					goto skipsize;
				}
			}
   14ea8:	ea000008 	b	14ed0 <_vfprintf_r+0x14b8>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   14eac:	e55b304d 	ldrb	r3, [fp, #-77]	; 0x4d
   14eb0:	e3530000 	cmp	r3, #0
   14eb4:	1a000005 	bne	14ed0 <_vfprintf_r+0x14b8>
   14eb8:	e2063001 	and	r3, r6, #1
   14ebc:	e3530000 	cmp	r3, #0
   14ec0:	0a000002 	beq	14ed0 <_vfprintf_r+0x14b8>
                         *--cp = '0';
   14ec4:	e2477001 	sub	r7, r7, #1
   14ec8:	e3a03030 	mov	r3, #48	; 0x30
   14ecc:	e5c73000 	strb	r3, [r7]

			size = buf + BUF - cp;
   14ed0:	e24b3f55 	sub	r3, fp, #340	; 0x154
   14ed4:	e2833064 	add	r3, r3, #100	; 0x64
   14ed8:	e1a02007 	mov	r2, r7
   14edc:	e0623003 	rsb	r3, r2, r3
   14ee0:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
		skipsize:
			break;
   14ee4:	ea00000a 	b	14f14 <_vfprintf_r+0x14fc>
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
   14ee8:	e3580000 	cmp	r8, #0
   14eec:	1a000000 	bne	14ef4 <_vfprintf_r+0x14dc>
				goto done;
   14ef0:	ea000523 	b	16384 <_vfprintf_r+0x296c>
			/* pretend it was %c with argument ch */
			cp = buf;
   14ef4:	e24b7f55 	sub	r7, fp, #340	; 0x154
			*cp = ch;
   14ef8:	e20830ff 	and	r3, r8, #255	; 0xff
   14efc:	e5c73000 	strb	r3, [r7]
			size = 1;
   14f00:	e3a03001 	mov	r3, #1
   14f04:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
			sign = '\0';
   14f08:	e3a03000 	mov	r3, #0
   14f0c:	e54b3089 	strb	r3, [fp, #-137]	; 0x89
			break;
   14f10:	e1a00000 	nop			; (mov r0, r0)
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
   14f14:	e51b205c 	ldr	r2, [fp, #-92]	; 0x5c
   14f18:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   14f1c:	e1520003 	cmp	r2, r3
   14f20:	a1a03002 	movge	r3, r2
   14f24:	b1a03003 	movlt	r3, r3
   14f28:	e50b3058 	str	r3, [fp, #-88]	; 0x58
		if (sign)
   14f2c:	e55b3089 	ldrb	r3, [fp, #-137]	; 0x89
   14f30:	e3530000 	cmp	r3, #0
   14f34:	0a000002 	beq	14f44 <_vfprintf_r+0x152c>
			realsz++;
   14f38:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   14f3c:	e2833001 	add	r3, r3, #1
   14f40:	e50b3058 	str	r3, [fp, #-88]	; 0x58
		if (flags & HEXPREFIX)
   14f44:	e2063002 	and	r3, r6, #2
   14f48:	e3530000 	cmp	r3, #0
   14f4c:	0a000002 	beq	14f5c <_vfprintf_r+0x1544>
			realsz+= 2;
   14f50:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   14f54:	e2833002 	add	r3, r3, #2
   14f58:	e50b3058 	str	r3, [fp, #-88]	; 0x58

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   14f5c:	e2063084 	and	r3, r6, #132	; 0x84
   14f60:	e3530000 	cmp	r3, #0
   14f64:	1a00003a 	bne	15054 <_vfprintf_r+0x163c>
			PAD (width - realsz, blanks);
   14f68:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   14f6c:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   14f70:	e0635002 	rsb	r5, r3, r2
   14f74:	e3550000 	cmp	r5, #0
   14f78:	da000035 	ble	15054 <_vfprintf_r+0x163c>
   14f7c:	ea000019 	b	14fe8 <_vfprintf_r+0x15d0>
   14f80:	e59f33b4 	ldr	r3, [pc, #948]	; 1533c <_vfprintf_r+0x1924>
   14f84:	e5843000 	str	r3, [r4]
   14f88:	e3a03010 	mov	r3, #16
   14f8c:	e5843004 	str	r3, [r4, #4]
   14f90:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   14f94:	e2833010 	add	r3, r3, #16
   14f98:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   14f9c:	e2844008 	add	r4, r4, #8
   14fa0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   14fa4:	e2833001 	add	r3, r3, #1
   14fa8:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   14fac:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   14fb0:	e3530007 	cmp	r3, #7
   14fb4:	da00000a 	ble	14fe4 <_vfprintf_r+0x15cc>
   14fb8:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   14fbc:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   14fc0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   14fc4:	e1a01002 	mov	r1, r2
   14fc8:	e1a02003 	mov	r2, r3
   14fcc:	eb002a66 	bl	1f96c <__sprint_r>
   14fd0:	e1a03000 	mov	r3, r0
   14fd4:	e3530000 	cmp	r3, #0
   14fd8:	0a000000 	beq	14fe0 <_vfprintf_r+0x15c8>
   14fdc:	ea0004f8 	b	163c4 <_vfprintf_r+0x29ac>
   14fe0:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   14fe4:	e2455010 	sub	r5, r5, #16
   14fe8:	e3550010 	cmp	r5, #16
   14fec:	caffffe3 	bgt	14f80 <_vfprintf_r+0x1568>
   14ff0:	e59f3344 	ldr	r3, [pc, #836]	; 1533c <_vfprintf_r+0x1924>
   14ff4:	e5843000 	str	r3, [r4]
   14ff8:	e1a03005 	mov	r3, r5
   14ffc:	e5843004 	str	r3, [r4, #4]
   15000:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   15004:	e0833005 	add	r3, r3, r5
   15008:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1500c:	e2844008 	add	r4, r4, #8
   15010:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15014:	e2833001 	add	r3, r3, #1
   15018:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1501c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15020:	e3530007 	cmp	r3, #7
   15024:	da00000a 	ble	15054 <_vfprintf_r+0x163c>
   15028:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1502c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15030:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15034:	e1a01002 	mov	r1, r2
   15038:	e1a02003 	mov	r2, r3
   1503c:	eb002a4a 	bl	1f96c <__sprint_r>
   15040:	e1a03000 	mov	r3, r0
   15044:	e3530000 	cmp	r3, #0
   15048:	0a000000 	beq	15050 <_vfprintf_r+0x1638>
   1504c:	ea0004dc 	b	163c4 <_vfprintf_r+0x29ac>
   15050:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* prefix */
		if (sign)
   15054:	e55b3089 	ldrb	r3, [fp, #-137]	; 0x89
   15058:	e3530000 	cmp	r3, #0
   1505c:	0a000018 	beq	150c4 <_vfprintf_r+0x16ac>
			PRINT (&sign, 1);
   15060:	e24b3089 	sub	r3, fp, #137	; 0x89
   15064:	e5843000 	str	r3, [r4]
   15068:	e3a03001 	mov	r3, #1
   1506c:	e5843004 	str	r3, [r4, #4]
   15070:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   15074:	e2833001 	add	r3, r3, #1
   15078:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1507c:	e2844008 	add	r4, r4, #8
   15080:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15084:	e2833001 	add	r3, r3, #1
   15088:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1508c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15090:	e3530007 	cmp	r3, #7
   15094:	da00000a 	ble	150c4 <_vfprintf_r+0x16ac>
   15098:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1509c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   150a0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   150a4:	e1a01002 	mov	r1, r2
   150a8:	e1a02003 	mov	r2, r3
   150ac:	eb002a2e 	bl	1f96c <__sprint_r>
   150b0:	e1a03000 	mov	r3, r0
   150b4:	e3530000 	cmp	r3, #0
   150b8:	0a000000 	beq	150c0 <_vfprintf_r+0x16a8>
   150bc:	ea0004c0 	b	163c4 <_vfprintf_r+0x29ac>
   150c0:	e24b40f0 	sub	r4, fp, #240	; 0xf0
		if (flags & HEXPREFIX)
   150c4:	e2063002 	and	r3, r6, #2
   150c8:	e3530000 	cmp	r3, #0
   150cc:	0a000018 	beq	15134 <_vfprintf_r+0x171c>
			PRINT (ox, 2);
   150d0:	e24b3f56 	sub	r3, fp, #344	; 0x158
   150d4:	e5843000 	str	r3, [r4]
   150d8:	e3a03002 	mov	r3, #2
   150dc:	e5843004 	str	r3, [r4, #4]
   150e0:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   150e4:	e2833002 	add	r3, r3, #2
   150e8:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   150ec:	e2844008 	add	r4, r4, #8
   150f0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   150f4:	e2833001 	add	r3, r3, #1
   150f8:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   150fc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15100:	e3530007 	cmp	r3, #7
   15104:	da00000a 	ble	15134 <_vfprintf_r+0x171c>
   15108:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1510c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15110:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15114:	e1a01002 	mov	r1, r2
   15118:	e1a02003 	mov	r2, r3
   1511c:	eb002a12 	bl	1f96c <__sprint_r>
   15120:	e1a03000 	mov	r3, r0
   15124:	e3530000 	cmp	r3, #0
   15128:	0a000000 	beq	15130 <_vfprintf_r+0x1718>
   1512c:	ea0004a4 	b	163c4 <_vfprintf_r+0x29ac>
   15130:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   15134:	e2063084 	and	r3, r6, #132	; 0x84
   15138:	e3530080 	cmp	r3, #128	; 0x80
   1513c:	1a00003a 	bne	1522c <_vfprintf_r+0x1814>
			PAD (width - realsz, zeroes);
   15140:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   15144:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   15148:	e0635002 	rsb	r5, r3, r2
   1514c:	e3550000 	cmp	r5, #0
   15150:	da000035 	ble	1522c <_vfprintf_r+0x1814>
   15154:	ea000019 	b	151c0 <_vfprintf_r+0x17a8>
   15158:	e59f31d8 	ldr	r3, [pc, #472]	; 15338 <_vfprintf_r+0x1920>
   1515c:	e5843000 	str	r3, [r4]
   15160:	e3a03010 	mov	r3, #16
   15164:	e5843004 	str	r3, [r4, #4]
   15168:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1516c:	e2833010 	add	r3, r3, #16
   15170:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15174:	e2844008 	add	r4, r4, #8
   15178:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1517c:	e2833001 	add	r3, r3, #1
   15180:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15184:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15188:	e3530007 	cmp	r3, #7
   1518c:	da00000a 	ble	151bc <_vfprintf_r+0x17a4>
   15190:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15194:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15198:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1519c:	e1a01002 	mov	r1, r2
   151a0:	e1a02003 	mov	r2, r3
   151a4:	eb0029f0 	bl	1f96c <__sprint_r>
   151a8:	e1a03000 	mov	r3, r0
   151ac:	e3530000 	cmp	r3, #0
   151b0:	0a000000 	beq	151b8 <_vfprintf_r+0x17a0>
   151b4:	ea000482 	b	163c4 <_vfprintf_r+0x29ac>
   151b8:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   151bc:	e2455010 	sub	r5, r5, #16
   151c0:	e3550010 	cmp	r5, #16
   151c4:	caffffe3 	bgt	15158 <_vfprintf_r+0x1740>
   151c8:	e59f3168 	ldr	r3, [pc, #360]	; 15338 <_vfprintf_r+0x1920>
   151cc:	e5843000 	str	r3, [r4]
   151d0:	e1a03005 	mov	r3, r5
   151d4:	e5843004 	str	r3, [r4, #4]
   151d8:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   151dc:	e0833005 	add	r3, r3, r5
   151e0:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   151e4:	e2844008 	add	r4, r4, #8
   151e8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   151ec:	e2833001 	add	r3, r3, #1
   151f0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   151f4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   151f8:	e3530007 	cmp	r3, #7
   151fc:	da00000a 	ble	1522c <_vfprintf_r+0x1814>
   15200:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15204:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15208:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1520c:	e1a01002 	mov	r1, r2
   15210:	e1a02003 	mov	r2, r3
   15214:	eb0029d4 	bl	1f96c <__sprint_r>
   15218:	e1a03000 	mov	r3, r0
   1521c:	e3530000 	cmp	r3, #0
   15220:	0a000000 	beq	15228 <_vfprintf_r+0x1810>
   15224:	ea000466 	b	163c4 <_vfprintf_r+0x29ac>
   15228:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   1522c:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   15230:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   15234:	e0635002 	rsb	r5, r3, r2
   15238:	e3550000 	cmp	r5, #0
   1523c:	da000040 	ble	15344 <_vfprintf_r+0x192c>
   15240:	ea000019 	b	152ac <_vfprintf_r+0x1894>
   15244:	e59f30ec 	ldr	r3, [pc, #236]	; 15338 <_vfprintf_r+0x1920>
   15248:	e5843000 	str	r3, [r4]
   1524c:	e3a03010 	mov	r3, #16
   15250:	e5843004 	str	r3, [r4, #4]
   15254:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   15258:	e2833010 	add	r3, r3, #16
   1525c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15260:	e2844008 	add	r4, r4, #8
   15264:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15268:	e2833001 	add	r3, r3, #1
   1526c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15270:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15274:	e3530007 	cmp	r3, #7
   15278:	da00000a 	ble	152a8 <_vfprintf_r+0x1890>
   1527c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15280:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15284:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15288:	e1a01002 	mov	r1, r2
   1528c:	e1a02003 	mov	r2, r3
   15290:	eb0029b5 	bl	1f96c <__sprint_r>
   15294:	e1a03000 	mov	r3, r0
   15298:	e3530000 	cmp	r3, #0
   1529c:	0a000000 	beq	152a4 <_vfprintf_r+0x188c>
   152a0:	ea000447 	b	163c4 <_vfprintf_r+0x29ac>
   152a4:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   152a8:	e2455010 	sub	r5, r5, #16
   152ac:	e3550010 	cmp	r5, #16
   152b0:	caffffe3 	bgt	15244 <_vfprintf_r+0x182c>
   152b4:	e59f307c 	ldr	r3, [pc, #124]	; 15338 <_vfprintf_r+0x1920>
   152b8:	e5843000 	str	r3, [r4]
   152bc:	e1a03005 	mov	r3, r5
   152c0:	e5843004 	str	r3, [r4, #4]
   152c4:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   152c8:	e0833005 	add	r3, r3, r5
   152cc:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   152d0:	e2844008 	add	r4, r4, #8
   152d4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   152d8:	e2833001 	add	r3, r3, #1
   152dc:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   152e0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   152e4:	e3530007 	cmp	r3, #7
   152e8:	da000015 	ble	15344 <_vfprintf_r+0x192c>
   152ec:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   152f0:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   152f4:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   152f8:	e1a01002 	mov	r1, r2
   152fc:	e1a02003 	mov	r2, r3
   15300:	eb002999 	bl	1f96c <__sprint_r>
   15304:	e1a03000 	mov	r3, r0
   15308:	e3530000 	cmp	r3, #0
   1530c:	0a00000b 	beq	15340 <_vfprintf_r+0x1928>
   15310:	ea00042b 	b	163c4 <_vfprintf_r+0x29ac>
   15314:	00024774 	.word	0x00024774
   15318:	00024778 	.word	0x00024778
   1531c:	0002477c 	.word	0x0002477c
   15320:	00024780 	.word	0x00024780
   15324:	00024784 	.word	0x00024784
   15328:	00024798 	.word	0x00024798
   1532c:	000247a0 	.word	0x000247a0
   15330:	000247b4 	.word	0x000247b4
   15334:	000247d0 	.word	0x000247d0
   15338:	000247e4 	.word	0x000247e4
   1533c:	000247d4 	.word	0x000247d4
   15340:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* the string or number proper */
#ifdef FLOATING_POINT
		if ((flags & FPT) == 0) {
   15344:	e2063c01 	and	r3, r6, #256	; 0x100
   15348:	e3530000 	cmp	r3, #0
   1534c:	1a000019 	bne	153b8 <_vfprintf_r+0x19a0>
			PRINT (cp, size);
   15350:	e5847000 	str	r7, [r4]
   15354:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   15358:	e5843004 	str	r3, [r4, #4]
   1535c:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   15360:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   15364:	e0823003 	add	r3, r2, r3
   15368:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1536c:	e2844008 	add	r4, r4, #8
   15370:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15374:	e2833001 	add	r3, r3, #1
   15378:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1537c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15380:	e3530007 	cmp	r3, #7
   15384:	da00039f 	ble	16208 <_vfprintf_r+0x27f0>
   15388:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   1538c:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15390:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15394:	e1a01002 	mov	r1, r2
   15398:	e1a02003 	mov	r2, r3
   1539c:	eb002972 	bl	1f96c <__sprint_r>
   153a0:	e1a03000 	mov	r3, r0
   153a4:	e3530000 	cmp	r3, #0
   153a8:	0a000000 	beq	153b0 <_vfprintf_r+0x1998>
   153ac:	ea000404 	b	163c4 <_vfprintf_r+0x29ac>
   153b0:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   153b4:	ea000393 	b	16208 <_vfprintf_r+0x27f0>
		} else {	/* glue together f_p fragments */
			if (ch >= 'f') {	/* 'f' or 'g' */
   153b8:	e3580065 	cmp	r8, #101	; 0x65
   153bc:	da0002c3 	ble	15ed0 <_vfprintf_r+0x24b8>
				if (_fpvalue == 0) {
   153c0:	e24b3094 	sub	r3, fp, #148	; 0x94
   153c4:	e893000c 	ldm	r3, {r2, r3}
   153c8:	e1a00002 	mov	r0, r2
   153cc:	e1a01003 	mov	r1, r3
   153d0:	e3a02000 	mov	r2, #0
   153d4:	e3a03000 	mov	r3, #0
   153d8:	eb003604 	bl	22bf0 <__aeabi_dcmpeq>
   153dc:	e1a03000 	mov	r3, r0
   153e0:	e3530000 	cmp	r3, #0
   153e4:	0a000075 	beq	155c0 <_vfprintf_r+0x1ba8>
					/* kludge for __dtoa irregularity */
					PRINT ("0", 1);
   153e8:	e51f30bc 	ldr	r3, [pc, #-188]	; 15334 <_vfprintf_r+0x191c>
   153ec:	e5843000 	str	r3, [r4]
   153f0:	e3a03001 	mov	r3, #1
   153f4:	e5843004 	str	r3, [r4, #4]
   153f8:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   153fc:	e2833001 	add	r3, r3, #1
   15400:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15404:	e2844008 	add	r4, r4, #8
   15408:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1540c:	e2833001 	add	r3, r3, #1
   15410:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15414:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15418:	e3530007 	cmp	r3, #7
   1541c:	da00000a 	ble	1544c <_vfprintf_r+0x1a34>
   15420:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15424:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15428:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1542c:	e1a01002 	mov	r1, r2
   15430:	e1a02003 	mov	r2, r3
   15434:	eb00294c 	bl	1f96c <__sprint_r>
   15438:	e1a03000 	mov	r3, r0
   1543c:	e3530000 	cmp	r3, #0
   15440:	0a000000 	beq	15448 <_vfprintf_r+0x1a30>
   15444:	ea0003de 	b	163c4 <_vfprintf_r+0x29ac>
   15448:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					if (expt < ndig || flags & ALT) {
   1544c:	e51b2098 	ldr	r2, [fp, #-152]	; 0x98
   15450:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   15454:	e1520003 	cmp	r2, r3
   15458:	ba000002 	blt	15468 <_vfprintf_r+0x1a50>
   1545c:	e2063001 	and	r3, r6, #1
   15460:	e3530000 	cmp	r3, #0
   15464:	0a000367 	beq	16208 <_vfprintf_r+0x27f0>
						PRINT (decimal_point, decp_len);
   15468:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1546c:	e5843000 	str	r3, [r4]
   15470:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   15474:	e5843004 	str	r3, [r4, #4]
   15478:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1547c:	e1a02003 	mov	r2, r3
   15480:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   15484:	e0823003 	add	r3, r2, r3
   15488:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   1548c:	e2844008 	add	r4, r4, #8
   15490:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15494:	e2833001 	add	r3, r3, #1
   15498:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1549c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   154a0:	e3530007 	cmp	r3, #7
   154a4:	da00000a 	ble	154d4 <_vfprintf_r+0x1abc>
   154a8:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   154ac:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   154b0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   154b4:	e1a01002 	mov	r1, r2
   154b8:	e1a02003 	mov	r2, r3
   154bc:	eb00292a 	bl	1f96c <__sprint_r>
   154c0:	e1a03000 	mov	r3, r0
   154c4:	e3530000 	cmp	r3, #0
   154c8:	0a000000 	beq	154d0 <_vfprintf_r+0x1ab8>
   154cc:	ea0003bc 	b	163c4 <_vfprintf_r+0x29ac>
   154d0:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						PAD (ndig - 1, zeroes);
   154d4:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   154d8:	e2435001 	sub	r5, r3, #1
   154dc:	e3550000 	cmp	r5, #0
   154e0:	da000348 	ble	16208 <_vfprintf_r+0x27f0>
   154e4:	ea000019 	b	15550 <_vfprintf_r+0x1b38>
   154e8:	e51f31b8 	ldr	r3, [pc, #-440]	; 15338 <_vfprintf_r+0x1920>
   154ec:	e5843000 	str	r3, [r4]
   154f0:	e3a03010 	mov	r3, #16
   154f4:	e5843004 	str	r3, [r4, #4]
   154f8:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   154fc:	e2833010 	add	r3, r3, #16
   15500:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15504:	e2844008 	add	r4, r4, #8
   15508:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1550c:	e2833001 	add	r3, r3, #1
   15510:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15514:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15518:	e3530007 	cmp	r3, #7
   1551c:	da00000a 	ble	1554c <_vfprintf_r+0x1b34>
   15520:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15524:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15528:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1552c:	e1a01002 	mov	r1, r2
   15530:	e1a02003 	mov	r2, r3
   15534:	eb00290c 	bl	1f96c <__sprint_r>
   15538:	e1a03000 	mov	r3, r0
   1553c:	e3530000 	cmp	r3, #0
   15540:	0a000000 	beq	15548 <_vfprintf_r+0x1b30>
   15544:	ea00039e 	b	163c4 <_vfprintf_r+0x29ac>
   15548:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1554c:	e2455010 	sub	r5, r5, #16
   15550:	e3550010 	cmp	r5, #16
   15554:	caffffe3 	bgt	154e8 <_vfprintf_r+0x1ad0>
   15558:	e51f3228 	ldr	r3, [pc, #-552]	; 15338 <_vfprintf_r+0x1920>
   1555c:	e5843000 	str	r3, [r4]
   15560:	e1a03005 	mov	r3, r5
   15564:	e5843004 	str	r3, [r4, #4]
   15568:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   1556c:	e0833005 	add	r3, r3, r5
   15570:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15574:	e2844008 	add	r4, r4, #8
   15578:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1557c:	e2833001 	add	r3, r3, #1
   15580:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15584:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15588:	e3530007 	cmp	r3, #7
   1558c:	da00031d 	ble	16208 <_vfprintf_r+0x27f0>
   15590:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15594:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15598:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1559c:	e1a01002 	mov	r1, r2
   155a0:	e1a02003 	mov	r2, r3
   155a4:	eb0028f0 	bl	1f96c <__sprint_r>
   155a8:	e1a03000 	mov	r3, r0
   155ac:	e3530000 	cmp	r3, #0
   155b0:	0a000000 	beq	155b8 <_vfprintf_r+0x1ba0>
   155b4:	ea000382 	b	163c4 <_vfprintf_r+0x29ac>
   155b8:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   155bc:	ea000311 	b	16208 <_vfprintf_r+0x27f0>
					}
				} else if (expt <= 0) {
   155c0:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   155c4:	e3530000 	cmp	r3, #0
   155c8:	ca000090 	bgt	15810 <_vfprintf_r+0x1df8>
					PRINT ("0", 1);
   155cc:	e51f32a0 	ldr	r3, [pc, #-672]	; 15334 <_vfprintf_r+0x191c>
   155d0:	e5843000 	str	r3, [r4]
   155d4:	e3a03001 	mov	r3, #1
   155d8:	e5843004 	str	r3, [r4, #4]
   155dc:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   155e0:	e2833001 	add	r3, r3, #1
   155e4:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   155e8:	e2844008 	add	r4, r4, #8
   155ec:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   155f0:	e2833001 	add	r3, r3, #1
   155f4:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   155f8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   155fc:	e3530007 	cmp	r3, #7
   15600:	da00000a 	ble	15630 <_vfprintf_r+0x1c18>
   15604:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15608:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1560c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15610:	e1a01002 	mov	r1, r2
   15614:	e1a02003 	mov	r2, r3
   15618:	eb0028d3 	bl	1f96c <__sprint_r>
   1561c:	e1a03000 	mov	r3, r0
   15620:	e3530000 	cmp	r3, #0
   15624:	0a000000 	beq	1562c <_vfprintf_r+0x1c14>
   15628:	ea000365 	b	163c4 <_vfprintf_r+0x29ac>
   1562c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					if (expt || ndig || flags & ALT) {
   15630:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   15634:	e3530000 	cmp	r3, #0
   15638:	1a000005 	bne	15654 <_vfprintf_r+0x1c3c>
   1563c:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   15640:	e3530000 	cmp	r3, #0
   15644:	1a000002 	bne	15654 <_vfprintf_r+0x1c3c>
   15648:	e2063001 	and	r3, r6, #1
   1564c:	e3530000 	cmp	r3, #0
   15650:	0a0002ec 	beq	16208 <_vfprintf_r+0x27f0>
						PRINT (decimal_point, decp_len);
   15654:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   15658:	e5843000 	str	r3, [r4]
   1565c:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   15660:	e5843004 	str	r3, [r4, #4]
   15664:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   15668:	e1a02003 	mov	r2, r3
   1566c:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   15670:	e0823003 	add	r3, r2, r3
   15674:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15678:	e2844008 	add	r4, r4, #8
   1567c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15680:	e2833001 	add	r3, r3, #1
   15684:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15688:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1568c:	e3530007 	cmp	r3, #7
   15690:	da00000a 	ble	156c0 <_vfprintf_r+0x1ca8>
   15694:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15698:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1569c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   156a0:	e1a01002 	mov	r1, r2
   156a4:	e1a02003 	mov	r2, r3
   156a8:	eb0028af 	bl	1f96c <__sprint_r>
   156ac:	e1a03000 	mov	r3, r0
   156b0:	e3530000 	cmp	r3, #0
   156b4:	0a000000 	beq	156bc <_vfprintf_r+0x1ca4>
   156b8:	ea000341 	b	163c4 <_vfprintf_r+0x29ac>
   156bc:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						PAD (-expt, zeroes);
   156c0:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   156c4:	e2635000 	rsb	r5, r3, #0
   156c8:	e3550000 	cmp	r5, #0
   156cc:	da000035 	ble	157a8 <_vfprintf_r+0x1d90>
   156d0:	ea000019 	b	1573c <_vfprintf_r+0x1d24>
   156d4:	e51f33a4 	ldr	r3, [pc, #-932]	; 15338 <_vfprintf_r+0x1920>
   156d8:	e5843000 	str	r3, [r4]
   156dc:	e3a03010 	mov	r3, #16
   156e0:	e5843004 	str	r3, [r4, #4]
   156e4:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   156e8:	e2833010 	add	r3, r3, #16
   156ec:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   156f0:	e2844008 	add	r4, r4, #8
   156f4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   156f8:	e2833001 	add	r3, r3, #1
   156fc:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15700:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15704:	e3530007 	cmp	r3, #7
   15708:	da00000a 	ble	15738 <_vfprintf_r+0x1d20>
   1570c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15710:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15714:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15718:	e1a01002 	mov	r1, r2
   1571c:	e1a02003 	mov	r2, r3
   15720:	eb002891 	bl	1f96c <__sprint_r>
   15724:	e1a03000 	mov	r3, r0
   15728:	e3530000 	cmp	r3, #0
   1572c:	0a000000 	beq	15734 <_vfprintf_r+0x1d1c>
   15730:	ea000323 	b	163c4 <_vfprintf_r+0x29ac>
   15734:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   15738:	e2455010 	sub	r5, r5, #16
   1573c:	e3550010 	cmp	r5, #16
   15740:	caffffe3 	bgt	156d4 <_vfprintf_r+0x1cbc>
   15744:	e51f3414 	ldr	r3, [pc, #-1044]	; 15338 <_vfprintf_r+0x1920>
   15748:	e5843000 	str	r3, [r4]
   1574c:	e1a03005 	mov	r3, r5
   15750:	e5843004 	str	r3, [r4, #4]
   15754:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   15758:	e0833005 	add	r3, r3, r5
   1575c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15760:	e2844008 	add	r4, r4, #8
   15764:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15768:	e2833001 	add	r3, r3, #1
   1576c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15770:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15774:	e3530007 	cmp	r3, #7
   15778:	da00000a 	ble	157a8 <_vfprintf_r+0x1d90>
   1577c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15780:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15784:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15788:	e1a01002 	mov	r1, r2
   1578c:	e1a02003 	mov	r2, r3
   15790:	eb002875 	bl	1f96c <__sprint_r>
   15794:	e1a03000 	mov	r3, r0
   15798:	e3530000 	cmp	r3, #0
   1579c:	0a000000 	beq	157a4 <_vfprintf_r+0x1d8c>
   157a0:	ea000307 	b	163c4 <_vfprintf_r+0x29ac>
   157a4:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						PRINT (cp, ndig);
   157a8:	e5847000 	str	r7, [r4]
   157ac:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   157b0:	e5843004 	str	r3, [r4, #4]
   157b4:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   157b8:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   157bc:	e0823003 	add	r3, r2, r3
   157c0:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   157c4:	e2844008 	add	r4, r4, #8
   157c8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   157cc:	e2833001 	add	r3, r3, #1
   157d0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   157d4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   157d8:	e3530007 	cmp	r3, #7
   157dc:	da000289 	ble	16208 <_vfprintf_r+0x27f0>
   157e0:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   157e4:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   157e8:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   157ec:	e1a01002 	mov	r1, r2
   157f0:	e1a02003 	mov	r2, r3
   157f4:	eb00285c 	bl	1f96c <__sprint_r>
   157f8:	e1a03000 	mov	r3, r0
   157fc:	e3530000 	cmp	r3, #0
   15800:	0a000000 	beq	15808 <_vfprintf_r+0x1df0>
   15804:	ea0002ee 	b	163c4 <_vfprintf_r+0x29ac>
   15808:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   1580c:	ea00027d 	b	16208 <_vfprintf_r+0x27f0>
					}
				} else {
					char *convbuf = cp;
   15810:	e50b7088 	str	r7, [fp, #-136]	; 0x88
					PRINTANDPAD(cp, convbuf + ndig,
   15814:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   15818:	e51b2088 	ldr	r2, [fp, #-136]	; 0x88
   1581c:	e0823003 	add	r3, r2, r3
   15820:	e1a02003 	mov	r2, r3
   15824:	e1a03007 	mov	r3, r7
   15828:	e0633002 	rsb	r3, r3, r2
   1582c:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   15830:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   15834:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   15838:	e1520003 	cmp	r2, r3
   1583c:	da000001 	ble	15848 <_vfprintf_r+0x1e30>
   15840:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   15844:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   15848:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1584c:	e3530000 	cmp	r3, #0
   15850:	da000018 	ble	158b8 <_vfprintf_r+0x1ea0>
   15854:	e5847000 	str	r7, [r4]
   15858:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1585c:	e5843004 	str	r3, [r4, #4]
   15860:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   15864:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   15868:	e0823003 	add	r3, r2, r3
   1586c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15870:	e2844008 	add	r4, r4, #8
   15874:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15878:	e2833001 	add	r3, r3, #1
   1587c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15880:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15884:	e3530007 	cmp	r3, #7
   15888:	da00000a 	ble	158b8 <_vfprintf_r+0x1ea0>
   1588c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15890:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15894:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15898:	e1a01002 	mov	r1, r2
   1589c:	e1a02003 	mov	r2, r3
   158a0:	eb002831 	bl	1f96c <__sprint_r>
   158a4:	e1a03000 	mov	r3, r0
   158a8:	e3530000 	cmp	r3, #0
   158ac:	0a000000 	beq	158b4 <_vfprintf_r+0x1e9c>
   158b0:	ea0002c3 	b	163c4 <_vfprintf_r+0x29ac>
   158b4:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   158b8:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   158bc:	e1c33fc3 	bic	r3, r3, r3, asr #31
   158c0:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   158c4:	e0633002 	rsb	r3, r3, r2
   158c8:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   158cc:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   158d0:	e3530000 	cmp	r3, #0
   158d4:	da000039 	ble	159c0 <_vfprintf_r+0x1fa8>
   158d8:	ea00001b 	b	1594c <_vfprintf_r+0x1f34>
   158dc:	e51f35ac 	ldr	r3, [pc, #-1452]	; 15338 <_vfprintf_r+0x1920>
   158e0:	e5843000 	str	r3, [r4]
   158e4:	e3a03010 	mov	r3, #16
   158e8:	e5843004 	str	r3, [r4, #4]
   158ec:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   158f0:	e2833010 	add	r3, r3, #16
   158f4:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   158f8:	e2844008 	add	r4, r4, #8
   158fc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15900:	e2833001 	add	r3, r3, #1
   15904:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15908:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1590c:	e3530007 	cmp	r3, #7
   15910:	da00000a 	ble	15940 <_vfprintf_r+0x1f28>
   15914:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15918:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1591c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15920:	e1a01002 	mov	r1, r2
   15924:	e1a02003 	mov	r2, r3
   15928:	eb00280f 	bl	1f96c <__sprint_r>
   1592c:	e1a03000 	mov	r3, r0
   15930:	e3530000 	cmp	r3, #0
   15934:	0a000000 	beq	1593c <_vfprintf_r+0x1f24>
   15938:	ea0002a1 	b	163c4 <_vfprintf_r+0x29ac>
   1593c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   15940:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   15944:	e2433010 	sub	r3, r3, #16
   15948:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   1594c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   15950:	e3530010 	cmp	r3, #16
   15954:	caffffe0 	bgt	158dc <_vfprintf_r+0x1ec4>
   15958:	e51f3628 	ldr	r3, [pc, #-1576]	; 15338 <_vfprintf_r+0x1920>
   1595c:	e5843000 	str	r3, [r4]
   15960:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   15964:	e5843004 	str	r3, [r4, #4]
   15968:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1596c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   15970:	e0823003 	add	r3, r2, r3
   15974:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15978:	e2844008 	add	r4, r4, #8
   1597c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15980:	e2833001 	add	r3, r3, #1
   15984:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15988:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1598c:	e3530007 	cmp	r3, #7
   15990:	da00000a 	ble	159c0 <_vfprintf_r+0x1fa8>
   15994:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15998:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1599c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   159a0:	e1a01002 	mov	r1, r2
   159a4:	e1a02003 	mov	r2, r3
   159a8:	eb0027ef 	bl	1f96c <__sprint_r>
   159ac:	e1a03000 	mov	r3, r0
   159b0:	e3530000 	cmp	r3, #0
   159b4:	0a000000 	beq	159bc <_vfprintf_r+0x1fa4>
   159b8:	ea000281 	b	163c4 <_vfprintf_r+0x29ac>
   159bc:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						    lead, zeroes);
					cp += lead;
   159c0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   159c4:	e0877003 	add	r7, r7, r3
#ifdef _WANT_IO_C99_FORMATS
					if (flags & GROUPING) {
   159c8:	e2063b01 	and	r3, r6, #1024	; 0x400
   159cc:	e3530000 	cmp	r3, #0
   159d0:	0a0000a9 	beq	15c7c <_vfprintf_r+0x2264>
					    while (nseps > 0 || nrepeats > 0) {
   159d4:	ea00009a 	b	15c44 <_vfprintf_r+0x222c>
						if (nrepeats > 0)
   159d8:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   159dc:	e3530000 	cmp	r3, #0
   159e0:	da000003 	ble	159f4 <_vfprintf_r+0x1fdc>
						    nrepeats--;
   159e4:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   159e8:	e2433001 	sub	r3, r3, #1
   159ec:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   159f0:	ea000005 	b	15a0c <_vfprintf_r+0x1ff4>
						else {
						    grouping--;
   159f4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   159f8:	e2433001 	sub	r3, r3, #1
   159fc:	e50b3034 	str	r3, [fp, #-52]	; 0x34
						    nseps--;
   15a00:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   15a04:	e2433001 	sub	r3, r3, #1
   15a08:	e50b3040 	str	r3, [fp, #-64]	; 0x40
						}
						PRINT(thousands_sep, thsnd_len);
   15a0c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   15a10:	e5843000 	str	r3, [r4]
   15a14:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   15a18:	e5843004 	str	r3, [r4, #4]
   15a1c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   15a20:	e1a02003 	mov	r2, r3
   15a24:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   15a28:	e0823003 	add	r3, r2, r3
   15a2c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15a30:	e2844008 	add	r4, r4, #8
   15a34:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15a38:	e2833001 	add	r3, r3, #1
   15a3c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15a40:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15a44:	e3530007 	cmp	r3, #7
   15a48:	da00000a 	ble	15a78 <_vfprintf_r+0x2060>
   15a4c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15a50:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15a54:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15a58:	e1a01002 	mov	r1, r2
   15a5c:	e1a02003 	mov	r2, r3
   15a60:	eb0027c1 	bl	1f96c <__sprint_r>
   15a64:	e1a03000 	mov	r3, r0
   15a68:	e3530000 	cmp	r3, #0
   15a6c:	0a000000 	beq	15a74 <_vfprintf_r+0x205c>
   15a70:	ea000253 	b	163c4 <_vfprintf_r+0x29ac>
   15a74:	e24b40f0 	sub	r4, fp, #240	; 0xf0
						PRINTANDPAD (cp, convbuf + ndig,
   15a78:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   15a7c:	e51b2088 	ldr	r2, [fp, #-136]	; 0x88
   15a80:	e0823003 	add	r3, r2, r3
   15a84:	e1a02003 	mov	r2, r3
   15a88:	e1a03007 	mov	r3, r7
   15a8c:	e0633002 	rsb	r3, r3, r2
   15a90:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   15a94:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   15a98:	e5d33000 	ldrb	r3, [r3]
   15a9c:	e1a02003 	mov	r2, r3
   15aa0:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   15aa4:	e1520003 	cmp	r2, r3
   15aa8:	aa000002 	bge	15ab8 <_vfprintf_r+0x20a0>
   15aac:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   15ab0:	e5d33000 	ldrb	r3, [r3]
   15ab4:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   15ab8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   15abc:	e3530000 	cmp	r3, #0
   15ac0:	da000018 	ble	15b28 <_vfprintf_r+0x2110>
   15ac4:	e5847000 	str	r7, [r4]
   15ac8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   15acc:	e5843004 	str	r3, [r4, #4]
   15ad0:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   15ad4:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   15ad8:	e0823003 	add	r3, r2, r3
   15adc:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15ae0:	e2844008 	add	r4, r4, #8
   15ae4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15ae8:	e2833001 	add	r3, r3, #1
   15aec:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15af0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15af4:	e3530007 	cmp	r3, #7
   15af8:	da00000a 	ble	15b28 <_vfprintf_r+0x2110>
   15afc:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15b00:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15b04:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15b08:	e1a01002 	mov	r1, r2
   15b0c:	e1a02003 	mov	r2, r3
   15b10:	eb002795 	bl	1f96c <__sprint_r>
   15b14:	e1a03000 	mov	r3, r0
   15b18:	e3530000 	cmp	r3, #0
   15b1c:	0a000000 	beq	15b24 <_vfprintf_r+0x210c>
   15b20:	ea000227 	b	163c4 <_vfprintf_r+0x29ac>
   15b24:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   15b28:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   15b2c:	e5d33000 	ldrb	r3, [r3]
   15b30:	e1a02003 	mov	r2, r3
   15b34:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   15b38:	e1c33fc3 	bic	r3, r3, r3, asr #31
   15b3c:	e0633002 	rsb	r3, r3, r2
   15b40:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   15b44:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   15b48:	e3530000 	cmp	r3, #0
   15b4c:	da000039 	ble	15c38 <_vfprintf_r+0x2220>
   15b50:	ea00001b 	b	15bc4 <_vfprintf_r+0x21ac>
   15b54:	e51f3824 	ldr	r3, [pc, #-2084]	; 15338 <_vfprintf_r+0x1920>
   15b58:	e5843000 	str	r3, [r4]
   15b5c:	e3a03010 	mov	r3, #16
   15b60:	e5843004 	str	r3, [r4, #4]
   15b64:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   15b68:	e2833010 	add	r3, r3, #16
   15b6c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15b70:	e2844008 	add	r4, r4, #8
   15b74:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15b78:	e2833001 	add	r3, r3, #1
   15b7c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15b80:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15b84:	e3530007 	cmp	r3, #7
   15b88:	da00000a 	ble	15bb8 <_vfprintf_r+0x21a0>
   15b8c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15b90:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15b94:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15b98:	e1a01002 	mov	r1, r2
   15b9c:	e1a02003 	mov	r2, r3
   15ba0:	eb002771 	bl	1f96c <__sprint_r>
   15ba4:	e1a03000 	mov	r3, r0
   15ba8:	e3530000 	cmp	r3, #0
   15bac:	0a000000 	beq	15bb4 <_vfprintf_r+0x219c>
   15bb0:	ea000203 	b	163c4 <_vfprintf_r+0x29ac>
   15bb4:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   15bb8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   15bbc:	e2433010 	sub	r3, r3, #16
   15bc0:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   15bc4:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   15bc8:	e3530010 	cmp	r3, #16
   15bcc:	caffffe0 	bgt	15b54 <_vfprintf_r+0x213c>
   15bd0:	e51f38a0 	ldr	r3, [pc, #-2208]	; 15338 <_vfprintf_r+0x1920>
   15bd4:	e5843000 	str	r3, [r4]
   15bd8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   15bdc:	e5843004 	str	r3, [r4, #4]
   15be0:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   15be4:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   15be8:	e0823003 	add	r3, r2, r3
   15bec:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15bf0:	e2844008 	add	r4, r4, #8
   15bf4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15bf8:	e2833001 	add	r3, r3, #1
   15bfc:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15c00:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15c04:	e3530007 	cmp	r3, #7
   15c08:	da00000a 	ble	15c38 <_vfprintf_r+0x2220>
   15c0c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15c10:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15c14:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15c18:	e1a01002 	mov	r1, r2
   15c1c:	e1a02003 	mov	r2, r3
   15c20:	eb002751 	bl	1f96c <__sprint_r>
   15c24:	e1a03000 	mov	r3, r0
   15c28:	e3530000 	cmp	r3, #0
   15c2c:	0a000000 	beq	15c34 <_vfprintf_r+0x221c>
   15c30:	ea0001e3 	b	163c4 <_vfprintf_r+0x29ac>
   15c34:	e24b40f0 	sub	r4, fp, #240	; 0xf0
							     *grouping, zeroes);
						cp += *grouping;
   15c38:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   15c3c:	e5d33000 	ldrb	r3, [r3]
   15c40:	e0877003 	add	r7, r7, r3
					PRINTANDPAD(cp, convbuf + ndig,
						    lead, zeroes);
					cp += lead;
#ifdef _WANT_IO_C99_FORMATS
					if (flags & GROUPING) {
					    while (nseps > 0 || nrepeats > 0) {
   15c44:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   15c48:	e3530000 	cmp	r3, #0
   15c4c:	caffff61 	bgt	159d8 <_vfprintf_r+0x1fc0>
   15c50:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   15c54:	e3530000 	cmp	r3, #0
   15c58:	caffff5e 	bgt	159d8 <_vfprintf_r+0x1fc0>
						PRINT(thousands_sep, thsnd_len);
						PRINTANDPAD (cp, convbuf + ndig,
							     *grouping, zeroes);
						cp += *grouping;
					    }
					    if (cp > convbuf + ndig)
   15c5c:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   15c60:	e51b2088 	ldr	r2, [fp, #-136]	; 0x88
   15c64:	e0823003 	add	r3, r2, r3
   15c68:	e1530007 	cmp	r3, r7
   15c6c:	2a000002 	bcs	15c7c <_vfprintf_r+0x2264>
						cp = convbuf + ndig;
   15c70:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   15c74:	e51b2088 	ldr	r2, [fp, #-136]	; 0x88
   15c78:	e0827003 	add	r7, r2, r3
					}
#endif
					if (expt < ndig || flags & ALT)
   15c7c:	e51b2098 	ldr	r2, [fp, #-152]	; 0x98
   15c80:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   15c84:	e1520003 	cmp	r2, r3
   15c88:	ba000002 	blt	15c98 <_vfprintf_r+0x2280>
   15c8c:	e2063001 	and	r3, r6, #1
   15c90:	e3530000 	cmp	r3, #0
   15c94:	0a00001a 	beq	15d04 <_vfprintf_r+0x22ec>
					    PRINT (decimal_point, decp_len);
   15c98:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   15c9c:	e5843000 	str	r3, [r4]
   15ca0:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   15ca4:	e5843004 	str	r3, [r4, #4]
   15ca8:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   15cac:	e1a02003 	mov	r2, r3
   15cb0:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   15cb4:	e0823003 	add	r3, r2, r3
   15cb8:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15cbc:	e2844008 	add	r4, r4, #8
   15cc0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15cc4:	e2833001 	add	r3, r3, #1
   15cc8:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15ccc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15cd0:	e3530007 	cmp	r3, #7
   15cd4:	da00000a 	ble	15d04 <_vfprintf_r+0x22ec>
   15cd8:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15cdc:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15ce0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15ce4:	e1a01002 	mov	r1, r2
   15ce8:	e1a02003 	mov	r2, r3
   15cec:	eb00271e 	bl	1f96c <__sprint_r>
   15cf0:	e1a03000 	mov	r3, r0
   15cf4:	e3530000 	cmp	r3, #0
   15cf8:	0a000000 	beq	15d00 <_vfprintf_r+0x22e8>
   15cfc:	ea0001b0 	b	163c4 <_vfprintf_r+0x29ac>
   15d00:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					PRINTANDPAD (cp, convbuf + ndig,
   15d04:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   15d08:	e51b2088 	ldr	r2, [fp, #-136]	; 0x88
   15d0c:	e0823003 	add	r3, r2, r3
   15d10:	e1a02003 	mov	r2, r3
   15d14:	e1a03007 	mov	r3, r7
   15d18:	e0633002 	rsb	r3, r3, r2
   15d1c:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   15d20:	e51b20a4 	ldr	r2, [fp, #-164]	; 0xa4
   15d24:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   15d28:	e0632002 	rsb	r2, r3, r2
   15d2c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   15d30:	e1520003 	cmp	r2, r3
   15d34:	aa000003 	bge	15d48 <_vfprintf_r+0x2330>
   15d38:	e51b20a4 	ldr	r2, [fp, #-164]	; 0xa4
   15d3c:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   15d40:	e0633002 	rsb	r3, r3, r2
   15d44:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   15d48:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   15d4c:	e3530000 	cmp	r3, #0
   15d50:	da000018 	ble	15db8 <_vfprintf_r+0x23a0>
   15d54:	e5847000 	str	r7, [r4]
   15d58:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   15d5c:	e5843004 	str	r3, [r4, #4]
   15d60:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   15d64:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   15d68:	e0823003 	add	r3, r2, r3
   15d6c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15d70:	e2844008 	add	r4, r4, #8
   15d74:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15d78:	e2833001 	add	r3, r3, #1
   15d7c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15d80:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15d84:	e3530007 	cmp	r3, #7
   15d88:	da00000a 	ble	15db8 <_vfprintf_r+0x23a0>
   15d8c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15d90:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15d94:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15d98:	e1a01002 	mov	r1, r2
   15d9c:	e1a02003 	mov	r2, r3
   15da0:	eb0026f1 	bl	1f96c <__sprint_r>
   15da4:	e1a03000 	mov	r3, r0
   15da8:	e3530000 	cmp	r3, #0
   15dac:	0a000000 	beq	15db4 <_vfprintf_r+0x239c>
   15db0:	ea000183 	b	163c4 <_vfprintf_r+0x29ac>
   15db4:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   15db8:	e51b20a4 	ldr	r2, [fp, #-164]	; 0xa4
   15dbc:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   15dc0:	e0632002 	rsb	r2, r3, r2
   15dc4:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   15dc8:	e1c33fc3 	bic	r3, r3, r3, asr #31
   15dcc:	e0633002 	rsb	r3, r3, r2
   15dd0:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   15dd4:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   15dd8:	e3530000 	cmp	r3, #0
   15ddc:	da00003a 	ble	15ecc <_vfprintf_r+0x24b4>
   15de0:	ea00001b 	b	15e54 <_vfprintf_r+0x243c>
   15de4:	e51f3ab4 	ldr	r3, [pc, #-2740]	; 15338 <_vfprintf_r+0x1920>
   15de8:	e5843000 	str	r3, [r4]
   15dec:	e3a03010 	mov	r3, #16
   15df0:	e5843004 	str	r3, [r4, #4]
   15df4:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   15df8:	e2833010 	add	r3, r3, #16
   15dfc:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15e00:	e2844008 	add	r4, r4, #8
   15e04:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15e08:	e2833001 	add	r3, r3, #1
   15e0c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15e10:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15e14:	e3530007 	cmp	r3, #7
   15e18:	da00000a 	ble	15e48 <_vfprintf_r+0x2430>
   15e1c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15e20:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15e24:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15e28:	e1a01002 	mov	r1, r2
   15e2c:	e1a02003 	mov	r2, r3
   15e30:	eb0026cd 	bl	1f96c <__sprint_r>
   15e34:	e1a03000 	mov	r3, r0
   15e38:	e3530000 	cmp	r3, #0
   15e3c:	0a000000 	beq	15e44 <_vfprintf_r+0x242c>
   15e40:	ea00015f 	b	163c4 <_vfprintf_r+0x29ac>
   15e44:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   15e48:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   15e4c:	e2433010 	sub	r3, r3, #16
   15e50:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   15e54:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   15e58:	e3530010 	cmp	r3, #16
   15e5c:	caffffe0 	bgt	15de4 <_vfprintf_r+0x23cc>
   15e60:	e51f3b30 	ldr	r3, [pc, #-2864]	; 15338 <_vfprintf_r+0x1920>
   15e64:	e5843000 	str	r3, [r4]
   15e68:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   15e6c:	e5843004 	str	r3, [r4, #4]
   15e70:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   15e74:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   15e78:	e0823003 	add	r3, r2, r3
   15e7c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15e80:	e2844008 	add	r4, r4, #8
   15e84:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15e88:	e2833001 	add	r3, r3, #1
   15e8c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15e90:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15e94:	e3530007 	cmp	r3, #7
   15e98:	da00000b 	ble	15ecc <_vfprintf_r+0x24b4>
   15e9c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15ea0:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15ea4:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15ea8:	e1a01002 	mov	r1, r2
   15eac:	e1a02003 	mov	r2, r3
   15eb0:	eb0026ad 	bl	1f96c <__sprint_r>
   15eb4:	e1a03000 	mov	r3, r0
   15eb8:	e3530000 	cmp	r3, #0
   15ebc:	0a000000 	beq	15ec4 <_vfprintf_r+0x24ac>
   15ec0:	ea00013f 	b	163c4 <_vfprintf_r+0x29ac>
   15ec4:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   15ec8:	ea0000ce 	b	16208 <_vfprintf_r+0x27f0>
   15ecc:	ea0000cd 	b	16208 <_vfprintf_r+0x27f0>
						     ndig - expt, zeroes);
				}
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
   15ed0:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   15ed4:	e3530001 	cmp	r3, #1
   15ed8:	ca000002 	bgt	15ee8 <_vfprintf_r+0x24d0>
   15edc:	e2063001 	and	r3, r6, #1
   15ee0:	e3530000 	cmp	r3, #0
   15ee4:	0a000095 	beq	16140 <_vfprintf_r+0x2728>
					PRINT (cp, 1);
   15ee8:	e5847000 	str	r7, [r4]
   15eec:	e3a03001 	mov	r3, #1
   15ef0:	e5843004 	str	r3, [r4, #4]
   15ef4:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   15ef8:	e2833001 	add	r3, r3, #1
   15efc:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15f00:	e2844008 	add	r4, r4, #8
   15f04:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15f08:	e2833001 	add	r3, r3, #1
   15f0c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15f10:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15f14:	e3530007 	cmp	r3, #7
   15f18:	da00000a 	ble	15f48 <_vfprintf_r+0x2530>
   15f1c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15f20:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15f24:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15f28:	e1a01002 	mov	r1, r2
   15f2c:	e1a02003 	mov	r2, r3
   15f30:	eb00268d 	bl	1f96c <__sprint_r>
   15f34:	e1a03000 	mov	r3, r0
   15f38:	e3530000 	cmp	r3, #0
   15f3c:	0a000000 	beq	15f44 <_vfprintf_r+0x252c>
   15f40:	ea00011f 	b	163c4 <_vfprintf_r+0x29ac>
   15f44:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					cp++;
   15f48:	e2877001 	add	r7, r7, #1
					PRINT (decimal_point, decp_len);
   15f4c:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   15f50:	e5843000 	str	r3, [r4]
   15f54:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   15f58:	e5843004 	str	r3, [r4, #4]
   15f5c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   15f60:	e1a02003 	mov	r2, r3
   15f64:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   15f68:	e0823003 	add	r3, r2, r3
   15f6c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   15f70:	e2844008 	add	r4, r4, #8
   15f74:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15f78:	e2833001 	add	r3, r3, #1
   15f7c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   15f80:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   15f84:	e3530007 	cmp	r3, #7
   15f88:	da00000a 	ble	15fb8 <_vfprintf_r+0x25a0>
   15f8c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   15f90:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   15f94:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   15f98:	e1a01002 	mov	r1, r2
   15f9c:	e1a02003 	mov	r2, r3
   15fa0:	eb002671 	bl	1f96c <__sprint_r>
   15fa4:	e1a03000 	mov	r3, r0
   15fa8:	e3530000 	cmp	r3, #0
   15fac:	0a000000 	beq	15fb4 <_vfprintf_r+0x259c>
   15fb0:	ea000103 	b	163c4 <_vfprintf_r+0x29ac>
   15fb4:	e24b40f0 	sub	r4, fp, #240	; 0xf0
					if (_fpvalue) {
   15fb8:	e24b3094 	sub	r3, fp, #148	; 0x94
   15fbc:	e893000c 	ldm	r3, {r2, r3}
   15fc0:	e1a00002 	mov	r0, r2
   15fc4:	e1a01003 	mov	r1, r3
   15fc8:	e3a02000 	mov	r2, #0
   15fcc:	e3a03000 	mov	r3, #0
   15fd0:	eb003306 	bl	22bf0 <__aeabi_dcmpeq>
   15fd4:	e1a03000 	mov	r3, r0
   15fd8:	e3530000 	cmp	r3, #0
   15fdc:	1a00001b 	bne	16050 <_vfprintf_r+0x2638>
						PRINT (cp, ndig - 1);
   15fe0:	e5847000 	str	r7, [r4]
   15fe4:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   15fe8:	e2433001 	sub	r3, r3, #1
   15fec:	e5843004 	str	r3, [r4, #4]
   15ff0:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   15ff4:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   15ff8:	e2433001 	sub	r3, r3, #1
   15ffc:	e0823003 	add	r3, r2, r3
   16000:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   16004:	e2844008 	add	r4, r4, #8
   16008:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1600c:	e2833001 	add	r3, r3, #1
   16010:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   16014:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   16018:	e3530007 	cmp	r3, #7
   1601c:	da000046 	ble	1613c <_vfprintf_r+0x2724>
   16020:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   16024:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   16028:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1602c:	e1a01002 	mov	r1, r2
   16030:	e1a02003 	mov	r2, r3
   16034:	eb00264c 	bl	1f96c <__sprint_r>
   16038:	e1a03000 	mov	r3, r0
   1603c:	e3530000 	cmp	r3, #0
   16040:	0a000000 	beq	16048 <_vfprintf_r+0x2630>
   16044:	ea0000de 	b	163c4 <_vfprintf_r+0x29ac>
   16048:	e24b40f0 	sub	r4, fp, #240	; 0xf0
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
					cp++;
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
   1604c:	ea000053 	b	161a0 <_vfprintf_r+0x2788>
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
   16050:	e51b30a4 	ldr	r3, [fp, #-164]	; 0xa4
   16054:	e2435001 	sub	r5, r3, #1
   16058:	e3550000 	cmp	r5, #0
   1605c:	da000036 	ble	1613c <_vfprintf_r+0x2724>
   16060:	ea000019 	b	160cc <_vfprintf_r+0x26b4>
   16064:	e51f3d34 	ldr	r3, [pc, #-3380]	; 15338 <_vfprintf_r+0x1920>
   16068:	e5843000 	str	r3, [r4]
   1606c:	e3a03010 	mov	r3, #16
   16070:	e5843004 	str	r3, [r4, #4]
   16074:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   16078:	e2833010 	add	r3, r3, #16
   1607c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   16080:	e2844008 	add	r4, r4, #8
   16084:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   16088:	e2833001 	add	r3, r3, #1
   1608c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   16090:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   16094:	e3530007 	cmp	r3, #7
   16098:	da00000a 	ble	160c8 <_vfprintf_r+0x26b0>
   1609c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   160a0:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   160a4:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   160a8:	e1a01002 	mov	r1, r2
   160ac:	e1a02003 	mov	r2, r3
   160b0:	eb00262d 	bl	1f96c <__sprint_r>
   160b4:	e1a03000 	mov	r3, r0
   160b8:	e3530000 	cmp	r3, #0
   160bc:	0a000000 	beq	160c4 <_vfprintf_r+0x26ac>
   160c0:	ea0000bf 	b	163c4 <_vfprintf_r+0x29ac>
   160c4:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   160c8:	e2455010 	sub	r5, r5, #16
   160cc:	e3550010 	cmp	r5, #16
   160d0:	caffffe3 	bgt	16064 <_vfprintf_r+0x264c>
   160d4:	e51f3da4 	ldr	r3, [pc, #-3492]	; 15338 <_vfprintf_r+0x1920>
   160d8:	e5843000 	str	r3, [r4]
   160dc:	e1a03005 	mov	r3, r5
   160e0:	e5843004 	str	r3, [r4, #4]
   160e4:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   160e8:	e0833005 	add	r3, r3, r5
   160ec:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   160f0:	e2844008 	add	r4, r4, #8
   160f4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   160f8:	e2833001 	add	r3, r3, #1
   160fc:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   16100:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   16104:	e3530007 	cmp	r3, #7
   16108:	da00000b 	ble	1613c <_vfprintf_r+0x2724>
   1610c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   16110:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   16114:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   16118:	e1a01002 	mov	r1, r2
   1611c:	e1a02003 	mov	r2, r3
   16120:	eb002611 	bl	1f96c <__sprint_r>
   16124:	e1a03000 	mov	r3, r0
   16128:	e3530000 	cmp	r3, #0
   1612c:	0a000000 	beq	16134 <_vfprintf_r+0x271c>
   16130:	ea0000a3 	b	163c4 <_vfprintf_r+0x29ac>
   16134:	e24b40f0 	sub	r4, fp, #240	; 0xf0
			} else {	/* 'a', 'A', 'e', or 'E' */
				if (ndig > 1 || flags & ALT) {
					PRINT (cp, 1);
					cp++;
					PRINT (decimal_point, decp_len);
					if (_fpvalue) {
   16138:	ea000018 	b	161a0 <_vfprintf_r+0x2788>
   1613c:	ea000017 	b	161a0 <_vfprintf_r+0x2788>
						PRINT (cp, ndig - 1);
					} else	/* 0.[0..] */
						/* __dtoa irregularity */
						PAD (ndig - 1, zeroes);
				} else	/* XeYYY */
					PRINT (cp, 1);
   16140:	e5847000 	str	r7, [r4]
   16144:	e3a03001 	mov	r3, #1
   16148:	e5843004 	str	r3, [r4, #4]
   1614c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   16150:	e2833001 	add	r3, r3, #1
   16154:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   16158:	e2844008 	add	r4, r4, #8
   1615c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   16160:	e2833001 	add	r3, r3, #1
   16164:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   16168:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1616c:	e3530007 	cmp	r3, #7
   16170:	da00000a 	ble	161a0 <_vfprintf_r+0x2788>
   16174:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   16178:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1617c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   16180:	e1a01002 	mov	r1, r2
   16184:	e1a02003 	mov	r2, r3
   16188:	eb0025f7 	bl	1f96c <__sprint_r>
   1618c:	e1a03000 	mov	r3, r0
   16190:	e3530000 	cmp	r3, #0
   16194:	0a000000 	beq	1619c <_vfprintf_r+0x2784>
   16198:	ea000089 	b	163c4 <_vfprintf_r+0x29ac>
   1619c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
				PRINT (expstr, expsize);
   161a0:	e24b30a0 	sub	r3, fp, #160	; 0xa0
   161a4:	e5843000 	str	r3, [r4]
   161a8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   161ac:	e5843004 	str	r3, [r4, #4]
   161b0:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   161b4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   161b8:	e0823003 	add	r3, r2, r3
   161bc:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   161c0:	e2844008 	add	r4, r4, #8
   161c4:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   161c8:	e2833001 	add	r3, r3, #1
   161cc:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   161d0:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   161d4:	e3530007 	cmp	r3, #7
   161d8:	da00000a 	ble	16208 <_vfprintf_r+0x27f0>
   161dc:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   161e0:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   161e4:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   161e8:	e1a01002 	mov	r1, r2
   161ec:	e1a02003 	mov	r2, r3
   161f0:	eb0025dd 	bl	1f96c <__sprint_r>
   161f4:	e1a03000 	mov	r3, r0
   161f8:	e3530000 	cmp	r3, #0
   161fc:	0a000000 	beq	16204 <_vfprintf_r+0x27ec>
   16200:	ea00006f 	b	163c4 <_vfprintf_r+0x29ac>
   16204:	e24b40f0 	sub	r4, fp, #240	; 0xf0
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   16208:	e2063004 	and	r3, r6, #4
   1620c:	e3530000 	cmp	r3, #0
   16210:	0a00003a 	beq	16300 <_vfprintf_r+0x28e8>
			PAD (width - realsz, blanks);
   16214:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   16218:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   1621c:	e0635002 	rsb	r5, r3, r2
   16220:	e3550000 	cmp	r5, #0
   16224:	da000035 	ble	16300 <_vfprintf_r+0x28e8>
   16228:	ea000019 	b	16294 <_vfprintf_r+0x287c>
   1622c:	e51f3ef8 	ldr	r3, [pc, #-3832]	; 1533c <_vfprintf_r+0x1924>
   16230:	e5843000 	str	r3, [r4]
   16234:	e3a03010 	mov	r3, #16
   16238:	e5843004 	str	r3, [r4, #4]
   1623c:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   16240:	e2833010 	add	r3, r3, #16
   16244:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   16248:	e2844008 	add	r4, r4, #8
   1624c:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   16250:	e2833001 	add	r3, r3, #1
   16254:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   16258:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1625c:	e3530007 	cmp	r3, #7
   16260:	da00000a 	ble	16290 <_vfprintf_r+0x2878>
   16264:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   16268:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   1626c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   16270:	e1a01002 	mov	r1, r2
   16274:	e1a02003 	mov	r2, r3
   16278:	eb0025bb 	bl	1f96c <__sprint_r>
   1627c:	e1a03000 	mov	r3, r0
   16280:	e3530000 	cmp	r3, #0
   16284:	0a000000 	beq	1628c <_vfprintf_r+0x2874>
   16288:	ea00004d 	b	163c4 <_vfprintf_r+0x29ac>
   1628c:	e24b40f0 	sub	r4, fp, #240	; 0xf0
   16290:	e2455010 	sub	r5, r5, #16
   16294:	e3550010 	cmp	r5, #16
   16298:	caffffe3 	bgt	1622c <_vfprintf_r+0x2814>
   1629c:	e51f3f68 	ldr	r3, [pc, #-3944]	; 1533c <_vfprintf_r+0x1924>
   162a0:	e5843000 	str	r3, [r4]
   162a4:	e1a03005 	mov	r3, r5
   162a8:	e5843004 	str	r3, [r4, #4]
   162ac:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   162b0:	e0833005 	add	r3, r3, r5
   162b4:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   162b8:	e2844008 	add	r4, r4, #8
   162bc:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   162c0:	e2833001 	add	r3, r3, #1
   162c4:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   162c8:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   162cc:	e3530007 	cmp	r3, #7
   162d0:	da00000a 	ble	16300 <_vfprintf_r+0x28e8>
   162d4:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   162d8:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   162dc:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   162e0:	e1a01002 	mov	r1, r2
   162e4:	e1a02003 	mov	r2, r3
   162e8:	eb00259f 	bl	1f96c <__sprint_r>
   162ec:	e1a03000 	mov	r3, r0
   162f0:	e3530000 	cmp	r3, #0
   162f4:	0a000000 	beq	162fc <_vfprintf_r+0x28e4>
   162f8:	ea000031 	b	163c4 <_vfprintf_r+0x29ac>
   162fc:	e24b40f0 	sub	r4, fp, #240	; 0xf0

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   16300:	e51b2058 	ldr	r2, [fp, #-88]	; 0x58
   16304:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   16308:	e1520003 	cmp	r2, r3
   1630c:	a1a03002 	movge	r3, r2
   16310:	b1a03003 	movlt	r3, r3
   16314:	e51b2020 	ldr	r2, [fp, #-32]
   16318:	e0823003 	add	r3, r2, r3
   1631c:	e50b3020 	str	r3, [fp, #-32]

		FLUSH ();	/* copy out the I/O vectors */
   16320:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   16324:	e3530000 	cmp	r3, #0
   16328:	0a000009 	beq	16354 <_vfprintf_r+0x293c>
   1632c:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   16330:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   16334:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   16338:	e1a01002 	mov	r1, r2
   1633c:	e1a02003 	mov	r2, r3
   16340:	eb002589 	bl	1f96c <__sprint_r>
   16344:	e1a03000 	mov	r3, r0
   16348:	e3530000 	cmp	r3, #0
   1634c:	0a000000 	beq	16354 <_vfprintf_r+0x293c>
   16350:	ea00001b 	b	163c4 <_vfprintf_r+0x29ac>
   16354:	e3a03000 	mov	r3, #0
   16358:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   1635c:	e24b40f0 	sub	r4, fp, #240	; 0xf0

                if (malloc_buf != NULL) {
   16360:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   16364:	e3530000 	cmp	r3, #0
   16368:	0a000004 	beq	16380 <_vfprintf_r+0x2968>
			_free_r (data, malloc_buf);
   1636c:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   16370:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
   16374:	eb000d48 	bl	1989c <_free_r>
			malloc_buf = NULL;
   16378:	e3a03000 	mov	r3, #0
   1637c:	e50b3064 	str	r3, [fp, #-100]	; 0x64
		}
	}
   16380:	eafff64e 	b	13cc0 <_vfprintf_r+0x2a8>
done:
	FLUSH ();
   16384:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   16388:	e3530000 	cmp	r3, #0
   1638c:	0a000009 	beq	163b8 <_vfprintf_r+0x29a0>
   16390:	e51b2164 	ldr	r2, [fp, #-356]	; 0x164
   16394:	e24b30b0 	sub	r3, fp, #176	; 0xb0
   16398:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   1639c:	e1a01002 	mov	r1, r2
   163a0:	e1a02003 	mov	r2, r3
   163a4:	eb002570 	bl	1f96c <__sprint_r>
   163a8:	e1a03000 	mov	r3, r0
   163ac:	e3530000 	cmp	r3, #0
   163b0:	0a000000 	beq	163b8 <_vfprintf_r+0x29a0>
   163b4:	ea000002 	b	163c4 <_vfprintf_r+0x29ac>
   163b8:	e3a03000 	mov	r3, #0
   163bc:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   163c0:	e24b40f0 	sub	r4, fp, #240	; 0xf0
error:
	if (malloc_buf != NULL)
   163c4:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   163c8:	e3530000 	cmp	r3, #0
   163cc:	0a000002 	beq	163dc <_vfprintf_r+0x29c4>
		_free_r (data, malloc_buf);
   163d0:	e51b0160 	ldr	r0, [fp, #-352]	; 0x160
   163d4:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
   163d8:	eb000d2f 	bl	1989c <_free_r>
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
   163dc:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   163e0:	e1d330bc 	ldrh	r3, [r3, #12]
   163e4:	e1a03803 	lsl	r3, r3, #16
   163e8:	e1a03823 	lsr	r3, r3, #16
   163ec:	e2033c02 	and	r3, r3, #512	; 0x200
   163f0:	e3530000 	cmp	r3, #0
   163f4:	1a000003 	bne	16408 <_vfprintf_r+0x29f0>
   163f8:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   163fc:	e283305c 	add	r3, r3, #92	; 0x5c
   16400:	e1a00003 	mov	r0, r3
   16404:	ebffe1e4 	bl	eb9c <_dna_lock_release>
#endif
	return (__sferror (fp) ? EOF : ret);
   16408:	e51b3164 	ldr	r3, [fp, #-356]	; 0x164
   1640c:	e1d330bc 	ldrh	r3, [r3, #12]
   16410:	e1a03803 	lsl	r3, r3, #16
   16414:	e1a03823 	lsr	r3, r3, #16
   16418:	e2033040 	and	r3, r3, #64	; 0x40
   1641c:	e3530000 	cmp	r3, #0
   16420:	1a000001 	bne	1642c <_vfprintf_r+0x2a14>
   16424:	e51b3020 	ldr	r3, [fp, #-32]
   16428:	ea000000 	b	16430 <_vfprintf_r+0x2a18>
   1642c:	e3e03000 	mvn	r3, #0
   16430:	e1a00000 	nop			; (mov r0, r0)
	/* NOTREACHED */
}
   16434:	e1a00003 	mov	r0, r3
   16438:	e24bd01c 	sub	sp, fp, #28
   1643c:	e8bd4bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, lr}
   16440:	e12fff1e 	bx	lr

00016444 <cvt>:
   [aAeEfFgG]; if it is [aA], then the return string lives in BUF,
   otherwise the return value shares the mprec reentrant storage.  */
static char *
cvt(struct _reent *data, _PRINTF_FLOAT_TYPE value, int ndigits, int flags,
    char *sign, int *decpt, int ch, int *length, char *buf)
{
   16444:	e92d4810 	push	{r4, fp, lr}
   16448:	e28db008 	add	fp, sp, #8
   1644c:	e24dd04c 	sub	sp, sp, #76	; 0x4c
   16450:	e50b0030 	str	r0, [fp, #-48]	; 0x30
   16454:	e50b203c 	str	r2, [fp, #-60]	; 0x3c
   16458:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	int mode, dsgn;
	char *digits, *bp, *rve;
# ifdef _NO_LONGDBL
	union double_union tmp;

	tmp.d = value;
   1645c:	e24b403c 	sub	r4, fp, #60	; 0x3c
   16460:	e8940018 	ldm	r4, {r3, r4}
   16464:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   16468:	e50b4028 	str	r4, [fp, #-40]	; 0x28
	if (word0 (tmp) & Sign_bit) { /* this will check for < 0 and -0.0 */
   1646c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   16470:	e3530000 	cmp	r3, #0
   16474:	aa000008 	bge	1649c <cvt+0x58>
		value = -value;
   16478:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1647c:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   16480:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   16484:	e2233102 	eor	r3, r3, #-2147483648	; 0x80000000
   16488:	e50b3038 	str	r3, [fp, #-56]	; 0x38
		*sign = '-';
   1648c:	e59b300c 	ldr	r3, [fp, #12]
   16490:	e3a0202d 	mov	r2, #45	; 0x2d
   16494:	e5c32000 	strb	r2, [r3]
   16498:	ea000002 	b	164a8 <cvt+0x64>
	} else
		*sign = '\000';
   1649c:	e59b300c 	ldr	r3, [fp, #12]
   164a0:	e3a02000 	mov	r2, #0
   164a4:	e5c32000 	strb	r2, [r3]
	} else
		*sign = '\000';
# endif /* !_NO_LONGDBL */

# ifdef _WANT_IO_C99_FORMATS
	if (ch == 'a' || ch == 'A') {
   164a8:	e59b3014 	ldr	r3, [fp, #20]
   164ac:	e3530061 	cmp	r3, #97	; 0x61
   164b0:	0a000002 	beq	164c0 <cvt+0x7c>
   164b4:	e59b3014 	ldr	r3, [fp, #20]
   164b8:	e3530041 	cmp	r3, #65	; 0x41
   164bc:	1a000096 	bne	1671c <cvt+0x2d8>
		/* This code assumes FLT_RADIX is a power of 2.  The initial
		   division ensures the digit before the decimal will be less
		   than FLT_RADIX (unless it is rounded later).	 There is no
		   loss of precision in these calculations.  */
		value = FREXP (value, decpt) / 8;
   164c0:	e24b103c 	sub	r1, fp, #60	; 0x3c
   164c4:	e8910003 	ldm	r1, {r0, r1}
   164c8:	e59b2010 	ldr	r2, [fp, #16]
   164cc:	eb001d51 	bl	1da18 <frexp>
   164d0:	e1a03000 	mov	r3, r0
   164d4:	e1a04001 	mov	r4, r1
   164d8:	e1a00003 	mov	r0, r3
   164dc:	e1a01004 	mov	r1, r4
   164e0:	e3a02000 	mov	r2, #0
   164e4:	e59f33dc 	ldr	r3, [pc, #988]	; 168c8 <cvt+0x484>
   164e8:	eb00310a 	bl	22918 <__aeabi_ddiv>
   164ec:	e1a03000 	mov	r3, r0
   164f0:	e1a04001 	mov	r4, r1
   164f4:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   164f8:	e50b4038 	str	r4, [fp, #-56]	; 0x38
		if (!value)
   164fc:	e24b103c 	sub	r1, fp, #60	; 0x3c
   16500:	e8910003 	ldm	r1, {r0, r1}
   16504:	e3a02000 	mov	r2, #0
   16508:	e3a03000 	mov	r3, #0
   1650c:	eb0031b7 	bl	22bf0 <__aeabi_dcmpeq>
   16510:	e1a03000 	mov	r3, r0
   16514:	e3530000 	cmp	r3, #0
   16518:	0a000002 	beq	16528 <cvt+0xe4>
			*decpt = 1;
   1651c:	e59b3010 	ldr	r3, [fp, #16]
   16520:	e3a02001 	mov	r2, #1
   16524:	e5832000 	str	r2, [r3]
		digits = ch == 'a' ? "0123456789abcdef" : "0123456789ABCDEF";
   16528:	e59b3014 	ldr	r3, [fp, #20]
   1652c:	e3530061 	cmp	r3, #97	; 0x61
   16530:	1a000001 	bne	1653c <cvt+0xf8>
   16534:	e59f3390 	ldr	r3, [pc, #912]	; 168cc <cvt+0x488>
   16538:	ea000000 	b	16540 <cvt+0xfc>
   1653c:	e59f338c 	ldr	r3, [pc, #908]	; 168d0 <cvt+0x48c>
   16540:	e50b3018 	str	r3, [fp, #-24]
		bp = buf;
   16544:	e59b301c 	ldr	r3, [fp, #28]
   16548:	e50b3014 	str	r3, [fp, #-20]
		do {
			value *= 16;
   1654c:	e24b103c 	sub	r1, fp, #60	; 0x3c
   16550:	e8910003 	ldm	r1, {r0, r1}
   16554:	e3a02000 	mov	r2, #0
   16558:	e59f3374 	ldr	r3, [pc, #884]	; 168d4 <cvt+0x490>
   1655c:	eb003049 	bl	22688 <__aeabi_dmul>
   16560:	e1a03000 	mov	r3, r0
   16564:	e1a04001 	mov	r4, r1
   16568:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   1656c:	e50b4038 	str	r4, [fp, #-56]	; 0x38
			mode = (int) value;
   16570:	e24b103c 	sub	r1, fp, #60	; 0x3c
   16574:	e8910003 	ldm	r1, {r0, r1}
   16578:	eb0031ba 	bl	22c68 <__aeabi_d2iz>
   1657c:	e1a03000 	mov	r3, r0
   16580:	e50b3010 	str	r3, [fp, #-16]
			value -= mode;
   16584:	e51b0010 	ldr	r0, [fp, #-16]
   16588:	eb003007 	bl	225ac <__aeabi_i2d>
   1658c:	e1a03000 	mov	r3, r0
   16590:	e1a04001 	mov	r4, r1
   16594:	e24b103c 	sub	r1, fp, #60	; 0x3c
   16598:	e8910003 	ldm	r1, {r0, r1}
   1659c:	e1a02003 	mov	r2, r3
   165a0:	e1a03004 	mov	r3, r4
   165a4:	eb002f32 	bl	22274 <__aeabi_dsub>
   165a8:	e1a03000 	mov	r3, r0
   165ac:	e1a04001 	mov	r4, r1
   165b0:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   165b4:	e50b4038 	str	r4, [fp, #-56]	; 0x38
			*bp++ = digits[mode];
   165b8:	e51b3014 	ldr	r3, [fp, #-20]
   165bc:	e2832001 	add	r2, r3, #1
   165c0:	e50b2014 	str	r2, [fp, #-20]
   165c4:	e51b2010 	ldr	r2, [fp, #-16]
   165c8:	e51b1018 	ldr	r1, [fp, #-24]
   165cc:	e0812002 	add	r2, r1, r2
   165d0:	e5d22000 	ldrb	r2, [r2]
   165d4:	e5c32000 	strb	r2, [r3]
		} while (ndigits-- && value);
   165d8:	e59b3004 	ldr	r3, [fp, #4]
   165dc:	e2432001 	sub	r2, r3, #1
   165e0:	e58b2004 	str	r2, [fp, #4]
   165e4:	e3530000 	cmp	r3, #0
   165e8:	0a000007 	beq	1660c <cvt+0x1c8>
   165ec:	e24b103c 	sub	r1, fp, #60	; 0x3c
   165f0:	e8910003 	ldm	r1, {r0, r1}
   165f4:	e3a02000 	mov	r2, #0
   165f8:	e3a03000 	mov	r3, #0
   165fc:	eb00317b 	bl	22bf0 <__aeabi_dcmpeq>
   16600:	e1a03000 	mov	r3, r0
   16604:	e3530000 	cmp	r3, #0
   16608:	0affffcf 	beq	1654c <cvt+0x108>
		if (value > 0.5 || (value == 0.5 && mode & 1)) {
   1660c:	e24b103c 	sub	r1, fp, #60	; 0x3c
   16610:	e8910003 	ldm	r1, {r0, r1}
   16614:	e3a02000 	mov	r2, #0
   16618:	e59f32b8 	ldr	r3, [pc, #696]	; 168d8 <cvt+0x494>
   1661c:	eb00318b 	bl	22c50 <__aeabi_dcmpgt>
   16620:	e1a03000 	mov	r3, r0
   16624:	e3530000 	cmp	r3, #0
   16628:	1a00000b 	bne	1665c <cvt+0x218>
   1662c:	e24b103c 	sub	r1, fp, #60	; 0x3c
   16630:	e8910003 	ldm	r1, {r0, r1}
   16634:	e3a02000 	mov	r2, #0
   16638:	e59f3298 	ldr	r3, [pc, #664]	; 168d8 <cvt+0x494>
   1663c:	eb00316b 	bl	22bf0 <__aeabi_dcmpeq>
   16640:	e1a03000 	mov	r3, r0
   16644:	e3530000 	cmp	r3, #0
   16648:	0a000021 	beq	166d4 <cvt+0x290>
   1664c:	e51b3010 	ldr	r3, [fp, #-16]
   16650:	e2033001 	and	r3, r3, #1
   16654:	e3530000 	cmp	r3, #0
   16658:	0a00001d 	beq	166d4 <cvt+0x290>
			/* round to even */
			rve = bp;
   1665c:	e51b3014 	ldr	r3, [fp, #-20]
   16660:	e50b3020 	str	r3, [fp, #-32]
			while (*--rve == digits[0xf]) {
   16664:	ea000002 	b	16674 <cvt+0x230>
				*rve = '0';
   16668:	e51b3020 	ldr	r3, [fp, #-32]
   1666c:	e3a02030 	mov	r2, #48	; 0x30
   16670:	e5c32000 	strb	r2, [r3]
			*bp++ = digits[mode];
		} while (ndigits-- && value);
		if (value > 0.5 || (value == 0.5 && mode & 1)) {
			/* round to even */
			rve = bp;
			while (*--rve == digits[0xf]) {
   16674:	e51b3020 	ldr	r3, [fp, #-32]
   16678:	e2433001 	sub	r3, r3, #1
   1667c:	e50b3020 	str	r3, [fp, #-32]
   16680:	e51b3020 	ldr	r3, [fp, #-32]
   16684:	e5d32000 	ldrb	r2, [r3]
   16688:	e51b3018 	ldr	r3, [fp, #-24]
   1668c:	e283300f 	add	r3, r3, #15
   16690:	e5d33000 	ldrb	r3, [r3]
   16694:	e1520003 	cmp	r2, r3
   16698:	0afffff2 	beq	16668 <cvt+0x224>
				*rve = '0';
			}
			*rve = *rve == '9' ? digits[0xa] : *rve + 1;
   1669c:	e51b2020 	ldr	r2, [fp, #-32]
   166a0:	e51b3020 	ldr	r3, [fp, #-32]
   166a4:	e5d33000 	ldrb	r3, [r3]
   166a8:	e3530039 	cmp	r3, #57	; 0x39
   166ac:	1a000002 	bne	166bc <cvt+0x278>
   166b0:	e51b3018 	ldr	r3, [fp, #-24]
   166b4:	e5d3300a 	ldrb	r3, [r3, #10]
   166b8:	ea000003 	b	166cc <cvt+0x288>
   166bc:	e51b3020 	ldr	r3, [fp, #-32]
   166c0:	e5d33000 	ldrb	r3, [r3]
   166c4:	e2833001 	add	r3, r3, #1
   166c8:	e20330ff 	and	r3, r3, #255	; 0xff
   166cc:	e5c23000 	strb	r3, [r2]
   166d0:	ea00000a 	b	16700 <cvt+0x2bc>
		} else {
			while (ndigits-- >= 0) {
   166d4:	ea000004 	b	166ec <cvt+0x2a8>
				*bp++ = '0';
   166d8:	e51b3014 	ldr	r3, [fp, #-20]
   166dc:	e2832001 	add	r2, r3, #1
   166e0:	e50b2014 	str	r2, [fp, #-20]
   166e4:	e3a02030 	mov	r2, #48	; 0x30
   166e8:	e5c32000 	strb	r2, [r3]
			while (*--rve == digits[0xf]) {
				*rve = '0';
			}
			*rve = *rve == '9' ? digits[0xa] : *rve + 1;
		} else {
			while (ndigits-- >= 0) {
   166ec:	e59b3004 	ldr	r3, [fp, #4]
   166f0:	e2432001 	sub	r2, r3, #1
   166f4:	e58b2004 	str	r2, [fp, #4]
   166f8:	e3530000 	cmp	r3, #0
   166fc:	aafffff5 	bge	166d8 <cvt+0x294>
				*bp++ = '0';
			}
		}
		*length = bp - buf;
   16700:	e51b2014 	ldr	r2, [fp, #-20]
   16704:	e59b301c 	ldr	r3, [fp, #28]
   16708:	e0632002 	rsb	r2, r3, r2
   1670c:	e59b3018 	ldr	r3, [fp, #24]
   16710:	e5832000 	str	r2, [r3]
		return buf;
   16714:	e59b301c 	ldr	r3, [fp, #28]
   16718:	ea000066 	b	168b8 <cvt+0x474>
	}
# endif /* _WANT_IO_C99_FORMATS */
	if (ch == 'f' || ch == 'F') {
   1671c:	e59b3014 	ldr	r3, [fp, #20]
   16720:	e3530066 	cmp	r3, #102	; 0x66
   16724:	0a000002 	beq	16734 <cvt+0x2f0>
   16728:	e59b3014 	ldr	r3, [fp, #20]
   1672c:	e3530046 	cmp	r3, #70	; 0x46
   16730:	1a000002 	bne	16740 <cvt+0x2fc>
		mode = 3;		/* ndigits after the decimal point */
   16734:	e3a03003 	mov	r3, #3
   16738:	e50b3010 	str	r3, [fp, #-16]
   1673c:	ea00000a 	b	1676c <cvt+0x328>
	} else {
		/* To obtain ndigits after the decimal point for the 'e'
		 * and 'E' formats, round to ndigits + 1 significant
		 * figures.
		 */
		if (ch == 'e' || ch == 'E') {
   16740:	e59b3014 	ldr	r3, [fp, #20]
   16744:	e3530065 	cmp	r3, #101	; 0x65
   16748:	0a000002 	beq	16758 <cvt+0x314>
   1674c:	e59b3014 	ldr	r3, [fp, #20]
   16750:	e3530045 	cmp	r3, #69	; 0x45
   16754:	1a000002 	bne	16764 <cvt+0x320>
			ndigits++;
   16758:	e59b3004 	ldr	r3, [fp, #4]
   1675c:	e2833001 	add	r3, r3, #1
   16760:	e58b3004 	str	r3, [fp, #4]
		}
		mode = 2;		/* ndigits significant digits */
   16764:	e3a03002 	mov	r3, #2
   16768:	e50b3010 	str	r3, [fp, #-16]
	}

	digits = _DTOA_R (data, value, mode, ndigits, decpt, &dsgn, &rve);
   1676c:	e51b3010 	ldr	r3, [fp, #-16]
   16770:	e58d3000 	str	r3, [sp]
   16774:	e59b3004 	ldr	r3, [fp, #4]
   16778:	e58d3004 	str	r3, [sp, #4]
   1677c:	e59b3010 	ldr	r3, [fp, #16]
   16780:	e58d3008 	str	r3, [sp, #8]
   16784:	e24b301c 	sub	r3, fp, #28
   16788:	e58d300c 	str	r3, [sp, #12]
   1678c:	e24b3020 	sub	r3, fp, #32
   16790:	e58d3010 	str	r3, [sp, #16]
   16794:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   16798:	e24b303c 	sub	r3, fp, #60	; 0x3c
   1679c:	e893000c 	ldm	r3, {r2, r3}
   167a0:	eb000262 	bl	17130 <_dtoa_r>
   167a4:	e50b0018 	str	r0, [fp, #-24]

	if ((ch != 'g' && ch != 'G') || flags & ALT) {	/* Print trailing zeros */
   167a8:	e59b3014 	ldr	r3, [fp, #20]
   167ac:	e3530067 	cmp	r3, #103	; 0x67
   167b0:	0a000002 	beq	167c0 <cvt+0x37c>
   167b4:	e59b3014 	ldr	r3, [fp, #20]
   167b8:	e3530047 	cmp	r3, #71	; 0x47
   167bc:	1a000003 	bne	167d0 <cvt+0x38c>
   167c0:	e59b3008 	ldr	r3, [fp, #8]
   167c4:	e2033001 	and	r3, r3, #1
   167c8:	e3530000 	cmp	r3, #0
   167cc:	0a000032 	beq	1689c <cvt+0x458>
		bp = digits + ndigits;
   167d0:	e59b3004 	ldr	r3, [fp, #4]
   167d4:	e51b2018 	ldr	r2, [fp, #-24]
   167d8:	e0823003 	add	r3, r2, r3
   167dc:	e50b3014 	str	r3, [fp, #-20]
		if (ch == 'f' || ch == 'F') {
   167e0:	e59b3014 	ldr	r3, [fp, #20]
   167e4:	e3530066 	cmp	r3, #102	; 0x66
   167e8:	0a000002 	beq	167f8 <cvt+0x3b4>
   167ec:	e59b3014 	ldr	r3, [fp, #20]
   167f0:	e3530046 	cmp	r3, #70	; 0x46
   167f4:	1a000014 	bne	1684c <cvt+0x408>
			if (*digits == '0' && value)
   167f8:	e51b3018 	ldr	r3, [fp, #-24]
   167fc:	e5d33000 	ldrb	r3, [r3]
   16800:	e3530030 	cmp	r3, #48	; 0x30
   16804:	1a00000b 	bne	16838 <cvt+0x3f4>
   16808:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1680c:	e8910003 	ldm	r1, {r0, r1}
   16810:	e3a02000 	mov	r2, #0
   16814:	e3a03000 	mov	r3, #0
   16818:	eb0030f4 	bl	22bf0 <__aeabi_dcmpeq>
   1681c:	e1a03000 	mov	r3, r0
   16820:	e3530000 	cmp	r3, #0
   16824:	1a000003 	bne	16838 <cvt+0x3f4>
				*decpt = -ndigits + 1;
   16828:	e59b3004 	ldr	r3, [fp, #4]
   1682c:	e2632001 	rsb	r2, r3, #1
   16830:	e59b3010 	ldr	r3, [fp, #16]
   16834:	e5832000 	str	r2, [r3]
			bp += *decpt;
   16838:	e59b3010 	ldr	r3, [fp, #16]
   1683c:	e5933000 	ldr	r3, [r3]
   16840:	e51b2014 	ldr	r2, [fp, #-20]
   16844:	e0823003 	add	r3, r2, r3
   16848:	e50b3014 	str	r3, [fp, #-20]
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
   1684c:	e24b103c 	sub	r1, fp, #60	; 0x3c
   16850:	e8910003 	ldm	r1, {r0, r1}
   16854:	e3a02000 	mov	r2, #0
   16858:	e3a03000 	mov	r3, #0
   1685c:	eb0030e3 	bl	22bf0 <__aeabi_dcmpeq>
   16860:	e1a03000 	mov	r3, r0
   16864:	e3530000 	cmp	r3, #0
   16868:	0a000001 	beq	16874 <cvt+0x430>
			rve = bp;
   1686c:	e51b3014 	ldr	r3, [fp, #-20]
   16870:	e50b3020 	str	r3, [fp, #-32]
		while (rve < bp)
   16874:	ea000004 	b	1688c <cvt+0x448>
			*rve++ = '0';
   16878:	e51b3020 	ldr	r3, [fp, #-32]
   1687c:	e2832001 	add	r2, r3, #1
   16880:	e50b2020 	str	r2, [fp, #-32]
   16884:	e3a02030 	mov	r2, #48	; 0x30
   16888:	e5c32000 	strb	r2, [r3]
				*decpt = -ndigits + 1;
			bp += *decpt;
		}
		if (value == 0)	/* kludge for __dtoa irregularity */
			rve = bp;
		while (rve < bp)
   1688c:	e51b2020 	ldr	r2, [fp, #-32]
   16890:	e51b3014 	ldr	r3, [fp, #-20]
   16894:	e1520003 	cmp	r2, r3
   16898:	3afffff6 	bcc	16878 <cvt+0x434>
			*rve++ = '0';
	}
	*length = rve - digits;
   1689c:	e51b3020 	ldr	r3, [fp, #-32]
   168a0:	e1a02003 	mov	r2, r3
   168a4:	e51b3018 	ldr	r3, [fp, #-24]
   168a8:	e0632002 	rsb	r2, r3, r2
   168ac:	e59b3018 	ldr	r3, [fp, #24]
   168b0:	e5832000 	str	r2, [r3]
	return (digits);
   168b4:	e51b3018 	ldr	r3, [fp, #-24]
}
   168b8:	e1a00003 	mov	r0, r3
   168bc:	e24bd008 	sub	sp, fp, #8
   168c0:	e8bd4810 	pop	{r4, fp, lr}
   168c4:	e12fff1e 	bx	lr
   168c8:	40200000 	.word	0x40200000
   168cc:	00024784 	.word	0x00024784
   168d0:	000247a0 	.word	0x000247a0
   168d4:	40300000 	.word	0x40300000
   168d8:	3fe00000 	.word	0x3fe00000

000168dc <exponent>:

static int
exponent(char *p0, int exp, int fmtch)
{
   168dc:	e92d0830 	push	{r4, r5, fp}
   168e0:	e28db008 	add	fp, sp, #8
   168e4:	e24dd024 	sub	sp, sp, #36	; 0x24
   168e8:	e50b0020 	str	r0, [fp, #-32]
   168ec:	e50b1024 	str	r1, [fp, #-36]	; 0x24
   168f0:	e50b2028 	str	r2, [fp, #-40]	; 0x28
	register char *p, *t;
	char expbuf[MAXEXPLEN];
# ifdef _WANT_IO_C99_FORMATS
	int isa = fmtch == 'a' || fmtch == 'A';
   168f4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   168f8:	e3530061 	cmp	r3, #97	; 0x61
   168fc:	0a000002 	beq	1690c <exponent+0x30>
   16900:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   16904:	e3530041 	cmp	r3, #65	; 0x41
   16908:	1a000001 	bne	16914 <exponent+0x38>
   1690c:	e3a03001 	mov	r3, #1
   16910:	ea000000 	b	16918 <exponent+0x3c>
   16914:	e3a03000 	mov	r3, #0
   16918:	e50b3010 	str	r3, [fp, #-16]
# else
#  define isa 0
# endif

	p = p0;
   1691c:	e51b4020 	ldr	r4, [fp, #-32]
	*p++ = isa ? 'p' - 'a' + fmtch : fmtch;
   16920:	e1a03004 	mov	r3, r4
   16924:	e2834001 	add	r4, r3, #1
   16928:	e51b2010 	ldr	r2, [fp, #-16]
   1692c:	e3520000 	cmp	r2, #0
   16930:	0a000004 	beq	16948 <exponent+0x6c>
   16934:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   16938:	e20220ff 	and	r2, r2, #255	; 0xff
   1693c:	e282200f 	add	r2, r2, #15
   16940:	e20220ff 	and	r2, r2, #255	; 0xff
   16944:	ea000001 	b	16950 <exponent+0x74>
   16948:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   1694c:	e20220ff 	and	r2, r2, #255	; 0xff
   16950:	e5c32000 	strb	r2, [r3]
	if (exp < 0) {
   16954:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   16958:	e3530000 	cmp	r3, #0
   1695c:	aa000007 	bge	16980 <exponent+0xa4>
		exp = -exp;
   16960:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   16964:	e2633000 	rsb	r3, r3, #0
   16968:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		*p++ = '-';
   1696c:	e1a03004 	mov	r3, r4
   16970:	e2834001 	add	r4, r3, #1
   16974:	e3a0202d 	mov	r2, #45	; 0x2d
   16978:	e5c32000 	strb	r2, [r3]
   1697c:	ea000003 	b	16990 <exponent+0xb4>
	}
	else
		*p++ = '+';
   16980:	e1a03004 	mov	r3, r4
   16984:	e2834001 	add	r4, r3, #1
   16988:	e3a0202b 	mov	r2, #43	; 0x2b
   1698c:	e5c32000 	strb	r2, [r3]
	t = expbuf + MAXEXPLEN;
   16990:	e24b5018 	sub	r5, fp, #24
   16994:	e2855007 	add	r5, r5, #7
	if (exp > 9) {
   16998:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1699c:	e3530009 	cmp	r3, #9
   169a0:	da00002b 	ble	16a54 <exponent+0x178>
		do {
			*--t = to_char (exp % 10);
   169a4:	e2455001 	sub	r5, r5, #1
   169a8:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
   169ac:	e59f30f4 	ldr	r3, [pc, #244]	; 16aa8 <exponent+0x1cc>
   169b0:	e0c32391 	smull	r2, r3, r1, r3
   169b4:	e1a02143 	asr	r2, r3, #2
   169b8:	e1a03fc1 	asr	r3, r1, #31
   169bc:	e0632002 	rsb	r2, r3, r2
   169c0:	e1a03002 	mov	r3, r2
   169c4:	e1a03103 	lsl	r3, r3, #2
   169c8:	e0833002 	add	r3, r3, r2
   169cc:	e1a03083 	lsl	r3, r3, #1
   169d0:	e0632001 	rsb	r2, r3, r1
   169d4:	e20230ff 	and	r3, r2, #255	; 0xff
   169d8:	e2833030 	add	r3, r3, #48	; 0x30
   169dc:	e20330ff 	and	r3, r3, #255	; 0xff
   169e0:	e5c53000 	strb	r3, [r5]
		} while ((exp /= 10) > 9);
   169e4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   169e8:	e59f20b8 	ldr	r2, [pc, #184]	; 16aa8 <exponent+0x1cc>
   169ec:	e0c21293 	smull	r1, r2, r3, r2
   169f0:	e1a02142 	asr	r2, r2, #2
   169f4:	e1a03fc3 	asr	r3, r3, #31
   169f8:	e0633002 	rsb	r3, r3, r2
   169fc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   16a00:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   16a04:	e3530009 	cmp	r3, #9
   16a08:	caffffe5 	bgt	169a4 <exponent+0xc8>
		*--t = to_char (exp);
   16a0c:	e2455001 	sub	r5, r5, #1
   16a10:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   16a14:	e20330ff 	and	r3, r3, #255	; 0xff
   16a18:	e2833030 	add	r3, r3, #48	; 0x30
   16a1c:	e20330ff 	and	r3, r3, #255	; 0xff
   16a20:	e5c53000 	strb	r3, [r5]
		for (; t < expbuf + MAXEXPLEN; *p++ = *t++);
   16a24:	ea000005 	b	16a40 <exponent+0x164>
   16a28:	e1a03004 	mov	r3, r4
   16a2c:	e2834001 	add	r4, r3, #1
   16a30:	e1a02005 	mov	r2, r5
   16a34:	e2825001 	add	r5, r2, #1
   16a38:	e5d22000 	ldrb	r2, [r2]
   16a3c:	e5c32000 	strb	r2, [r3]
   16a40:	e24b3018 	sub	r3, fp, #24
   16a44:	e2833007 	add	r3, r3, #7
   16a48:	e1550003 	cmp	r5, r3
   16a4c:	3afffff5 	bcc	16a28 <exponent+0x14c>
   16a50:	ea00000d 	b	16a8c <exponent+0x1b0>
	}
	else {
		if (!isa)
   16a54:	e51b3010 	ldr	r3, [fp, #-16]
   16a58:	e3530000 	cmp	r3, #0
   16a5c:	1a000003 	bne	16a70 <exponent+0x194>
			*p++ = '0';
   16a60:	e1a03004 	mov	r3, r4
   16a64:	e2834001 	add	r4, r3, #1
   16a68:	e3a02030 	mov	r2, #48	; 0x30
   16a6c:	e5c32000 	strb	r2, [r3]
		*p++ = to_char (exp);
   16a70:	e1a03004 	mov	r3, r4
   16a74:	e2834001 	add	r4, r3, #1
   16a78:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   16a7c:	e20220ff 	and	r2, r2, #255	; 0xff
   16a80:	e2822030 	add	r2, r2, #48	; 0x30
   16a84:	e20220ff 	and	r2, r2, #255	; 0xff
   16a88:	e5c32000 	strb	r2, [r3]
	}
	return (p - p0);
   16a8c:	e1a02004 	mov	r2, r4
   16a90:	e51b3020 	ldr	r3, [fp, #-32]
   16a94:	e0633002 	rsb	r3, r3, r2
}
   16a98:	e1a00003 	mov	r0, r3
   16a9c:	e24bd008 	sub	sp, fp, #8
   16aa0:	e8bd0830 	pop	{r4, r5, fp}
   16aa4:	e12fff1e 	bx	lr
   16aa8:	66666667 	.word	0x66666667

00016aac <write>:
int
_DEFUN (_write, (file, ptr, len),
        int   file  _AND
        char *ptr   _AND
        int   len)
{
   16aac:	e92d4800 	push	{fp, lr}
   16ab0:	e28db004 	add	fp, sp, #4
   16ab4:	e24dd018 	sub	sp, sp, #24
   16ab8:	e50b0010 	str	r0, [fp, #-16]
   16abc:	e50b1014 	str	r1, [fp, #-20]
   16ac0:	e50b2018 	str	r2, [fp, #-24]
	status_t status = DNA_OK;
   16ac4:	e3a03000 	mov	r3, #0
   16ac8:	e14b30b6 	strh	r3, [fp, #-6]
	int32_t res = -1;
   16acc:	e3e03000 	mvn	r3, #0
   16ad0:	e50b300c 	str	r3, [fp, #-12]

	status = vfs_write (file, ptr, len, & res);
   16ad4:	e51b3010 	ldr	r3, [fp, #-16]
   16ad8:	e1a03803 	lsl	r3, r3, #16
   16adc:	e1a03823 	lsr	r3, r3, #16
   16ae0:	e1a03803 	lsl	r3, r3, #16
   16ae4:	e1a02843 	asr	r2, r3, #16
   16ae8:	e24b300c 	sub	r3, fp, #12
   16aec:	e1a00002 	mov	r0, r2
   16af0:	e51b1014 	ldr	r1, [fp, #-20]
   16af4:	e51b2018 	ldr	r2, [fp, #-24]
   16af8:	ebffc472 	bl	7cc8 <vfs_write>
   16afc:	e1a03000 	mov	r3, r0
   16b00:	e14b30b6 	strh	r3, [fp, #-6]
	return res;
   16b04:	e51b300c 	ldr	r3, [fp, #-12]
}
   16b08:	e1a00003 	mov	r0, r3
   16b0c:	e24bd004 	sub	sp, fp, #4
   16b10:	e8bd4800 	pop	{fp, lr}
   16b14:	e12fff1e 	bx	lr

00016b18 <__swsetup_r>:

int
_DEFUN(__swsetup_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   16b18:	e92d4810 	push	{r4, fp, lr}
   16b1c:	e28db008 	add	fp, sp, #8
   16b20:	e24dd014 	sub	sp, sp, #20
   16b24:	e50b0018 	str	r0, [fp, #-24]
   16b28:	e1a04001 	mov	r4, r1
  /* Make sure stdio is set up.  */

  CHECK_INIT (_REENT, fp);
   16b2c:	e59f31f8 	ldr	r3, [pc, #504]	; 16d2c <__swsetup_r+0x214>
   16b30:	e5933000 	ldr	r3, [r3]
   16b34:	e50b3010 	str	r3, [fp, #-16]
   16b38:	e51b3010 	ldr	r3, [fp, #-16]
   16b3c:	e3530000 	cmp	r3, #0
   16b40:	0a000005 	beq	16b5c <__swsetup_r+0x44>
   16b44:	e51b3010 	ldr	r3, [fp, #-16]
   16b48:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   16b4c:	e3530000 	cmp	r3, #0
   16b50:	1a000001 	bne	16b5c <__swsetup_r+0x44>
   16b54:	e51b0010 	ldr	r0, [fp, #-16]
   16b58:	eb000ab8 	bl	19640 <__sinit>

  /*
   * If we are not writing, we had better be reading and writing.
   */

  if ((fp->_flags & __SWR) == 0)
   16b5c:	e1d430bc 	ldrh	r3, [r4, #12]
   16b60:	e1a03803 	lsl	r3, r3, #16
   16b64:	e1a03823 	lsr	r3, r3, #16
   16b68:	e2033008 	and	r3, r3, #8
   16b6c:	e3530000 	cmp	r3, #0
   16b70:	1a000030 	bne	16c38 <__swsetup_r+0x120>
    {
      if ((fp->_flags & __SRW) == 0)
   16b74:	e1d430bc 	ldrh	r3, [r4, #12]
   16b78:	e1a03803 	lsl	r3, r3, #16
   16b7c:	e1a03823 	lsr	r3, r3, #16
   16b80:	e2033010 	and	r3, r3, #16
   16b84:	e3530000 	cmp	r3, #0
   16b88:	1a000009 	bne	16bb4 <__swsetup_r+0x9c>
        {
	  ptr->_errno = EBADF;
   16b8c:	e51b3018 	ldr	r3, [fp, #-24]
   16b90:	e3a02009 	mov	r2, #9
   16b94:	e5832000 	str	r2, [r3]
	  fp->_flags |= __SERR;
   16b98:	e1d430bc 	ldrh	r3, [r4, #12]
   16b9c:	e3833040 	orr	r3, r3, #64	; 0x40
   16ba0:	e1a03803 	lsl	r3, r3, #16
   16ba4:	e1a03823 	lsr	r3, r3, #16
   16ba8:	e1c430bc 	strh	r3, [r4, #12]
	  return EOF;
   16bac:	e3e03000 	mvn	r3, #0
   16bb0:	ea000059 	b	16d1c <__swsetup_r+0x204>
        }
      if (fp->_flags & __SRD)
   16bb4:	e1d430bc 	ldrh	r3, [r4, #12]
   16bb8:	e1a03803 	lsl	r3, r3, #16
   16bbc:	e1a03823 	lsr	r3, r3, #16
   16bc0:	e2033004 	and	r3, r3, #4
   16bc4:	e3530000 	cmp	r3, #0
   16bc8:	0a000015 	beq	16c24 <__swsetup_r+0x10c>
	{
	  /* clobber any ungetc data */
	  if (HASUB (fp))
   16bcc:	e5943030 	ldr	r3, [r4, #48]	; 0x30
   16bd0:	e3530000 	cmp	r3, #0
   16bd4:	0a000009 	beq	16c00 <__swsetup_r+0xe8>
	    FREEUB (ptr, fp);
   16bd8:	e5942030 	ldr	r2, [r4, #48]	; 0x30
   16bdc:	e2843040 	add	r3, r4, #64	; 0x40
   16be0:	e1520003 	cmp	r2, r3
   16be4:	0a000003 	beq	16bf8 <__swsetup_r+0xe0>
   16be8:	e5943030 	ldr	r3, [r4, #48]	; 0x30
   16bec:	e51b0018 	ldr	r0, [fp, #-24]
   16bf0:	e1a01003 	mov	r1, r3
   16bf4:	eb000b28 	bl	1989c <_free_r>
   16bf8:	e3a03000 	mov	r3, #0
   16bfc:	e5843030 	str	r3, [r4, #48]	; 0x30
	  fp->_flags &= ~(__SRD | __SEOF);
   16c00:	e1d430bc 	ldrh	r3, [r4, #12]
   16c04:	e3c33024 	bic	r3, r3, #36	; 0x24
   16c08:	e1a03803 	lsl	r3, r3, #16
   16c0c:	e1a03823 	lsr	r3, r3, #16
   16c10:	e1c430bc 	strh	r3, [r4, #12]
	  fp->_r = 0;
   16c14:	e3a03000 	mov	r3, #0
   16c18:	e5843004 	str	r3, [r4, #4]
	  fp->_p = fp->_bf._base;
   16c1c:	e5943010 	ldr	r3, [r4, #16]
   16c20:	e5843000 	str	r3, [r4]
	}
      fp->_flags |= __SWR;
   16c24:	e1d430bc 	ldrh	r3, [r4, #12]
   16c28:	e3833008 	orr	r3, r3, #8
   16c2c:	e1a03803 	lsl	r3, r3, #16
   16c30:	e1a03823 	lsr	r3, r3, #16
   16c34:	e1c430bc 	strh	r3, [r4, #12]
  /*
   * Make a buffer if necessary, then set _w.
   * A string I/O file should not explicitly allocate a buffer
   * unless asprintf is being used.
   */
  if (fp->_bf._base == NULL
   16c38:	e5943010 	ldr	r3, [r4, #16]
   16c3c:	e3530000 	cmp	r3, #0
   16c40:	1a00000e 	bne	16c80 <__swsetup_r+0x168>
        && (!(fp->_flags & __SSTR) || (fp->_flags & __SMBF)))
   16c44:	e1d430bc 	ldrh	r3, [r4, #12]
   16c48:	e1a03803 	lsl	r3, r3, #16
   16c4c:	e1a03823 	lsr	r3, r3, #16
   16c50:	e2033c02 	and	r3, r3, #512	; 0x200
   16c54:	e3530000 	cmp	r3, #0
   16c58:	0a000005 	beq	16c74 <__swsetup_r+0x15c>
   16c5c:	e1d430bc 	ldrh	r3, [r4, #12]
   16c60:	e1a03803 	lsl	r3, r3, #16
   16c64:	e1a03823 	lsr	r3, r3, #16
   16c68:	e2033080 	and	r3, r3, #128	; 0x80
   16c6c:	e3530000 	cmp	r3, #0
   16c70:	0a000002 	beq	16c80 <__swsetup_r+0x168>
    __smakebuf_r (ptr, fp);
   16c74:	e51b0018 	ldr	r0, [fp, #-24]
   16c78:	e1a01004 	mov	r1, r4
   16c7c:	eb000f4b 	bl	1a9b0 <__smakebuf_r>

  if (fp->_flags & __SLBF)
   16c80:	e1d430bc 	ldrh	r3, [r4, #12]
   16c84:	e1a03803 	lsl	r3, r3, #16
   16c88:	e1a03823 	lsr	r3, r3, #16
   16c8c:	e2033001 	and	r3, r3, #1
   16c90:	e3530000 	cmp	r3, #0
   16c94:	0a000005 	beq	16cb0 <__swsetup_r+0x198>
      /*
       * It is line buffered, so make _lbfsize be -_bufsize
       * for the putc() macro.  We will change _lbfsize back
       * to 0 whenever we turn off __SWR.
       */
      fp->_w = 0;
   16c98:	e3a03000 	mov	r3, #0
   16c9c:	e5843008 	str	r3, [r4, #8]
      fp->_lbfsize = -fp->_bf._size;
   16ca0:	e5943014 	ldr	r3, [r4, #20]
   16ca4:	e2633000 	rsb	r3, r3, #0
   16ca8:	e5843018 	str	r3, [r4, #24]
   16cac:	ea000009 	b	16cd8 <__swsetup_r+0x1c0>
    }
  else
    fp->_w = fp->_flags & __SNBF ? 0 : fp->_bf._size;
   16cb0:	e1d430bc 	ldrh	r3, [r4, #12]
   16cb4:	e1a03803 	lsl	r3, r3, #16
   16cb8:	e1a03823 	lsr	r3, r3, #16
   16cbc:	e2033002 	and	r3, r3, #2
   16cc0:	e3530000 	cmp	r3, #0
   16cc4:	1a000001 	bne	16cd0 <__swsetup_r+0x1b8>
   16cc8:	e5943014 	ldr	r3, [r4, #20]
   16ccc:	ea000000 	b	16cd4 <__swsetup_r+0x1bc>
   16cd0:	e3a03000 	mov	r3, #0
   16cd4:	e5843008 	str	r3, [r4, #8]

  if (!fp->_bf._base && (fp->_flags & __SMBF))
   16cd8:	e5943010 	ldr	r3, [r4, #16]
   16cdc:	e3530000 	cmp	r3, #0
   16ce0:	1a00000c 	bne	16d18 <__swsetup_r+0x200>
   16ce4:	e1d430bc 	ldrh	r3, [r4, #12]
   16ce8:	e1a03803 	lsl	r3, r3, #16
   16cec:	e1a03823 	lsr	r3, r3, #16
   16cf0:	e2033080 	and	r3, r3, #128	; 0x80
   16cf4:	e3530000 	cmp	r3, #0
   16cf8:	0a000006 	beq	16d18 <__swsetup_r+0x200>
    {
      /* __smakebuf_r set errno, but not flag */
      fp->_flags |= __SERR;
   16cfc:	e1d430bc 	ldrh	r3, [r4, #12]
   16d00:	e3833040 	orr	r3, r3, #64	; 0x40
   16d04:	e1a03803 	lsl	r3, r3, #16
   16d08:	e1a03823 	lsr	r3, r3, #16
   16d0c:	e1c430bc 	strh	r3, [r4, #12]
      return EOF;
   16d10:	e3e03000 	mvn	r3, #0
   16d14:	ea000000 	b	16d1c <__swsetup_r+0x204>
    }
  return 0;
   16d18:	e3a03000 	mov	r3, #0
}
   16d1c:	e1a00003 	mov	r0, r3
   16d20:	e24bd008 	sub	sp, fp, #8
   16d24:	e8bd4810 	pop	{r4, fp, lr}
   16d28:	e12fff1e 	bx	lr
   16d2c:	00025440 	.word	0x00025440

00016d30 <quorem>:

static int
_DEFUN (quorem,
	(b, S),
	_Bigint * b _AND _Bigint * S)
{
   16d30:	e92d4800 	push	{fp, lr}
   16d34:	e28db004 	add	fp, sp, #4
   16d38:	e24dd040 	sub	sp, sp, #64	; 0x40
   16d3c:	e50b0040 	str	r0, [fp, #-64]	; 0x40
   16d40:	e50b1044 	str	r1, [fp, #-68]	; 0x44
#ifdef Pack_32
  __Long z;
  __ULong si, zs;
#endif

  n = S->_wds;
   16d44:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   16d48:	e5933010 	ldr	r3, [r3, #16]
   16d4c:	e50b3008 	str	r3, [fp, #-8]
#ifdef DEBUG
  /*debug*/ if (b->_wds > n)
    /*debug*/ Bug ("oversize b in quorem");
#endif
  if (b->_wds < n)
   16d50:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   16d54:	e5932010 	ldr	r2, [r3, #16]
   16d58:	e51b3008 	ldr	r3, [fp, #-8]
   16d5c:	e1520003 	cmp	r2, r3
   16d60:	aa000001 	bge	16d6c <quorem+0x3c>
    return 0;
   16d64:	e3a03000 	mov	r3, #0
   16d68:	ea0000ec 	b	17120 <quorem+0x3f0>
  sx = S->_x;
   16d6c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   16d70:	e2833014 	add	r3, r3, #20
   16d74:	e50b3020 	str	r3, [fp, #-32]
  sxe = sx + --n;
   16d78:	e51b3008 	ldr	r3, [fp, #-8]
   16d7c:	e2433001 	sub	r3, r3, #1
   16d80:	e50b3008 	str	r3, [fp, #-8]
   16d84:	e51b3008 	ldr	r3, [fp, #-8]
   16d88:	e1a03103 	lsl	r3, r3, #2
   16d8c:	e51b2020 	ldr	r2, [fp, #-32]
   16d90:	e0823003 	add	r3, r2, r3
   16d94:	e50b3024 	str	r3, [fp, #-36]	; 0x24
  bx = b->_x;
   16d98:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   16d9c:	e2833014 	add	r3, r3, #20
   16da0:	e50b3018 	str	r3, [fp, #-24]
  bxe = bx + n;
   16da4:	e51b3008 	ldr	r3, [fp, #-8]
   16da8:	e1a03103 	lsl	r3, r3, #2
   16dac:	e51b2018 	ldr	r2, [fp, #-24]
   16db0:	e0823003 	add	r3, r2, r3
   16db4:	e50b301c 	str	r3, [fp, #-28]
  q = *bxe / (*sxe + 1);	/* ensure q <= true quotient */
   16db8:	e51b301c 	ldr	r3, [fp, #-28]
   16dbc:	e5932000 	ldr	r2, [r3]
   16dc0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   16dc4:	e5933000 	ldr	r3, [r3]
   16dc8:	e2833001 	add	r3, r3, #1
   16dcc:	e1a00002 	mov	r0, r2
   16dd0:	e1a01003 	mov	r1, r3
   16dd4:	ebffdb43 	bl	dae8 <__aeabi_uidiv>
   16dd8:	e1a03000 	mov	r3, r0
   16ddc:	e50b3014 	str	r3, [fp, #-20]
#ifdef DEBUG
  /*debug*/ if (q > 9)
    /*debug*/ Bug ("oversized quotient in quorem");
#endif
  if (q)
   16de0:	e51b3014 	ldr	r3, [fp, #-20]
   16de4:	e3530000 	cmp	r3, #0
   16de8:	0a00005d 	beq	16f64 <quorem+0x234>
    {
      borrow = 0;
   16dec:	e3a03000 	mov	r3, #0
   16df0:	e50b300c 	str	r3, [fp, #-12]
      carry = 0;
   16df4:	e3a03000 	mov	r3, #0
   16df8:	e50b3010 	str	r3, [fp, #-16]
      do
	{
#ifdef Pack_32
	  si = *sx++;
   16dfc:	e51b3020 	ldr	r3, [fp, #-32]
   16e00:	e2832004 	add	r2, r3, #4
   16e04:	e50b2020 	str	r2, [fp, #-32]
   16e08:	e5933000 	ldr	r3, [r3]
   16e0c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	  ys = (si & 0xffff) * q + carry;
   16e10:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   16e14:	e1a03803 	lsl	r3, r3, #16
   16e18:	e1a03823 	lsr	r3, r3, #16
   16e1c:	e51b2014 	ldr	r2, [fp, #-20]
   16e20:	e0020293 	mul	r2, r3, r2
   16e24:	e51b3010 	ldr	r3, [fp, #-16]
   16e28:	e0823003 	add	r3, r2, r3
   16e2c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	  zs = (si >> 16) * q + (ys >> 16);
   16e30:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   16e34:	e1a03823 	lsr	r3, r3, #16
   16e38:	e51b2014 	ldr	r2, [fp, #-20]
   16e3c:	e0020293 	mul	r2, r3, r2
   16e40:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   16e44:	e1a03823 	lsr	r3, r3, #16
   16e48:	e0823003 	add	r3, r2, r3
   16e4c:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	  carry = zs >> 16;
   16e50:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   16e54:	e1a03823 	lsr	r3, r3, #16
   16e58:	e50b3010 	str	r3, [fp, #-16]
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   16e5c:	e51b3018 	ldr	r3, [fp, #-24]
   16e60:	e5933000 	ldr	r3, [r3]
   16e64:	e1a02803 	lsl	r2, r3, #16
   16e68:	e1a02822 	lsr	r2, r2, #16
   16e6c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   16e70:	e1a03803 	lsl	r3, r3, #16
   16e74:	e1a03823 	lsr	r3, r3, #16
   16e78:	e0632002 	rsb	r2, r3, r2
   16e7c:	e51b300c 	ldr	r3, [fp, #-12]
   16e80:	e0823003 	add	r3, r2, r3
   16e84:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	  borrow = y >> 16;
   16e88:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   16e8c:	e1a03843 	asr	r3, r3, #16
   16e90:	e50b300c 	str	r3, [fp, #-12]
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   16e94:	e51b3018 	ldr	r3, [fp, #-24]
   16e98:	e5933000 	ldr	r3, [r3]
   16e9c:	e1a02823 	lsr	r2, r3, #16
   16ea0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   16ea4:	e1a03803 	lsl	r3, r3, #16
   16ea8:	e1a03823 	lsr	r3, r3, #16
   16eac:	e0632002 	rsb	r2, r3, r2
   16eb0:	e51b300c 	ldr	r3, [fp, #-12]
   16eb4:	e0823003 	add	r3, r2, r3
   16eb8:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	  borrow = z >> 16;
   16ebc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   16ec0:	e1a03843 	asr	r3, r3, #16
   16ec4:	e50b300c 	str	r3, [fp, #-12]
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   16ec8:	e51b2018 	ldr	r2, [fp, #-24]
   16ecc:	e2823004 	add	r3, r2, #4
   16ed0:	e50b3018 	str	r3, [fp, #-24]
   16ed4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   16ed8:	e1a01803 	lsl	r1, r3, #16
   16edc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   16ee0:	e1a03803 	lsl	r3, r3, #16
   16ee4:	e1a03823 	lsr	r3, r3, #16
   16ee8:	e1813003 	orr	r3, r1, r3
   16eec:	e5823000 	str	r3, [r2]
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
   16ef0:	e51b2020 	ldr	r2, [fp, #-32]
   16ef4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   16ef8:	e1520003 	cmp	r2, r3
   16efc:	9affffbe 	bls	16dfc <quorem+0xcc>
      if (!*bxe)
   16f00:	e51b301c 	ldr	r3, [fp, #-28]
   16f04:	e5933000 	ldr	r3, [r3]
   16f08:	e3530000 	cmp	r3, #0
   16f0c:	1a000014 	bne	16f64 <quorem+0x234>
	{
	  bx = b->_x;
   16f10:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   16f14:	e2833014 	add	r3, r3, #20
   16f18:	e50b3018 	str	r3, [fp, #-24]
	  while (--bxe > bx && !*bxe)
   16f1c:	ea000002 	b	16f2c <quorem+0x1fc>
	    --n;
   16f20:	e51b3008 	ldr	r3, [fp, #-8]
   16f24:	e2433001 	sub	r3, r3, #1
   16f28:	e50b3008 	str	r3, [fp, #-8]
	}
      while (sx <= sxe);
      if (!*bxe)
	{
	  bx = b->_x;
	  while (--bxe > bx && !*bxe)
   16f2c:	e51b301c 	ldr	r3, [fp, #-28]
   16f30:	e2433004 	sub	r3, r3, #4
   16f34:	e50b301c 	str	r3, [fp, #-28]
   16f38:	e51b201c 	ldr	r2, [fp, #-28]
   16f3c:	e51b3018 	ldr	r3, [fp, #-24]
   16f40:	e1520003 	cmp	r2, r3
   16f44:	9a000003 	bls	16f58 <quorem+0x228>
   16f48:	e51b301c 	ldr	r3, [fp, #-28]
   16f4c:	e5933000 	ldr	r3, [r3]
   16f50:	e3530000 	cmp	r3, #0
   16f54:	0afffff1 	beq	16f20 <quorem+0x1f0>
	    --n;
	  b->_wds = n;
   16f58:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   16f5c:	e51b2008 	ldr	r2, [fp, #-8]
   16f60:	e5832010 	str	r2, [r3, #16]
	}
    }
  if (cmp (b, S) >= 0)
   16f64:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   16f68:	e51b1044 	ldr	r1, [fp, #-68]	; 0x44
   16f6c:	eb0013a1 	bl	1bdf8 <__mcmp>
   16f70:	e1a03000 	mov	r3, r0
   16f74:	e3530000 	cmp	r3, #0
   16f78:	ba000067 	blt	1711c <quorem+0x3ec>
    {
      q++;
   16f7c:	e51b3014 	ldr	r3, [fp, #-20]
   16f80:	e2833001 	add	r3, r3, #1
   16f84:	e50b3014 	str	r3, [fp, #-20]
      borrow = 0;
   16f88:	e3a03000 	mov	r3, #0
   16f8c:	e50b300c 	str	r3, [fp, #-12]
      carry = 0;
   16f90:	e3a03000 	mov	r3, #0
   16f94:	e50b3010 	str	r3, [fp, #-16]
      bx = b->_x;
   16f98:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   16f9c:	e2833014 	add	r3, r3, #20
   16fa0:	e50b3018 	str	r3, [fp, #-24]
      sx = S->_x;
   16fa4:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   16fa8:	e2833014 	add	r3, r3, #20
   16fac:	e50b3020 	str	r3, [fp, #-32]
      do
	{
#ifdef Pack_32
	  si = *sx++;
   16fb0:	e51b3020 	ldr	r3, [fp, #-32]
   16fb4:	e2832004 	add	r2, r3, #4
   16fb8:	e50b2020 	str	r2, [fp, #-32]
   16fbc:	e5933000 	ldr	r3, [r3]
   16fc0:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	  ys = (si & 0xffff) + carry;
   16fc4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   16fc8:	e1a03803 	lsl	r3, r3, #16
   16fcc:	e1a03823 	lsr	r3, r3, #16
   16fd0:	e51b2010 	ldr	r2, [fp, #-16]
   16fd4:	e0833002 	add	r3, r3, r2
   16fd8:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	  zs = (si >> 16) + (ys >> 16);
   16fdc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   16fe0:	e1a02823 	lsr	r2, r3, #16
   16fe4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   16fe8:	e1a03823 	lsr	r3, r3, #16
   16fec:	e0823003 	add	r3, r2, r3
   16ff0:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	  carry = zs >> 16;
   16ff4:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   16ff8:	e1a03823 	lsr	r3, r3, #16
   16ffc:	e50b3010 	str	r3, [fp, #-16]
	  y = (*bx & 0xffff) - (ys & 0xffff) + borrow;
   17000:	e51b3018 	ldr	r3, [fp, #-24]
   17004:	e5933000 	ldr	r3, [r3]
   17008:	e1a02803 	lsl	r2, r3, #16
   1700c:	e1a02822 	lsr	r2, r2, #16
   17010:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17014:	e1a03803 	lsl	r3, r3, #16
   17018:	e1a03823 	lsr	r3, r3, #16
   1701c:	e0632002 	rsb	r2, r3, r2
   17020:	e51b300c 	ldr	r3, [fp, #-12]
   17024:	e0823003 	add	r3, r2, r3
   17028:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	  borrow = y >> 16;
   1702c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   17030:	e1a03843 	asr	r3, r3, #16
   17034:	e50b300c 	str	r3, [fp, #-12]
	  Sign_Extend (borrow, y);
	  z = (*bx >> 16) - (zs & 0xffff) + borrow;
   17038:	e51b3018 	ldr	r3, [fp, #-24]
   1703c:	e5933000 	ldr	r3, [r3]
   17040:	e1a02823 	lsr	r2, r3, #16
   17044:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   17048:	e1a03803 	lsl	r3, r3, #16
   1704c:	e1a03823 	lsr	r3, r3, #16
   17050:	e0632002 	rsb	r2, r3, r2
   17054:	e51b300c 	ldr	r3, [fp, #-12]
   17058:	e0823003 	add	r3, r2, r3
   1705c:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	  borrow = z >> 16;
   17060:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   17064:	e1a03843 	asr	r3, r3, #16
   17068:	e50b300c 	str	r3, [fp, #-12]
	  Sign_Extend (borrow, z);
	  Storeinc (bx, z, y);
   1706c:	e51b2018 	ldr	r2, [fp, #-24]
   17070:	e2823004 	add	r3, r2, #4
   17074:	e50b3018 	str	r3, [fp, #-24]
   17078:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1707c:	e1a01803 	lsl	r1, r3, #16
   17080:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   17084:	e1a03803 	lsl	r3, r3, #16
   17088:	e1a03823 	lsr	r3, r3, #16
   1708c:	e1813003 	orr	r3, r1, r3
   17090:	e5823000 	str	r3, [r2]
	  borrow = y >> 16;
	  Sign_Extend (borrow, y);
	  *bx++ = y & 0xffff;
#endif
	}
      while (sx <= sxe);
   17094:	e51b2020 	ldr	r2, [fp, #-32]
   17098:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1709c:	e1520003 	cmp	r2, r3
   170a0:	9affffc2 	bls	16fb0 <quorem+0x280>
      bx = b->_x;
   170a4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   170a8:	e2833014 	add	r3, r3, #20
   170ac:	e50b3018 	str	r3, [fp, #-24]
      bxe = bx + n;
   170b0:	e51b3008 	ldr	r3, [fp, #-8]
   170b4:	e1a03103 	lsl	r3, r3, #2
   170b8:	e51b2018 	ldr	r2, [fp, #-24]
   170bc:	e0823003 	add	r3, r2, r3
   170c0:	e50b301c 	str	r3, [fp, #-28]
      if (!*bxe)
   170c4:	e51b301c 	ldr	r3, [fp, #-28]
   170c8:	e5933000 	ldr	r3, [r3]
   170cc:	e3530000 	cmp	r3, #0
   170d0:	1a000011 	bne	1711c <quorem+0x3ec>
	{
	  while (--bxe > bx && !*bxe)
   170d4:	ea000002 	b	170e4 <quorem+0x3b4>
	    --n;
   170d8:	e51b3008 	ldr	r3, [fp, #-8]
   170dc:	e2433001 	sub	r3, r3, #1
   170e0:	e50b3008 	str	r3, [fp, #-8]
      while (sx <= sxe);
      bx = b->_x;
      bxe = bx + n;
      if (!*bxe)
	{
	  while (--bxe > bx && !*bxe)
   170e4:	e51b301c 	ldr	r3, [fp, #-28]
   170e8:	e2433004 	sub	r3, r3, #4
   170ec:	e50b301c 	str	r3, [fp, #-28]
   170f0:	e51b201c 	ldr	r2, [fp, #-28]
   170f4:	e51b3018 	ldr	r3, [fp, #-24]
   170f8:	e1520003 	cmp	r2, r3
   170fc:	9a000003 	bls	17110 <quorem+0x3e0>
   17100:	e51b301c 	ldr	r3, [fp, #-28]
   17104:	e5933000 	ldr	r3, [r3]
   17108:	e3530000 	cmp	r3, #0
   1710c:	0afffff1 	beq	170d8 <quorem+0x3a8>
	    --n;
	  b->_wds = n;
   17110:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   17114:	e51b2008 	ldr	r2, [fp, #-8]
   17118:	e5832010 	str	r2, [r3, #16]
	}
    }
  return q;
   1711c:	e51b3014 	ldr	r3, [fp, #-20]
}
   17120:	e1a00003 	mov	r0, r3
   17124:	e24bd004 	sub	sp, fp, #4
   17128:	e8bd4800 	pop	{fp, lr}
   1712c:	e12fff1e 	bx	lr

00017130 <_dtoa_r>:
	int mode _AND
	int ndigits _AND
	int *decpt _AND
	int *sign _AND
	char **rve)
{
   17130:	e92d48f0 	push	{r4, r5, r6, r7, fp, lr}
   17134:	e28db014 	add	fp, sp, #20
   17138:	e24dd0c0 	sub	sp, sp, #192	; 0xc0
   1713c:	e50b00c0 	str	r0, [fp, #-192]	; 0xc0
   17140:	e50b20cc 	str	r2, [fp, #-204]	; 0xcc
   17144:	e50b30c8 	str	r3, [fp, #-200]	; 0xc8
  __Long L;
#ifndef Sudden_Underflow
  int denorm;
  __ULong x;
#endif
  _Bigint *b, *b1, *delta, *mlo = NULL, *mhi, *S;
   17148:	e3a03000 	mov	r3, #0
   1714c:	e50b3064 	str	r3, [fp, #-100]	; 0x64
  double ds;
  char *s, *s0;

  d.d = _d;
   17150:	e24b30cc 	sub	r3, fp, #204	; 0xcc
   17154:	e893000c 	ldm	r3, {r2, r3}
   17158:	e50b20ac 	str	r2, [fp, #-172]	; 0xac
   1715c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_RESULT(ptr))
   17160:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   17164:	e5933040 	ldr	r3, [r3, #64]	; 0x40
   17168:	e3530000 	cmp	r3, #0
   1716c:	0a000013 	beq	171c0 <_dtoa_r+0x90>
    {
      _REENT_MP_RESULT(ptr)->_k = _REENT_MP_RESULT_K(ptr);
   17170:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   17174:	e5933040 	ldr	r3, [r3, #64]	; 0x40
   17178:	e51b20c0 	ldr	r2, [fp, #-192]	; 0xc0
   1717c:	e5922044 	ldr	r2, [r2, #68]	; 0x44
   17180:	e5832004 	str	r2, [r3, #4]
      _REENT_MP_RESULT(ptr)->_maxwds = 1 << _REENT_MP_RESULT_K(ptr);
   17184:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   17188:	e5933040 	ldr	r3, [r3, #64]	; 0x40
   1718c:	e51b20c0 	ldr	r2, [fp, #-192]	; 0xc0
   17190:	e5922044 	ldr	r2, [r2, #68]	; 0x44
   17194:	e3a01001 	mov	r1, #1
   17198:	e1a02211 	lsl	r2, r1, r2
   1719c:	e5832008 	str	r2, [r3, #8]
      Bfree (ptr, _REENT_MP_RESULT(ptr));
   171a0:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   171a4:	e5933040 	ldr	r3, [r3, #64]	; 0x40
   171a8:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   171ac:	e1a01003 	mov	r1, r3
   171b0:	eb000fcc 	bl	1b0e8 <_Bfree>
      _REENT_MP_RESULT(ptr) = 0;
   171b4:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   171b8:	e3a02000 	mov	r2, #0
   171bc:	e5832040 	str	r2, [r3, #64]	; 0x40
    }

  if (word0 (d) & Sign_bit)
   171c0:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   171c4:	e3530000 	cmp	r3, #0
   171c8:	aa000006 	bge	171e8 <_dtoa_r+0xb8>
    {
      /* set sign for everything, including 0's and NaNs */
      *sign = 1;
   171cc:	e59b3010 	ldr	r3, [fp, #16]
   171d0:	e3a02001 	mov	r2, #1
   171d4:	e5832000 	str	r2, [r3]
      word0 (d) &= ~Sign_bit;	/* clear sign bit */
   171d8:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   171dc:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   171e0:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   171e4:	ea000002 	b	171f4 <_dtoa_r+0xc4>
    }
  else
    *sign = 0;
   171e8:	e59b3010 	ldr	r3, [fp, #16]
   171ec:	e3a02000 	mov	r2, #0
   171f0:	e5832000 	str	r2, [r3]

#if defined(IEEE_Arith) + defined(VAX)
#ifdef IEEE_Arith
  if ((word0 (d) & Exp_mask) == Exp_mask)
   171f4:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   171f8:	e59f35a8 	ldr	r3, [pc, #1448]	; 177a8 <_dtoa_r+0x678>
   171fc:	e0033002 	and	r3, r3, r2
   17200:	e59f25a0 	ldr	r2, [pc, #1440]	; 177a8 <_dtoa_r+0x678>
   17204:	e1530002 	cmp	r3, r2
   17208:	1a00001f 	bne	1728c <_dtoa_r+0x15c>
#else
  if (word0 (d) == 0x8000)
#endif
    {
      /* Infinity or NaN */
      *decpt = 9999;
   1720c:	e59b300c 	ldr	r3, [fp, #12]
   17210:	e59f2560 	ldr	r2, [pc, #1376]	; 17778 <_dtoa_r+0x648>
   17214:	e5832000 	str	r2, [r3]
      s =
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
   17218:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1721c:	e3530000 	cmp	r3, #0
   17220:	1a000006 	bne	17240 <_dtoa_r+0x110>
   17224:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   17228:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
   1722c:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   17230:	e3530000 	cmp	r3, #0
   17234:	1a000001 	bne	17240 <_dtoa_r+0x110>
   17238:	e59f353c 	ldr	r3, [pc, #1340]	; 1777c <_dtoa_r+0x64c>
   1723c:	ea000000 	b	17244 <_dtoa_r+0x114>
   17240:	e59f3538 	ldr	r3, [pc, #1336]	; 17780 <_dtoa_r+0x650>
  if (word0 (d) == 0x8000)
#endif
    {
      /* Infinity or NaN */
      *decpt = 9999;
      s =
   17244:	e50b3078 	str	r3, [fp, #-120]	; 0x78
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
#endif
	"NaN";
      if (rve)
   17248:	e59b3014 	ldr	r3, [fp, #20]
   1724c:	e3530000 	cmp	r3, #0
   17250:	0a00000b 	beq	17284 <_dtoa_r+0x154>
	*rve =
#ifdef IEEE_Arith
	  s[3] ? s + 8 :
   17254:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   17258:	e2833003 	add	r3, r3, #3
   1725c:	e5d33000 	ldrb	r3, [r3]
   17260:	e3530000 	cmp	r3, #0
   17264:	0a000002 	beq	17274 <_dtoa_r+0x144>
   17268:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1726c:	e2833008 	add	r3, r3, #8
   17270:	ea000001 	b	1727c <_dtoa_r+0x14c>
   17274:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   17278:	e2833003 	add	r3, r3, #3
#ifdef IEEE_Arith
	!word1 (d) && !(word0 (d) & 0xfffff) ? "Infinity" :
#endif
	"NaN";
      if (rve)
	*rve =
   1727c:	e59b2014 	ldr	r2, [fp, #20]
   17280:	e5823000 	str	r3, [r2]
#ifdef IEEE_Arith
	  s[3] ? s + 8 :
#endif
	  s + 3;
      return s;
   17284:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   17288:	ea0006a4 	b	18d20 <_dtoa_r+0x1bf0>
    }
#endif
#ifdef IBM
  d.d += 0;			/* normalize */
#endif
  if (!d.d)
   1728c:	e24b30ac 	sub	r3, fp, #172	; 0xac
   17290:	e893000c 	ldm	r3, {r2, r3}
   17294:	e1a00002 	mov	r0, r2
   17298:	e1a01003 	mov	r1, r3
   1729c:	e3a02000 	mov	r2, #0
   172a0:	e3a03000 	mov	r3, #0
   172a4:	eb002e51 	bl	22bf0 <__aeabi_dcmpeq>
   172a8:	e1a03000 	mov	r3, r0
   172ac:	e3530000 	cmp	r3, #0
   172b0:	0a00000d 	beq	172ec <_dtoa_r+0x1bc>
    {
      *decpt = 1;
   172b4:	e59b300c 	ldr	r3, [fp, #12]
   172b8:	e3a02001 	mov	r2, #1
   172bc:	e5832000 	str	r2, [r3]
      s = "0";
   172c0:	e59f34bc 	ldr	r3, [pc, #1212]	; 17784 <_dtoa_r+0x654>
   172c4:	e50b3078 	str	r3, [fp, #-120]	; 0x78
      if (rve)
   172c8:	e59b3014 	ldr	r3, [fp, #20]
   172cc:	e3530000 	cmp	r3, #0
   172d0:	0a000003 	beq	172e4 <_dtoa_r+0x1b4>
	*rve = s + 1;
   172d4:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   172d8:	e2832001 	add	r2, r3, #1
   172dc:	e59b3014 	ldr	r3, [fp, #20]
   172e0:	e5832000 	str	r2, [r3]
      return s;
   172e4:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   172e8:	ea00068c 	b	18d20 <_dtoa_r+0x1bf0>
    }

  b = d2b (ptr, d.d, &be, &bbits);
   172ec:	e24b30ac 	sub	r3, fp, #172	; 0xac
   172f0:	e893000c 	ldm	r3, {r2, r3}
   172f4:	e24b10a0 	sub	r1, fp, #160	; 0xa0
   172f8:	e58d1000 	str	r1, [sp]
   172fc:	e24b109c 	sub	r1, fp, #156	; 0x9c
   17300:	e58d1004 	str	r1, [sp, #4]
   17304:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   17308:	eb00145e 	bl	1c488 <__d2b>
   1730c:	e50b0060 	str	r0, [fp, #-96]	; 0x60
#ifdef Sudden_Underflow
  i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1));
#else
  if ((i = (int) (word0 (d) >> Exp_shift1 & (Exp_mask >> Exp_shift1))) != 0)
   17310:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   17314:	e1a03a23 	lsr	r3, r3, #20
   17318:	e1a03a83 	lsl	r3, r3, #21
   1731c:	e1a03aa3 	lsr	r3, r3, #21
   17320:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   17324:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17328:	e3530000 	cmp	r3, #0
   1732c:	0a000012 	beq	1737c <_dtoa_r+0x24c>
    {
#endif
      d2.d = d.d;
   17330:	e24b30ac 	sub	r3, fp, #172	; 0xac
   17334:	e893000c 	ldm	r3, {r2, r3}
   17338:	e50b20b4 	str	r2, [fp, #-180]	; 0xb4
   1733c:	e50b30b0 	str	r3, [fp, #-176]	; 0xb0
      word0 (d2) &= Frac_mask1;
   17340:	e51b30b0 	ldr	r3, [fp, #-176]	; 0xb0
   17344:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
   17348:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   1734c:	e50b30b0 	str	r3, [fp, #-176]	; 0xb0
      word0 (d2) |= Exp_11;
   17350:	e51b30b0 	ldr	r3, [fp, #-176]	; 0xb0
   17354:	e38335ff 	orr	r3, r3, #1069547520	; 0x3fc00000
   17358:	e3833603 	orr	r3, r3, #3145728	; 0x300000
   1735c:	e50b30b0 	str	r3, [fp, #-176]	; 0xb0
		 * Hence we adjust the constant term to 0.1760912590558.
		 * (We could get a more accurate k by invoking log10,
		 *  but this is probably not worthwhile.)
		 */

      i -= Bias;
   17360:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17364:	e2433fff 	sub	r3, r3, #1020	; 0x3fc
   17368:	e2433003 	sub	r3, r3, #3
   1736c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
#ifdef IBM
      i <<= 2;
      i += j;
#endif
#ifndef Sudden_Underflow
      denorm = 0;
   17370:	e3a03000 	mov	r3, #0
   17374:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   17378:	ea000026 	b	17418 <_dtoa_r+0x2e8>
    }
  else
    {
      /* d is denormalized */

      i = bbits + be + (Bias + (P - 1) - 1);
   1737c:	e51b209c 	ldr	r2, [fp, #-156]	; 0x9c
   17380:	e51b30a0 	ldr	r3, [fp, #-160]	; 0xa0
   17384:	e0823003 	add	r3, r2, r3
   17388:	e2833e43 	add	r3, r3, #1072	; 0x430
   1738c:	e2833002 	add	r3, r3, #2
   17390:	e50b3024 	str	r3, [fp, #-36]	; 0x24
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
   17394:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17398:	e3530020 	cmp	r3, #32
   1739c:	da000009 	ble	173c8 <_dtoa_r+0x298>
   173a0:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   173a4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   173a8:	e2633040 	rsb	r3, r3, #64	; 0x40
   173ac:	e1a02312 	lsl	r2, r2, r3
   173b0:	e51b10ac 	ldr	r1, [fp, #-172]	; 0xac
   173b4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   173b8:	e2433020 	sub	r3, r3, #32
   173bc:	e1a03331 	lsr	r3, r1, r3
   173c0:	e1823003 	orr	r3, r2, r3
   173c4:	ea000003 	b	173d8 <_dtoa_r+0x2a8>
       : (word1 (d) << (32 - i));
   173c8:	e51b20ac 	ldr	r2, [fp, #-172]	; 0xac
   173cc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   173d0:	e2633020 	rsb	r3, r3, #32

      i = bbits + be + (Bias + (P - 1) - 1);
#if defined (_DOUBLE_IS_32BITS)
      x = word0 (d) << (32 - i);
#else
      x = (i > 32) ? (word0 (d) << (64 - i)) | (word1 (d) >> (i - 32))
   173d4:	e1a03312 	lsl	r3, r2, r3
   173d8:	e50b307c 	str	r3, [fp, #-124]	; 0x7c
       : (word1 (d) << (32 - i));
#endif
      d2.d = x;
   173dc:	e51b007c 	ldr	r0, [fp, #-124]	; 0x7c
   173e0:	eb002c68 	bl	22588 <__aeabi_ui2d>
   173e4:	e1a02000 	mov	r2, r0
   173e8:	e1a03001 	mov	r3, r1
   173ec:	e50b20b4 	str	r2, [fp, #-180]	; 0xb4
   173f0:	e50b30b0 	str	r3, [fp, #-176]	; 0xb0
      word0 (d2) -= 31 * Exp_msk1;	/* adjust exponent */
   173f4:	e51b30b0 	ldr	r3, [fp, #-176]	; 0xb0
   173f8:	e243361f 	sub	r3, r3, #32505856	; 0x1f00000
   173fc:	e50b30b0 	str	r3, [fp, #-176]	; 0xb0
      i -= (Bias + (P - 1) - 1) + 1;
   17400:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17404:	e2433e43 	sub	r3, r3, #1072	; 0x430
   17408:	e2433003 	sub	r3, r3, #3
   1740c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      denorm = 1;
   17410:	e3a03001 	mov	r3, #1
   17414:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
    }
#endif
#if defined (_DOUBLE_IS_32BITS)
  ds = (d2.d - 1.5) * 0.289529651 + 0.176091269 + i * 0.30103001;
#else
  ds = (d2.d - 1.5) * 0.289529654602168 + 0.1760912590558 + i * 0.301029995663981;
   17418:	e24b30b4 	sub	r3, fp, #180	; 0xb4
   1741c:	e893000c 	ldm	r3, {r2, r3}
   17420:	e1a00002 	mov	r0, r2
   17424:	e1a01003 	mov	r1, r3
   17428:	e3a02000 	mov	r2, #0
   1742c:	e59f3354 	ldr	r3, [pc, #852]	; 17788 <_dtoa_r+0x658>
   17430:	eb002b8f 	bl	22274 <__aeabi_dsub>
   17434:	e1a02000 	mov	r2, r0
   17438:	e1a03001 	mov	r3, r1
   1743c:	e1a00002 	mov	r0, r2
   17440:	e1a01003 	mov	r1, r3
   17444:	e28f3fc5 	add	r3, pc, #788	; 0x314
   17448:	e893000c 	ldm	r3, {r2, r3}
   1744c:	eb002c8d 	bl	22688 <__aeabi_dmul>
   17450:	e1a02000 	mov	r2, r0
   17454:	e1a03001 	mov	r3, r1
   17458:	e1a00002 	mov	r0, r2
   1745c:	e1a01003 	mov	r1, r3
   17460:	e28f3c03 	add	r3, pc, #768	; 0x300
   17464:	e893000c 	ldm	r3, {r2, r3}
   17468:	eb002b82 	bl	22278 <__adddf3>
   1746c:	e1a02000 	mov	r2, r0
   17470:	e1a03001 	mov	r3, r1
   17474:	e1a06002 	mov	r6, r2
   17478:	e1a07003 	mov	r7, r3
   1747c:	e51b0024 	ldr	r0, [fp, #-36]	; 0x24
   17480:	eb002c49 	bl	225ac <__aeabi_i2d>
   17484:	e1a02000 	mov	r2, r0
   17488:	e1a03001 	mov	r3, r1
   1748c:	e1a00002 	mov	r0, r2
   17490:	e1a01003 	mov	r1, r3
   17494:	e28f3fb5 	add	r3, pc, #724	; 0x2d4
   17498:	e893000c 	ldm	r3, {r2, r3}
   1749c:	eb002c79 	bl	22688 <__aeabi_dmul>
   174a0:	e1a02000 	mov	r2, r0
   174a4:	e1a03001 	mov	r3, r1
   174a8:	e1a00006 	mov	r0, r6
   174ac:	e1a01007 	mov	r1, r7
   174b0:	eb002b70 	bl	22278 <__adddf3>
   174b4:	e1a02000 	mov	r2, r0
   174b8:	e1a03001 	mov	r3, r1
   174bc:	e50b2074 	str	r2, [fp, #-116]	; 0x74
   174c0:	e50b3070 	str	r3, [fp, #-112]	; 0x70
#endif
  k = (int) ds;
   174c4:	e24b1074 	sub	r1, fp, #116	; 0x74
   174c8:	e8910003 	ldm	r1, {r0, r1}
   174cc:	eb002de5 	bl	22c68 <__aeabi_d2iz>
   174d0:	e1a03000 	mov	r3, r0
   174d4:	e50b3038 	str	r3, [fp, #-56]	; 0x38
  if (ds < 0. && ds != k)
   174d8:	e24b1074 	sub	r1, fp, #116	; 0x74
   174dc:	e8910003 	ldm	r1, {r0, r1}
   174e0:	e3a02000 	mov	r2, #0
   174e4:	e3a03000 	mov	r3, #0
   174e8:	eb002dc6 	bl	22c08 <__aeabi_dcmplt>
   174ec:	e1a03000 	mov	r3, r0
   174f0:	e3530000 	cmp	r3, #0
   174f4:	0a00000e 	beq	17534 <_dtoa_r+0x404>
   174f8:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
   174fc:	eb002c2a 	bl	225ac <__aeabi_i2d>
   17500:	e1a02000 	mov	r2, r0
   17504:	e1a03001 	mov	r3, r1
   17508:	e1a00002 	mov	r0, r2
   1750c:	e1a01003 	mov	r1, r3
   17510:	e24b3074 	sub	r3, fp, #116	; 0x74
   17514:	e893000c 	ldm	r3, {r2, r3}
   17518:	eb002db4 	bl	22bf0 <__aeabi_dcmpeq>
   1751c:	e1a03000 	mov	r3, r0
   17520:	e3530000 	cmp	r3, #0
   17524:	1a000002 	bne	17534 <_dtoa_r+0x404>
    k--;			/* want k = floor(ds) */
   17528:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1752c:	e2433001 	sub	r3, r3, #1
   17530:	e50b3038 	str	r3, [fp, #-56]	; 0x38
  k_check = 1;
   17534:	e3a03001 	mov	r3, #1
   17538:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
  if (k >= 0 && k <= Ten_pmax)
   1753c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   17540:	e3530000 	cmp	r3, #0
   17544:	ba000012 	blt	17594 <_dtoa_r+0x464>
   17548:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1754c:	e3530016 	cmp	r3, #22
   17550:	ca00000f 	bgt	17594 <_dtoa_r+0x464>
    {
      if (d.d < tens[k])
   17554:	e24b10ac 	sub	r1, fp, #172	; 0xac
   17558:	e8910003 	ldm	r1, {r0, r1}
   1755c:	e59f2238 	ldr	r2, [pc, #568]	; 1779c <_dtoa_r+0x66c>
   17560:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   17564:	e1a03183 	lsl	r3, r3, #3
   17568:	e0823003 	add	r3, r2, r3
   1756c:	e893000c 	ldm	r3, {r2, r3}
   17570:	eb002da4 	bl	22c08 <__aeabi_dcmplt>
   17574:	e1a03000 	mov	r3, r0
   17578:	e3530000 	cmp	r3, #0
   1757c:	0a000002 	beq	1758c <_dtoa_r+0x45c>
	k--;
   17580:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   17584:	e2433001 	sub	r3, r3, #1
   17588:	e50b3038 	str	r3, [fp, #-56]	; 0x38
      k_check = 0;
   1758c:	e3a03000 	mov	r3, #0
   17590:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
    }
  j = bbits - i - 1;
   17594:	e51b209c 	ldr	r2, [fp, #-156]	; 0x9c
   17598:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1759c:	e0633002 	rsb	r3, r3, r2
   175a0:	e2433001 	sub	r3, r3, #1
   175a4:	e50b3034 	str	r3, [fp, #-52]	; 0x34
  if (j >= 0)
   175a8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   175ac:	e3530000 	cmp	r3, #0
   175b0:	ba000004 	blt	175c8 <_dtoa_r+0x498>
    {
      b2 = 0;
   175b4:	e3a03000 	mov	r3, #0
   175b8:	e50b3018 	str	r3, [fp, #-24]
      s2 = j;
   175bc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   175c0:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   175c4:	ea000004 	b	175dc <_dtoa_r+0x4ac>
    }
  else
    {
      b2 = -j;
   175c8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   175cc:	e2633000 	rsb	r3, r3, #0
   175d0:	e50b3018 	str	r3, [fp, #-24]
      s2 = 0;
   175d4:	e3a03000 	mov	r3, #0
   175d8:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
    }
  if (k >= 0)
   175dc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   175e0:	e3530000 	cmp	r3, #0
   175e4:	ba000008 	blt	1760c <_dtoa_r+0x4dc>
    {
      b5 = 0;
   175e8:	e3a03000 	mov	r3, #0
   175ec:	e50b301c 	str	r3, [fp, #-28]
      s5 = k;
   175f0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   175f4:	e50b3050 	str	r3, [fp, #-80]	; 0x50
      s2 += k;
   175f8:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   175fc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   17600:	e0823003 	add	r3, r2, r3
   17604:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   17608:	ea000008 	b	17630 <_dtoa_r+0x500>
    }
  else
    {
      b2 -= k;
   1760c:	e51b2018 	ldr	r2, [fp, #-24]
   17610:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   17614:	e0633002 	rsb	r3, r3, r2
   17618:	e50b3018 	str	r3, [fp, #-24]
      b5 = -k;
   1761c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   17620:	e2633000 	rsb	r3, r3, #0
   17624:	e50b301c 	str	r3, [fp, #-28]
      s5 = 0;
   17628:	e3a03000 	mov	r3, #0
   1762c:	e50b3050 	str	r3, [fp, #-80]	; 0x50
    }
  if (mode < 0 || mode > 9)
   17630:	e59b3004 	ldr	r3, [fp, #4]
   17634:	e3530000 	cmp	r3, #0
   17638:	ba000002 	blt	17648 <_dtoa_r+0x518>
   1763c:	e59b3004 	ldr	r3, [fp, #4]
   17640:	e3530009 	cmp	r3, #9
   17644:	da000001 	ble	17650 <_dtoa_r+0x520>
    mode = 0;
   17648:	e3a03000 	mov	r3, #0
   1764c:	e58b3004 	str	r3, [fp, #4]
  try_quick = 1;
   17650:	e3a03001 	mov	r3, #1
   17654:	e50b3058 	str	r3, [fp, #-88]	; 0x58
  if (mode > 5)
   17658:	e59b3004 	ldr	r3, [fp, #4]
   1765c:	e3530005 	cmp	r3, #5
   17660:	da000004 	ble	17678 <_dtoa_r+0x548>
    {
      mode -= 4;
   17664:	e59b3004 	ldr	r3, [fp, #4]
   17668:	e2433004 	sub	r3, r3, #4
   1766c:	e58b3004 	str	r3, [fp, #4]
      try_quick = 0;
   17670:	e3a03000 	mov	r3, #0
   17674:	e50b3058 	str	r3, [fp, #-88]	; 0x58
    }
  leftright = 1;
   17678:	e3a03001 	mov	r3, #1
   1767c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
  ilim = ilim1 = -1;
   17680:	e3e03000 	mvn	r3, #0
   17684:	e50b3030 	str	r3, [fp, #-48]	; 0x30
   17688:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1768c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
  switch (mode)
   17690:	e59b3004 	ldr	r3, [fp, #4]
   17694:	e3530005 	cmp	r3, #5
   17698:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   1769c:	ea000029 	b	17748 <_dtoa_r+0x618>
   176a0:	000176b8 	.word	0x000176b8
   176a4:	000176b8 	.word	0x000176b8
   176a8:	000176cc 	.word	0x000176cc
   176ac:	00017704 	.word	0x00017704
   176b0:	000176d4 	.word	0x000176d4
   176b4:	0001770c 	.word	0x0001770c
    {
    case 0:
    case 1:
      i = 18;
   176b8:	e3a03012 	mov	r3, #18
   176bc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      ndigits = 0;
   176c0:	e3a03000 	mov	r3, #0
   176c4:	e58b3008 	str	r3, [fp, #8]
      break;
   176c8:	ea00001e 	b	17748 <_dtoa_r+0x618>
    case 2:
      leftright = 0;
   176cc:	e3a03000 	mov	r3, #0
   176d0:	e50b3040 	str	r3, [fp, #-64]	; 0x40
      /* no break */
    case 4:
      if (ndigits <= 0)
   176d4:	e59b3008 	ldr	r3, [fp, #8]
   176d8:	e3530000 	cmp	r3, #0
   176dc:	ca000001 	bgt	176e8 <_dtoa_r+0x5b8>
	ndigits = 1;
   176e0:	e3a03001 	mov	r3, #1
   176e4:	e58b3008 	str	r3, [fp, #8]
      ilim = ilim1 = i = ndigits;
   176e8:	e59b3008 	ldr	r3, [fp, #8]
   176ec:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   176f0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   176f4:	e50b3030 	str	r3, [fp, #-48]	; 0x30
   176f8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   176fc:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
      break;
   17700:	ea000010 	b	17748 <_dtoa_r+0x618>
    case 3:
      leftright = 0;
   17704:	e3a03000 	mov	r3, #0
   17708:	e50b3040 	str	r3, [fp, #-64]	; 0x40
      /* no break */
    case 5:
      i = ndigits + k + 1;
   1770c:	e59b2008 	ldr	r2, [fp, #8]
   17710:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   17714:	e0823003 	add	r3, r2, r3
   17718:	e2833001 	add	r3, r3, #1
   1771c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      ilim = i;
   17720:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17724:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
      ilim1 = i - 1;
   17728:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1772c:	e2433001 	sub	r3, r3, #1
   17730:	e50b3030 	str	r3, [fp, #-48]	; 0x30
      if (i <= 0)
   17734:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17738:	e3530000 	cmp	r3, #0
   1773c:	ca000001 	bgt	17748 <_dtoa_r+0x618>
	i = 1;
   17740:	e3a03001 	mov	r3, #1
   17744:	e50b3024 	str	r3, [fp, #-36]	; 0x24
    }
  j = sizeof (__ULong);
   17748:	e3a03004 	mov	r3, #4
   1774c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   17750:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   17754:	e3a02000 	mov	r2, #0
   17758:	e5832044 	str	r2, [r3, #68]	; 0x44
   1775c:	ea00001a 	b	177cc <_dtoa_r+0x69c>
   17760:	636f4361 	.word	0x636f4361
   17764:	3fd287a7 	.word	0x3fd287a7
   17768:	8b60c8b3 	.word	0x8b60c8b3
   1776c:	3fc68a28 	.word	0x3fc68a28
   17770:	509f79fb 	.word	0x509f79fb
   17774:	3fd34413 	.word	0x3fd34413
   17778:	0000270f 	.word	0x0000270f
   1777c:	000247f4 	.word	0x000247f4
   17780:	00024800 	.word	0x00024800
   17784:	00024804 	.word	0x00024804
   17788:	3ff80000 	.word	0x3ff80000
   1778c:	000248f0 	.word	0x000248f0
   17790:	401c0000 	.word	0x401c0000
   17794:	3ff00000 	.word	0x3ff00000
   17798:	3fe00000 	.word	0x3fe00000
   1779c:	00024828 	.word	0x00024828
   177a0:	40140000 	.word	0x40140000
   177a4:	40240000 	.word	0x40240000
   177a8:	7ff00000 	.word	0x7ff00000
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
   177ac:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   177b0:	e5933044 	ldr	r3, [r3, #68]	; 0x44
   177b4:	e2832001 	add	r2, r3, #1
   177b8:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   177bc:	e5832044 	str	r2, [r3, #68]	; 0x44
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
       j <<= 1)
   177c0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   177c4:	e1a03083 	lsl	r3, r3, #1
   177c8:	e50b3034 	str	r3, [fp, #-52]	; 0x34
      ilim1 = i - 1;
      if (i <= 0)
	i = 1;
    }
  j = sizeof (__ULong);
  for (_REENT_MP_RESULT_K(ptr) = 0; sizeof (_Bigint) - sizeof (__ULong) + j <= i;
   177cc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   177d0:	e2832014 	add	r2, r3, #20
   177d4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   177d8:	e1520003 	cmp	r2, r3
   177dc:	9afffff2 	bls	177ac <_dtoa_r+0x67c>
       j <<= 1)
    _REENT_MP_RESULT_K(ptr)++;
  _REENT_MP_RESULT(ptr) = Balloc (ptr, _REENT_MP_RESULT_K(ptr));
   177e0:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   177e4:	e5933044 	ldr	r3, [r3, #68]	; 0x44
   177e8:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   177ec:	e1a01003 	mov	r1, r3
   177f0:	eb000df0 	bl	1afb8 <_Balloc>
   177f4:	e1a02000 	mov	r2, r0
   177f8:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   177fc:	e5832040 	str	r2, [r3, #64]	; 0x40
  s = s0 = (char *) _REENT_MP_RESULT(ptr);
   17800:	e51b30c0 	ldr	r3, [fp, #-192]	; 0xc0
   17804:	e5933040 	ldr	r3, [r3, #64]	; 0x40
   17808:	e50b3080 	str	r3, [fp, #-128]	; 0x80
   1780c:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
   17810:	e50b3078 	str	r3, [fp, #-120]	; 0x78

  if (ilim >= 0 && ilim <= Quick_max && try_quick)
   17814:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17818:	e3530000 	cmp	r3, #0
   1781c:	ba0001f3 	blt	17ff0 <_dtoa_r+0xec0>
   17820:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17824:	e353000e 	cmp	r3, #14
   17828:	ca0001f0 	bgt	17ff0 <_dtoa_r+0xec0>
   1782c:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   17830:	e3530000 	cmp	r3, #0
   17834:	0a0001ed 	beq	17ff0 <_dtoa_r+0xec0>
    {
      /* Try to get by with floating-point arithmetic. */

      i = 0;
   17838:	e3a03000 	mov	r3, #0
   1783c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      d2.d = d.d;
   17840:	e24b30ac 	sub	r3, fp, #172	; 0xac
   17844:	e893000c 	ldm	r3, {r2, r3}
   17848:	e50b20b4 	str	r2, [fp, #-180]	; 0xb4
   1784c:	e50b30b0 	str	r3, [fp, #-176]	; 0xb0
      k0 = k;
   17850:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   17854:	e50b3084 	str	r3, [fp, #-132]	; 0x84
      ilim0 = ilim;
   17858:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1785c:	e50b3088 	str	r3, [fp, #-136]	; 0x88
      ieps = 2;			/* conservative */
   17860:	e3a03002 	mov	r3, #2
   17864:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      if (k > 0)
   17868:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1786c:	e3530000 	cmp	r3, #0
   17870:	da000047 	ble	17994 <_dtoa_r+0x864>
	{
	  ds = tens[k & 0xf];
   17874:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   17878:	e203300f 	and	r3, r3, #15
   1787c:	e51f20e8 	ldr	r2, [pc, #-232]	; 1779c <_dtoa_r+0x66c>
   17880:	e1a03183 	lsl	r3, r3, #3
   17884:	e0823003 	add	r3, r2, r3
   17888:	e893000c 	ldm	r3, {r2, r3}
   1788c:	e50b2074 	str	r2, [fp, #-116]	; 0x74
   17890:	e50b3070 	str	r3, [fp, #-112]	; 0x70
	  j = k >> 4;
   17894:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   17898:	e1a03243 	asr	r3, r3, #4
   1789c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	  if (j & Bletch)
   178a0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   178a4:	e2033010 	and	r3, r3, #16
   178a8:	e3530000 	cmp	r3, #0
   178ac:	0a00000f 	beq	178f0 <_dtoa_r+0x7c0>
	    {
	      /* prevent overflows */
	      j &= Bletch - 1;
   178b0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   178b4:	e203300f 	and	r3, r3, #15
   178b8:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	      d.d /= bigtens[n_bigtens - 1];
   178bc:	e24b10ac 	sub	r1, fp, #172	; 0xac
   178c0:	e8910003 	ldm	r1, {r0, r1}
   178c4:	e51f3140 	ldr	r3, [pc, #-320]	; 1778c <_dtoa_r+0x65c>
   178c8:	e2833020 	add	r3, r3, #32
   178cc:	e893000c 	ldm	r3, {r2, r3}
   178d0:	eb002c10 	bl	22918 <__aeabi_ddiv>
   178d4:	e1a02000 	mov	r2, r0
   178d8:	e1a03001 	mov	r3, r1
   178dc:	e50b20ac 	str	r2, [fp, #-172]	; 0xac
   178e0:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
	      ieps++;
   178e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   178e8:	e2833001 	add	r3, r3, #1
   178ec:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	    }
	  for (; j; j >>= 1, i++)
   178f0:	ea000018 	b	17958 <_dtoa_r+0x828>
	    if (j & 1)
   178f4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   178f8:	e2033001 	and	r3, r3, #1
   178fc:	e3530000 	cmp	r3, #0
   17900:	0a00000e 	beq	17940 <_dtoa_r+0x810>
	      {
		ieps++;
   17904:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   17908:	e2833001 	add	r3, r3, #1
   1790c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		ds *= bigtens[i];
   17910:	e51f218c 	ldr	r2, [pc, #-396]	; 1778c <_dtoa_r+0x65c>
   17914:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17918:	e1a03183 	lsl	r3, r3, #3
   1791c:	e0823003 	add	r3, r2, r3
   17920:	e893000c 	ldm	r3, {r2, r3}
   17924:	e24b1074 	sub	r1, fp, #116	; 0x74
   17928:	e8910003 	ldm	r1, {r0, r1}
   1792c:	eb002b55 	bl	22688 <__aeabi_dmul>
   17930:	e1a02000 	mov	r2, r0
   17934:	e1a03001 	mov	r3, r1
   17938:	e50b2074 	str	r2, [fp, #-116]	; 0x74
   1793c:	e50b3070 	str	r3, [fp, #-112]	; 0x70
	      /* prevent overflows */
	      j &= Bletch - 1;
	      d.d /= bigtens[n_bigtens - 1];
	      ieps++;
	    }
	  for (; j; j >>= 1, i++)
   17940:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   17944:	e1a030c3 	asr	r3, r3, #1
   17948:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   1794c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17950:	e2833001 	add	r3, r3, #1
   17954:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   17958:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1795c:	e3530000 	cmp	r3, #0
   17960:	1affffe3 	bne	178f4 <_dtoa_r+0x7c4>
	    if (j & 1)
	      {
		ieps++;
		ds *= bigtens[i];
	      }
	  d.d /= ds;
   17964:	e24b30ac 	sub	r3, fp, #172	; 0xac
   17968:	e893000c 	ldm	r3, {r2, r3}
   1796c:	e1a00002 	mov	r0, r2
   17970:	e1a01003 	mov	r1, r3
   17974:	e24b3074 	sub	r3, fp, #116	; 0x74
   17978:	e893000c 	ldm	r3, {r2, r3}
   1797c:	eb002be5 	bl	22918 <__aeabi_ddiv>
   17980:	e1a02000 	mov	r2, r0
   17984:	e1a03001 	mov	r3, r1
   17988:	e50b20ac 	str	r2, [fp, #-172]	; 0xac
   1798c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
   17990:	ea000032 	b	17a60 <_dtoa_r+0x930>
	}
      else if ((j1 = -k) != 0)
   17994:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   17998:	e2633000 	rsb	r3, r3, #0
   1799c:	e50b308c 	str	r3, [fp, #-140]	; 0x8c
   179a0:	e51b308c 	ldr	r3, [fp, #-140]	; 0x8c
   179a4:	e3530000 	cmp	r3, #0
   179a8:	0a00002c 	beq	17a60 <_dtoa_r+0x930>
	{
	  d.d *= tens[j1 & 0xf];
   179ac:	e24b10ac 	sub	r1, fp, #172	; 0xac
   179b0:	e8910003 	ldm	r1, {r0, r1}
   179b4:	e51b308c 	ldr	r3, [fp, #-140]	; 0x8c
   179b8:	e203300f 	and	r3, r3, #15
   179bc:	e51f2228 	ldr	r2, [pc, #-552]	; 1779c <_dtoa_r+0x66c>
   179c0:	e1a03183 	lsl	r3, r3, #3
   179c4:	e0823003 	add	r3, r2, r3
   179c8:	e893000c 	ldm	r3, {r2, r3}
   179cc:	eb002b2d 	bl	22688 <__aeabi_dmul>
   179d0:	e1a02000 	mov	r2, r0
   179d4:	e1a03001 	mov	r3, r1
   179d8:	e50b20ac 	str	r2, [fp, #-172]	; 0xac
   179dc:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
	  for (j = j1 >> 4; j; j >>= 1, i++)
   179e0:	e51b308c 	ldr	r3, [fp, #-140]	; 0x8c
   179e4:	e1a03243 	asr	r3, r3, #4
   179e8:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   179ec:	ea000018 	b	17a54 <_dtoa_r+0x924>
	    if (j & 1)
   179f0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   179f4:	e2033001 	and	r3, r3, #1
   179f8:	e3530000 	cmp	r3, #0
   179fc:	0a00000e 	beq	17a3c <_dtoa_r+0x90c>
	      {
		ieps++;
   17a00:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   17a04:	e2833001 	add	r3, r3, #1
   17a08:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		d.d *= bigtens[i];
   17a0c:	e24b10ac 	sub	r1, fp, #172	; 0xac
   17a10:	e8910003 	ldm	r1, {r0, r1}
   17a14:	e51f2290 	ldr	r2, [pc, #-656]	; 1778c <_dtoa_r+0x65c>
   17a18:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17a1c:	e1a03183 	lsl	r3, r3, #3
   17a20:	e0823003 	add	r3, r2, r3
   17a24:	e893000c 	ldm	r3, {r2, r3}
   17a28:	eb002b16 	bl	22688 <__aeabi_dmul>
   17a2c:	e1a02000 	mov	r2, r0
   17a30:	e1a03001 	mov	r3, r1
   17a34:	e50b20ac 	str	r2, [fp, #-172]	; 0xac
   17a38:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
	  d.d /= ds;
	}
      else if ((j1 = -k) != 0)
	{
	  d.d *= tens[j1 & 0xf];
	  for (j = j1 >> 4; j; j >>= 1, i++)
   17a3c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   17a40:	e1a030c3 	asr	r3, r3, #1
   17a44:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   17a48:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17a4c:	e2833001 	add	r3, r3, #1
   17a50:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   17a54:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   17a58:	e3530000 	cmp	r3, #0
   17a5c:	1affffe3 	bne	179f0 <_dtoa_r+0x8c0>
	      {
		ieps++;
		d.d *= bigtens[i];
	      }
	}
      if (k_check && d.d < 1. && ilim > 0)
   17a60:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   17a64:	e3530000 	cmp	r3, #0
   17a68:	0a000023 	beq	17afc <_dtoa_r+0x9cc>
   17a6c:	e24b30ac 	sub	r3, fp, #172	; 0xac
   17a70:	e893000c 	ldm	r3, {r2, r3}
   17a74:	e1a00002 	mov	r0, r2
   17a78:	e1a01003 	mov	r1, r3
   17a7c:	e3a02000 	mov	r2, #0
   17a80:	e51f32f4 	ldr	r3, [pc, #-756]	; 17794 <_dtoa_r+0x664>
   17a84:	eb002c5f 	bl	22c08 <__aeabi_dcmplt>
   17a88:	e1a03000 	mov	r3, r0
   17a8c:	e3530000 	cmp	r3, #0
   17a90:	0a000019 	beq	17afc <_dtoa_r+0x9cc>
   17a94:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17a98:	e3530000 	cmp	r3, #0
   17a9c:	da000016 	ble	17afc <_dtoa_r+0x9cc>
	{
	  if (ilim1 <= 0)
   17aa0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   17aa4:	e3530000 	cmp	r3, #0
   17aa8:	ca000000 	bgt	17ab0 <_dtoa_r+0x980>
	    goto fast_failed;
   17aac:	ea000145 	b	17fc8 <_dtoa_r+0xe98>
	  ilim = ilim1;
   17ab0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   17ab4:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	  k--;
   17ab8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   17abc:	e2433001 	sub	r3, r3, #1
   17ac0:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	  d.d *= 10.;
   17ac4:	e24b30ac 	sub	r3, fp, #172	; 0xac
   17ac8:	e893000c 	ldm	r3, {r2, r3}
   17acc:	e1a00002 	mov	r0, r2
   17ad0:	e1a01003 	mov	r1, r3
   17ad4:	e3a02000 	mov	r2, #0
   17ad8:	e51f333c 	ldr	r3, [pc, #-828]	; 177a4 <_dtoa_r+0x674>
   17adc:	eb002ae9 	bl	22688 <__aeabi_dmul>
   17ae0:	e1a02000 	mov	r2, r0
   17ae4:	e1a03001 	mov	r3, r1
   17ae8:	e50b20ac 	str	r2, [fp, #-172]	; 0xac
   17aec:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
	  ieps++;
   17af0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   17af4:	e2833001 	add	r3, r3, #1
   17af8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	}
      eps.d = ieps * d.d + 7.;
   17afc:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
   17b00:	eb002aa9 	bl	225ac <__aeabi_i2d>
   17b04:	e24b30ac 	sub	r3, fp, #172	; 0xac
   17b08:	e893000c 	ldm	r3, {r2, r3}
   17b0c:	eb002add 	bl	22688 <__aeabi_dmul>
   17b10:	e1a02000 	mov	r2, r0
   17b14:	e1a03001 	mov	r3, r1
   17b18:	e1a00002 	mov	r0, r2
   17b1c:	e1a01003 	mov	r1, r3
   17b20:	e3a02000 	mov	r2, #0
   17b24:	e51f339c 	ldr	r3, [pc, #-924]	; 17790 <_dtoa_r+0x660>
   17b28:	eb0029d2 	bl	22278 <__adddf3>
   17b2c:	e1a02000 	mov	r2, r0
   17b30:	e1a03001 	mov	r3, r1
   17b34:	e50b20bc 	str	r2, [fp, #-188]	; 0xbc
   17b38:	e50b30b8 	str	r3, [fp, #-184]	; 0xb8
      word0 (eps) -= (P - 1) * Exp_msk1;
   17b3c:	e51b30b8 	ldr	r3, [fp, #-184]	; 0xb8
   17b40:	e243350d 	sub	r3, r3, #54525952	; 0x3400000
   17b44:	e50b30b8 	str	r3, [fp, #-184]	; 0xb8
      if (ilim == 0)
   17b48:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17b4c:	e3530000 	cmp	r3, #0
   17b50:	1a000025 	bne	17bec <_dtoa_r+0xabc>
	{
	  S = mhi = 0;
   17b54:	e3a03000 	mov	r3, #0
   17b58:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   17b5c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   17b60:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
	  d.d -= 5.;
   17b64:	e24b30ac 	sub	r3, fp, #172	; 0xac
   17b68:	e893000c 	ldm	r3, {r2, r3}
   17b6c:	e1a00002 	mov	r0, r2
   17b70:	e1a01003 	mov	r1, r3
   17b74:	e3a02000 	mov	r2, #0
   17b78:	e51f33e0 	ldr	r3, [pc, #-992]	; 177a0 <_dtoa_r+0x670>
   17b7c:	eb0029bc 	bl	22274 <__aeabi_dsub>
   17b80:	e1a02000 	mov	r2, r0
   17b84:	e1a03001 	mov	r3, r1
   17b88:	e50b20ac 	str	r2, [fp, #-172]	; 0xac
   17b8c:	e50b30a8 	str	r3, [fp, #-168]	; 0xa8
	  if (d.d > eps.d)
   17b90:	e24b10ac 	sub	r1, fp, #172	; 0xac
   17b94:	e8910003 	ldm	r1, {r0, r1}
   17b98:	e24b30bc 	sub	r3, fp, #188	; 0xbc
   17b9c:	e893000c 	ldm	r3, {r2, r3}
   17ba0:	eb002c2a 	bl	22c50 <__aeabi_dcmpgt>
   17ba4:	e1a03000 	mov	r3, r0
   17ba8:	e3530000 	cmp	r3, #0
   17bac:	0a000000 	beq	17bb4 <_dtoa_r+0xa84>
	    goto one_digit;
   17bb0:	ea000301 	b	187bc <_dtoa_r+0x168c>
	  if (d.d < -eps.d)
   17bb4:	e24b10ac 	sub	r1, fp, #172	; 0xac
   17bb8:	e8910003 	ldm	r1, {r0, r1}
   17bbc:	e24b30bc 	sub	r3, fp, #188	; 0xbc
   17bc0:	e893000c 	ldm	r3, {r2, r3}
   17bc4:	e1a04002 	mov	r4, r2
   17bc8:	e2235102 	eor	r5, r3, #-2147483648	; 0x80000000
   17bcc:	e1a02004 	mov	r2, r4
   17bd0:	e1a03005 	mov	r3, r5
   17bd4:	eb002c0b 	bl	22c08 <__aeabi_dcmplt>
   17bd8:	e1a03000 	mov	r3, r0
   17bdc:	e3530000 	cmp	r3, #0
   17be0:	1a000000 	bne	17be8 <_dtoa_r+0xab8>
	    goto no_digits;
	  goto fast_failed;
   17be4:	ea0000f7 	b	17fc8 <_dtoa_r+0xe98>
	  S = mhi = 0;
	  d.d -= 5.;
	  if (d.d > eps.d)
	    goto one_digit;
	  if (d.d < -eps.d)
	    goto no_digits;
   17be8:	ea0002ef 	b	187ac <_dtoa_r+0x167c>
	  goto fast_failed;
	}
#ifndef No_leftright
      if (leftright)
   17bec:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   17bf0:	e3530000 	cmp	r3, #0
   17bf4:	0a00007c 	beq	17dec <_dtoa_r+0xcbc>
	{
	  /* Use Steele & White method of only
	   * generating digits needed.
	   */
	  eps.d = 0.5 / tens[ilim - 1] - eps.d;
   17bf8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17bfc:	e2433001 	sub	r3, r3, #1
   17c00:	e51f246c 	ldr	r2, [pc, #-1132]	; 1779c <_dtoa_r+0x66c>
   17c04:	e1a03183 	lsl	r3, r3, #3
   17c08:	e0823003 	add	r3, r2, r3
   17c0c:	e8930018 	ldm	r3, {r3, r4}
   17c10:	e3a00000 	mov	r0, #0
   17c14:	e51f1484 	ldr	r1, [pc, #-1156]	; 17798 <_dtoa_r+0x668>
   17c18:	e1a02003 	mov	r2, r3
   17c1c:	e1a03004 	mov	r3, r4
   17c20:	eb002b3c 	bl	22918 <__aeabi_ddiv>
   17c24:	e1a03000 	mov	r3, r0
   17c28:	e1a04001 	mov	r4, r1
   17c2c:	e1a01003 	mov	r1, r3
   17c30:	e1a02004 	mov	r2, r4
   17c34:	e24b40bc 	sub	r4, fp, #188	; 0xbc
   17c38:	e8940018 	ldm	r4, {r3, r4}
   17c3c:	e1a00001 	mov	r0, r1
   17c40:	e1a01002 	mov	r1, r2
   17c44:	e1a02003 	mov	r2, r3
   17c48:	e1a03004 	mov	r3, r4
   17c4c:	eb002988 	bl	22274 <__aeabi_dsub>
   17c50:	e1a03000 	mov	r3, r0
   17c54:	e1a04001 	mov	r4, r1
   17c58:	e50b30bc 	str	r3, [fp, #-188]	; 0xbc
   17c5c:	e50b40b8 	str	r4, [fp, #-184]	; 0xb8
	  for (i = 0;;)
   17c60:	e3a03000 	mov	r3, #0
   17c64:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	    {
	      L = d.d;
   17c68:	e24b40ac 	sub	r4, fp, #172	; 0xac
   17c6c:	e8940018 	ldm	r4, {r3, r4}
   17c70:	e1a00003 	mov	r0, r3
   17c74:	e1a01004 	mov	r1, r4
   17c78:	eb002bfa 	bl	22c68 <__aeabi_d2iz>
   17c7c:	e1a03000 	mov	r3, r0
   17c80:	e50b3090 	str	r3, [fp, #-144]	; 0x90
	      d.d -= L;
   17c84:	e24b60ac 	sub	r6, fp, #172	; 0xac
   17c88:	e8960060 	ldm	r6, {r5, r6}
   17c8c:	e51b0090 	ldr	r0, [fp, #-144]	; 0x90
   17c90:	eb002a45 	bl	225ac <__aeabi_i2d>
   17c94:	e1a03000 	mov	r3, r0
   17c98:	e1a04001 	mov	r4, r1
   17c9c:	e1a00005 	mov	r0, r5
   17ca0:	e1a01006 	mov	r1, r6
   17ca4:	e1a02003 	mov	r2, r3
   17ca8:	e1a03004 	mov	r3, r4
   17cac:	eb002970 	bl	22274 <__aeabi_dsub>
   17cb0:	e1a03000 	mov	r3, r0
   17cb4:	e1a04001 	mov	r4, r1
   17cb8:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   17cbc:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
	      *s++ = '0' + (int) L;
   17cc0:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   17cc4:	e2832001 	add	r2, r3, #1
   17cc8:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   17ccc:	e51b2090 	ldr	r2, [fp, #-144]	; 0x90
   17cd0:	e20220ff 	and	r2, r2, #255	; 0xff
   17cd4:	e2822030 	add	r2, r2, #48	; 0x30
   17cd8:	e20220ff 	and	r2, r2, #255	; 0xff
   17cdc:	e5c32000 	strb	r2, [r3]
	      if (d.d < eps.d)
   17ce0:	e24b20ac 	sub	r2, fp, #172	; 0xac
   17ce4:	e8920006 	ldm	r2, {r1, r2}
   17ce8:	e24b40bc 	sub	r4, fp, #188	; 0xbc
   17cec:	e8940018 	ldm	r4, {r3, r4}
   17cf0:	e1a00001 	mov	r0, r1
   17cf4:	e1a01002 	mov	r1, r2
   17cf8:	e1a02003 	mov	r2, r3
   17cfc:	e1a03004 	mov	r3, r4
   17d00:	eb002bc0 	bl	22c08 <__aeabi_dcmplt>
   17d04:	e1a03000 	mov	r3, r0
   17d08:	e3530000 	cmp	r3, #0
   17d0c:	0a000000 	beq	17d14 <_dtoa_r+0xbe4>
		goto ret1;
   17d10:	ea0003f1 	b	18cdc <_dtoa_r+0x1bac>
	      if (1. - d.d < eps.d)
   17d14:	e24b40ac 	sub	r4, fp, #172	; 0xac
   17d18:	e8940018 	ldm	r4, {r3, r4}
   17d1c:	e3a00000 	mov	r0, #0
   17d20:	e51f1594 	ldr	r1, [pc, #-1428]	; 17794 <_dtoa_r+0x664>
   17d24:	e1a02003 	mov	r2, r3
   17d28:	e1a03004 	mov	r3, r4
   17d2c:	eb002950 	bl	22274 <__aeabi_dsub>
   17d30:	e1a03000 	mov	r3, r0
   17d34:	e1a04001 	mov	r4, r1
   17d38:	e1a01003 	mov	r1, r3
   17d3c:	e1a02004 	mov	r2, r4
   17d40:	e24b40bc 	sub	r4, fp, #188	; 0xbc
   17d44:	e8940018 	ldm	r4, {r3, r4}
   17d48:	e1a00001 	mov	r0, r1
   17d4c:	e1a01002 	mov	r1, r2
   17d50:	e1a02003 	mov	r2, r3
   17d54:	e1a03004 	mov	r3, r4
   17d58:	eb002baa 	bl	22c08 <__aeabi_dcmplt>
   17d5c:	e1a03000 	mov	r3, r0
   17d60:	e3530000 	cmp	r3, #0
   17d64:	0a000000 	beq	17d6c <_dtoa_r+0xc3c>
		goto bump_up;
   17d68:	ea000122 	b	181f8 <_dtoa_r+0x10c8>
	      if (++i >= ilim)
   17d6c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17d70:	e2833001 	add	r3, r3, #1
   17d74:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   17d78:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   17d7c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17d80:	e1520003 	cmp	r2, r3
   17d84:	ba000001 	blt	17d90 <_dtoa_r+0xc60>
		break;
   17d88:	e1a00000 	nop			; (mov r0, r0)
   17d8c:	ea00008d 	b	17fc8 <_dtoa_r+0xe98>
	      eps.d *= 10.;
   17d90:	e24b40bc 	sub	r4, fp, #188	; 0xbc
   17d94:	e8940018 	ldm	r4, {r3, r4}
   17d98:	e1a00003 	mov	r0, r3
   17d9c:	e1a01004 	mov	r1, r4
   17da0:	e3a02000 	mov	r2, #0
   17da4:	e51f3608 	ldr	r3, [pc, #-1544]	; 177a4 <_dtoa_r+0x674>
   17da8:	eb002a36 	bl	22688 <__aeabi_dmul>
   17dac:	e1a03000 	mov	r3, r0
   17db0:	e1a04001 	mov	r4, r1
   17db4:	e50b30bc 	str	r3, [fp, #-188]	; 0xbc
   17db8:	e50b40b8 	str	r4, [fp, #-184]	; 0xb8
	      d.d *= 10.;
   17dbc:	e24b40ac 	sub	r4, fp, #172	; 0xac
   17dc0:	e8940018 	ldm	r4, {r3, r4}
   17dc4:	e1a00003 	mov	r0, r3
   17dc8:	e1a01004 	mov	r1, r4
   17dcc:	e3a02000 	mov	r2, #0
   17dd0:	e51f3634 	ldr	r3, [pc, #-1588]	; 177a4 <_dtoa_r+0x674>
   17dd4:	eb002a2b 	bl	22688 <__aeabi_dmul>
   17dd8:	e1a03000 	mov	r3, r0
   17ddc:	e1a04001 	mov	r4, r1
   17de0:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   17de4:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
	    }
   17de8:	eaffff9e 	b	17c68 <_dtoa_r+0xb38>
	}
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
   17dec:	e24b20bc 	sub	r2, fp, #188	; 0xbc
   17df0:	e8920006 	ldm	r2, {r1, r2}
   17df4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17df8:	e2433001 	sub	r3, r3, #1
   17dfc:	e51f0668 	ldr	r0, [pc, #-1640]	; 1779c <_dtoa_r+0x66c>
   17e00:	e1a03183 	lsl	r3, r3, #3
   17e04:	e0803003 	add	r3, r0, r3
   17e08:	e8930018 	ldm	r3, {r3, r4}
   17e0c:	e1a00001 	mov	r0, r1
   17e10:	e1a01002 	mov	r1, r2
   17e14:	e1a02003 	mov	r2, r3
   17e18:	e1a03004 	mov	r3, r4
   17e1c:	eb002a19 	bl	22688 <__aeabi_dmul>
   17e20:	e1a03000 	mov	r3, r0
   17e24:	e1a04001 	mov	r4, r1
   17e28:	e50b30bc 	str	r3, [fp, #-188]	; 0xbc
   17e2c:	e50b40b8 	str	r4, [fp, #-184]	; 0xb8
	  for (i = 1;; i++, d.d *= 10.)
   17e30:	e3a03001 	mov	r3, #1
   17e34:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	    {
	      L = d.d;
   17e38:	e24b40ac 	sub	r4, fp, #172	; 0xac
   17e3c:	e8940018 	ldm	r4, {r3, r4}
   17e40:	e1a00003 	mov	r0, r3
   17e44:	e1a01004 	mov	r1, r4
   17e48:	eb002b86 	bl	22c68 <__aeabi_d2iz>
   17e4c:	e1a03000 	mov	r3, r0
   17e50:	e50b3090 	str	r3, [fp, #-144]	; 0x90
	      d.d -= L;
   17e54:	e24b60ac 	sub	r6, fp, #172	; 0xac
   17e58:	e8960060 	ldm	r6, {r5, r6}
   17e5c:	e51b0090 	ldr	r0, [fp, #-144]	; 0x90
   17e60:	eb0029d1 	bl	225ac <__aeabi_i2d>
   17e64:	e1a03000 	mov	r3, r0
   17e68:	e1a04001 	mov	r4, r1
   17e6c:	e1a00005 	mov	r0, r5
   17e70:	e1a01006 	mov	r1, r6
   17e74:	e1a02003 	mov	r2, r3
   17e78:	e1a03004 	mov	r3, r4
   17e7c:	eb0028fc 	bl	22274 <__aeabi_dsub>
   17e80:	e1a03000 	mov	r3, r0
   17e84:	e1a04001 	mov	r4, r1
   17e88:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   17e8c:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
	      *s++ = '0' + (int) L;
   17e90:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   17e94:	e2832001 	add	r2, r3, #1
   17e98:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   17e9c:	e51b2090 	ldr	r2, [fp, #-144]	; 0x90
   17ea0:	e20220ff 	and	r2, r2, #255	; 0xff
   17ea4:	e2822030 	add	r2, r2, #48	; 0x30
   17ea8:	e20220ff 	and	r2, r2, #255	; 0xff
   17eac:	e5c32000 	strb	r2, [r3]
	      if (i == ilim)
   17eb0:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   17eb4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   17eb8:	e1520003 	cmp	r2, r3
   17ebc:	1a000032 	bne	17f8c <_dtoa_r+0xe5c>
		{
		  if (d.d > 0.5 + eps.d)
   17ec0:	e24b60ac 	sub	r6, fp, #172	; 0xac
   17ec4:	e8960060 	ldm	r6, {r5, r6}
   17ec8:	e24b40bc 	sub	r4, fp, #188	; 0xbc
   17ecc:	e8940018 	ldm	r4, {r3, r4}
   17ed0:	e1a00003 	mov	r0, r3
   17ed4:	e1a01004 	mov	r1, r4
   17ed8:	e3a02000 	mov	r2, #0
   17edc:	e51f374c 	ldr	r3, [pc, #-1868]	; 17798 <_dtoa_r+0x668>
   17ee0:	eb0028e4 	bl	22278 <__adddf3>
   17ee4:	e1a03000 	mov	r3, r0
   17ee8:	e1a04001 	mov	r4, r1
   17eec:	e1a00005 	mov	r0, r5
   17ef0:	e1a01006 	mov	r1, r6
   17ef4:	e1a02003 	mov	r2, r3
   17ef8:	e1a03004 	mov	r3, r4
   17efc:	eb002b53 	bl	22c50 <__aeabi_dcmpgt>
   17f00:	e1a03000 	mov	r3, r0
   17f04:	e3530000 	cmp	r3, #0
   17f08:	0a000000 	beq	17f10 <_dtoa_r+0xde0>
		    goto bump_up;
   17f0c:	ea0000b9 	b	181f8 <_dtoa_r+0x10c8>
		  else if (d.d < 0.5 - eps.d)
   17f10:	e24b60ac 	sub	r6, fp, #172	; 0xac
   17f14:	e8960060 	ldm	r6, {r5, r6}
   17f18:	e24b40bc 	sub	r4, fp, #188	; 0xbc
   17f1c:	e8940018 	ldm	r4, {r3, r4}
   17f20:	e3a00000 	mov	r0, #0
   17f24:	e51f1794 	ldr	r1, [pc, #-1940]	; 17798 <_dtoa_r+0x668>
   17f28:	e1a02003 	mov	r2, r3
   17f2c:	e1a03004 	mov	r3, r4
   17f30:	eb0028cf 	bl	22274 <__aeabi_dsub>
   17f34:	e1a03000 	mov	r3, r0
   17f38:	e1a04001 	mov	r4, r1
   17f3c:	e1a00005 	mov	r0, r5
   17f40:	e1a01006 	mov	r1, r6
   17f44:	e1a02003 	mov	r2, r3
   17f48:	e1a03004 	mov	r3, r4
   17f4c:	eb002b2d 	bl	22c08 <__aeabi_dcmplt>
   17f50:	e1a03000 	mov	r3, r0
   17f54:	e3530000 	cmp	r3, #0
   17f58:	1a000000 	bne	17f60 <_dtoa_r+0xe30>
		    {
		      while (*--s == '0');
		      s++;
		      goto ret1;
		    }
		  break;
   17f5c:	ea000019 	b	17fc8 <_dtoa_r+0xe98>
		{
		  if (d.d > 0.5 + eps.d)
		    goto bump_up;
		  else if (d.d < 0.5 - eps.d)
		    {
		      while (*--s == '0');
   17f60:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   17f64:	e2433001 	sub	r3, r3, #1
   17f68:	e50b3078 	str	r3, [fp, #-120]	; 0x78
   17f6c:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   17f70:	e5d33000 	ldrb	r3, [r3]
   17f74:	e3530030 	cmp	r3, #48	; 0x30
   17f78:	0afffff8 	beq	17f60 <_dtoa_r+0xe30>
		      s++;
   17f7c:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   17f80:	e2833001 	add	r3, r3, #1
   17f84:	e50b3078 	str	r3, [fp, #-120]	; 0x78
		      goto ret1;
   17f88:	ea000353 	b	18cdc <_dtoa_r+0x1bac>
      else
	{
#endif
	  /* Generate ilim digits, then fix them up. */
	  eps.d *= tens[ilim - 1];
	  for (i = 1;; i++, d.d *= 10.)
   17f8c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   17f90:	e2833001 	add	r3, r3, #1
   17f94:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   17f98:	e24b40ac 	sub	r4, fp, #172	; 0xac
   17f9c:	e8940018 	ldm	r4, {r3, r4}
   17fa0:	e1a00003 	mov	r0, r3
   17fa4:	e1a01004 	mov	r1, r4
   17fa8:	e3a02000 	mov	r2, #0
   17fac:	e51f3810 	ldr	r3, [pc, #-2064]	; 177a4 <_dtoa_r+0x674>
   17fb0:	eb0029b4 	bl	22688 <__aeabi_dmul>
   17fb4:	e1a03000 	mov	r3, r0
   17fb8:	e1a04001 	mov	r4, r1
   17fbc:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   17fc0:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
		      s++;
		      goto ret1;
		    }
		  break;
		}
	    }
   17fc4:	eaffff9b 	b	17e38 <_dtoa_r+0xd08>
#ifndef No_leftright
	}
#endif
    fast_failed:
      s = s0;
   17fc8:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
   17fcc:	e50b3078 	str	r3, [fp, #-120]	; 0x78
      d.d = d2.d;
   17fd0:	e24b40b4 	sub	r4, fp, #180	; 0xb4
   17fd4:	e8940018 	ldm	r4, {r3, r4}
   17fd8:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   17fdc:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
      k = k0;
   17fe0:	e51b3084 	ldr	r3, [fp, #-132]	; 0x84
   17fe4:	e50b3038 	str	r3, [fp, #-56]	; 0x38
      ilim = ilim0;
   17fe8:	e51b3088 	ldr	r3, [fp, #-136]	; 0x88
   17fec:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
    }

  /* Do we have a "small" integer? */

  if (be >= 0 && k <= Int_max)
   17ff0:	e51b30a0 	ldr	r3, [fp, #-160]	; 0xa0
   17ff4:	e3530000 	cmp	r3, #0
   17ff8:	ba0000b5 	blt	182d4 <_dtoa_r+0x11a4>
   17ffc:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   18000:	e353000e 	cmp	r3, #14
   18004:	ca0000b2 	bgt	182d4 <_dtoa_r+0x11a4>
    {
      /* Yes. */
      ds = tens[k];
   18008:	e51f2874 	ldr	r2, [pc, #-2164]	; 1779c <_dtoa_r+0x66c>
   1800c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   18010:	e1a03183 	lsl	r3, r3, #3
   18014:	e0823003 	add	r3, r2, r3
   18018:	e8930018 	ldm	r3, {r3, r4}
   1801c:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   18020:	e50b4070 	str	r4, [fp, #-112]	; 0x70
      if (ndigits < 0 && ilim <= 0)
   18024:	e59b3008 	ldr	r3, [fp, #8]
   18028:	e3530000 	cmp	r3, #0
   1802c:	aa00001b 	bge	180a0 <_dtoa_r+0xf70>
   18030:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   18034:	e3530000 	cmp	r3, #0
   18038:	ca000018 	bgt	180a0 <_dtoa_r+0xf70>
	{
	  S = mhi = 0;
   1803c:	e3a03000 	mov	r3, #0
   18040:	e50b3068 	str	r3, [fp, #-104]	; 0x68
   18044:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   18048:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
	  if (ilim < 0 || d.d <= 5 * ds)
   1804c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   18050:	e3530000 	cmp	r3, #0
   18054:	ba0001d4 	blt	187ac <_dtoa_r+0x167c>
   18058:	e24b60ac 	sub	r6, fp, #172	; 0xac
   1805c:	e8960060 	ldm	r6, {r5, r6}
   18060:	e24b1074 	sub	r1, fp, #116	; 0x74
   18064:	e8910003 	ldm	r1, {r0, r1}
   18068:	e3a02000 	mov	r2, #0
   1806c:	e51f38d4 	ldr	r3, [pc, #-2260]	; 177a0 <_dtoa_r+0x670>
   18070:	eb002984 	bl	22688 <__aeabi_dmul>
   18074:	e1a03000 	mov	r3, r0
   18078:	e1a04001 	mov	r4, r1
   1807c:	e1a00005 	mov	r0, r5
   18080:	e1a01006 	mov	r1, r6
   18084:	e1a02003 	mov	r2, r3
   18088:	e1a03004 	mov	r3, r4
   1808c:	eb002ae3 	bl	22c20 <__aeabi_dcmple>
   18090:	e1a03000 	mov	r3, r0
   18094:	e3530000 	cmp	r3, #0
   18098:	1a0001c3 	bne	187ac <_dtoa_r+0x167c>
	    goto no_digits;
	  goto one_digit;
   1809c:	ea0001c6 	b	187bc <_dtoa_r+0x168c>
	}
      for (i = 1;; i++)
   180a0:	e3a03001 	mov	r3, #1
   180a4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	{
	  L = d.d / ds;
   180a8:	e24b40ac 	sub	r4, fp, #172	; 0xac
   180ac:	e8940018 	ldm	r4, {r3, r4}
   180b0:	e1a00003 	mov	r0, r3
   180b4:	e1a01004 	mov	r1, r4
   180b8:	e24b3074 	sub	r3, fp, #116	; 0x74
   180bc:	e893000c 	ldm	r3, {r2, r3}
   180c0:	eb002a14 	bl	22918 <__aeabi_ddiv>
   180c4:	e1a03000 	mov	r3, r0
   180c8:	e1a04001 	mov	r4, r1
   180cc:	e1a00003 	mov	r0, r3
   180d0:	e1a01004 	mov	r1, r4
   180d4:	eb002ae3 	bl	22c68 <__aeabi_d2iz>
   180d8:	e1a03000 	mov	r3, r0
   180dc:	e50b3090 	str	r3, [fp, #-144]	; 0x90
	  d.d -= L * ds;
   180e0:	e24b60ac 	sub	r6, fp, #172	; 0xac
   180e4:	e8960060 	ldm	r6, {r5, r6}
   180e8:	e51b0090 	ldr	r0, [fp, #-144]	; 0x90
   180ec:	eb00292e 	bl	225ac <__aeabi_i2d>
   180f0:	e1a03000 	mov	r3, r0
   180f4:	e1a04001 	mov	r4, r1
   180f8:	e1a00003 	mov	r0, r3
   180fc:	e1a01004 	mov	r1, r4
   18100:	e24b3074 	sub	r3, fp, #116	; 0x74
   18104:	e893000c 	ldm	r3, {r2, r3}
   18108:	eb00295e 	bl	22688 <__aeabi_dmul>
   1810c:	e1a03000 	mov	r3, r0
   18110:	e1a04001 	mov	r4, r1
   18114:	e1a00005 	mov	r0, r5
   18118:	e1a01006 	mov	r1, r6
   1811c:	e1a02003 	mov	r2, r3
   18120:	e1a03004 	mov	r3, r4
   18124:	eb002852 	bl	22274 <__aeabi_dsub>
   18128:	e1a03000 	mov	r3, r0
   1812c:	e1a04001 	mov	r4, r1
   18130:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   18134:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
	    {
	      L--;
	      d.d += ds;
	    }
#endif
	  *s++ = '0' + (int) L;
   18138:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1813c:	e2832001 	add	r2, r3, #1
   18140:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   18144:	e51b2090 	ldr	r2, [fp, #-144]	; 0x90
   18148:	e20220ff 	and	r2, r2, #255	; 0xff
   1814c:	e2822030 	add	r2, r2, #48	; 0x30
   18150:	e20220ff 	and	r2, r2, #255	; 0xff
   18154:	e5c32000 	strb	r2, [r3]
	  if (i == ilim)
   18158:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1815c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   18160:	e1520003 	cmp	r2, r3
   18164:	1a00003f 	bne	18268 <_dtoa_r+0x1138>
	    {
	      d.d += d.d;
   18168:	e24b40ac 	sub	r4, fp, #172	; 0xac
   1816c:	e8940018 	ldm	r4, {r3, r4}
   18170:	e1a00003 	mov	r0, r3
   18174:	e1a01004 	mov	r1, r4
   18178:	e1a02003 	mov	r2, r3
   1817c:	e1a03004 	mov	r3, r4
   18180:	eb00283c 	bl	22278 <__adddf3>
   18184:	e1a03000 	mov	r3, r0
   18188:	e1a04001 	mov	r4, r1
   1818c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   18190:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
   18194:	e24b40ac 	sub	r4, fp, #172	; 0xac
   18198:	e8940018 	ldm	r4, {r3, r4}
   1819c:	e1a00003 	mov	r0, r3
   181a0:	e1a01004 	mov	r1, r4
   181a4:	e24b3074 	sub	r3, fp, #116	; 0x74
   181a8:	e893000c 	ldm	r3, {r2, r3}
   181ac:	eb002aa7 	bl	22c50 <__aeabi_dcmpgt>
   181b0:	e1a03000 	mov	r3, r0
   181b4:	e3530000 	cmp	r3, #0
   181b8:	1a00000e 	bne	181f8 <_dtoa_r+0x10c8>
   181bc:	e24b40ac 	sub	r4, fp, #172	; 0xac
   181c0:	e8940018 	ldm	r4, {r3, r4}
   181c4:	e1a00003 	mov	r0, r3
   181c8:	e1a01004 	mov	r1, r4
   181cc:	e24b3074 	sub	r3, fp, #116	; 0x74
   181d0:	e893000c 	ldm	r3, {r2, r3}
   181d4:	eb002a85 	bl	22bf0 <__aeabi_dcmpeq>
   181d8:	e1a03000 	mov	r3, r0
   181dc:	e3530000 	cmp	r3, #0
   181e0:	1a000000 	bne	181e8 <_dtoa_r+0x10b8>
			*s = '0';
			break;
		      }
		  ++*s++;
		}
	      break;
   181e4:	ea000039 	b	182d0 <_dtoa_r+0x11a0>
#endif
	  *s++ = '0' + (int) L;
	  if (i == ilim)
	    {
	      d.d += d.d;
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
   181e8:	e51b3090 	ldr	r3, [fp, #-144]	; 0x90
   181ec:	e2033001 	and	r3, r3, #1
   181f0:	e3530000 	cmp	r3, #0
   181f4:	0a00001a 	beq	18264 <_dtoa_r+0x1134>
		{
		bump_up:
		  while (*--s == '9')
   181f8:	ea00000a 	b	18228 <_dtoa_r+0x10f8>
		    if (s == s0)
   181fc:	e51b2078 	ldr	r2, [fp, #-120]	; 0x78
   18200:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
   18204:	e1520003 	cmp	r2, r3
   18208:	1a000006 	bne	18228 <_dtoa_r+0x10f8>
		      {
			k++;
   1820c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   18210:	e2833001 	add	r3, r3, #1
   18214:	e50b3038 	str	r3, [fp, #-56]	; 0x38
			*s = '0';
   18218:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1821c:	e3a02030 	mov	r2, #48	; 0x30
   18220:	e5c32000 	strb	r2, [r3]
			break;
   18224:	ea000006 	b	18244 <_dtoa_r+0x1114>
	    {
	      d.d += d.d;
             if ((d.d > ds) || ((d.d == ds) && (L & 1)))
		{
		bump_up:
		  while (*--s == '9')
   18228:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1822c:	e2433001 	sub	r3, r3, #1
   18230:	e50b3078 	str	r3, [fp, #-120]	; 0x78
   18234:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   18238:	e5d33000 	ldrb	r3, [r3]
   1823c:	e3530039 	cmp	r3, #57	; 0x39
   18240:	0affffed 	beq	181fc <_dtoa_r+0x10cc>
		      {
			k++;
			*s = '0';
			break;
		      }
		  ++*s++;
   18244:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   18248:	e2832001 	add	r2, r3, #1
   1824c:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   18250:	e5d32000 	ldrb	r2, [r3]
   18254:	e2822001 	add	r2, r2, #1
   18258:	e20220ff 	and	r2, r2, #255	; 0xff
   1825c:	e5c32000 	strb	r2, [r3]
		}
	      break;
   18260:	ea00001a 	b	182d0 <_dtoa_r+0x11a0>
   18264:	ea000019 	b	182d0 <_dtoa_r+0x11a0>
	    }
	  if (!(d.d *= 10.))
   18268:	e24b40ac 	sub	r4, fp, #172	; 0xac
   1826c:	e8940018 	ldm	r4, {r3, r4}
   18270:	e1a00003 	mov	r0, r3
   18274:	e1a01004 	mov	r1, r4
   18278:	e3a02000 	mov	r2, #0
   1827c:	e51f3ae0 	ldr	r3, [pc, #-2784]	; 177a4 <_dtoa_r+0x674>
   18280:	eb002900 	bl	22688 <__aeabi_dmul>
   18284:	e1a03000 	mov	r3, r0
   18288:	e1a04001 	mov	r4, r1
   1828c:	e50b30ac 	str	r3, [fp, #-172]	; 0xac
   18290:	e50b40a8 	str	r4, [fp, #-168]	; 0xa8
   18294:	e24b40ac 	sub	r4, fp, #172	; 0xac
   18298:	e8940018 	ldm	r4, {r3, r4}
   1829c:	e1a00003 	mov	r0, r3
   182a0:	e1a01004 	mov	r1, r4
   182a4:	e3a02000 	mov	r2, #0
   182a8:	e3a03000 	mov	r3, #0
   182ac:	eb002a4f 	bl	22bf0 <__aeabi_dcmpeq>
   182b0:	e1a03000 	mov	r3, r0
   182b4:	e3530000 	cmp	r3, #0
   182b8:	0a000000 	beq	182c0 <_dtoa_r+0x1190>
	    break;
   182bc:	ea000003 	b	182d0 <_dtoa_r+0x11a0>
	  S = mhi = 0;
	  if (ilim < 0 || d.d <= 5 * ds)
	    goto no_digits;
	  goto one_digit;
	}
      for (i = 1;; i++)
   182c0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   182c4:	e2833001 	add	r3, r3, #1
   182c8:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		}
	      break;
	    }
	  if (!(d.d *= 10.))
	    break;
	}
   182cc:	eaffff75 	b	180a8 <_dtoa_r+0xf78>
      goto ret1;
   182d0:	ea000281 	b	18cdc <_dtoa_r+0x1bac>
    }

  m2 = b2;
   182d4:	e51b3018 	ldr	r3, [fp, #-24]
   182d8:	e50b3044 	str	r3, [fp, #-68]	; 0x44
  m5 = b5;
   182dc:	e51b301c 	ldr	r3, [fp, #-28]
   182e0:	e50b3048 	str	r3, [fp, #-72]	; 0x48
  mhi = mlo = 0;
   182e4:	e3a03000 	mov	r3, #0
   182e8:	e50b3064 	str	r3, [fp, #-100]	; 0x64
   182ec:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   182f0:	e50b3068 	str	r3, [fp, #-104]	; 0x68
  if (leftright)
   182f4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   182f8:	e3530000 	cmp	r3, #0
   182fc:	0a00003e 	beq	183fc <_dtoa_r+0x12cc>
    {
      if (mode < 2)
   18300:	e59b3004 	ldr	r3, [fp, #4]
   18304:	e3530001 	cmp	r3, #1
   18308:	ca00000a 	bgt	18338 <_dtoa_r+0x1208>
	{
	  i =
#ifndef Sudden_Underflow
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
   1830c:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   18310:	e3530000 	cmp	r3, #0
   18314:	0a000003 	beq	18328 <_dtoa_r+0x11f8>
   18318:	e51b30a0 	ldr	r3, [fp, #-160]	; 0xa0
   1831c:	e2833e43 	add	r3, r3, #1072	; 0x430
   18320:	e2833003 	add	r3, r3, #3
   18324:	ea000001 	b	18330 <_dtoa_r+0x1200>
#endif
#ifdef IBM
	    1 + 4 * P - 3 - bbits + ((bbits + be - 1) & 3);
#else
	    1 + P - bbits;
   18328:	e51b309c 	ldr	r3, [fp, #-156]	; 0x9c
    {
      if (mode < 2)
	{
	  i =
#ifndef Sudden_Underflow
	    denorm ? be + (Bias + (P - 1) - 1 + 1) :
   1832c:	e2633036 	rsb	r3, r3, #54	; 0x36
  mhi = mlo = 0;
  if (leftright)
    {
      if (mode < 2)
	{
	  i =
   18330:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   18334:	ea000024 	b	183cc <_dtoa_r+0x129c>
	    1 + P - bbits;
#endif
	}
      else
	{
	  j = ilim - 1;
   18338:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1833c:	e2433001 	sub	r3, r3, #1
   18340:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	  if (m5 >= j)
   18344:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   18348:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1834c:	e1520003 	cmp	r2, r3
   18350:	ba000004 	blt	18368 <_dtoa_r+0x1238>
	    m5 -= j;
   18354:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   18358:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1835c:	e0633002 	rsb	r3, r3, r2
   18360:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   18364:	ea00000d 	b	183a0 <_dtoa_r+0x1270>
	  else
	    {
	      s5 += j -= m5;
   18368:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   1836c:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   18370:	e0633002 	rsb	r3, r3, r2
   18374:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   18378:	e51b2050 	ldr	r2, [fp, #-80]	; 0x50
   1837c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   18380:	e0823003 	add	r3, r2, r3
   18384:	e50b3050 	str	r3, [fp, #-80]	; 0x50
	      b5 += j;
   18388:	e51b201c 	ldr	r2, [fp, #-28]
   1838c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   18390:	e0823003 	add	r3, r2, r3
   18394:	e50b301c 	str	r3, [fp, #-28]
	      m5 = 0;
   18398:	e3a03000 	mov	r3, #0
   1839c:	e50b3048 	str	r3, [fp, #-72]	; 0x48
	    }
	  if ((i = ilim) < 0)
   183a0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   183a4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   183a8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   183ac:	e3530000 	cmp	r3, #0
   183b0:	aa000005 	bge	183cc <_dtoa_r+0x129c>
	    {
	      m2 -= i;
   183b4:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   183b8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   183bc:	e0633002 	rsb	r3, r3, r2
   183c0:	e50b3044 	str	r3, [fp, #-68]	; 0x44
	      i = 0;
   183c4:	e3a03000 	mov	r3, #0
   183c8:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	    }
	}
      b2 += i;
   183cc:	e51b2018 	ldr	r2, [fp, #-24]
   183d0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   183d4:	e0823003 	add	r3, r2, r3
   183d8:	e50b3018 	str	r3, [fp, #-24]
      s2 += i;
   183dc:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   183e0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   183e4:	e0823003 	add	r3, r2, r3
   183e8:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
      mhi = i2b (ptr, 1);
   183ec:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   183f0:	e3a01001 	mov	r1, #1
   183f4:	eb000c88 	bl	1b61c <__i2b>
   183f8:	e50b0068 	str	r0, [fp, #-104]	; 0x68
    }
  if (m2 > 0 && s2 > 0)
   183fc:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   18400:	e3530000 	cmp	r3, #0
   18404:	da000014 	ble	1845c <_dtoa_r+0x132c>
   18408:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1840c:	e3530000 	cmp	r3, #0
   18410:	da000011 	ble	1845c <_dtoa_r+0x132c>
    {
      i = m2 < s2 ? m2 : s2;
   18414:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   18418:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1841c:	e1520003 	cmp	r2, r3
   18420:	b1a03002 	movlt	r3, r2
   18424:	a1a03003 	movge	r3, r3
   18428:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      b2 -= i;
   1842c:	e51b2018 	ldr	r2, [fp, #-24]
   18430:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   18434:	e0633002 	rsb	r3, r3, r2
   18438:	e50b3018 	str	r3, [fp, #-24]
      m2 -= i;
   1843c:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   18440:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   18444:	e0633002 	rsb	r3, r3, r2
   18448:	e50b3044 	str	r3, [fp, #-68]	; 0x44
      s2 -= i;
   1844c:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   18450:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   18454:	e0633002 	rsb	r3, r3, r2
   18458:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
    }
  if (b5 > 0)
   1845c:	e51b301c 	ldr	r3, [fp, #-28]
   18460:	e3530000 	cmp	r3, #0
   18464:	da000026 	ble	18504 <_dtoa_r+0x13d4>
    {
      if (leftright)
   18468:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1846c:	e3530000 	cmp	r3, #0
   18470:	0a00001e 	beq	184f0 <_dtoa_r+0x13c0>
	{
	  if (m5 > 0)
   18474:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   18478:	e3530000 	cmp	r3, #0
   1847c:	da00000e 	ble	184bc <_dtoa_r+0x138c>
	    {
	      mhi = pow5mult (ptr, mhi, m5);
   18480:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   18484:	e51b1068 	ldr	r1, [fp, #-104]	; 0x68
   18488:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   1848c:	eb000d74 	bl	1ba64 <__pow5mult>
   18490:	e50b0068 	str	r0, [fp, #-104]	; 0x68
	      b1 = mult (ptr, mhi, b);
   18494:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   18498:	e51b1068 	ldr	r1, [fp, #-104]	; 0x68
   1849c:	e51b2060 	ldr	r2, [fp, #-96]	; 0x60
   184a0:	eb000c71 	bl	1b66c <__multiply>
   184a4:	e50b0094 	str	r0, [fp, #-148]	; 0x94
	      Bfree (ptr, b);
   184a8:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   184ac:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   184b0:	eb000b0c 	bl	1b0e8 <_Bfree>
	      b = b1;
   184b4:	e51b3094 	ldr	r3, [fp, #-148]	; 0x94
   184b8:	e50b3060 	str	r3, [fp, #-96]	; 0x60
	    }
         if ((j = b5 - m5) != 0)
   184bc:	e51b201c 	ldr	r2, [fp, #-28]
   184c0:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   184c4:	e0633002 	rsb	r3, r3, r2
   184c8:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   184cc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   184d0:	e3530000 	cmp	r3, #0
   184d4:	0a00000a 	beq	18504 <_dtoa_r+0x13d4>
	    b = pow5mult (ptr, b, j);
   184d8:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   184dc:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   184e0:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   184e4:	eb000d5e 	bl	1ba64 <__pow5mult>
   184e8:	e50b0060 	str	r0, [fp, #-96]	; 0x60
   184ec:	ea000004 	b	18504 <_dtoa_r+0x13d4>
	}
      else
	b = pow5mult (ptr, b, b5);
   184f0:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   184f4:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   184f8:	e51b201c 	ldr	r2, [fp, #-28]
   184fc:	eb000d58 	bl	1ba64 <__pow5mult>
   18500:	e50b0060 	str	r0, [fp, #-96]	; 0x60
    }
  S = i2b (ptr, 1);
   18504:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   18508:	e3a01001 	mov	r1, #1
   1850c:	eb000c42 	bl	1b61c <__i2b>
   18510:	e50b006c 	str	r0, [fp, #-108]	; 0x6c
  if (s5 > 0)
   18514:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   18518:	e3530000 	cmp	r3, #0
   1851c:	da000004 	ble	18534 <_dtoa_r+0x1404>
    S = pow5mult (ptr, S, s5);
   18520:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   18524:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   18528:	e51b2050 	ldr	r2, [fp, #-80]	; 0x50
   1852c:	eb000d4c 	bl	1ba64 <__pow5mult>
   18530:	e50b006c 	str	r0, [fp, #-108]	; 0x6c

  /* Check for special case that d is a normalized power of 2. */

  spec_case = 0;
   18534:	e3a03000 	mov	r3, #0
   18538:	e50b3054 	str	r3, [fp, #-84]	; 0x54
  if (mode < 2)
   1853c:	e59b3004 	ldr	r3, [fp, #4]
   18540:	e3530001 	cmp	r3, #1
   18544:	ca000014 	bgt	1859c <_dtoa_r+0x146c>
    {
      if (!word1 (d) && !(word0 (d) & Bndry_mask)
   18548:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1854c:	e3530000 	cmp	r3, #0
   18550:	1a000011 	bne	1859c <_dtoa_r+0x146c>
   18554:	e51b30a8 	ldr	r3, [fp, #-168]	; 0xa8
   18558:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
   1855c:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   18560:	e3530000 	cmp	r3, #0
   18564:	1a00000c 	bne	1859c <_dtoa_r+0x146c>
#ifndef Sudden_Underflow
	  && word0 (d) & Exp_mask
   18568:	e51b20a8 	ldr	r2, [fp, #-168]	; 0xa8
   1856c:	e51f3dcc 	ldr	r3, [pc, #-3532]	; 177a8 <_dtoa_r+0x678>
   18570:	e0033002 	and	r3, r3, r2
   18574:	e3530000 	cmp	r3, #0
   18578:	0a000007 	beq	1859c <_dtoa_r+0x146c>
#endif
	)
	{
	  /* The special case */
	  b2 += Log2P;
   1857c:	e51b3018 	ldr	r3, [fp, #-24]
   18580:	e2833001 	add	r3, r3, #1
   18584:	e50b3018 	str	r3, [fp, #-24]
	  s2 += Log2P;
   18588:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1858c:	e2833001 	add	r3, r3, #1
   18590:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
	  spec_case = 1;
   18594:	e3a03001 	mov	r3, #1
   18598:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   * and for all and pass them and a shift to quorem, so it
   * can do shifts and ors to compute the numerator for q.
   */

#ifdef Pack_32
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0x1f) != 0)
   1859c:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   185a0:	e3530000 	cmp	r3, #0
   185a4:	0a00000e 	beq	185e4 <_dtoa_r+0x14b4>
   185a8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   185ac:	e5933010 	ldr	r3, [r3, #16]
   185b0:	e2433001 	sub	r3, r3, #1
   185b4:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   185b8:	e2832004 	add	r2, r3, #4
   185bc:	e3a03004 	mov	r3, #4
   185c0:	e1a02102 	lsl	r2, r2, #2
   185c4:	e0812002 	add	r2, r1, r2
   185c8:	e0823003 	add	r3, r2, r3
   185cc:	e5933000 	ldr	r3, [r3]
   185d0:	e1a00003 	mov	r0, r3
   185d4:	eb000ba8 	bl	1b47c <__hi0bits>
   185d8:	e1a03000 	mov	r3, r0
   185dc:	e2633020 	rsb	r3, r3, #32
   185e0:	ea000000 	b	185e8 <_dtoa_r+0x14b8>
   185e4:	e3a03001 	mov	r3, #1
   185e8:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   185ec:	e0833002 	add	r3, r3, r2
   185f0:	e203301f 	and	r3, r3, #31
   185f4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   185f8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   185fc:	e3530000 	cmp	r3, #0
   18600:	0a000002 	beq	18610 <_dtoa_r+0x14e0>
    i = 32 - i;
   18604:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   18608:	e2633020 	rsb	r3, r3, #32
   1860c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
#else
  if ((i = ((s5 ? 32 - hi0bits (S->_x[S->_wds - 1]) : 1) + s2) & 0xf) != 0)
    i = 16 - i;
#endif
  if (i > 4)
   18610:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   18614:	e3530004 	cmp	r3, #4
   18618:	da00000f 	ble	1865c <_dtoa_r+0x152c>
    {
      i -= 4;
   1861c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   18620:	e2433004 	sub	r3, r3, #4
   18624:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      b2 += i;
   18628:	e51b2018 	ldr	r2, [fp, #-24]
   1862c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   18630:	e0823003 	add	r3, r2, r3
   18634:	e50b3018 	str	r3, [fp, #-24]
      m2 += i;
   18638:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   1863c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   18640:	e0823003 	add	r3, r2, r3
   18644:	e50b3044 	str	r3, [fp, #-68]	; 0x44
      s2 += i;
   18648:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   1864c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   18650:	e0823003 	add	r3, r2, r3
   18654:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   18658:	ea000011 	b	186a4 <_dtoa_r+0x1574>
    }
  else if (i < 4)
   1865c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   18660:	e3530003 	cmp	r3, #3
   18664:	ca00000e 	bgt	186a4 <_dtoa_r+0x1574>
    {
      i += 28;
   18668:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1866c:	e283301c 	add	r3, r3, #28
   18670:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      b2 += i;
   18674:	e51b2018 	ldr	r2, [fp, #-24]
   18678:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1867c:	e0823003 	add	r3, r2, r3
   18680:	e50b3018 	str	r3, [fp, #-24]
      m2 += i;
   18684:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   18688:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1868c:	e0823003 	add	r3, r2, r3
   18690:	e50b3044 	str	r3, [fp, #-68]	; 0x44
      s2 += i;
   18694:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   18698:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1869c:	e0823003 	add	r3, r2, r3
   186a0:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
    }
  if (b2 > 0)
   186a4:	e51b3018 	ldr	r3, [fp, #-24]
   186a8:	e3530000 	cmp	r3, #0
   186ac:	da000004 	ble	186c4 <_dtoa_r+0x1594>
    b = lshift (ptr, b, b2);
   186b0:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   186b4:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   186b8:	e51b2018 	ldr	r2, [fp, #-24]
   186bc:	eb000d4b 	bl	1bbf0 <__lshift>
   186c0:	e50b0060 	str	r0, [fp, #-96]	; 0x60
  if (s2 > 0)
   186c4:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   186c8:	e3530000 	cmp	r3, #0
   186cc:	da000004 	ble	186e4 <_dtoa_r+0x15b4>
    S = lshift (ptr, S, s2);
   186d0:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   186d4:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   186d8:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   186dc:	eb000d43 	bl	1bbf0 <__lshift>
   186e0:	e50b006c 	str	r0, [fp, #-108]	; 0x6c
  if (k_check)
   186e4:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   186e8:	e3530000 	cmp	r3, #0
   186ec:	0a000019 	beq	18758 <_dtoa_r+0x1628>
    {
      if (cmp (b, S) < 0)
   186f0:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   186f4:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   186f8:	eb000dbe 	bl	1bdf8 <__mcmp>
   186fc:	e1a03000 	mov	r3, r0
   18700:	e3530000 	cmp	r3, #0
   18704:	aa000013 	bge	18758 <_dtoa_r+0x1628>
	{
	  k--;
   18708:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1870c:	e2433001 	sub	r3, r3, #1
   18710:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	  b = multadd (ptr, b, 10, 0);	/* we botched the k estimate */
   18714:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   18718:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   1871c:	e3a0200a 	mov	r2, #10
   18720:	e3a03000 	mov	r3, #0
   18724:	eb000a8b 	bl	1b158 <__multadd>
   18728:	e50b0060 	str	r0, [fp, #-96]	; 0x60
	  if (leftright)
   1872c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   18730:	e3530000 	cmp	r3, #0
   18734:	0a000005 	beq	18750 <_dtoa_r+0x1620>
	    mhi = multadd (ptr, mhi, 10, 0);
   18738:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   1873c:	e51b1068 	ldr	r1, [fp, #-104]	; 0x68
   18740:	e3a0200a 	mov	r2, #10
   18744:	e3a03000 	mov	r3, #0
   18748:	eb000a82 	bl	1b158 <__multadd>
   1874c:	e50b0068 	str	r0, [fp, #-104]	; 0x68
	  ilim = ilim1;
   18750:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   18754:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	}
    }
  if (ilim <= 0 && mode > 2)
   18758:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1875c:	e3530000 	cmp	r3, #0
   18760:	ca00001e 	bgt	187e0 <_dtoa_r+0x16b0>
   18764:	e59b3004 	ldr	r3, [fp, #4]
   18768:	e3530002 	cmp	r3, #2
   1876c:	da00001b 	ble	187e0 <_dtoa_r+0x16b0>
    {
      if (ilim < 0 || cmp (b, S = multadd (ptr, S, 5, 0)) <= 0)
   18770:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   18774:	e3530000 	cmp	r3, #0
   18778:	ba00000b 	blt	187ac <_dtoa_r+0x167c>
   1877c:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   18780:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   18784:	e3a02005 	mov	r2, #5
   18788:	e3a03000 	mov	r3, #0
   1878c:	eb000a71 	bl	1b158 <__multadd>
   18790:	e50b006c 	str	r0, [fp, #-108]	; 0x6c
   18794:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   18798:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   1879c:	eb000d95 	bl	1bdf8 <__mcmp>
   187a0:	e1a03000 	mov	r3, r0
   187a4:	e3530000 	cmp	r3, #0
   187a8:	ca000003 	bgt	187bc <_dtoa_r+0x168c>
	{
	  /* no digits, fcvt style */
	no_digits:
	  k = -1 - ndigits;
   187ac:	e59b3008 	ldr	r3, [fp, #8]
   187b0:	e1e03003 	mvn	r3, r3
   187b4:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	  goto ret;
   187b8:	ea000134 	b	18c90 <_dtoa_r+0x1b60>
	}
    one_digit:
      *s++ = '1';
   187bc:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   187c0:	e2832001 	add	r2, r3, #1
   187c4:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   187c8:	e3a02031 	mov	r2, #49	; 0x31
   187cc:	e5c32000 	strb	r2, [r3]
      k++;
   187d0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   187d4:	e2833001 	add	r3, r3, #1
   187d8:	e50b3038 	str	r3, [fp, #-56]	; 0x38
      goto ret;
   187dc:	ea00012b 	b	18c90 <_dtoa_r+0x1b60>
    }
  if (leftright)
   187e0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   187e4:	e3530000 	cmp	r3, #0
   187e8:	0a0000d1 	beq	18b34 <_dtoa_r+0x1a04>
    {
      if (m2 > 0)
   187ec:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   187f0:	e3530000 	cmp	r3, #0
   187f4:	da000004 	ble	1880c <_dtoa_r+0x16dc>
	mhi = lshift (ptr, mhi, m2);
   187f8:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   187fc:	e51b1068 	ldr	r1, [fp, #-104]	; 0x68
   18800:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   18804:	eb000cf9 	bl	1bbf0 <__lshift>
   18808:	e50b0068 	str	r0, [fp, #-104]	; 0x68

      /* Compute mlo -- check for special case
       * that d is a normalized power of 2.
       */

      mlo = mhi;
   1880c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   18810:	e50b3064 	str	r3, [fp, #-100]	; 0x64
      if (spec_case)
   18814:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   18818:	e3530000 	cmp	r3, #0
   1881c:	0a000016 	beq	1887c <_dtoa_r+0x174c>
	{
	  mhi = Balloc (ptr, mhi->_k);
   18820:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   18824:	e5933004 	ldr	r3, [r3, #4]
   18828:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   1882c:	e1a01003 	mov	r1, r3
   18830:	eb0009e0 	bl	1afb8 <_Balloc>
   18834:	e50b0068 	str	r0, [fp, #-104]	; 0x68
	  Bcopy (mhi, mlo);
   18838:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1883c:	e283100c 	add	r1, r3, #12
   18840:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   18844:	e283200c 	add	r2, r3, #12
   18848:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   1884c:	e5933010 	ldr	r3, [r3, #16]
   18850:	e2833002 	add	r3, r3, #2
   18854:	e1a03103 	lsl	r3, r3, #2
   18858:	e1a00001 	mov	r0, r1
   1885c:	e1a01002 	mov	r1, r2
   18860:	e1a02003 	mov	r2, r3
   18864:	ebffdcb9 	bl	fb50 <memcpy>
	  mhi = lshift (ptr, mhi, Log2P);
   18868:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   1886c:	e51b1068 	ldr	r1, [fp, #-104]	; 0x68
   18870:	e3a02001 	mov	r2, #1
   18874:	eb000cdd 	bl	1bbf0 <__lshift>
   18878:	e50b0068 	str	r0, [fp, #-104]	; 0x68
	}

      for (i = 1;; i++)
   1887c:	e3a03001 	mov	r3, #1
   18880:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	{
	  dig = quorem (b, S) + '0';
   18884:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   18888:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   1888c:	ebfff927 	bl	16d30 <quorem>
   18890:	e1a03000 	mov	r3, r0
   18894:	e2833030 	add	r3, r3, #48	; 0x30
   18898:	e50b3020 	str	r3, [fp, #-32]
	  /* Do we yet have the shortest decimal string
	   * that will round to d?
	   */
	  j = cmp (b, mlo);
   1889c:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   188a0:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
   188a4:	eb000d53 	bl	1bdf8 <__mcmp>
   188a8:	e50b0034 	str	r0, [fp, #-52]	; 0x34
	  delta = diff (ptr, S, mhi);
   188ac:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   188b0:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   188b4:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   188b8:	eb000d94 	bl	1bf10 <__mdiff>
   188bc:	e50b0098 	str	r0, [fp, #-152]	; 0x98
	  j1 = delta->_sign ? 1 : cmp (b, delta);
   188c0:	e51b3098 	ldr	r3, [fp, #-152]	; 0x98
   188c4:	e593300c 	ldr	r3, [r3, #12]
   188c8:	e3530000 	cmp	r3, #0
   188cc:	1a000004 	bne	188e4 <_dtoa_r+0x17b4>
   188d0:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   188d4:	e51b1098 	ldr	r1, [fp, #-152]	; 0x98
   188d8:	eb000d46 	bl	1bdf8 <__mcmp>
   188dc:	e1a03000 	mov	r3, r0
   188e0:	ea000000 	b	188e8 <_dtoa_r+0x17b8>
   188e4:	e3a03001 	mov	r3, #1
   188e8:	e50b308c 	str	r3, [fp, #-140]	; 0x8c
	  Bfree (ptr, delta);
   188ec:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   188f0:	e51b1098 	ldr	r1, [fp, #-152]	; 0x98
   188f4:	eb0009fb 	bl	1b0e8 <_Bfree>
#ifndef ROUND_BIASED
	  if (j1 == 0 && !mode && !(word1 (d) & 1))
   188f8:	e51b308c 	ldr	r3, [fp, #-140]	; 0x8c
   188fc:	e3530000 	cmp	r3, #0
   18900:	1a000017 	bne	18964 <_dtoa_r+0x1834>
   18904:	e59b3004 	ldr	r3, [fp, #4]
   18908:	e3530000 	cmp	r3, #0
   1890c:	1a000014 	bne	18964 <_dtoa_r+0x1834>
   18910:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   18914:	e2033001 	and	r3, r3, #1
   18918:	e3530000 	cmp	r3, #0
   1891c:	1a000010 	bne	18964 <_dtoa_r+0x1834>
	    {
	      if (dig == '9')
   18920:	e51b3020 	ldr	r3, [fp, #-32]
   18924:	e3530039 	cmp	r3, #57	; 0x39
   18928:	1a000000 	bne	18930 <_dtoa_r+0x1800>
		goto round_9_up;
   1892c:	ea000042 	b	18a3c <_dtoa_r+0x190c>
	      if (j > 0)
   18930:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   18934:	e3530000 	cmp	r3, #0
   18938:	da000002 	ble	18948 <_dtoa_r+0x1818>
		dig++;
   1893c:	e51b3020 	ldr	r3, [fp, #-32]
   18940:	e2833001 	add	r3, r3, #1
   18944:	e50b3020 	str	r3, [fp, #-32]
	      *s++ = dig;
   18948:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1894c:	e2832001 	add	r2, r3, #1
   18950:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   18954:	e51b2020 	ldr	r2, [fp, #-32]
   18958:	e20220ff 	and	r2, r2, #255	; 0xff
   1895c:	e5c32000 	strb	r2, [r3]
	      goto ret;
   18960:	ea0000ca 	b	18c90 <_dtoa_r+0x1b60>
	    }
#endif
         if ((j < 0) || ((j == 0) && !mode
   18964:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   18968:	e3530000 	cmp	r3, #0
   1896c:	ba000009 	blt	18998 <_dtoa_r+0x1868>
   18970:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   18974:	e3530000 	cmp	r3, #0
   18978:	1a000029 	bne	18a24 <_dtoa_r+0x18f4>
   1897c:	e59b3004 	ldr	r3, [fp, #4]
   18980:	e3530000 	cmp	r3, #0
   18984:	1a000026 	bne	18a24 <_dtoa_r+0x18f4>
#ifndef ROUND_BIASED
	      && !(word1 (d) & 1)
   18988:	e51b30ac 	ldr	r3, [fp, #-172]	; 0xac
   1898c:	e2033001 	and	r3, r3, #1
   18990:	e3530000 	cmp	r3, #0
   18994:	1a000022 	bne	18a24 <_dtoa_r+0x18f4>
#endif
           ))
	    {
	      if (j1 > 0)
   18998:	e51b308c 	ldr	r3, [fp, #-140]	; 0x8c
   1899c:	e3530000 	cmp	r3, #0
   189a0:	da000018 	ble	18a08 <_dtoa_r+0x18d8>
		{
		  b = lshift (ptr, b, 1);
   189a4:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   189a8:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   189ac:	e3a02001 	mov	r2, #1
   189b0:	eb000c8e 	bl	1bbf0 <__lshift>
   189b4:	e50b0060 	str	r0, [fp, #-96]	; 0x60
		  j1 = cmp (b, S);
   189b8:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   189bc:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   189c0:	eb000d0c 	bl	1bdf8 <__mcmp>
   189c4:	e50b008c 	str	r0, [fp, #-140]	; 0x8c
                 if (((j1 > 0) || ((j1 == 0) && (dig & 1)))
   189c8:	e51b308c 	ldr	r3, [fp, #-140]	; 0x8c
   189cc:	e3530000 	cmp	r3, #0
   189d0:	ca000006 	bgt	189f0 <_dtoa_r+0x18c0>
   189d4:	e51b308c 	ldr	r3, [fp, #-140]	; 0x8c
   189d8:	e3530000 	cmp	r3, #0
   189dc:	1a000009 	bne	18a08 <_dtoa_r+0x18d8>
   189e0:	e51b3020 	ldr	r3, [fp, #-32]
   189e4:	e2033001 	and	r3, r3, #1
   189e8:	e3530000 	cmp	r3, #0
   189ec:	0a000005 	beq	18a08 <_dtoa_r+0x18d8>
		      && dig++ == '9')
   189f0:	e51b3020 	ldr	r3, [fp, #-32]
   189f4:	e2832001 	add	r2, r3, #1
   189f8:	e50b2020 	str	r2, [fp, #-32]
   189fc:	e3530039 	cmp	r3, #57	; 0x39
   18a00:	1a000000 	bne	18a08 <_dtoa_r+0x18d8>
		    goto round_9_up;
   18a04:	ea00000c 	b	18a3c <_dtoa_r+0x190c>
		}
	      *s++ = dig;
   18a08:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   18a0c:	e2832001 	add	r2, r3, #1
   18a10:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   18a14:	e51b2020 	ldr	r2, [fp, #-32]
   18a18:	e20220ff 	and	r2, r2, #255	; 0xff
   18a1c:	e5c32000 	strb	r2, [r3]
	      goto ret;
   18a20:	ea00009a 	b	18c90 <_dtoa_r+0x1b60>
	    }
	  if (j1 > 0)
   18a24:	e51b308c 	ldr	r3, [fp, #-140]	; 0x8c
   18a28:	e3530000 	cmp	r3, #0
   18a2c:	da000011 	ble	18a78 <_dtoa_r+0x1948>
	    {
	      if (dig == '9')
   18a30:	e51b3020 	ldr	r3, [fp, #-32]
   18a34:	e3530039 	cmp	r3, #57	; 0x39
   18a38:	1a000005 	bne	18a54 <_dtoa_r+0x1924>
		{		/* possible if i == 1 */
		round_9_up:
		  *s++ = '9';
   18a3c:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   18a40:	e2832001 	add	r2, r3, #1
   18a44:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   18a48:	e3a02039 	mov	r2, #57	; 0x39
   18a4c:	e5c32000 	strb	r2, [r3]
		  goto roundoff;
   18a50:	ea000067 	b	18bf4 <_dtoa_r+0x1ac4>
		}
	      *s++ = dig + 1;
   18a54:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   18a58:	e2832001 	add	r2, r3, #1
   18a5c:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   18a60:	e51b2020 	ldr	r2, [fp, #-32]
   18a64:	e20220ff 	and	r2, r2, #255	; 0xff
   18a68:	e2822001 	add	r2, r2, #1
   18a6c:	e20220ff 	and	r2, r2, #255	; 0xff
   18a70:	e5c32000 	strb	r2, [r3]
	      goto ret;
   18a74:	ea000085 	b	18c90 <_dtoa_r+0x1b60>
	    }
	  *s++ = dig;
   18a78:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   18a7c:	e2832001 	add	r2, r3, #1
   18a80:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   18a84:	e51b2020 	ldr	r2, [fp, #-32]
   18a88:	e20220ff 	and	r2, r2, #255	; 0xff
   18a8c:	e5c32000 	strb	r2, [r3]
	  if (i == ilim)
   18a90:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   18a94:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   18a98:	e1520003 	cmp	r2, r3
   18a9c:	1a000001 	bne	18aa8 <_dtoa_r+0x1978>
	    break;
   18aa0:	e1a00000 	nop			; (mov r0, r0)
   18aa4:	ea00003f 	b	18ba8 <_dtoa_r+0x1a78>
	  b = multadd (ptr, b, 10, 0);
   18aa8:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   18aac:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   18ab0:	e3a0200a 	mov	r2, #10
   18ab4:	e3a03000 	mov	r3, #0
   18ab8:	eb0009a6 	bl	1b158 <__multadd>
   18abc:	e50b0060 	str	r0, [fp, #-96]	; 0x60
	  if (mlo == mhi)
   18ac0:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
   18ac4:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   18ac8:	e1520003 	cmp	r2, r3
   18acc:	1a000008 	bne	18af4 <_dtoa_r+0x19c4>
	    mlo = mhi = multadd (ptr, mhi, 10, 0);
   18ad0:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   18ad4:	e51b1068 	ldr	r1, [fp, #-104]	; 0x68
   18ad8:	e3a0200a 	mov	r2, #10
   18adc:	e3a03000 	mov	r3, #0
   18ae0:	eb00099c 	bl	1b158 <__multadd>
   18ae4:	e50b0068 	str	r0, [fp, #-104]	; 0x68
   18ae8:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   18aec:	e50b3064 	str	r3, [fp, #-100]	; 0x64
   18af0:	ea00000b 	b	18b24 <_dtoa_r+0x19f4>
	  else
	    {
	      mlo = multadd (ptr, mlo, 10, 0);
   18af4:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   18af8:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
   18afc:	e3a0200a 	mov	r2, #10
   18b00:	e3a03000 	mov	r3, #0
   18b04:	eb000993 	bl	1b158 <__multadd>
   18b08:	e50b0064 	str	r0, [fp, #-100]	; 0x64
	      mhi = multadd (ptr, mhi, 10, 0);
   18b0c:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   18b10:	e51b1068 	ldr	r1, [fp, #-104]	; 0x68
   18b14:	e3a0200a 	mov	r2, #10
   18b18:	e3a03000 	mov	r3, #0
   18b1c:	eb00098d 	bl	1b158 <__multadd>
   18b20:	e50b0068 	str	r0, [fp, #-104]	; 0x68
	  mhi = Balloc (ptr, mhi->_k);
	  Bcopy (mhi, mlo);
	  mhi = lshift (ptr, mhi, Log2P);
	}

      for (i = 1;; i++)
   18b24:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   18b28:	e2833001 	add	r3, r3, #1
   18b2c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	  else
	    {
	      mlo = multadd (ptr, mlo, 10, 0);
	      mhi = multadd (ptr, mhi, 10, 0);
	    }
	}
   18b30:	eaffff53 	b	18884 <_dtoa_r+0x1754>
    }
  else
    for (i = 1;; i++)
   18b34:	e3a03001 	mov	r3, #1
   18b38:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      {
	*s++ = dig = quorem (b, S) + '0';
   18b3c:	e51b4078 	ldr	r4, [fp, #-120]	; 0x78
   18b40:	e2843001 	add	r3, r4, #1
   18b44:	e50b3078 	str	r3, [fp, #-120]	; 0x78
   18b48:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   18b4c:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   18b50:	ebfff876 	bl	16d30 <quorem>
   18b54:	e1a03000 	mov	r3, r0
   18b58:	e2833030 	add	r3, r3, #48	; 0x30
   18b5c:	e50b3020 	str	r3, [fp, #-32]
   18b60:	e51b3020 	ldr	r3, [fp, #-32]
   18b64:	e20330ff 	and	r3, r3, #255	; 0xff
   18b68:	e5c43000 	strb	r3, [r4]
	if (i >= ilim)
   18b6c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   18b70:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   18b74:	e1520003 	cmp	r2, r3
   18b78:	ba000000 	blt	18b80 <_dtoa_r+0x1a50>
	  break;
   18b7c:	ea000009 	b	18ba8 <_dtoa_r+0x1a78>
	b = multadd (ptr, b, 10, 0);
   18b80:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   18b84:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   18b88:	e3a0200a 	mov	r2, #10
   18b8c:	e3a03000 	mov	r3, #0
   18b90:	eb000970 	bl	1b158 <__multadd>
   18b94:	e50b0060 	str	r0, [fp, #-96]	; 0x60
	      mhi = multadd (ptr, mhi, 10, 0);
	    }
	}
    }
  else
    for (i = 1;; i++)
   18b98:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   18b9c:	e2833001 	add	r3, r3, #1
   18ba0:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      {
	*s++ = dig = quorem (b, S) + '0';
	if (i >= ilim)
	  break;
	b = multadd (ptr, b, 10, 0);
      }
   18ba4:	eaffffe4 	b	18b3c <_dtoa_r+0x1a0c>

  /* Round off last digit */

  b = lshift (ptr, b, 1);
   18ba8:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   18bac:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   18bb0:	e3a02001 	mov	r2, #1
   18bb4:	eb000c0d 	bl	1bbf0 <__lshift>
   18bb8:	e50b0060 	str	r0, [fp, #-96]	; 0x60
  j = cmp (b, S);
   18bbc:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   18bc0:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   18bc4:	eb000c8b 	bl	1bdf8 <__mcmp>
   18bc8:	e50b0034 	str	r0, [fp, #-52]	; 0x34
  if ((j > 0) || ((j == 0) && (dig & 1)))
   18bcc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   18bd0:	e3530000 	cmp	r3, #0
   18bd4:	ca000006 	bgt	18bf4 <_dtoa_r+0x1ac4>
   18bd8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   18bdc:	e3530000 	cmp	r3, #0
   18be0:	1a000020 	bne	18c68 <_dtoa_r+0x1b38>
   18be4:	e51b3020 	ldr	r3, [fp, #-32]
   18be8:	e2033001 	and	r3, r3, #1
   18bec:	e3530000 	cmp	r3, #0
   18bf0:	0a00001c 	beq	18c68 <_dtoa_r+0x1b38>
    {
    roundoff:
      while (*--s == '9')
   18bf4:	ea00000c 	b	18c2c <_dtoa_r+0x1afc>
	if (s == s0)
   18bf8:	e51b2078 	ldr	r2, [fp, #-120]	; 0x78
   18bfc:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
   18c00:	e1520003 	cmp	r2, r3
   18c04:	1a000008 	bne	18c2c <_dtoa_r+0x1afc>
	  {
	    k++;
   18c08:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   18c0c:	e2833001 	add	r3, r3, #1
   18c10:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	    *s++ = '1';
   18c14:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   18c18:	e2832001 	add	r2, r3, #1
   18c1c:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   18c20:	e3a02031 	mov	r2, #49	; 0x31
   18c24:	e5c32000 	strb	r2, [r3]
	    goto ret;
   18c28:	ea000018 	b	18c90 <_dtoa_r+0x1b60>
  b = lshift (ptr, b, 1);
  j = cmp (b, S);
  if ((j > 0) || ((j == 0) && (dig & 1)))
    {
    roundoff:
      while (*--s == '9')
   18c2c:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   18c30:	e2433001 	sub	r3, r3, #1
   18c34:	e50b3078 	str	r3, [fp, #-120]	; 0x78
   18c38:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   18c3c:	e5d33000 	ldrb	r3, [r3]
   18c40:	e3530039 	cmp	r3, #57	; 0x39
   18c44:	0affffeb 	beq	18bf8 <_dtoa_r+0x1ac8>
	  {
	    k++;
	    *s++ = '1';
	    goto ret;
	  }
      ++*s++;
   18c48:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   18c4c:	e2832001 	add	r2, r3, #1
   18c50:	e50b2078 	str	r2, [fp, #-120]	; 0x78
   18c54:	e5d32000 	ldrb	r2, [r3]
   18c58:	e2822001 	add	r2, r2, #1
   18c5c:	e20220ff 	and	r2, r2, #255	; 0xff
   18c60:	e5c32000 	strb	r2, [r3]
   18c64:	ea000009 	b	18c90 <_dtoa_r+0x1b60>
    }
  else
    {
      while (*--s == '0');
   18c68:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   18c6c:	e2433001 	sub	r3, r3, #1
   18c70:	e50b3078 	str	r3, [fp, #-120]	; 0x78
   18c74:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   18c78:	e5d33000 	ldrb	r3, [r3]
   18c7c:	e3530030 	cmp	r3, #48	; 0x30
   18c80:	0afffff8 	beq	18c68 <_dtoa_r+0x1b38>
      s++;
   18c84:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   18c88:	e2833001 	add	r3, r3, #1
   18c8c:	e50b3078 	str	r3, [fp, #-120]	; 0x78
    }
ret:
  Bfree (ptr, S);
   18c90:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   18c94:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   18c98:	eb000912 	bl	1b0e8 <_Bfree>
  if (mhi)
   18c9c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   18ca0:	e3530000 	cmp	r3, #0
   18ca4:	0a00000c 	beq	18cdc <_dtoa_r+0x1bac>
    {
      if (mlo && mlo != mhi)
   18ca8:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   18cac:	e3530000 	cmp	r3, #0
   18cb0:	0a000006 	beq	18cd0 <_dtoa_r+0x1ba0>
   18cb4:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
   18cb8:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   18cbc:	e1520003 	cmp	r2, r3
   18cc0:	0a000002 	beq	18cd0 <_dtoa_r+0x1ba0>
	Bfree (ptr, mlo);
   18cc4:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   18cc8:	e51b1064 	ldr	r1, [fp, #-100]	; 0x64
   18ccc:	eb000905 	bl	1b0e8 <_Bfree>
      Bfree (ptr, mhi);
   18cd0:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   18cd4:	e51b1068 	ldr	r1, [fp, #-104]	; 0x68
   18cd8:	eb000902 	bl	1b0e8 <_Bfree>
    }
ret1:
  Bfree (ptr, b);
   18cdc:	e51b00c0 	ldr	r0, [fp, #-192]	; 0xc0
   18ce0:	e51b1060 	ldr	r1, [fp, #-96]	; 0x60
   18ce4:	eb0008ff 	bl	1b0e8 <_Bfree>
  *s = 0;
   18ce8:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   18cec:	e3a02000 	mov	r2, #0
   18cf0:	e5c32000 	strb	r2, [r3]
  *decpt = k + 1;
   18cf4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   18cf8:	e2832001 	add	r2, r3, #1
   18cfc:	e59b300c 	ldr	r3, [fp, #12]
   18d00:	e5832000 	str	r2, [r3]
  if (rve)
   18d04:	e59b3014 	ldr	r3, [fp, #20]
   18d08:	e3530000 	cmp	r3, #0
   18d0c:	0a000002 	beq	18d1c <_dtoa_r+0x1bec>
    *rve = s;
   18d10:	e59b3014 	ldr	r3, [fp, #20]
   18d14:	e51b2078 	ldr	r2, [fp, #-120]	; 0x78
   18d18:	e5832000 	str	r2, [r3]
  return s0;
   18d1c:	e51b3080 	ldr	r3, [fp, #-128]	; 0x80
}
   18d20:	e1a00003 	mov	r0, r3
   18d24:	e24bd014 	sub	sp, fp, #20
   18d28:	e8bd48f0 	pop	{r4, r5, r6, r7, fp, lr}
   18d2c:	e12fff1e 	bx	lr

00018d30 <__sflush_r>:
   directly from __srefill. */
int
_DEFUN(__sflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   18d30:	e92d48f0 	push	{r4, r5, r6, r7, fp, lr}
   18d34:	e28db014 	add	fp, sp, #20
   18d38:	e24dd020 	sub	sp, sp, #32
   18d3c:	e50b0028 	str	r0, [fp, #-40]	; 0x28
   18d40:	e1a04001 	mov	r4, r1
  register unsigned char *p;
  register int n, t;

  t = fp->_flags;
   18d44:	e1d430bc 	ldrh	r3, [r4, #12]
   18d48:	e1a03803 	lsl	r3, r3, #16
   18d4c:	e1a06843 	asr	r6, r3, #16
  if ((t & __SWR) == 0)
   18d50:	e2063008 	and	r3, r6, #8
   18d54:	e3530000 	cmp	r3, #0
   18d58:	1a0000bf 	bne	1905c <__sflush_r+0x32c>
    {
#ifdef _FSEEK_OPTIMIZATION
      /* For a read stream, an fflush causes the next seek to be
         unoptimized (i.e. forces a system-level seek).  This conforms
         to the POSIX and SUSv3 standards.  */
      fp->_flags |= __SNPT;
   18d5c:	e1d430bc 	ldrh	r3, [r4, #12]
   18d60:	e3833b02 	orr	r3, r3, #2048	; 0x800
   18d64:	e1a03803 	lsl	r3, r3, #16
   18d68:	e1a03823 	lsr	r3, r3, #16
   18d6c:	e1c430bc 	strh	r3, [r4, #12]
         the next byte from the file rather than the buffer.  This conforms
         to the POSIX and SUSv3 standards.  Note that the standards allow
         this seek to be deferred until necessary, but we choose to do it here
         to make the change simpler, more contained, and less likely
         to miss a code scenario.  */
      if ((fp->_r > 0 || fp->_ur > 0) && fp->_seek != NULL)
   18d70:	e5943004 	ldr	r3, [r4, #4]
   18d74:	e3530000 	cmp	r3, #0
   18d78:	ca000002 	bgt	18d88 <__sflush_r+0x58>
   18d7c:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
   18d80:	e3530000 	cmp	r3, #0
   18d84:	da0000b2 	ble	19054 <__sflush_r+0x324>
   18d88:	e5943028 	ldr	r3, [r4, #40]	; 0x28
   18d8c:	e3530000 	cmp	r3, #0
   18d90:	0a0000af 	beq	19054 <__sflush_r+0x324>
#endif

	  /* Save last errno and set errno to 0, so we can check if a device
	     returns with a valid position -1.  We restore the last errno if
	     no other error condition has been encountered. */
	  tmp_errno = ptr->_errno;
   18d94:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   18d98:	e5933000 	ldr	r3, [r3]
   18d9c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	  ptr->_errno = 0;
   18da0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   18da4:	e3a02000 	mov	r2, #0
   18da8:	e5832000 	str	r2, [r3]
	  /* Get the physical position we are at in the file.  */
	  if (fp->_flags & __SOFF)
   18dac:	e1d430bc 	ldrh	r3, [r4, #12]
   18db0:	e1a03803 	lsl	r3, r3, #16
   18db4:	e1a03823 	lsr	r3, r3, #16
   18db8:	e2033a01 	and	r3, r3, #4096	; 0x1000
   18dbc:	e3530000 	cmp	r3, #0
   18dc0:	0a000004 	beq	18dd8 <__sflush_r+0xa8>
	    curoff = fp->_offset;
   18dc4:	e2843050 	add	r3, r4, #80	; 0x50
   18dc8:	e893000c 	ldm	r3, {r2, r3}
   18dcc:	e50b201c 	str	r2, [fp, #-28]
   18dd0:	e50b3018 	str	r3, [fp, #-24]
   18dd4:	ea00002d 	b	18e90 <__sflush_r+0x160>
#ifdef __LARGE64_FILES
	      if (fp->_flags & __SL64)
		curoff = fp->_seek64 (ptr, fp->_cookie, 0, SEEK_CUR);
	      else
#endif
		curoff = fp->_seek (ptr, fp->_cookie, 0, SEEK_CUR);
   18dd8:	e594c028 	ldr	ip, [r4, #40]	; 0x28
   18ddc:	e594301c 	ldr	r3, [r4, #28]
   18de0:	e3a02001 	mov	r2, #1
   18de4:	e58d2000 	str	r2, [sp]
   18de8:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
   18dec:	e1a01003 	mov	r1, r3
   18df0:	e3a02000 	mov	r2, #0
   18df4:	e3a03000 	mov	r3, #0
   18df8:	e1a0e00f 	mov	lr, pc
   18dfc:	e12fff1c 	bx	ip
   18e00:	e50b001c 	str	r0, [fp, #-28]
   18e04:	e50b1018 	str	r1, [fp, #-24]
	      if (curoff == -1L && ptr->_errno != 0)
   18e08:	e24b101c 	sub	r1, fp, #28
   18e0c:	e8910003 	ldm	r1, {r0, r1}
   18e10:	e3e02000 	mvn	r2, #0
   18e14:	e3e03000 	mvn	r3, #0
   18e18:	e1510003 	cmp	r1, r3
   18e1c:	01500002 	cmpeq	r0, r2
   18e20:	1a00001a 	bne	18e90 <__sflush_r+0x160>
   18e24:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   18e28:	e5933000 	ldr	r3, [r3]
   18e2c:	e3530000 	cmp	r3, #0
   18e30:	0a000016 	beq	18e90 <__sflush_r+0x160>
		{
		  int result = EOF;
   18e34:	e3e03000 	mvn	r3, #0
   18e38:	e50b3020 	str	r3, [fp, #-32]
		  if (ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
   18e3c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   18e40:	e5933000 	ldr	r3, [r3]
   18e44:	e353001d 	cmp	r3, #29
   18e48:	0a000003 	beq	18e5c <__sflush_r+0x12c>
   18e4c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   18e50:	e5933000 	ldr	r3, [r3]
   18e54:	e3530016 	cmp	r3, #22
   18e58:	1a000005 	bne	18e74 <__sflush_r+0x144>
		    {
		      result = 0;
   18e5c:	e3a03000 	mov	r3, #0
   18e60:	e50b3020 	str	r3, [fp, #-32]
		      ptr->_errno = tmp_errno;
   18e64:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   18e68:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   18e6c:	e5832000 	str	r2, [r3]
   18e70:	ea000004 	b	18e88 <__sflush_r+0x158>
		    }
		  else
		    fp->_flags |= __SERR;
   18e74:	e1d430bc 	ldrh	r3, [r4, #12]
   18e78:	e3833040 	orr	r3, r3, #64	; 0x40
   18e7c:	e1a03803 	lsl	r3, r3, #16
   18e80:	e1a03823 	lsr	r3, r3, #16
   18e84:	e1c430bc 	strh	r3, [r4, #12]
		  return result;
   18e88:	e51b3020 	ldr	r3, [fp, #-32]
   18e8c:	ea00009c 	b	19104 <__sflush_r+0x3d4>
		}
            }
          if (fp->_flags & __SRD)
   18e90:	e1d430bc 	ldrh	r3, [r4, #12]
   18e94:	e1a03803 	lsl	r3, r3, #16
   18e98:	e1a03823 	lsr	r3, r3, #16
   18e9c:	e2033004 	and	r3, r3, #4
   18ea0:	e3530000 	cmp	r3, #0
   18ea4:	0a000014 	beq	18efc <__sflush_r+0x1cc>
            {
              /* Current offset is at end of buffer.  Compensate for
                 characters not yet read.  */
              curoff -= fp->_r;
   18ea8:	e5943004 	ldr	r3, [r4, #4]
   18eac:	e1a02003 	mov	r2, r3
   18eb0:	e1a03fc2 	asr	r3, r2, #31
   18eb4:	e24b101c 	sub	r1, fp, #28
   18eb8:	e8910003 	ldm	r1, {r0, r1}
   18ebc:	e0502002 	subs	r2, r0, r2
   18ec0:	e0c13003 	sbc	r3, r1, r3
   18ec4:	e50b201c 	str	r2, [fp, #-28]
   18ec8:	e50b3018 	str	r3, [fp, #-24]
              if (HASUB (fp))
   18ecc:	e5943030 	ldr	r3, [r4, #48]	; 0x30
   18ed0:	e3530000 	cmp	r3, #0
   18ed4:	0a000008 	beq	18efc <__sflush_r+0x1cc>
                curoff -= fp->_ur;
   18ed8:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
   18edc:	e1a02003 	mov	r2, r3
   18ee0:	e1a03fc2 	asr	r3, r2, #31
   18ee4:	e24b101c 	sub	r1, fp, #28
   18ee8:	e8910003 	ldm	r1, {r0, r1}
   18eec:	e0502002 	subs	r2, r0, r2
   18ef0:	e0c13003 	sbc	r3, r1, r3
   18ef4:	e50b201c 	str	r2, [fp, #-28]
   18ef8:	e50b3018 	str	r3, [fp, #-24]
#ifdef __LARGE64_FILES
	  if (fp->_flags & __SL64)
	    curoff = fp->_seek64 (ptr, fp->_cookie, curoff, SEEK_SET);
	  else
#endif
	    curoff = fp->_seek (ptr, fp->_cookie, curoff, SEEK_SET);
   18efc:	e594c028 	ldr	ip, [r4, #40]	; 0x28
   18f00:	e594301c 	ldr	r3, [r4, #28]
   18f04:	e3a02000 	mov	r2, #0
   18f08:	e58d2000 	str	r2, [sp]
   18f0c:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
   18f10:	e1a01003 	mov	r1, r3
   18f14:	e24b301c 	sub	r3, fp, #28
   18f18:	e893000c 	ldm	r3, {r2, r3}
   18f1c:	e1a0e00f 	mov	lr, pc
   18f20:	e12fff1c 	bx	ip
   18f24:	e50b001c 	str	r0, [fp, #-28]
   18f28:	e50b1018 	str	r1, [fp, #-24]
	  if (curoff != -1 || ptr->_errno == 0
   18f2c:	e24b101c 	sub	r1, fp, #28
   18f30:	e8910003 	ldm	r1, {r0, r1}
   18f34:	e3e02000 	mvn	r2, #0
   18f38:	e3e03000 	mvn	r3, #0
   18f3c:	e1510003 	cmp	r1, r3
   18f40:	01500002 	cmpeq	r0, r2
   18f44:	1a00000b 	bne	18f78 <__sflush_r+0x248>
   18f48:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   18f4c:	e5933000 	ldr	r3, [r3]
   18f50:	e3530000 	cmp	r3, #0
   18f54:	0a000007 	beq	18f78 <__sflush_r+0x248>
	      || ptr->_errno == ESPIPE || ptr->_errno == EINVAL)
   18f58:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   18f5c:	e5933000 	ldr	r3, [r3]
   18f60:	e353001d 	cmp	r3, #29
   18f64:	0a000003 	beq	18f78 <__sflush_r+0x248>
   18f68:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   18f6c:	e5933000 	ldr	r3, [r3]
   18f70:	e3530016 	cmp	r3, #22
   18f74:	1a00002f 	bne	19038 <__sflush_r+0x308>
	    {
	      /* Seek successful or ignorable error condition.
		 We can clear read buffer now.  */
#ifdef _FSEEK_OPTIMIZATION
	      fp->_flags &= ~__SNPT;
   18f78:	e1d430bc 	ldrh	r3, [r4, #12]
   18f7c:	e3c33b02 	bic	r3, r3, #2048	; 0x800
   18f80:	e1a03803 	lsl	r3, r3, #16
   18f84:	e1a03823 	lsr	r3, r3, #16
   18f88:	e1c430bc 	strh	r3, [r4, #12]
#endif
	      fp->_r = 0;
   18f8c:	e3a03000 	mov	r3, #0
   18f90:	e5843004 	str	r3, [r4, #4]
	      fp->_p = fp->_bf._base;
   18f94:	e5943010 	ldr	r3, [r4, #16]
   18f98:	e5843000 	str	r3, [r4]
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
   18f9c:	e1d430bc 	ldrh	r3, [r4, #12]
   18fa0:	e1a03803 	lsl	r3, r3, #16
   18fa4:	e1a03823 	lsr	r3, r3, #16
   18fa8:	e2033a01 	and	r3, r3, #4096	; 0x1000
   18fac:	e3530000 	cmp	r3, #0
   18fb0:	0a00000e 	beq	18ff0 <__sflush_r+0x2c0>
   18fb4:	e24b101c 	sub	r1, fp, #28
   18fb8:	e8910003 	ldm	r1, {r0, r1}
   18fbc:	e3e02000 	mvn	r2, #0
   18fc0:	e3e03000 	mvn	r3, #0
   18fc4:	e1510003 	cmp	r1, r3
   18fc8:	01500002 	cmpeq	r0, r2
   18fcc:	1a000003 	bne	18fe0 <__sflush_r+0x2b0>
   18fd0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   18fd4:	e5933000 	ldr	r3, [r3]
   18fd8:	e3530000 	cmp	r3, #0
   18fdc:	1a000003 	bne	18ff0 <__sflush_r+0x2c0>
		fp->_offset = curoff;
   18fe0:	e24b301c 	sub	r3, fp, #28
   18fe4:	e893000c 	ldm	r3, {r2, r3}
   18fe8:	e5842050 	str	r2, [r4, #80]	; 0x50
   18fec:	e5843054 	str	r3, [r4, #84]	; 0x54
	      ptr->_errno = tmp_errno;
   18ff0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   18ff4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   18ff8:	e5832000 	str	r2, [r3]
	      if (HASUB (fp))
   18ffc:	e5943030 	ldr	r3, [r4, #48]	; 0x30
   19000:	e3530000 	cmp	r3, #0
   19004:	0a00000a 	beq	19034 <__sflush_r+0x304>
		FREEUB (ptr, fp);
   19008:	e5942030 	ldr	r2, [r4, #48]	; 0x30
   1900c:	e2843040 	add	r3, r4, #64	; 0x40
   19010:	e1520003 	cmp	r2, r3
   19014:	0a000003 	beq	19028 <__sflush_r+0x2f8>
   19018:	e5943030 	ldr	r3, [r4, #48]	; 0x30
   1901c:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
   19020:	e1a01003 	mov	r1, r3
   19024:	eb00021c 	bl	1989c <_free_r>
   19028:	e3a03000 	mov	r3, #0
   1902c:	e5843030 	str	r3, [r4, #48]	; 0x30
	      fp->_r = 0;
	      fp->_p = fp->_bf._base;
	      if ((fp->_flags & __SOFF) && (curoff != -1 || ptr->_errno == 0))
		fp->_offset = curoff;
	      ptr->_errno = tmp_errno;
	      if (HASUB (fp))
   19030:	ea000007 	b	19054 <__sflush_r+0x324>
   19034:	ea000006 	b	19054 <__sflush_r+0x324>
		FREEUB (ptr, fp);
	    }
	  else
	    {
	      fp->_flags |= __SERR;
   19038:	e1d430bc 	ldrh	r3, [r4, #12]
   1903c:	e3833040 	orr	r3, r3, #64	; 0x40
   19040:	e1a03803 	lsl	r3, r3, #16
   19044:	e1a03823 	lsr	r3, r3, #16
   19048:	e1c430bc 	strh	r3, [r4, #12]
	      return EOF;
   1904c:	e3e03000 	mvn	r3, #0
   19050:	ea00002b 	b	19104 <__sflush_r+0x3d4>
	    }
	}
      return 0;
   19054:	e3a03000 	mov	r3, #0
   19058:	ea000029 	b	19104 <__sflush_r+0x3d4>
    }
  if ((p = fp->_bf._base) == NULL)
   1905c:	e5945010 	ldr	r5, [r4, #16]
   19060:	e3550000 	cmp	r5, #0
   19064:	1a000001 	bne	19070 <__sflush_r+0x340>
    {
      /* Nothing to flush.  */
      return 0;
   19068:	e3a03000 	mov	r3, #0
   1906c:	ea000024 	b	19104 <__sflush_r+0x3d4>
    }
  n = fp->_p - p;		/* write this much */
   19070:	e5943000 	ldr	r3, [r4]
   19074:	e1a02003 	mov	r2, r3
   19078:	e1a03005 	mov	r3, r5
   1907c:	e0637002 	rsb	r7, r3, r2
  /*
   * Set these immediately to avoid problems with longjmp
   * and to allow exchange buffering (via setvbuf) in user
   * write function.
   */
  fp->_p = p;
   19080:	e5845000 	str	r5, [r4]
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;
   19084:	e2063003 	and	r3, r6, #3
   19088:	e3530000 	cmp	r3, #0
   1908c:	1a000001 	bne	19098 <__sflush_r+0x368>
   19090:	e5943014 	ldr	r3, [r4, #20]
   19094:	ea000000 	b	1909c <__sflush_r+0x36c>
   19098:	e3a03000 	mov	r3, #0
   1909c:	e5843008 	str	r3, [r4, #8]

  while (n > 0)
   190a0:	ea000014 	b	190f8 <__sflush_r+0x3c8>
    {
      t = fp->_write (ptr, fp->_cookie, (char *) p, n);
   190a4:	e594c024 	ldr	ip, [r4, #36]	; 0x24
   190a8:	e594301c 	ldr	r3, [r4, #28]
   190ac:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
   190b0:	e1a01003 	mov	r1, r3
   190b4:	e1a02005 	mov	r2, r5
   190b8:	e1a03007 	mov	r3, r7
   190bc:	e1a0e00f 	mov	lr, pc
   190c0:	e12fff1c 	bx	ip
   190c4:	e1a06000 	mov	r6, r0
      if (t <= 0)
   190c8:	e3560000 	cmp	r6, #0
   190cc:	ca000006 	bgt	190ec <__sflush_r+0x3bc>
	{
          fp->_flags |= __SERR;
   190d0:	e1d430bc 	ldrh	r3, [r4, #12]
   190d4:	e3833040 	orr	r3, r3, #64	; 0x40
   190d8:	e1a03803 	lsl	r3, r3, #16
   190dc:	e1a03823 	lsr	r3, r3, #16
   190e0:	e1c430bc 	strh	r3, [r4, #12]
          return EOF;
   190e4:	e3e03000 	mvn	r3, #0
   190e8:	ea000005 	b	19104 <__sflush_r+0x3d4>
	}
      p += t;
   190ec:	e1a03006 	mov	r3, r6
   190f0:	e0855003 	add	r5, r5, r3
      n -= t;
   190f4:	e0667007 	rsb	r7, r6, r7
   * write function.
   */
  fp->_p = p;
  fp->_w = t & (__SLBF | __SNBF) ? 0 : fp->_bf._size;

  while (n > 0)
   190f8:	e3570000 	cmp	r7, #0
   190fc:	caffffe8 	bgt	190a4 <__sflush_r+0x374>
          return EOF;
	}
      p += t;
      n -= t;
    }
  return 0;
   19100:	e3a03000 	mov	r3, #0
}
   19104:	e1a00003 	mov	r0, r3
   19108:	e24bd014 	sub	sp, fp, #20
   1910c:	e8bd48f0 	pop	{r4, r5, r6, r7, fp, lr}
   19110:	e12fff1e 	bx	lr

00019114 <_fflush_r>:

int
_DEFUN(_fflush_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE * fp)
{
   19114:	e92d4810 	push	{r4, fp, lr}
   19118:	e28db008 	add	fp, sp, #8
   1911c:	e24dd014 	sub	sp, sp, #20
   19120:	e50b0018 	str	r0, [fp, #-24]
   19124:	e1a04001 	mov	r4, r1
     2 is implemented here due to its simplicity.  */
  if (fp->_bf._base == NULL)
    return 0;
#endif /* _REENT_SMALL  */

  CHECK_INIT (ptr, fp);
   19128:	e51b3018 	ldr	r3, [fp, #-24]
   1912c:	e50b3010 	str	r3, [fp, #-16]
   19130:	e51b3010 	ldr	r3, [fp, #-16]
   19134:	e3530000 	cmp	r3, #0
   19138:	0a000005 	beq	19154 <_fflush_r+0x40>
   1913c:	e51b3010 	ldr	r3, [fp, #-16]
   19140:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   19144:	e3530000 	cmp	r3, #0
   19148:	1a000001 	bne	19154 <_fflush_r+0x40>
   1914c:	e51b0010 	ldr	r0, [fp, #-16]
   19150:	eb00013a 	bl	19640 <__sinit>

  if (!fp->_flags)
   19154:	e1d430bc 	ldrh	r3, [r4, #12]
   19158:	e3530000 	cmp	r3, #0
   1915c:	1a000001 	bne	19168 <_fflush_r+0x54>
    return 0;
   19160:	e3a03000 	mov	r3, #0
   19164:	ea000016 	b	191c4 <_fflush_r+0xb0>

  _newlib_flockfile_start (fp);
   19168:	e1d430bc 	ldrh	r3, [r4, #12]
   1916c:	e1a03803 	lsl	r3, r3, #16
   19170:	e1a03823 	lsr	r3, r3, #16
   19174:	e2033c02 	and	r3, r3, #512	; 0x200
   19178:	e3530000 	cmp	r3, #0
   1917c:	1a000002 	bne	1918c <_fflush_r+0x78>
   19180:	e284305c 	add	r3, r4, #92	; 0x5c
   19184:	e1a00003 	mov	r0, r3
   19188:	ebffd61c 	bl	ea00 <_dna_lock_acquire>
  ret = __sflush_r (ptr, fp);
   1918c:	e51b0018 	ldr	r0, [fp, #-24]
   19190:	e1a01004 	mov	r1, r4
   19194:	ebfffee5 	bl	18d30 <__sflush_r>
   19198:	e50b0014 	str	r0, [fp, #-20]
  _newlib_flockfile_end (fp);
   1919c:	e1d430bc 	ldrh	r3, [r4, #12]
   191a0:	e1a03803 	lsl	r3, r3, #16
   191a4:	e1a03823 	lsr	r3, r3, #16
   191a8:	e2033c02 	and	r3, r3, #512	; 0x200
   191ac:	e3530000 	cmp	r3, #0
   191b0:	1a000002 	bne	191c0 <_fflush_r+0xac>
   191b4:	e284305c 	add	r3, r4, #92	; 0x5c
   191b8:	e1a00003 	mov	r0, r3
   191bc:	ebffd676 	bl	eb9c <_dna_lock_release>
  return ret;
   191c0:	e51b3014 	ldr	r3, [fp, #-20]
}
   191c4:	e1a00003 	mov	r0, r3
   191c8:	e24bd008 	sub	sp, fp, #8
   191cc:	e8bd4810 	pop	{r4, fp, lr}
   191d0:	e12fff1e 	bx	lr

000191d4 <fflush>:
#ifndef _REENT_ONLY

int
_DEFUN(fflush, (fp),
       register FILE * fp)
{
   191d4:	e92d4800 	push	{fp, lr}
   191d8:	e28db004 	add	fp, sp, #4
   191dc:	e1a03000 	mov	r3, r0
  if (fp == NULL)
   191e0:	e3530000 	cmp	r3, #0
   191e4:	1a000006 	bne	19204 <fflush+0x30>
    return _fwalk_reent (_GLOBAL_REENT, _fflush_r);
   191e8:	e59f303c 	ldr	r3, [pc, #60]	; 1922c <fflush+0x58>
   191ec:	e5933000 	ldr	r3, [r3]
   191f0:	e1a00003 	mov	r0, r3
   191f4:	e59f1034 	ldr	r1, [pc, #52]	; 19230 <fflush+0x5c>
   191f8:	eb000537 	bl	1a6dc <_fwalk_reent>
   191fc:	e1a03000 	mov	r3, r0
   19200:	ea000005 	b	1921c <fflush+0x48>

  return _fflush_r (_REENT, fp);
   19204:	e59f2028 	ldr	r2, [pc, #40]	; 19234 <fflush+0x60>
   19208:	e5922000 	ldr	r2, [r2]
   1920c:	e1a00002 	mov	r0, r2
   19210:	e1a01003 	mov	r1, r3
   19214:	ebffffbe 	bl	19114 <_fflush_r>
   19218:	e1a03000 	mov	r3, r0
}
   1921c:	e1a00003 	mov	r0, r3
   19220:	e24bd004 	sub	sp, fp, #4
   19224:	e8bd4800 	pop	{fp, lr}
   19228:	e12fff1e 	bx	lr
   1922c:	0002480c 	.word	0x0002480c
   19230:	00019114 	.word	0x00019114
   19234:	00025440 	.word	0x00025440

00019238 <std>:
_DEFUN(std, (ptr, flags, file, data),
            FILE *ptr _AND
            int flags _AND
            int file  _AND
            struct _reent *data)
{
   19238:	e92d4800 	push	{fp, lr}
   1923c:	e28db004 	add	fp, sp, #4
   19240:	e24dd010 	sub	sp, sp, #16
   19244:	e50b0008 	str	r0, [fp, #-8]
   19248:	e50b100c 	str	r1, [fp, #-12]
   1924c:	e50b2010 	str	r2, [fp, #-16]
   19250:	e50b3014 	str	r3, [fp, #-20]
  ptr->_p = 0;
   19254:	e51b3008 	ldr	r3, [fp, #-8]
   19258:	e3a02000 	mov	r2, #0
   1925c:	e5832000 	str	r2, [r3]
  ptr->_r = 0;
   19260:	e51b3008 	ldr	r3, [fp, #-8]
   19264:	e3a02000 	mov	r2, #0
   19268:	e5832004 	str	r2, [r3, #4]
  ptr->_w = 0;
   1926c:	e51b3008 	ldr	r3, [fp, #-8]
   19270:	e3a02000 	mov	r2, #0
   19274:	e5832008 	str	r2, [r3, #8]
  ptr->_flags = flags;
   19278:	e51b300c 	ldr	r3, [fp, #-12]
   1927c:	e1a03803 	lsl	r3, r3, #16
   19280:	e1a02823 	lsr	r2, r3, #16
   19284:	e51b3008 	ldr	r3, [fp, #-8]
   19288:	e1c320bc 	strh	r2, [r3, #12]
  ptr->_flags2 = 0;
   1928c:	e51b3008 	ldr	r3, [fp, #-8]
   19290:	e3a02000 	mov	r2, #0
   19294:	e583206c 	str	r2, [r3, #108]	; 0x6c
  ptr->_file = file;
   19298:	e51b3010 	ldr	r3, [fp, #-16]
   1929c:	e1a03803 	lsl	r3, r3, #16
   192a0:	e1a02823 	lsr	r2, r3, #16
   192a4:	e51b3008 	ldr	r3, [fp, #-8]
   192a8:	e1c320be 	strh	r2, [r3, #14]
  ptr->_bf._base = 0;
   192ac:	e51b3008 	ldr	r3, [fp, #-8]
   192b0:	e3a02000 	mov	r2, #0
   192b4:	e5832010 	str	r2, [r3, #16]
  ptr->_bf._size = 0;
   192b8:	e51b3008 	ldr	r3, [fp, #-8]
   192bc:	e3a02000 	mov	r2, #0
   192c0:	e5832014 	str	r2, [r3, #20]
  ptr->_lbfsize = 0;
   192c4:	e51b3008 	ldr	r3, [fp, #-8]
   192c8:	e3a02000 	mov	r2, #0
   192cc:	e5832018 	str	r2, [r3, #24]
  memset (&ptr->_mbstate, 0, sizeof (_mbstate_t));
   192d0:	e51b3008 	ldr	r3, [fp, #-8]
   192d4:	e2833064 	add	r3, r3, #100	; 0x64
   192d8:	e1a00003 	mov	r0, r3
   192dc:	e3a01000 	mov	r1, #0
   192e0:	e3a02008 	mov	r2, #8
   192e4:	ebffda83 	bl	fcf8 <memset>
  ptr->_cookie = ptr;
   192e8:	e51b3008 	ldr	r3, [fp, #-8]
   192ec:	e51b2008 	ldr	r2, [fp, #-8]
   192f0:	e583201c 	str	r2, [r3, #28]
  ptr->_read = __sread;
   192f4:	e51b3008 	ldr	r3, [fp, #-8]
   192f8:	e59f2040 	ldr	r2, [pc, #64]	; 19340 <std+0x108>
   192fc:	e5832020 	str	r2, [r3, #32]
#ifndef __LARGE64_FILES
  ptr->_write = __swrite;
   19300:	e51b3008 	ldr	r3, [fp, #-8]
   19304:	e59f2038 	ldr	r2, [pc, #56]	; 19344 <std+0x10c>
   19308:	e5832024 	str	r2, [r3, #36]	; 0x24
#else /* __LARGE64_FILES */
  ptr->_write = __swrite64;
  ptr->_seek64 = __sseek64;
  ptr->_flags |= __SL64;
#endif /* __LARGE64_FILES */
  ptr->_seek = __sseek;
   1930c:	e51b3008 	ldr	r3, [fp, #-8]
   19310:	e59f2030 	ldr	r2, [pc, #48]	; 19348 <std+0x110>
   19314:	e5832028 	str	r2, [r3, #40]	; 0x28
#ifdef _STDIO_CLOSE_PER_REENT_STD_STREAMS
  ptr->_close = __sclose;
   19318:	e51b3008 	ldr	r3, [fp, #-8]
   1931c:	e59f2028 	ldr	r2, [pc, #40]	; 1934c <std+0x114>
   19320:	e583202c 	str	r2, [r3, #44]	; 0x2c
#else /* _STDIO_CLOSE_STD_STREAMS */
  ptr->_close = NULL;
#endif /* _STDIO_CLOSE_STD_STREAMS */
#if !defined(__SINGLE_THREAD__) && !defined(_REENT_SMALL)
  __lock_init_recursive (ptr->_lock);
   19324:	e51b3008 	ldr	r3, [fp, #-8]
   19328:	e283305c 	add	r3, r3, #92	; 0x5c
   1932c:	e1a00003 	mov	r0, r3
   19330:	ebffd561 	bl	e8bc <_dna_lock_init>

#ifdef __SCLE
  if (__stextmode (ptr->_file))
    ptr->_flags |= __SCLE;
#endif
}
   19334:	e24bd004 	sub	sp, fp, #4
   19338:	e8bd4800 	pop	{fp, lr}
   1933c:	e12fff1e 	bx	lr
   19340:	0001db88 	.word	0x0001db88
   19344:	0001dc50 	.word	0x0001dc50
   19348:	0001dcfc 	.word	0x0001dcfc
   1934c:	0001ddb0 	.word	0x0001ddb0

00019350 <__sfmoreglue>:

struct _glue *
_DEFUN(__sfmoreglue, (d, n),
       struct _reent *d _AND
       register int n)
{
   19350:	e92d4810 	push	{r4, fp, lr}
   19354:	e28db008 	add	fp, sp, #8
   19358:	e24dd014 	sub	sp, sp, #20
   1935c:	e50b0018 	str	r0, [fp, #-24]
   19360:	e1a04001 	mov	r4, r1
  struct glue_with_file *g;

  g = (struct glue_with_file *)
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
   19364:	e2443001 	sub	r3, r4, #1
   19368:	e1a02003 	mov	r2, r3
   1936c:	e1a03002 	mov	r3, r2
   19370:	e1a03183 	lsl	r3, r3, #3
   19374:	e0623003 	rsb	r3, r2, r3
   19378:	e1a03203 	lsl	r3, r3, #4
   1937c:	e2833080 	add	r3, r3, #128	; 0x80
       struct _reent *d _AND
       register int n)
{
  struct glue_with_file *g;

  g = (struct glue_with_file *)
   19380:	e51b0018 	ldr	r0, [fp, #-24]
   19384:	e1a01003 	mov	r1, r3
   19388:	ebffd729 	bl	f034 <_malloc_r>
   1938c:	e50b0010 	str	r0, [fp, #-16]
    _malloc_r (d, sizeof (*g) + (n - 1) * sizeof (FILE));
  if (g == NULL)
   19390:	e51b3010 	ldr	r3, [fp, #-16]
   19394:	e3530000 	cmp	r3, #0
   19398:	1a000001 	bne	193a4 <__sfmoreglue+0x54>
    return NULL;
   1939c:	e3a03000 	mov	r3, #0
   193a0:	ea000014 	b	193f8 <__sfmoreglue+0xa8>
  g->glue._next = NULL;
   193a4:	e51b3010 	ldr	r3, [fp, #-16]
   193a8:	e3a02000 	mov	r2, #0
   193ac:	e5832000 	str	r2, [r3]
  g->glue._niobs = n;
   193b0:	e51b3010 	ldr	r3, [fp, #-16]
   193b4:	e5834004 	str	r4, [r3, #4]
  g->glue._iobs = &g->file;
   193b8:	e51b3010 	ldr	r3, [fp, #-16]
   193bc:	e2832010 	add	r2, r3, #16
   193c0:	e51b3010 	ldr	r3, [fp, #-16]
   193c4:	e5832008 	str	r2, [r3, #8]
  memset (&g->file, 0, n * sizeof (FILE));
   193c8:	e51b3010 	ldr	r3, [fp, #-16]
   193cc:	e2831010 	add	r1, r3, #16
   193d0:	e1a02004 	mov	r2, r4
   193d4:	e1a03002 	mov	r3, r2
   193d8:	e1a03183 	lsl	r3, r3, #3
   193dc:	e0623003 	rsb	r3, r2, r3
   193e0:	e1a03203 	lsl	r3, r3, #4
   193e4:	e1a00001 	mov	r0, r1
   193e8:	e3a01000 	mov	r1, #0
   193ec:	e1a02003 	mov	r2, r3
   193f0:	ebffda40 	bl	fcf8 <memset>
  return &g->glue;
   193f4:	e51b3010 	ldr	r3, [fp, #-16]
}
   193f8:	e1a00003 	mov	r0, r3
   193fc:	e24bd008 	sub	sp, fp, #8
   19400:	e8bd4810 	pop	{r4, fp, lr}
   19404:	e12fff1e 	bx	lr

00019408 <__sfp>:
 */

FILE *
_DEFUN(__sfp, (d),
       struct _reent *d)
{
   19408:	e92d4800 	push	{fp, lr}
   1940c:	e28db004 	add	fp, sp, #4
   19410:	e24dd018 	sub	sp, sp, #24
   19414:	e50b0018 	str	r0, [fp, #-24]
  FILE *fp;
  int n;
  struct _glue *g;

  _newlib_sfp_lock_start ();
   19418:	eb0000bd 	bl	19714 <__sfp_lock_acquire>

  if (!_GLOBAL_REENT->__sdidinit)
   1941c:	e59f31c4 	ldr	r3, [pc, #452]	; 195e8 <__sfp+0x1e0>
   19420:	e5933000 	ldr	r3, [r3]
   19424:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   19428:	e3530000 	cmp	r3, #0
   1942c:	1a000003 	bne	19440 <__sfp+0x38>
    __sinit (_GLOBAL_REENT);
   19430:	e59f31b0 	ldr	r3, [pc, #432]	; 195e8 <__sfp+0x1e0>
   19434:	e5933000 	ldr	r3, [r3]
   19438:	e1a00003 	mov	r0, r3
   1943c:	eb00007f 	bl	19640 <__sinit>
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
   19440:	e59f31a0 	ldr	r3, [pc, #416]	; 195e8 <__sfp+0x1e0>
   19444:	e5933000 	ldr	r3, [r3]
   19448:	e2833e2e 	add	r3, r3, #736	; 0x2e0
   1944c:	e50b3010 	str	r3, [fp, #-16]
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   19450:	e51b3010 	ldr	r3, [fp, #-16]
   19454:	e5933008 	ldr	r3, [r3, #8]
   19458:	e50b3008 	str	r3, [fp, #-8]
   1945c:	e51b3010 	ldr	r3, [fp, #-16]
   19460:	e5933004 	ldr	r3, [r3, #4]
   19464:	e50b300c 	str	r3, [fp, #-12]
   19468:	ea00003b 	b	1955c <__sfp+0x154>
	if (fp->_flags == 0)
   1946c:	e51b3008 	ldr	r3, [fp, #-8]
   19470:	e1d330bc 	ldrh	r3, [r3, #12]
   19474:	e3530000 	cmp	r3, #0
   19478:	1a000034 	bne	19550 <__sfp+0x148>
	  goto found;
   1947c:	e1a00000 	nop			; (mov r0, r0)
  _newlib_sfp_lock_exit ();
  d->_errno = ENOMEM;
  return NULL;

found:
  fp->_file = -1;		/* no file */
   19480:	e51b3008 	ldr	r3, [fp, #-8]
   19484:	e3e02000 	mvn	r2, #0
   19488:	e1c320be 	strh	r2, [r3, #14]
  fp->_flags = 1;		/* reserve this slot; caller sets real flags */
   1948c:	e51b3008 	ldr	r3, [fp, #-8]
   19490:	e3a02001 	mov	r2, #1
   19494:	e1c320bc 	strh	r2, [r3, #12]
  fp->_flags2 = 0;
   19498:	e51b3008 	ldr	r3, [fp, #-8]
   1949c:	e3a02000 	mov	r2, #0
   194a0:	e583206c 	str	r2, [r3, #108]	; 0x6c
#ifndef __SINGLE_THREAD__
  __lock_init_recursive (fp->_lock);
   194a4:	e51b3008 	ldr	r3, [fp, #-8]
   194a8:	e283305c 	add	r3, r3, #92	; 0x5c
   194ac:	e1a00003 	mov	r0, r3
   194b0:	ebffd501 	bl	e8bc <_dna_lock_init>
#endif
  _newlib_sfp_lock_end ();
   194b4:	eb00009e 	bl	19734 <__sfp_lock_release>

  fp->_p = NULL;		/* no current pointer */
   194b8:	e51b3008 	ldr	r3, [fp, #-8]
   194bc:	e3a02000 	mov	r2, #0
   194c0:	e5832000 	str	r2, [r3]
  fp->_w = 0;			/* nothing to read or write */
   194c4:	e51b3008 	ldr	r3, [fp, #-8]
   194c8:	e3a02000 	mov	r2, #0
   194cc:	e5832008 	str	r2, [r3, #8]
  fp->_r = 0;
   194d0:	e51b3008 	ldr	r3, [fp, #-8]
   194d4:	e3a02000 	mov	r2, #0
   194d8:	e5832004 	str	r2, [r3, #4]
  fp->_bf._base = NULL;		/* no buffer */
   194dc:	e51b3008 	ldr	r3, [fp, #-8]
   194e0:	e3a02000 	mov	r2, #0
   194e4:	e5832010 	str	r2, [r3, #16]
  fp->_bf._size = 0;
   194e8:	e51b3008 	ldr	r3, [fp, #-8]
   194ec:	e3a02000 	mov	r2, #0
   194f0:	e5832014 	str	r2, [r3, #20]
  fp->_lbfsize = 0;		/* not line buffered */
   194f4:	e51b3008 	ldr	r3, [fp, #-8]
   194f8:	e3a02000 	mov	r2, #0
   194fc:	e5832018 	str	r2, [r3, #24]
  memset (&fp->_mbstate, 0, sizeof (_mbstate_t));
   19500:	e51b3008 	ldr	r3, [fp, #-8]
   19504:	e2833064 	add	r3, r3, #100	; 0x64
   19508:	e1a00003 	mov	r0, r3
   1950c:	e3a01000 	mov	r1, #0
   19510:	e3a02008 	mov	r2, #8
   19514:	ebffd9f7 	bl	fcf8 <memset>
  /* fp->_cookie = <any>; */	/* caller sets cookie, _read/_write etc */
  fp->_ub._base = NULL;		/* no ungetc buffer */
   19518:	e51b3008 	ldr	r3, [fp, #-8]
   1951c:	e3a02000 	mov	r2, #0
   19520:	e5832030 	str	r2, [r3, #48]	; 0x30
  fp->_ub._size = 0;
   19524:	e51b3008 	ldr	r3, [fp, #-8]
   19528:	e3a02000 	mov	r2, #0
   1952c:	e5832034 	str	r2, [r3, #52]	; 0x34
  fp->_lb._base = NULL;		/* no line buffer */
   19530:	e51b3008 	ldr	r3, [fp, #-8]
   19534:	e3a02000 	mov	r2, #0
   19538:	e5832044 	str	r2, [r3, #68]	; 0x44
  fp->_lb._size = 0;
   1953c:	e51b3008 	ldr	r3, [fp, #-8]
   19540:	e3a02000 	mov	r2, #0
   19544:	e5832048 	str	r2, [r3, #72]	; 0x48

  return fp;
   19548:	e51b3008 	ldr	r3, [fp, #-8]
   1954c:	ea000021 	b	195d8 <__sfp+0x1d0>

  if (!_GLOBAL_REENT->__sdidinit)
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   19550:	e51b3008 	ldr	r3, [fp, #-8]
   19554:	e2833070 	add	r3, r3, #112	; 0x70
   19558:	e50b3008 	str	r3, [fp, #-8]
   1955c:	e51b300c 	ldr	r3, [fp, #-12]
   19560:	e2433001 	sub	r3, r3, #1
   19564:	e50b300c 	str	r3, [fp, #-12]
   19568:	e51b300c 	ldr	r3, [fp, #-12]
   1956c:	e3530000 	cmp	r3, #0
   19570:	aaffffbd 	bge	1946c <__sfp+0x64>
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
   19574:	e51b3010 	ldr	r3, [fp, #-16]
   19578:	e5933000 	ldr	r3, [r3]
   1957c:	e3530000 	cmp	r3, #0
   19580:	1a000010 	bne	195c8 <__sfp+0x1c0>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
   19584:	e51b0018 	ldr	r0, [fp, #-24]
   19588:	e3a01004 	mov	r1, #4
   1958c:	ebffff6f 	bl	19350 <__sfmoreglue>
   19590:	e1a02000 	mov	r2, r0
   19594:	e51b3010 	ldr	r3, [fp, #-16]
   19598:	e5832000 	str	r2, [r3]
   1959c:	e51b3010 	ldr	r3, [fp, #-16]
   195a0:	e5933000 	ldr	r3, [r3]
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
    {
      for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
   195a4:	e3530000 	cmp	r3, #0
   195a8:	1a000006 	bne	195c8 <__sfp+0x1c0>
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
   195ac:	e1a00000 	nop			; (mov r0, r0)
    }
  _newlib_sfp_lock_exit ();
   195b0:	eb00005f 	bl	19734 <__sfp_lock_release>
  d->_errno = ENOMEM;
   195b4:	e51b3018 	ldr	r3, [fp, #-24]
   195b8:	e3a0200c 	mov	r2, #12
   195bc:	e5832000 	str	r2, [r3]
  return NULL;
   195c0:	e3a03000 	mov	r3, #0
   195c4:	ea000003 	b	195d8 <__sfp+0x1d0>

  _newlib_sfp_lock_start ();

  if (!_GLOBAL_REENT->__sdidinit)
    __sinit (_GLOBAL_REENT);
  for (g = &_GLOBAL_REENT->__sglue;; g = g->_next)
   195c8:	e51b3010 	ldr	r3, [fp, #-16]
   195cc:	e5933000 	ldr	r3, [r3]
   195d0:	e50b3010 	str	r3, [fp, #-16]
	if (fp->_flags == 0)
	  goto found;
      if (g->_next == NULL &&
	  (g->_next = __sfmoreglue (d, NDYNAMIC)) == NULL)
	break;
    }
   195d4:	eaffff9d 	b	19450 <__sfp+0x48>
  fp->_ub._size = 0;
  fp->_lb._base = NULL;		/* no line buffer */
  fp->_lb._size = 0;

  return fp;
}
   195d8:	e1a00003 	mov	r0, r3
   195dc:	e24bd004 	sub	sp, fp, #4
   195e0:	e8bd4800 	pop	{fp, lr}
   195e4:	e12fff1e 	bx	lr
   195e8:	0002480c 	.word	0x0002480c

000195ec <_cleanup_r>:
 */

_VOID
_DEFUN(_cleanup_r, (ptr),
       struct _reent *ptr)
{
   195ec:	e92d4800 	push	{fp, lr}
   195f0:	e28db004 	add	fp, sp, #4
   195f4:	e24dd008 	sub	sp, sp, #8
   195f8:	e50b0008 	str	r0, [fp, #-8]
  _CAST_VOID _fwalk(ptr, fclose);
   195fc:	e51b0008 	ldr	r0, [fp, #-8]
   19600:	e59f100c 	ldr	r1, [pc, #12]	; 19614 <_cleanup_r+0x28>
   19604:	eb00040a 	bl	1a634 <_fwalk>
  /* _CAST_VOID _fwalk (ptr, fflush); */	/* `cheating' */
}
   19608:	e24bd004 	sub	sp, fp, #4
   1960c:	e8bd4800 	pop	{fp, lr}
   19610:	e12fff1e 	bx	lr
   19614:	00021740 	.word	0x00021740

00019618 <_cleanup>:

#ifndef _REENT_ONLY
_VOID
_DEFUN_VOID(_cleanup)
{
   19618:	e92d4800 	push	{fp, lr}
   1961c:	e28db004 	add	fp, sp, #4
  _cleanup_r (_GLOBAL_REENT);
   19620:	e59f3014 	ldr	r3, [pc, #20]	; 1963c <_cleanup+0x24>
   19624:	e5933000 	ldr	r3, [r3]
   19628:	e1a00003 	mov	r0, r3
   1962c:	ebffffee 	bl	195ec <_cleanup_r>
}
   19630:	e24bd004 	sub	sp, fp, #4
   19634:	e8bd4800 	pop	{fp, lr}
   19638:	e12fff1e 	bx	lr
   1963c:	0002480c 	.word	0x0002480c

00019640 <__sinit>:
 */

_VOID
_DEFUN(__sinit, (s),
       struct _reent *s)
{
   19640:	e92d4800 	push	{fp, lr}
   19644:	e28db004 	add	fp, sp, #4
   19648:	e24dd008 	sub	sp, sp, #8
   1964c:	e50b0008 	str	r0, [fp, #-8]
  __sinit_lock_acquire ();
   19650:	eb00003f 	bl	19754 <__sinit_lock_acquire>

  if (s->__sdidinit)
   19654:	e51b3008 	ldr	r3, [fp, #-8]
   19658:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   1965c:	e3530000 	cmp	r3, #0
   19660:	0a000001 	beq	1966c <__sinit+0x2c>
    {
      __sinit_lock_release ();
   19664:	eb000042 	bl	19774 <__sinit_lock_release>
      return;
   19668:	ea000025 	b	19704 <__sinit+0xc4>
    }

  /* make sure we clean up on exit */
  s->__cleanup = _cleanup_r;	/* conservative */
   1966c:	e51b3008 	ldr	r3, [fp, #-8]
   19670:	e59f2098 	ldr	r2, [pc, #152]	; 19710 <__sinit+0xd0>
   19674:	e583203c 	str	r2, [r3, #60]	; 0x3c

  s->__sglue._next = NULL;
   19678:	e51b3008 	ldr	r3, [fp, #-8]
   1967c:	e3a02000 	mov	r2, #0
   19680:	e58322e0 	str	r2, [r3, #736]	; 0x2e0
#ifndef _REENT_SMALL
  s->__sglue._niobs = 3;
   19684:	e51b3008 	ldr	r3, [fp, #-8]
   19688:	e3a02003 	mov	r2, #3
   1968c:	e58322e4 	str	r2, [r3, #740]	; 0x2e4
  s->__sglue._iobs = &s->__sf[0];
   19690:	e51b3008 	ldr	r3, [fp, #-8]
   19694:	e2832e2f 	add	r2, r3, #752	; 0x2f0
   19698:	e51b3008 	ldr	r3, [fp, #-8]
   1969c:	e58322e8 	str	r2, [r3, #744]	; 0x2e8
  s->_stdin = __sfp(s);
  s->_stdout = __sfp(s);
  s->_stderr = __sfp(s);
#endif

  std (s->_stdin,  __SRD, 0, s);
   196a0:	e51b3008 	ldr	r3, [fp, #-8]
   196a4:	e5933004 	ldr	r3, [r3, #4]
   196a8:	e1a00003 	mov	r0, r3
   196ac:	e3a01004 	mov	r1, #4
   196b0:	e3a02000 	mov	r2, #0
   196b4:	e51b3008 	ldr	r3, [fp, #-8]
   196b8:	ebfffede 	bl	19238 <std>
     requires both stdin and stdout to be line-buffered, but tradition
     leaves stdin alone on systems without fcntl.  */
#ifdef HAVE_FCNTL
  std (s->_stdout, __SWR, 1, s);
#else
  std (s->_stdout, __SWR | __SLBF, 1, s);
   196bc:	e51b3008 	ldr	r3, [fp, #-8]
   196c0:	e5933008 	ldr	r3, [r3, #8]
   196c4:	e1a00003 	mov	r0, r3
   196c8:	e3a01009 	mov	r1, #9
   196cc:	e3a02001 	mov	r2, #1
   196d0:	e51b3008 	ldr	r3, [fp, #-8]
   196d4:	ebfffed7 	bl	19238 <std>
#endif

  /* POSIX requires stderr to be opened for reading and writing, even
     when the underlying fd 2 is write-only.  */
  std (s->_stderr, __SRW | __SNBF, 2, s);
   196d8:	e51b3008 	ldr	r3, [fp, #-8]
   196dc:	e593300c 	ldr	r3, [r3, #12]
   196e0:	e1a00003 	mov	r0, r3
   196e4:	e3a01012 	mov	r1, #18
   196e8:	e3a02002 	mov	r2, #2
   196ec:	e51b3008 	ldr	r3, [fp, #-8]
   196f0:	ebfffed0 	bl	19238 <std>

  s->__sdidinit = 1;
   196f4:	e51b3008 	ldr	r3, [fp, #-8]
   196f8:	e3a02001 	mov	r2, #1
   196fc:	e5832038 	str	r2, [r3, #56]	; 0x38

  __sinit_lock_release ();
   19700:	eb00001b 	bl	19774 <__sinit_lock_release>
}
   19704:	e24bd004 	sub	sp, fp, #4
   19708:	e8bd4800 	pop	{fp, lr}
   1970c:	e12fff1e 	bx	lr
   19710:	000195ec 	.word	0x000195ec

00019714 <__sfp_lock_acquire>:
__LOCK_INIT_RECURSIVE(static, __sfp_lock);
__LOCK_INIT_RECURSIVE(static, __sinit_lock);

_VOID
_DEFUN_VOID(__sfp_lock_acquire)
{
   19714:	e92d4800 	push	{fp, lr}
   19718:	e28db004 	add	fp, sp, #4
  __lock_acquire_recursive (__sfp_lock);
   1971c:	e59f000c 	ldr	r0, [pc, #12]	; 19730 <__sfp_lock_acquire+0x1c>
   19720:	ebffd4b6 	bl	ea00 <_dna_lock_acquire>
}
   19724:	e24bd004 	sub	sp, fp, #4
   19728:	e8bd4800 	pop	{fp, lr}
   1972c:	e12fff1e 	bx	lr
   19730:	00024ff0 	.word	0x00024ff0

00019734 <__sfp_lock_release>:

_VOID
_DEFUN_VOID(__sfp_lock_release)
{
   19734:	e92d4800 	push	{fp, lr}
   19738:	e28db004 	add	fp, sp, #4
  __lock_release_recursive (__sfp_lock);
   1973c:	e59f000c 	ldr	r0, [pc, #12]	; 19750 <__sfp_lock_release+0x1c>
   19740:	ebffd515 	bl	eb9c <_dna_lock_release>
}
   19744:	e24bd004 	sub	sp, fp, #4
   19748:	e8bd4800 	pop	{fp, lr}
   1974c:	e12fff1e 	bx	lr
   19750:	00024ff0 	.word	0x00024ff0

00019754 <__sinit_lock_acquire>:

_VOID
_DEFUN_VOID(__sinit_lock_acquire)
{
   19754:	e92d4800 	push	{fp, lr}
   19758:	e28db004 	add	fp, sp, #4
  __lock_acquire_recursive (__sinit_lock);
   1975c:	e59f000c 	ldr	r0, [pc, #12]	; 19770 <__sinit_lock_acquire+0x1c>
   19760:	ebffd4a6 	bl	ea00 <_dna_lock_acquire>
}
   19764:	e24bd004 	sub	sp, fp, #4
   19768:	e8bd4800 	pop	{fp, lr}
   1976c:	e12fff1e 	bx	lr
   19770:	00024ff8 	.word	0x00024ff8

00019774 <__sinit_lock_release>:

_VOID
_DEFUN_VOID(__sinit_lock_release)
{
   19774:	e92d4800 	push	{fp, lr}
   19778:	e28db004 	add	fp, sp, #4
  __lock_release_recursive (__sinit_lock);
   1977c:	e59f000c 	ldr	r0, [pc, #12]	; 19790 <__sinit_lock_release+0x1c>
   19780:	ebffd505 	bl	eb9c <_dna_lock_release>
}
   19784:	e24bd004 	sub	sp, fp, #4
   19788:	e8bd4800 	pop	{fp, lr}
   1978c:	e12fff1e 	bx	lr
   19790:	00024ff8 	.word	0x00024ff8

00019794 <__fp_lock>:

/* Walkable file locking routine.  */
static int
_DEFUN(__fp_lock, (ptr),
       FILE * ptr)
{
   19794:	e92d4800 	push	{fp, lr}
   19798:	e28db004 	add	fp, sp, #4
   1979c:	e24dd008 	sub	sp, sp, #8
   197a0:	e50b0008 	str	r0, [fp, #-8]
  _flockfile (ptr);
   197a4:	e51b3008 	ldr	r3, [fp, #-8]
   197a8:	e1d330bc 	ldrh	r3, [r3, #12]
   197ac:	e1a03803 	lsl	r3, r3, #16
   197b0:	e1a03823 	lsr	r3, r3, #16
   197b4:	e2033c02 	and	r3, r3, #512	; 0x200
   197b8:	e3530000 	cmp	r3, #0
   197bc:	1a000003 	bne	197d0 <__fp_lock+0x3c>
   197c0:	e51b3008 	ldr	r3, [fp, #-8]
   197c4:	e283305c 	add	r3, r3, #92	; 0x5c
   197c8:	e1a00003 	mov	r0, r3
   197cc:	ebffd48b 	bl	ea00 <_dna_lock_acquire>

  return 0;
   197d0:	e3a03000 	mov	r3, #0
}
   197d4:	e1a00003 	mov	r0, r3
   197d8:	e24bd004 	sub	sp, fp, #4
   197dc:	e8bd4800 	pop	{fp, lr}
   197e0:	e12fff1e 	bx	lr

000197e4 <__fp_unlock>:

/* Walkable file unlocking routine.  */
static int
_DEFUN(__fp_unlock, (ptr),
       FILE * ptr)
{
   197e4:	e92d4800 	push	{fp, lr}
   197e8:	e28db004 	add	fp, sp, #4
   197ec:	e24dd008 	sub	sp, sp, #8
   197f0:	e50b0008 	str	r0, [fp, #-8]
  _funlockfile (ptr);
   197f4:	e51b3008 	ldr	r3, [fp, #-8]
   197f8:	e1d330bc 	ldrh	r3, [r3, #12]
   197fc:	e1a03803 	lsl	r3, r3, #16
   19800:	e1a03823 	lsr	r3, r3, #16
   19804:	e2033c02 	and	r3, r3, #512	; 0x200
   19808:	e3530000 	cmp	r3, #0
   1980c:	1a000003 	bne	19820 <__fp_unlock+0x3c>
   19810:	e51b3008 	ldr	r3, [fp, #-8]
   19814:	e283305c 	add	r3, r3, #92	; 0x5c
   19818:	e1a00003 	mov	r0, r3
   1981c:	ebffd4de 	bl	eb9c <_dna_lock_release>

  return 0;
   19820:	e3a03000 	mov	r3, #0
}
   19824:	e1a00003 	mov	r0, r3
   19828:	e24bd004 	sub	sp, fp, #4
   1982c:	e8bd4800 	pop	{fp, lr}
   19830:	e12fff1e 	bx	lr

00019834 <__fp_lock_all>:

_VOID
_DEFUN_VOID(__fp_lock_all)
{
   19834:	e92d4800 	push	{fp, lr}
   19838:	e28db004 	add	fp, sp, #4
  __sfp_lock_acquire ();
   1983c:	ebffffb4 	bl	19714 <__sfp_lock_acquire>

  _CAST_VOID _fwalk (_REENT, __fp_lock);
   19840:	e59f3018 	ldr	r3, [pc, #24]	; 19860 <__fp_lock_all+0x2c>
   19844:	e5933000 	ldr	r3, [r3]
   19848:	e1a00003 	mov	r0, r3
   1984c:	e59f1010 	ldr	r1, [pc, #16]	; 19864 <__fp_lock_all+0x30>
   19850:	eb000377 	bl	1a634 <_fwalk>
}
   19854:	e24bd004 	sub	sp, fp, #4
   19858:	e8bd4800 	pop	{fp, lr}
   1985c:	e12fff1e 	bx	lr
   19860:	00025440 	.word	0x00025440
   19864:	00019794 	.word	0x00019794

00019868 <__fp_unlock_all>:

_VOID
_DEFUN_VOID(__fp_unlock_all)
{
   19868:	e92d4800 	push	{fp, lr}
   1986c:	e28db004 	add	fp, sp, #4
  _CAST_VOID _fwalk (_REENT, __fp_unlock);
   19870:	e59f301c 	ldr	r3, [pc, #28]	; 19894 <__fp_unlock_all+0x2c>
   19874:	e5933000 	ldr	r3, [r3]
   19878:	e1a00003 	mov	r0, r3
   1987c:	e59f1014 	ldr	r1, [pc, #20]	; 19898 <__fp_unlock_all+0x30>
   19880:	eb00036b 	bl	1a634 <_fwalk>

  __sfp_lock_release ();
   19884:	ebffffaa 	bl	19734 <__sfp_lock_release>
}
   19888:	e24bd004 	sub	sp, fp, #4
   1988c:	e8bd4800 	pop	{fp, lr}
   19890:	e12fff1e 	bx	lr
   19894:	00025440 	.word	0x00025440
   19898:	000197e4 	.word	0x000197e4

0001989c <_free_r>:
#if __STD_C
void fREe(RARG Void_t* mem)
#else
void fREe(RARG mem) RDECL Void_t* mem;
#endif
{
   1989c:	e92d4800 	push	{fp, lr}
   198a0:	e28db004 	add	fp, sp, #4
   198a4:	e24dd030 	sub	sp, sp, #48	; 0x30
   198a8:	e50b0030 	str	r0, [fp, #-48]	; 0x30
   198ac:	e50b1034 	str	r1, [fp, #-52]	; 0x34
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
   198b0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   198b4:	e3530000 	cmp	r3, #0
   198b8:	1a000000 	bne	198c0 <_free_r+0x24>
    return;
   198bc:	ea000146 	b	19ddc <_free_r+0x540>

  MALLOC_LOCK;
   198c0:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   198c4:	ebffd981 	bl	fed0 <__malloc_lock>

  p = mem2chunk(mem);
   198c8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   198cc:	e2433008 	sub	r3, r3, #8
   198d0:	e50b3008 	str	r3, [fp, #-8]
  hd = p->size;
   198d4:	e51b3008 	ldr	r3, [fp, #-8]
   198d8:	e5933004 	ldr	r3, [r3, #4]
   198dc:	e50b301c 	str	r3, [fp, #-28]
  }
#endif
  
  check_inuse_chunk(p);
  
  sz = hd & ~PREV_INUSE;
   198e0:	e51b301c 	ldr	r3, [fp, #-28]
   198e4:	e3c33001 	bic	r3, r3, #1
   198e8:	e50b300c 	str	r3, [fp, #-12]
  next = chunk_at_offset(p, sz);
   198ec:	e51b2008 	ldr	r2, [fp, #-8]
   198f0:	e51b300c 	ldr	r3, [fp, #-12]
   198f4:	e0823003 	add	r3, r2, r3
   198f8:	e50b3020 	str	r3, [fp, #-32]
  nextsz = chunksize(next);
   198fc:	e51b3020 	ldr	r3, [fp, #-32]
   19900:	e5933004 	ldr	r3, [r3, #4]
   19904:	e3c33003 	bic	r3, r3, #3
   19908:	e50b3024 	str	r3, [fp, #-36]	; 0x24
  
  if (next == top)                            /* merge with top */
   1990c:	e59f34d4 	ldr	r3, [pc, #1236]	; 19de8 <_free_r+0x54c>
   19910:	e5932008 	ldr	r2, [r3, #8]
   19914:	e51b3020 	ldr	r3, [fp, #-32]
   19918:	e1520003 	cmp	r2, r3
   1991c:	1a000033 	bne	199f0 <_free_r+0x154>
  {
    sz += nextsz;
   19920:	e51b200c 	ldr	r2, [fp, #-12]
   19924:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   19928:	e0823003 	add	r3, r2, r3
   1992c:	e50b300c 	str	r3, [fp, #-12]

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
   19930:	e51b301c 	ldr	r3, [fp, #-28]
   19934:	e2033001 	and	r3, r3, #1
   19938:	e3530000 	cmp	r3, #0
   1993c:	1a000017 	bne	199a0 <_free_r+0x104>
    {
      prevsz = p->prev_size;
   19940:	e51b3008 	ldr	r3, [fp, #-8]
   19944:	e5933000 	ldr	r3, [r3]
   19948:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      p = chunk_at_offset(p, -prevsz);
   1994c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   19950:	e2633000 	rsb	r3, r3, #0
   19954:	e51b2008 	ldr	r2, [fp, #-8]
   19958:	e0823003 	add	r3, r2, r3
   1995c:	e50b3008 	str	r3, [fp, #-8]
      sz += prevsz;
   19960:	e51b200c 	ldr	r2, [fp, #-12]
   19964:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   19968:	e0823003 	add	r3, r2, r3
   1996c:	e50b300c 	str	r3, [fp, #-12]
      unlink(p, bck, fwd);
   19970:	e51b3008 	ldr	r3, [fp, #-8]
   19974:	e593300c 	ldr	r3, [r3, #12]
   19978:	e50b3010 	str	r3, [fp, #-16]
   1997c:	e51b3008 	ldr	r3, [fp, #-8]
   19980:	e5933008 	ldr	r3, [r3, #8]
   19984:	e50b3014 	str	r3, [fp, #-20]
   19988:	e51b3014 	ldr	r3, [fp, #-20]
   1998c:	e51b2010 	ldr	r2, [fp, #-16]
   19990:	e583200c 	str	r2, [r3, #12]
   19994:	e51b3010 	ldr	r3, [fp, #-16]
   19998:	e51b2014 	ldr	r2, [fp, #-20]
   1999c:	e5832008 	str	r2, [r3, #8]
    }

    set_head(p, sz | PREV_INUSE);
   199a0:	e51b300c 	ldr	r3, [fp, #-12]
   199a4:	e3832001 	orr	r2, r3, #1
   199a8:	e51b3008 	ldr	r3, [fp, #-8]
   199ac:	e5832004 	str	r2, [r3, #4]
    top = p;
   199b0:	e59f3430 	ldr	r3, [pc, #1072]	; 19de8 <_free_r+0x54c>
   199b4:	e51b2008 	ldr	r2, [fp, #-8]
   199b8:	e5832008 	str	r2, [r3, #8]
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold) 
   199bc:	e59f3428 	ldr	r3, [pc, #1064]	; 19dec <_free_r+0x550>
   199c0:	e5933000 	ldr	r3, [r3]
   199c4:	e51b200c 	ldr	r2, [fp, #-12]
   199c8:	e1520003 	cmp	r2, r3
   199cc:	3a000004 	bcc	199e4 <_free_r+0x148>
      malloc_trim(RCALL top_pad); 
   199d0:	e59f3418 	ldr	r3, [pc, #1048]	; 19df0 <_free_r+0x554>
   199d4:	e5933000 	ldr	r3, [r3]
   199d8:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   199dc:	e1a01003 	mov	r1, r3
   199e0:	eb000105 	bl	19dfc <_malloc_trim_r>
    MALLOC_UNLOCK;
   199e4:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   199e8:	ebffd942 	bl	fef8 <__malloc_unlock>
    return;
   199ec:	ea0000fa 	b	19ddc <_free_r+0x540>
  }

  set_head(next, nextsz);                    /* clear inuse bit */
   199f0:	e51b3020 	ldr	r3, [fp, #-32]
   199f4:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   199f8:	e5832004 	str	r2, [r3, #4]

  islr = 0;
   199fc:	e3a03000 	mov	r3, #0
   19a00:	e50b3018 	str	r3, [fp, #-24]

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
   19a04:	e51b301c 	ldr	r3, [fp, #-28]
   19a08:	e2033001 	and	r3, r3, #1
   19a0c:	e3530000 	cmp	r3, #0
   19a10:	1a00001f 	bne	19a94 <_free_r+0x1f8>
  {
    prevsz = p->prev_size;
   19a14:	e51b3008 	ldr	r3, [fp, #-8]
   19a18:	e5933000 	ldr	r3, [r3]
   19a1c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
    p = chunk_at_offset(p, -prevsz);
   19a20:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   19a24:	e2633000 	rsb	r3, r3, #0
   19a28:	e51b2008 	ldr	r2, [fp, #-8]
   19a2c:	e0823003 	add	r3, r2, r3
   19a30:	e50b3008 	str	r3, [fp, #-8]
    sz += prevsz;
   19a34:	e51b200c 	ldr	r2, [fp, #-12]
   19a38:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   19a3c:	e0823003 	add	r3, r2, r3
   19a40:	e50b300c 	str	r3, [fp, #-12]
    
    if (p->fd == last_remainder)             /* keep as last_remainder */
   19a44:	e51b3008 	ldr	r3, [fp, #-8]
   19a48:	e5932008 	ldr	r2, [r3, #8]
   19a4c:	e59f33a0 	ldr	r3, [pc, #928]	; 19df4 <_free_r+0x558>
   19a50:	e1520003 	cmp	r2, r3
   19a54:	1a000002 	bne	19a64 <_free_r+0x1c8>
      islr = 1;
   19a58:	e3a03001 	mov	r3, #1
   19a5c:	e50b3018 	str	r3, [fp, #-24]
   19a60:	ea00000b 	b	19a94 <_free_r+0x1f8>
    else
      unlink(p, bck, fwd);
   19a64:	e51b3008 	ldr	r3, [fp, #-8]
   19a68:	e593300c 	ldr	r3, [r3, #12]
   19a6c:	e50b3010 	str	r3, [fp, #-16]
   19a70:	e51b3008 	ldr	r3, [fp, #-8]
   19a74:	e5933008 	ldr	r3, [r3, #8]
   19a78:	e50b3014 	str	r3, [fp, #-20]
   19a7c:	e51b3014 	ldr	r3, [fp, #-20]
   19a80:	e51b2010 	ldr	r2, [fp, #-16]
   19a84:	e583200c 	str	r2, [r3, #12]
   19a88:	e51b3010 	ldr	r3, [fp, #-16]
   19a8c:	e51b2014 	ldr	r2, [fp, #-20]
   19a90:	e5832008 	str	r2, [r3, #8]
  }
  
  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
   19a94:	e51b2020 	ldr	r2, [fp, #-32]
   19a98:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   19a9c:	e0823003 	add	r3, r2, r3
   19aa0:	e5933004 	ldr	r3, [r3, #4]
   19aa4:	e2033001 	and	r3, r3, #1
   19aa8:	e3530000 	cmp	r3, #0
   19aac:	1a000027 	bne	19b50 <_free_r+0x2b4>
  {
    sz += nextsz;
   19ab0:	e51b200c 	ldr	r2, [fp, #-12]
   19ab4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   19ab8:	e0823003 	add	r3, r2, r3
   19abc:	e50b300c 	str	r3, [fp, #-12]
    
    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
   19ac0:	e51b3018 	ldr	r3, [fp, #-24]
   19ac4:	e3530000 	cmp	r3, #0
   19ac8:	1a000014 	bne	19b20 <_free_r+0x284>
   19acc:	e51b3020 	ldr	r3, [fp, #-32]
   19ad0:	e5932008 	ldr	r2, [r3, #8]
   19ad4:	e59f3318 	ldr	r3, [pc, #792]	; 19df4 <_free_r+0x558>
   19ad8:	e1520003 	cmp	r2, r3
   19adc:	1a00000f 	bne	19b20 <_free_r+0x284>
    {
      islr = 1;
   19ae0:	e3a03001 	mov	r3, #1
   19ae4:	e50b3018 	str	r3, [fp, #-24]
      link_last_remainder(p);   
   19ae8:	e59f2304 	ldr	r2, [pc, #772]	; 19df4 <_free_r+0x558>
   19aec:	e59f3300 	ldr	r3, [pc, #768]	; 19df4 <_free_r+0x558>
   19af0:	e51b1008 	ldr	r1, [fp, #-8]
   19af4:	e583100c 	str	r1, [r3, #12]
   19af8:	e593300c 	ldr	r3, [r3, #12]
   19afc:	e5823008 	str	r3, [r2, #8]
   19b00:	e51b3008 	ldr	r3, [fp, #-8]
   19b04:	e59f22e8 	ldr	r2, [pc, #744]	; 19df4 <_free_r+0x558>
   19b08:	e583200c 	str	r2, [r3, #12]
   19b0c:	e51b3008 	ldr	r3, [fp, #-8]
   19b10:	e593200c 	ldr	r2, [r3, #12]
   19b14:	e51b3008 	ldr	r3, [fp, #-8]
   19b18:	e5832008 	str	r2, [r3, #8]
   19b1c:	ea00000b 	b	19b50 <_free_r+0x2b4>
    }
    else
      unlink(next, bck, fwd);
   19b20:	e51b3020 	ldr	r3, [fp, #-32]
   19b24:	e593300c 	ldr	r3, [r3, #12]
   19b28:	e50b3010 	str	r3, [fp, #-16]
   19b2c:	e51b3020 	ldr	r3, [fp, #-32]
   19b30:	e5933008 	ldr	r3, [r3, #8]
   19b34:	e50b3014 	str	r3, [fp, #-20]
   19b38:	e51b3014 	ldr	r3, [fp, #-20]
   19b3c:	e51b2010 	ldr	r2, [fp, #-16]
   19b40:	e583200c 	str	r2, [r3, #12]
   19b44:	e51b3010 	ldr	r3, [fp, #-16]
   19b48:	e51b2014 	ldr	r2, [fp, #-20]
   19b4c:	e5832008 	str	r2, [r3, #8]
  }


  set_head(p, sz | PREV_INUSE);
   19b50:	e51b300c 	ldr	r3, [fp, #-12]
   19b54:	e3832001 	orr	r2, r3, #1
   19b58:	e51b3008 	ldr	r3, [fp, #-8]
   19b5c:	e5832004 	str	r2, [r3, #4]
  set_foot(p, sz);
   19b60:	e51b2008 	ldr	r2, [fp, #-8]
   19b64:	e51b300c 	ldr	r3, [fp, #-12]
   19b68:	e0823003 	add	r3, r2, r3
   19b6c:	e51b200c 	ldr	r2, [fp, #-12]
   19b70:	e5832000 	str	r2, [r3]
  if (!islr)
   19b74:	e51b3018 	ldr	r3, [fp, #-24]
   19b78:	e3530000 	cmp	r3, #0
   19b7c:	1a000094 	bne	19dd4 <_free_r+0x538>
    frontlink(p, sz, idx, bck, fwd);  
   19b80:	e51b300c 	ldr	r3, [fp, #-12]
   19b84:	e3530c02 	cmp	r3, #512	; 0x200
   19b88:	2a000026 	bcs	19c28 <_free_r+0x38c>
   19b8c:	e51b300c 	ldr	r3, [fp, #-12]
   19b90:	e1a031a3 	lsr	r3, r3, #3
   19b94:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   19b98:	e59f2248 	ldr	r2, [pc, #584]	; 19de8 <_free_r+0x54c>
   19b9c:	e59f3244 	ldr	r3, [pc, #580]	; 19de8 <_free_r+0x54c>
   19ba0:	e5931004 	ldr	r1, [r3, #4]
   19ba4:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   19ba8:	e2830003 	add	r0, r3, #3
   19bac:	e3530000 	cmp	r3, #0
   19bb0:	b1a03000 	movlt	r3, r0
   19bb4:	a1a03003 	movge	r3, r3
   19bb8:	e1a03143 	asr	r3, r3, #2
   19bbc:	e3a00001 	mov	r0, #1
   19bc0:	e1a03310 	lsl	r3, r0, r3
   19bc4:	e1813003 	orr	r3, r1, r3
   19bc8:	e5823004 	str	r3, [r2, #4]
   19bcc:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   19bd0:	e1a03083 	lsl	r3, r3, #1
   19bd4:	e1a02103 	lsl	r2, r3, #2
   19bd8:	e59f3208 	ldr	r3, [pc, #520]	; 19de8 <_free_r+0x54c>
   19bdc:	e0823003 	add	r3, r2, r3
   19be0:	e50b3010 	str	r3, [fp, #-16]
   19be4:	e51b3010 	ldr	r3, [fp, #-16]
   19be8:	e5933008 	ldr	r3, [r3, #8]
   19bec:	e50b3014 	str	r3, [fp, #-20]
   19bf0:	e51b3008 	ldr	r3, [fp, #-8]
   19bf4:	e51b2010 	ldr	r2, [fp, #-16]
   19bf8:	e583200c 	str	r2, [r3, #12]
   19bfc:	e51b3008 	ldr	r3, [fp, #-8]
   19c00:	e51b2014 	ldr	r2, [fp, #-20]
   19c04:	e5832008 	str	r2, [r3, #8]
   19c08:	e51b3010 	ldr	r3, [fp, #-16]
   19c0c:	e51b2008 	ldr	r2, [fp, #-8]
   19c10:	e5832008 	str	r2, [r3, #8]
   19c14:	e51b3010 	ldr	r3, [fp, #-16]
   19c18:	e5932008 	ldr	r2, [r3, #8]
   19c1c:	e51b3014 	ldr	r3, [fp, #-20]
   19c20:	e583200c 	str	r2, [r3, #12]
   19c24:	ea00006a 	b	19dd4 <_free_r+0x538>
   19c28:	e51b300c 	ldr	r3, [fp, #-12]
   19c2c:	e1a034a3 	lsr	r3, r3, #9
   19c30:	e3530000 	cmp	r3, #0
   19c34:	1a000002 	bne	19c44 <_free_r+0x3a8>
   19c38:	e51b300c 	ldr	r3, [fp, #-12]
   19c3c:	e1a031a3 	lsr	r3, r3, #3
   19c40:	ea000029 	b	19cec <_free_r+0x450>
   19c44:	e51b300c 	ldr	r3, [fp, #-12]
   19c48:	e1a034a3 	lsr	r3, r3, #9
   19c4c:	e3530004 	cmp	r3, #4
   19c50:	8a000003 	bhi	19c64 <_free_r+0x3c8>
   19c54:	e51b300c 	ldr	r3, [fp, #-12]
   19c58:	e1a03323 	lsr	r3, r3, #6
   19c5c:	e2833038 	add	r3, r3, #56	; 0x38
   19c60:	ea000021 	b	19cec <_free_r+0x450>
   19c64:	e51b300c 	ldr	r3, [fp, #-12]
   19c68:	e1a034a3 	lsr	r3, r3, #9
   19c6c:	e3530014 	cmp	r3, #20
   19c70:	8a000003 	bhi	19c84 <_free_r+0x3e8>
   19c74:	e51b300c 	ldr	r3, [fp, #-12]
   19c78:	e1a034a3 	lsr	r3, r3, #9
   19c7c:	e283305b 	add	r3, r3, #91	; 0x5b
   19c80:	ea000019 	b	19cec <_free_r+0x450>
   19c84:	e51b300c 	ldr	r3, [fp, #-12]
   19c88:	e1a034a3 	lsr	r3, r3, #9
   19c8c:	e3530054 	cmp	r3, #84	; 0x54
   19c90:	8a000003 	bhi	19ca4 <_free_r+0x408>
   19c94:	e51b300c 	ldr	r3, [fp, #-12]
   19c98:	e1a03623 	lsr	r3, r3, #12
   19c9c:	e283306e 	add	r3, r3, #110	; 0x6e
   19ca0:	ea000011 	b	19cec <_free_r+0x450>
   19ca4:	e51b300c 	ldr	r3, [fp, #-12]
   19ca8:	e1a034a3 	lsr	r3, r3, #9
   19cac:	e3530f55 	cmp	r3, #340	; 0x154
   19cb0:	8a000003 	bhi	19cc4 <_free_r+0x428>
   19cb4:	e51b300c 	ldr	r3, [fp, #-12]
   19cb8:	e1a037a3 	lsr	r3, r3, #15
   19cbc:	e2833077 	add	r3, r3, #119	; 0x77
   19cc0:	ea000009 	b	19cec <_free_r+0x450>
   19cc4:	e51b300c 	ldr	r3, [fp, #-12]
   19cc8:	e1a024a3 	lsr	r2, r3, #9
   19ccc:	e59f3124 	ldr	r3, [pc, #292]	; 19df8 <_free_r+0x55c>
   19cd0:	e1520003 	cmp	r2, r3
   19cd4:	8a000003 	bhi	19ce8 <_free_r+0x44c>
   19cd8:	e51b300c 	ldr	r3, [fp, #-12]
   19cdc:	e1a03923 	lsr	r3, r3, #18
   19ce0:	e283307c 	add	r3, r3, #124	; 0x7c
   19ce4:	ea000000 	b	19cec <_free_r+0x450>
   19ce8:	e3a0307e 	mov	r3, #126	; 0x7e
   19cec:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   19cf0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   19cf4:	e1a03083 	lsl	r3, r3, #1
   19cf8:	e1a02103 	lsl	r2, r3, #2
   19cfc:	e59f30e4 	ldr	r3, [pc, #228]	; 19de8 <_free_r+0x54c>
   19d00:	e0823003 	add	r3, r2, r3
   19d04:	e50b3010 	str	r3, [fp, #-16]
   19d08:	e51b3010 	ldr	r3, [fp, #-16]
   19d0c:	e5933008 	ldr	r3, [r3, #8]
   19d10:	e50b3014 	str	r3, [fp, #-20]
   19d14:	e51b2014 	ldr	r2, [fp, #-20]
   19d18:	e51b3010 	ldr	r3, [fp, #-16]
   19d1c:	e1520003 	cmp	r2, r3
   19d20:	1a00000d 	bne	19d5c <_free_r+0x4c0>
   19d24:	e59f20bc 	ldr	r2, [pc, #188]	; 19de8 <_free_r+0x54c>
   19d28:	e59f30b8 	ldr	r3, [pc, #184]	; 19de8 <_free_r+0x54c>
   19d2c:	e5931004 	ldr	r1, [r3, #4]
   19d30:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   19d34:	e2830003 	add	r0, r3, #3
   19d38:	e3530000 	cmp	r3, #0
   19d3c:	b1a03000 	movlt	r3, r0
   19d40:	a1a03003 	movge	r3, r3
   19d44:	e1a03143 	asr	r3, r3, #2
   19d48:	e3a00001 	mov	r0, #1
   19d4c:	e1a03310 	lsl	r3, r0, r3
   19d50:	e1813003 	orr	r3, r1, r3
   19d54:	e5823004 	str	r3, [r2, #4]
   19d58:	ea000010 	b	19da0 <_free_r+0x504>
   19d5c:	ea000002 	b	19d6c <_free_r+0x4d0>
   19d60:	e51b3014 	ldr	r3, [fp, #-20]
   19d64:	e5933008 	ldr	r3, [r3, #8]
   19d68:	e50b3014 	str	r3, [fp, #-20]
   19d6c:	e51b2014 	ldr	r2, [fp, #-20]
   19d70:	e51b3010 	ldr	r3, [fp, #-16]
   19d74:	e1520003 	cmp	r2, r3
   19d78:	0a000005 	beq	19d94 <_free_r+0x4f8>
   19d7c:	e51b3014 	ldr	r3, [fp, #-20]
   19d80:	e5933004 	ldr	r3, [r3, #4]
   19d84:	e3c32003 	bic	r2, r3, #3
   19d88:	e51b300c 	ldr	r3, [fp, #-12]
   19d8c:	e1520003 	cmp	r2, r3
   19d90:	8afffff2 	bhi	19d60 <_free_r+0x4c4>
   19d94:	e51b3014 	ldr	r3, [fp, #-20]
   19d98:	e593300c 	ldr	r3, [r3, #12]
   19d9c:	e50b3010 	str	r3, [fp, #-16]
   19da0:	e51b3008 	ldr	r3, [fp, #-8]
   19da4:	e51b2010 	ldr	r2, [fp, #-16]
   19da8:	e583200c 	str	r2, [r3, #12]
   19dac:	e51b3008 	ldr	r3, [fp, #-8]
   19db0:	e51b2014 	ldr	r2, [fp, #-20]
   19db4:	e5832008 	str	r2, [r3, #8]
   19db8:	e51b3010 	ldr	r3, [fp, #-16]
   19dbc:	e51b2008 	ldr	r2, [fp, #-8]
   19dc0:	e5832008 	str	r2, [r3, #8]
   19dc4:	e51b3010 	ldr	r3, [fp, #-16]
   19dc8:	e5932008 	ldr	r2, [r3, #8]
   19dcc:	e51b3014 	ldr	r3, [fp, #-20]
   19dd0:	e583200c 	str	r2, [r3, #12]

  MALLOC_UNLOCK;
   19dd4:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   19dd8:	ebffd846 	bl	fef8 <__malloc_unlock>

#endif /* MALLOC_PROVIDED */
}
   19ddc:	e24bd004 	sub	sp, fp, #4
   19de0:	e8bd4800 	pop	{fp, lr}
   19de4:	e12fff1e 	bx	lr
   19de8:	00024bd8 	.word	0x00024bd8
   19dec:	00024fe0 	.word	0x00024fe0
   19df0:	0003558c 	.word	0x0003558c
   19df4:	00024be0 	.word	0x00024be0
   19df8:	00000554 	.word	0x00000554

00019dfc <_malloc_trim_r>:
#if __STD_C
int malloc_trim(RARG size_t pad)
#else
int malloc_trim(RARG pad) RDECL size_t pad;
#endif
{
   19dfc:	e92d4800 	push	{fp, lr}
   19e00:	e28db004 	add	fp, sp, #4
   19e04:	e24dd020 	sub	sp, sp, #32
   19e08:	e50b0020 	str	r0, [fp, #-32]
   19e0c:	e50b1024 	str	r1, [fp, #-36]	; 0x24
  long  top_size;        /* Amount of top-most memory */
  long  extra;           /* Amount to release */
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;
   19e10:	e3a03a01 	mov	r3, #4096	; 0x1000
   19e14:	e50b3008 	str	r3, [fp, #-8]

  MALLOC_LOCK;
   19e18:	e51b0020 	ldr	r0, [fp, #-32]
   19e1c:	ebffd82b 	bl	fed0 <__malloc_lock>

  top_size = chunksize(top);
   19e20:	e59f3180 	ldr	r3, [pc, #384]	; 19fa8 <_malloc_trim_r+0x1ac>
   19e24:	e5933008 	ldr	r3, [r3, #8]
   19e28:	e5933004 	ldr	r3, [r3, #4]
   19e2c:	e3c33003 	bic	r3, r3, #3
   19e30:	e50b300c 	str	r3, [fp, #-12]
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
   19e34:	e51b200c 	ldr	r2, [fp, #-12]
   19e38:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   19e3c:	e0632002 	rsb	r2, r3, r2
   19e40:	e51b3008 	ldr	r3, [fp, #-8]
   19e44:	e0823003 	add	r3, r2, r3
   19e48:	e2433011 	sub	r3, r3, #17
   19e4c:	e1a00003 	mov	r0, r3
   19e50:	e51b1008 	ldr	r1, [fp, #-8]
   19e54:	ebffcf23 	bl	dae8 <__aeabi_uidiv>
   19e58:	e1a03000 	mov	r3, r0
   19e5c:	e2433001 	sub	r3, r3, #1
   19e60:	e51b2008 	ldr	r2, [fp, #-8]
   19e64:	e0030392 	mul	r3, r2, r3
   19e68:	e50b3010 	str	r3, [fp, #-16]

  if (extra < (long)pagesz)  /* Not enough memory to release */
   19e6c:	e51b2008 	ldr	r2, [fp, #-8]
   19e70:	e51b3010 	ldr	r3, [fp, #-16]
   19e74:	e1520003 	cmp	r2, r3
   19e78:	da000003 	ble	19e8c <_malloc_trim_r+0x90>
  {
    MALLOC_UNLOCK;
   19e7c:	e51b0020 	ldr	r0, [fp, #-32]
   19e80:	ebffd81c 	bl	fef8 <__malloc_unlock>
    return 0;
   19e84:	e3a03000 	mov	r3, #0
   19e88:	ea000042 	b	19f98 <_malloc_trim_r+0x19c>
  }

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
   19e8c:	e51b0020 	ldr	r0, [fp, #-32]
   19e90:	e3a01000 	mov	r1, #0
   19e94:	ebffd8f0 	bl	1025c <_sbrk_r>
   19e98:	e50b0014 	str	r0, [fp, #-20]
    if (current_brk != (char*)(top) + top_size)
   19e9c:	e59f3104 	ldr	r3, [pc, #260]	; 19fa8 <_malloc_trim_r+0x1ac>
   19ea0:	e5932008 	ldr	r2, [r3, #8]
   19ea4:	e51b300c 	ldr	r3, [fp, #-12]
   19ea8:	e0822003 	add	r2, r2, r3
   19eac:	e51b3014 	ldr	r3, [fp, #-20]
   19eb0:	e1520003 	cmp	r2, r3
   19eb4:	0a000003 	beq	19ec8 <_malloc_trim_r+0xcc>
    {
      MALLOC_UNLOCK;
   19eb8:	e51b0020 	ldr	r0, [fp, #-32]
   19ebc:	ebffd80d 	bl	fef8 <__malloc_unlock>
      return 0;     /* Apparently we don't own memory; must fail */
   19ec0:	e3a03000 	mov	r3, #0
   19ec4:	ea000033 	b	19f98 <_malloc_trim_r+0x19c>
    }

    else
    {
      new_brk = (char*)(MORECORE (-extra));
   19ec8:	e51b3010 	ldr	r3, [fp, #-16]
   19ecc:	e2633000 	rsb	r3, r3, #0
   19ed0:	e51b0020 	ldr	r0, [fp, #-32]
   19ed4:	e1a01003 	mov	r1, r3
   19ed8:	ebffd8df 	bl	1025c <_sbrk_r>
   19edc:	e50b0018 	str	r0, [fp, #-24]
      
      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
   19ee0:	e51b3018 	ldr	r3, [fp, #-24]
   19ee4:	e3730001 	cmn	r3, #1
   19ee8:	1a00001a 	bne	19f58 <_malloc_trim_r+0x15c>
      {
        /* Try to figure out what we have */
        current_brk = (char*)(MORECORE (0));
   19eec:	e51b0020 	ldr	r0, [fp, #-32]
   19ef0:	e3a01000 	mov	r1, #0
   19ef4:	ebffd8d8 	bl	1025c <_sbrk_r>
   19ef8:	e50b0014 	str	r0, [fp, #-20]
        top_size = current_brk - (char*)top;
   19efc:	e51b2014 	ldr	r2, [fp, #-20]
   19f00:	e59f30a0 	ldr	r3, [pc, #160]	; 19fa8 <_malloc_trim_r+0x1ac>
   19f04:	e5933008 	ldr	r3, [r3, #8]
   19f08:	e0633002 	rsb	r3, r3, r2
   19f0c:	e50b300c 	str	r3, [fp, #-12]
        if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
   19f10:	e51b300c 	ldr	r3, [fp, #-12]
   19f14:	e353000f 	cmp	r3, #15
   19f18:	da00000a 	ble	19f48 <_malloc_trim_r+0x14c>
        {
          sbrked_mem = current_brk - sbrk_base;
   19f1c:	e51b2014 	ldr	r2, [fp, #-20]
   19f20:	e59f3084 	ldr	r3, [pc, #132]	; 19fac <_malloc_trim_r+0x1b0>
   19f24:	e5933000 	ldr	r3, [r3]
   19f28:	e0632002 	rsb	r2, r3, r2
   19f2c:	e59f307c 	ldr	r3, [pc, #124]	; 19fb0 <_malloc_trim_r+0x1b4>
   19f30:	e5832000 	str	r2, [r3]
          set_head(top, top_size | PREV_INUSE);
   19f34:	e59f306c 	ldr	r3, [pc, #108]	; 19fa8 <_malloc_trim_r+0x1ac>
   19f38:	e5933008 	ldr	r3, [r3, #8]
   19f3c:	e51b200c 	ldr	r2, [fp, #-12]
   19f40:	e3822001 	orr	r2, r2, #1
   19f44:	e5832004 	str	r2, [r3, #4]
        }
        check_chunk(top);
	MALLOC_UNLOCK;
   19f48:	e51b0020 	ldr	r0, [fp, #-32]
   19f4c:	ebffd7e9 	bl	fef8 <__malloc_unlock>
        return 0; 
   19f50:	e3a03000 	mov	r3, #0
   19f54:	ea00000f 	b	19f98 <_malloc_trim_r+0x19c>
      }

      else
      {
        /* Success. Adjust top accordingly. */
        set_head(top, (top_size - extra) | PREV_INUSE);
   19f58:	e59f3048 	ldr	r3, [pc, #72]	; 19fa8 <_malloc_trim_r+0x1ac>
   19f5c:	e5933008 	ldr	r3, [r3, #8]
   19f60:	e51b100c 	ldr	r1, [fp, #-12]
   19f64:	e51b2010 	ldr	r2, [fp, #-16]
   19f68:	e0622001 	rsb	r2, r2, r1
   19f6c:	e3822001 	orr	r2, r2, #1
   19f70:	e5832004 	str	r2, [r3, #4]
        sbrked_mem -= extra;
   19f74:	e59f3034 	ldr	r3, [pc, #52]	; 19fb0 <_malloc_trim_r+0x1b4>
   19f78:	e5932000 	ldr	r2, [r3]
   19f7c:	e51b3010 	ldr	r3, [fp, #-16]
   19f80:	e0632002 	rsb	r2, r3, r2
   19f84:	e59f3024 	ldr	r3, [pc, #36]	; 19fb0 <_malloc_trim_r+0x1b4>
   19f88:	e5832000 	str	r2, [r3]
        check_chunk(top);
	MALLOC_UNLOCK;
   19f8c:	e51b0020 	ldr	r0, [fp, #-32]
   19f90:	ebffd7d8 	bl	fef8 <__malloc_unlock>
        return 1;
   19f94:	e3a03001 	mov	r3, #1
      }
    }
  }
}
   19f98:	e1a00003 	mov	r0, r3
   19f9c:	e24bd004 	sub	sp, fp, #4
   19fa0:	e8bd4800 	pop	{fp, lr}
   19fa4:	e12fff1e 	bx	lr
   19fa8:	00024bd8 	.word	0x00024bd8
   19fac:	00024fe4 	.word	0x00024fe4
   19fb0:	00035598 	.word	0x00035598

00019fb4 <__sfvwrite_r>:
int
_DEFUN(__sfvwrite_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       register FILE *fp _AND
       register struct __suio *uio)
{
   19fb4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   19fb8:	e28db020 	add	fp, sp, #32
   19fbc:	e24dd024 	sub	sp, sp, #36	; 0x24
   19fc0:	e50b0040 	str	r0, [fp, #-64]	; 0x40
   19fc4:	e1a04001 	mov	r4, r1
   19fc8:	e1a09002 	mov	r9, r2
  register size_t len;
  register _CONST char *p = NULL;
   19fcc:	e3a07000 	mov	r7, #0
  register struct __siov *iov;
  register int w, s;
  char *nl;
  int nlknown, nldist;

  if ((len = uio->uio_resid) == 0)
   19fd0:	e5993008 	ldr	r3, [r9, #8]
   19fd4:	e1a06003 	mov	r6, r3
   19fd8:	e3560000 	cmp	r6, #0
   19fdc:	1a000001 	bne	19fe8 <__sfvwrite_r+0x34>
    return 0;
   19fe0:	e3a03000 	mov	r3, #0
   19fe4:	ea00018e 	b	1a624 <__sfvwrite_r+0x670>

  /* make sure we can write */
  if (cantwrite (ptr, fp))
   19fe8:	e1d430bc 	ldrh	r3, [r4, #12]
   19fec:	e1a03803 	lsl	r3, r3, #16
   19ff0:	e1a03823 	lsr	r3, r3, #16
   19ff4:	e2033008 	and	r3, r3, #8
   19ff8:	e3530000 	cmp	r3, #0
   19ffc:	0a000002 	beq	1a00c <__sfvwrite_r+0x58>
   1a000:	e5943010 	ldr	r3, [r4, #16]
   1a004:	e3530000 	cmp	r3, #0
   1a008:	1a000007 	bne	1a02c <__sfvwrite_r+0x78>
   1a00c:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   1a010:	e1a01004 	mov	r1, r4
   1a014:	ebfff2bf 	bl	16b18 <__swsetup_r>
   1a018:	e1a03000 	mov	r3, r0
   1a01c:	e3530000 	cmp	r3, #0
   1a020:	0a000001 	beq	1a02c <__sfvwrite_r+0x78>
    return EOF;
   1a024:	e3e03000 	mvn	r3, #0
   1a028:	ea00017d 	b	1a624 <__sfvwrite_r+0x670>

  iov = uio->uio_iov;
   1a02c:	e5998000 	ldr	r8, [r9]
  len = 0;
   1a030:	e3a06000 	mov	r6, #0
      while (uio->uio_resid > 0);
      return 0;
    }
#endif

  if (fp->_flags & __SNBF)
   1a034:	e1d430bc 	ldrh	r3, [r4, #12]
   1a038:	e1a03803 	lsl	r3, r3, #16
   1a03c:	e1a03823 	lsr	r3, r3, #16
   1a040:	e2033002 	and	r3, r3, #2
   1a044:	e3530000 	cmp	r3, #0
   1a048:	0a00001e 	beq	1a0c8 <__sfvwrite_r+0x114>
      /*
       * Unbuffered: write up to BUFSIZ bytes at a time.
       */
      do
	{
	  GETIOV (;);
   1a04c:	ea000002 	b	1a05c <__sfvwrite_r+0xa8>
   1a050:	e5987000 	ldr	r7, [r8]
   1a054:	e5986004 	ldr	r6, [r8, #4]
   1a058:	e2888008 	add	r8, r8, #8
   1a05c:	e3560000 	cmp	r6, #0
   1a060:	0afffffa 	beq	1a050 <__sfvwrite_r+0x9c>
	  w = fp->_write (ptr, fp->_cookie, p, MIN (len, BUFSIZ));
   1a064:	e594c024 	ldr	ip, [r4, #36]	; 0x24
   1a068:	e594201c 	ldr	r2, [r4, #28]
   1a06c:	e3560b01 	cmp	r6, #1024	; 0x400
   1a070:	31a03006 	movcc	r3, r6
   1a074:	23a03b01 	movcs	r3, #1024	; 0x400
   1a078:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   1a07c:	e1a01002 	mov	r1, r2
   1a080:	e1a02007 	mov	r2, r7
   1a084:	e1a0e00f 	mov	lr, pc
   1a088:	e12fff1c 	bx	ip
   1a08c:	e1a05000 	mov	r5, r0
	  if (w <= 0)
   1a090:	e3550000 	cmp	r5, #0
   1a094:	ca000000 	bgt	1a09c <__sfvwrite_r+0xe8>
	    goto err;
   1a098:	ea00015b 	b	1a60c <__sfvwrite_r+0x658>
	  p += w;
   1a09c:	e1a03005 	mov	r3, r5
   1a0a0:	e0877003 	add	r7, r7, r3
	  len -= w;
   1a0a4:	e1a03005 	mov	r3, r5
   1a0a8:	e0636006 	rsb	r6, r3, r6
	}
      while ((uio->uio_resid -= w) != 0);
   1a0ac:	e5993008 	ldr	r3, [r9, #8]
   1a0b0:	e0653003 	rsb	r3, r5, r3
   1a0b4:	e5893008 	str	r3, [r9, #8]
   1a0b8:	e5993008 	ldr	r3, [r9, #8]
   1a0bc:	e3530000 	cmp	r3, #0
   1a0c0:	1affffe1 	bne	1a04c <__sfvwrite_r+0x98>
   1a0c4:	ea00014e 	b	1a604 <__sfvwrite_r+0x650>
    }
  else if ((fp->_flags & __SLBF) == 0)
   1a0c8:	e1d430bc 	ldrh	r3, [r4, #12]
   1a0cc:	e1a03803 	lsl	r3, r3, #16
   1a0d0:	e1a03823 	lsr	r3, r3, #16
   1a0d4:	e2033001 	and	r3, r3, #1
   1a0d8:	e3530000 	cmp	r3, #0
   1a0dc:	1a0000c6 	bne	1a3fc <__sfvwrite_r+0x448>
       * we are dealing with the asprintf routines, we will
       * dynamically increase the buffer size as needed.
       */
      do
	{
	  GETIOV (;);
   1a0e0:	ea000002 	b	1a0f0 <__sfvwrite_r+0x13c>
   1a0e4:	e5987000 	ldr	r7, [r8]
   1a0e8:	e5986004 	ldr	r6, [r8, #4]
   1a0ec:	e2888008 	add	r8, r8, #8
   1a0f0:	e3560000 	cmp	r6, #0
   1a0f4:	0afffffa 	beq	1a0e4 <__sfvwrite_r+0x130>
	  w = fp->_w;
   1a0f8:	e5945008 	ldr	r5, [r4, #8]
	  if (fp->_flags & __SSTR)
   1a0fc:	e1d430bc 	ldrh	r3, [r4, #12]
   1a100:	e1a03803 	lsl	r3, r3, #16
   1a104:	e1a03823 	lsr	r3, r3, #16
   1a108:	e2033c02 	and	r3, r3, #512	; 0x200
   1a10c:	e3530000 	cmp	r3, #0
   1a110:	0a000077 	beq	1a2f4 <__sfvwrite_r+0x340>
	    {
	      if (len >= w && fp->_flags & (__SMBF | __SOPT))
   1a114:	e1a03005 	mov	r3, r5
   1a118:	e1530006 	cmp	r3, r6
   1a11c:	8a000061 	bhi	1a2a8 <__sfvwrite_r+0x2f4>
   1a120:	e1d430bc 	ldrh	r3, [r4, #12]
   1a124:	e1a03803 	lsl	r3, r3, #16
   1a128:	e1a03823 	lsr	r3, r3, #16
   1a12c:	e2033d12 	and	r3, r3, #1152	; 0x480
   1a130:	e3530000 	cmp	r3, #0
   1a134:	0a00005b 	beq	1a2a8 <__sfvwrite_r+0x2f4>
		{ /* must be asprintf family */
		  unsigned char *str;
		  int curpos = (fp->_p - fp->_bf._base);
   1a138:	e5943000 	ldr	r3, [r4]
   1a13c:	e1a02003 	mov	r2, r3
   1a140:	e5943010 	ldr	r3, [r4, #16]
   1a144:	e0633002 	rsb	r3, r3, r2
   1a148:	e50b3038 	str	r3, [fp, #-56]	; 0x38
		     than (1+sqrt(5))/2 to accomodate malloc
		     overhead. asprintf EXPECTS us to overallocate, so
		     that it can add a trailing \0 without
		     reallocating.  The new allocation should thus be
		     max(prev_size*1.5, curpos+len+1). */
		  int newsize = fp->_bf._size * 3 / 2;
   1a14c:	e5942014 	ldr	r2, [r4, #20]
   1a150:	e1a03002 	mov	r3, r2
   1a154:	e1a03083 	lsl	r3, r3, #1
   1a158:	e0833002 	add	r3, r3, r2
   1a15c:	e1a02fa3 	lsr	r2, r3, #31
   1a160:	e0823003 	add	r3, r2, r3
   1a164:	e1a030c3 	asr	r3, r3, #1
   1a168:	e50b3034 	str	r3, [fp, #-52]	; 0x34
		  if (newsize < curpos + len + 1)
   1a16c:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   1a170:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1a174:	e0833006 	add	r3, r3, r6
   1a178:	e2833001 	add	r3, r3, #1
   1a17c:	e1520003 	cmp	r2, r3
   1a180:	2a000003 	bcs	1a194 <__sfvwrite_r+0x1e0>
		    newsize = curpos + len + 1;
   1a184:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1a188:	e0833006 	add	r3, r3, r6
   1a18c:	e2833001 	add	r3, r3, #1
   1a190:	e50b3034 	str	r3, [fp, #-52]	; 0x34
		  if (fp->_flags & __SOPT)
   1a194:	e1d430bc 	ldrh	r3, [r4, #12]
   1a198:	e1a03803 	lsl	r3, r3, #16
   1a19c:	e1a03823 	lsr	r3, r3, #16
   1a1a0:	e2033b01 	and	r3, r3, #1024	; 0x400
   1a1a4:	e3530000 	cmp	r3, #0
   1a1a8:	0a00001a 	beq	1a218 <__sfvwrite_r+0x264>
		    {
		      /* asnprintf leaves original buffer alone.  */
		      str = (unsigned char *)_malloc_r (ptr, newsize);
   1a1ac:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1a1b0:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   1a1b4:	e1a01003 	mov	r1, r3
   1a1b8:	ebffd39d 	bl	f034 <_malloc_r>
   1a1bc:	e50b0030 	str	r0, [fp, #-48]	; 0x30
		      if (!str)
   1a1c0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1a1c4:	e3530000 	cmp	r3, #0
   1a1c8:	1a000003 	bne	1a1dc <__sfvwrite_r+0x228>
			{
			  ptr->_errno = ENOMEM;
   1a1cc:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1a1d0:	e3a0200c 	mov	r2, #12
   1a1d4:	e5832000 	str	r2, [r3]
			  goto err;
   1a1d8:	ea00010b 	b	1a60c <__sfvwrite_r+0x658>
			}
		      memcpy (str, fp->_bf._base, curpos);
   1a1dc:	e5942010 	ldr	r2, [r4, #16]
   1a1e0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1a1e4:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   1a1e8:	e1a01002 	mov	r1, r2
   1a1ec:	e1a02003 	mov	r2, r3
   1a1f0:	ebffd656 	bl	fb50 <memcpy>
		      fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
   1a1f4:	e1d430bc 	ldrh	r3, [r4, #12]
   1a1f8:	e3c33d12 	bic	r3, r3, #1152	; 0x480
   1a1fc:	e1a03803 	lsl	r3, r3, #16
   1a200:	e1a03823 	lsr	r3, r3, #16
   1a204:	e3833080 	orr	r3, r3, #128	; 0x80
   1a208:	e1a03803 	lsl	r3, r3, #16
   1a20c:	e1a03823 	lsr	r3, r3, #16
   1a210:	e1c430bc 	strh	r3, [r4, #12]
   1a214:	ea000016 	b	1a274 <__sfvwrite_r+0x2c0>
		    }
		  else
		    {
		      str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
   1a218:	e5942010 	ldr	r2, [r4, #16]
   1a21c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1a220:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   1a224:	e1a01002 	mov	r1, r2
   1a228:	e1a02003 	mov	r2, r3
   1a22c:	eb000a0b 	bl	1ca60 <_realloc_r>
   1a230:	e50b0030 	str	r0, [fp, #-48]	; 0x30
							 newsize);
		      if (!str)
   1a234:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1a238:	e3530000 	cmp	r3, #0
   1a23c:	1a00000c 	bne	1a274 <__sfvwrite_r+0x2c0>
			{
			  /* Free buffer which is no longer used and clear
			     __SMBF flag to avoid double free in fclose.  */
			  _free_r (ptr, fp->_bf._base);
   1a240:	e5943010 	ldr	r3, [r4, #16]
   1a244:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   1a248:	e1a01003 	mov	r1, r3
   1a24c:	ebfffd92 	bl	1989c <_free_r>
			  fp->_flags &=  ~__SMBF;
   1a250:	e1d430bc 	ldrh	r3, [r4, #12]
   1a254:	e3c33080 	bic	r3, r3, #128	; 0x80
   1a258:	e1a03803 	lsl	r3, r3, #16
   1a25c:	e1a03823 	lsr	r3, r3, #16
   1a260:	e1c430bc 	strh	r3, [r4, #12]
			  /* Ensure correct errno, even if free changed it.  */
			  ptr->_errno = ENOMEM;
   1a264:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1a268:	e3a0200c 	mov	r2, #12
   1a26c:	e5832000 	str	r2, [r3]
			  goto err;
   1a270:	ea0000e5 	b	1a60c <__sfvwrite_r+0x658>
			}
		    }
		  fp->_bf._base = str;
   1a274:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1a278:	e5843010 	str	r3, [r4, #16]
		  fp->_p = str + curpos;
   1a27c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1a280:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   1a284:	e0823003 	add	r3, r2, r3
   1a288:	e5843000 	str	r3, [r4]
		  fp->_bf._size = newsize;
   1a28c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1a290:	e5843014 	str	r3, [r4, #20]
		  w = len;
   1a294:	e1a05006 	mov	r5, r6
		  fp->_w = newsize - curpos;
   1a298:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   1a29c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1a2a0:	e0633002 	rsb	r3, r3, r2
   1a2a4:	e5843008 	str	r3, [r4, #8]
		}
	      if (len < w)
   1a2a8:	e1a03005 	mov	r3, r5
   1a2ac:	e1530006 	cmp	r3, r6
   1a2b0:	9a000000 	bls	1a2b8 <__sfvwrite_r+0x304>
		w = len;
   1a2b4:	e1a05006 	mov	r5, r6
	      COPY (w);		/* copy MIN(fp->_w,len), */
   1a2b8:	e5942000 	ldr	r2, [r4]
   1a2bc:	e1a03005 	mov	r3, r5
   1a2c0:	e1a00002 	mov	r0, r2
   1a2c4:	e1a01007 	mov	r1, r7
   1a2c8:	e1a02003 	mov	r2, r3
   1a2cc:	eb0002b2 	bl	1ad9c <memmove>
	      fp->_w -= w;
   1a2d0:	e5943008 	ldr	r3, [r4, #8]
   1a2d4:	e0653003 	rsb	r3, r5, r3
   1a2d8:	e5843008 	str	r3, [r4, #8]
	      fp->_p += w;
   1a2dc:	e5942000 	ldr	r2, [r4]
   1a2e0:	e1a03005 	mov	r3, r5
   1a2e4:	e0823003 	add	r3, r2, r3
   1a2e8:	e5843000 	str	r3, [r4]
	      w = len;		/* but pretend copied all */
   1a2ec:	e1a05006 	mov	r5, r6
   1a2f0:	ea000036 	b	1a3d0 <__sfvwrite_r+0x41c>
	    }
	  else if (fp->_p > fp->_bf._base && len > w)
   1a2f4:	e5942000 	ldr	r2, [r4]
   1a2f8:	e5943010 	ldr	r3, [r4, #16]
   1a2fc:	e1520003 	cmp	r2, r3
   1a300:	9a000014 	bls	1a358 <__sfvwrite_r+0x3a4>
   1a304:	e1a03005 	mov	r3, r5
   1a308:	e1530006 	cmp	r3, r6
   1a30c:	2a000011 	bcs	1a358 <__sfvwrite_r+0x3a4>
	    {
	      /* fill and flush */
	      COPY (w);
   1a310:	e5942000 	ldr	r2, [r4]
   1a314:	e1a03005 	mov	r3, r5
   1a318:	e1a00002 	mov	r0, r2
   1a31c:	e1a01007 	mov	r1, r7
   1a320:	e1a02003 	mov	r2, r3
   1a324:	eb00029c 	bl	1ad9c <memmove>
	      /* fp->_w -= w; *//* unneeded */
	      fp->_p += w;
   1a328:	e5942000 	ldr	r2, [r4]
   1a32c:	e1a03005 	mov	r3, r5
   1a330:	e0823003 	add	r3, r2, r3
   1a334:	e5843000 	str	r3, [r4]
	      if (_fflush_r (ptr, fp))
   1a338:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   1a33c:	e1a01004 	mov	r1, r4
   1a340:	ebfffb73 	bl	19114 <_fflush_r>
   1a344:	e1a03000 	mov	r3, r0
   1a348:	e3530000 	cmp	r3, #0
   1a34c:	0a000000 	beq	1a354 <__sfvwrite_r+0x3a0>
		goto err;
   1a350:	ea0000ad 	b	1a60c <__sfvwrite_r+0x658>
	    {
	      /* fill and flush */
	      COPY (w);
	      /* fp->_w -= w; *//* unneeded */
	      fp->_p += w;
	      if (_fflush_r (ptr, fp))
   1a354:	ea00001d 	b	1a3d0 <__sfvwrite_r+0x41c>
		goto err;
	    }
	  else if (len >= (w = fp->_bf._size))
   1a358:	e5945014 	ldr	r5, [r4, #20]
   1a35c:	e1a03005 	mov	r3, r5
   1a360:	e1530006 	cmp	r3, r6
   1a364:	8a00000b 	bhi	1a398 <__sfvwrite_r+0x3e4>
	    {
	      /* write directly */
	      w = fp->_write (ptr, fp->_cookie, p, w);
   1a368:	e594c024 	ldr	ip, [r4, #36]	; 0x24
   1a36c:	e594301c 	ldr	r3, [r4, #28]
   1a370:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   1a374:	e1a01003 	mov	r1, r3
   1a378:	e1a02007 	mov	r2, r7
   1a37c:	e1a03005 	mov	r3, r5
   1a380:	e1a0e00f 	mov	lr, pc
   1a384:	e12fff1c 	bx	ip
   1a388:	e1a05000 	mov	r5, r0
	      if (w <= 0)
   1a38c:	e3550000 	cmp	r5, #0
   1a390:	ca00000e 	bgt	1a3d0 <__sfvwrite_r+0x41c>
		goto err;
   1a394:	ea00009c 	b	1a60c <__sfvwrite_r+0x658>
	    }
	  else
	    {
	      /* fill and done */
	      w = len;
   1a398:	e1a05006 	mov	r5, r6
	      COPY (w);
   1a39c:	e5942000 	ldr	r2, [r4]
   1a3a0:	e1a03005 	mov	r3, r5
   1a3a4:	e1a00002 	mov	r0, r2
   1a3a8:	e1a01007 	mov	r1, r7
   1a3ac:	e1a02003 	mov	r2, r3
   1a3b0:	eb000279 	bl	1ad9c <memmove>
	      fp->_w -= w;
   1a3b4:	e5943008 	ldr	r3, [r4, #8]
   1a3b8:	e0653003 	rsb	r3, r5, r3
   1a3bc:	e5843008 	str	r3, [r4, #8]
	      fp->_p += w;
   1a3c0:	e5942000 	ldr	r2, [r4]
   1a3c4:	e1a03005 	mov	r3, r5
   1a3c8:	e0823003 	add	r3, r2, r3
   1a3cc:	e5843000 	str	r3, [r4]
	    }
	  p += w;
   1a3d0:	e1a03005 	mov	r3, r5
   1a3d4:	e0877003 	add	r7, r7, r3
	  len -= w;
   1a3d8:	e1a03005 	mov	r3, r5
   1a3dc:	e0636006 	rsb	r6, r3, r6
	}
      while ((uio->uio_resid -= w) != 0);
   1a3e0:	e5993008 	ldr	r3, [r9, #8]
   1a3e4:	e0653003 	rsb	r3, r5, r3
   1a3e8:	e5893008 	str	r3, [r9, #8]
   1a3ec:	e5993008 	ldr	r3, [r9, #8]
   1a3f0:	e3530000 	cmp	r3, #0
   1a3f4:	1affff39 	bne	1a0e0 <__sfvwrite_r+0x12c>
   1a3f8:	ea000081 	b	1a604 <__sfvwrite_r+0x650>
       * must check for newlines.  Compute the distance
       * to the first newline (including the newline),
       * or `infinity' if there is none, then pretend
       * that the amount to write is MIN(len,nldist).
       */
      nlknown = 0;
   1a3fc:	e3a03000 	mov	r3, #0
   1a400:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      nldist = 0;
   1a404:	e3a03000 	mov	r3, #0
   1a408:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
      do
	{
	  GETIOV (nlknown = 0);
   1a40c:	ea000004 	b	1a424 <__sfvwrite_r+0x470>
   1a410:	e3a03000 	mov	r3, #0
   1a414:	e50b3028 	str	r3, [fp, #-40]	; 0x28
   1a418:	e5987000 	ldr	r7, [r8]
   1a41c:	e5986004 	ldr	r6, [r8, #4]
   1a420:	e2888008 	add	r8, r8, #8
   1a424:	e3560000 	cmp	r6, #0
   1a428:	0afffff8 	beq	1a410 <__sfvwrite_r+0x45c>
	  if (!nlknown)
   1a42c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1a430:	e3530000 	cmp	r3, #0
   1a434:	1a000011 	bne	1a480 <__sfvwrite_r+0x4cc>
	    {
	      nl = memchr ((_PTR) p, '\n', len);
   1a438:	e1a00007 	mov	r0, r7
   1a43c:	e3a0100a 	mov	r1, #10
   1a440:	e1a02006 	mov	r2, r6
   1a444:	eb0001e2 	bl	1abd4 <memchr>
   1a448:	e50b003c 	str	r0, [fp, #-60]	; 0x3c
	      nldist = nl ? nl + 1 - p : len + 1;
   1a44c:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1a450:	e3530000 	cmp	r3, #0
   1a454:	0a000005 	beq	1a470 <__sfvwrite_r+0x4bc>
   1a458:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1a45c:	e2833001 	add	r3, r3, #1
   1a460:	e1a02003 	mov	r2, r3
   1a464:	e1a03007 	mov	r3, r7
   1a468:	e0633002 	rsb	r3, r3, r2
   1a46c:	ea000000 	b	1a474 <__sfvwrite_r+0x4c0>
   1a470:	e2863001 	add	r3, r6, #1
   1a474:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	      nlknown = 1;
   1a478:	e3a03001 	mov	r3, #1
   1a47c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	    }
	  s = MIN (len, nldist);
   1a480:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1a484:	e1530006 	cmp	r3, r6
   1a488:	31a03003 	movcc	r3, r3
   1a48c:	21a03006 	movcs	r3, r6
   1a490:	e1a0a003 	mov	sl, r3

//      cpu_dcache_inv_addr((void*)&(fp->_bf._size));
//      cpu_dcache_inv_addr((void*)&(fp->_w));
	  w = fp->_w + fp->_bf._size;
   1a494:	e5942008 	ldr	r2, [r4, #8]
   1a498:	e5943014 	ldr	r3, [r4, #20]
   1a49c:	e0825003 	add	r5, r2, r3

      cpu_dcache_invalidate((void*)(fp), sizeof(struct __sFILE));
   1a4a0:	e1a00004 	mov	r0, r4
   1a4a4:	e3a01070 	mov	r1, #112	; 0x70
   1a4a8:	ebffbe00 	bl	9cb0 <cpu_dcache_invalidate>
      cpu_dcache_invalidate((void*)&(fp->_bf._base), sizeof(unsigned char*));
   1a4ac:	e2843010 	add	r3, r4, #16
   1a4b0:	e1a00003 	mov	r0, r3
   1a4b4:	e3a01004 	mov	r1, #4
   1a4b8:	ebffbdfc 	bl	9cb0 <cpu_dcache_invalidate>
      cpu_dcache_invalidate((void*)&(fp->_p), sizeof(unsigned char*));
   1a4bc:	e1a03004 	mov	r3, r4
   1a4c0:	e1a00003 	mov	r0, r3
   1a4c4:	e3a01004 	mov	r1, #4
   1a4c8:	ebffbdf8 	bl	9cb0 <cpu_dcache_invalidate>
	  if (fp->_p > fp->_bf._base && s > w)
   1a4cc:	e5942000 	ldr	r2, [r4]
   1a4d0:	e5943010 	ldr	r3, [r4, #16]
   1a4d4:	e1520003 	cmp	r2, r3
   1a4d8:	9a000013 	bls	1a52c <__sfvwrite_r+0x578>
   1a4dc:	e15a0005 	cmp	sl, r5
   1a4e0:	da000011 	ble	1a52c <__sfvwrite_r+0x578>
	    {
	      COPY (w);
   1a4e4:	e5942000 	ldr	r2, [r4]
   1a4e8:	e1a03005 	mov	r3, r5
   1a4ec:	e1a00002 	mov	r0, r2
   1a4f0:	e1a01007 	mov	r1, r7
   1a4f4:	e1a02003 	mov	r2, r3
   1a4f8:	eb000227 	bl	1ad9c <memmove>
	      /* fp->_w -= w; */
	      fp->_p += w;
   1a4fc:	e5942000 	ldr	r2, [r4]
   1a500:	e1a03005 	mov	r3, r5
   1a504:	e0823003 	add	r3, r2, r3
   1a508:	e5843000 	str	r3, [r4]
	      if (_fflush_r (ptr, fp))
   1a50c:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   1a510:	e1a01004 	mov	r1, r4
   1a514:	ebfffafe 	bl	19114 <_fflush_r>
   1a518:	e1a03000 	mov	r3, r0
   1a51c:	e3530000 	cmp	r3, #0
   1a520:	0a000000 	beq	1a528 <__sfvwrite_r+0x574>
		goto err;
   1a524:	ea000038 	b	1a60c <__sfvwrite_r+0x658>
	  if (fp->_p > fp->_bf._base && s > w)
	    {
	      COPY (w);
	      /* fp->_w -= w; */
	      fp->_p += w;
	      if (_fflush_r (ptr, fp))
   1a528:	ea00001c 	b	1a5a0 <__sfvwrite_r+0x5ec>
		goto err;
	    }
	  else if (s >= (w = fp->_bf._size))
   1a52c:	e5945014 	ldr	r5, [r4, #20]
   1a530:	e155000a 	cmp	r5, sl
   1a534:	ca00000b 	bgt	1a568 <__sfvwrite_r+0x5b4>
	    {
	      w = fp->_write (ptr, fp->_cookie, p, w);
   1a538:	e594c024 	ldr	ip, [r4, #36]	; 0x24
   1a53c:	e594301c 	ldr	r3, [r4, #28]
   1a540:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   1a544:	e1a01003 	mov	r1, r3
   1a548:	e1a02007 	mov	r2, r7
   1a54c:	e1a03005 	mov	r3, r5
   1a550:	e1a0e00f 	mov	lr, pc
   1a554:	e12fff1c 	bx	ip
   1a558:	e1a05000 	mov	r5, r0
	      if (w <= 0)
   1a55c:	e3550000 	cmp	r5, #0
   1a560:	ca00000e 	bgt	1a5a0 <__sfvwrite_r+0x5ec>
		goto err;
   1a564:	ea000028 	b	1a60c <__sfvwrite_r+0x658>
	    }
	  else
	    {
	      w = s;
   1a568:	e1a0500a 	mov	r5, sl
	      COPY (w);
   1a56c:	e5942000 	ldr	r2, [r4]
   1a570:	e1a03005 	mov	r3, r5
   1a574:	e1a00002 	mov	r0, r2
   1a578:	e1a01007 	mov	r1, r7
   1a57c:	e1a02003 	mov	r2, r3
   1a580:	eb000205 	bl	1ad9c <memmove>
	      fp->_w -= w;
   1a584:	e5943008 	ldr	r3, [r4, #8]
   1a588:	e0653003 	rsb	r3, r5, r3
   1a58c:	e5843008 	str	r3, [r4, #8]
	      fp->_p += w;
   1a590:	e5942000 	ldr	r2, [r4]
   1a594:	e1a03005 	mov	r3, r5
   1a598:	e0823003 	add	r3, r2, r3
   1a59c:	e5843000 	str	r3, [r4]
	    }
	  if ((nldist -= w) == 0)
   1a5a0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1a5a4:	e0653003 	rsb	r3, r5, r3
   1a5a8:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   1a5ac:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1a5b0:	e3530000 	cmp	r3, #0
   1a5b4:	1a000008 	bne	1a5dc <__sfvwrite_r+0x628>
	    {
	      /* copied the newline: flush and forget */
	      if (_fflush_r (ptr, fp))
   1a5b8:	e51b0040 	ldr	r0, [fp, #-64]	; 0x40
   1a5bc:	e1a01004 	mov	r1, r4
   1a5c0:	ebfffad3 	bl	19114 <_fflush_r>
   1a5c4:	e1a03000 	mov	r3, r0
   1a5c8:	e3530000 	cmp	r3, #0
   1a5cc:	0a000000 	beq	1a5d4 <__sfvwrite_r+0x620>
		goto err;
   1a5d0:	ea00000d 	b	1a60c <__sfvwrite_r+0x658>
	      nlknown = 0;
   1a5d4:	e3a03000 	mov	r3, #0
   1a5d8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	    }
	  p += w;
   1a5dc:	e1a03005 	mov	r3, r5
   1a5e0:	e0877003 	add	r7, r7, r3
	  len -= w;
   1a5e4:	e1a03005 	mov	r3, r5
   1a5e8:	e0636006 	rsb	r6, r3, r6
	}
      while ((uio->uio_resid -= w) != 0);
   1a5ec:	e5993008 	ldr	r3, [r9, #8]
   1a5f0:	e0653003 	rsb	r3, r5, r3
   1a5f4:	e5893008 	str	r3, [r9, #8]
   1a5f8:	e5993008 	ldr	r3, [r9, #8]
   1a5fc:	e3530000 	cmp	r3, #0
   1a600:	1affff81 	bne	1a40c <__sfvwrite_r+0x458>
    }
  return 0;
   1a604:	e3a03000 	mov	r3, #0
   1a608:	ea000005 	b	1a624 <__sfvwrite_r+0x670>

err:
  fp->_flags |= __SERR;
   1a60c:	e1d430bc 	ldrh	r3, [r4, #12]
   1a610:	e3833040 	orr	r3, r3, #64	; 0x40
   1a614:	e1a03803 	lsl	r3, r3, #16
   1a618:	e1a03823 	lsr	r3, r3, #16
   1a61c:	e1c430bc 	strh	r3, [r4, #12]
  return EOF;
   1a620:	e3e03000 	mvn	r3, #0
}
   1a624:	e1a00003 	mov	r0, r3
   1a628:	e24bd020 	sub	sp, fp, #32
   1a62c:	e8bd4ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
   1a630:	e12fff1e 	bx	lr

0001a634 <_fwalk>:

int
_DEFUN(_fwalk, (ptr, function),
       struct _reent *ptr _AND
       register int (*function) (FILE *))
{
   1a634:	e92d49f0 	push	{r4, r5, r6, r7, r8, fp, lr}
   1a638:	e28db018 	add	fp, sp, #24
   1a63c:	e24dd00c 	sub	sp, sp, #12
   1a640:	e50b0020 	str	r0, [fp, #-32]
   1a644:	e1a08001 	mov	r8, r1
  register FILE *fp;
  register int n, ret = 0;
   1a648:	e3a06000 	mov	r6, #0
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   1a64c:	e51b3020 	ldr	r3, [fp, #-32]
   1a650:	e2835e2e 	add	r5, r3, #736	; 0x2e0
   1a654:	ea000019 	b	1a6c0 <_fwalk+0x8c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   1a658:	e5954008 	ldr	r4, [r5, #8]
   1a65c:	e5957004 	ldr	r7, [r5, #4]
   1a660:	ea000012 	b	1a6b0 <_fwalk+0x7c>
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   1a664:	e1d430bc 	ldrh	r3, [r4, #12]
   1a668:	e3530000 	cmp	r3, #0
   1a66c:	0a00000e 	beq	1a6ac <_fwalk+0x78>
   1a670:	e1d430bc 	ldrh	r3, [r4, #12]
   1a674:	e1a03803 	lsl	r3, r3, #16
   1a678:	e1a03843 	asr	r3, r3, #16
   1a67c:	e3530001 	cmp	r3, #1
   1a680:	0a000009 	beq	1a6ac <_fwalk+0x78>
   1a684:	e1d430be 	ldrh	r3, [r4, #14]
   1a688:	e1a03803 	lsl	r3, r3, #16
   1a68c:	e1a03843 	asr	r3, r3, #16
   1a690:	e3730001 	cmn	r3, #1
   1a694:	0a000004 	beq	1a6ac <_fwalk+0x78>
	ret |= (*function) (fp);
   1a698:	e1a00004 	mov	r0, r4
   1a69c:	e1a0e00f 	mov	lr, pc
   1a6a0:	e12fff18 	bx	r8
   1a6a4:	e1a03000 	mov	r3, r0
   1a6a8:	e1866003 	orr	r6, r6, r3
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   1a6ac:	e2844070 	add	r4, r4, #112	; 0x70
   1a6b0:	e2477001 	sub	r7, r7, #1
   1a6b4:	e3570000 	cmp	r7, #0
   1a6b8:	aaffffe9 	bge	1a664 <_fwalk+0x30>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   1a6bc:	e5955000 	ldr	r5, [r5]
   1a6c0:	e3550000 	cmp	r5, #0
   1a6c4:	1affffe3 	bne	1a658 <_fwalk+0x24>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
      if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
	ret |= (*function) (fp);

  return ret;
   1a6c8:	e1a03006 	mov	r3, r6
}
   1a6cc:	e1a00003 	mov	r0, r3
   1a6d0:	e24bd018 	sub	sp, fp, #24
   1a6d4:	e8bd49f0 	pop	{r4, r5, r6, r7, r8, fp, lr}
   1a6d8:	e12fff1e 	bx	lr

0001a6dc <_fwalk_reent>:
   I/O function (e.g. _fclose_r).  */
int
_DEFUN(_fwalk_reent, (ptr, reent_function),
       struct _reent *ptr _AND
       register int (*reent_function) (struct _reent *, FILE *))
{
   1a6dc:	e92d49f0 	push	{r4, r5, r6, r7, r8, fp, lr}
   1a6e0:	e28db018 	add	fp, sp, #24
   1a6e4:	e24dd00c 	sub	sp, sp, #12
   1a6e8:	e50b0020 	str	r0, [fp, #-32]
   1a6ec:	e1a08001 	mov	r8, r1
  register FILE *fp;
  register int n, ret = 0;
   1a6f0:	e3a06000 	mov	r6, #0
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   1a6f4:	e51b3020 	ldr	r3, [fp, #-32]
   1a6f8:	e2835e2e 	add	r5, r3, #736	; 0x2e0
   1a6fc:	ea00001d 	b	1a778 <_fwalk_reent+0x9c>
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   1a700:	e5954008 	ldr	r4, [r5, #8]
   1a704:	e5957004 	ldr	r7, [r5, #4]
   1a708:	ea000016 	b	1a768 <_fwalk_reent+0x8c>
      if (fp->_flags != 0)
   1a70c:	e1d430bc 	ldrh	r3, [r4, #12]
   1a710:	e3530000 	cmp	r3, #0
   1a714:	0a000012 	beq	1a764 <_fwalk_reent+0x88>
        {
          if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
   1a718:	e1d430bc 	ldrh	r3, [r4, #12]
   1a71c:	e3530000 	cmp	r3, #0
   1a720:	0a00000f 	beq	1a764 <_fwalk_reent+0x88>
   1a724:	e1d430bc 	ldrh	r3, [r4, #12]
   1a728:	e1a03803 	lsl	r3, r3, #16
   1a72c:	e1a03843 	asr	r3, r3, #16
   1a730:	e3530001 	cmp	r3, #1
   1a734:	0a00000a 	beq	1a764 <_fwalk_reent+0x88>
   1a738:	e1d430be 	ldrh	r3, [r4, #14]
   1a73c:	e1a03803 	lsl	r3, r3, #16
   1a740:	e1a03843 	asr	r3, r3, #16
   1a744:	e3730001 	cmn	r3, #1
   1a748:	0a000005 	beq	1a764 <_fwalk_reent+0x88>
            ret |= (*reent_function) (ptr, fp);
   1a74c:	e51b0020 	ldr	r0, [fp, #-32]
   1a750:	e1a01004 	mov	r1, r4
   1a754:	e1a0e00f 	mov	lr, pc
   1a758:	e12fff18 	bx	r8
   1a75c:	e1a03000 	mov	r3, r0
   1a760:	e1866003 	orr	r6, r6, r3
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
    for (fp = g->_iobs, n = g->_niobs; --n >= 0; fp++)
   1a764:	e2844070 	add	r4, r4, #112	; 0x70
   1a768:	e2477001 	sub	r7, r7, #1
   1a76c:	e3570000 	cmp	r7, #0
   1a770:	aaffffe5 	bge	1a70c <_fwalk_reent+0x30>
   * removed.
   *
   * Avoid locking this list while walking it or else you will
   * introduce a potential deadlock in [at least] refill.c.
   */
  for (g = &ptr->__sglue; g != NULL; g = g->_next)
   1a774:	e5955000 	ldr	r5, [r5]
   1a778:	e3550000 	cmp	r5, #0
   1a77c:	1affffdf 	bne	1a700 <_fwalk_reent+0x24>
        {
          if (fp->_flags != 0 && fp->_flags != 1 && fp->_file != -1)
            ret |= (*reent_function) (ptr, fp);
        }

  return ret;
   1a780:	e1a03006 	mov	r3, r6
}
   1a784:	e1a00003 	mov	r0, r3
   1a788:	e24bd018 	sub	sp, fp, #24
   1a78c:	e8bd49f0 	pop	{r4, r5, r6, r7, r8, fp, lr}
   1a790:	e12fff1e 	bx	lr

0001a794 <getpid>:
#include <errno.h>

int
_DEFUN (_getpid, (),
        _NOARGS)
{
   1a794:	e92d4800 	push	{fp, lr}
   1a798:	e28db004 	add	fp, sp, #4
  errno = ENOSYS;
   1a79c:	eb001b6d 	bl	21558 <__errno>
   1a7a0:	e1a03000 	mov	r3, r0
   1a7a4:	e3a02058 	mov	r2, #88	; 0x58
   1a7a8:	e5832000 	str	r2, [r3]
  return -1;
   1a7ac:	e3e03000 	mvn	r3, #0
}
   1a7b0:	e1a00003 	mov	r0, r3
   1a7b4:	e24bd004 	sub	sp, fp, #4
   1a7b8:	e8bd4800 	pop	{fp, lr}
   1a7bc:	e12fff1e 	bx	lr

0001a7c0 <kill>:

int
_DEFUN (_kill, (pid, sig),
        int pid  _AND
        int sig)
{
   1a7c0:	e92d4800 	push	{fp, lr}
   1a7c4:	e28db004 	add	fp, sp, #4
   1a7c8:	e24dd008 	sub	sp, sp, #8
   1a7cc:	e50b0008 	str	r0, [fp, #-8]
   1a7d0:	e50b100c 	str	r1, [fp, #-12]
  errno = ENOSYS;
   1a7d4:	eb001b5f 	bl	21558 <__errno>
   1a7d8:	e1a03000 	mov	r3, r0
   1a7dc:	e3a02058 	mov	r2, #88	; 0x58
   1a7e0:	e5832000 	str	r2, [r3]
  return -1;
   1a7e4:	e3e03000 	mvn	r3, #0
}
   1a7e8:	e1a00003 	mov	r0, r3
   1a7ec:	e24bd004 	sub	sp, fp, #4
   1a7f0:	e8bd4800 	pop	{fp, lr}
   1a7f4:	e12fff1e 	bx	lr

0001a7f8 <_setlocale_r>:
char *
_DEFUN(_setlocale_r, (p, category, locale),
       struct _reent *p _AND
       int category _AND
       _CONST char *locale)
{
   1a7f8:	e92d4800 	push	{fp, lr}
   1a7fc:	e28db004 	add	fp, sp, #4
   1a800:	e24dd010 	sub	sp, sp, #16
   1a804:	e50b0008 	str	r0, [fp, #-8]
   1a808:	e50b100c 	str	r1, [fp, #-12]
   1a80c:	e50b2010 	str	r2, [fp, #-16]
#ifndef _MB_CAPABLE
  if (locale)
   1a810:	e51b3010 	ldr	r3, [fp, #-16]
   1a814:	e3530000 	cmp	r3, #0
   1a818:	0a000013 	beq	1a86c <_setlocale_r+0x74>
    { 
      if (strcmp (locale, "POSIX") && strcmp (locale, "C")
   1a81c:	e51b0010 	ldr	r0, [fp, #-16]
   1a820:	e59f1058 	ldr	r1, [pc, #88]	; 1a880 <_setlocale_r+0x88>
   1a824:	eb000d74 	bl	1ddfc <strcmp>
   1a828:	e1a03000 	mov	r3, r0
   1a82c:	e3530000 	cmp	r3, #0
   1a830:	0a00000d 	beq	1a86c <_setlocale_r+0x74>
   1a834:	e51b0010 	ldr	r0, [fp, #-16]
   1a838:	e59f1044 	ldr	r1, [pc, #68]	; 1a884 <_setlocale_r+0x8c>
   1a83c:	eb000d6e 	bl	1ddfc <strcmp>
   1a840:	e1a03000 	mov	r3, r0
   1a844:	e3530000 	cmp	r3, #0
   1a848:	0a000007 	beq	1a86c <_setlocale_r+0x74>
	  && strcmp (locale, ""))
   1a84c:	e51b0010 	ldr	r0, [fp, #-16]
   1a850:	e59f1030 	ldr	r1, [pc, #48]	; 1a888 <_setlocale_r+0x90>
   1a854:	eb000d68 	bl	1ddfc <strcmp>
   1a858:	e1a03000 	mov	r3, r0
   1a85c:	e3530000 	cmp	r3, #0
   1a860:	0a000001 	beq	1a86c <_setlocale_r+0x74>
        return NULL;
   1a864:	e3a03000 	mov	r3, #0
   1a868:	ea000000 	b	1a870 <_setlocale_r+0x78>
    }
  return "C";
   1a86c:	e59f3010 	ldr	r3, [pc, #16]	; 1a884 <_setlocale_r+0x8c>
	  return NULL;
	}
    }
  return currentlocale ();
#endif /* !_MB_CAPABLE */
}
   1a870:	e1a00003 	mov	r0, r3
   1a874:	e24bd004 	sub	sp, fp, #4
   1a878:	e8bd4800 	pop	{fp, lr}
   1a87c:	e12fff1e 	bx	lr
   1a880:	00024818 	.word	0x00024818
   1a884:	00024820 	.word	0x00024820
   1a888:	00024814 	.word	0x00024814

0001a88c <__locale_charset>:
}
#endif /* _MB_CAPABLE */

char *
_DEFUN_VOID(__locale_charset)
{
   1a88c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   1a890:	e28db000 	add	fp, sp, #0
#if 0//def __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->codeset;
#else
  return lc_ctype_charset;
   1a894:	e59f300c 	ldr	r3, [pc, #12]	; 1a8a8 <__locale_charset+0x1c>
#endif
}
   1a898:	e1a00003 	mov	r0, r3
   1a89c:	e24bd000 	sub	sp, fp, #0
   1a8a0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1a8a4:	e12fff1e 	bx	lr
   1a8a8:	00025480 	.word	0x00025480

0001a8ac <__locale_mb_cur_max>:

int
_DEFUN_VOID(__locale_mb_cur_max)
{
   1a8ac:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   1a8b0:	e28db000 	add	fp, sp, #0
#if 0//def __HAVE_LOCALE_INFO__
  return __get_current_ctype_locale ()->mb_cur_max[0];
#else
  return __mb_cur_max;
   1a8b4:	e59f3010 	ldr	r3, [pc, #16]	; 1a8cc <__locale_mb_cur_max+0x20>
   1a8b8:	e5933000 	ldr	r3, [r3]
#endif
}
   1a8bc:	e1a00003 	mov	r0, r3
   1a8c0:	e24bd000 	sub	sp, fp, #0
   1a8c4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1a8c8:	e12fff1e 	bx	lr
   1a8cc:	00025444 	.word	0x00025444

0001a8d0 <__locale_msgcharset>:


char *
_DEFUN_VOID(__locale_msgcharset)
{
   1a8d0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   1a8d4:	e28db000 	add	fp, sp, #0
#ifdef __HAVE_LOCALE_INFO__
  return (char *) __get_current_messages_locale ()->codeset;
#else
  return lc_message_charset;
   1a8d8:	e59f300c 	ldr	r3, [pc, #12]	; 1a8ec <__locale_msgcharset+0x1c>
#endif
}
   1a8dc:	e1a00003 	mov	r0, r3
   1a8e0:	e24bd000 	sub	sp, fp, #0
   1a8e4:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1a8e8:	e12fff1e 	bx	lr
   1a8ec:	000254a0 	.word	0x000254a0

0001a8f0 <__locale_cjk_lang>:

int
_DEFUN_VOID(__locale_cjk_lang)
{
   1a8f0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   1a8f4:	e28db000 	add	fp, sp, #0
  return lc_ctype_cjk_lang;
   1a8f8:	e59f3010 	ldr	r3, [pc, #16]	; 1a910 <__locale_cjk_lang+0x20>
   1a8fc:	e5933000 	ldr	r3, [r3]
}
   1a900:	e1a00003 	mov	r0, r3
   1a904:	e24bd000 	sub	sp, fp, #0
   1a908:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1a90c:	e12fff1e 	bx	lr
   1a910:	000355cc 	.word	0x000355cc

0001a914 <_localeconv_r>:

struct lconv *
_DEFUN(_localeconv_r, (data), 
      struct _reent *data)
{
   1a914:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   1a918:	e28db000 	add	fp, sp, #0
   1a91c:	e24dd00c 	sub	sp, sp, #12
   1a920:	e50b0008 	str	r0, [fp, #-8]
      lconv.int_p_sign_posn = m->p_sign_posn[0];
#endif /* !__HAVE_LOCALE_INFO_EXTENDED__ */
      __mlocale_changed = 0;
    }
#endif /* __HAVE_LOCALE_INFO__ */
  return (struct lconv *) &lconv;
   1a924:	e59f300c 	ldr	r3, [pc, #12]	; 1a938 <_localeconv_r+0x24>
}
   1a928:	e1a00003 	mov	r0, r3
   1a92c:	e24bd000 	sub	sp, fp, #0
   1a930:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1a934:	e12fff1e 	bx	lr
   1a938:	00025448 	.word	0x00025448

0001a93c <setlocale>:
   initialization work.  It calls _setlocale_r, though. */
char *
_DEFUN(setlocale, (category, locale),
       int category _AND
       _CONST char *locale)
{
   1a93c:	e92d4800 	push	{fp, lr}
   1a940:	e28db004 	add	fp, sp, #4
   1a944:	e24dd008 	sub	sp, sp, #8
   1a948:	e50b0008 	str	r0, [fp, #-8]
   1a94c:	e50b100c 	str	r1, [fp, #-12]
  return _setlocale_r (_REENT, category, locale);
   1a950:	e59f3024 	ldr	r3, [pc, #36]	; 1a97c <setlocale+0x40>
   1a954:	e5933000 	ldr	r3, [r3]
   1a958:	e1a00003 	mov	r0, r3
   1a95c:	e51b1008 	ldr	r1, [fp, #-8]
   1a960:	e51b200c 	ldr	r2, [fp, #-12]
   1a964:	ebffffa3 	bl	1a7f8 <_setlocale_r>
   1a968:	e1a03000 	mov	r3, r0
}
   1a96c:	e1a00003 	mov	r0, r3
   1a970:	e24bd004 	sub	sp, fp, #4
   1a974:	e8bd4800 	pop	{fp, lr}
   1a978:	e12fff1e 	bx	lr
   1a97c:	00025440 	.word	0x00025440

0001a980 <localeconv>:
#endif /* __CYGWIN__ */

struct lconv *
_DEFUN_VOID(localeconv)
{
   1a980:	e92d4800 	push	{fp, lr}
   1a984:	e28db004 	add	fp, sp, #4
  return _localeconv_r (_REENT);
   1a988:	e59f301c 	ldr	r3, [pc, #28]	; 1a9ac <localeconv+0x2c>
   1a98c:	e5933000 	ldr	r3, [r3]
   1a990:	e1a00003 	mov	r0, r3
   1a994:	ebffffde 	bl	1a914 <_localeconv_r>
   1a998:	e1a03000 	mov	r3, r0
}
   1a99c:	e1a00003 	mov	r0, r3
   1a9a0:	e24bd004 	sub	sp, fp, #4
   1a9a4:	e8bd4800 	pop	{fp, lr}
   1a9a8:	e12fff1e 	bx	lr
   1a9ac:	00025440 	.word	0x00025440

0001a9b0 <__smakebuf_r>:

_VOID
_DEFUN(__smakebuf_r, (ptr, fp),
       struct _reent *ptr _AND
       register FILE *fp)
{
   1a9b0:	e92d48f0 	push	{r4, r5, r6, r7, fp, lr}
   1a9b4:	e28db014 	add	fp, sp, #20
   1a9b8:	e24dd060 	sub	sp, sp, #96	; 0x60
   1a9bc:	e50b0070 	str	r0, [fp, #-112]	; 0x70
   1a9c0:	e1a04001 	mov	r4, r1
  struct stat64 st;
#else
  struct stat st;
#endif

  if (fp->_flags & __SNBF)
   1a9c4:	e1d430bc 	ldrh	r3, [r4, #12]
   1a9c8:	e1a03803 	lsl	r3, r3, #16
   1a9cc:	e1a03823 	lsr	r3, r3, #16
   1a9d0:	e2033002 	and	r3, r3, #2
   1a9d4:	e3530000 	cmp	r3, #0
   1a9d8:	0a000006 	beq	1a9f8 <__smakebuf_r+0x48>
    {
      fp->_bf._base = fp->_p = fp->_nbuf;
   1a9dc:	e2843043 	add	r3, r4, #67	; 0x43
   1a9e0:	e5843000 	str	r3, [r4]
   1a9e4:	e5943000 	ldr	r3, [r4]
   1a9e8:	e5843010 	str	r3, [r4, #16]
      fp->_bf._size = 1;
   1a9ec:	e3a03001 	mov	r3, #1
   1a9f0:	e5843014 	str	r3, [r4, #20]
   1a9f4:	ea000071 	b	1abc0 <__smakebuf_r+0x210>
      return;
    }
#ifdef __USE_INTERNAL_STAT64
  if (fp->_file < 0 || _fstat64_r (ptr, fp->_file, &st) < 0)
#else
  if (fp->_file < 0 || _fstat_r (ptr, fp->_file, &st) < 0)
   1a9f8:	e1d430be 	ldrh	r3, [r4, #14]
   1a9fc:	e1a03803 	lsl	r3, r3, #16
   1aa00:	e1a03843 	asr	r3, r3, #16
   1aa04:	e3530000 	cmp	r3, #0
   1aa08:	ba00000a 	blt	1aa38 <__smakebuf_r+0x88>
   1aa0c:	e1d430be 	ldrh	r3, [r4, #14]
   1aa10:	e1a03803 	lsl	r3, r3, #16
   1aa14:	e1a02843 	asr	r2, r3, #16
   1aa18:	e24b306c 	sub	r3, fp, #108	; 0x6c
   1aa1c:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   1aa20:	e1a01002 	mov	r1, r2
   1aa24:	e1a02003 	mov	r2, r3
   1aa28:	eb001c3a 	bl	21b18 <_fstat_r>
   1aa2c:	e1a03000 	mov	r3, r0
   1aa30:	e3530000 	cmp	r3, #0
   1aa34:	aa00000f 	bge	1aa78 <__smakebuf_r+0xc8>
#endif
    {
      couldbetty = 0;
   1aa38:	e3a06000 	mov	r6, #0
      /* Check if we are be called by asprintf family for initial buffer.  */
      if (fp->_flags & __SMBF)
   1aa3c:	e1d430bc 	ldrh	r3, [r4, #12]
   1aa40:	e1a03803 	lsl	r3, r3, #16
   1aa44:	e1a03823 	lsr	r3, r3, #16
   1aa48:	e2033080 	and	r3, r3, #128	; 0x80
   1aa4c:	e3530000 	cmp	r3, #0
   1aa50:	0a000001 	beq	1aa5c <__smakebuf_r+0xac>
        size = _DEFAULT_ASPRINTF_BUFSIZE;
   1aa54:	e3a05040 	mov	r5, #64	; 0x40
   1aa58:	ea000000 	b	1aa60 <__smakebuf_r+0xb0>
      else
        size = BUFSIZ;
   1aa5c:	e3a05b01 	mov	r5, #1024	; 0x400
#ifdef _FSEEK_OPTIMIZATION
      /* do not try to optimise fseek() */
      fp->_flags |= __SNPT;
   1aa60:	e1d430bc 	ldrh	r3, [r4, #12]
   1aa64:	e3833b02 	orr	r3, r3, #2048	; 0x800
   1aa68:	e1a03803 	lsl	r3, r3, #16
   1aa6c:	e1a03823 	lsr	r3, r3, #16
   1aa70:	e1c430bc 	strh	r3, [r4, #12]
   1aa74:	ea00001c 	b	1aaec <__smakebuf_r+0x13c>
#endif
    }
  else
    {
      couldbetty = (st.st_mode & S_IFMT) == S_IFCHR;
   1aa78:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1aa7c:	e2033a0f 	and	r3, r3, #61440	; 0xf000
   1aa80:	e3530a02 	cmp	r3, #8192	; 0x2000
   1aa84:	03a03001 	moveq	r3, #1
   1aa88:	13a03000 	movne	r3, #0
   1aa8c:	e20330ff 	and	r3, r3, #255	; 0xff
   1aa90:	e1a06003 	mov	r6, r3
#ifdef HAVE_BLKSIZE
      size = st.st_blksize <= 0 ? BUFSIZ : st.st_blksize;
#else
      size = BUFSIZ;
   1aa94:	e3a05b01 	mov	r5, #1024	; 0x400
#ifdef _FSEEK_OPTIMIZATION
      /*
       * Optimize fseek() only if it is a regular file.
       * (The test for __sseek is mainly paranoia.)
       */
      if ((st.st_mode & S_IFMT) == S_IFREG && fp->_seek == __sseek)
   1aa98:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1aa9c:	e2033a0f 	and	r3, r3, #61440	; 0xf000
   1aaa0:	e3530902 	cmp	r3, #32768	; 0x8000
   1aaa4:	1a00000b 	bne	1aad8 <__smakebuf_r+0x128>
   1aaa8:	e5942028 	ldr	r2, [r4, #40]	; 0x28
   1aaac:	e59f3118 	ldr	r3, [pc, #280]	; 1abcc <__smakebuf_r+0x21c>
   1aab0:	e1520003 	cmp	r2, r3
   1aab4:	1a000007 	bne	1aad8 <__smakebuf_r+0x128>
	{
	  fp->_flags |= __SOPT;
   1aab8:	e1d430bc 	ldrh	r3, [r4, #12]
   1aabc:	e3833b01 	orr	r3, r3, #1024	; 0x400
   1aac0:	e1a03803 	lsl	r3, r3, #16
   1aac4:	e1a03823 	lsr	r3, r3, #16
   1aac8:	e1c430bc 	strh	r3, [r4, #12]
#ifdef HAVE_BLKSIZE
	  fp->_blksize = st.st_blksize;
#else
	  fp->_blksize = 1024;
   1aacc:	e3a03b01 	mov	r3, #1024	; 0x400
   1aad0:	e584304c 	str	r3, [r4, #76]	; 0x4c
   1aad4:	ea000004 	b	1aaec <__smakebuf_r+0x13c>
#endif
	}
      else
	fp->_flags |= __SNPT;
   1aad8:	e1d430bc 	ldrh	r3, [r4, #12]
   1aadc:	e3833b02 	orr	r3, r3, #2048	; 0x800
   1aae0:	e1a03803 	lsl	r3, r3, #16
   1aae4:	e1a03823 	lsr	r3, r3, #16
   1aae8:	e1c430bc 	strh	r3, [r4, #12]
#endif
    }
  if ((p = _malloc_r (ptr, size)) == NULL)
   1aaec:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   1aaf0:	e1a01005 	mov	r1, r5
   1aaf4:	ebffd14e 	bl	f034 <_malloc_r>
   1aaf8:	e1a07000 	mov	r7, r0
   1aafc:	e3570000 	cmp	r7, #0
   1ab00:	1a000011 	bne	1ab4c <__smakebuf_r+0x19c>
    {
      if (!(fp->_flags & __SSTR))
   1ab04:	e1d430bc 	ldrh	r3, [r4, #12]
   1ab08:	e1a03803 	lsl	r3, r3, #16
   1ab0c:	e1a03823 	lsr	r3, r3, #16
   1ab10:	e2033c02 	and	r3, r3, #512	; 0x200
   1ab14:	e3530000 	cmp	r3, #0
   1ab18:	1a000028 	bne	1abc0 <__smakebuf_r+0x210>
	{
	  fp->_flags |= __SNBF;
   1ab1c:	e1d430bc 	ldrh	r3, [r4, #12]
   1ab20:	e3833002 	orr	r3, r3, #2
   1ab24:	e1a03803 	lsl	r3, r3, #16
   1ab28:	e1a03823 	lsr	r3, r3, #16
   1ab2c:	e1c430bc 	strh	r3, [r4, #12]
	  fp->_bf._base = fp->_p = fp->_nbuf;
   1ab30:	e2843043 	add	r3, r4, #67	; 0x43
   1ab34:	e5843000 	str	r3, [r4]
   1ab38:	e5943000 	ldr	r3, [r4]
   1ab3c:	e5843010 	str	r3, [r4, #16]
	  fp->_bf._size = 1;
   1ab40:	e3a03001 	mov	r3, #1
   1ab44:	e5843014 	str	r3, [r4, #20]
   1ab48:	ea00001c 	b	1abc0 <__smakebuf_r+0x210>
	}
    }
  else
    {
      ptr->__cleanup = _cleanup_r;
   1ab4c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1ab50:	e59f2078 	ldr	r2, [pc, #120]	; 1abd0 <__smakebuf_r+0x220>
   1ab54:	e583203c 	str	r2, [r3, #60]	; 0x3c
      fp->_flags |= __SMBF;
   1ab58:	e1d430bc 	ldrh	r3, [r4, #12]
   1ab5c:	e3833080 	orr	r3, r3, #128	; 0x80
   1ab60:	e1a03803 	lsl	r3, r3, #16
   1ab64:	e1a03823 	lsr	r3, r3, #16
   1ab68:	e1c430bc 	strh	r3, [r4, #12]
      fp->_bf._base = fp->_p = (unsigned char *) p;
   1ab6c:	e5847000 	str	r7, [r4]
   1ab70:	e5943000 	ldr	r3, [r4]
   1ab74:	e5843010 	str	r3, [r4, #16]
      fp->_bf._size = size;
   1ab78:	e1a03005 	mov	r3, r5
   1ab7c:	e5843014 	str	r3, [r4, #20]
      if (couldbetty && _isatty_r (ptr, fp->_file))
   1ab80:	e3560000 	cmp	r6, #0
   1ab84:	0a00000d 	beq	1abc0 <__smakebuf_r+0x210>
   1ab88:	e1d430be 	ldrh	r3, [r4, #14]
   1ab8c:	e1a03803 	lsl	r3, r3, #16
   1ab90:	e1a03843 	asr	r3, r3, #16
   1ab94:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   1ab98:	e1a01003 	mov	r1, r3
   1ab9c:	eb001bfb 	bl	21b90 <_isatty_r>
   1aba0:	e1a03000 	mov	r3, r0
   1aba4:	e3530000 	cmp	r3, #0
   1aba8:	0a000004 	beq	1abc0 <__smakebuf_r+0x210>
	fp->_flags |= __SLBF;
   1abac:	e1d430bc 	ldrh	r3, [r4, #12]
   1abb0:	e3833001 	orr	r3, r3, #1
   1abb4:	e1a03803 	lsl	r3, r3, #16
   1abb8:	e1a03823 	lsr	r3, r3, #16
   1abbc:	e1c430bc 	strh	r3, [r4, #12]
    }
}
   1abc0:	e24bd014 	sub	sp, fp, #20
   1abc4:	e8bd48f0 	pop	{r4, r5, r6, r7, fp, lr}
   1abc8:	e12fff1e 	bx	lr
   1abcc:	0001dcfc 	.word	0x0001dcfc
   1abd0:	000195ec 	.word	0x000195ec

0001abd4 <memchr>:
_PTR
_DEFUN (memchr, (src_void, c, length),
	_CONST _PTR src_void _AND
	int c _AND
	size_t length)
{
   1abd4:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   1abd8:	e28db000 	add	fp, sp, #0
   1abdc:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   1abe0:	e50b0020 	str	r0, [fp, #-32]
   1abe4:	e50b1024 	str	r1, [fp, #-36]	; 0x24
   1abe8:	e50b2028 	str	r2, [fp, #-40]	; 0x28
  _CONST unsigned char *src = (_CONST unsigned char *) src_void;
   1abec:	e51b3020 	ldr	r3, [fp, #-32]
   1abf0:	e50b3008 	str	r3, [fp, #-8]
  unsigned char d = c;
   1abf4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1abf8:	e54b3015 	strb	r3, [fp, #-21]
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  int i;

  while (UNALIGNED (src))
   1abfc:	ea000010 	b	1ac44 <memchr+0x70>
    {
      if (!length--)
   1ac00:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1ac04:	e2432001 	sub	r2, r3, #1
   1ac08:	e50b2028 	str	r2, [fp, #-40]	; 0x28
   1ac0c:	e3530000 	cmp	r3, #0
   1ac10:	1a000001 	bne	1ac1c <memchr+0x48>
        return NULL;
   1ac14:	e3a03000 	mov	r3, #0
   1ac18:	ea000059 	b	1ad84 <memchr+0x1b0>
      if (*src == d)
   1ac1c:	e51b3008 	ldr	r3, [fp, #-8]
   1ac20:	e5d33000 	ldrb	r3, [r3]
   1ac24:	e55b2015 	ldrb	r2, [fp, #-21]
   1ac28:	e1520003 	cmp	r2, r3
   1ac2c:	1a000001 	bne	1ac38 <memchr+0x64>
        return (void *) src;
   1ac30:	e51b3008 	ldr	r3, [fp, #-8]
   1ac34:	ea000052 	b	1ad84 <memchr+0x1b0>
      src++;
   1ac38:	e51b3008 	ldr	r3, [fp, #-8]
   1ac3c:	e2833001 	add	r3, r3, #1
   1ac40:	e50b3008 	str	r3, [fp, #-8]
#if !defined(PREFER_SIZE_OVER_SPEED) && !defined(__OPTIMIZE_SIZE__)
  unsigned long *asrc;
  unsigned long  mask;
  int i;

  while (UNALIGNED (src))
   1ac44:	e51b3008 	ldr	r3, [fp, #-8]
   1ac48:	e2033003 	and	r3, r3, #3
   1ac4c:	e3530000 	cmp	r3, #0
   1ac50:	1affffea 	bne	1ac00 <memchr+0x2c>
      if (*src == d)
        return (void *) src;
      src++;
    }

  if (!TOO_SMALL (length))
   1ac54:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1ac58:	e3530003 	cmp	r3, #3
   1ac5c:	9a000037 	bls	1ad40 <memchr+0x16c>
         performs the bytewise search on word-sized segments if they
         contain the search character, which is detected by XORing
         the word-sized segment with a word-sized block of the search
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
   1ac60:	e51b3008 	ldr	r3, [fp, #-8]
   1ac64:	e50b300c 	str	r3, [fp, #-12]
      mask = d << 8 | d;
   1ac68:	e55b3015 	ldrb	r3, [fp, #-21]
   1ac6c:	e1a02403 	lsl	r2, r3, #8
   1ac70:	e55b3015 	ldrb	r3, [fp, #-21]
   1ac74:	e1823003 	orr	r3, r2, r3
   1ac78:	e50b3010 	str	r3, [fp, #-16]
      mask = mask << 16 | mask;
   1ac7c:	e51b3010 	ldr	r3, [fp, #-16]
   1ac80:	e1a03803 	lsl	r3, r3, #16
   1ac84:	e51b2010 	ldr	r2, [fp, #-16]
   1ac88:	e1823003 	orr	r3, r2, r3
   1ac8c:	e50b3010 	str	r3, [fp, #-16]
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
   1ac90:	e3a03020 	mov	r3, #32
   1ac94:	e50b3014 	str	r3, [fp, #-20]
   1ac98:	ea000008 	b	1acc0 <memchr+0xec>
        mask = (mask << i) | mask;
   1ac9c:	e51b2010 	ldr	r2, [fp, #-16]
   1aca0:	e51b3014 	ldr	r3, [fp, #-20]
   1aca4:	e1a03312 	lsl	r3, r2, r3
   1aca8:	e51b2010 	ldr	r2, [fp, #-16]
   1acac:	e1823003 	orr	r3, r2, r3
   1acb0:	e50b3010 	str	r3, [fp, #-16]
         character and then detecting for the presence of NUL in the
         result.  */
      asrc = (unsigned long *) src;
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
   1acb4:	e51b3014 	ldr	r3, [fp, #-20]
   1acb8:	e1a03083 	lsl	r3, r3, #1
   1acbc:	e50b3014 	str	r3, [fp, #-20]
   1acc0:	e51b3014 	ldr	r3, [fp, #-20]
   1acc4:	e353001f 	cmp	r3, #31
   1acc8:	9afffff3 	bls	1ac9c <memchr+0xc8>
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
   1accc:	ea000016 	b	1ad2c <memchr+0x158>
        {
          if (DETECTCHAR (*asrc, mask))
   1acd0:	e51b300c 	ldr	r3, [fp, #-12]
   1acd4:	e5932000 	ldr	r2, [r3]
   1acd8:	e51b3010 	ldr	r3, [fp, #-16]
   1acdc:	e0222003 	eor	r2, r2, r3
   1ace0:	e59f30ac 	ldr	r3, [pc, #172]	; 1ad94 <memchr+0x1c0>
   1ace4:	e0823003 	add	r3, r2, r3
   1ace8:	e51b200c 	ldr	r2, [fp, #-12]
   1acec:	e5921000 	ldr	r1, [r2]
   1acf0:	e51b2010 	ldr	r2, [fp, #-16]
   1acf4:	e0222001 	eor	r2, r2, r1
   1acf8:	e1e02002 	mvn	r2, r2
   1acfc:	e0022003 	and	r2, r2, r3
   1ad00:	e59f3090 	ldr	r3, [pc, #144]	; 1ad98 <memchr+0x1c4>
   1ad04:	e0033002 	and	r3, r3, r2
   1ad08:	e3530000 	cmp	r3, #0
   1ad0c:	0a000000 	beq	1ad14 <memchr+0x140>
            break;
   1ad10:	ea000008 	b	1ad38 <memchr+0x164>
          length -= LBLOCKSIZE;
   1ad14:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1ad18:	e2433004 	sub	r3, r3, #4
   1ad1c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
          asrc++;
   1ad20:	e51b300c 	ldr	r3, [fp, #-12]
   1ad24:	e2833004 	add	r3, r3, #4
   1ad28:	e50b300c 	str	r3, [fp, #-12]
      mask = d << 8 | d;
      mask = mask << 16 | mask;
      for (i = 32; i < LBLOCKSIZE * 8; i <<= 1)
        mask = (mask << i) | mask;

      while (length >= LBLOCKSIZE)
   1ad2c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1ad30:	e3530003 	cmp	r3, #3
   1ad34:	8affffe5 	bhi	1acd0 <memchr+0xfc>
        }

      /* If there are fewer than LBLOCKSIZE characters left,
         then we resort to the bytewise loop.  */

      src = (unsigned char *) asrc;
   1ad38:	e51b300c 	ldr	r3, [fp, #-12]
   1ad3c:	e50b3008 	str	r3, [fp, #-8]
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
   1ad40:	ea000009 	b	1ad6c <memchr+0x198>
    {
      if (*src == d)
   1ad44:	e51b3008 	ldr	r3, [fp, #-8]
   1ad48:	e5d33000 	ldrb	r3, [r3]
   1ad4c:	e55b2015 	ldrb	r2, [fp, #-21]
   1ad50:	e1520003 	cmp	r2, r3
   1ad54:	1a000001 	bne	1ad60 <memchr+0x18c>
        return (void *) src;
   1ad58:	e51b3008 	ldr	r3, [fp, #-8]
   1ad5c:	ea000008 	b	1ad84 <memchr+0x1b0>
      src++;
   1ad60:	e51b3008 	ldr	r3, [fp, #-8]
   1ad64:	e2833001 	add	r3, r3, #1
   1ad68:	e50b3008 	str	r3, [fp, #-8]
      src = (unsigned char *) asrc;
    }

#endif /* not PREFER_SIZE_OVER_SPEED */

  while (length--)
   1ad6c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1ad70:	e2432001 	sub	r2, r3, #1
   1ad74:	e50b2028 	str	r2, [fp, #-40]	; 0x28
   1ad78:	e3530000 	cmp	r3, #0
   1ad7c:	1afffff0 	bne	1ad44 <memchr+0x170>
      if (*src == d)
        return (void *) src;
      src++;
    }

  return NULL;
   1ad80:	e3a03000 	mov	r3, #0
}
   1ad84:	e1a00003 	mov	r0, r3
   1ad88:	e24bd000 	sub	sp, fp, #0
   1ad8c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1ad90:	e12fff1e 	bx	lr
   1ad94:	fefefeff 	.word	0xfefefeff
   1ad98:	80808080 	.word	0x80808080

0001ad9c <memmove>:
_PTR
_DEFUN (memmove, (dst_void, src_void, length),
	_PTR dst_void _AND
	_CONST _PTR src_void _AND
	size_t length)
{
   1ad9c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   1ada0:	e28db000 	add	fp, sp, #0
   1ada4:	e24dd024 	sub	sp, sp, #36	; 0x24
   1ada8:	e50b0018 	str	r0, [fp, #-24]
   1adac:	e50b101c 	str	r1, [fp, #-28]
   1adb0:	e50b2020 	str	r2, [fp, #-32]
	}
    }

  return dst_void;
#else
  char *dst = dst_void;
   1adb4:	e51b3018 	ldr	r3, [fp, #-24]
   1adb8:	e50b3008 	str	r3, [fp, #-8]
  _CONST char *src = src_void;
   1adbc:	e51b301c 	ldr	r3, [fp, #-28]
   1adc0:	e50b300c 	str	r3, [fp, #-12]
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
   1adc4:	e51b200c 	ldr	r2, [fp, #-12]
   1adc8:	e51b3008 	ldr	r3, [fp, #-8]
   1adcc:	e1520003 	cmp	r2, r3
   1add0:	2a00001e 	bcs	1ae50 <memmove+0xb4>
   1add4:	e51b200c 	ldr	r2, [fp, #-12]
   1add8:	e51b3020 	ldr	r3, [fp, #-32]
   1addc:	e0822003 	add	r2, r2, r3
   1ade0:	e51b3008 	ldr	r3, [fp, #-8]
   1ade4:	e1520003 	cmp	r2, r3
   1ade8:	9a000018 	bls	1ae50 <memmove+0xb4>
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
   1adec:	e51b200c 	ldr	r2, [fp, #-12]
   1adf0:	e51b3020 	ldr	r3, [fp, #-32]
   1adf4:	e0823003 	add	r3, r2, r3
   1adf8:	e50b300c 	str	r3, [fp, #-12]
      dst += length;
   1adfc:	e51b2008 	ldr	r2, [fp, #-8]
   1ae00:	e51b3020 	ldr	r3, [fp, #-32]
   1ae04:	e0823003 	add	r3, r2, r3
   1ae08:	e50b3008 	str	r3, [fp, #-8]
      while (length--)
   1ae0c:	ea000009 	b	1ae38 <memmove+0x9c>
	{
	  *--dst = *--src;
   1ae10:	e51b3008 	ldr	r3, [fp, #-8]
   1ae14:	e2433001 	sub	r3, r3, #1
   1ae18:	e50b3008 	str	r3, [fp, #-8]
   1ae1c:	e51b300c 	ldr	r3, [fp, #-12]
   1ae20:	e2433001 	sub	r3, r3, #1
   1ae24:	e50b300c 	str	r3, [fp, #-12]
   1ae28:	e51b300c 	ldr	r3, [fp, #-12]
   1ae2c:	e5d32000 	ldrb	r2, [r3]
   1ae30:	e51b3008 	ldr	r3, [fp, #-8]
   1ae34:	e5c32000 	strb	r2, [r3]
  if (src < dst && dst < src + length)
    {
      /* Destructive overlap...have to copy backwards */
      src += length;
      dst += length;
      while (length--)
   1ae38:	e51b3020 	ldr	r3, [fp, #-32]
   1ae3c:	e2432001 	sub	r2, r3, #1
   1ae40:	e50b2020 	str	r2, [fp, #-32]
   1ae44:	e3530000 	cmp	r3, #0
   1ae48:	1afffff0 	bne	1ae10 <memmove+0x74>
  char *dst = dst_void;
  _CONST char *src = src_void;
  long *aligned_dst;
  _CONST long *aligned_src;

  if (src < dst && dst < src + length)
   1ae4c:	ea000054 	b	1afa4 <memmove+0x208>
  else
    {
      /* Use optimizing algorithm for a non-destructive copy to closely 
         match memcpy. If the size is small or either SRC or DST is unaligned,
         then punt into the byte copy loop.  This should be rare.  */
      if (!TOO_SMALL(length) && !UNALIGNED (src, dst))
   1ae50:	e51b3020 	ldr	r3, [fp, #-32]
   1ae54:	e353000f 	cmp	r3, #15
   1ae58:	9a000043 	bls	1af6c <memmove+0x1d0>
   1ae5c:	e51b200c 	ldr	r2, [fp, #-12]
   1ae60:	e51b3008 	ldr	r3, [fp, #-8]
   1ae64:	e1823003 	orr	r3, r2, r3
   1ae68:	e2033003 	and	r3, r3, #3
   1ae6c:	e3530000 	cmp	r3, #0
   1ae70:	1a00003d 	bne	1af6c <memmove+0x1d0>
        {
          aligned_dst = (long*)dst;
   1ae74:	e51b3008 	ldr	r3, [fp, #-8]
   1ae78:	e50b3010 	str	r3, [fp, #-16]
          aligned_src = (long*)src;
   1ae7c:	e51b300c 	ldr	r3, [fp, #-12]
   1ae80:	e50b3014 	str	r3, [fp, #-20]

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
   1ae84:	ea000022 	b	1af14 <memmove+0x178>
            {
              *aligned_dst++ = *aligned_src++;
   1ae88:	e51b3010 	ldr	r3, [fp, #-16]
   1ae8c:	e2832004 	add	r2, r3, #4
   1ae90:	e50b2010 	str	r2, [fp, #-16]
   1ae94:	e51b2014 	ldr	r2, [fp, #-20]
   1ae98:	e2821004 	add	r1, r2, #4
   1ae9c:	e50b1014 	str	r1, [fp, #-20]
   1aea0:	e5922000 	ldr	r2, [r2]
   1aea4:	e5832000 	str	r2, [r3]
              *aligned_dst++ = *aligned_src++;
   1aea8:	e51b3010 	ldr	r3, [fp, #-16]
   1aeac:	e2832004 	add	r2, r3, #4
   1aeb0:	e50b2010 	str	r2, [fp, #-16]
   1aeb4:	e51b2014 	ldr	r2, [fp, #-20]
   1aeb8:	e2821004 	add	r1, r2, #4
   1aebc:	e50b1014 	str	r1, [fp, #-20]
   1aec0:	e5922000 	ldr	r2, [r2]
   1aec4:	e5832000 	str	r2, [r3]
              *aligned_dst++ = *aligned_src++;
   1aec8:	e51b3010 	ldr	r3, [fp, #-16]
   1aecc:	e2832004 	add	r2, r3, #4
   1aed0:	e50b2010 	str	r2, [fp, #-16]
   1aed4:	e51b2014 	ldr	r2, [fp, #-20]
   1aed8:	e2821004 	add	r1, r2, #4
   1aedc:	e50b1014 	str	r1, [fp, #-20]
   1aee0:	e5922000 	ldr	r2, [r2]
   1aee4:	e5832000 	str	r2, [r3]
              *aligned_dst++ = *aligned_src++;
   1aee8:	e51b3010 	ldr	r3, [fp, #-16]
   1aeec:	e2832004 	add	r2, r3, #4
   1aef0:	e50b2010 	str	r2, [fp, #-16]
   1aef4:	e51b2014 	ldr	r2, [fp, #-20]
   1aef8:	e2821004 	add	r1, r2, #4
   1aefc:	e50b1014 	str	r1, [fp, #-20]
   1af00:	e5922000 	ldr	r2, [r2]
   1af04:	e5832000 	str	r2, [r3]
              length -= BIGBLOCKSIZE;
   1af08:	e51b3020 	ldr	r3, [fp, #-32]
   1af0c:	e2433010 	sub	r3, r3, #16
   1af10:	e50b3020 	str	r3, [fp, #-32]
        {
          aligned_dst = (long*)dst;
          aligned_src = (long*)src;

          /* Copy 4X long words at a time if possible.  */
          while (length >= BIGBLOCKSIZE)
   1af14:	e51b3020 	ldr	r3, [fp, #-32]
   1af18:	e353000f 	cmp	r3, #15
   1af1c:	8affffd9 	bhi	1ae88 <memmove+0xec>
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   1af20:	ea00000a 	b	1af50 <memmove+0x1b4>
            {
              *aligned_dst++ = *aligned_src++;
   1af24:	e51b3010 	ldr	r3, [fp, #-16]
   1af28:	e2832004 	add	r2, r3, #4
   1af2c:	e50b2010 	str	r2, [fp, #-16]
   1af30:	e51b2014 	ldr	r2, [fp, #-20]
   1af34:	e2821004 	add	r1, r2, #4
   1af38:	e50b1014 	str	r1, [fp, #-20]
   1af3c:	e5922000 	ldr	r2, [r2]
   1af40:	e5832000 	str	r2, [r3]
              length -= LITTLEBLOCKSIZE;
   1af44:	e51b3020 	ldr	r3, [fp, #-32]
   1af48:	e2433004 	sub	r3, r3, #4
   1af4c:	e50b3020 	str	r3, [fp, #-32]
              *aligned_dst++ = *aligned_src++;
              length -= BIGBLOCKSIZE;
            }

          /* Copy one long word at a time if possible.  */
          while (length >= LITTLEBLOCKSIZE)
   1af50:	e51b3020 	ldr	r3, [fp, #-32]
   1af54:	e3530003 	cmp	r3, #3
   1af58:	8afffff1 	bhi	1af24 <memmove+0x188>
              *aligned_dst++ = *aligned_src++;
              length -= LITTLEBLOCKSIZE;
            }

          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
   1af5c:	e51b3010 	ldr	r3, [fp, #-16]
   1af60:	e50b3008 	str	r3, [fp, #-8]
          src = (char*)aligned_src;
   1af64:	e51b3014 	ldr	r3, [fp, #-20]
   1af68:	e50b300c 	str	r3, [fp, #-12]
        }

      while (length--)
   1af6c:	ea000007 	b	1af90 <memmove+0x1f4>
        {
          *dst++ = *src++;
   1af70:	e51b3008 	ldr	r3, [fp, #-8]
   1af74:	e2832001 	add	r2, r3, #1
   1af78:	e50b2008 	str	r2, [fp, #-8]
   1af7c:	e51b200c 	ldr	r2, [fp, #-12]
   1af80:	e2821001 	add	r1, r2, #1
   1af84:	e50b100c 	str	r1, [fp, #-12]
   1af88:	e5d22000 	ldrb	r2, [r2]
   1af8c:	e5c32000 	strb	r2, [r3]
          /* Pick up any residual with a byte copier.  */
          dst = (char*)aligned_dst;
          src = (char*)aligned_src;
        }

      while (length--)
   1af90:	e51b3020 	ldr	r3, [fp, #-32]
   1af94:	e2432001 	sub	r2, r3, #1
   1af98:	e50b2020 	str	r2, [fp, #-32]
   1af9c:	e3530000 	cmp	r3, #0
   1afa0:	1afffff2 	bne	1af70 <memmove+0x1d4>
        {
          *dst++ = *src++;
        }
    }

  return dst_void;
   1afa4:	e51b3018 	ldr	r3, [fp, #-24]
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   1afa8:	e1a00003 	mov	r0, r3
   1afac:	e24bd000 	sub	sp, fp, #0
   1afb0:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1afb4:	e12fff1e 	bx	lr

0001afb8 <_Balloc>:
#define _Kmax 15
*/

_Bigint *
_DEFUN (Balloc, (ptr, k), struct _reent *ptr _AND int k)
{
   1afb8:	e92d4800 	push	{fp, lr}
   1afbc:	e28db004 	add	fp, sp, #4
   1afc0:	e24dd010 	sub	sp, sp, #16
   1afc4:	e50b0010 	str	r0, [fp, #-16]
   1afc8:	e50b1014 	str	r1, [fp, #-20]
  int x;
  _Bigint *rv ;

  _REENT_CHECK_MP(ptr);
  if (_REENT_MP_FREELIST(ptr) == NULL)
   1afcc:	e51b3010 	ldr	r3, [fp, #-16]
   1afd0:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
   1afd4:	e3530000 	cmp	r3, #0
   1afd8:	1a00000c 	bne	1b010 <_Balloc+0x58>
    {
      /* Allocate a list of pointers to the mprec objects */
      _REENT_MP_FREELIST(ptr) = (struct _Bigint **) _calloc_r (ptr, 
   1afdc:	e51b0010 	ldr	r0, [fp, #-16]
   1afe0:	e3a01004 	mov	r1, #4
   1afe4:	e3a02021 	mov	r2, #33	; 0x21
   1afe8:	eb0018de 	bl	21368 <_calloc_r>
   1afec:	e1a02000 	mov	r2, r0
   1aff0:	e51b3010 	ldr	r3, [fp, #-16]
   1aff4:	e583204c 	str	r2, [r3, #76]	; 0x4c
						      sizeof (struct _Bigint *),
						      _Kmax + 1);
      if (_REENT_MP_FREELIST(ptr) == NULL)
   1aff8:	e51b3010 	ldr	r3, [fp, #-16]
   1affc:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
   1b000:	e3530000 	cmp	r3, #0
   1b004:	1a000001 	bne	1b010 <_Balloc+0x58>
	{
	  return NULL;
   1b008:	e3a03000 	mov	r3, #0
   1b00c:	ea000031 	b	1b0d8 <_Balloc+0x120>
	}
    }

  if ((rv = _REENT_MP_FREELIST(ptr)[k]) != 0)
   1b010:	e51b3010 	ldr	r3, [fp, #-16]
   1b014:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
   1b018:	e51b3014 	ldr	r3, [fp, #-20]
   1b01c:	e1a03103 	lsl	r3, r3, #2
   1b020:	e0823003 	add	r3, r2, r3
   1b024:	e5933000 	ldr	r3, [r3]
   1b028:	e50b3008 	str	r3, [fp, #-8]
   1b02c:	e51b3008 	ldr	r3, [fp, #-8]
   1b030:	e3530000 	cmp	r3, #0
   1b034:	0a000008 	beq	1b05c <_Balloc+0xa4>
    {
      _REENT_MP_FREELIST(ptr)[k] = rv->_next;
   1b038:	e51b3010 	ldr	r3, [fp, #-16]
   1b03c:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
   1b040:	e51b3014 	ldr	r3, [fp, #-20]
   1b044:	e1a03103 	lsl	r3, r3, #2
   1b048:	e0823003 	add	r3, r2, r3
   1b04c:	e51b2008 	ldr	r2, [fp, #-8]
   1b050:	e5922000 	ldr	r2, [r2]
   1b054:	e5832000 	str	r2, [r3]
   1b058:	ea000016 	b	1b0b8 <_Balloc+0x100>
    }
  else
    {
      x = 1 << k;
   1b05c:	e3a02001 	mov	r2, #1
   1b060:	e51b3014 	ldr	r3, [fp, #-20]
   1b064:	e1a03312 	lsl	r3, r2, r3
   1b068:	e50b300c 	str	r3, [fp, #-12]
      /* Allocate an mprec Bigint and stick in in the freelist */
      rv = (_Bigint *) _calloc_r (ptr,
				  1,
				  sizeof (_Bigint) +
   1b06c:	e51b300c 	ldr	r3, [fp, #-12]
    }
  else
    {
      x = 1 << k;
      /* Allocate an mprec Bigint and stick in in the freelist */
      rv = (_Bigint *) _calloc_r (ptr,
   1b070:	e2833005 	add	r3, r3, #5
   1b074:	e1a03103 	lsl	r3, r3, #2
   1b078:	e51b0010 	ldr	r0, [fp, #-16]
   1b07c:	e3a01001 	mov	r1, #1
   1b080:	e1a02003 	mov	r2, r3
   1b084:	eb0018b7 	bl	21368 <_calloc_r>
   1b088:	e50b0008 	str	r0, [fp, #-8]
				  1,
				  sizeof (_Bigint) +
				  (x-1) * sizeof(rv->_x));
      if (rv == NULL) return NULL;
   1b08c:	e51b3008 	ldr	r3, [fp, #-8]
   1b090:	e3530000 	cmp	r3, #0
   1b094:	1a000001 	bne	1b0a0 <_Balloc+0xe8>
   1b098:	e3a03000 	mov	r3, #0
   1b09c:	ea00000d 	b	1b0d8 <_Balloc+0x120>
      rv->_k = k;
   1b0a0:	e51b3008 	ldr	r3, [fp, #-8]
   1b0a4:	e51b2014 	ldr	r2, [fp, #-20]
   1b0a8:	e5832004 	str	r2, [r3, #4]
      rv->_maxwds = x;
   1b0ac:	e51b3008 	ldr	r3, [fp, #-8]
   1b0b0:	e51b200c 	ldr	r2, [fp, #-12]
   1b0b4:	e5832008 	str	r2, [r3, #8]
    }
  rv->_sign = rv->_wds = 0;
   1b0b8:	e51b3008 	ldr	r3, [fp, #-8]
   1b0bc:	e3a02000 	mov	r2, #0
   1b0c0:	e5832010 	str	r2, [r3, #16]
   1b0c4:	e51b3008 	ldr	r3, [fp, #-8]
   1b0c8:	e5932010 	ldr	r2, [r3, #16]
   1b0cc:	e51b3008 	ldr	r3, [fp, #-8]
   1b0d0:	e583200c 	str	r2, [r3, #12]
  return rv;
   1b0d4:	e51b3008 	ldr	r3, [fp, #-8]
}
   1b0d8:	e1a00003 	mov	r0, r3
   1b0dc:	e24bd004 	sub	sp, fp, #4
   1b0e0:	e8bd4800 	pop	{fp, lr}
   1b0e4:	e12fff1e 	bx	lr

0001b0e8 <_Bfree>:

void
_DEFUN (Bfree, (ptr, v), struct _reent *ptr _AND _Bigint * v)
{
   1b0e8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   1b0ec:	e28db000 	add	fp, sp, #0
   1b0f0:	e24dd00c 	sub	sp, sp, #12
   1b0f4:	e50b0008 	str	r0, [fp, #-8]
   1b0f8:	e50b100c 	str	r1, [fp, #-12]
  _REENT_CHECK_MP(ptr);
  if (v)
   1b0fc:	e51b300c 	ldr	r3, [fp, #-12]
   1b100:	e3530000 	cmp	r3, #0
   1b104:	0a000010 	beq	1b14c <_Bfree+0x64>
    {
      v->_next = _REENT_MP_FREELIST(ptr)[v->_k];
   1b108:	e51b3008 	ldr	r3, [fp, #-8]
   1b10c:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
   1b110:	e51b300c 	ldr	r3, [fp, #-12]
   1b114:	e5933004 	ldr	r3, [r3, #4]
   1b118:	e1a03103 	lsl	r3, r3, #2
   1b11c:	e0823003 	add	r3, r2, r3
   1b120:	e5932000 	ldr	r2, [r3]
   1b124:	e51b300c 	ldr	r3, [fp, #-12]
   1b128:	e5832000 	str	r2, [r3]
      _REENT_MP_FREELIST(ptr)[v->_k] = v;
   1b12c:	e51b3008 	ldr	r3, [fp, #-8]
   1b130:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
   1b134:	e51b300c 	ldr	r3, [fp, #-12]
   1b138:	e5933004 	ldr	r3, [r3, #4]
   1b13c:	e1a03103 	lsl	r3, r3, #2
   1b140:	e0823003 	add	r3, r2, r3
   1b144:	e51b200c 	ldr	r2, [fp, #-12]
   1b148:	e5832000 	str	r2, [r3]
    }
}
   1b14c:	e24bd000 	sub	sp, fp, #0
   1b150:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1b154:	e12fff1e 	bx	lr

0001b158 <__multadd>:
_DEFUN (multadd, (ptr, b, m, a),
	struct _reent *ptr _AND
	_Bigint * b _AND
	int m _AND
	int a)
{
   1b158:	e92d4800 	push	{fp, lr}
   1b15c:	e28db004 	add	fp, sp, #4
   1b160:	e24dd030 	sub	sp, sp, #48	; 0x30
   1b164:	e50b0028 	str	r0, [fp, #-40]	; 0x28
   1b168:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
   1b16c:	e50b2030 	str	r2, [fp, #-48]	; 0x30
   1b170:	e50b3034 	str	r3, [fp, #-52]	; 0x34
#ifdef Pack_32
  __ULong xi, z;
#endif
  _Bigint *b1;

  wds = b->_wds;
   1b174:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1b178:	e5933010 	ldr	r3, [r3, #16]
   1b17c:	e50b3010 	str	r3, [fp, #-16]
  x = b->_x;
   1b180:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1b184:	e2833014 	add	r3, r3, #20
   1b188:	e50b300c 	str	r3, [fp, #-12]
  i = 0;
   1b18c:	e3a03000 	mov	r3, #0
   1b190:	e50b3008 	str	r3, [fp, #-8]
  do
    {
#ifdef Pack_32
      xi = *x;
   1b194:	e51b300c 	ldr	r3, [fp, #-12]
   1b198:	e5933000 	ldr	r3, [r3]
   1b19c:	e50b3014 	str	r3, [fp, #-20]
      y = (xi & 0xffff) * m + a;
   1b1a0:	e51b3014 	ldr	r3, [fp, #-20]
   1b1a4:	e1a03803 	lsl	r3, r3, #16
   1b1a8:	e1a03823 	lsr	r3, r3, #16
   1b1ac:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   1b1b0:	e0020293 	mul	r2, r3, r2
   1b1b4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1b1b8:	e0823003 	add	r3, r2, r3
   1b1bc:	e50b3018 	str	r3, [fp, #-24]
      z = (xi >> 16) * m + (y >> 16);
   1b1c0:	e51b3014 	ldr	r3, [fp, #-20]
   1b1c4:	e1a03823 	lsr	r3, r3, #16
   1b1c8:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   1b1cc:	e0020293 	mul	r2, r3, r2
   1b1d0:	e51b3018 	ldr	r3, [fp, #-24]
   1b1d4:	e1a03823 	lsr	r3, r3, #16
   1b1d8:	e0823003 	add	r3, r2, r3
   1b1dc:	e50b301c 	str	r3, [fp, #-28]
      a = (int) (z >> 16);
   1b1e0:	e51b301c 	ldr	r3, [fp, #-28]
   1b1e4:	e1a03823 	lsr	r3, r3, #16
   1b1e8:	e50b3034 	str	r3, [fp, #-52]	; 0x34
      *x++ = (z << 16) + (y & 0xffff);
   1b1ec:	e51b200c 	ldr	r2, [fp, #-12]
   1b1f0:	e2823004 	add	r3, r2, #4
   1b1f4:	e50b300c 	str	r3, [fp, #-12]
   1b1f8:	e51b301c 	ldr	r3, [fp, #-28]
   1b1fc:	e1a01803 	lsl	r1, r3, #16
   1b200:	e51b3018 	ldr	r3, [fp, #-24]
   1b204:	e1a03803 	lsl	r3, r3, #16
   1b208:	e1a03823 	lsr	r3, r3, #16
   1b20c:	e0813003 	add	r3, r1, r3
   1b210:	e5823000 	str	r3, [r2]
      y = *x * m + a;
      a = (int) (y >> 16);
      *x++ = y & 0xffff;
#endif
    }
  while (++i < wds);
   1b214:	e51b3008 	ldr	r3, [fp, #-8]
   1b218:	e2833001 	add	r3, r3, #1
   1b21c:	e50b3008 	str	r3, [fp, #-8]
   1b220:	e51b2008 	ldr	r2, [fp, #-8]
   1b224:	e51b3010 	ldr	r3, [fp, #-16]
   1b228:	e1520003 	cmp	r2, r3
   1b22c:	baffffd8 	blt	1b194 <__multadd+0x3c>
  if (a)
   1b230:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1b234:	e3530000 	cmp	r3, #0
   1b238:	0a00002a 	beq	1b2e8 <__multadd+0x190>
    {
      if (wds >= b->_maxwds)
   1b23c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1b240:	e5932008 	ldr	r2, [r3, #8]
   1b244:	e51b3010 	ldr	r3, [fp, #-16]
   1b248:	e1520003 	cmp	r2, r3
   1b24c:	ca000017 	bgt	1b2b0 <__multadd+0x158>
	{
	  b1 = Balloc (ptr, b->_k + 1);
   1b250:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1b254:	e5933004 	ldr	r3, [r3, #4]
   1b258:	e2833001 	add	r3, r3, #1
   1b25c:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
   1b260:	e1a01003 	mov	r1, r3
   1b264:	ebffff53 	bl	1afb8 <_Balloc>
   1b268:	e50b0020 	str	r0, [fp, #-32]
	  Bcopy (b1, b);
   1b26c:	e51b3020 	ldr	r3, [fp, #-32]
   1b270:	e283100c 	add	r1, r3, #12
   1b274:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1b278:	e283200c 	add	r2, r3, #12
   1b27c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1b280:	e5933010 	ldr	r3, [r3, #16]
   1b284:	e2833002 	add	r3, r3, #2
   1b288:	e1a03103 	lsl	r3, r3, #2
   1b28c:	e1a00001 	mov	r0, r1
   1b290:	e1a01002 	mov	r1, r2
   1b294:	e1a02003 	mov	r2, r3
   1b298:	ebffd22c 	bl	fb50 <memcpy>
	  Bfree (ptr, b);
   1b29c:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
   1b2a0:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
   1b2a4:	ebffff8f 	bl	1b0e8 <_Bfree>
	  b = b1;
   1b2a8:	e51b3020 	ldr	r3, [fp, #-32]
   1b2ac:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	}
      b->_x[wds++] = a;
   1b2b0:	e51b3010 	ldr	r3, [fp, #-16]
   1b2b4:	e2832001 	add	r2, r3, #1
   1b2b8:	e50b2010 	str	r2, [fp, #-16]
   1b2bc:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   1b2c0:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
   1b2c4:	e2831004 	add	r1, r3, #4
   1b2c8:	e3a03004 	mov	r3, #4
   1b2cc:	e1a01101 	lsl	r1, r1, #2
   1b2d0:	e0801001 	add	r1, r0, r1
   1b2d4:	e0813003 	add	r3, r1, r3
   1b2d8:	e5832000 	str	r2, [r3]
      b->_wds = wds;
   1b2dc:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1b2e0:	e51b2010 	ldr	r2, [fp, #-16]
   1b2e4:	e5832010 	str	r2, [r3, #16]
    }
  return b;
   1b2e8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
}
   1b2ec:	e1a00003 	mov	r0, r3
   1b2f0:	e24bd004 	sub	sp, fp, #4
   1b2f4:	e8bd4800 	pop	{fp, lr}
   1b2f8:	e12fff1e 	bx	lr

0001b2fc <__s2b>:
	struct _reent * ptr _AND
	_CONST char *s _AND
	int nd0 _AND
	int nd _AND
	__ULong y9)
{
   1b2fc:	e92d4800 	push	{fp, lr}
   1b300:	e28db004 	add	fp, sp, #4
   1b304:	e24dd028 	sub	sp, sp, #40	; 0x28
   1b308:	e50b0020 	str	r0, [fp, #-32]
   1b30c:	e50b1024 	str	r1, [fp, #-36]	; 0x24
   1b310:	e50b2028 	str	r2, [fp, #-40]	; 0x28
   1b314:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
  _Bigint *b;
  int i, k;
  __Long x, y;

  x = (nd + 8) / 9;
   1b318:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1b31c:	e2833008 	add	r3, r3, #8
   1b320:	e59f2150 	ldr	r2, [pc, #336]	; 1b478 <__s2b+0x17c>
   1b324:	e0c21293 	smull	r1, r2, r3, r2
   1b328:	e1a020c2 	asr	r2, r2, #1
   1b32c:	e1a03fc3 	asr	r3, r3, #31
   1b330:	e0633002 	rsb	r3, r3, r2
   1b334:	e50b3018 	str	r3, [fp, #-24]
  for (k = 0, y = 1; x > y; y <<= 1, k++);
   1b338:	e3a03000 	mov	r3, #0
   1b33c:	e50b3010 	str	r3, [fp, #-16]
   1b340:	e3a03001 	mov	r3, #1
   1b344:	e50b3014 	str	r3, [fp, #-20]
   1b348:	ea000005 	b	1b364 <__s2b+0x68>
   1b34c:	e51b3014 	ldr	r3, [fp, #-20]
   1b350:	e1a03083 	lsl	r3, r3, #1
   1b354:	e50b3014 	str	r3, [fp, #-20]
   1b358:	e51b3010 	ldr	r3, [fp, #-16]
   1b35c:	e2833001 	add	r3, r3, #1
   1b360:	e50b3010 	str	r3, [fp, #-16]
   1b364:	e51b2018 	ldr	r2, [fp, #-24]
   1b368:	e51b3014 	ldr	r3, [fp, #-20]
   1b36c:	e1520003 	cmp	r2, r3
   1b370:	cafffff5 	bgt	1b34c <__s2b+0x50>
#ifdef Pack_32
  b = Balloc (ptr, k);
   1b374:	e51b0020 	ldr	r0, [fp, #-32]
   1b378:	e51b1010 	ldr	r1, [fp, #-16]
   1b37c:	ebffff0d 	bl	1afb8 <_Balloc>
   1b380:	e50b0008 	str	r0, [fp, #-8]
  b->_x[0] = y9;
   1b384:	e51b3008 	ldr	r3, [fp, #-8]
   1b388:	e59b2004 	ldr	r2, [fp, #4]
   1b38c:	e5832014 	str	r2, [r3, #20]
  b->_wds = 1;
   1b390:	e51b3008 	ldr	r3, [fp, #-8]
   1b394:	e3a02001 	mov	r2, #1
   1b398:	e5832010 	str	r2, [r3, #16]
  b = Balloc (ptr, k + 1);
  b->_x[0] = y9 & 0xffff;
  b->_wds = (b->_x[1] = y9 >> 16) ? 2 : 1;
#endif

  i = 9;
   1b39c:	e3a03009 	mov	r3, #9
   1b3a0:	e50b300c 	str	r3, [fp, #-12]
  if (9 < nd0)
   1b3a4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1b3a8:	e3530009 	cmp	r3, #9
   1b3ac:	da000017 	ble	1b410 <__s2b+0x114>
    {
      s += 9;
   1b3b0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1b3b4:	e2833009 	add	r3, r3, #9
   1b3b8:	e50b3024 	str	r3, [fp, #-36]	; 0x24
      do
	b = multadd (ptr, b, 10, *s++ - '0');
   1b3bc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1b3c0:	e2832001 	add	r2, r3, #1
   1b3c4:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   1b3c8:	e5d33000 	ldrb	r3, [r3]
   1b3cc:	e2433030 	sub	r3, r3, #48	; 0x30
   1b3d0:	e51b0020 	ldr	r0, [fp, #-32]
   1b3d4:	e51b1008 	ldr	r1, [fp, #-8]
   1b3d8:	e3a0200a 	mov	r2, #10
   1b3dc:	ebffff5d 	bl	1b158 <__multadd>
   1b3e0:	e50b0008 	str	r0, [fp, #-8]
      while (++i < nd0);
   1b3e4:	e51b300c 	ldr	r3, [fp, #-12]
   1b3e8:	e2833001 	add	r3, r3, #1
   1b3ec:	e50b300c 	str	r3, [fp, #-12]
   1b3f0:	e51b200c 	ldr	r2, [fp, #-12]
   1b3f4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1b3f8:	e1520003 	cmp	r2, r3
   1b3fc:	baffffee 	blt	1b3bc <__s2b+0xc0>
      s++;
   1b400:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1b404:	e2833001 	add	r3, r3, #1
   1b408:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   1b40c:	ea000002 	b	1b41c <__s2b+0x120>
    }
  else
    s += 10;
   1b410:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1b414:	e283300a 	add	r3, r3, #10
   1b418:	e50b3024 	str	r3, [fp, #-36]	; 0x24
  for (; i < nd; i++)
   1b41c:	ea00000c 	b	1b454 <__s2b+0x158>
    b = multadd (ptr, b, 10, *s++ - '0');
   1b420:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1b424:	e2832001 	add	r2, r3, #1
   1b428:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   1b42c:	e5d33000 	ldrb	r3, [r3]
   1b430:	e2433030 	sub	r3, r3, #48	; 0x30
   1b434:	e51b0020 	ldr	r0, [fp, #-32]
   1b438:	e51b1008 	ldr	r1, [fp, #-8]
   1b43c:	e3a0200a 	mov	r2, #10
   1b440:	ebffff44 	bl	1b158 <__multadd>
   1b444:	e50b0008 	str	r0, [fp, #-8]
      while (++i < nd0);
      s++;
    }
  else
    s += 10;
  for (; i < nd; i++)
   1b448:	e51b300c 	ldr	r3, [fp, #-12]
   1b44c:	e2833001 	add	r3, r3, #1
   1b450:	e50b300c 	str	r3, [fp, #-12]
   1b454:	e51b200c 	ldr	r2, [fp, #-12]
   1b458:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1b45c:	e1520003 	cmp	r2, r3
   1b460:	baffffee 	blt	1b420 <__s2b+0x124>
    b = multadd (ptr, b, 10, *s++ - '0');
  return b;
   1b464:	e51b3008 	ldr	r3, [fp, #-8]
}
   1b468:	e1a00003 	mov	r0, r3
   1b46c:	e24bd004 	sub	sp, fp, #4
   1b470:	e8bd4800 	pop	{fp, lr}
   1b474:	e12fff1e 	bx	lr
   1b478:	38e38e39 	.word	0x38e38e39

0001b47c <__hi0bits>:

int
_DEFUN (hi0bits,
	(x), register __ULong x)
{
   1b47c:	e92d0810 	push	{r4, fp}
   1b480:	e28db004 	add	fp, sp, #4
   1b484:	e1a03000 	mov	r3, r0
  register int k = 0;
   1b488:	e3a04000 	mov	r4, #0

  if (!(x & 0xffff0000))
   1b48c:	e1a02823 	lsr	r2, r3, #16
   1b490:	e1a02802 	lsl	r2, r2, #16
   1b494:	e3520000 	cmp	r2, #0
   1b498:	1a000001 	bne	1b4a4 <__hi0bits+0x28>
    {
      k = 16;
   1b49c:	e3a04010 	mov	r4, #16
      x <<= 16;
   1b4a0:	e1a03803 	lsl	r3, r3, #16
    }
  if (!(x & 0xff000000))
   1b4a4:	e20324ff 	and	r2, r3, #-16777216	; 0xff000000
   1b4a8:	e3520000 	cmp	r2, #0
   1b4ac:	1a000001 	bne	1b4b8 <__hi0bits+0x3c>
    {
      k += 8;
   1b4b0:	e2844008 	add	r4, r4, #8
      x <<= 8;
   1b4b4:	e1a03403 	lsl	r3, r3, #8
    }
  if (!(x & 0xf0000000))
   1b4b8:	e203220f 	and	r2, r3, #-268435456	; 0xf0000000
   1b4bc:	e3520000 	cmp	r2, #0
   1b4c0:	1a000001 	bne	1b4cc <__hi0bits+0x50>
    {
      k += 4;
   1b4c4:	e2844004 	add	r4, r4, #4
      x <<= 4;
   1b4c8:	e1a03203 	lsl	r3, r3, #4
    }
  if (!(x & 0xc0000000))
   1b4cc:	e2032103 	and	r2, r3, #-1073741824	; 0xc0000000
   1b4d0:	e3520000 	cmp	r2, #0
   1b4d4:	1a000001 	bne	1b4e0 <__hi0bits+0x64>
    {
      k += 2;
   1b4d8:	e2844002 	add	r4, r4, #2
      x <<= 2;
   1b4dc:	e1a03103 	lsl	r3, r3, #2
    }
  if (!(x & 0x80000000))
   1b4e0:	e1a02003 	mov	r2, r3
   1b4e4:	e3520000 	cmp	r2, #0
   1b4e8:	ba000005 	blt	1b504 <__hi0bits+0x88>
    {
      k++;
   1b4ec:	e2844001 	add	r4, r4, #1
      if (!(x & 0x40000000))
   1b4f0:	e2033101 	and	r3, r3, #1073741824	; 0x40000000
   1b4f4:	e3530000 	cmp	r3, #0
   1b4f8:	1a000001 	bne	1b504 <__hi0bits+0x88>
	return 32;
   1b4fc:	e3a03020 	mov	r3, #32
   1b500:	ea000000 	b	1b508 <__hi0bits+0x8c>
    }
  return k;
   1b504:	e1a03004 	mov	r3, r4
}
   1b508:	e1a00003 	mov	r0, r3
   1b50c:	e24bd004 	sub	sp, fp, #4
   1b510:	e8bd0810 	pop	{r4, fp}
   1b514:	e12fff1e 	bx	lr

0001b518 <__lo0bits>:

int
_DEFUN (lo0bits, (y), __ULong *y)
{
   1b518:	e92d0830 	push	{r4, r5, fp}
   1b51c:	e28db008 	add	fp, sp, #8
   1b520:	e24dd00c 	sub	sp, sp, #12
   1b524:	e50b0010 	str	r0, [fp, #-16]
  register int k;
  register __ULong x = *y;
   1b528:	e51b3010 	ldr	r3, [fp, #-16]
   1b52c:	e5934000 	ldr	r4, [r3]

  if (x & 7)
   1b530:	e2043007 	and	r3, r4, #7
   1b534:	e3530000 	cmp	r3, #0
   1b538:	0a000011 	beq	1b584 <__lo0bits+0x6c>
    {
      if (x & 1)
   1b53c:	e2043001 	and	r3, r4, #1
   1b540:	e3530000 	cmp	r3, #0
   1b544:	0a000001 	beq	1b550 <__lo0bits+0x38>
	return 0;
   1b548:	e3a03000 	mov	r3, #0
   1b54c:	ea00002e 	b	1b60c <__lo0bits+0xf4>
      if (x & 2)
   1b550:	e2043002 	and	r3, r4, #2
   1b554:	e3530000 	cmp	r3, #0
   1b558:	0a000004 	beq	1b570 <__lo0bits+0x58>
	{
	  *y = x >> 1;
   1b55c:	e1a020a4 	lsr	r2, r4, #1
   1b560:	e51b3010 	ldr	r3, [fp, #-16]
   1b564:	e5832000 	str	r2, [r3]
	  return 1;
   1b568:	e3a03001 	mov	r3, #1
   1b56c:	ea000026 	b	1b60c <__lo0bits+0xf4>
	}
      *y = x >> 2;
   1b570:	e1a02124 	lsr	r2, r4, #2
   1b574:	e51b3010 	ldr	r3, [fp, #-16]
   1b578:	e5832000 	str	r2, [r3]
      return 2;
   1b57c:	e3a03002 	mov	r3, #2
   1b580:	ea000021 	b	1b60c <__lo0bits+0xf4>
    }
  k = 0;
   1b584:	e3a05000 	mov	r5, #0
  if (!(x & 0xffff))
   1b588:	e1a03804 	lsl	r3, r4, #16
   1b58c:	e1a03823 	lsr	r3, r3, #16
   1b590:	e3530000 	cmp	r3, #0
   1b594:	1a000001 	bne	1b5a0 <__lo0bits+0x88>
    {
      k = 16;
   1b598:	e3a05010 	mov	r5, #16
      x >>= 16;
   1b59c:	e1a04824 	lsr	r4, r4, #16
    }
  if (!(x & 0xff))
   1b5a0:	e20430ff 	and	r3, r4, #255	; 0xff
   1b5a4:	e3530000 	cmp	r3, #0
   1b5a8:	1a000001 	bne	1b5b4 <__lo0bits+0x9c>
    {
      k += 8;
   1b5ac:	e2855008 	add	r5, r5, #8
      x >>= 8;
   1b5b0:	e1a04424 	lsr	r4, r4, #8
    }
  if (!(x & 0xf))
   1b5b4:	e204300f 	and	r3, r4, #15
   1b5b8:	e3530000 	cmp	r3, #0
   1b5bc:	1a000001 	bne	1b5c8 <__lo0bits+0xb0>
    {
      k += 4;
   1b5c0:	e2855004 	add	r5, r5, #4
      x >>= 4;
   1b5c4:	e1a04224 	lsr	r4, r4, #4
    }
  if (!(x & 0x3))
   1b5c8:	e2043003 	and	r3, r4, #3
   1b5cc:	e3530000 	cmp	r3, #0
   1b5d0:	1a000001 	bne	1b5dc <__lo0bits+0xc4>
    {
      k += 2;
   1b5d4:	e2855002 	add	r5, r5, #2
      x >>= 2;
   1b5d8:	e1a04124 	lsr	r4, r4, #2
    }
  if (!(x & 1))
   1b5dc:	e2043001 	and	r3, r4, #1
   1b5e0:	e3530000 	cmp	r3, #0
   1b5e4:	1a000005 	bne	1b600 <__lo0bits+0xe8>
    {
      k++;
   1b5e8:	e2855001 	add	r5, r5, #1
      x >>= 1;
   1b5ec:	e1a040a4 	lsr	r4, r4, #1
      if (!x & 1)
   1b5f0:	e3540000 	cmp	r4, #0
   1b5f4:	1a000001 	bne	1b600 <__lo0bits+0xe8>
	return 32;
   1b5f8:	e3a03020 	mov	r3, #32
   1b5fc:	ea000002 	b	1b60c <__lo0bits+0xf4>
    }
  *y = x;
   1b600:	e51b3010 	ldr	r3, [fp, #-16]
   1b604:	e5834000 	str	r4, [r3]
  return k;
   1b608:	e1a03005 	mov	r3, r5
}
   1b60c:	e1a00003 	mov	r0, r3
   1b610:	e24bd008 	sub	sp, fp, #8
   1b614:	e8bd0830 	pop	{r4, r5, fp}
   1b618:	e12fff1e 	bx	lr

0001b61c <__i2b>:

_Bigint *
_DEFUN (i2b, (ptr, i), struct _reent * ptr _AND int i)
{
   1b61c:	e92d4800 	push	{fp, lr}
   1b620:	e28db004 	add	fp, sp, #4
   1b624:	e24dd010 	sub	sp, sp, #16
   1b628:	e50b0010 	str	r0, [fp, #-16]
   1b62c:	e50b1014 	str	r1, [fp, #-20]
  _Bigint *b;

  b = Balloc (ptr, 1);
   1b630:	e51b0010 	ldr	r0, [fp, #-16]
   1b634:	e3a01001 	mov	r1, #1
   1b638:	ebfffe5e 	bl	1afb8 <_Balloc>
   1b63c:	e50b0008 	str	r0, [fp, #-8]
  b->_x[0] = i;
   1b640:	e51b2014 	ldr	r2, [fp, #-20]
   1b644:	e51b3008 	ldr	r3, [fp, #-8]
   1b648:	e5832014 	str	r2, [r3, #20]
  b->_wds = 1;
   1b64c:	e51b3008 	ldr	r3, [fp, #-8]
   1b650:	e3a02001 	mov	r2, #1
   1b654:	e5832010 	str	r2, [r3, #16]
  return b;
   1b658:	e51b3008 	ldr	r3, [fp, #-8]
}
   1b65c:	e1a00003 	mov	r0, r3
   1b660:	e24bd004 	sub	sp, fp, #4
   1b664:	e8bd4800 	pop	{fp, lr}
   1b668:	e12fff1e 	bx	lr

0001b66c <__multiply>:

_Bigint *
_DEFUN (mult, (ptr, a, b), struct _reent * ptr _AND _Bigint * a _AND _Bigint * b)
{
   1b66c:	e92d4800 	push	{fp, lr}
   1b670:	e28db004 	add	fp, sp, #4
   1b674:	e24dd050 	sub	sp, sp, #80	; 0x50
   1b678:	e50b0048 	str	r0, [fp, #-72]	; 0x48
   1b67c:	e50b104c 	str	r1, [fp, #-76]	; 0x4c
   1b680:	e50b2050 	str	r2, [fp, #-80]	; 0x50
  __ULong *x, *xa, *xae, *xb, *xbe, *xc, *xc0;
#ifdef Pack_32
  __ULong z2;
#endif

  if (a->_wds < b->_wds)
   1b684:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1b688:	e5932010 	ldr	r2, [r3, #16]
   1b68c:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   1b690:	e5933010 	ldr	r3, [r3, #16]
   1b694:	e1520003 	cmp	r2, r3
   1b698:	aa000005 	bge	1b6b4 <__multiply+0x48>
    {
      c = a;
   1b69c:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1b6a0:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      a = b;
   1b6a4:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   1b6a8:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
      b = c;
   1b6ac:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1b6b0:	e50b3050 	str	r3, [fp, #-80]	; 0x50
    }
  k = a->_k;
   1b6b4:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1b6b8:	e5933004 	ldr	r3, [r3, #4]
   1b6bc:	e50b3008 	str	r3, [fp, #-8]
  wa = a->_wds;
   1b6c0:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1b6c4:	e5933010 	ldr	r3, [r3, #16]
   1b6c8:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
  wb = b->_wds;
   1b6cc:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   1b6d0:	e5933010 	ldr	r3, [r3, #16]
   1b6d4:	e50b3030 	str	r3, [fp, #-48]	; 0x30
  wc = wa + wb;
   1b6d8:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
   1b6dc:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1b6e0:	e0823003 	add	r3, r2, r3
   1b6e4:	e50b300c 	str	r3, [fp, #-12]
  if (wc > a->_maxwds)
   1b6e8:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1b6ec:	e5932008 	ldr	r2, [r3, #8]
   1b6f0:	e51b300c 	ldr	r3, [fp, #-12]
   1b6f4:	e1520003 	cmp	r2, r3
   1b6f8:	aa000002 	bge	1b708 <__multiply+0x9c>
    k++;
   1b6fc:	e51b3008 	ldr	r3, [fp, #-8]
   1b700:	e2833001 	add	r3, r3, #1
   1b704:	e50b3008 	str	r3, [fp, #-8]
  c = Balloc (ptr, k);
   1b708:	e51b0048 	ldr	r0, [fp, #-72]	; 0x48
   1b70c:	e51b1008 	ldr	r1, [fp, #-8]
   1b710:	ebfffe28 	bl	1afb8 <_Balloc>
   1b714:	e50b0028 	str	r0, [fp, #-40]	; 0x28
  for (x = c->_x, xa = x + wc; x < xa; x++)
   1b718:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1b71c:	e2833014 	add	r3, r3, #20
   1b720:	e50b3014 	str	r3, [fp, #-20]
   1b724:	e51b300c 	ldr	r3, [fp, #-12]
   1b728:	e1a03103 	lsl	r3, r3, #2
   1b72c:	e51b2014 	ldr	r2, [fp, #-20]
   1b730:	e0823003 	add	r3, r2, r3
   1b734:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   1b738:	ea000005 	b	1b754 <__multiply+0xe8>
    *x = 0;
   1b73c:	e51b3014 	ldr	r3, [fp, #-20]
   1b740:	e3a02000 	mov	r2, #0
   1b744:	e5832000 	str	r2, [r3]
  wb = b->_wds;
  wc = wa + wb;
  if (wc > a->_maxwds)
    k++;
  c = Balloc (ptr, k);
  for (x = c->_x, xa = x + wc; x < xa; x++)
   1b748:	e51b3014 	ldr	r3, [fp, #-20]
   1b74c:	e2833004 	add	r3, r3, #4
   1b750:	e50b3014 	str	r3, [fp, #-20]
   1b754:	e51b2014 	ldr	r2, [fp, #-20]
   1b758:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1b75c:	e1520003 	cmp	r2, r3
   1b760:	3afffff5 	bcc	1b73c <__multiply+0xd0>
    *x = 0;
  xa = a->_x;
   1b764:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1b768:	e2833014 	add	r3, r3, #20
   1b76c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
  xae = xa + wa;
   1b770:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1b774:	e1a03103 	lsl	r3, r3, #2
   1b778:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   1b77c:	e0823003 	add	r3, r2, r3
   1b780:	e50b3038 	str	r3, [fp, #-56]	; 0x38
  xb = b->_x;
   1b784:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   1b788:	e2833014 	add	r3, r3, #20
   1b78c:	e50b3018 	str	r3, [fp, #-24]
  xbe = xb + wb;
   1b790:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1b794:	e1a03103 	lsl	r3, r3, #2
   1b798:	e51b2018 	ldr	r2, [fp, #-24]
   1b79c:	e0823003 	add	r3, r2, r3
   1b7a0:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
  xc0 = c->_x;
   1b7a4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1b7a8:	e2833014 	add	r3, r3, #20
   1b7ac:	e50b3020 	str	r3, [fp, #-32]
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
   1b7b0:	ea000089 	b	1b9dc <__multiply+0x370>
    {
      if ((y = *xb & 0xffff) != 0)
   1b7b4:	e51b3018 	ldr	r3, [fp, #-24]
   1b7b8:	e5933000 	ldr	r3, [r3]
   1b7bc:	e1a03803 	lsl	r3, r3, #16
   1b7c0:	e1a03823 	lsr	r3, r3, #16
   1b7c4:	e50b3040 	str	r3, [fp, #-64]	; 0x40
   1b7c8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1b7cc:	e3530000 	cmp	r3, #0
   1b7d0:	0a000038 	beq	1b8b8 <__multiply+0x24c>
	{
	  x = xa;
   1b7d4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1b7d8:	e50b3014 	str	r3, [fp, #-20]
	  xc = xc0;
   1b7dc:	e51b3020 	ldr	r3, [fp, #-32]
   1b7e0:	e50b301c 	str	r3, [fp, #-28]
	  carry = 0;
   1b7e4:	e3a03000 	mov	r3, #0
   1b7e8:	e50b3010 	str	r3, [fp, #-16]
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc & 0xffff) + carry;
   1b7ec:	e51b3014 	ldr	r3, [fp, #-20]
   1b7f0:	e5933000 	ldr	r3, [r3]
   1b7f4:	e1a03803 	lsl	r3, r3, #16
   1b7f8:	e1a03823 	lsr	r3, r3, #16
   1b7fc:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   1b800:	e0020293 	mul	r2, r3, r2
   1b804:	e51b301c 	ldr	r3, [fp, #-28]
   1b808:	e5933000 	ldr	r3, [r3]
   1b80c:	e1a03803 	lsl	r3, r3, #16
   1b810:	e1a03823 	lsr	r3, r3, #16
   1b814:	e0822003 	add	r2, r2, r3
   1b818:	e51b3010 	ldr	r3, [fp, #-16]
   1b81c:	e0823003 	add	r3, r2, r3
   1b820:	e50b3044 	str	r3, [fp, #-68]	; 0x44
	      carry = z >> 16;
   1b824:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1b828:	e1a03823 	lsr	r3, r3, #16
   1b82c:	e50b3010 	str	r3, [fp, #-16]
	      z2 = (*x++ >> 16) * y + (*xc >> 16) + carry;
   1b830:	e51b3014 	ldr	r3, [fp, #-20]
   1b834:	e2832004 	add	r2, r3, #4
   1b838:	e50b2014 	str	r2, [fp, #-20]
   1b83c:	e5933000 	ldr	r3, [r3]
   1b840:	e1a03823 	lsr	r3, r3, #16
   1b844:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   1b848:	e0020293 	mul	r2, r3, r2
   1b84c:	e51b301c 	ldr	r3, [fp, #-28]
   1b850:	e5933000 	ldr	r3, [r3]
   1b854:	e1a03823 	lsr	r3, r3, #16
   1b858:	e0822003 	add	r2, r2, r3
   1b85c:	e51b3010 	ldr	r3, [fp, #-16]
   1b860:	e0823003 	add	r3, r2, r3
   1b864:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	      carry = z2 >> 16;
   1b868:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1b86c:	e1a03823 	lsr	r3, r3, #16
   1b870:	e50b3010 	str	r3, [fp, #-16]
	      Storeinc (xc, z2, z);
   1b874:	e51b201c 	ldr	r2, [fp, #-28]
   1b878:	e2823004 	add	r3, r2, #4
   1b87c:	e50b301c 	str	r3, [fp, #-28]
   1b880:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1b884:	e1a01803 	lsl	r1, r3, #16
   1b888:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1b88c:	e1a03803 	lsl	r3, r3, #16
   1b890:	e1a03823 	lsr	r3, r3, #16
   1b894:	e1813003 	orr	r3, r1, r3
   1b898:	e5823000 	str	r3, [r2]
	    }
	  while (x < xae);
   1b89c:	e51b2014 	ldr	r2, [fp, #-20]
   1b8a0:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1b8a4:	e1520003 	cmp	r2, r3
   1b8a8:	3affffcf 	bcc	1b7ec <__multiply+0x180>
	  *xc = carry;
   1b8ac:	e51b301c 	ldr	r3, [fp, #-28]
   1b8b0:	e51b2010 	ldr	r2, [fp, #-16]
   1b8b4:	e5832000 	str	r2, [r3]
	}
      if ((y = *xb >> 16) != 0)
   1b8b8:	e51b3018 	ldr	r3, [fp, #-24]
   1b8bc:	e5933000 	ldr	r3, [r3]
   1b8c0:	e1a03823 	lsr	r3, r3, #16
   1b8c4:	e50b3040 	str	r3, [fp, #-64]	; 0x40
   1b8c8:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1b8cc:	e3530000 	cmp	r3, #0
   1b8d0:	0a00003b 	beq	1b9c4 <__multiply+0x358>
	{
	  x = xa;
   1b8d4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1b8d8:	e50b3014 	str	r3, [fp, #-20]
	  xc = xc0;
   1b8dc:	e51b3020 	ldr	r3, [fp, #-32]
   1b8e0:	e50b301c 	str	r3, [fp, #-28]
	  carry = 0;
   1b8e4:	e3a03000 	mov	r3, #0
   1b8e8:	e50b3010 	str	r3, [fp, #-16]
	  z2 = *xc;
   1b8ec:	e51b301c 	ldr	r3, [fp, #-28]
   1b8f0:	e5933000 	ldr	r3, [r3]
   1b8f4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	  do
	    {
	      z = (*x & 0xffff) * y + (*xc >> 16) + carry;
   1b8f8:	e51b3014 	ldr	r3, [fp, #-20]
   1b8fc:	e5933000 	ldr	r3, [r3]
   1b900:	e1a03803 	lsl	r3, r3, #16
   1b904:	e1a03823 	lsr	r3, r3, #16
   1b908:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   1b90c:	e0020293 	mul	r2, r3, r2
   1b910:	e51b301c 	ldr	r3, [fp, #-28]
   1b914:	e5933000 	ldr	r3, [r3]
   1b918:	e1a03823 	lsr	r3, r3, #16
   1b91c:	e0822003 	add	r2, r2, r3
   1b920:	e51b3010 	ldr	r3, [fp, #-16]
   1b924:	e0823003 	add	r3, r2, r3
   1b928:	e50b3044 	str	r3, [fp, #-68]	; 0x44
	      carry = z >> 16;
   1b92c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1b930:	e1a03823 	lsr	r3, r3, #16
   1b934:	e50b3010 	str	r3, [fp, #-16]
	      Storeinc (xc, z, z2);
   1b938:	e51b201c 	ldr	r2, [fp, #-28]
   1b93c:	e2823004 	add	r3, r2, #4
   1b940:	e50b301c 	str	r3, [fp, #-28]
   1b944:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1b948:	e1a01803 	lsl	r1, r3, #16
   1b94c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1b950:	e1a03803 	lsl	r3, r3, #16
   1b954:	e1a03823 	lsr	r3, r3, #16
   1b958:	e1813003 	orr	r3, r1, r3
   1b95c:	e5823000 	str	r3, [r2]
	      z2 = (*x++ >> 16) * y + (*xc & 0xffff) + carry;
   1b960:	e51b3014 	ldr	r3, [fp, #-20]
   1b964:	e2832004 	add	r2, r3, #4
   1b968:	e50b2014 	str	r2, [fp, #-20]
   1b96c:	e5933000 	ldr	r3, [r3]
   1b970:	e1a03823 	lsr	r3, r3, #16
   1b974:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   1b978:	e0020293 	mul	r2, r3, r2
   1b97c:	e51b301c 	ldr	r3, [fp, #-28]
   1b980:	e5933000 	ldr	r3, [r3]
   1b984:	e1a03803 	lsl	r3, r3, #16
   1b988:	e1a03823 	lsr	r3, r3, #16
   1b98c:	e0822003 	add	r2, r2, r3
   1b990:	e51b3010 	ldr	r3, [fp, #-16]
   1b994:	e0823003 	add	r3, r2, r3
   1b998:	e50b3024 	str	r3, [fp, #-36]	; 0x24
	      carry = z2 >> 16;
   1b99c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1b9a0:	e1a03823 	lsr	r3, r3, #16
   1b9a4:	e50b3010 	str	r3, [fp, #-16]
	    }
	  while (x < xae);
   1b9a8:	e51b2014 	ldr	r2, [fp, #-20]
   1b9ac:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1b9b0:	e1520003 	cmp	r2, r3
   1b9b4:	3affffcf 	bcc	1b8f8 <__multiply+0x28c>
	  *xc = z2;
   1b9b8:	e51b301c 	ldr	r3, [fp, #-28]
   1b9bc:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1b9c0:	e5832000 	str	r2, [r3]
  xae = xa + wa;
  xb = b->_x;
  xbe = xb + wb;
  xc0 = c->_x;
#ifdef Pack_32
  for (; xb < xbe; xb++, xc0++)
   1b9c4:	e51b3018 	ldr	r3, [fp, #-24]
   1b9c8:	e2833004 	add	r3, r3, #4
   1b9cc:	e50b3018 	str	r3, [fp, #-24]
   1b9d0:	e51b3020 	ldr	r3, [fp, #-32]
   1b9d4:	e2833004 	add	r3, r3, #4
   1b9d8:	e50b3020 	str	r3, [fp, #-32]
   1b9dc:	e51b2018 	ldr	r2, [fp, #-24]
   1b9e0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1b9e4:	e1520003 	cmp	r2, r3
   1b9e8:	3affff71 	bcc	1b7b4 <__multiply+0x148>
	  while (x < xae);
	  *xc = carry;
	}
    }
#endif
  for (xc0 = c->_x, xc = xc0 + wc; wc > 0 && !*--xc; --wc);
   1b9ec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1b9f0:	e2833014 	add	r3, r3, #20
   1b9f4:	e50b3020 	str	r3, [fp, #-32]
   1b9f8:	e51b300c 	ldr	r3, [fp, #-12]
   1b9fc:	e1a03103 	lsl	r3, r3, #2
   1ba00:	e51b2020 	ldr	r2, [fp, #-32]
   1ba04:	e0823003 	add	r3, r2, r3
   1ba08:	e50b301c 	str	r3, [fp, #-28]
   1ba0c:	ea000002 	b	1ba1c <__multiply+0x3b0>
   1ba10:	e51b300c 	ldr	r3, [fp, #-12]
   1ba14:	e2433001 	sub	r3, r3, #1
   1ba18:	e50b300c 	str	r3, [fp, #-12]
   1ba1c:	e51b300c 	ldr	r3, [fp, #-12]
   1ba20:	e3530000 	cmp	r3, #0
   1ba24:	da000006 	ble	1ba44 <__multiply+0x3d8>
   1ba28:	e51b301c 	ldr	r3, [fp, #-28]
   1ba2c:	e2433004 	sub	r3, r3, #4
   1ba30:	e50b301c 	str	r3, [fp, #-28]
   1ba34:	e51b301c 	ldr	r3, [fp, #-28]
   1ba38:	e5933000 	ldr	r3, [r3]
   1ba3c:	e3530000 	cmp	r3, #0
   1ba40:	0afffff2 	beq	1ba10 <__multiply+0x3a4>
  c->_wds = wc;
   1ba44:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1ba48:	e51b200c 	ldr	r2, [fp, #-12]
   1ba4c:	e5832010 	str	r2, [r3, #16]
  return c;
   1ba50:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
}
   1ba54:	e1a00003 	mov	r0, r3
   1ba58:	e24bd004 	sub	sp, fp, #4
   1ba5c:	e8bd4800 	pop	{fp, lr}
   1ba60:	e12fff1e 	bx	lr

0001ba64 <__pow5mult>:

_Bigint *
_DEFUN (pow5mult,
	(ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   1ba64:	e92d4800 	push	{fp, lr}
   1ba68:	e28db004 	add	fp, sp, #4
   1ba6c:	e24dd020 	sub	sp, sp, #32
   1ba70:	e50b0018 	str	r0, [fp, #-24]
   1ba74:	e50b101c 	str	r1, [fp, #-28]
   1ba78:	e50b2020 	str	r2, [fp, #-32]
  _Bigint *b1, *p5, *p51;
  int i;
  static _CONST int p05[3] = {5, 25, 125};

  if ((i = k & 3) != 0)
   1ba7c:	e51b3020 	ldr	r3, [fp, #-32]
   1ba80:	e2033003 	and	r3, r3, #3
   1ba84:	e50b3010 	str	r3, [fp, #-16]
   1ba88:	e51b3010 	ldr	r3, [fp, #-16]
   1ba8c:	e3530000 	cmp	r3, #0
   1ba90:	0a000009 	beq	1babc <__pow5mult+0x58>
    b = multadd (ptr, b, p05[i - 1], 0);
   1ba94:	e51b3010 	ldr	r3, [fp, #-16]
   1ba98:	e2432001 	sub	r2, r3, #1
   1ba9c:	e59f3144 	ldr	r3, [pc, #324]	; 1bbe8 <__pow5mult+0x184>
   1baa0:	e7933102 	ldr	r3, [r3, r2, lsl #2]
   1baa4:	e51b0018 	ldr	r0, [fp, #-24]
   1baa8:	e51b101c 	ldr	r1, [fp, #-28]
   1baac:	e1a02003 	mov	r2, r3
   1bab0:	e3a03000 	mov	r3, #0
   1bab4:	ebfffda7 	bl	1b158 <__multadd>
   1bab8:	e50b001c 	str	r0, [fp, #-28]

  if (!(k >>= 2))
   1babc:	e51b3020 	ldr	r3, [fp, #-32]
   1bac0:	e1a03143 	asr	r3, r3, #2
   1bac4:	e50b3020 	str	r3, [fp, #-32]
   1bac8:	e51b3020 	ldr	r3, [fp, #-32]
   1bacc:	e3530000 	cmp	r3, #0
   1bad0:	1a000001 	bne	1badc <__pow5mult+0x78>
    return b;
   1bad4:	e51b301c 	ldr	r3, [fp, #-28]
   1bad8:	ea00003e 	b	1bbd8 <__pow5mult+0x174>
  _REENT_CHECK_MP(ptr);
  if (!(p5 = _REENT_MP_P5S(ptr)))
   1badc:	e51b3018 	ldr	r3, [fp, #-24]
   1bae0:	e5933048 	ldr	r3, [r3, #72]	; 0x48
   1bae4:	e50b3008 	str	r3, [fp, #-8]
   1bae8:	e51b3008 	ldr	r3, [fp, #-8]
   1baec:	e3530000 	cmp	r3, #0
   1baf0:	1a00000b 	bne	1bb24 <__pow5mult+0xc0>
    {
      /* first time */
      p5 = _REENT_MP_P5S(ptr) = i2b (ptr, 625);
   1baf4:	e51b0018 	ldr	r0, [fp, #-24]
   1baf8:	e59f10ec 	ldr	r1, [pc, #236]	; 1bbec <__pow5mult+0x188>
   1bafc:	ebfffec6 	bl	1b61c <__i2b>
   1bb00:	e1a02000 	mov	r2, r0
   1bb04:	e51b3018 	ldr	r3, [fp, #-24]
   1bb08:	e5832048 	str	r2, [r3, #72]	; 0x48
   1bb0c:	e51b3018 	ldr	r3, [fp, #-24]
   1bb10:	e5933048 	ldr	r3, [r3, #72]	; 0x48
   1bb14:	e50b3008 	str	r3, [fp, #-8]
      p5->_next = 0;
   1bb18:	e51b3008 	ldr	r3, [fp, #-8]
   1bb1c:	e3a02000 	mov	r2, #0
   1bb20:	e5832000 	str	r2, [r3]
    }
  for (;;)
    {
      if (k & 1)
   1bb24:	e51b3020 	ldr	r3, [fp, #-32]
   1bb28:	e2033001 	and	r3, r3, #1
   1bb2c:	e3530000 	cmp	r3, #0
   1bb30:	0a000009 	beq	1bb5c <__pow5mult+0xf8>
	{
	  b1 = mult (ptr, b, p5);
   1bb34:	e51b0018 	ldr	r0, [fp, #-24]
   1bb38:	e51b101c 	ldr	r1, [fp, #-28]
   1bb3c:	e51b2008 	ldr	r2, [fp, #-8]
   1bb40:	ebfffec9 	bl	1b66c <__multiply>
   1bb44:	e50b0014 	str	r0, [fp, #-20]
	  Bfree (ptr, b);
   1bb48:	e51b0018 	ldr	r0, [fp, #-24]
   1bb4c:	e51b101c 	ldr	r1, [fp, #-28]
   1bb50:	ebfffd64 	bl	1b0e8 <_Bfree>
	  b = b1;
   1bb54:	e51b3014 	ldr	r3, [fp, #-20]
   1bb58:	e50b301c 	str	r3, [fp, #-28]
	}
      if (!(k >>= 1))
   1bb5c:	e51b3020 	ldr	r3, [fp, #-32]
   1bb60:	e1a030c3 	asr	r3, r3, #1
   1bb64:	e50b3020 	str	r3, [fp, #-32]
   1bb68:	e51b3020 	ldr	r3, [fp, #-32]
   1bb6c:	e3530000 	cmp	r3, #0
   1bb70:	1a000002 	bne	1bb80 <__pow5mult+0x11c>
	break;
   1bb74:	e1a00000 	nop			; (mov r0, r0)
	  p51 = p5->_next = mult (ptr, p5, p5);
	  p51->_next = 0;
	}
      p5 = p51;
    }
  return b;
   1bb78:	e51b301c 	ldr	r3, [fp, #-28]
   1bb7c:	ea000015 	b	1bbd8 <__pow5mult+0x174>
	  Bfree (ptr, b);
	  b = b1;
	}
      if (!(k >>= 1))
	break;
      if (!(p51 = p5->_next))
   1bb80:	e51b3008 	ldr	r3, [fp, #-8]
   1bb84:	e5933000 	ldr	r3, [r3]
   1bb88:	e50b300c 	str	r3, [fp, #-12]
   1bb8c:	e51b300c 	ldr	r3, [fp, #-12]
   1bb90:	e3530000 	cmp	r3, #0
   1bb94:	1a00000c 	bne	1bbcc <__pow5mult+0x168>
	{
	  p51 = p5->_next = mult (ptr, p5, p5);
   1bb98:	e51b0018 	ldr	r0, [fp, #-24]
   1bb9c:	e51b1008 	ldr	r1, [fp, #-8]
   1bba0:	e51b2008 	ldr	r2, [fp, #-8]
   1bba4:	ebfffeb0 	bl	1b66c <__multiply>
   1bba8:	e1a02000 	mov	r2, r0
   1bbac:	e51b3008 	ldr	r3, [fp, #-8]
   1bbb0:	e5832000 	str	r2, [r3]
   1bbb4:	e51b3008 	ldr	r3, [fp, #-8]
   1bbb8:	e5933000 	ldr	r3, [r3]
   1bbbc:	e50b300c 	str	r3, [fp, #-12]
	  p51->_next = 0;
   1bbc0:	e51b300c 	ldr	r3, [fp, #-12]
   1bbc4:	e3a02000 	mov	r2, #0
   1bbc8:	e5832000 	str	r2, [r3]
	}
      p5 = p51;
   1bbcc:	e51b300c 	ldr	r3, [fp, #-12]
   1bbd0:	e50b3008 	str	r3, [fp, #-8]
    }
   1bbd4:	eaffffd2 	b	1bb24 <__pow5mult+0xc0>
  return b;
}
   1bbd8:	e1a00003 	mov	r0, r3
   1bbdc:	e24bd004 	sub	sp, fp, #4
   1bbe0:	e8bd4800 	pop	{fp, lr}
   1bbe4:	e12fff1e 	bx	lr
   1bbe8:	00024940 	.word	0x00024940
   1bbec:	00000271 	.word	0x00000271

0001bbf0 <__lshift>:

_Bigint *
_DEFUN (lshift, (ptr, b, k), struct _reent * ptr _AND _Bigint * b _AND int k)
{
   1bbf0:	e92d4800 	push	{fp, lr}
   1bbf4:	e28db004 	add	fp, sp, #4
   1bbf8:	e24dd038 	sub	sp, sp, #56	; 0x38
   1bbfc:	e50b0030 	str	r0, [fp, #-48]	; 0x30
   1bc00:	e50b1034 	str	r1, [fp, #-52]	; 0x34
   1bc04:	e50b2038 	str	r2, [fp, #-56]	; 0x38
  int i, k1, n, n1;
  _Bigint *b1;
  __ULong *x, *x1, *xe, z;

#ifdef Pack_32
  n = k >> 5;
   1bc08:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1bc0c:	e1a032c3 	asr	r3, r3, #5
   1bc10:	e50b3020 	str	r3, [fp, #-32]
#else
  n = k >> 4;
#endif
  k1 = b->_k;
   1bc14:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1bc18:	e5933004 	ldr	r3, [r3, #4]
   1bc1c:	e50b300c 	str	r3, [fp, #-12]
  n1 = n + b->_wds + 1;
   1bc20:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1bc24:	e5932010 	ldr	r2, [r3, #16]
   1bc28:	e51b3020 	ldr	r3, [fp, #-32]
   1bc2c:	e0823003 	add	r3, r2, r3
   1bc30:	e2833001 	add	r3, r3, #1
   1bc34:	e50b3010 	str	r3, [fp, #-16]
  for (i = b->_maxwds; n1 > i; i <<= 1)
   1bc38:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1bc3c:	e5933008 	ldr	r3, [r3, #8]
   1bc40:	e50b3008 	str	r3, [fp, #-8]
   1bc44:	ea000005 	b	1bc60 <__lshift+0x70>
    k1++;
   1bc48:	e51b300c 	ldr	r3, [fp, #-12]
   1bc4c:	e2833001 	add	r3, r3, #1
   1bc50:	e50b300c 	str	r3, [fp, #-12]
#else
  n = k >> 4;
#endif
  k1 = b->_k;
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
   1bc54:	e51b3008 	ldr	r3, [fp, #-8]
   1bc58:	e1a03083 	lsl	r3, r3, #1
   1bc5c:	e50b3008 	str	r3, [fp, #-8]
   1bc60:	e51b2010 	ldr	r2, [fp, #-16]
   1bc64:	e51b3008 	ldr	r3, [fp, #-8]
   1bc68:	e1520003 	cmp	r2, r3
   1bc6c:	cafffff5 	bgt	1bc48 <__lshift+0x58>
    k1++;
  b1 = Balloc (ptr, k1);
   1bc70:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   1bc74:	e51b100c 	ldr	r1, [fp, #-12]
   1bc78:	ebfffcce 	bl	1afb8 <_Balloc>
   1bc7c:	e50b0024 	str	r0, [fp, #-36]	; 0x24
  x1 = b1->_x;
   1bc80:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1bc84:	e2833014 	add	r3, r3, #20
   1bc88:	e50b3018 	str	r3, [fp, #-24]
  for (i = 0; i < n; i++)
   1bc8c:	e3a03000 	mov	r3, #0
   1bc90:	e50b3008 	str	r3, [fp, #-8]
   1bc94:	ea000007 	b	1bcb8 <__lshift+0xc8>
    *x1++ = 0;
   1bc98:	e51b3018 	ldr	r3, [fp, #-24]
   1bc9c:	e2832004 	add	r2, r3, #4
   1bca0:	e50b2018 	str	r2, [fp, #-24]
   1bca4:	e3a02000 	mov	r2, #0
   1bca8:	e5832000 	str	r2, [r3]
  n1 = n + b->_wds + 1;
  for (i = b->_maxwds; n1 > i; i <<= 1)
    k1++;
  b1 = Balloc (ptr, k1);
  x1 = b1->_x;
  for (i = 0; i < n; i++)
   1bcac:	e51b3008 	ldr	r3, [fp, #-8]
   1bcb0:	e2833001 	add	r3, r3, #1
   1bcb4:	e50b3008 	str	r3, [fp, #-8]
   1bcb8:	e51b2008 	ldr	r2, [fp, #-8]
   1bcbc:	e51b3020 	ldr	r3, [fp, #-32]
   1bcc0:	e1520003 	cmp	r2, r3
   1bcc4:	bafffff3 	blt	1bc98 <__lshift+0xa8>
    *x1++ = 0;
  x = b->_x;
   1bcc8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1bccc:	e2833014 	add	r3, r3, #20
   1bcd0:	e50b3014 	str	r3, [fp, #-20]
  xe = x + b->_wds;
   1bcd4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1bcd8:	e5933010 	ldr	r3, [r3, #16]
   1bcdc:	e1a03103 	lsl	r3, r3, #2
   1bce0:	e51b2014 	ldr	r2, [fp, #-20]
   1bce4:	e0823003 	add	r3, r2, r3
   1bce8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
#ifdef Pack_32
  if (k &= 0x1f)
   1bcec:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1bcf0:	e203301f 	and	r3, r3, #31
   1bcf4:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   1bcf8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1bcfc:	e3530000 	cmp	r3, #0
   1bd00:	0a000024 	beq	1bd98 <__lshift+0x1a8>
    {
      k1 = 32 - k;
   1bd04:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1bd08:	e2633020 	rsb	r3, r3, #32
   1bd0c:	e50b300c 	str	r3, [fp, #-12]
      z = 0;
   1bd10:	e3a03000 	mov	r3, #0
   1bd14:	e50b301c 	str	r3, [fp, #-28]
      do
	{
	  *x1++ = *x << k | z;
   1bd18:	e51b3018 	ldr	r3, [fp, #-24]
   1bd1c:	e2832004 	add	r2, r3, #4
   1bd20:	e50b2018 	str	r2, [fp, #-24]
   1bd24:	e51b2014 	ldr	r2, [fp, #-20]
   1bd28:	e5921000 	ldr	r1, [r2]
   1bd2c:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   1bd30:	e1a01211 	lsl	r1, r1, r2
   1bd34:	e51b201c 	ldr	r2, [fp, #-28]
   1bd38:	e1812002 	orr	r2, r1, r2
   1bd3c:	e5832000 	str	r2, [r3]
	  z = *x++ >> k1;
   1bd40:	e51b3014 	ldr	r3, [fp, #-20]
   1bd44:	e2832004 	add	r2, r3, #4
   1bd48:	e50b2014 	str	r2, [fp, #-20]
   1bd4c:	e5932000 	ldr	r2, [r3]
   1bd50:	e51b300c 	ldr	r3, [fp, #-12]
   1bd54:	e1a03332 	lsr	r3, r2, r3
   1bd58:	e50b301c 	str	r3, [fp, #-28]
	}
      while (x < xe);
   1bd5c:	e51b2014 	ldr	r2, [fp, #-20]
   1bd60:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1bd64:	e1520003 	cmp	r2, r3
   1bd68:	3affffea 	bcc	1bd18 <__lshift+0x128>
      if ((*x1 = z) != 0)
   1bd6c:	e51b3018 	ldr	r3, [fp, #-24]
   1bd70:	e51b201c 	ldr	r2, [fp, #-28]
   1bd74:	e5832000 	str	r2, [r3]
   1bd78:	e51b3018 	ldr	r3, [fp, #-24]
   1bd7c:	e5933000 	ldr	r3, [r3]
   1bd80:	e3530000 	cmp	r3, #0
   1bd84:	0a00000f 	beq	1bdc8 <__lshift+0x1d8>
	++n1;
   1bd88:	e51b3010 	ldr	r3, [fp, #-16]
   1bd8c:	e2833001 	add	r3, r3, #1
   1bd90:	e50b3010 	str	r3, [fp, #-16]
   1bd94:	ea00000b 	b	1bdc8 <__lshift+0x1d8>
	++n1;
    }
#endif
  else
    do
      *x1++ = *x++;
   1bd98:	e51b3018 	ldr	r3, [fp, #-24]
   1bd9c:	e2832004 	add	r2, r3, #4
   1bda0:	e50b2018 	str	r2, [fp, #-24]
   1bda4:	e51b2014 	ldr	r2, [fp, #-20]
   1bda8:	e2821004 	add	r1, r2, #4
   1bdac:	e50b1014 	str	r1, [fp, #-20]
   1bdb0:	e5922000 	ldr	r2, [r2]
   1bdb4:	e5832000 	str	r2, [r3]
    while (x < xe);
   1bdb8:	e51b2014 	ldr	r2, [fp, #-20]
   1bdbc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1bdc0:	e1520003 	cmp	r2, r3
   1bdc4:	3afffff3 	bcc	1bd98 <__lshift+0x1a8>
  b1->_wds = n1 - 1;
   1bdc8:	e51b3010 	ldr	r3, [fp, #-16]
   1bdcc:	e2432001 	sub	r2, r3, #1
   1bdd0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1bdd4:	e5832010 	str	r2, [r3, #16]
  Bfree (ptr, b);
   1bdd8:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   1bddc:	e51b1034 	ldr	r1, [fp, #-52]	; 0x34
   1bde0:	ebfffcc0 	bl	1b0e8 <_Bfree>
  return b1;
   1bde4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
}
   1bde8:	e1a00003 	mov	r0, r3
   1bdec:	e24bd004 	sub	sp, fp, #4
   1bdf0:	e8bd4800 	pop	{fp, lr}
   1bdf4:	e12fff1e 	bx	lr

0001bdf8 <__mcmp>:

int
_DEFUN (cmp, (a, b), _Bigint * a _AND _Bigint * b)
{
   1bdf8:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   1bdfc:	e28db000 	add	fp, sp, #0
   1be00:	e24dd024 	sub	sp, sp, #36	; 0x24
   1be04:	e50b0020 	str	r0, [fp, #-32]
   1be08:	e50b1024 	str	r1, [fp, #-36]	; 0x24
  __ULong *xa, *xa0, *xb, *xb0;
  int i, j;

  i = a->_wds;
   1be0c:	e51b3020 	ldr	r3, [fp, #-32]
   1be10:	e5933010 	ldr	r3, [r3, #16]
   1be14:	e50b3010 	str	r3, [fp, #-16]
  j = b->_wds;
   1be18:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1be1c:	e5933010 	ldr	r3, [r3, #16]
   1be20:	e50b3014 	str	r3, [fp, #-20]
  if (i > 1 && !a->_x[i - 1])
    Bug ("cmp called with a->_x[a->_wds-1] == 0");
  if (j > 1 && !b->_x[j - 1])
    Bug ("cmp called with b->_x[b->_wds-1] == 0");
#endif
  if (i -= j)
   1be24:	e51b2010 	ldr	r2, [fp, #-16]
   1be28:	e51b3014 	ldr	r3, [fp, #-20]
   1be2c:	e0633002 	rsb	r3, r3, r2
   1be30:	e50b3010 	str	r3, [fp, #-16]
   1be34:	e51b3010 	ldr	r3, [fp, #-16]
   1be38:	e3530000 	cmp	r3, #0
   1be3c:	0a000001 	beq	1be48 <__mcmp+0x50>
    return i;
   1be40:	e51b3010 	ldr	r3, [fp, #-16]
   1be44:	ea00002d 	b	1bf00 <__mcmp+0x108>
  xa0 = a->_x;
   1be48:	e51b3020 	ldr	r3, [fp, #-32]
   1be4c:	e2833014 	add	r3, r3, #20
   1be50:	e50b3018 	str	r3, [fp, #-24]
  xa = xa0 + j;
   1be54:	e51b3014 	ldr	r3, [fp, #-20]
   1be58:	e1a03103 	lsl	r3, r3, #2
   1be5c:	e51b2018 	ldr	r2, [fp, #-24]
   1be60:	e0823003 	add	r3, r2, r3
   1be64:	e50b3008 	str	r3, [fp, #-8]
  xb0 = b->_x;
   1be68:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1be6c:	e2833014 	add	r3, r3, #20
   1be70:	e50b301c 	str	r3, [fp, #-28]
  xb = xb0 + j;
   1be74:	e51b3014 	ldr	r3, [fp, #-20]
   1be78:	e1a03103 	lsl	r3, r3, #2
   1be7c:	e51b201c 	ldr	r2, [fp, #-28]
   1be80:	e0823003 	add	r3, r2, r3
   1be84:	e50b300c 	str	r3, [fp, #-12]
  for (;;)
    {
      if (*--xa != *--xb)
   1be88:	e51b3008 	ldr	r3, [fp, #-8]
   1be8c:	e2433004 	sub	r3, r3, #4
   1be90:	e50b3008 	str	r3, [fp, #-8]
   1be94:	e51b3008 	ldr	r3, [fp, #-8]
   1be98:	e5932000 	ldr	r2, [r3]
   1be9c:	e51b300c 	ldr	r3, [fp, #-12]
   1bea0:	e2433004 	sub	r3, r3, #4
   1bea4:	e50b300c 	str	r3, [fp, #-12]
   1bea8:	e51b300c 	ldr	r3, [fp, #-12]
   1beac:	e5933000 	ldr	r3, [r3]
   1beb0:	e1520003 	cmp	r2, r3
   1beb4:	0a000009 	beq	1bee0 <__mcmp+0xe8>
	return *xa < *xb ? -1 : 1;
   1beb8:	e51b3008 	ldr	r3, [fp, #-8]
   1bebc:	e5932000 	ldr	r2, [r3]
   1bec0:	e51b300c 	ldr	r3, [fp, #-12]
   1bec4:	e5933000 	ldr	r3, [r3]
   1bec8:	e1520003 	cmp	r2, r3
   1becc:	2a000001 	bcs	1bed8 <__mcmp+0xe0>
   1bed0:	e3e03000 	mvn	r3, #0
   1bed4:	ea000009 	b	1bf00 <__mcmp+0x108>
   1bed8:	e3a03001 	mov	r3, #1
   1bedc:	ea000007 	b	1bf00 <__mcmp+0x108>
      if (xa <= xa0)
   1bee0:	e51b2008 	ldr	r2, [fp, #-8]
   1bee4:	e51b3018 	ldr	r3, [fp, #-24]
   1bee8:	e1520003 	cmp	r2, r3
   1beec:	8a000002 	bhi	1befc <__mcmp+0x104>
	break;
   1bef0:	e1a00000 	nop			; (mov r0, r0)
    }
  return 0;
   1bef4:	e3a03000 	mov	r3, #0
   1bef8:	ea000000 	b	1bf00 <__mcmp+0x108>
    {
      if (*--xa != *--xb)
	return *xa < *xb ? -1 : 1;
      if (xa <= xa0)
	break;
    }
   1befc:	eaffffe1 	b	1be88 <__mcmp+0x90>
  return 0;
}
   1bf00:	e1a00003 	mov	r0, r3
   1bf04:	e24bd000 	sub	sp, fp, #0
   1bf08:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1bf0c:	e12fff1e 	bx	lr

0001bf10 <__mdiff>:

_Bigint *
_DEFUN (diff, (ptr, a, b), struct _reent * ptr _AND
	_Bigint * a _AND _Bigint * b)
{
   1bf10:	e92d4800 	push	{fp, lr}
   1bf14:	e28db004 	add	fp, sp, #4
   1bf18:	e24dd040 	sub	sp, sp, #64	; 0x40
   1bf1c:	e50b0038 	str	r0, [fp, #-56]	; 0x38
   1bf20:	e50b103c 	str	r1, [fp, #-60]	; 0x3c
   1bf24:	e50b2040 	str	r2, [fp, #-64]	; 0x40
  __ULong *xa, *xae, *xb, *xbe, *xc;
#ifdef Pack_32
  __Long z;
#endif

  i = cmp (a, b);
   1bf28:	e51b003c 	ldr	r0, [fp, #-60]	; 0x3c
   1bf2c:	e51b1040 	ldr	r1, [fp, #-64]	; 0x40
   1bf30:	ebffffb0 	bl	1bdf8 <__mcmp>
   1bf34:	e50b0008 	str	r0, [fp, #-8]
  if (!i)
   1bf38:	e51b3008 	ldr	r3, [fp, #-8]
   1bf3c:	e3530000 	cmp	r3, #0
   1bf40:	1a00000b 	bne	1bf74 <__mdiff+0x64>
    {
      c = Balloc (ptr, 0);
   1bf44:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
   1bf48:	e3a01000 	mov	r1, #0
   1bf4c:	ebfffc19 	bl	1afb8 <_Balloc>
   1bf50:	e50b0020 	str	r0, [fp, #-32]
      c->_wds = 1;
   1bf54:	e51b3020 	ldr	r3, [fp, #-32]
   1bf58:	e3a02001 	mov	r2, #1
   1bf5c:	e5832010 	str	r2, [r3, #16]
      c->_x[0] = 0;
   1bf60:	e51b3020 	ldr	r3, [fp, #-32]
   1bf64:	e3a02000 	mov	r2, #0
   1bf68:	e5832014 	str	r2, [r3, #20]
      return c;
   1bf6c:	e51b3020 	ldr	r3, [fp, #-32]
   1bf70:	ea000092 	b	1c1c0 <__mdiff+0x2b0>
    }
  if (i < 0)
   1bf74:	e51b3008 	ldr	r3, [fp, #-8]
   1bf78:	e3530000 	cmp	r3, #0
   1bf7c:	aa000008 	bge	1bfa4 <__mdiff+0x94>
    {
      c = a;
   1bf80:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1bf84:	e50b3020 	str	r3, [fp, #-32]
      a = b;
   1bf88:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1bf8c:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
      b = c;
   1bf90:	e51b3020 	ldr	r3, [fp, #-32]
   1bf94:	e50b3040 	str	r3, [fp, #-64]	; 0x40
      i = 1;
   1bf98:	e3a03001 	mov	r3, #1
   1bf9c:	e50b3008 	str	r3, [fp, #-8]
   1bfa0:	ea000001 	b	1bfac <__mdiff+0x9c>
    }
  else
    i = 0;
   1bfa4:	e3a03000 	mov	r3, #0
   1bfa8:	e50b3008 	str	r3, [fp, #-8]
  c = Balloc (ptr, a->_k);
   1bfac:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1bfb0:	e5933004 	ldr	r3, [r3, #4]
   1bfb4:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
   1bfb8:	e1a01003 	mov	r1, r3
   1bfbc:	ebfffbfd 	bl	1afb8 <_Balloc>
   1bfc0:	e50b0020 	str	r0, [fp, #-32]
  c->_sign = i;
   1bfc4:	e51b3020 	ldr	r3, [fp, #-32]
   1bfc8:	e51b2008 	ldr	r2, [fp, #-8]
   1bfcc:	e583200c 	str	r2, [r3, #12]
  wa = a->_wds;
   1bfd0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1bfd4:	e5933010 	ldr	r3, [r3, #16]
   1bfd8:	e50b300c 	str	r3, [fp, #-12]
  xa = a->_x;
   1bfdc:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1bfe0:	e2833014 	add	r3, r3, #20
   1bfe4:	e50b3014 	str	r3, [fp, #-20]
  xae = xa + wa;
   1bfe8:	e51b300c 	ldr	r3, [fp, #-12]
   1bfec:	e1a03103 	lsl	r3, r3, #2
   1bff0:	e51b2014 	ldr	r2, [fp, #-20]
   1bff4:	e0823003 	add	r3, r2, r3
   1bff8:	e50b3024 	str	r3, [fp, #-36]	; 0x24
  wb = b->_wds;
   1bffc:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1c000:	e5933010 	ldr	r3, [r3, #16]
   1c004:	e50b3028 	str	r3, [fp, #-40]	; 0x28
  xb = b->_x;
   1c008:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1c00c:	e2833014 	add	r3, r3, #20
   1c010:	e50b3018 	str	r3, [fp, #-24]
  xbe = xb + wb;
   1c014:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1c018:	e1a03103 	lsl	r3, r3, #2
   1c01c:	e51b2018 	ldr	r2, [fp, #-24]
   1c020:	e0823003 	add	r3, r2, r3
   1c024:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
  xc = c->_x;
   1c028:	e51b3020 	ldr	r3, [fp, #-32]
   1c02c:	e2833014 	add	r3, r3, #20
   1c030:	e50b301c 	str	r3, [fp, #-28]
  borrow = 0;
   1c034:	e3a03000 	mov	r3, #0
   1c038:	e50b3010 	str	r3, [fp, #-16]
#ifdef Pack_32
  do
    {
      y = (*xa & 0xffff) - (*xb & 0xffff) + borrow;
   1c03c:	e51b3014 	ldr	r3, [fp, #-20]
   1c040:	e5933000 	ldr	r3, [r3]
   1c044:	e1a02803 	lsl	r2, r3, #16
   1c048:	e1a02822 	lsr	r2, r2, #16
   1c04c:	e51b3018 	ldr	r3, [fp, #-24]
   1c050:	e5933000 	ldr	r3, [r3]
   1c054:	e1a03803 	lsl	r3, r3, #16
   1c058:	e1a03823 	lsr	r3, r3, #16
   1c05c:	e0632002 	rsb	r2, r3, r2
   1c060:	e51b3010 	ldr	r3, [fp, #-16]
   1c064:	e0823003 	add	r3, r2, r3
   1c068:	e50b3030 	str	r3, [fp, #-48]	; 0x30
      borrow = y >> 16;
   1c06c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1c070:	e1a03843 	asr	r3, r3, #16
   1c074:	e50b3010 	str	r3, [fp, #-16]
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) - (*xb++ >> 16) + borrow;
   1c078:	e51b3014 	ldr	r3, [fp, #-20]
   1c07c:	e2832004 	add	r2, r3, #4
   1c080:	e50b2014 	str	r2, [fp, #-20]
   1c084:	e5933000 	ldr	r3, [r3]
   1c088:	e1a02823 	lsr	r2, r3, #16
   1c08c:	e51b3018 	ldr	r3, [fp, #-24]
   1c090:	e2831004 	add	r1, r3, #4
   1c094:	e50b1018 	str	r1, [fp, #-24]
   1c098:	e5933000 	ldr	r3, [r3]
   1c09c:	e1a03823 	lsr	r3, r3, #16
   1c0a0:	e0632002 	rsb	r2, r3, r2
   1c0a4:	e51b3010 	ldr	r3, [fp, #-16]
   1c0a8:	e0823003 	add	r3, r2, r3
   1c0ac:	e50b3034 	str	r3, [fp, #-52]	; 0x34
      borrow = z >> 16;
   1c0b0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1c0b4:	e1a03843 	asr	r3, r3, #16
   1c0b8:	e50b3010 	str	r3, [fp, #-16]
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   1c0bc:	e51b201c 	ldr	r2, [fp, #-28]
   1c0c0:	e2823004 	add	r3, r2, #4
   1c0c4:	e50b301c 	str	r3, [fp, #-28]
   1c0c8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1c0cc:	e1a01803 	lsl	r1, r3, #16
   1c0d0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1c0d4:	e1a03803 	lsl	r3, r3, #16
   1c0d8:	e1a03823 	lsr	r3, r3, #16
   1c0dc:	e1813003 	orr	r3, r1, r3
   1c0e0:	e5823000 	str	r3, [r2]
    }
  while (xb < xbe);
   1c0e4:	e51b2018 	ldr	r2, [fp, #-24]
   1c0e8:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1c0ec:	e1520003 	cmp	r2, r3
   1c0f0:	3affffd1 	bcc	1c03c <__mdiff+0x12c>
  while (xa < xae)
   1c0f4:	ea00001e 	b	1c174 <__mdiff+0x264>
    {
      y = (*xa & 0xffff) + borrow;
   1c0f8:	e51b3014 	ldr	r3, [fp, #-20]
   1c0fc:	e5933000 	ldr	r3, [r3]
   1c100:	e1a03803 	lsl	r3, r3, #16
   1c104:	e1a03823 	lsr	r3, r3, #16
   1c108:	e51b2010 	ldr	r2, [fp, #-16]
   1c10c:	e0833002 	add	r3, r3, r2
   1c110:	e50b3030 	str	r3, [fp, #-48]	; 0x30
      borrow = y >> 16;
   1c114:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1c118:	e1a03843 	asr	r3, r3, #16
   1c11c:	e50b3010 	str	r3, [fp, #-16]
      Sign_Extend (borrow, y);
      z = (*xa++ >> 16) + borrow;
   1c120:	e51b3014 	ldr	r3, [fp, #-20]
   1c124:	e2832004 	add	r2, r3, #4
   1c128:	e50b2014 	str	r2, [fp, #-20]
   1c12c:	e5933000 	ldr	r3, [r3]
   1c130:	e1a02823 	lsr	r2, r3, #16
   1c134:	e51b3010 	ldr	r3, [fp, #-16]
   1c138:	e0823003 	add	r3, r2, r3
   1c13c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
      borrow = z >> 16;
   1c140:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1c144:	e1a03843 	asr	r3, r3, #16
   1c148:	e50b3010 	str	r3, [fp, #-16]
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
   1c14c:	e51b201c 	ldr	r2, [fp, #-28]
   1c150:	e2823004 	add	r3, r2, #4
   1c154:	e50b301c 	str	r3, [fp, #-28]
   1c158:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1c15c:	e1a01803 	lsl	r1, r3, #16
   1c160:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1c164:	e1a03803 	lsl	r3, r3, #16
   1c168:	e1a03823 	lsr	r3, r3, #16
   1c16c:	e1813003 	orr	r3, r1, r3
   1c170:	e5823000 	str	r3, [r2]
      borrow = z >> 16;
      Sign_Extend (borrow, z);
      Storeinc (xc, z, y);
    }
  while (xb < xbe);
  while (xa < xae)
   1c174:	e51b2014 	ldr	r2, [fp, #-20]
   1c178:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1c17c:	e1520003 	cmp	r2, r3
   1c180:	3affffdc 	bcc	1c0f8 <__mdiff+0x1e8>
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
   1c184:	ea000002 	b	1c194 <__mdiff+0x284>
    wa--;
   1c188:	e51b300c 	ldr	r3, [fp, #-12]
   1c18c:	e2433001 	sub	r3, r3, #1
   1c190:	e50b300c 	str	r3, [fp, #-12]
      borrow = y >> 16;
      Sign_Extend (borrow, y);
      *xc++ = y & 0xffff;
    }
#endif
  while (!*--xc)
   1c194:	e51b301c 	ldr	r3, [fp, #-28]
   1c198:	e2433004 	sub	r3, r3, #4
   1c19c:	e50b301c 	str	r3, [fp, #-28]
   1c1a0:	e51b301c 	ldr	r3, [fp, #-28]
   1c1a4:	e5933000 	ldr	r3, [r3]
   1c1a8:	e3530000 	cmp	r3, #0
   1c1ac:	0afffff5 	beq	1c188 <__mdiff+0x278>
    wa--;
  c->_wds = wa;
   1c1b0:	e51b3020 	ldr	r3, [fp, #-32]
   1c1b4:	e51b200c 	ldr	r2, [fp, #-12]
   1c1b8:	e5832010 	str	r2, [r3, #16]
  return c;
   1c1bc:	e51b3020 	ldr	r3, [fp, #-32]
}
   1c1c0:	e1a00003 	mov	r0, r3
   1c1c4:	e24bd004 	sub	sp, fp, #4
   1c1c8:	e8bd4800 	pop	{fp, lr}
   1c1cc:	e12fff1e 	bx	lr

0001c1d0 <__ulp>:

double
_DEFUN (ulp, (_x), double _x)
{
   1c1d0:	e92d0810 	push	{r4, fp}
   1c1d4:	e28db004 	add	fp, sp, #4
   1c1d8:	e24dd018 	sub	sp, sp, #24
   1c1dc:	e50b001c 	str	r0, [fp, #-28]
   1c1e0:	e50b1018 	str	r1, [fp, #-24]
  union double_union x, a;
  register __Long L;

  x.d = _x;
   1c1e4:	e24b401c 	sub	r4, fp, #28
   1c1e8:	e8940018 	ldm	r4, {r3, r4}
   1c1ec:	e50b300c 	str	r3, [fp, #-12]
   1c1f0:	e50b4008 	str	r4, [fp, #-8]

  L = (word0 (x) & Exp_mask) - (P - 1) * Exp_msk1;
   1c1f4:	e51b2008 	ldr	r2, [fp, #-8]
   1c1f8:	e59f3094 	ldr	r3, [pc, #148]	; 1c294 <__ulp+0xc4>
   1c1fc:	e0033002 	and	r3, r3, r2
   1c200:	e243350d 	sub	r3, r3, #54525952	; 0x3400000
   1c204:	e1a04003 	mov	r4, r3
#ifndef Sudden_Underflow
  if (L > 0)
   1c208:	e3540000 	cmp	r4, #0
   1c20c:	da000004 	ble	1c224 <__ulp+0x54>
    {
#endif
#ifdef IBM
      L |= Exp_msk1 >> 4;
#endif
      word0 (a) = L;
   1c210:	e1a03004 	mov	r3, r4
   1c214:	e50b3010 	str	r3, [fp, #-16]
#ifndef _DOUBLE_IS_32BITS
      word1 (a) = 0;
   1c218:	e3a03000 	mov	r3, #0
   1c21c:	e50b3014 	str	r3, [fp, #-20]
   1c220:	ea000014 	b	1c278 <__ulp+0xa8>

#ifndef Sudden_Underflow
    }
  else
    {
      L = -L >> Exp_shift;
   1c224:	e2643000 	rsb	r3, r4, #0
   1c228:	e1a04a43 	asr	r4, r3, #20
      if (L < Exp_shift)
   1c22c:	e3540013 	cmp	r4, #19
   1c230:	ca000005 	bgt	1c24c <__ulp+0x7c>
	{
	  word0 (a) = 0x80000 >> L;
   1c234:	e3a03702 	mov	r3, #524288	; 0x80000
   1c238:	e1a03453 	asr	r3, r3, r4
   1c23c:	e50b3010 	str	r3, [fp, #-16]
#ifndef _DOUBLE_IS_32BITS
	  word1 (a) = 0;
   1c240:	e3a03000 	mov	r3, #0
   1c244:	e50b3014 	str	r3, [fp, #-20]
   1c248:	ea00000a 	b	1c278 <__ulp+0xa8>
#endif
	}
      else
	{
	  word0 (a) = 0;
   1c24c:	e3a03000 	mov	r3, #0
   1c250:	e50b3010 	str	r3, [fp, #-16]
	  L -= Exp_shift;
   1c254:	e2444014 	sub	r4, r4, #20
#ifndef _DOUBLE_IS_32BITS
         word1 (a) = L >= 31 ? 1 : 1 << (31 - L);
   1c258:	e354001e 	cmp	r4, #30
   1c25c:	ca000003 	bgt	1c270 <__ulp+0xa0>
   1c260:	e264301f 	rsb	r3, r4, #31
   1c264:	e3a02001 	mov	r2, #1
   1c268:	e1a03312 	lsl	r3, r2, r3
   1c26c:	ea000000 	b	1c274 <__ulp+0xa4>
   1c270:	e3a03001 	mov	r3, #1
   1c274:	e50b3014 	str	r3, [fp, #-20]
#endif
	}
    }
#endif
  return a.d;
   1c278:	e24b4014 	sub	r4, fp, #20
   1c27c:	e8940018 	ldm	r4, {r3, r4}
}
   1c280:	e1a00003 	mov	r0, r3
   1c284:	e1a01004 	mov	r1, r4
   1c288:	e24bd004 	sub	sp, fp, #4
   1c28c:	e8bd0810 	pop	{r4, fp}
   1c290:	e12fff1e 	bx	lr
   1c294:	7ff00000 	.word	0x7ff00000

0001c298 <__b2d>:

double
_DEFUN (b2d, (a, e),
	_Bigint * a _AND int *e)
{
   1c298:	e92d4810 	push	{r4, fp, lr}
   1c29c:	e28db008 	add	fp, sp, #8
   1c2a0:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   1c2a4:	e50b0030 	str	r0, [fp, #-48]	; 0x30
   1c2a8:	e50b1034 	str	r1, [fp, #-52]	; 0x34
#else
#define d0 word0(d)
#define d1 word1(d)
#endif

  xa0 = a->_x;
   1c2ac:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1c2b0:	e2833014 	add	r3, r3, #20
   1c2b4:	e50b3014 	str	r3, [fp, #-20]
  xa = xa0 + a->_wds;
   1c2b8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1c2bc:	e5933010 	ldr	r3, [r3, #16]
   1c2c0:	e1a03103 	lsl	r3, r3, #2
   1c2c4:	e51b2014 	ldr	r2, [fp, #-20]
   1c2c8:	e0823003 	add	r3, r2, r3
   1c2cc:	e50b3010 	str	r3, [fp, #-16]
  y = *--xa;
   1c2d0:	e51b3010 	ldr	r3, [fp, #-16]
   1c2d4:	e2433004 	sub	r3, r3, #4
   1c2d8:	e50b3010 	str	r3, [fp, #-16]
   1c2dc:	e51b3010 	ldr	r3, [fp, #-16]
   1c2e0:	e5933000 	ldr	r3, [r3]
   1c2e4:	e50b3018 	str	r3, [fp, #-24]
#ifdef DEBUG
  if (!y)
    Bug ("zero y in b2d");
#endif
  k = hi0bits (y);
   1c2e8:	e51b0018 	ldr	r0, [fp, #-24]
   1c2ec:	ebfffc62 	bl	1b47c <__hi0bits>
   1c2f0:	e50b001c 	str	r0, [fp, #-28]
  *e = 32 - k;
   1c2f4:	e51b301c 	ldr	r3, [fp, #-28]
   1c2f8:	e2632020 	rsb	r2, r3, #32
   1c2fc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1c300:	e5832000 	str	r2, [r3]
#ifdef Pack_32
  if (k < Ebits)
   1c304:	e51b301c 	ldr	r3, [fp, #-28]
   1c308:	e353000a 	cmp	r3, #10
   1c30c:	ca00001d 	bgt	1c388 <__b2d+0xf0>
    {
      d0 = Exp_1 | y >> (Ebits - k);
   1c310:	e51b301c 	ldr	r3, [fp, #-28]
   1c314:	e263300b 	rsb	r3, r3, #11
   1c318:	e51b2018 	ldr	r2, [fp, #-24]
   1c31c:	e1a03332 	lsr	r3, r2, r3
   1c320:	e38335ff 	orr	r3, r3, #1069547520	; 0x3fc00000
   1c324:	e3833603 	orr	r3, r3, #3145728	; 0x300000
   1c328:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      w = xa > xa0 ? *--xa : 0;
   1c32c:	e51b2010 	ldr	r2, [fp, #-16]
   1c330:	e51b3014 	ldr	r3, [fp, #-20]
   1c334:	e1520003 	cmp	r2, r3
   1c338:	9a000005 	bls	1c354 <__b2d+0xbc>
   1c33c:	e51b3010 	ldr	r3, [fp, #-16]
   1c340:	e2433004 	sub	r3, r3, #4
   1c344:	e50b3010 	str	r3, [fp, #-16]
   1c348:	e51b3010 	ldr	r3, [fp, #-16]
   1c34c:	e5933000 	ldr	r3, [r3]
   1c350:	ea000000 	b	1c358 <__b2d+0xc0>
   1c354:	e3a03000 	mov	r3, #0
   1c358:	e50b3020 	str	r3, [fp, #-32]
#ifndef _DOUBLE_IS_32BITS
      d1 = y << ((32 - Ebits) + k) | w >> (Ebits - k);
   1c35c:	e51b301c 	ldr	r3, [fp, #-28]
   1c360:	e2833015 	add	r3, r3, #21
   1c364:	e51b2018 	ldr	r2, [fp, #-24]
   1c368:	e1a02312 	lsl	r2, r2, r3
   1c36c:	e51b301c 	ldr	r3, [fp, #-28]
   1c370:	e263300b 	rsb	r3, r3, #11
   1c374:	e51b1020 	ldr	r1, [fp, #-32]
   1c378:	e1a03331 	lsr	r3, r1, r3
   1c37c:	e1823003 	orr	r3, r2, r3
   1c380:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
#endif
      goto ret_d;
   1c384:	ea000038 	b	1c46c <__b2d+0x1d4>
    }
  z = xa > xa0 ? *--xa : 0;
   1c388:	e51b2010 	ldr	r2, [fp, #-16]
   1c38c:	e51b3014 	ldr	r3, [fp, #-20]
   1c390:	e1520003 	cmp	r2, r3
   1c394:	9a000005 	bls	1c3b0 <__b2d+0x118>
   1c398:	e51b3010 	ldr	r3, [fp, #-16]
   1c39c:	e2433004 	sub	r3, r3, #4
   1c3a0:	e50b3010 	str	r3, [fp, #-16]
   1c3a4:	e51b3010 	ldr	r3, [fp, #-16]
   1c3a8:	e5933000 	ldr	r3, [r3]
   1c3ac:	ea000000 	b	1c3b4 <__b2d+0x11c>
   1c3b0:	e3a03000 	mov	r3, #0
   1c3b4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
  if (k -= Ebits)
   1c3b8:	e51b301c 	ldr	r3, [fp, #-28]
   1c3bc:	e243300b 	sub	r3, r3, #11
   1c3c0:	e50b301c 	str	r3, [fp, #-28]
   1c3c4:	e51b301c 	ldr	r3, [fp, #-28]
   1c3c8:	e3530000 	cmp	r3, #0
   1c3cc:	0a000020 	beq	1c454 <__b2d+0x1bc>
    {
      d0 = Exp_1 | y << k | z >> (32 - k);
   1c3d0:	e51b2018 	ldr	r2, [fp, #-24]
   1c3d4:	e51b301c 	ldr	r3, [fp, #-28]
   1c3d8:	e1a02312 	lsl	r2, r2, r3
   1c3dc:	e51b301c 	ldr	r3, [fp, #-28]
   1c3e0:	e2633020 	rsb	r3, r3, #32
   1c3e4:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
   1c3e8:	e1a03331 	lsr	r3, r1, r3
   1c3ec:	e1823003 	orr	r3, r2, r3
   1c3f0:	e38335ff 	orr	r3, r3, #1069547520	; 0x3fc00000
   1c3f4:	e3833603 	orr	r3, r3, #3145728	; 0x300000
   1c3f8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
      y = xa > xa0 ? *--xa : 0;
   1c3fc:	e51b2010 	ldr	r2, [fp, #-16]
   1c400:	e51b3014 	ldr	r3, [fp, #-20]
   1c404:	e1520003 	cmp	r2, r3
   1c408:	9a000005 	bls	1c424 <__b2d+0x18c>
   1c40c:	e51b3010 	ldr	r3, [fp, #-16]
   1c410:	e2433004 	sub	r3, r3, #4
   1c414:	e50b3010 	str	r3, [fp, #-16]
   1c418:	e51b3010 	ldr	r3, [fp, #-16]
   1c41c:	e5933000 	ldr	r3, [r3]
   1c420:	ea000000 	b	1c428 <__b2d+0x190>
   1c424:	e3a03000 	mov	r3, #0
   1c428:	e50b3018 	str	r3, [fp, #-24]
#ifndef _DOUBLE_IS_32BITS
      d1 = z << k | y >> (32 - k);
   1c42c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1c430:	e51b301c 	ldr	r3, [fp, #-28]
   1c434:	e1a02312 	lsl	r2, r2, r3
   1c438:	e51b301c 	ldr	r3, [fp, #-28]
   1c43c:	e2633020 	rsb	r3, r3, #32
   1c440:	e51b1018 	ldr	r1, [fp, #-24]
   1c444:	e1a03331 	lsr	r3, r1, r3
   1c448:	e1823003 	orr	r3, r2, r3
   1c44c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   1c450:	ea000005 	b	1c46c <__b2d+0x1d4>
#endif
    }
  else
    {
      d0 = Exp_1 | y;
   1c454:	e51b3018 	ldr	r3, [fp, #-24]
   1c458:	e38335ff 	orr	r3, r3, #1069547520	; 0x3fc00000
   1c45c:	e3833603 	orr	r3, r3, #3145728	; 0x300000
   1c460:	e50b3028 	str	r3, [fp, #-40]	; 0x28
#ifndef _DOUBLE_IS_32BITS
      d1 = z;
   1c464:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1c468:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
  word1 (d) = d1 >> 16 | d1 << 16;
#else
#undef d0
#undef d1
#endif
  return d.d;
   1c46c:	e24b402c 	sub	r4, fp, #44	; 0x2c
   1c470:	e8940018 	ldm	r4, {r3, r4}
}
   1c474:	e1a00003 	mov	r0, r3
   1c478:	e1a01004 	mov	r1, r4
   1c47c:	e24bd008 	sub	sp, fp, #8
   1c480:	e8bd4810 	pop	{r4, fp, lr}
   1c484:	e12fff1e 	bx	lr

0001c488 <__d2b>:
	struct _reent * ptr _AND
	double _d _AND
	int *e _AND
	int *bits)

{
   1c488:	e92d4810 	push	{r4, fp, lr}
   1c48c:	e28db008 	add	fp, sp, #8
   1c490:	e24dd03c 	sub	sp, sp, #60	; 0x3c
   1c494:	e50b0038 	str	r0, [fp, #-56]	; 0x38
   1c498:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   1c49c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
  int de, i, k;
  __ULong *x, y, z;
#ifdef VAX
  __ULong d0, d1;
#endif
  d.d = _d;
   1c4a0:	e24b4044 	sub	r4, fp, #68	; 0x44
   1c4a4:	e8940018 	ldm	r4, {r3, r4}
   1c4a8:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   1c4ac:	e50b4028 	str	r4, [fp, #-40]	; 0x28
  d0 = word0 (d) >> 16 | word0 (d) << 16;
  d1 = word1 (d) >> 16 | word1 (d) << 16;
#else
#define d0 word0(d)
#define d1 word1(d)
  d.d = _d;
   1c4b0:	e24b4044 	sub	r4, fp, #68	; 0x44
   1c4b4:	e8940018 	ldm	r4, {r3, r4}
   1c4b8:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   1c4bc:	e50b4028 	str	r4, [fp, #-40]	; 0x28
#endif

#ifdef Pack_32
  b = Balloc (ptr, 1);
   1c4c0:	e51b0038 	ldr	r0, [fp, #-56]	; 0x38
   1c4c4:	e3a01001 	mov	r1, #1
   1c4c8:	ebfffaba 	bl	1afb8 <_Balloc>
   1c4cc:	e50b0018 	str	r0, [fp, #-24]
#else
  b = Balloc (ptr, 2);
#endif
  x = b->_x;
   1c4d0:	e51b3018 	ldr	r3, [fp, #-24]
   1c4d4:	e2833014 	add	r3, r3, #20
   1c4d8:	e50b301c 	str	r3, [fp, #-28]

  z = d0 & Frac_mask;
   1c4dc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1c4e0:	e3c334ff 	bic	r3, r3, #-16777216	; 0xff000000
   1c4e4:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   1c4e8:	e50b3034 	str	r3, [fp, #-52]	; 0x34
  d0 &= 0x7fffffff;		/* clear sign bit, which we ignore */
   1c4ec:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1c4f0:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   1c4f4:	e50b3028 	str	r3, [fp, #-40]	; 0x28
  de = (int) (d0 >> Exp_shift);
#ifndef IBM
  z |= Exp_msk11;
#endif
#else
  if ((de = (int) (d0 >> Exp_shift)) != 0)
   1c4f8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1c4fc:	e1a03a23 	lsr	r3, r3, #20
   1c500:	e50b3020 	str	r3, [fp, #-32]
   1c504:	e51b3020 	ldr	r3, [fp, #-32]
   1c508:	e3530000 	cmp	r3, #0
   1c50c:	0a000002 	beq	1c51c <__d2b+0x94>
    z |= Exp_msk1;
   1c510:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1c514:	e3833601 	orr	r3, r3, #1048576	; 0x100000
   1c518:	e50b3034 	str	r3, [fp, #-52]	; 0x34
#endif
#ifdef Pack_32
#ifndef _DOUBLE_IS_32BITS
  if (d1)
   1c51c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1c520:	e3530000 	cmp	r3, #0
   1c524:	0a000028 	beq	1c5cc <__d2b+0x144>
    {
      y = d1;
   1c528:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1c52c:	e50b3030 	str	r3, [fp, #-48]	; 0x30
      k = lo0bits (&y);
   1c530:	e24b3030 	sub	r3, fp, #48	; 0x30
   1c534:	e1a00003 	mov	r0, r3
   1c538:	ebfffbf6 	bl	1b518 <__lo0bits>
   1c53c:	e50b0014 	str	r0, [fp, #-20]
      if (k)
   1c540:	e51b3014 	ldr	r3, [fp, #-20]
   1c544:	e3530000 	cmp	r3, #0
   1c548:	0a00000c 	beq	1c580 <__d2b+0xf8>
	{
         x[0] = y | z << (32 - k);
   1c54c:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   1c550:	e51b3014 	ldr	r3, [fp, #-20]
   1c554:	e2633020 	rsb	r3, r3, #32
   1c558:	e1a02312 	lsl	r2, r2, r3
   1c55c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1c560:	e1822003 	orr	r2, r2, r3
   1c564:	e51b301c 	ldr	r3, [fp, #-28]
   1c568:	e5832000 	str	r2, [r3]
	  z >>= k;
   1c56c:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   1c570:	e51b3014 	ldr	r3, [fp, #-20]
   1c574:	e1a03332 	lsr	r3, r2, r3
   1c578:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   1c57c:	ea000002 	b	1c58c <__d2b+0x104>
	}
      else
	x[0] = y;
   1c580:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   1c584:	e51b301c 	ldr	r3, [fp, #-28]
   1c588:	e5832000 	str	r2, [r3]
      i = b->_wds = (x[1] = z) ? 2 : 1;
   1c58c:	e51b301c 	ldr	r3, [fp, #-28]
   1c590:	e2833004 	add	r3, r3, #4
   1c594:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   1c598:	e5832000 	str	r2, [r3]
   1c59c:	e5933000 	ldr	r3, [r3]
   1c5a0:	e3530000 	cmp	r3, #0
   1c5a4:	0a000001 	beq	1c5b0 <__d2b+0x128>
   1c5a8:	e3a03002 	mov	r3, #2
   1c5ac:	ea000000 	b	1c5b4 <__d2b+0x12c>
   1c5b0:	e3a03001 	mov	r3, #1
   1c5b4:	e51b2018 	ldr	r2, [fp, #-24]
   1c5b8:	e5823010 	str	r3, [r2, #16]
   1c5bc:	e51b3018 	ldr	r3, [fp, #-24]
   1c5c0:	e5933010 	ldr	r3, [r3, #16]
   1c5c4:	e50b3010 	str	r3, [fp, #-16]
   1c5c8:	ea00000f 	b	1c60c <__d2b+0x184>
    {
#ifdef DEBUG
      if (!z)
	Bug ("Zero passed to d2b");
#endif
      k = lo0bits (&z);
   1c5cc:	e24b3034 	sub	r3, fp, #52	; 0x34
   1c5d0:	e1a00003 	mov	r0, r3
   1c5d4:	ebfffbcf 	bl	1b518 <__lo0bits>
   1c5d8:	e50b0014 	str	r0, [fp, #-20]
      x[0] = z;
   1c5dc:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
   1c5e0:	e51b301c 	ldr	r3, [fp, #-28]
   1c5e4:	e5832000 	str	r2, [r3]
      i = b->_wds = 1;
   1c5e8:	e51b3018 	ldr	r3, [fp, #-24]
   1c5ec:	e3a02001 	mov	r2, #1
   1c5f0:	e5832010 	str	r2, [r3, #16]
   1c5f4:	e51b3018 	ldr	r3, [fp, #-24]
   1c5f8:	e5933010 	ldr	r3, [r3, #16]
   1c5fc:	e50b3010 	str	r3, [fp, #-16]
#ifndef _DOUBLE_IS_32BITS
      k += 32;
   1c600:	e51b3014 	ldr	r3, [fp, #-20]
   1c604:	e2833020 	add	r3, r3, #32
   1c608:	e50b3014 	str	r3, [fp, #-20]
  while (!x[i])
    --i;
  b->_wds = i + 1;
#endif
#ifndef Sudden_Underflow
  if (de)
   1c60c:	e51b3020 	ldr	r3, [fp, #-32]
   1c610:	e3530000 	cmp	r3, #0
   1c614:	0a00000b 	beq	1c648 <__d2b+0x1c0>
#endif
#ifdef IBM
      *e = (de - Bias - (P - 1) << 2) + k;
      *bits = 4 * P + 8 - k - hi0bits (word0 (d) & Frac_mask);
#else
      *e = de - Bias - (P - 1) + k;
   1c618:	e51b3020 	ldr	r3, [fp, #-32]
   1c61c:	e2433e43 	sub	r3, r3, #1072	; 0x430
   1c620:	e2433003 	sub	r3, r3, #3
   1c624:	e51b2014 	ldr	r2, [fp, #-20]
   1c628:	e0832002 	add	r2, r3, r2
   1c62c:	e59b3004 	ldr	r3, [fp, #4]
   1c630:	e5832000 	str	r2, [r3]
      *bits = P - k;
   1c634:	e51b3014 	ldr	r3, [fp, #-20]
   1c638:	e2632035 	rsb	r2, r3, #53	; 0x35
   1c63c:	e59b3008 	ldr	r3, [fp, #8]
   1c640:	e5832000 	str	r2, [r3]
   1c644:	ea000014 	b	1c69c <__d2b+0x214>
#endif
#ifndef Sudden_Underflow
    }
  else
    {
      *e = de - Bias - (P - 1) + 1 + k;
   1c648:	e51b3020 	ldr	r3, [fp, #-32]
   1c64c:	e2433e43 	sub	r3, r3, #1072	; 0x430
   1c650:	e2433002 	sub	r3, r3, #2
   1c654:	e51b2014 	ldr	r2, [fp, #-20]
   1c658:	e0832002 	add	r2, r3, r2
   1c65c:	e59b3004 	ldr	r3, [fp, #4]
   1c660:	e5832000 	str	r2, [r3]
#ifdef Pack_32
      *bits = 32 * i - hi0bits (x[i - 1]);
   1c664:	e51b3010 	ldr	r3, [fp, #-16]
   1c668:	e1a04283 	lsl	r4, r3, #5
   1c66c:	e51b3010 	ldr	r3, [fp, #-16]
   1c670:	e2433107 	sub	r3, r3, #-1073741823	; 0xc0000001
   1c674:	e1a03103 	lsl	r3, r3, #2
   1c678:	e51b201c 	ldr	r2, [fp, #-28]
   1c67c:	e0823003 	add	r3, r2, r3
   1c680:	e5933000 	ldr	r3, [r3]
   1c684:	e1a00003 	mov	r0, r3
   1c688:	ebfffb7b 	bl	1b47c <__hi0bits>
   1c68c:	e1a03000 	mov	r3, r0
   1c690:	e0632004 	rsb	r2, r3, r4
   1c694:	e59b3008 	ldr	r3, [fp, #8]
   1c698:	e5832000 	str	r2, [r3]
#else
      *bits = (i + 2) * 16 - hi0bits (x[i]);
#endif
    }
#endif
  return b;
   1c69c:	e51b3018 	ldr	r3, [fp, #-24]
}
   1c6a0:	e1a00003 	mov	r0, r3
   1c6a4:	e24bd008 	sub	sp, fp, #8
   1c6a8:	e8bd4810 	pop	{r4, fp, lr}
   1c6ac:	e12fff1e 	bx	lr

0001c6b0 <__ratio>:
#undef d1

double
_DEFUN (ratio, (a, b), _Bigint * a _AND _Bigint * b)

{
   1c6b0:	e92d4810 	push	{r4, fp, lr}
   1c6b4:	e28db008 	add	fp, sp, #8
   1c6b8:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   1c6bc:	e50b0030 	str	r0, [fp, #-48]	; 0x30
   1c6c0:	e50b1034 	str	r1, [fp, #-52]	; 0x34
  union double_union da, db;
  int k, ka, kb;

  da.d = b2d (a, &ka);
   1c6c4:	e24b3028 	sub	r3, fp, #40	; 0x28
   1c6c8:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   1c6cc:	e1a01003 	mov	r1, r3
   1c6d0:	ebfffef0 	bl	1c298 <__b2d>
   1c6d4:	e1a03000 	mov	r3, r0
   1c6d8:	e1a04001 	mov	r4, r1
   1c6dc:	e50b301c 	str	r3, [fp, #-28]
   1c6e0:	e50b4018 	str	r4, [fp, #-24]
  db.d = b2d (b, &kb);
   1c6e4:	e24b302c 	sub	r3, fp, #44	; 0x2c
   1c6e8:	e51b0034 	ldr	r0, [fp, #-52]	; 0x34
   1c6ec:	e1a01003 	mov	r1, r3
   1c6f0:	ebfffee8 	bl	1c298 <__b2d>
   1c6f4:	e1a03000 	mov	r3, r0
   1c6f8:	e1a04001 	mov	r4, r1
   1c6fc:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   1c700:	e50b4020 	str	r4, [fp, #-32]
#ifdef Pack_32
  k = ka - kb + 32 * (a->_wds - b->_wds);
   1c704:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   1c708:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1c70c:	e0632002 	rsb	r2, r3, r2
   1c710:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1c714:	e5931010 	ldr	r1, [r3, #16]
   1c718:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1c71c:	e5933010 	ldr	r3, [r3, #16]
   1c720:	e0633001 	rsb	r3, r3, r1
   1c724:	e1a03283 	lsl	r3, r3, #5
   1c728:	e0823003 	add	r3, r2, r3
   1c72c:	e50b3010 	str	r3, [fp, #-16]
      word0 (db) += (k >> 2) * Exp_msk1;
      if (k &= 3)
	db.d *= 1 << k;
    }
#else
  if (k > 0)
   1c730:	e51b3010 	ldr	r3, [fp, #-16]
   1c734:	e3530000 	cmp	r3, #0
   1c738:	da000005 	ble	1c754 <__ratio+0xa4>
    word0 (da) += k * Exp_msk1;
   1c73c:	e51b2018 	ldr	r2, [fp, #-24]
   1c740:	e51b3010 	ldr	r3, [fp, #-16]
   1c744:	e1a03a03 	lsl	r3, r3, #20
   1c748:	e0823003 	add	r3, r2, r3
   1c74c:	e50b3018 	str	r3, [fp, #-24]
   1c750:	ea000007 	b	1c774 <__ratio+0xc4>
  else
    {
      k = -k;
   1c754:	e51b3010 	ldr	r3, [fp, #-16]
   1c758:	e2633000 	rsb	r3, r3, #0
   1c75c:	e50b3010 	str	r3, [fp, #-16]
      word0 (db) += k * Exp_msk1;
   1c760:	e51b2020 	ldr	r2, [fp, #-32]
   1c764:	e51b3010 	ldr	r3, [fp, #-16]
   1c768:	e1a03a03 	lsl	r3, r3, #20
   1c76c:	e0823003 	add	r3, r2, r3
   1c770:	e50b3020 	str	r3, [fp, #-32]
    }
#endif
  return da.d / db.d;
   1c774:	e24b201c 	sub	r2, fp, #28
   1c778:	e8920006 	ldm	r2, {r1, r2}
   1c77c:	e24b4024 	sub	r4, fp, #36	; 0x24
   1c780:	e8940018 	ldm	r4, {r3, r4}
   1c784:	e1a00001 	mov	r0, r1
   1c788:	e1a01002 	mov	r1, r2
   1c78c:	e1a02003 	mov	r2, r3
   1c790:	e1a03004 	mov	r3, r4
   1c794:	eb00185f 	bl	22918 <__aeabi_ddiv>
   1c798:	e1a03000 	mov	r3, r0
   1c79c:	e1a04001 	mov	r4, r1
}
   1c7a0:	e1a00003 	mov	r0, r3
   1c7a4:	e1a01004 	mov	r1, r4
   1c7a8:	e24bd008 	sub	sp, fp, #8
   1c7ac:	e8bd4810 	pop	{r4, fp, lr}
   1c7b0:	e12fff1e 	bx	lr

0001c7b4 <_mprec_log10>:


double
_DEFUN (_mprec_log10, (dig),
	int dig)
{
   1c7b4:	e92d4810 	push	{r4, fp, lr}
   1c7b8:	e28db008 	add	fp, sp, #8
   1c7bc:	e24dd014 	sub	sp, sp, #20
   1c7c0:	e50b0018 	str	r0, [fp, #-24]
  double v = 1.0;
   1c7c4:	e3a03000 	mov	r3, #0
   1c7c8:	e59f4084 	ldr	r4, [pc, #132]	; 1c854 <_mprec_log10+0xa0>
   1c7cc:	e50b3014 	str	r3, [fp, #-20]
   1c7d0:	e50b4010 	str	r4, [fp, #-16]
  if (dig < 24)
   1c7d4:	e51b3018 	ldr	r3, [fp, #-24]
   1c7d8:	e3530017 	cmp	r3, #23
   1c7dc:	ca000005 	bgt	1c7f8 <_mprec_log10+0x44>
    return tens[dig];
   1c7e0:	e59f2070 	ldr	r2, [pc, #112]	; 1c858 <_mprec_log10+0xa4>
   1c7e4:	e51b3018 	ldr	r3, [fp, #-24]
   1c7e8:	e1a03183 	lsl	r3, r3, #3
   1c7ec:	e0823003 	add	r3, r2, r3
   1c7f0:	e8930018 	ldm	r3, {r3, r4}
   1c7f4:	ea000011 	b	1c840 <_mprec_log10+0x8c>
  while (dig > 0)
   1c7f8:	ea00000b 	b	1c82c <_mprec_log10+0x78>
    {
      v *= 10;
   1c7fc:	e24b1014 	sub	r1, fp, #20
   1c800:	e8910003 	ldm	r1, {r0, r1}
   1c804:	e3a02000 	mov	r2, #0
   1c808:	e59f304c 	ldr	r3, [pc, #76]	; 1c85c <_mprec_log10+0xa8>
   1c80c:	eb00179d 	bl	22688 <__aeabi_dmul>
   1c810:	e1a03000 	mov	r3, r0
   1c814:	e1a04001 	mov	r4, r1
   1c818:	e50b3014 	str	r3, [fp, #-20]
   1c81c:	e50b4010 	str	r4, [fp, #-16]
      dig--;
   1c820:	e51b3018 	ldr	r3, [fp, #-24]
   1c824:	e2433001 	sub	r3, r3, #1
   1c828:	e50b3018 	str	r3, [fp, #-24]
	int dig)
{
  double v = 1.0;
  if (dig < 24)
    return tens[dig];
  while (dig > 0)
   1c82c:	e51b3018 	ldr	r3, [fp, #-24]
   1c830:	e3530000 	cmp	r3, #0
   1c834:	cafffff0 	bgt	1c7fc <_mprec_log10+0x48>
    {
      v *= 10;
      dig--;
    }
  return v;
   1c838:	e24b4014 	sub	r4, fp, #20
   1c83c:	e8940018 	ldm	r4, {r3, r4}
}
   1c840:	e1a00003 	mov	r0, r3
   1c844:	e1a01004 	mov	r1, r4
   1c848:	e24bd008 	sub	sp, fp, #8
   1c84c:	e8bd4810 	pop	{r4, fp, lr}
   1c850:	e12fff1e 	bx	lr
   1c854:	3ff00000 	.word	0x3ff00000
   1c858:	00024828 	.word	0x00024828
   1c85c:	40240000 	.word	0x40240000

0001c860 <__copybits>:
void
_DEFUN (copybits, (c, n, b),
	__ULong *c _AND
	int n _AND
	_Bigint *b)
{
   1c860:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   1c864:	e28db000 	add	fp, sp, #0
   1c868:	e24dd024 	sub	sp, sp, #36	; 0x24
   1c86c:	e50b0018 	str	r0, [fp, #-24]
   1c870:	e50b101c 	str	r1, [fp, #-28]
   1c874:	e50b2020 	str	r2, [fp, #-32]
	__ULong *ce, *x, *xe;
#ifdef Pack_16
	int nw, nw1;
#endif

	ce = c + ((n-1) >> kshift) + 1;
   1c878:	e51b301c 	ldr	r3, [fp, #-28]
   1c87c:	e2433001 	sub	r3, r3, #1
   1c880:	e1a032c3 	asr	r3, r3, #5
   1c884:	e2833001 	add	r3, r3, #1
   1c888:	e1a03103 	lsl	r3, r3, #2
   1c88c:	e51b2018 	ldr	r2, [fp, #-24]
   1c890:	e0823003 	add	r3, r2, r3
   1c894:	e50b300c 	str	r3, [fp, #-12]
	x = b->_x;
   1c898:	e51b3020 	ldr	r3, [fp, #-32]
   1c89c:	e2833014 	add	r3, r3, #20
   1c8a0:	e50b3008 	str	r3, [fp, #-8]
#ifdef Pack_32
	xe = x + b->_wds;
   1c8a4:	e51b3020 	ldr	r3, [fp, #-32]
   1c8a8:	e5933010 	ldr	r3, [r3, #16]
   1c8ac:	e1a03103 	lsl	r3, r3, #2
   1c8b0:	e51b2008 	ldr	r2, [fp, #-8]
   1c8b4:	e0823003 	add	r3, r2, r3
   1c8b8:	e50b3010 	str	r3, [fp, #-16]
	while(x < xe)
   1c8bc:	ea000007 	b	1c8e0 <__copybits+0x80>
		*c++ = *x++;
   1c8c0:	e51b3018 	ldr	r3, [fp, #-24]
   1c8c4:	e2832004 	add	r2, r3, #4
   1c8c8:	e50b2018 	str	r2, [fp, #-24]
   1c8cc:	e51b2008 	ldr	r2, [fp, #-8]
   1c8d0:	e2821004 	add	r1, r2, #4
   1c8d4:	e50b1008 	str	r1, [fp, #-8]
   1c8d8:	e5922000 	ldr	r2, [r2]
   1c8dc:	e5832000 	str	r2, [r3]

	ce = c + ((n-1) >> kshift) + 1;
	x = b->_x;
#ifdef Pack_32
	xe = x + b->_wds;
	while(x < xe)
   1c8e0:	e51b2008 	ldr	r2, [fp, #-8]
   1c8e4:	e51b3010 	ldr	r3, [fp, #-16]
   1c8e8:	e1520003 	cmp	r2, r3
   1c8ec:	3afffff3 	bcc	1c8c0 <__copybits+0x60>
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
   1c8f0:	ea000004 	b	1c908 <__copybits+0xa8>
		*c++ = 0;
   1c8f4:	e51b3018 	ldr	r3, [fp, #-24]
   1c8f8:	e2832004 	add	r2, r3, #4
   1c8fc:	e50b2018 	str	r2, [fp, #-24]
   1c900:	e3a02000 	mov	r2, #0
   1c904:	e5832000 	str	r2, [r3]
	for(xe = x + (nw - nw1); x < xe; x += 2)
		Storeinc(c, x[1], x[0]);
	if (nw1)
		*c++ = *x;
#endif
	while(c < ce)
   1c908:	e51b2018 	ldr	r2, [fp, #-24]
   1c90c:	e51b300c 	ldr	r3, [fp, #-12]
   1c910:	e1520003 	cmp	r2, r3
   1c914:	3afffff6 	bcc	1c8f4 <__copybits+0x94>
		*c++ = 0;
}
   1c918:	e24bd000 	sub	sp, fp, #0
   1c91c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1c920:	e12fff1e 	bx	lr

0001c924 <__any_on>:

__ULong
_DEFUN (any_on, (b, k),
	_Bigint *b _AND
	int k)
{
   1c924:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   1c928:	e28db000 	add	fp, sp, #0
   1c92c:	e24dd024 	sub	sp, sp, #36	; 0x24
   1c930:	e50b0020 	str	r0, [fp, #-32]
   1c934:	e50b1024 	str	r1, [fp, #-36]	; 0x24
	int n, nwds;
	__ULong *x, *x0, x1, x2;

	x = b->_x;
   1c938:	e51b3020 	ldr	r3, [fp, #-32]
   1c93c:	e2833014 	add	r3, r3, #20
   1c940:	e50b300c 	str	r3, [fp, #-12]
	nwds = b->_wds;
   1c944:	e51b3020 	ldr	r3, [fp, #-32]
   1c948:	e5933010 	ldr	r3, [r3, #16]
   1c94c:	e50b3010 	str	r3, [fp, #-16]
	n = k >> kshift;
   1c950:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1c954:	e1a032c3 	asr	r3, r3, #5
   1c958:	e50b3008 	str	r3, [fp, #-8]
	if (n > nwds)
   1c95c:	e51b2008 	ldr	r2, [fp, #-8]
   1c960:	e51b3010 	ldr	r3, [fp, #-16]
   1c964:	e1520003 	cmp	r2, r3
   1c968:	da000002 	ble	1c978 <__any_on+0x54>
		n = nwds;
   1c96c:	e51b3010 	ldr	r3, [fp, #-16]
   1c970:	e50b3008 	str	r3, [fp, #-8]
   1c974:	ea00001f 	b	1c9f8 <__any_on+0xd4>
	else if (n < nwds && (k &= kmask)) {
   1c978:	e51b2008 	ldr	r2, [fp, #-8]
   1c97c:	e51b3010 	ldr	r3, [fp, #-16]
   1c980:	e1520003 	cmp	r2, r3
   1c984:	aa00001b 	bge	1c9f8 <__any_on+0xd4>
   1c988:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1c98c:	e203301f 	and	r3, r3, #31
   1c990:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   1c994:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1c998:	e3530000 	cmp	r3, #0
   1c99c:	0a000015 	beq	1c9f8 <__any_on+0xd4>
		x1 = x2 = x[n];
   1c9a0:	e51b3008 	ldr	r3, [fp, #-8]
   1c9a4:	e1a03103 	lsl	r3, r3, #2
   1c9a8:	e51b200c 	ldr	r2, [fp, #-12]
   1c9ac:	e0823003 	add	r3, r2, r3
   1c9b0:	e5933000 	ldr	r3, [r3]
   1c9b4:	e50b3014 	str	r3, [fp, #-20]
   1c9b8:	e51b3014 	ldr	r3, [fp, #-20]
   1c9bc:	e50b3018 	str	r3, [fp, #-24]
		x1 >>= k;
   1c9c0:	e51b2018 	ldr	r2, [fp, #-24]
   1c9c4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1c9c8:	e1a03332 	lsr	r3, r2, r3
   1c9cc:	e50b3018 	str	r3, [fp, #-24]
		x1 <<= k;
   1c9d0:	e51b2018 	ldr	r2, [fp, #-24]
   1c9d4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1c9d8:	e1a03312 	lsl	r3, r2, r3
   1c9dc:	e50b3018 	str	r3, [fp, #-24]
		if (x1 != x2)
   1c9e0:	e51b2018 	ldr	r2, [fp, #-24]
   1c9e4:	e51b3014 	ldr	r3, [fp, #-20]
   1c9e8:	e1520003 	cmp	r2, r3
   1c9ec:	0a000001 	beq	1c9f8 <__any_on+0xd4>
			return 1;
   1c9f0:	e3a03001 	mov	r3, #1
   1c9f4:	ea000015 	b	1ca50 <__any_on+0x12c>
		}
	x0 = x;
   1c9f8:	e51b300c 	ldr	r3, [fp, #-12]
   1c9fc:	e50b301c 	str	r3, [fp, #-28]
	x += n;
   1ca00:	e51b3008 	ldr	r3, [fp, #-8]
   1ca04:	e1a03103 	lsl	r3, r3, #2
   1ca08:	e51b200c 	ldr	r2, [fp, #-12]
   1ca0c:	e0823003 	add	r3, r2, r3
   1ca10:	e50b300c 	str	r3, [fp, #-12]
	while(x > x0)
   1ca14:	ea000008 	b	1ca3c <__any_on+0x118>
		if (*--x)
   1ca18:	e51b300c 	ldr	r3, [fp, #-12]
   1ca1c:	e2433004 	sub	r3, r3, #4
   1ca20:	e50b300c 	str	r3, [fp, #-12]
   1ca24:	e51b300c 	ldr	r3, [fp, #-12]
   1ca28:	e5933000 	ldr	r3, [r3]
   1ca2c:	e3530000 	cmp	r3, #0
   1ca30:	0a000001 	beq	1ca3c <__any_on+0x118>
			return 1;
   1ca34:	e3a03001 	mov	r3, #1
   1ca38:	ea000004 	b	1ca50 <__any_on+0x12c>
		if (x1 != x2)
			return 1;
		}
	x0 = x;
	x += n;
	while(x > x0)
   1ca3c:	e51b200c 	ldr	r2, [fp, #-12]
   1ca40:	e51b301c 	ldr	r3, [fp, #-28]
   1ca44:	e1520003 	cmp	r2, r3
   1ca48:	8afffff2 	bhi	1ca18 <__any_on+0xf4>
		if (*--x)
			return 1;
	return 0;
   1ca4c:	e3a03000 	mov	r3, #0
}
   1ca50:	e1a00003 	mov	r0, r3
   1ca54:	e24bd000 	sub	sp, fp, #0
   1ca58:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1ca5c:	e12fff1e 	bx	lr

0001ca60 <_realloc_r>:
#if __STD_C
Void_t* rEALLOc(RARG Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(RARG oldmem, bytes) RDECL Void_t* oldmem; size_t bytes;
#endif
{
   1ca60:	e92d4800 	push	{fp, lr}
   1ca64:	e28db004 	add	fp, sp, #4
   1ca68:	e24dd078 	sub	sp, sp, #120	; 0x78
   1ca6c:	e50b0070 	str	r0, [fp, #-112]	; 0x70
   1ca70:	e50b1074 	str	r1, [fp, #-116]	; 0x74
   1ca74:	e50b2078 	str	r2, [fp, #-120]	; 0x78
  if (bytes == 0) { fREe(RCALL oldmem); return 0; }
#endif


  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(RCALL bytes);
   1ca78:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1ca7c:	e3530000 	cmp	r3, #0
   1ca80:	1a000004 	bne	1ca98 <_realloc_r+0x38>
   1ca84:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   1ca88:	e51b1078 	ldr	r1, [fp, #-120]	; 0x78
   1ca8c:	ebffc968 	bl	f034 <_malloc_r>
   1ca90:	e1a03000 	mov	r3, r0
   1ca94:	ea0002ed 	b	1d650 <_realloc_r+0xbf0>

  MALLOC_LOCK;
   1ca98:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   1ca9c:	ebffcd0b 	bl	fed0 <__malloc_lock>

  newp    = oldp    = mem2chunk(oldmem);
   1caa0:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1caa4:	e2433008 	sub	r3, r3, #8
   1caa8:	e50b3038 	str	r3, [fp, #-56]	; 0x38
   1caac:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1cab0:	e50b3008 	str	r3, [fp, #-8]
  newsize = oldsize = chunksize(oldp);
   1cab4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1cab8:	e5933004 	ldr	r3, [r3, #4]
   1cabc:	e3c33003 	bic	r3, r3, #3
   1cac0:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   1cac4:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1cac8:	e50b300c 	str	r3, [fp, #-12]


  nb = request2size(bytes);
   1cacc:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1cad0:	e283300b 	add	r3, r3, #11
   1cad4:	e3530016 	cmp	r3, #22
   1cad8:	9a000003 	bls	1caec <_realloc_r+0x8c>
   1cadc:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1cae0:	e283300b 	add	r3, r3, #11
   1cae4:	e3c33007 	bic	r3, r3, #7
   1cae8:	ea000000 	b	1caf0 <_realloc_r+0x90>
   1caec:	e3a03010 	mov	r3, #16
   1caf0:	e50b3040 	str	r3, [fp, #-64]	; 0x40

  /* Check for overflow and just fail, if so. */
  if (nb > INT_MAX || nb < bytes)
   1caf4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1caf8:	e3530000 	cmp	r3, #0
   1cafc:	ba000003 	blt	1cb10 <_realloc_r+0xb0>
   1cb00:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   1cb04:	e51b3078 	ldr	r3, [fp, #-120]	; 0x78
   1cb08:	e1520003 	cmp	r2, r3
   1cb0c:	2a000004 	bcs	1cb24 <_realloc_r+0xc4>
  {
    RERRNO = ENOMEM;
   1cb10:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1cb14:	e3a0200c 	mov	r2, #12
   1cb18:	e5832000 	str	r2, [r3]
    return 0;
   1cb1c:	e3a03000 	mov	r3, #0
   1cb20:	ea0002ca 	b	1d650 <_realloc_r+0xbf0>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))  
   1cb24:	e51b203c 	ldr	r2, [fp, #-60]	; 0x3c
   1cb28:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1cb2c:	e1520003 	cmp	r2, r3
   1cb30:	aa00028d 	bge	1d56c <_realloc_r+0xb0c>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
   1cb34:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   1cb38:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1cb3c:	e0823003 	add	r3, r2, r3
   1cb40:	e50b3010 	str	r3, [fp, #-16]
    if (next == top || !inuse(next)) 
   1cb44:	e59f3b14 	ldr	r3, [pc, #2836]	; 1d660 <_realloc_r+0xc00>
   1cb48:	e5932008 	ldr	r2, [r3, #8]
   1cb4c:	e51b3010 	ldr	r3, [fp, #-16]
   1cb50:	e1520003 	cmp	r2, r3
   1cb54:	0a000008 	beq	1cb7c <_realloc_r+0x11c>
   1cb58:	e51b3010 	ldr	r3, [fp, #-16]
   1cb5c:	e5933004 	ldr	r3, [r3, #4]
   1cb60:	e3c33001 	bic	r3, r3, #1
   1cb64:	e51b2010 	ldr	r2, [fp, #-16]
   1cb68:	e0823003 	add	r3, r2, r3
   1cb6c:	e5933004 	ldr	r3, [r3, #4]
   1cb70:	e2033001 	and	r3, r3, #1
   1cb74:	e3530000 	cmp	r3, #0
   1cb78:	1a000045 	bne	1cc94 <_realloc_r+0x234>
    {
      nextsize = chunksize(next);
   1cb7c:	e51b3010 	ldr	r3, [fp, #-16]
   1cb80:	e5933004 	ldr	r3, [r3, #4]
   1cb84:	e3c33003 	bic	r3, r3, #3
   1cb88:	e50b3014 	str	r3, [fp, #-20]

      /* Forward into top only if a remainder */
      if (next == top)
   1cb8c:	e59f3acc 	ldr	r3, [pc, #2764]	; 1d660 <_realloc_r+0xc00>
   1cb90:	e5932008 	ldr	r2, [r3, #8]
   1cb94:	e51b3010 	ldr	r3, [fp, #-16]
   1cb98:	e1520003 	cmp	r2, r3
   1cb9c:	1a000023 	bne	1cc30 <_realloc_r+0x1d0>
      {
        if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
   1cba0:	e51b2014 	ldr	r2, [fp, #-20]
   1cba4:	e51b300c 	ldr	r3, [fp, #-12]
   1cba8:	e0823003 	add	r3, r2, r3
   1cbac:	e1a02003 	mov	r2, r3
   1cbb0:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1cbb4:	e2833010 	add	r3, r3, #16
   1cbb8:	e1520003 	cmp	r2, r3
   1cbbc:	ba000033 	blt	1cc90 <_realloc_r+0x230>
        {
          newsize += nextsize;
   1cbc0:	e51b200c 	ldr	r2, [fp, #-12]
   1cbc4:	e51b3014 	ldr	r3, [fp, #-20]
   1cbc8:	e0823003 	add	r3, r2, r3
   1cbcc:	e50b300c 	str	r3, [fp, #-12]
          top = chunk_at_offset(oldp, nb);
   1cbd0:	e59f3a88 	ldr	r3, [pc, #2696]	; 1d660 <_realloc_r+0xc00>
   1cbd4:	e51b1038 	ldr	r1, [fp, #-56]	; 0x38
   1cbd8:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   1cbdc:	e0812002 	add	r2, r1, r2
   1cbe0:	e5832008 	str	r2, [r3, #8]
          set_head(top, (newsize - nb) | PREV_INUSE);
   1cbe4:	e59f3a74 	ldr	r3, [pc, #2676]	; 1d660 <_realloc_r+0xc00>
   1cbe8:	e5933008 	ldr	r3, [r3, #8]
   1cbec:	e51b100c 	ldr	r1, [fp, #-12]
   1cbf0:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   1cbf4:	e0622001 	rsb	r2, r2, r1
   1cbf8:	e3822001 	orr	r2, r2, #1
   1cbfc:	e5832004 	str	r2, [r3, #4]
          set_head_size(oldp, nb);
   1cc00:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1cc04:	e5933004 	ldr	r3, [r3, #4]
   1cc08:	e2032001 	and	r2, r3, #1
   1cc0c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1cc10:	e1822003 	orr	r2, r2, r3
   1cc14:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1cc18:	e5832004 	str	r2, [r3, #4]
	  MALLOC_UNLOCK;
   1cc1c:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   1cc20:	ebffccb4 	bl	fef8 <__malloc_unlock>
          return chunk2mem(oldp);
   1cc24:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1cc28:	e2833008 	add	r3, r3, #8
   1cc2c:	ea000287 	b	1d650 <_realloc_r+0xbf0>
        }
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
   1cc30:	e51b2014 	ldr	r2, [fp, #-20]
   1cc34:	e51b300c 	ldr	r3, [fp, #-12]
   1cc38:	e0823003 	add	r3, r2, r3
   1cc3c:	e1a02003 	mov	r2, r3
   1cc40:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1cc44:	e1520003 	cmp	r2, r3
   1cc48:	ba000010 	blt	1cc90 <_realloc_r+0x230>
      { 
        unlink(next, bck, fwd);
   1cc4c:	e51b3010 	ldr	r3, [fp, #-16]
   1cc50:	e593300c 	ldr	r3, [r3, #12]
   1cc54:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   1cc58:	e51b3010 	ldr	r3, [fp, #-16]
   1cc5c:	e5933008 	ldr	r3, [r3, #8]
   1cc60:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   1cc64:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   1cc68:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   1cc6c:	e583200c 	str	r2, [r3, #12]
   1cc70:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1cc74:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   1cc78:	e5832008 	str	r2, [r3, #8]
        newsize  += nextsize;
   1cc7c:	e51b200c 	ldr	r2, [fp, #-12]
   1cc80:	e51b3014 	ldr	r3, [fp, #-20]
   1cc84:	e0823003 	add	r3, r2, r3
   1cc88:	e50b300c 	str	r3, [fp, #-12]
        goto split;
   1cc8c:	ea000236 	b	1d56c <_realloc_r+0xb0c>
    if (next == top || !inuse(next)) 
    {
      nextsize = chunksize(next);

      /* Forward into top only if a remainder */
      if (next == top)
   1cc90:	ea000003 	b	1cca4 <_realloc_r+0x244>
        goto split;
      }
    }
    else
    {
      next = 0;
   1cc94:	e3a03000 	mov	r3, #0
   1cc98:	e50b3010 	str	r3, [fp, #-16]
      nextsize = 0;
   1cc9c:	e3a03000 	mov	r3, #0
   1cca0:	e50b3014 	str	r3, [fp, #-20]
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
   1cca4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1cca8:	e5933004 	ldr	r3, [r3, #4]
   1ccac:	e2033001 	and	r3, r3, #1
   1ccb0:	e3530000 	cmp	r3, #0
   1ccb4:	1a0001aa 	bne	1d364 <_realloc_r+0x904>
    {
      prev = prev_chunk(oldp);
   1ccb8:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1ccbc:	e5933000 	ldr	r3, [r3]
   1ccc0:	e2633000 	rsb	r3, r3, #0
   1ccc4:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   1ccc8:	e0823003 	add	r3, r2, r3
   1cccc:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
      prevsize = chunksize(prev);
   1ccd0:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1ccd4:	e5933004 	ldr	r3, [r3, #4]
   1ccd8:	e3c33003 	bic	r3, r3, #3
   1ccdc:	e50b3050 	str	r3, [fp, #-80]	; 0x50

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
   1cce0:	e51b3010 	ldr	r3, [fp, #-16]
   1cce4:	e3530000 	cmp	r3, #0
   1cce8:	0a000121 	beq	1d174 <_realloc_r+0x714>
      {
        /* into top */
        if (next == top)
   1ccec:	e59f396c 	ldr	r3, [pc, #2412]	; 1d660 <_realloc_r+0xc00>
   1ccf0:	e5932008 	ldr	r2, [r3, #8]
   1ccf4:	e51b3010 	ldr	r3, [fp, #-16]
   1ccf8:	e1520003 	cmp	r2, r3
   1ccfc:	1a000093 	bne	1cf50 <_realloc_r+0x4f0>
        {
          if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
   1cd00:	e51b2014 	ldr	r2, [fp, #-20]
   1cd04:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   1cd08:	e0822003 	add	r2, r2, r3
   1cd0c:	e51b300c 	ldr	r3, [fp, #-12]
   1cd10:	e0823003 	add	r3, r2, r3
   1cd14:	e1a02003 	mov	r2, r3
   1cd18:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1cd1c:	e2833010 	add	r3, r3, #16
   1cd20:	e1520003 	cmp	r2, r3
   1cd24:	ba000112 	blt	1d174 <_realloc_r+0x714>
          {
            unlink(prev, bck, fwd);
   1cd28:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1cd2c:	e593300c 	ldr	r3, [r3, #12]
   1cd30:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   1cd34:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1cd38:	e5933008 	ldr	r3, [r3, #8]
   1cd3c:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   1cd40:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   1cd44:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   1cd48:	e583200c 	str	r2, [r3, #12]
   1cd4c:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1cd50:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   1cd54:	e5832008 	str	r2, [r3, #8]
            newp = prev;
   1cd58:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1cd5c:	e50b3008 	str	r3, [fp, #-8]
            newsize += prevsize + nextsize;
   1cd60:	e51b2050 	ldr	r2, [fp, #-80]	; 0x50
   1cd64:	e51b3014 	ldr	r3, [fp, #-20]
   1cd68:	e0823003 	add	r3, r2, r3
   1cd6c:	e51b200c 	ldr	r2, [fp, #-12]
   1cd70:	e0823003 	add	r3, r2, r3
   1cd74:	e50b300c 	str	r3, [fp, #-12]
            newmem = chunk2mem(newp);
   1cd78:	e51b3008 	ldr	r3, [fp, #-8]
   1cd7c:	e2833008 	add	r3, r3, #8
   1cd80:	e50b3054 	str	r3, [fp, #-84]	; 0x54
            MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1cd84:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1cd88:	e2433004 	sub	r3, r3, #4
   1cd8c:	e50b3058 	str	r3, [fp, #-88]	; 0x58
   1cd90:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   1cd94:	e3530024 	cmp	r3, #36	; 0x24
   1cd98:	8a000051 	bhi	1cee4 <_realloc_r+0x484>
   1cd9c:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1cda0:	e50b3018 	str	r3, [fp, #-24]
   1cda4:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   1cda8:	e50b301c 	str	r3, [fp, #-28]
   1cdac:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   1cdb0:	e3530013 	cmp	r3, #19
   1cdb4:	9a000035 	bls	1ce90 <_realloc_r+0x430>
   1cdb8:	e51b301c 	ldr	r3, [fp, #-28]
   1cdbc:	e2832004 	add	r2, r3, #4
   1cdc0:	e50b201c 	str	r2, [fp, #-28]
   1cdc4:	e51b2018 	ldr	r2, [fp, #-24]
   1cdc8:	e2821004 	add	r1, r2, #4
   1cdcc:	e50b1018 	str	r1, [fp, #-24]
   1cdd0:	e5922000 	ldr	r2, [r2]
   1cdd4:	e5832000 	str	r2, [r3]
   1cdd8:	e51b301c 	ldr	r3, [fp, #-28]
   1cddc:	e2832004 	add	r2, r3, #4
   1cde0:	e50b201c 	str	r2, [fp, #-28]
   1cde4:	e51b2018 	ldr	r2, [fp, #-24]
   1cde8:	e2821004 	add	r1, r2, #4
   1cdec:	e50b1018 	str	r1, [fp, #-24]
   1cdf0:	e5922000 	ldr	r2, [r2]
   1cdf4:	e5832000 	str	r2, [r3]
   1cdf8:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   1cdfc:	e353001b 	cmp	r3, #27
   1ce00:	9a000022 	bls	1ce90 <_realloc_r+0x430>
   1ce04:	e51b301c 	ldr	r3, [fp, #-28]
   1ce08:	e2832004 	add	r2, r3, #4
   1ce0c:	e50b201c 	str	r2, [fp, #-28]
   1ce10:	e51b2018 	ldr	r2, [fp, #-24]
   1ce14:	e2821004 	add	r1, r2, #4
   1ce18:	e50b1018 	str	r1, [fp, #-24]
   1ce1c:	e5922000 	ldr	r2, [r2]
   1ce20:	e5832000 	str	r2, [r3]
   1ce24:	e51b301c 	ldr	r3, [fp, #-28]
   1ce28:	e2832004 	add	r2, r3, #4
   1ce2c:	e50b201c 	str	r2, [fp, #-28]
   1ce30:	e51b2018 	ldr	r2, [fp, #-24]
   1ce34:	e2821004 	add	r1, r2, #4
   1ce38:	e50b1018 	str	r1, [fp, #-24]
   1ce3c:	e5922000 	ldr	r2, [r2]
   1ce40:	e5832000 	str	r2, [r3]
   1ce44:	e51b3058 	ldr	r3, [fp, #-88]	; 0x58
   1ce48:	e3530023 	cmp	r3, #35	; 0x23
   1ce4c:	9a00000f 	bls	1ce90 <_realloc_r+0x430>
   1ce50:	e51b301c 	ldr	r3, [fp, #-28]
   1ce54:	e2832004 	add	r2, r3, #4
   1ce58:	e50b201c 	str	r2, [fp, #-28]
   1ce5c:	e51b2018 	ldr	r2, [fp, #-24]
   1ce60:	e2821004 	add	r1, r2, #4
   1ce64:	e50b1018 	str	r1, [fp, #-24]
   1ce68:	e5922000 	ldr	r2, [r2]
   1ce6c:	e5832000 	str	r2, [r3]
   1ce70:	e51b301c 	ldr	r3, [fp, #-28]
   1ce74:	e2832004 	add	r2, r3, #4
   1ce78:	e50b201c 	str	r2, [fp, #-28]
   1ce7c:	e51b2018 	ldr	r2, [fp, #-24]
   1ce80:	e2821004 	add	r1, r2, #4
   1ce84:	e50b1018 	str	r1, [fp, #-24]
   1ce88:	e5922000 	ldr	r2, [r2]
   1ce8c:	e5832000 	str	r2, [r3]
   1ce90:	e51b301c 	ldr	r3, [fp, #-28]
   1ce94:	e2832004 	add	r2, r3, #4
   1ce98:	e50b201c 	str	r2, [fp, #-28]
   1ce9c:	e51b2018 	ldr	r2, [fp, #-24]
   1cea0:	e2821004 	add	r1, r2, #4
   1cea4:	e50b1018 	str	r1, [fp, #-24]
   1cea8:	e5922000 	ldr	r2, [r2]
   1ceac:	e5832000 	str	r2, [r3]
   1ceb0:	e51b301c 	ldr	r3, [fp, #-28]
   1ceb4:	e2832004 	add	r2, r3, #4
   1ceb8:	e50b201c 	str	r2, [fp, #-28]
   1cebc:	e51b2018 	ldr	r2, [fp, #-24]
   1cec0:	e2821004 	add	r1, r2, #4
   1cec4:	e50b1018 	str	r1, [fp, #-24]
   1cec8:	e5922000 	ldr	r2, [r2]
   1cecc:	e5832000 	str	r2, [r3]
   1ced0:	e51b3018 	ldr	r3, [fp, #-24]
   1ced4:	e5932000 	ldr	r2, [r3]
   1ced8:	e51b301c 	ldr	r3, [fp, #-28]
   1cedc:	e5832000 	str	r2, [r3]
   1cee0:	ea000003 	b	1cef4 <_realloc_r+0x494>
   1cee4:	e51b0054 	ldr	r0, [fp, #-84]	; 0x54
   1cee8:	e51b1074 	ldr	r1, [fp, #-116]	; 0x74
   1ceec:	e51b2058 	ldr	r2, [fp, #-88]	; 0x58
   1cef0:	ebfff7a9 	bl	1ad9c <memmove>
            top = chunk_at_offset(newp, nb);
   1cef4:	e59f3764 	ldr	r3, [pc, #1892]	; 1d660 <_realloc_r+0xc00>
   1cef8:	e51b1008 	ldr	r1, [fp, #-8]
   1cefc:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   1cf00:	e0812002 	add	r2, r1, r2
   1cf04:	e5832008 	str	r2, [r3, #8]
            set_head(top, (newsize - nb) | PREV_INUSE);
   1cf08:	e59f3750 	ldr	r3, [pc, #1872]	; 1d660 <_realloc_r+0xc00>
   1cf0c:	e5933008 	ldr	r3, [r3, #8]
   1cf10:	e51b100c 	ldr	r1, [fp, #-12]
   1cf14:	e51b2040 	ldr	r2, [fp, #-64]	; 0x40
   1cf18:	e0622001 	rsb	r2, r2, r1
   1cf1c:	e3822001 	orr	r2, r2, #1
   1cf20:	e5832004 	str	r2, [r3, #4]
            set_head_size(newp, nb);
   1cf24:	e51b3008 	ldr	r3, [fp, #-8]
   1cf28:	e5933004 	ldr	r3, [r3, #4]
   1cf2c:	e2032001 	and	r2, r3, #1
   1cf30:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1cf34:	e1822003 	orr	r2, r2, r3
   1cf38:	e51b3008 	ldr	r3, [fp, #-8]
   1cf3c:	e5832004 	str	r2, [r3, #4]
	    MALLOC_UNLOCK;
   1cf40:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   1cf44:	ebffcbeb 	bl	fef8 <__malloc_unlock>
            return newmem;
   1cf48:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   1cf4c:	ea0001bf 	b	1d650 <_realloc_r+0xbf0>
          }
        }

        /* into next chunk */
        else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
   1cf50:	e51b2014 	ldr	r2, [fp, #-20]
   1cf54:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   1cf58:	e0822003 	add	r2, r2, r3
   1cf5c:	e51b300c 	ldr	r3, [fp, #-12]
   1cf60:	e0823003 	add	r3, r2, r3
   1cf64:	e1a02003 	mov	r2, r3
   1cf68:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1cf6c:	e1520003 	cmp	r2, r3
   1cf70:	ba00007f 	blt	1d174 <_realloc_r+0x714>
        {
          unlink(next, bck, fwd);
   1cf74:	e51b3010 	ldr	r3, [fp, #-16]
   1cf78:	e593300c 	ldr	r3, [r3, #12]
   1cf7c:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   1cf80:	e51b3010 	ldr	r3, [fp, #-16]
   1cf84:	e5933008 	ldr	r3, [r3, #8]
   1cf88:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   1cf8c:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   1cf90:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   1cf94:	e583200c 	str	r2, [r3, #12]
   1cf98:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1cf9c:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   1cfa0:	e5832008 	str	r2, [r3, #8]
          unlink(prev, bck, fwd);
   1cfa4:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1cfa8:	e593300c 	ldr	r3, [r3, #12]
   1cfac:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   1cfb0:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1cfb4:	e5933008 	ldr	r3, [r3, #8]
   1cfb8:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   1cfbc:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   1cfc0:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   1cfc4:	e583200c 	str	r2, [r3, #12]
   1cfc8:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1cfcc:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   1cfd0:	e5832008 	str	r2, [r3, #8]
          newp = prev;
   1cfd4:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1cfd8:	e50b3008 	str	r3, [fp, #-8]
          newsize += nextsize + prevsize;
   1cfdc:	e51b2014 	ldr	r2, [fp, #-20]
   1cfe0:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   1cfe4:	e0823003 	add	r3, r2, r3
   1cfe8:	e51b200c 	ldr	r2, [fp, #-12]
   1cfec:	e0823003 	add	r3, r2, r3
   1cff0:	e50b300c 	str	r3, [fp, #-12]
          newmem = chunk2mem(newp);
   1cff4:	e51b3008 	ldr	r3, [fp, #-8]
   1cff8:	e2833008 	add	r3, r3, #8
   1cffc:	e50b3054 	str	r3, [fp, #-84]	; 0x54
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1d000:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1d004:	e2433004 	sub	r3, r3, #4
   1d008:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
   1d00c:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1d010:	e3530024 	cmp	r3, #36	; 0x24
   1d014:	8a000051 	bhi	1d160 <_realloc_r+0x700>
   1d018:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1d01c:	e50b3020 	str	r3, [fp, #-32]
   1d020:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   1d024:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   1d028:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1d02c:	e3530013 	cmp	r3, #19
   1d030:	9a000035 	bls	1d10c <_realloc_r+0x6ac>
   1d034:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1d038:	e2832004 	add	r2, r3, #4
   1d03c:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   1d040:	e51b2020 	ldr	r2, [fp, #-32]
   1d044:	e2821004 	add	r1, r2, #4
   1d048:	e50b1020 	str	r1, [fp, #-32]
   1d04c:	e5922000 	ldr	r2, [r2]
   1d050:	e5832000 	str	r2, [r3]
   1d054:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1d058:	e2832004 	add	r2, r3, #4
   1d05c:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   1d060:	e51b2020 	ldr	r2, [fp, #-32]
   1d064:	e2821004 	add	r1, r2, #4
   1d068:	e50b1020 	str	r1, [fp, #-32]
   1d06c:	e5922000 	ldr	r2, [r2]
   1d070:	e5832000 	str	r2, [r3]
   1d074:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1d078:	e353001b 	cmp	r3, #27
   1d07c:	9a000022 	bls	1d10c <_realloc_r+0x6ac>
   1d080:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1d084:	e2832004 	add	r2, r3, #4
   1d088:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   1d08c:	e51b2020 	ldr	r2, [fp, #-32]
   1d090:	e2821004 	add	r1, r2, #4
   1d094:	e50b1020 	str	r1, [fp, #-32]
   1d098:	e5922000 	ldr	r2, [r2]
   1d09c:	e5832000 	str	r2, [r3]
   1d0a0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1d0a4:	e2832004 	add	r2, r3, #4
   1d0a8:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   1d0ac:	e51b2020 	ldr	r2, [fp, #-32]
   1d0b0:	e2821004 	add	r1, r2, #4
   1d0b4:	e50b1020 	str	r1, [fp, #-32]
   1d0b8:	e5922000 	ldr	r2, [r2]
   1d0bc:	e5832000 	str	r2, [r3]
   1d0c0:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1d0c4:	e3530023 	cmp	r3, #35	; 0x23
   1d0c8:	9a00000f 	bls	1d10c <_realloc_r+0x6ac>
   1d0cc:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1d0d0:	e2832004 	add	r2, r3, #4
   1d0d4:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   1d0d8:	e51b2020 	ldr	r2, [fp, #-32]
   1d0dc:	e2821004 	add	r1, r2, #4
   1d0e0:	e50b1020 	str	r1, [fp, #-32]
   1d0e4:	e5922000 	ldr	r2, [r2]
   1d0e8:	e5832000 	str	r2, [r3]
   1d0ec:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1d0f0:	e2832004 	add	r2, r3, #4
   1d0f4:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   1d0f8:	e51b2020 	ldr	r2, [fp, #-32]
   1d0fc:	e2821004 	add	r1, r2, #4
   1d100:	e50b1020 	str	r1, [fp, #-32]
   1d104:	e5922000 	ldr	r2, [r2]
   1d108:	e5832000 	str	r2, [r3]
   1d10c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1d110:	e2832004 	add	r2, r3, #4
   1d114:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   1d118:	e51b2020 	ldr	r2, [fp, #-32]
   1d11c:	e2821004 	add	r1, r2, #4
   1d120:	e50b1020 	str	r1, [fp, #-32]
   1d124:	e5922000 	ldr	r2, [r2]
   1d128:	e5832000 	str	r2, [r3]
   1d12c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1d130:	e2832004 	add	r2, r3, #4
   1d134:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   1d138:	e51b2020 	ldr	r2, [fp, #-32]
   1d13c:	e2821004 	add	r1, r2, #4
   1d140:	e50b1020 	str	r1, [fp, #-32]
   1d144:	e5922000 	ldr	r2, [r2]
   1d148:	e5832000 	str	r2, [r3]
   1d14c:	e51b3020 	ldr	r3, [fp, #-32]
   1d150:	e5932000 	ldr	r2, [r3]
   1d154:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1d158:	e5832000 	str	r2, [r3]
          goto split;
   1d15c:	ea000102 	b	1d56c <_realloc_r+0xb0c>
          unlink(next, bck, fwd);
          unlink(prev, bck, fwd);
          newp = prev;
          newsize += nextsize + prevsize;
          newmem = chunk2mem(newp);
          MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1d160:	e51b0054 	ldr	r0, [fp, #-84]	; 0x54
   1d164:	e51b1074 	ldr	r1, [fp, #-116]	; 0x74
   1d168:	e51b205c 	ldr	r2, [fp, #-92]	; 0x5c
   1d16c:	ebfff70a 	bl	1ad9c <memmove>
          goto split;
   1d170:	ea0000fd 	b	1d56c <_realloc_r+0xb0c>
        }
      }
      
      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)  
   1d174:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1d178:	e3530000 	cmp	r3, #0
   1d17c:	0a000078 	beq	1d364 <_realloc_r+0x904>
   1d180:	e51b2050 	ldr	r2, [fp, #-80]	; 0x50
   1d184:	e51b300c 	ldr	r3, [fp, #-12]
   1d188:	e0823003 	add	r3, r2, r3
   1d18c:	e1a02003 	mov	r2, r3
   1d190:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1d194:	e1520003 	cmp	r2, r3
   1d198:	ba000071 	blt	1d364 <_realloc_r+0x904>
      {
        unlink(prev, bck, fwd);
   1d19c:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1d1a0:	e593300c 	ldr	r3, [r3, #12]
   1d1a4:	e50b3044 	str	r3, [fp, #-68]	; 0x44
   1d1a8:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1d1ac:	e5933008 	ldr	r3, [r3, #8]
   1d1b0:	e50b3048 	str	r3, [fp, #-72]	; 0x48
   1d1b4:	e51b3048 	ldr	r3, [fp, #-72]	; 0x48
   1d1b8:	e51b2044 	ldr	r2, [fp, #-68]	; 0x44
   1d1bc:	e583200c 	str	r2, [r3, #12]
   1d1c0:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1d1c4:	e51b2048 	ldr	r2, [fp, #-72]	; 0x48
   1d1c8:	e5832008 	str	r2, [r3, #8]
        newp = prev;
   1d1cc:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1d1d0:	e50b3008 	str	r3, [fp, #-8]
        newsize += prevsize;
   1d1d4:	e51b200c 	ldr	r2, [fp, #-12]
   1d1d8:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   1d1dc:	e0823003 	add	r3, r2, r3
   1d1e0:	e50b300c 	str	r3, [fp, #-12]
        newmem = chunk2mem(newp);
   1d1e4:	e51b3008 	ldr	r3, [fp, #-8]
   1d1e8:	e2833008 	add	r3, r3, #8
   1d1ec:	e50b3054 	str	r3, [fp, #-84]	; 0x54
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1d1f0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1d1f4:	e2433004 	sub	r3, r3, #4
   1d1f8:	e50b3060 	str	r3, [fp, #-96]	; 0x60
   1d1fc:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   1d200:	e3530024 	cmp	r3, #36	; 0x24
   1d204:	8a000051 	bhi	1d350 <_realloc_r+0x8f0>
   1d208:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1d20c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
   1d210:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   1d214:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   1d218:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   1d21c:	e3530013 	cmp	r3, #19
   1d220:	9a000035 	bls	1d2fc <_realloc_r+0x89c>
   1d224:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1d228:	e2832004 	add	r2, r3, #4
   1d22c:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   1d230:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   1d234:	e2821004 	add	r1, r2, #4
   1d238:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   1d23c:	e5922000 	ldr	r2, [r2]
   1d240:	e5832000 	str	r2, [r3]
   1d244:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1d248:	e2832004 	add	r2, r3, #4
   1d24c:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   1d250:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   1d254:	e2821004 	add	r1, r2, #4
   1d258:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   1d25c:	e5922000 	ldr	r2, [r2]
   1d260:	e5832000 	str	r2, [r3]
   1d264:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   1d268:	e353001b 	cmp	r3, #27
   1d26c:	9a000022 	bls	1d2fc <_realloc_r+0x89c>
   1d270:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1d274:	e2832004 	add	r2, r3, #4
   1d278:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   1d27c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   1d280:	e2821004 	add	r1, r2, #4
   1d284:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   1d288:	e5922000 	ldr	r2, [r2]
   1d28c:	e5832000 	str	r2, [r3]
   1d290:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1d294:	e2832004 	add	r2, r3, #4
   1d298:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   1d29c:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   1d2a0:	e2821004 	add	r1, r2, #4
   1d2a4:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   1d2a8:	e5922000 	ldr	r2, [r2]
   1d2ac:	e5832000 	str	r2, [r3]
   1d2b0:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   1d2b4:	e3530023 	cmp	r3, #35	; 0x23
   1d2b8:	9a00000f 	bls	1d2fc <_realloc_r+0x89c>
   1d2bc:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1d2c0:	e2832004 	add	r2, r3, #4
   1d2c4:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   1d2c8:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   1d2cc:	e2821004 	add	r1, r2, #4
   1d2d0:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   1d2d4:	e5922000 	ldr	r2, [r2]
   1d2d8:	e5832000 	str	r2, [r3]
   1d2dc:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1d2e0:	e2832004 	add	r2, r3, #4
   1d2e4:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   1d2e8:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   1d2ec:	e2821004 	add	r1, r2, #4
   1d2f0:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   1d2f4:	e5922000 	ldr	r2, [r2]
   1d2f8:	e5832000 	str	r2, [r3]
   1d2fc:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1d300:	e2832004 	add	r2, r3, #4
   1d304:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   1d308:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   1d30c:	e2821004 	add	r1, r2, #4
   1d310:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   1d314:	e5922000 	ldr	r2, [r2]
   1d318:	e5832000 	str	r2, [r3]
   1d31c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1d320:	e2832004 	add	r2, r3, #4
   1d324:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   1d328:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   1d32c:	e2821004 	add	r1, r2, #4
   1d330:	e50b1028 	str	r1, [fp, #-40]	; 0x28
   1d334:	e5922000 	ldr	r2, [r2]
   1d338:	e5832000 	str	r2, [r3]
   1d33c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1d340:	e5932000 	ldr	r2, [r3]
   1d344:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   1d348:	e5832000 	str	r2, [r3]
        goto split;
   1d34c:	ea000086 	b	1d56c <_realloc_r+0xb0c>
      {
        unlink(prev, bck, fwd);
        newp = prev;
        newsize += prevsize;
        newmem = chunk2mem(newp);
        MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1d350:	e51b0054 	ldr	r0, [fp, #-84]	; 0x54
   1d354:	e51b1074 	ldr	r1, [fp, #-116]	; 0x74
   1d358:	e51b2060 	ldr	r2, [fp, #-96]	; 0x60
   1d35c:	ebfff68e 	bl	1ad9c <memmove>
        goto split;
   1d360:	ea000081 	b	1d56c <_realloc_r+0xb0c>
      }
    }

    /* Must allocate */

    newmem = mALLOc (RCALL bytes);
   1d364:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   1d368:	e51b1078 	ldr	r1, [fp, #-120]	; 0x78
   1d36c:	ebffc730 	bl	f034 <_malloc_r>
   1d370:	e50b0054 	str	r0, [fp, #-84]	; 0x54

    if (newmem == 0)  /* propagate failure */
   1d374:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   1d378:	e3530000 	cmp	r3, #0
   1d37c:	1a000003 	bne	1d390 <_realloc_r+0x930>
    {
      MALLOC_UNLOCK;
   1d380:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   1d384:	ebffcadb 	bl	fef8 <__malloc_unlock>
      return 0;
   1d388:	e3a03000 	mov	r3, #0
   1d38c:	ea0000af 	b	1d650 <_realloc_r+0xbf0>
    }

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp)) 
   1d390:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   1d394:	e2433008 	sub	r3, r3, #8
   1d398:	e50b3008 	str	r3, [fp, #-8]
   1d39c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1d3a0:	e5933004 	ldr	r3, [r3, #4]
   1d3a4:	e3c33001 	bic	r3, r3, #1
   1d3a8:	e51b2038 	ldr	r2, [fp, #-56]	; 0x38
   1d3ac:	e0823003 	add	r3, r2, r3
   1d3b0:	e51b2008 	ldr	r2, [fp, #-8]
   1d3b4:	e1520003 	cmp	r2, r3
   1d3b8:	1a000008 	bne	1d3e0 <_realloc_r+0x980>
    {
      newsize += chunksize(newp);
   1d3bc:	e51b3008 	ldr	r3, [fp, #-8]
   1d3c0:	e5933004 	ldr	r3, [r3, #4]
   1d3c4:	e3c33003 	bic	r3, r3, #3
   1d3c8:	e51b200c 	ldr	r2, [fp, #-12]
   1d3cc:	e0823003 	add	r3, r2, r3
   1d3d0:	e50b300c 	str	r3, [fp, #-12]
      newp = oldp;
   1d3d4:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1d3d8:	e50b3008 	str	r3, [fp, #-8]
      goto split;
   1d3dc:	ea000062 	b	1d56c <_realloc_r+0xb0c>
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
   1d3e0:	e51b303c 	ldr	r3, [fp, #-60]	; 0x3c
   1d3e4:	e2433004 	sub	r3, r3, #4
   1d3e8:	e50b3064 	str	r3, [fp, #-100]	; 0x64
   1d3ec:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   1d3f0:	e3530024 	cmp	r3, #36	; 0x24
   1d3f4:	8a000051 	bhi	1d540 <_realloc_r+0xae0>
   1d3f8:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1d3fc:	e50b3030 	str	r3, [fp, #-48]	; 0x30
   1d400:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   1d404:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   1d408:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   1d40c:	e3530013 	cmp	r3, #19
   1d410:	9a000035 	bls	1d4ec <_realloc_r+0xa8c>
   1d414:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1d418:	e2832004 	add	r2, r3, #4
   1d41c:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   1d420:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   1d424:	e2821004 	add	r1, r2, #4
   1d428:	e50b1030 	str	r1, [fp, #-48]	; 0x30
   1d42c:	e5922000 	ldr	r2, [r2]
   1d430:	e5832000 	str	r2, [r3]
   1d434:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1d438:	e2832004 	add	r2, r3, #4
   1d43c:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   1d440:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   1d444:	e2821004 	add	r1, r2, #4
   1d448:	e50b1030 	str	r1, [fp, #-48]	; 0x30
   1d44c:	e5922000 	ldr	r2, [r2]
   1d450:	e5832000 	str	r2, [r3]
   1d454:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   1d458:	e353001b 	cmp	r3, #27
   1d45c:	9a000022 	bls	1d4ec <_realloc_r+0xa8c>
   1d460:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1d464:	e2832004 	add	r2, r3, #4
   1d468:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   1d46c:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   1d470:	e2821004 	add	r1, r2, #4
   1d474:	e50b1030 	str	r1, [fp, #-48]	; 0x30
   1d478:	e5922000 	ldr	r2, [r2]
   1d47c:	e5832000 	str	r2, [r3]
   1d480:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1d484:	e2832004 	add	r2, r3, #4
   1d488:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   1d48c:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   1d490:	e2821004 	add	r1, r2, #4
   1d494:	e50b1030 	str	r1, [fp, #-48]	; 0x30
   1d498:	e5922000 	ldr	r2, [r2]
   1d49c:	e5832000 	str	r2, [r3]
   1d4a0:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   1d4a4:	e3530023 	cmp	r3, #35	; 0x23
   1d4a8:	9a00000f 	bls	1d4ec <_realloc_r+0xa8c>
   1d4ac:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1d4b0:	e2832004 	add	r2, r3, #4
   1d4b4:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   1d4b8:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   1d4bc:	e2821004 	add	r1, r2, #4
   1d4c0:	e50b1030 	str	r1, [fp, #-48]	; 0x30
   1d4c4:	e5922000 	ldr	r2, [r2]
   1d4c8:	e5832000 	str	r2, [r3]
   1d4cc:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1d4d0:	e2832004 	add	r2, r3, #4
   1d4d4:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   1d4d8:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   1d4dc:	e2821004 	add	r1, r2, #4
   1d4e0:	e50b1030 	str	r1, [fp, #-48]	; 0x30
   1d4e4:	e5922000 	ldr	r2, [r2]
   1d4e8:	e5832000 	str	r2, [r3]
   1d4ec:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1d4f0:	e2832004 	add	r2, r3, #4
   1d4f4:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   1d4f8:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   1d4fc:	e2821004 	add	r1, r2, #4
   1d500:	e50b1030 	str	r1, [fp, #-48]	; 0x30
   1d504:	e5922000 	ldr	r2, [r2]
   1d508:	e5832000 	str	r2, [r3]
   1d50c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1d510:	e2832004 	add	r2, r3, #4
   1d514:	e50b2034 	str	r2, [fp, #-52]	; 0x34
   1d518:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   1d51c:	e2821004 	add	r1, r2, #4
   1d520:	e50b1030 	str	r1, [fp, #-48]	; 0x30
   1d524:	e5922000 	ldr	r2, [r2]
   1d528:	e5832000 	str	r2, [r3]
   1d52c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1d530:	e5932000 	ldr	r2, [r3]
   1d534:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1d538:	e5832000 	str	r2, [r3]
   1d53c:	ea000003 	b	1d550 <_realloc_r+0xaf0>
   1d540:	e51b0054 	ldr	r0, [fp, #-84]	; 0x54
   1d544:	e51b1074 	ldr	r1, [fp, #-116]	; 0x74
   1d548:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
   1d54c:	ebfff612 	bl	1ad9c <memmove>
    fREe(RCALL oldmem);
   1d550:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   1d554:	e51b1074 	ldr	r1, [fp, #-116]	; 0x74
   1d558:	ebfff0cf 	bl	1989c <_free_r>
    MALLOC_UNLOCK;
   1d55c:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   1d560:	ebffca64 	bl	fef8 <__malloc_unlock>
    return newmem;
   1d564:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   1d568:	ea000038 	b	1d650 <_realloc_r+0xbf0>
  }


 split:  /* split off extra room in old or expanded chunk */

  remainder_size = long_sub_size_t(newsize, nb);
   1d56c:	e51b200c 	ldr	r2, [fp, #-12]
   1d570:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1d574:	e0633002 	rsb	r3, r3, r2
   1d578:	e50b3068 	str	r3, [fp, #-104]	; 0x68

  if (remainder_size >= (long)MINSIZE) /* split off remainder */
   1d57c:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1d580:	e353000f 	cmp	r3, #15
   1d584:	9a00001d 	bls	1d600 <_realloc_r+0xba0>
  {
    remainder = chunk_at_offset(newp, nb);
   1d588:	e51b2008 	ldr	r2, [fp, #-8]
   1d58c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1d590:	e0823003 	add	r3, r2, r3
   1d594:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
    set_head_size(newp, nb);
   1d598:	e51b3008 	ldr	r3, [fp, #-8]
   1d59c:	e5933004 	ldr	r3, [r3, #4]
   1d5a0:	e2032001 	and	r2, r3, #1
   1d5a4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1d5a8:	e1822003 	orr	r2, r2, r3
   1d5ac:	e51b3008 	ldr	r3, [fp, #-8]
   1d5b0:	e5832004 	str	r2, [r3, #4]
    set_head(remainder, remainder_size | PREV_INUSE);
   1d5b4:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1d5b8:	e3832001 	orr	r2, r3, #1
   1d5bc:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1d5c0:	e5832004 	str	r2, [r3, #4]
    set_inuse_bit_at_offset(remainder, remainder_size);
   1d5c4:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
   1d5c8:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   1d5cc:	e0823003 	add	r3, r2, r3
   1d5d0:	e51b106c 	ldr	r1, [fp, #-108]	; 0x6c
   1d5d4:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   1d5d8:	e0812002 	add	r2, r1, r2
   1d5dc:	e5922004 	ldr	r2, [r2, #4]
   1d5e0:	e3822001 	orr	r2, r2, #1
   1d5e4:	e5832004 	str	r2, [r3, #4]
    fREe(RCALL chunk2mem(remainder)); /* let free() deal with it */
   1d5e8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1d5ec:	e2833008 	add	r3, r3, #8
   1d5f0:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   1d5f4:	e1a01003 	mov	r1, r3
   1d5f8:	ebfff0a7 	bl	1989c <_free_r>
   1d5fc:	ea00000f 	b	1d640 <_realloc_r+0xbe0>
  }
  else
  {
    set_head_size(newp, newsize);
   1d600:	e51b3008 	ldr	r3, [fp, #-8]
   1d604:	e5933004 	ldr	r3, [r3, #4]
   1d608:	e2032001 	and	r2, r3, #1
   1d60c:	e51b300c 	ldr	r3, [fp, #-12]
   1d610:	e1822003 	orr	r2, r2, r3
   1d614:	e51b3008 	ldr	r3, [fp, #-8]
   1d618:	e5832004 	str	r2, [r3, #4]
    set_inuse_bit_at_offset(newp, newsize);
   1d61c:	e51b2008 	ldr	r2, [fp, #-8]
   1d620:	e51b300c 	ldr	r3, [fp, #-12]
   1d624:	e0823003 	add	r3, r2, r3
   1d628:	e51b1008 	ldr	r1, [fp, #-8]
   1d62c:	e51b200c 	ldr	r2, [fp, #-12]
   1d630:	e0812002 	add	r2, r1, r2
   1d634:	e5922004 	ldr	r2, [r2, #4]
   1d638:	e3822001 	orr	r2, r2, #1
   1d63c:	e5832004 	str	r2, [r3, #4]
  }

  check_inuse_chunk(newp);
  MALLOC_UNLOCK;
   1d640:	e51b0070 	ldr	r0, [fp, #-112]	; 0x70
   1d644:	ebffca2b 	bl	fef8 <__malloc_unlock>
  return chunk2mem(newp);
   1d648:	e51b3008 	ldr	r3, [fp, #-8]
   1d64c:	e2833008 	add	r3, r3, #8

#endif /* MALLOC_PROVIDED */
}
   1d650:	e1a00003 	mov	r0, r3
   1d654:	e24bd004 	sub	sp, fp, #4
   1d658:	e8bd4800 	pop	{fp, lr}
   1d65c:	e12fff1e 	bx	lr
   1d660:	00024bd8 	.word	0x00024bd8

0001d664 <cleanup_glue>:

void
_DEFUN (cleanup_glue, (ptr, glue),
     struct _reent *ptr _AND
     struct _glue *glue)
{
   1d664:	e92d4800 	push	{fp, lr}
   1d668:	e28db004 	add	fp, sp, #4
   1d66c:	e24dd008 	sub	sp, sp, #8
   1d670:	e50b0008 	str	r0, [fp, #-8]
   1d674:	e50b100c 	str	r1, [fp, #-12]
  /* Have to reclaim these in reverse order: */
  if (glue->_next)
   1d678:	e51b300c 	ldr	r3, [fp, #-12]
   1d67c:	e5933000 	ldr	r3, [r3]
   1d680:	e3530000 	cmp	r3, #0
   1d684:	0a000004 	beq	1d69c <cleanup_glue+0x38>
    cleanup_glue (ptr, glue->_next);
   1d688:	e51b300c 	ldr	r3, [fp, #-12]
   1d68c:	e5933000 	ldr	r3, [r3]
   1d690:	e51b0008 	ldr	r0, [fp, #-8]
   1d694:	e1a01003 	mov	r1, r3
   1d698:	ebfffff1 	bl	1d664 <cleanup_glue>

  _free_r (ptr, glue);
   1d69c:	e51b0008 	ldr	r0, [fp, #-8]
   1d6a0:	e51b100c 	ldr	r1, [fp, #-12]
   1d6a4:	ebfff07c 	bl	1989c <_free_r>
}
   1d6a8:	e24bd004 	sub	sp, fp, #4
   1d6ac:	e8bd4800 	pop	{fp, lr}
   1d6b0:	e12fff1e 	bx	lr

0001d6b4 <_reclaim_reent>:

void
_DEFUN (_reclaim_reent, (ptr),
     struct _reent *ptr)
{
   1d6b4:	e92d4800 	push	{fp, lr}
   1d6b8:	e28db004 	add	fp, sp, #4
   1d6bc:	e24dd020 	sub	sp, sp, #32
   1d6c0:	e50b0020 	str	r0, [fp, #-32]
  if (ptr != _impure_ptr)
   1d6c4:	e59f31a8 	ldr	r3, [pc, #424]	; 1d874 <_reclaim_reent+0x1c0>
   1d6c8:	e5933000 	ldr	r3, [r3]
   1d6cc:	e51b2020 	ldr	r2, [fp, #-32]
   1d6d0:	e1520003 	cmp	r2, r3
   1d6d4:	0a000063 	beq	1d868 <_reclaim_reent+0x1b4>
      /* used by mprec routines. */
#ifdef _REENT_SMALL
      if (ptr->_mp)	/* don't bother allocating it! */
      {
#endif
      if (_REENT_MP_FREELIST(ptr))
   1d6d8:	e51b3020 	ldr	r3, [fp, #-32]
   1d6dc:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
   1d6e0:	e3530000 	cmp	r3, #0
   1d6e4:	0a000020 	beq	1d76c <_reclaim_reent+0xb8>
	{
	  int i;
	  for (i = 0; i < _Kmax; i++) 
   1d6e8:	e3a03000 	mov	r3, #0
   1d6ec:	e50b3008 	str	r3, [fp, #-8]
   1d6f0:	ea000015 	b	1d74c <_reclaim_reent+0x98>
	    {
	      struct _Bigint *thisone, *nextone;
	
	      nextone = _REENT_MP_FREELIST(ptr)[i];
   1d6f4:	e51b3020 	ldr	r3, [fp, #-32]
   1d6f8:	e593204c 	ldr	r2, [r3, #76]	; 0x4c
   1d6fc:	e51b3008 	ldr	r3, [fp, #-8]
   1d700:	e1a03103 	lsl	r3, r3, #2
   1d704:	e0823003 	add	r3, r2, r3
   1d708:	e5933000 	ldr	r3, [r3]
   1d70c:	e50b300c 	str	r3, [fp, #-12]
	      while (nextone)
   1d710:	ea000007 	b	1d734 <_reclaim_reent+0x80>
		{
		  thisone = nextone;
   1d714:	e51b300c 	ldr	r3, [fp, #-12]
   1d718:	e50b3014 	str	r3, [fp, #-20]
		  nextone = nextone->_next;
   1d71c:	e51b300c 	ldr	r3, [fp, #-12]
   1d720:	e5933000 	ldr	r3, [r3]
   1d724:	e50b300c 	str	r3, [fp, #-12]
		  _free_r (ptr, thisone);
   1d728:	e51b0020 	ldr	r0, [fp, #-32]
   1d72c:	e51b1014 	ldr	r1, [fp, #-20]
   1d730:	ebfff059 	bl	1989c <_free_r>
	  for (i = 0; i < _Kmax; i++) 
	    {
	      struct _Bigint *thisone, *nextone;
	
	      nextone = _REENT_MP_FREELIST(ptr)[i];
	      while (nextone)
   1d734:	e51b300c 	ldr	r3, [fp, #-12]
   1d738:	e3530000 	cmp	r3, #0
   1d73c:	1afffff4 	bne	1d714 <_reclaim_reent+0x60>
      {
#endif
      if (_REENT_MP_FREELIST(ptr))
	{
	  int i;
	  for (i = 0; i < _Kmax; i++) 
   1d740:	e51b3008 	ldr	r3, [fp, #-8]
   1d744:	e2833001 	add	r3, r3, #1
   1d748:	e50b3008 	str	r3, [fp, #-8]
   1d74c:	e51b3008 	ldr	r3, [fp, #-8]
   1d750:	e353001f 	cmp	r3, #31
   1d754:	9affffe6 	bls	1d6f4 <_reclaim_reent+0x40>
		  nextone = nextone->_next;
		  _free_r (ptr, thisone);
		}
	    }    

	  _free_r (ptr, _REENT_MP_FREELIST(ptr));
   1d758:	e51b3020 	ldr	r3, [fp, #-32]
   1d75c:	e593304c 	ldr	r3, [r3, #76]	; 0x4c
   1d760:	e51b0020 	ldr	r0, [fp, #-32]
   1d764:	e1a01003 	mov	r1, r3
   1d768:	ebfff04b 	bl	1989c <_free_r>
	}
      if (_REENT_MP_RESULT(ptr))
   1d76c:	e51b3020 	ldr	r3, [fp, #-32]
   1d770:	e5933040 	ldr	r3, [r3, #64]	; 0x40
   1d774:	e3530000 	cmp	r3, #0
   1d778:	0a000004 	beq	1d790 <_reclaim_reent+0xdc>
	_free_r (ptr, _REENT_MP_RESULT(ptr));
   1d77c:	e51b3020 	ldr	r3, [fp, #-32]
   1d780:	e5933040 	ldr	r3, [r3, #64]	; 0x40
   1d784:	e51b0020 	ldr	r0, [fp, #-32]
   1d788:	e1a01003 	mov	r1, r3
   1d78c:	ebfff042 	bl	1989c <_free_r>
      /* atexit stuff */
# ifdef _REENT_SMALL
      if (ptr->_atexit && ptr->_atexit->_on_exit_args_ptr)
	_free_r (ptr, ptr->_atexit->_on_exit_args_ptr);
# else
      if ((ptr->_atexit) && (ptr->_atexit != &ptr->_atexit0))
   1d790:	e51b3020 	ldr	r3, [fp, #-32]
   1d794:	e5933148 	ldr	r3, [r3, #328]	; 0x148
   1d798:	e3530000 	cmp	r3, #0
   1d79c:	0a000016 	beq	1d7fc <_reclaim_reent+0x148>
   1d7a0:	e51b3020 	ldr	r3, [fp, #-32]
   1d7a4:	e5932148 	ldr	r2, [r3, #328]	; 0x148
   1d7a8:	e51b3020 	ldr	r3, [fp, #-32]
   1d7ac:	e2833f53 	add	r3, r3, #332	; 0x14c
   1d7b0:	e1520003 	cmp	r2, r3
   1d7b4:	0a000010 	beq	1d7fc <_reclaim_reent+0x148>
	{
	  struct _atexit *p, *q;
	  for (p = ptr->_atexit; p != &ptr->_atexit0;)
   1d7b8:	e51b3020 	ldr	r3, [fp, #-32]
   1d7bc:	e5933148 	ldr	r3, [r3, #328]	; 0x148
   1d7c0:	e50b3010 	str	r3, [fp, #-16]
   1d7c4:	ea000007 	b	1d7e8 <_reclaim_reent+0x134>
	    {
	      q = p;
   1d7c8:	e51b3010 	ldr	r3, [fp, #-16]
   1d7cc:	e50b3018 	str	r3, [fp, #-24]
	      p = p->_next;
   1d7d0:	e51b3010 	ldr	r3, [fp, #-16]
   1d7d4:	e5933000 	ldr	r3, [r3]
   1d7d8:	e50b3010 	str	r3, [fp, #-16]
	      _free_r (ptr, q);
   1d7dc:	e51b0020 	ldr	r0, [fp, #-32]
   1d7e0:	e51b1018 	ldr	r1, [fp, #-24]
   1d7e4:	ebfff02c 	bl	1989c <_free_r>
	_free_r (ptr, ptr->_atexit->_on_exit_args_ptr);
# else
      if ((ptr->_atexit) && (ptr->_atexit != &ptr->_atexit0))
	{
	  struct _atexit *p, *q;
	  for (p = ptr->_atexit; p != &ptr->_atexit0;)
   1d7e8:	e51b3020 	ldr	r3, [fp, #-32]
   1d7ec:	e2832f53 	add	r2, r3, #332	; 0x14c
   1d7f0:	e51b3010 	ldr	r3, [fp, #-16]
   1d7f4:	e1520003 	cmp	r2, r3
   1d7f8:	1afffff2 	bne	1d7c8 <_reclaim_reent+0x114>
	    }
	}
# endif
#endif

      if (ptr->_cvtbuf)
   1d7fc:	e51b3020 	ldr	r3, [fp, #-32]
   1d800:	e5933054 	ldr	r3, [r3, #84]	; 0x54
   1d804:	e3530000 	cmp	r3, #0
   1d808:	0a000004 	beq	1d820 <_reclaim_reent+0x16c>
	_free_r (ptr, ptr->_cvtbuf);
   1d80c:	e51b3020 	ldr	r3, [fp, #-32]
   1d810:	e5933054 	ldr	r3, [r3, #84]	; 0x54
   1d814:	e51b0020 	ldr	r0, [fp, #-32]
   1d818:	e1a01003 	mov	r1, r3
   1d81c:	ebfff01e 	bl	1989c <_free_r>
	   do it safely considering that a signal may be delivered immediately
	   after the free?
	  if (ptr->_sig_func)
	_free_r (ptr, ptr->_sig_func);*/

      if (ptr->__sdidinit)
   1d820:	e51b3020 	ldr	r3, [fp, #-32]
   1d824:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   1d828:	e3530000 	cmp	r3, #0
   1d82c:	0a00000d 	beq	1d868 <_reclaim_reent+0x1b4>
	{
	  /* cleanup won't reclaim memory 'coz usually it's run
	     before the program exits, and who wants to wait for that? */
	  ptr->__cleanup (ptr);
   1d830:	e51b3020 	ldr	r3, [fp, #-32]
   1d834:	e593303c 	ldr	r3, [r3, #60]	; 0x3c
   1d838:	e51b0020 	ldr	r0, [fp, #-32]
   1d83c:	e1a0e00f 	mov	lr, pc
   1d840:	e12fff13 	bx	r3

	  if (ptr->__sglue._next)
   1d844:	e51b3020 	ldr	r3, [fp, #-32]
   1d848:	e59332e0 	ldr	r3, [r3, #736]	; 0x2e0
   1d84c:	e3530000 	cmp	r3, #0
   1d850:	0a000004 	beq	1d868 <_reclaim_reent+0x1b4>
	    cleanup_glue (ptr, ptr->__sglue._next);
   1d854:	e51b3020 	ldr	r3, [fp, #-32]
   1d858:	e59332e0 	ldr	r3, [r3, #736]	; 0x2e0
   1d85c:	e51b0020 	ldr	r0, [fp, #-32]
   1d860:	e1a01003 	mov	r1, r3
   1d864:	ebffff7e 	bl	1d664 <cleanup_glue>
	}

      /* Malloc memory not reclaimed; no good way to return memory anyway. */

    }
}
   1d868:	e24bd004 	sub	sp, fp, #4
   1d86c:	e8bd4800 	pop	{fp, lr}
   1d870:	e12fff1e 	bx	lr
   1d874:	00025440 	.word	0x00025440

0001d878 <sbrk>:
extern uint8_t * OS_USER_HEAP_ADDRESS;

void *
_DEFUN (_sbrk, (incr),
     int incr)
{ 
   1d878:	e92d4800 	push	{fp, lr}
   1d87c:	e28db004 	add	fp, sp, #4
   1d880:	e24dd010 	sub	sp, sp, #16
   1d884:	e50b0010 	str	r0, [fp, #-16]
  uint8_t * ptr_start = NULL;
   1d888:	e3a03000 	mov	r3, #0
   1d88c:	e50b3008 	str	r3, [fp, #-8]
 
  cpu_dcache_invalidate((void*)&OS_USER_HEAP_ADDRESS, sizeof(uint8_t*));
   1d890:	e59f0044 	ldr	r0, [pc, #68]	; 1d8dc <sbrk+0x64>
   1d894:	e3a01004 	mov	r1, #4
   1d898:	ebffb104 	bl	9cb0 <cpu_dcache_invalidate>
  ptr_start = (uint8_t *)(((uint32_t)(OS_USER_HEAP_ADDRESS + 8)) & 0xFFFFFFF8);
   1d89c:	e59f3038 	ldr	r3, [pc, #56]	; 1d8dc <sbrk+0x64>
   1d8a0:	e5933000 	ldr	r3, [r3]
   1d8a4:	e2833008 	add	r3, r3, #8
   1d8a8:	e3c33007 	bic	r3, r3, #7
   1d8ac:	e50b3008 	str	r3, [fp, #-8]
  OS_USER_HEAP_ADDRESS = OS_USER_HEAP_ADDRESS + incr; 
   1d8b0:	e59f3024 	ldr	r3, [pc, #36]	; 1d8dc <sbrk+0x64>
   1d8b4:	e5932000 	ldr	r2, [r3]
   1d8b8:	e51b3010 	ldr	r3, [fp, #-16]
   1d8bc:	e0822003 	add	r2, r2, r3
   1d8c0:	e59f3014 	ldr	r3, [pc, #20]	; 1d8dc <sbrk+0x64>
   1d8c4:	e5832000 	str	r2, [r3]

  return ptr_start;
   1d8c8:	e51b3008 	ldr	r3, [fp, #-8]
} 
   1d8cc:	e1a00003 	mov	r0, r3
   1d8d0:	e24bd004 	sub	sp, fp, #4
   1d8d4:	e8bd4800 	pop	{fp, lr}
   1d8d8:	e12fff1e 	bx	lr
   1d8dc:	000254f4 	.word	0x000254f4

0001d8e0 <__fpclassifyd>:

#include "fdlibm.h"

int
__fpclassifyd (double x)
{
   1d8e0:	e92d0810 	push	{r4, fp}
   1d8e4:	e28db004 	add	fp, sp, #4
   1d8e8:	e24dd018 	sub	sp, sp, #24
   1d8ec:	e50b001c 	str	r0, [fp, #-28]
   1d8f0:	e50b1018 	str	r1, [fp, #-24]
  __uint32_t msw, lsw;

  EXTRACT_WORDS(msw,lsw,x);
   1d8f4:	e24b401c 	sub	r4, fp, #28
   1d8f8:	e8940018 	ldm	r4, {r3, r4}
   1d8fc:	e50b3014 	str	r3, [fp, #-20]
   1d900:	e50b4010 	str	r4, [fp, #-16]
   1d904:	e51b3010 	ldr	r3, [fp, #-16]
   1d908:	e50b3008 	str	r3, [fp, #-8]
   1d90c:	e51b3014 	ldr	r3, [fp, #-20]
   1d910:	e50b300c 	str	r3, [fp, #-12]

  if ((msw == 0x00000000 && lsw == 0x00000000) ||
   1d914:	e51b3008 	ldr	r3, [fp, #-8]
   1d918:	e3530000 	cmp	r3, #0
   1d91c:	1a000002 	bne	1d92c <__fpclassifyd+0x4c>
   1d920:	e51b300c 	ldr	r3, [fp, #-12]
   1d924:	e3530000 	cmp	r3, #0
   1d928:	0a000005 	beq	1d944 <__fpclassifyd+0x64>
   1d92c:	e51b3008 	ldr	r3, [fp, #-8]
   1d930:	e3530102 	cmp	r3, #-2147483648	; 0x80000000
   1d934:	1a000004 	bne	1d94c <__fpclassifyd+0x6c>
      (msw == 0x80000000 && lsw == 0x00000000))
   1d938:	e51b300c 	ldr	r3, [fp, #-12]
   1d93c:	e3530000 	cmp	r3, #0
   1d940:	1a000001 	bne	1d94c <__fpclassifyd+0x6c>
    return FP_ZERO;
   1d944:	e3a03002 	mov	r3, #2
   1d948:	ea00002b 	b	1d9fc <__fpclassifyd+0x11c>
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
   1d94c:	e51b3008 	ldr	r3, [fp, #-8]
   1d950:	e3530601 	cmp	r3, #1048576	; 0x100000
   1d954:	3a000003 	bcc	1d968 <__fpclassifyd+0x88>
   1d958:	e51b2008 	ldr	r2, [fp, #-8]
   1d95c:	e59f30a8 	ldr	r3, [pc, #168]	; 1da0c <__fpclassifyd+0x12c>
   1d960:	e1520003 	cmp	r2, r3
   1d964:	9a000006 	bls	1d984 <__fpclassifyd+0xa4>
   1d968:	e51b2008 	ldr	r2, [fp, #-8]
   1d96c:	e59f309c 	ldr	r3, [pc, #156]	; 1da10 <__fpclassifyd+0x130>
   1d970:	e1520003 	cmp	r2, r3
   1d974:	9a000004 	bls	1d98c <__fpclassifyd+0xac>
           (msw >= 0x80100000 && msw <= 0xffefffff))
   1d978:	e51b3008 	ldr	r3, [fp, #-8]
   1d97c:	e3730601 	cmn	r3, #1048576	; 0x100000
   1d980:	2a000001 	bcs	1d98c <__fpclassifyd+0xac>
    return FP_NORMAL;
   1d984:	e3a03004 	mov	r3, #4
   1d988:	ea00001b 	b	1d9fc <__fpclassifyd+0x11c>
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
   1d98c:	e51b3008 	ldr	r3, [fp, #-8]
   1d990:	e3530601 	cmp	r3, #1048576	; 0x100000
   1d994:	3a000006 	bcc	1d9b4 <__fpclassifyd+0xd4>
           (msw >= 0x80000000 && msw <= 0x800fffff))
   1d998:	e51b3008 	ldr	r3, [fp, #-8]
      (msw == 0x80000000 && lsw == 0x00000000))
    return FP_ZERO;
  else if ((msw >= 0x00100000 && msw <= 0x7fefffff) ||
           (msw >= 0x80100000 && msw <= 0xffefffff))
    return FP_NORMAL;
  else if ((msw >= 0x00000000 && msw <= 0x000fffff) ||
   1d99c:	e3530000 	cmp	r3, #0
   1d9a0:	aa000005 	bge	1d9bc <__fpclassifyd+0xdc>
           (msw >= 0x80000000 && msw <= 0x800fffff))
   1d9a4:	e51b2008 	ldr	r2, [fp, #-8]
   1d9a8:	e59f3060 	ldr	r3, [pc, #96]	; 1da10 <__fpclassifyd+0x130>
   1d9ac:	e1520003 	cmp	r2, r3
   1d9b0:	8a000001 	bhi	1d9bc <__fpclassifyd+0xdc>
    /* zero is already handled above */
    return FP_SUBNORMAL;
   1d9b4:	e3a03003 	mov	r3, #3
   1d9b8:	ea00000f 	b	1d9fc <__fpclassifyd+0x11c>
  else if ((msw == 0x7ff00000 && lsw == 0x00000000) ||
   1d9bc:	e51b2008 	ldr	r2, [fp, #-8]
   1d9c0:	e59f304c 	ldr	r3, [pc, #76]	; 1da14 <__fpclassifyd+0x134>
   1d9c4:	e1520003 	cmp	r2, r3
   1d9c8:	1a000002 	bne	1d9d8 <__fpclassifyd+0xf8>
   1d9cc:	e51b300c 	ldr	r3, [fp, #-12]
   1d9d0:	e3530000 	cmp	r3, #0
   1d9d4:	0a000005 	beq	1d9f0 <__fpclassifyd+0x110>
   1d9d8:	e51b3008 	ldr	r3, [fp, #-8]
   1d9dc:	e3730601 	cmn	r3, #1048576	; 0x100000
   1d9e0:	1a000004 	bne	1d9f8 <__fpclassifyd+0x118>
           (msw == 0xfff00000 && lsw == 0x00000000))
   1d9e4:	e51b300c 	ldr	r3, [fp, #-12]
   1d9e8:	e3530000 	cmp	r3, #0
   1d9ec:	1a000001 	bne	1d9f8 <__fpclassifyd+0x118>
    return FP_INFINITE;
   1d9f0:	e3a03001 	mov	r3, #1
   1d9f4:	ea000000 	b	1d9fc <__fpclassifyd+0x11c>
  else
    return FP_NAN;
   1d9f8:	e3a03000 	mov	r3, #0
}
   1d9fc:	e1a00003 	mov	r0, r3
   1da00:	e24bd004 	sub	sp, fp, #4
   1da04:	e8bd0810 	pop	{r4, fp}
   1da08:	e12fff1e 	bx	lr
   1da0c:	7fefffff 	.word	0x7fefffff
   1da10:	800fffff 	.word	0x800fffff
   1da14:	7ff00000 	.word	0x7ff00000

0001da18 <frexp>:
	double frexp(double x, int *eptr)
#else
	double frexp(x, eptr)
	double x; int *eptr;
#endif
{
   1da18:	e92d4810 	push	{r4, fp, lr}
   1da1c:	e28db008 	add	fp, sp, #8
   1da20:	e24dd03c 	sub	sp, sp, #60	; 0x3c
   1da24:	e50b003c 	str	r0, [fp, #-60]	; 0x3c
   1da28:	e50b1038 	str	r1, [fp, #-56]	; 0x38
   1da2c:	e50b2040 	str	r2, [fp, #-64]	; 0x40
	__int32_t hx, ix, lx;
	EXTRACT_WORDS(hx,lx,x);
   1da30:	e24b403c 	sub	r4, fp, #60	; 0x3c
   1da34:	e8940018 	ldm	r4, {r3, r4}
   1da38:	e50b3024 	str	r3, [fp, #-36]	; 0x24
   1da3c:	e50b4020 	str	r4, [fp, #-32]
   1da40:	e51b3020 	ldr	r3, [fp, #-32]
   1da44:	e50b3010 	str	r3, [fp, #-16]
   1da48:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1da4c:	e50b3018 	str	r3, [fp, #-24]
	ix = 0x7fffffff&hx;
   1da50:	e51b3010 	ldr	r3, [fp, #-16]
   1da54:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   1da58:	e50b3014 	str	r3, [fp, #-20]
	*eptr = 0;
   1da5c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1da60:	e3a02000 	mov	r2, #0
   1da64:	e5832000 	str	r2, [r3]
	if(ix>=0x7ff00000||((ix|lx)==0)) return x;	/* 0,inf,nan */
   1da68:	e51b2014 	ldr	r2, [fp, #-20]
   1da6c:	e59f310c 	ldr	r3, [pc, #268]	; 1db80 <frexp+0x168>
   1da70:	e1520003 	cmp	r2, r3
   1da74:	ca000004 	bgt	1da8c <frexp+0x74>
   1da78:	e51b2014 	ldr	r2, [fp, #-20]
   1da7c:	e51b3018 	ldr	r3, [fp, #-24]
   1da80:	e1823003 	orr	r3, r2, r3
   1da84:	e3530000 	cmp	r3, #0
   1da88:	1a000002 	bne	1da98 <frexp+0x80>
   1da8c:	e24b403c 	sub	r4, fp, #60	; 0x3c
   1da90:	e8940018 	ldm	r4, {r3, r4}
   1da94:	ea000034 	b	1db6c <frexp+0x154>
	if (ix<0x00100000) {		/* subnormal */
   1da98:	e51b3014 	ldr	r3, [fp, #-20]
   1da9c:	e3530601 	cmp	r3, #1048576	; 0x100000
   1daa0:	aa000016 	bge	1db00 <frexp+0xe8>
	    x *= two54;
   1daa4:	e3a03000 	mov	r3, #0
   1daa8:	e59f40d4 	ldr	r4, [pc, #212]	; 1db84 <frexp+0x16c>
   1daac:	e24b103c 	sub	r1, fp, #60	; 0x3c
   1dab0:	e8910003 	ldm	r1, {r0, r1}
   1dab4:	e1a02003 	mov	r2, r3
   1dab8:	e1a03004 	mov	r3, r4
   1dabc:	eb0012f1 	bl	22688 <__aeabi_dmul>
   1dac0:	e1a03000 	mov	r3, r0
   1dac4:	e1a04001 	mov	r4, r1
   1dac8:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   1dacc:	e50b4038 	str	r4, [fp, #-56]	; 0x38
	    GET_HIGH_WORD(hx,x);
   1dad0:	e24b403c 	sub	r4, fp, #60	; 0x3c
   1dad4:	e8940018 	ldm	r4, {r3, r4}
   1dad8:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
   1dadc:	e50b4028 	str	r4, [fp, #-40]	; 0x28
   1dae0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1dae4:	e50b3010 	str	r3, [fp, #-16]
	    ix = hx&0x7fffffff;
   1dae8:	e51b3010 	ldr	r3, [fp, #-16]
   1daec:	e3c33102 	bic	r3, r3, #-2147483648	; 0x80000000
   1daf0:	e50b3014 	str	r3, [fp, #-20]
	    *eptr = -54;
   1daf4:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1daf8:	e3e02035 	mvn	r2, #53	; 0x35
   1dafc:	e5832000 	str	r2, [r3]
	}
	*eptr += (ix>>20)-1022;
   1db00:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1db04:	e5932000 	ldr	r2, [r3]
   1db08:	e51b3014 	ldr	r3, [fp, #-20]
   1db0c:	e1a03a43 	asr	r3, r3, #20
   1db10:	e2433fff 	sub	r3, r3, #1020	; 0x3fc
   1db14:	e2433002 	sub	r3, r3, #2
   1db18:	e0822003 	add	r2, r2, r3
   1db1c:	e51b3040 	ldr	r3, [fp, #-64]	; 0x40
   1db20:	e5832000 	str	r2, [r3]
	hx = (hx&0x800fffff)|0x3fe00000;
   1db24:	e51b3010 	ldr	r3, [fp, #-16]
   1db28:	e3c3347f 	bic	r3, r3, #2130706432	; 0x7f000000
   1db2c:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
   1db30:	e38335ff 	orr	r3, r3, #1069547520	; 0x3fc00000
   1db34:	e3833602 	orr	r3, r3, #2097152	; 0x200000
   1db38:	e50b3010 	str	r3, [fp, #-16]
	SET_HIGH_WORD(x,hx);
   1db3c:	e24b403c 	sub	r4, fp, #60	; 0x3c
   1db40:	e8940018 	ldm	r4, {r3, r4}
   1db44:	e50b3034 	str	r3, [fp, #-52]	; 0x34
   1db48:	e50b4030 	str	r4, [fp, #-48]	; 0x30
   1db4c:	e51b3010 	ldr	r3, [fp, #-16]
   1db50:	e50b3030 	str	r3, [fp, #-48]	; 0x30
   1db54:	e24b4034 	sub	r4, fp, #52	; 0x34
   1db58:	e8940018 	ldm	r4, {r3, r4}
   1db5c:	e50b303c 	str	r3, [fp, #-60]	; 0x3c
   1db60:	e50b4038 	str	r4, [fp, #-56]	; 0x38
	return x;
   1db64:	e24b403c 	sub	r4, fp, #60	; 0x3c
   1db68:	e8940018 	ldm	r4, {r3, r4}
}
   1db6c:	e1a00003 	mov	r0, r3
   1db70:	e1a01004 	mov	r1, r4
   1db74:	e24bd008 	sub	sp, fp, #8
   1db78:	e8bd4810 	pop	{r4, fp, lr}
   1db7c:	e12fff1e 	bx	lr
   1db80:	7fefffff 	.word	0x7fefffff
   1db84:	43500000 	.word	0x43500000

0001db88 <__sread>:
_DEFUN(__sread, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char *buf _AND
       int n)
{
   1db88:	e92d4830 	push	{r4, r5, fp, lr}
   1db8c:	e28db00c 	add	fp, sp, #12
   1db90:	e24dd010 	sub	sp, sp, #16
   1db94:	e50b0010 	str	r0, [fp, #-16]
   1db98:	e50b1014 	str	r1, [fp, #-20]
   1db9c:	e50b2018 	str	r2, [fp, #-24]
   1dba0:	e50b301c 	str	r3, [fp, #-28]
  register FILE *fp = (FILE *) cookie;
   1dba4:	e51b4014 	ldr	r4, [fp, #-20]
  int oldmode = 0;
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  ret = _read_r (ptr, fp->_file, buf, n);
   1dba8:	e1d430be 	ldrh	r3, [r4, #14]
   1dbac:	e1a03803 	lsl	r3, r3, #16
   1dbb0:	e1a02843 	asr	r2, r3, #16
   1dbb4:	e51b301c 	ldr	r3, [fp, #-28]
   1dbb8:	e51b0010 	ldr	r0, [fp, #-16]
   1dbbc:	e1a01002 	mov	r1, r2
   1dbc0:	e51b2018 	ldr	r2, [fp, #-24]
   1dbc4:	eb001036 	bl	21ca4 <_read_r>
   1dbc8:	e1a05000 	mov	r5, r0
    setmode (fp->_file, oldmode);
#endif

  /* If the read succeeded, update the current offset.  */

  if (ret >= 0)
   1dbcc:	e3550000 	cmp	r5, #0
   1dbd0:	ba000008 	blt	1dbf8 <__sread+0x70>
    fp->_offset += ret;
   1dbd4:	e2841050 	add	r1, r4, #80	; 0x50
   1dbd8:	e8910003 	ldm	r1, {r0, r1}
   1dbdc:	e1a02005 	mov	r2, r5
   1dbe0:	e1a03fc2 	asr	r3, r2, #31
   1dbe4:	e0922000 	adds	r2, r2, r0
   1dbe8:	e0a33001 	adc	r3, r3, r1
   1dbec:	e5842050 	str	r2, [r4, #80]	; 0x50
   1dbf0:	e5843054 	str	r3, [r4, #84]	; 0x54
   1dbf4:	ea000004 	b	1dc0c <__sread+0x84>
  else
    fp->_flags &= ~__SOFF;	/* paranoia */
   1dbf8:	e1d430bc 	ldrh	r3, [r4, #12]
   1dbfc:	e3c33a01 	bic	r3, r3, #4096	; 0x1000
   1dc00:	e1a03803 	lsl	r3, r3, #16
   1dc04:	e1a03823 	lsr	r3, r3, #16
   1dc08:	e1c430bc 	strh	r3, [r4, #12]
  return ret;
   1dc0c:	e1a03005 	mov	r3, r5
}
   1dc10:	e1a00003 	mov	r0, r3
   1dc14:	e24bd00c 	sub	sp, fp, #12
   1dc18:	e8bd4830 	pop	{r4, r5, fp, lr}
   1dc1c:	e12fff1e 	bx	lr

0001dc20 <__seofread>:
_DEFUN(__seofread, (ptr, cookie, buf, len),
       struct _reent *_ptr _AND
       _PTR cookie _AND
       char *buf   _AND
       int len)
{
   1dc20:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   1dc24:	e28db000 	add	fp, sp, #0
   1dc28:	e24dd014 	sub	sp, sp, #20
   1dc2c:	e50b0008 	str	r0, [fp, #-8]
   1dc30:	e50b100c 	str	r1, [fp, #-12]
   1dc34:	e50b2010 	str	r2, [fp, #-16]
   1dc38:	e50b3014 	str	r3, [fp, #-20]
  return 0;
   1dc3c:	e3a03000 	mov	r3, #0
}
   1dc40:	e1a00003 	mov	r0, r3
   1dc44:	e24bd000 	sub	sp, fp, #0
   1dc48:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1dc4c:	e12fff1e 	bx	lr

0001dc50 <__swrite>:
_DEFUN(__swrite, (ptr, cookie, buf, n),
       struct _reent *ptr _AND
       void *cookie _AND
       char const *buf _AND
       int n)
{
   1dc50:	e92d4810 	push	{r4, fp, lr}
   1dc54:	e28db008 	add	fp, sp, #8
   1dc58:	e24dd024 	sub	sp, sp, #36	; 0x24
   1dc5c:	e50b0018 	str	r0, [fp, #-24]
   1dc60:	e50b101c 	str	r1, [fp, #-28]
   1dc64:	e50b2020 	str	r2, [fp, #-32]
   1dc68:	e50b3024 	str	r3, [fp, #-36]	; 0x24
  register FILE *fp = (FILE *) cookie;
   1dc6c:	e51b401c 	ldr	r4, [fp, #-28]
  int w;
#ifdef __SCLE
  int oldmode=0;
#endif

  if (fp->_flags & __SAPP)
   1dc70:	e1d430bc 	ldrh	r3, [r4, #12]
   1dc74:	e1a03803 	lsl	r3, r3, #16
   1dc78:	e1a03823 	lsr	r3, r3, #16
   1dc7c:	e2033c01 	and	r3, r3, #256	; 0x100
   1dc80:	e3530000 	cmp	r3, #0
   1dc84:	0a000009 	beq	1dcb0 <__swrite+0x60>
    _lseek_r (ptr, fp->_file, (_off_t) 0, SEEK_END);
   1dc88:	e1d430be 	ldrh	r3, [r4, #14]
   1dc8c:	e1a03803 	lsl	r3, r3, #16
   1dc90:	e1a03843 	asr	r3, r3, #16
   1dc94:	e3a02002 	mov	r2, #2
   1dc98:	e58d2000 	str	r2, [sp]
   1dc9c:	e51b0018 	ldr	r0, [fp, #-24]
   1dca0:	e1a01003 	mov	r1, r3
   1dca4:	e3a02000 	mov	r2, #0
   1dca8:	e3a03000 	mov	r3, #0
   1dcac:	eb000fd3 	bl	21c00 <_lseek_r>
  fp->_flags &= ~__SOFF;	/* in case O_APPEND mode is set */
   1dcb0:	e1d430bc 	ldrh	r3, [r4, #12]
   1dcb4:	e3c33a01 	bic	r3, r3, #4096	; 0x1000
   1dcb8:	e1a03803 	lsl	r3, r3, #16
   1dcbc:	e1a03823 	lsr	r3, r3, #16
   1dcc0:	e1c430bc 	strh	r3, [r4, #12]
#ifdef __SCLE
  if (fp->_flags & __SCLE)
    oldmode = setmode (fp->_file, O_BINARY);
#endif

  w = _write_r (ptr, fp->_file, buf, n);
   1dcc4:	e1d430be 	ldrh	r3, [r4, #14]
   1dcc8:	e1a03803 	lsl	r3, r3, #16
   1dccc:	e1a02843 	asr	r2, r3, #16
   1dcd0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1dcd4:	e51b0018 	ldr	r0, [fp, #-24]
   1dcd8:	e1a01002 	mov	r1, r2
   1dcdc:	e51b2020 	ldr	r2, [fp, #-32]
   1dce0:	eb000d80 	bl	212e8 <_write_r>
   1dce4:	e50b0010 	str	r0, [fp, #-16]
#ifdef __SCLE
  if (oldmode)
    setmode (fp->_file, oldmode);
#endif

  return w;
   1dce8:	e51b3010 	ldr	r3, [fp, #-16]
}
   1dcec:	e1a00003 	mov	r0, r3
   1dcf0:	e24bd008 	sub	sp, fp, #8
   1dcf4:	e8bd4810 	pop	{r4, fp, lr}
   1dcf8:	e12fff1e 	bx	lr

0001dcfc <__sseek>:
_DEFUN(__sseek, (ptr, cookie, offset, whence),
       struct _reent *ptr _AND
       void *cookie _AND
       _fpos_t offset _AND
       int whence)
{
   1dcfc:	e92d4870 	push	{r4, r5, r6, fp, lr}
   1dd00:	e28db010 	add	fp, sp, #16
   1dd04:	e24dd01c 	sub	sp, sp, #28
   1dd08:	e50b0018 	str	r0, [fp, #-24]
   1dd0c:	e50b101c 	str	r1, [fp, #-28]
   1dd10:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   1dd14:	e50b3020 	str	r3, [fp, #-32]
  register FILE *fp = (FILE *) cookie;
   1dd18:	e51b601c 	ldr	r6, [fp, #-28]
  register _off_t ret;

  ret = _lseek_r (ptr, fp->_file, (_off_t) offset, whence);
   1dd1c:	e1d630be 	ldrh	r3, [r6, #14]
   1dd20:	e1a03803 	lsl	r3, r3, #16
   1dd24:	e1a03843 	asr	r3, r3, #16
   1dd28:	e59b2004 	ldr	r2, [fp, #4]
   1dd2c:	e58d2000 	str	r2, [sp]
   1dd30:	e51b0018 	ldr	r0, [fp, #-24]
   1dd34:	e1a01003 	mov	r1, r3
   1dd38:	e24b3024 	sub	r3, fp, #36	; 0x24
   1dd3c:	e893000c 	ldm	r3, {r2, r3}
   1dd40:	eb000fae 	bl	21c00 <_lseek_r>
   1dd44:	e1a04000 	mov	r4, r0
   1dd48:	e1a05001 	mov	r5, r1
  if (ret == -1L)
   1dd4c:	e3e02000 	mvn	r2, #0
   1dd50:	e3e03000 	mvn	r3, #0
   1dd54:	e1550003 	cmp	r5, r3
   1dd58:	01540002 	cmpeq	r4, r2
   1dd5c:	1a000005 	bne	1dd78 <__sseek+0x7c>
    fp->_flags &= ~__SOFF;
   1dd60:	e1d630bc 	ldrh	r3, [r6, #12]
   1dd64:	e3c33a01 	bic	r3, r3, #4096	; 0x1000
   1dd68:	e1a03803 	lsl	r3, r3, #16
   1dd6c:	e1a03823 	lsr	r3, r3, #16
   1dd70:	e1c630bc 	strh	r3, [r6, #12]
   1dd74:	ea000006 	b	1dd94 <__sseek+0x98>
  else
    {
      fp->_flags |= __SOFF;
   1dd78:	e1d630bc 	ldrh	r3, [r6, #12]
   1dd7c:	e3833a01 	orr	r3, r3, #4096	; 0x1000
   1dd80:	e1a03803 	lsl	r3, r3, #16
   1dd84:	e1a03823 	lsr	r3, r3, #16
   1dd88:	e1c630bc 	strh	r3, [r6, #12]
      fp->_offset = ret;
   1dd8c:	e5864050 	str	r4, [r6, #80]	; 0x50
   1dd90:	e5865054 	str	r5, [r6, #84]	; 0x54
    }
  return ret;
   1dd94:	e1a03004 	mov	r3, r4
   1dd98:	e1a04005 	mov	r4, r5
}
   1dd9c:	e1a00003 	mov	r0, r3
   1dda0:	e1a01004 	mov	r1, r4
   1dda4:	e24bd010 	sub	sp, fp, #16
   1dda8:	e8bd4870 	pop	{r4, r5, r6, fp, lr}
   1ddac:	e12fff1e 	bx	lr

0001ddb0 <__sclose>:

int
_DEFUN(__sclose, (ptr, cookie),
       struct _reent *ptr _AND
       void *cookie)
{
   1ddb0:	e92d4800 	push	{fp, lr}
   1ddb4:	e28db004 	add	fp, sp, #4
   1ddb8:	e24dd010 	sub	sp, sp, #16
   1ddbc:	e50b0010 	str	r0, [fp, #-16]
   1ddc0:	e50b1014 	str	r1, [fp, #-20]
  FILE *fp = (FILE *) cookie;
   1ddc4:	e51b3014 	ldr	r3, [fp, #-20]
   1ddc8:	e50b3008 	str	r3, [fp, #-8]

  return _close_r (ptr, fp->_file);
   1ddcc:	e51b3008 	ldr	r3, [fp, #-8]
   1ddd0:	e1d330be 	ldrh	r3, [r3, #14]
   1ddd4:	e1a03803 	lsl	r3, r3, #16
   1ddd8:	e1a03843 	asr	r3, r3, #16
   1dddc:	e51b0010 	ldr	r0, [fp, #-16]
   1dde0:	e1a01003 	mov	r1, r3
   1dde4:	eb000dbf 	bl	214e8 <_close_r>
   1dde8:	e1a03000 	mov	r3, r0
}
   1ddec:	e1a00003 	mov	r0, r3
   1ddf0:	e24bd004 	sub	sp, fp, #4
   1ddf4:	e8bd4800 	pop	{fp, lr}
   1ddf8:	e12fff1e 	bx	lr

0001ddfc <strcmp>:
#define magic2(REG) REG, lsl #7
#endif

        optpld  r0
        optpld  r1
        eor     r2, r0, r1
   1ddfc:	e0202001 	eor	r2, r0, r1
        tst     r2, #3
   1de00:	e3120003 	tst	r2, #3
        /* Strings not at same byte offset from a word boundary.  */
        bne     .Lstrcmp_unaligned
   1de04:	1a000021 	bne	1de90 <strcmp+0x94>
        ands    r2, r0, #3
   1de08:	e2102003 	ands	r2, r0, #3
        bic     r0, r0, #3
   1de0c:	e3c00003 	bic	r0, r0, #3
        bic     r1, r1, #3
   1de10:	e3c11003 	bic	r1, r1, #3
        ldr     ip, [r0], #4
   1de14:	e490c004 	ldr	ip, [r0], #4
        it      eq
        ldreq   r3, [r1], #4
   1de18:	04913004 	ldreq	r3, [r1], #4
        beq     1f
   1de1c:	0a000006 	beq	1de3c <strcmp+0x40>
        /* Although s1 and s2 have identical initial alignment, they are
        not currently word aligned.  Rather than comparing bytes,
	make sure that any bytes fetched from before the addressed
	bytes are forced to 0xff.  Then they will always compare
	equal.  */
        eor     r2, r2, #3
   1de20:	e2222003 	eor	r2, r2, #3
        lsl     r2, r2, #3
   1de24:	e1a02182 	lsl	r2, r2, #3
        mvn     r3, MSB
   1de28:	e3e034ff 	mvn	r3, #-16777216	; 0xff000000
        S2LOMEM        r2, r3, r2
   1de2c:	e1a02233 	lsr	r2, r3, r2
        ldr     r3, [r1], #4
   1de30:	e4913004 	ldr	r3, [r1], #4
        orr     ip, ip, r2
   1de34:	e18cc002 	orr	ip, ip, r2
        orr     r3, r3, r2
   1de38:	e1833002 	orr	r3, r3, r2
1:
#ifndef __thumb2__
              /* Load the 'magic' constant 0x01010101.  */
        str     r4, [sp, #-4]!
   1de3c:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
        mov     r4, #1
   1de40:	e3a04001 	mov	r4, #1
        orr     r4, r4, r4, lsl #8
   1de44:	e1844404 	orr	r4, r4, r4, lsl #8
        orr     r4, r4, r4, lsl #16
   1de48:	e1844804 	orr	r4, r4, r4, lsl #16
#endif
        .p2align        2
4:
        optpld  r0, #8
        optpld  r1, #8
        sub     r2, ip, magic1(r4)
   1de4c:	e04c2004 	sub	r2, ip, r4
        cmp     ip, r3
   1de50:	e15c0003 	cmp	ip, r3
        itttt   eq
        /* check for any zero bytes in first word */
        biceq   r2, r2, ip
   1de54:	01c2200c 	biceq	r2, r2, ip
        tsteq   r2, magic2(r4)
   1de58:	01120384 	tsteq	r2, r4, lsl #7
        ldreq   ip, [r0], #4
   1de5c:	0490c004 	ldreq	ip, [r0], #4
        ldreq   r3, [r1], #4
   1de60:	04913004 	ldreq	r3, [r1], #4
        beq     4b
   1de64:	0afffff8 	beq	1de4c <strcmp+0x50>
2:
        /* There's a zero or a different byte in the word */
        S2HIMEM  r0, ip, #24
   1de68:	e1a00c0c 	lsl	r0, ip, #24
        S2LOMEM  ip, ip, #8
   1de6c:	e1a0c42c 	lsr	ip, ip, #8
        cmp     r0, #1
   1de70:	e3500001 	cmp	r0, #1
        it      cs
        cmpcs   r0, r3, S2HIMEM #24
   1de74:	21500c03 	cmpcs	r0, r3, lsl #24
        it      eq
        S2LOMEMEQ r3, r3, #8
   1de78:	01a03423 	lsreq	r3, r3, #8
        beq     2b
   1de7c:	0afffff9 	beq	1de68 <strcmp+0x6c>
        little-endian case we can't just shift the interesting bits
        up.  */
#ifdef __ARMEB__
        sub     r0, r0, r3, lsr #24
#else
        and     r3, r3, #255
   1de80:	e20330ff 	and	r3, r3, #255	; 0xff
#ifdef __thumb2__
        /* No RSB instruction in Thumb2 */
        lsr     r0, r0, #24
        sub     r0, r0, r3
#else
        rsb     r0, r3, r0, lsr #24
   1de84:	e0630c20 	rsb	r0, r3, r0, lsr #24
#endif
#endif
#ifndef __thumb2__
        ldr     r4, [sp], #4
   1de88:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
#endif
        RETURN
   1de8c:	e12fff1e 	bx	lr
        t1  .req ip
        @ r3 is scratch

        /* First of all, compare bytes until wp1(sp1) is word-aligned. */
1:
        tst     wp1, #3
   1de90:	e3100003 	tst	r0, #3
        beq     2f
   1de94:	0a000006 	beq	1deb4 <strcmp+0xb8>
        ldrb    r2, [wp1], #1
   1de98:	e4d02001 	ldrb	r2, [r0], #1
        ldrb    r3, [wp2], #1
   1de9c:	e4d13001 	ldrb	r3, [r1], #1
        cmp     r2, #1
   1dea0:	e3520001 	cmp	r2, #1
        it      cs
        cmpcs   r2, r3
   1dea4:	21520003 	cmpcs	r2, r3
        beq     1b
   1dea8:	0afffff8 	beq	1de90 <strcmp+0x94>
        sub     r0, r2, r3
   1deac:	e0420003 	sub	r0, r2, r3
        RETURN
   1deb0:	e12fff1e 	bx	lr

2:
        str     r5, [sp, #-4]!
   1deb4:	e52d5004 	push	{r5}		; (str r5, [sp, #-4]!)
        str     r4, [sp, #-4]!
   1deb8:	e52d4004 	push	{r4}		; (str r4, [sp, #-4]!)
        //stmfd   sp!, {r4, r5}
        mov     b1, #1
   1debc:	e3a02001 	mov	r2, #1
        orr     b1, b1, b1, lsl #8
   1dec0:	e1822402 	orr	r2, r2, r2, lsl #8
        orr     b1, b1, b1, lsl #16
   1dec4:	e1822802 	orr	r2, r2, r2, lsl #16

        and     t1, wp2, #3
   1dec8:	e201c003 	and	ip, r1, #3
        bic     wp2, wp2, #3
   1decc:	e3c11003 	bic	r1, r1, #3
        ldr     w1, [wp1], #4
   1ded0:	e4904004 	ldr	r4, [r0], #4
        ldr     w2, [wp2], #4
   1ded4:	e4915004 	ldr	r5, [r1], #4
        cmp     t1, #2
   1ded8:	e35c0002 	cmp	ip, #2
        beq     2f
   1dedc:	0a000017 	beq	1df40 <strcmp+0x144>
        bhi     3f
   1dee0:	8a00002d 	bhi	1df9c <strcmp+0x1a0>

        /* Critical inner Loop: Block with 3 bytes initial overlap */
        .p2align        2
1:
        bic     t1, w1, MSB
   1dee4:	e3c4c4ff 	bic	ip, r4, #-16777216	; 0xff000000
        cmp     t1, w2, S2LOMEM #8
   1dee8:	e15c0425 	cmp	ip, r5, lsr #8
        sub     r3, w1, b1
   1deec:	e0443002 	sub	r3, r4, r2
        bic     r3, r3, w1
   1def0:	e1c33004 	bic	r3, r3, r4
        bne     4f
   1def4:	1a000007 	bne	1df18 <strcmp+0x11c>
        ands    r3, r3, b1, lsl #7
   1def8:	e0133382 	ands	r3, r3, r2, lsl #7
        it      eq
        ldreq   w2, [wp2], #4
   1defc:	04915004 	ldreq	r5, [r1], #4
        bne     5f
   1df00:	1a000006 	bne	1df20 <strcmp+0x124>
        eor     t1, t1, w1
   1df04:	e02cc004 	eor	ip, ip, r4
        cmp     t1, w2, S2HIMEM #24
   1df08:	e15c0c05 	cmp	ip, r5, lsl #24
        bne     6f
   1df0c:	1a000008 	bne	1df34 <strcmp+0x138>
        ldr     w1, [wp1], #4
   1df10:	e4904004 	ldr	r4, [r0], #4
        b       1b
   1df14:	eafffff2 	b	1dee4 <strcmp+0xe8>
4:
        S2LOMEM        w2, w2, #8
   1df18:	e1a05425 	lsr	r5, r5, #8
        b       8f
   1df1c:	ea000037 	b	1e000 <strcmp+0x204>
        itt     ne
        tstne   w1, #0x00ff0000
        tstne   w1, #0x0000ff00
        beq     7f
#else
        bics    r3, r3, #0xff000000
   1df20:	e3d334ff 	bics	r3, r3, #-16777216	; 0xff000000
        bne     7f
   1df24:	1a000031 	bne	1dff0 <strcmp+0x1f4>
#endif
        ldrb    w2, [wp2]
   1df28:	e5d15000 	ldrb	r5, [r1]
        S2LOMEM  t1, w1, #24
   1df2c:	e1a0cc24 	lsr	ip, r4, #24
#ifdef __ARMEB__
        lsl     w2, w2, #24
#endif
        b       8f
   1df30:	ea000032 	b	1e000 <strcmp+0x204>

6:
        S2LOMEM  t1, w1, #24
   1df34:	e1a0cc24 	lsr	ip, r4, #24
        and     w2, w2, LSB
   1df38:	e20550ff 	and	r5, r5, #255	; 0xff
        b       8f
   1df3c:	ea00002f 	b	1e000 <strcmp+0x204>

        /* Critical inner Loop: Block with 2 bytes initial overlap */
        .p2align        2
2:
        S2HIMEM  t1, w1, #16
   1df40:	e1a0c804 	lsl	ip, r4, #16
        sub     r3, w1, b1
   1df44:	e0443002 	sub	r3, r4, r2
        S2LOMEM  t1, t1, #16
   1df48:	e1a0c82c 	lsr	ip, ip, #16
        bic     r3, r3, w1
   1df4c:	e1c33004 	bic	r3, r3, r4
        cmp     t1, w2, S2LOMEM #16
   1df50:	e15c0825 	cmp	ip, r5, lsr #16
        bne     4f
   1df54:	1a00000e 	bne	1df94 <strcmp+0x198>
        ands    r3, r3, b1, lsl #7
   1df58:	e0133382 	ands	r3, r3, r2, lsl #7
        it      eq
        ldreq   w2, [wp2], #4
   1df5c:	04915004 	ldreq	r5, [r1], #4
        bne     5f
   1df60:	1a000004 	bne	1df78 <strcmp+0x17c>
        eor     t1, t1, w1
   1df64:	e02cc004 	eor	ip, ip, r4
        cmp     t1, w2, S2HIMEM #16
   1df68:	e15c0805 	cmp	ip, r5, lsl #16
        bne     6f
   1df6c:	1a000006 	bne	1df8c <strcmp+0x190>
        ldr     w1, [wp1], #4
   1df70:	e4904004 	ldr	r4, [r0], #4
        b       2b
   1df74:	eafffff1 	b	1df40 <strcmp+0x144>
        tst     w1, #0xff000000
        it      ne
        tstne   w1, #0x00ff0000
        beq     7f
#else
        lsls    r3, r3, #16
   1df78:	e1b03803 	lsls	r3, r3, #16
        bne     7f
   1df7c:	1a00001b 	bne	1dff0 <strcmp+0x1f4>
#endif
        ldrh    w2, [wp2]
   1df80:	e1d150b0 	ldrh	r5, [r1]
        S2LOMEM  t1, w1, #16
   1df84:	e1a0c824 	lsr	ip, r4, #16
#ifdef __ARMEB__
        lsl     w2, w2, #16
#endif
        b       8f
   1df88:	ea00001c 	b	1e000 <strcmp+0x204>

6:
        S2HIMEM  w2, w2, #16
   1df8c:	e1a05805 	lsl	r5, r5, #16
        S2LOMEM  t1, w1, #16
   1df90:	e1a0c824 	lsr	ip, r4, #16
4:
        S2LOMEM  w2, w2, #16
   1df94:	e1a05825 	lsr	r5, r5, #16
        b       8f
   1df98:	ea000018 	b	1e000 <strcmp+0x204>

        /* Critical inner Loop: Block with 1 byte initial overlap */
        .p2align        2
3:
        and     t1, w1, LSB
   1df9c:	e204c0ff 	and	ip, r4, #255	; 0xff
        cmp     t1, w2, S2LOMEM #24
   1dfa0:	e15c0c25 	cmp	ip, r5, lsr #24
        sub     r3, w1, b1
   1dfa4:	e0443002 	sub	r3, r4, r2
        bic     r3, r3, w1
   1dfa8:	e1c33004 	bic	r3, r3, r4
        bne     4f
   1dfac:	1a000007 	bne	1dfd0 <strcmp+0x1d4>
        ands    r3, r3, b1, lsl #7
   1dfb0:	e0133382 	ands	r3, r3, r2, lsl #7
        it      eq
        ldreq   w2, [wp2], #4
   1dfb4:	04915004 	ldreq	r5, [r1], #4
        bne     5f
   1dfb8:	1a000006 	bne	1dfd8 <strcmp+0x1dc>
        eor     t1, t1, w1
   1dfbc:	e02cc004 	eor	ip, ip, r4
        cmp     t1, w2, S2HIMEM #8
   1dfc0:	e15c0405 	cmp	ip, r5, lsl #8
        bne     6f
   1dfc4:	1a000006 	bne	1dfe4 <strcmp+0x1e8>
        ldr     w1, [wp1], #4
   1dfc8:	e4904004 	ldr	r4, [r0], #4
        b       3b
   1dfcc:	eafffff2 	b	1df9c <strcmp+0x1a0>
4:
        S2LOMEM  w2, w2, #24
   1dfd0:	e1a05c25 	lsr	r5, r5, #24
        b       8f
   1dfd4:	ea000009 	b	1e000 <strcmp+0x204>
5:
        /* The syndrome value may contain false ones if the string ends
        with the bytes 0x01 0x00 */
        tst     w1, LSB
   1dfd8:	e31400ff 	tst	r4, #255	; 0xff
        beq     7f
   1dfdc:	0a000003 	beq	1dff0 <strcmp+0x1f4>
        ldr     w2, [wp2], #4
   1dfe0:	e4915004 	ldr	r5, [r1], #4
6:
        S2LOMEM  t1, w1, #8
   1dfe4:	e1a0c424 	lsr	ip, r4, #8
        bic     w2, w2, MSB
   1dfe8:	e3c554ff 	bic	r5, r5, #-16777216	; 0xff000000
        b       8f
   1dfec:	ea000003 	b	1e000 <strcmp+0x204>
7:
        mov     r0, #0
   1dff0:	e3a00000 	mov	r0, #0
        //ldmfd   sp!, {r4, r5}
        ldr     r4, [sp], #4
   1dff4:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
        ldr     r5, [sp], #4
   1dff8:	e49d5004 	pop	{r5}		; (ldr r5, [sp], #4)
        RETURN
   1dffc:	e12fff1e 	bx	lr
8:
        and     r2, t1, LSB
   1e000:	e20c20ff 	and	r2, ip, #255	; 0xff
        and     r0, w2, LSB
   1e004:	e20500ff 	and	r0, r5, #255	; 0xff
        cmp     r0, #1
   1e008:	e3500001 	cmp	r0, #1
        it      cs
        cmpcs   r0, r2
   1e00c:	21500002 	cmpcs	r0, r2
        itt     eq
        S2LOMEMEQ        t1, t1, #8
   1e010:	01a0c42c 	lsreq	ip, ip, #8
        S2LOMEMEQ        w2, w2, #8
   1e014:	01a05425 	lsreq	r5, r5, #8
        beq     8b
   1e018:	0afffff8 	beq	1e000 <strcmp+0x204>
        sub     r0, r2, r0
   1e01c:	e0420000 	sub	r0, r2, r0
        //ldmfd   sp!, {r4, r5}
        ldr     r4, [sp], #4
   1e020:	e49d4004 	pop	{r4}		; (ldr r4, [sp], #4)
        ldr     r5, [sp], #4
   1e024:	e49d5004 	pop	{r5}		; (ldr r5, [sp], #4)
        RETURN
   1e028:	e12fff1e 	bx	lr

0001e02c <strncpy>:
char *
_DEFUN (strncpy, (dst0, src0),
	char *__restrict dst0 _AND
	_CONST char *__restrict src0 _AND
	size_t count)
{
   1e02c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   1e030:	e28db000 	add	fp, sp, #0
   1e034:	e24dd024 	sub	sp, sp, #36	; 0x24
   1e038:	e50b0018 	str	r0, [fp, #-24]
   1e03c:	e50b101c 	str	r1, [fp, #-28]
   1e040:	e50b2020 	str	r2, [fp, #-32]
  while (count-- > 0)
    *dscan++ = '\0';

  return dst0;
#else
  char *dst = dst0;
   1e044:	e51b3018 	ldr	r3, [fp, #-24]
   1e048:	e50b3008 	str	r3, [fp, #-8]
  _CONST char *src = src0;
   1e04c:	e51b301c 	ldr	r3, [fp, #-28]
   1e050:	e50b300c 	str	r3, [fp, #-12]
  long *aligned_dst;
  _CONST long *aligned_src;

  /* If SRC and DEST is aligned and count large enough, then copy words.  */
  if (!UNALIGNED (src, dst) && !TOO_SMALL (count))
   1e054:	e51b200c 	ldr	r2, [fp, #-12]
   1e058:	e51b3008 	ldr	r3, [fp, #-8]
   1e05c:	e1823003 	orr	r3, r2, r3
   1e060:	e2033003 	and	r3, r3, #3
   1e064:	e3530000 	cmp	r3, #0
   1e068:	1a000026 	bne	1e108 <strncpy+0xdc>
   1e06c:	e51b3020 	ldr	r3, [fp, #-32]
   1e070:	e3530003 	cmp	r3, #3
   1e074:	9a000023 	bls	1e108 <strncpy+0xdc>
    {
      aligned_dst = (long*)dst;
   1e078:	e51b3008 	ldr	r3, [fp, #-8]
   1e07c:	e50b3010 	str	r3, [fp, #-16]
      aligned_src = (long*)src;
   1e080:	e51b300c 	ldr	r3, [fp, #-12]
   1e084:	e50b3014 	str	r3, [fp, #-20]

      /* SRC and DEST are both "long int" aligned, try to do "long int"
	 sized copies.  */
      while (count >= sizeof (long int) && !DETECTNULL(*aligned_src))
   1e088:	ea00000a 	b	1e0b8 <strncpy+0x8c>
	{
	  count -= sizeof (long int);
   1e08c:	e51b3020 	ldr	r3, [fp, #-32]
   1e090:	e2433004 	sub	r3, r3, #4
   1e094:	e50b3020 	str	r3, [fp, #-32]
	  *aligned_dst++ = *aligned_src++;
   1e098:	e51b3010 	ldr	r3, [fp, #-16]
   1e09c:	e2832004 	add	r2, r3, #4
   1e0a0:	e50b2010 	str	r2, [fp, #-16]
   1e0a4:	e51b2014 	ldr	r2, [fp, #-20]
   1e0a8:	e2821004 	add	r1, r2, #4
   1e0ac:	e50b1014 	str	r1, [fp, #-20]
   1e0b0:	e5922000 	ldr	r2, [r2]
   1e0b4:	e5832000 	str	r2, [r3]
      aligned_dst = (long*)dst;
      aligned_src = (long*)src;

      /* SRC and DEST are both "long int" aligned, try to do "long int"
	 sized copies.  */
      while (count >= sizeof (long int) && !DETECTNULL(*aligned_src))
   1e0b8:	e51b3020 	ldr	r3, [fp, #-32]
   1e0bc:	e3530003 	cmp	r3, #3
   1e0c0:	9a00000c 	bls	1e0f8 <strncpy+0xcc>
   1e0c4:	e51b3014 	ldr	r3, [fp, #-20]
   1e0c8:	e5932000 	ldr	r2, [r3]
   1e0cc:	e59f30c0 	ldr	r3, [pc, #192]	; 1e194 <strncpy+0x168>
   1e0d0:	e0823003 	add	r3, r2, r3
   1e0d4:	e51b2014 	ldr	r2, [fp, #-20]
   1e0d8:	e5922000 	ldr	r2, [r2]
   1e0dc:	e1e02002 	mvn	r2, r2
   1e0e0:	e0033002 	and	r3, r3, r2
   1e0e4:	e1a02003 	mov	r2, r3
   1e0e8:	e59f30a8 	ldr	r3, [pc, #168]	; 1e198 <strncpy+0x16c>
   1e0ec:	e0033002 	and	r3, r3, r2
   1e0f0:	e3530000 	cmp	r3, #0
   1e0f4:	0affffe4 	beq	1e08c <strncpy+0x60>
	{
	  count -= sizeof (long int);
	  *aligned_dst++ = *aligned_src++;
	}

      dst = (char*)aligned_dst;
   1e0f8:	e51b3010 	ldr	r3, [fp, #-16]
   1e0fc:	e50b3008 	str	r3, [fp, #-8]
      src = (char*)aligned_src;
   1e100:	e51b3014 	ldr	r3, [fp, #-20]
   1e104:	e50b300c 	str	r3, [fp, #-12]
    }

  while (count > 0)
   1e108:	ea00000e 	b	1e148 <strncpy+0x11c>
    {
      --count;
   1e10c:	e51b3020 	ldr	r3, [fp, #-32]
   1e110:	e2433001 	sub	r3, r3, #1
   1e114:	e50b3020 	str	r3, [fp, #-32]
      if ((*dst++ = *src++) == '\0')
   1e118:	e51b3008 	ldr	r3, [fp, #-8]
   1e11c:	e2832001 	add	r2, r3, #1
   1e120:	e50b2008 	str	r2, [fp, #-8]
   1e124:	e51b200c 	ldr	r2, [fp, #-12]
   1e128:	e2821001 	add	r1, r2, #1
   1e12c:	e50b100c 	str	r1, [fp, #-12]
   1e130:	e5d22000 	ldrb	r2, [r2]
   1e134:	e5c32000 	strb	r2, [r3]
   1e138:	e5d33000 	ldrb	r3, [r3]
   1e13c:	e3530000 	cmp	r3, #0
   1e140:	1a000000 	bne	1e148 <strncpy+0x11c>
	break;
   1e144:	ea000002 	b	1e154 <strncpy+0x128>

      dst = (char*)aligned_dst;
      src = (char*)aligned_src;
    }

  while (count > 0)
   1e148:	e51b3020 	ldr	r3, [fp, #-32]
   1e14c:	e3530000 	cmp	r3, #0
   1e150:	1affffed 	bne	1e10c <strncpy+0xe0>
      --count;
      if ((*dst++ = *src++) == '\0')
	break;
    }

  while (count-- > 0)
   1e154:	ea000004 	b	1e16c <strncpy+0x140>
    *dst++ = '\0';
   1e158:	e51b3008 	ldr	r3, [fp, #-8]
   1e15c:	e2832001 	add	r2, r3, #1
   1e160:	e50b2008 	str	r2, [fp, #-8]
   1e164:	e3a02000 	mov	r2, #0
   1e168:	e5c32000 	strb	r2, [r3]
      --count;
      if ((*dst++ = *src++) == '\0')
	break;
    }

  while (count-- > 0)
   1e16c:	e51b3020 	ldr	r3, [fp, #-32]
   1e170:	e2432001 	sub	r2, r3, #1
   1e174:	e50b2020 	str	r2, [fp, #-32]
   1e178:	e3530000 	cmp	r3, #0
   1e17c:	1afffff5 	bne	1e158 <strncpy+0x12c>
    *dst++ = '\0';

  return dst0;
   1e180:	e51b3018 	ldr	r3, [fp, #-24]
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   1e184:	e1a00003 	mov	r0, r3
   1e188:	e24bd000 	sub	sp, fp, #0
   1e18c:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   1e190:	e12fff1e 	bx	lr
   1e194:	fefefeff 	.word	0xfefefeff
   1e198:	80808080 	.word	0x80808080

0001e19c <__ssprint_r>:
int
_DEFUN(__ssprint_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       FILE *fp _AND
       register struct __suio *uio)
{
   1e19c:	e92d49f0 	push	{r4, r5, r6, r7, r8, fp, lr}
   1e1a0:	e28db018 	add	fp, sp, #24
   1e1a4:	e24dd01c 	sub	sp, sp, #28
   1e1a8:	e50b0030 	str	r0, [fp, #-48]	; 0x30
   1e1ac:	e50b1034 	str	r1, [fp, #-52]	; 0x34
   1e1b0:	e1a06002 	mov	r6, r2
	register size_t len;
	register int w;
	register struct __siov *iov;
	register _CONST char *p = NULL;
   1e1b4:	e3a07000 	mov	r7, #0

	iov = uio->uio_iov;
   1e1b8:	e5968000 	ldr	r8, [r6]
	len = 0;
   1e1bc:	e3a05000 	mov	r5, #0

	if (uio->uio_resid == 0) {
   1e1c0:	e5963008 	ldr	r3, [r6, #8]
   1e1c4:	e3530000 	cmp	r3, #0
   1e1c8:	1a000003 	bne	1e1dc <__ssprint_r+0x40>
		uio->uio_iovcnt = 0;
   1e1cc:	e3a03000 	mov	r3, #0
   1e1d0:	e5863004 	str	r3, [r6, #4]
		return (0);
   1e1d4:	e3a03000 	mov	r3, #0
   1e1d8:	ea0000a8 	b	1e480 <__ssprint_r+0x2e4>
	}

        do {
		while (len == 0) {
   1e1dc:	ea000002 	b	1e1ec <__ssprint_r+0x50>
			p = iov->iov_base;
   1e1e0:	e5987000 	ldr	r7, [r8]
			len = iov->iov_len;
   1e1e4:	e5985004 	ldr	r5, [r8, #4]
			iov++;
   1e1e8:	e2888008 	add	r8, r8, #8
		uio->uio_iovcnt = 0;
		return (0);
	}

        do {
		while (len == 0) {
   1e1ec:	e3550000 	cmp	r5, #0
   1e1f0:	0afffffa 	beq	1e1e0 <__ssprint_r+0x44>
			p = iov->iov_base;
			len = iov->iov_len;
			iov++;
		}
		w = fp->_w;
   1e1f4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e1f8:	e5934008 	ldr	r4, [r3, #8]
		if (len >= w && fp->_flags & (__SMBF | __SOPT)) {
   1e1fc:	e1a03004 	mov	r3, r4
   1e200:	e1530005 	cmp	r3, r5
   1e204:	8a00006a 	bhi	1e3b4 <__ssprint_r+0x218>
   1e208:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e20c:	e1d330bc 	ldrh	r3, [r3, #12]
   1e210:	e1a03803 	lsl	r3, r3, #16
   1e214:	e1a03823 	lsr	r3, r3, #16
   1e218:	e2033d12 	and	r3, r3, #1152	; 0x480
   1e21c:	e3530000 	cmp	r3, #0
   1e220:	0a000063 	beq	1e3b4 <__ssprint_r+0x218>
			/* must be asprintf family */
			unsigned char *str;
			int curpos = (fp->_p - fp->_bf._base);
   1e224:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e228:	e5933000 	ldr	r3, [r3]
   1e22c:	e1a02003 	mov	r2, r3
   1e230:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e234:	e5933010 	ldr	r3, [r3, #16]
   1e238:	e0633002 	rsb	r3, r3, r2
   1e23c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
			 * than (1+sqrt(5))/2 to accomodate malloc
		 	 * overhead. asprintf EXPECTS us to overallocate, so
		 	 * that it can add a trailing \0 without
		 	 * reallocating.  The new allocation should thus be
		 	 * max(prev_size*1.5, curpos+len+1). */
			int newsize = fp->_bf._size * 3 / 2;
   1e240:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e244:	e5932014 	ldr	r2, [r3, #20]
   1e248:	e1a03002 	mov	r3, r2
   1e24c:	e1a03083 	lsl	r3, r3, #1
   1e250:	e0833002 	add	r3, r3, r2
   1e254:	e1a02fa3 	lsr	r2, r3, #31
   1e258:	e0823003 	add	r3, r2, r3
   1e25c:	e1a030c3 	asr	r3, r3, #1
   1e260:	e50b3024 	str	r3, [fp, #-36]	; 0x24
			if (newsize < curpos + len + 1)
   1e264:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1e268:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1e26c:	e0833005 	add	r3, r3, r5
   1e270:	e2833001 	add	r3, r3, #1
   1e274:	e1520003 	cmp	r2, r3
   1e278:	2a000003 	bcs	1e28c <__ssprint_r+0xf0>
				newsize = curpos + len + 1;
   1e27c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1e280:	e0833005 	add	r3, r3, r5
   1e284:	e2833001 	add	r3, r3, #1
   1e288:	e50b3024 	str	r3, [fp, #-36]	; 0x24
			if (fp->_flags & __SOPT)
   1e28c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e290:	e1d330bc 	ldrh	r3, [r3, #12]
   1e294:	e1a03803 	lsl	r3, r3, #16
   1e298:	e1a03823 	lsr	r3, r3, #16
   1e29c:	e2033b01 	and	r3, r3, #1024	; 0x400
   1e2a0:	e3530000 	cmp	r3, #0
   1e2a4:	0a00001d 	beq	1e320 <__ssprint_r+0x184>
			{
				/* asnprintf leaves original buffer alone.  */
				str = (unsigned char *)_malloc_r (ptr, newsize);
   1e2a8:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1e2ac:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   1e2b0:	e1a01003 	mov	r1, r3
   1e2b4:	ebffc35e 	bl	f034 <_malloc_r>
   1e2b8:	e50b0020 	str	r0, [fp, #-32]
				if (!str)
   1e2bc:	e51b3020 	ldr	r3, [fp, #-32]
   1e2c0:	e3530000 	cmp	r3, #0
   1e2c4:	1a000003 	bne	1e2d8 <__ssprint_r+0x13c>
				{
					ptr->_errno = ENOMEM;
   1e2c8:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1e2cc:	e3a0200c 	mov	r2, #12
   1e2d0:	e5832000 	str	r2, [r3]
					goto err;
   1e2d4:	ea00005d 	b	1e450 <__ssprint_r+0x2b4>
				}
				memcpy (str, fp->_bf._base, curpos);
   1e2d8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e2dc:	e5932010 	ldr	r2, [r3, #16]
   1e2e0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1e2e4:	e51b0020 	ldr	r0, [fp, #-32]
   1e2e8:	e1a01002 	mov	r1, r2
   1e2ec:	e1a02003 	mov	r2, r3
   1e2f0:	ebffc616 	bl	fb50 <memcpy>
				fp->_flags = (fp->_flags & ~__SOPT) | __SMBF;
   1e2f4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e2f8:	e1d330bc 	ldrh	r3, [r3, #12]
   1e2fc:	e3c33d12 	bic	r3, r3, #1152	; 0x480
   1e300:	e1a03803 	lsl	r3, r3, #16
   1e304:	e1a03823 	lsr	r3, r3, #16
   1e308:	e3833080 	orr	r3, r3, #128	; 0x80
   1e30c:	e1a03803 	lsl	r3, r3, #16
   1e310:	e1a02823 	lsr	r2, r3, #16
   1e314:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e318:	e1c320bc 	strh	r2, [r3, #12]
   1e31c:	ea000013 	b	1e370 <__ssprint_r+0x1d4>
			}
			else
			{
				str = (unsigned char *)_realloc_r (ptr, fp->_bf._base,
   1e320:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e324:	e5932010 	ldr	r2, [r3, #16]
   1e328:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1e32c:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   1e330:	e1a01002 	mov	r1, r2
   1e334:	e1a02003 	mov	r2, r3
   1e338:	ebfff9c8 	bl	1ca60 <_realloc_r>
   1e33c:	e50b0020 	str	r0, [fp, #-32]
						newsize);
				if (!str) {
   1e340:	e51b3020 	ldr	r3, [fp, #-32]
   1e344:	e3530000 	cmp	r3, #0
   1e348:	1a000008 	bne	1e370 <__ssprint_r+0x1d4>
					/* Free unneeded buffer.  */
					_free_r (ptr, fp->_bf._base);
   1e34c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e350:	e5933010 	ldr	r3, [r3, #16]
   1e354:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
   1e358:	e1a01003 	mov	r1, r3
   1e35c:	ebffed4e 	bl	1989c <_free_r>
					/* Ensure correct errno, even if free
					 * changed it.  */
					ptr->_errno = ENOMEM;
   1e360:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1e364:	e3a0200c 	mov	r2, #12
   1e368:	e5832000 	str	r2, [r3]
					goto err;
   1e36c:	ea000037 	b	1e450 <__ssprint_r+0x2b4>
				}
			}
			fp->_bf._base = str;
   1e370:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e374:	e51b2020 	ldr	r2, [fp, #-32]
   1e378:	e5832010 	str	r2, [r3, #16]
			fp->_p = str + curpos;
   1e37c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1e380:	e51b2020 	ldr	r2, [fp, #-32]
   1e384:	e0822003 	add	r2, r2, r3
   1e388:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e38c:	e5832000 	str	r2, [r3]
			fp->_bf._size = newsize;
   1e390:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e394:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1e398:	e5832014 	str	r2, [r3, #20]
			w = len;
   1e39c:	e1a04005 	mov	r4, r5
			fp->_w = newsize - curpos;
   1e3a0:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1e3a4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1e3a8:	e0632002 	rsb	r2, r3, r2
   1e3ac:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e3b0:	e5832008 	str	r2, [r3, #8]
		}
		if (len < w)
   1e3b4:	e1a03004 	mov	r3, r4
   1e3b8:	e1530005 	cmp	r3, r5
   1e3bc:	9a000000 	bls	1e3c4 <__ssprint_r+0x228>
			w = len;
   1e3c0:	e1a04005 	mov	r4, r5
		(void)memmove ((_PTR) fp->_p, (_PTR) p, (size_t) (w));
   1e3c4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e3c8:	e5932000 	ldr	r2, [r3]
   1e3cc:	e1a03004 	mov	r3, r4
   1e3d0:	e1a00002 	mov	r0, r2
   1e3d4:	e1a01007 	mov	r1, r7
   1e3d8:	e1a02003 	mov	r2, r3
   1e3dc:	ebfff26e 	bl	1ad9c <memmove>
		fp->_w -= w;
   1e3e0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e3e4:	e5933008 	ldr	r3, [r3, #8]
   1e3e8:	e0642003 	rsb	r2, r4, r3
   1e3ec:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e3f0:	e5832008 	str	r2, [r3, #8]
		fp->_p += w;
   1e3f4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e3f8:	e5932000 	ldr	r2, [r3]
   1e3fc:	e1a03004 	mov	r3, r4
   1e400:	e0822003 	add	r2, r2, r3
   1e404:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e408:	e5832000 	str	r2, [r3]
		w = len;          /* pretend we copied all */
   1e40c:	e1a04005 	mov	r4, r5
		p += w;
   1e410:	e1a03004 	mov	r3, r4
   1e414:	e0877003 	add	r7, r7, r3
		len -= w;
   1e418:	e1a03004 	mov	r3, r4
   1e41c:	e0635005 	rsb	r5, r3, r5
        } while ((uio->uio_resid -= w) != 0);
   1e420:	e5963008 	ldr	r3, [r6, #8]
   1e424:	e0643003 	rsb	r3, r4, r3
   1e428:	e5863008 	str	r3, [r6, #8]
   1e42c:	e5963008 	ldr	r3, [r6, #8]
   1e430:	e3530000 	cmp	r3, #0
   1e434:	1affff68 	bne	1e1dc <__ssprint_r+0x40>

	uio->uio_resid = 0;
   1e438:	e3a03000 	mov	r3, #0
   1e43c:	e5863008 	str	r3, [r6, #8]
	uio->uio_iovcnt = 0;
   1e440:	e3a03000 	mov	r3, #0
   1e444:	e5863004 	str	r3, [r6, #4]
	return 0;
   1e448:	e3a03000 	mov	r3, #0
   1e44c:	ea00000b 	b	1e480 <__ssprint_r+0x2e4>

err:
  fp->_flags |= __SERR;
   1e450:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e454:	e1d330bc 	ldrh	r3, [r3, #12]
   1e458:	e3833040 	orr	r3, r3, #64	; 0x40
   1e45c:	e1a03803 	lsl	r3, r3, #16
   1e460:	e1a02823 	lsr	r2, r3, #16
   1e464:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e468:	e1c320bc 	strh	r2, [r3, #12]
  uio->uio_resid = 0;
   1e46c:	e3a03000 	mov	r3, #0
   1e470:	e5863008 	str	r3, [r6, #8]
  uio->uio_iovcnt = 0;
   1e474:	e3a03000 	mov	r3, #0
   1e478:	e5863004 	str	r3, [r6, #4]
  return EOF;
   1e47c:	e3e03000 	mvn	r3, #0
}
   1e480:	e1a00003 	mov	r0, r3
   1e484:	e24bd018 	sub	sp, fp, #24
   1e488:	e8bd49f0 	pop	{r4, r5, r6, r7, r8, fp, lr}
   1e48c:	e12fff1e 	bx	lr

0001e490 <_svfiprintf_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
   1e490:	e92d4bf0 	push	{r4, r5, r6, r7, r8, r9, fp, lr}
   1e494:	e28db01c 	add	fp, sp, #28
   1e498:	e24dde12 	sub	sp, sp, #288	; 0x120
   1e49c:	e50b0120 	str	r0, [fp, #-288]	; 0x120
   1e4a0:	e50b1124 	str	r1, [fp, #-292]	; 0x124
   1e4a4:	e50b2128 	str	r2, [fp, #-296]	; 0x128
   1e4a8:	e50b312c 	str	r3, [fp, #-300]	; 0x12c
	int width;		/* width from format (%8d), or 0 */
	int prec;		/* precision from format (%.3d), or -1 */
	char sign;		/* sign prefix (' ', '+', '-', or \0) */
#ifdef _WANT_IO_C99_FORMATS
				/* locale specific numeric grouping */
	char *thousands_sep = NULL;
   1e4ac:	e3a03000 	mov	r3, #0
   1e4b0:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	size_t thsnd_len = 0;
   1e4b4:	e3a03000 	mov	r3, #0
   1e4b8:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	const char *grouping = NULL;
   1e4bc:	e3a03000 	mov	r3, #0
   1e4c0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	int expsize = 0;	/* character count for expstr */
	char expstr[MAXEXPLEN];	/* buffer for exponent string */
	int lead;		/* sig figs before decimal or group sep */
#endif /* FLOATING_POINT */
#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
	int ndig = 0;		/* actual number of digits returned by cvt */
   1e4c4:	e3a03000 	mov	r3, #0
   1e4c8:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
   1e4cc:	e3a03000 	mov	r3, #0
   1e4d0:	e50b3058 	str	r3, [fp, #-88]	; 0x58
	char ox[2];		/* space for 0x hex-prefix */
#ifdef _MB_CAPABLE
	wchar_t wc;
	mbstate_t state;        /* mbtowc calls from library must not change state */
#endif
	char *malloc_buf = NULL;/* handy pointer for malloced buffers */
   1e4d4:	e3a03000 	mov	r3, #0
   1e4d8:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
		return (__sbprintf (data, fp, fmt0, ap));
	}
#endif
#else /* STRING_ONLY */
        /* Create initial buffer if we are called by asprintf family.  */
        if (fp->_flags & __SMBF && !fp->_bf._base)
   1e4dc:	e51b3124 	ldr	r3, [fp, #-292]	; 0x124
   1e4e0:	e1d330bc 	ldrh	r3, [r3, #12]
   1e4e4:	e1a03803 	lsl	r3, r3, #16
   1e4e8:	e1a03823 	lsr	r3, r3, #16
   1e4ec:	e2033080 	and	r3, r3, #128	; 0x80
   1e4f0:	e3530000 	cmp	r3, #0
   1e4f4:	0a000019 	beq	1e560 <_svfiprintf_r+0xd0>
   1e4f8:	e51b3124 	ldr	r3, [fp, #-292]	; 0x124
   1e4fc:	e5933010 	ldr	r3, [r3, #16]
   1e500:	e3530000 	cmp	r3, #0
   1e504:	1a000015 	bne	1e560 <_svfiprintf_r+0xd0>
        {
		fp->_bf._base = fp->_p = _malloc_r (data, 64);
   1e508:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1e50c:	e3a01040 	mov	r1, #64	; 0x40
   1e510:	ebffc2c7 	bl	f034 <_malloc_r>
   1e514:	e1a02000 	mov	r2, r0
   1e518:	e51b3124 	ldr	r3, [fp, #-292]	; 0x124
   1e51c:	e5832000 	str	r2, [r3]
   1e520:	e51b3124 	ldr	r3, [fp, #-292]	; 0x124
   1e524:	e5932000 	ldr	r2, [r3]
   1e528:	e51b3124 	ldr	r3, [fp, #-292]	; 0x124
   1e52c:	e5832010 	str	r2, [r3, #16]
		if (!fp->_p)
   1e530:	e51b3124 	ldr	r3, [fp, #-292]	; 0x124
   1e534:	e5933000 	ldr	r3, [r3]
   1e538:	e3530000 	cmp	r3, #0
   1e53c:	1a000004 	bne	1e554 <_svfiprintf_r+0xc4>
		{
			data->_errno = ENOMEM;
   1e540:	e51b3120 	ldr	r3, [fp, #-288]	; 0x120
   1e544:	e3a0200c 	mov	r2, #12
   1e548:	e5832000 	str	r2, [r3]
			return EOF;
   1e54c:	e3e03000 	mvn	r3, #0
   1e550:	ea0004fb 	b	1f944 <_svfiprintf_r+0x14b4>
		}
		fp->_bf._size = 64;
   1e554:	e51b3124 	ldr	r3, [fp, #-292]	; 0x124
   1e558:	e3a02040 	mov	r2, #64	; 0x40
   1e55c:	e5832014 	str	r2, [r3, #20]
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
   1e560:	e51b8128 	ldr	r8, [fp, #-296]	; 0x128
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   1e564:	e24b50b4 	sub	r5, fp, #180	; 0xb4
   1e568:	e50b5074 	str	r5, [fp, #-116]	; 0x74
	uio.uio_resid = 0;
   1e56c:	e3a03000 	mov	r3, #0
   1e570:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
	uio.uio_iovcnt = 0;
   1e574:	e3a03000 	mov	r3, #0
   1e578:	e50b3070 	str	r3, [fp, #-112]	; 0x70
#endif
	ret = 0;
   1e57c:	e3a03000 	mov	r3, #0
   1e580:	e50b3020 	str	r3, [fp, #-32]

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
	        cp = fmt;
   1e584:	e1a06008 	mov	r6, r8
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   1e588:	ea000000 	b	1e590 <_svfiprintf_r+0x100>
                    fmt += 1;
   1e58c:	e2888001 	add	r8, r8, #1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   1e590:	e5d83000 	ldrb	r3, [r8]
   1e594:	e3530000 	cmp	r3, #0
   1e598:	0a000002 	beq	1e5a8 <_svfiprintf_r+0x118>
   1e59c:	e5d83000 	ldrb	r3, [r8]
   1e5a0:	e3530025 	cmp	r3, #37	; 0x25
   1e5a4:	1afffff8 	bne	1e58c <_svfiprintf_r+0xfc>
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
   1e5a8:	e1a02008 	mov	r2, r8
   1e5ac:	e1a03006 	mov	r3, r6
   1e5b0:	e0634002 	rsb	r4, r3, r2
   1e5b4:	e3540000 	cmp	r4, #0
   1e5b8:	0a000019 	beq	1e624 <_svfiprintf_r+0x194>
			PRINT (cp, m);
   1e5bc:	e5856000 	str	r6, [r5]
   1e5c0:	e1a03004 	mov	r3, r4
   1e5c4:	e5853004 	str	r3, [r5, #4]
   1e5c8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1e5cc:	e0833004 	add	r3, r3, r4
   1e5d0:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1e5d4:	e2855008 	add	r5, r5, #8
   1e5d8:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1e5dc:	e2833001 	add	r3, r3, #1
   1e5e0:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1e5e4:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1e5e8:	e3530007 	cmp	r3, #7
   1e5ec:	da000009 	ble	1e618 <_svfiprintf_r+0x188>
   1e5f0:	e24b3074 	sub	r3, fp, #116	; 0x74
   1e5f4:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1e5f8:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   1e5fc:	e1a02003 	mov	r2, r3
   1e600:	ebfffee5 	bl	1e19c <__ssprint_r>
   1e604:	e1a03000 	mov	r3, r0
   1e608:	e3530000 	cmp	r3, #0
   1e60c:	0a000000 	beq	1e614 <_svfiprintf_r+0x184>
   1e610:	ea0004ba 	b	1f900 <_svfiprintf_r+0x1470>
   1e614:	e24b50b4 	sub	r5, fp, #180	; 0xb4
			ret += m;
   1e618:	e51b3020 	ldr	r3, [fp, #-32]
   1e61c:	e0833004 	add	r3, r3, r4
   1e620:	e50b3020 	str	r3, [fp, #-32]
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   1e624:	e5d83000 	ldrb	r3, [r8]
   1e628:	e3530000 	cmp	r3, #0
   1e62c:	1a000000 	bne	1e634 <_svfiprintf_r+0x1a4>
                    goto done;
   1e630:	ea0004a3 	b	1f8c4 <_svfiprintf_r+0x1434>
#endif
		fmt_anchor = fmt;
   1e634:	e50b8060 	str	r8, [fp, #-96]	; 0x60
		fmt++;		/* skip over '%' */
   1e638:	e2888001 	add	r8, r8, #1

		flags = 0;
   1e63c:	e3a04000 	mov	r4, #0
		dprec = 0;
   1e640:	e3a03000 	mov	r3, #0
   1e644:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
		width = 0;
   1e648:	e3a03000 	mov	r3, #0
   1e64c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		prec = -1;
   1e650:	e3e03000 	mvn	r3, #0
   1e654:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		sign = '\0';
   1e658:	e3a03000 	mov	r3, #0
   1e65c:	e54b3065 	strb	r3, [fp, #-101]	; 0x65
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   1e660:	e1a03008 	mov	r3, r8
   1e664:	e2838001 	add	r8, r3, #1
   1e668:	e5d33000 	ldrb	r3, [r3]
   1e66c:	e1a09003 	mov	r9, r3
reswitch:	switch (ch) {
   1e670:	e2493020 	sub	r3, r9, #32
   1e674:	e353005a 	cmp	r3, #90	; 0x5a
   1e678:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   1e67c:	ea000318 	b	1f2e4 <_svfiprintf_r+0xe54>
   1e680:	0001e850 	.word	0x0001e850
   1e684:	0001f2e4 	.word	0x0001f2e4
   1e688:	0001f2e4 	.word	0x0001f2e4
   1e68c:	0001e868 	.word	0x0001e868
   1e690:	0001f2e4 	.word	0x0001f2e4
   1e694:	0001f2e4 	.word	0x0001f2e4
   1e698:	0001f2e4 	.word	0x0001f2e4
   1e69c:	0001e7ec 	.word	0x0001e7ec
   1e6a0:	0001f2e4 	.word	0x0001f2e4
   1e6a4:	0001f2e4 	.word	0x0001f2e4
   1e6a8:	0001e870 	.word	0x0001e870
   1e6ac:	0001e8a8 	.word	0x0001e8a8
   1e6b0:	0001f2e4 	.word	0x0001f2e4
   1e6b4:	0001e8a0 	.word	0x0001e8a0
   1e6b8:	0001e8b4 	.word	0x0001e8b4
   1e6bc:	0001f2e4 	.word	0x0001f2e4
   1e6c0:	0001e950 	.word	0x0001e950
   1e6c4:	0001e958 	.word	0x0001e958
   1e6c8:	0001e958 	.word	0x0001e958
   1e6cc:	0001e958 	.word	0x0001e958
   1e6d0:	0001e958 	.word	0x0001e958
   1e6d4:	0001e958 	.word	0x0001e958
   1e6d8:	0001e958 	.word	0x0001e958
   1e6dc:	0001e958 	.word	0x0001e958
   1e6e0:	0001e958 	.word	0x0001e958
   1e6e4:	0001e958 	.word	0x0001e958
   1e6e8:	0001f2e4 	.word	0x0001f2e4
   1e6ec:	0001f2e4 	.word	0x0001f2e4
   1e6f0:	0001f2e4 	.word	0x0001f2e4
   1e6f4:	0001f2e4 	.word	0x0001f2e4
   1e6f8:	0001f2e4 	.word	0x0001f2e4
   1e6fc:	0001f2e4 	.word	0x0001f2e4
   1e700:	0001f2e4 	.word	0x0001f2e4
   1e704:	0001f2e4 	.word	0x0001f2e4
   1e708:	0001f2e4 	.word	0x0001f2e4
   1e70c:	0001e9ec 	.word	0x0001e9ec
   1e710:	0001ea1c 	.word	0x0001ea1c
   1e714:	0001f2e4 	.word	0x0001f2e4
   1e718:	0001f2e4 	.word	0x0001f2e4
   1e71c:	0001f2e4 	.word	0x0001f2e4
   1e720:	0001f2e4 	.word	0x0001f2e4
   1e724:	0001f2e4 	.word	0x0001f2e4
   1e728:	0001f2e4 	.word	0x0001f2e4
   1e72c:	0001f2e4 	.word	0x0001f2e4
   1e730:	0001f2e4 	.word	0x0001f2e4
   1e734:	0001f2e4 	.word	0x0001f2e4
   1e738:	0001f2e4 	.word	0x0001f2e4
   1e73c:	0001ec0c 	.word	0x0001ec0c
   1e740:	0001f2e4 	.word	0x0001f2e4
   1e744:	0001f2e4 	.word	0x0001f2e4
   1e748:	0001f2e4 	.word	0x0001f2e4
   1e74c:	0001ed3c 	.word	0x0001ed3c
   1e750:	0001f2e4 	.word	0x0001f2e4
   1e754:	0001edfc 	.word	0x0001edfc
   1e758:	0001f2e4 	.word	0x0001f2e4
   1e75c:	0001f2e4 	.word	0x0001f2e4
   1e760:	0001eedc 	.word	0x0001eedc
   1e764:	0001f2e4 	.word	0x0001f2e4
   1e768:	0001f2e4 	.word	0x0001f2e4
   1e76c:	0001f2e4 	.word	0x0001f2e4
   1e770:	0001f2e4 	.word	0x0001f2e4
   1e774:	0001f2e4 	.word	0x0001f2e4
   1e778:	0001f2e4 	.word	0x0001f2e4
   1e77c:	0001f2e4 	.word	0x0001f2e4
   1e780:	0001f2e4 	.word	0x0001f2e4
   1e784:	0001f2e4 	.word	0x0001f2e4
   1e788:	0001f2e4 	.word	0x0001f2e4
   1e78c:	0001e9ec 	.word	0x0001e9ec
   1e790:	0001ea20 	.word	0x0001ea20
   1e794:	0001f2e4 	.word	0x0001f2e4
   1e798:	0001f2e4 	.word	0x0001f2e4
   1e79c:	0001f2e4 	.word	0x0001f2e4
   1e7a0:	0001e99c 	.word	0x0001e99c
   1e7a4:	0001ea20 	.word	0x0001ea20
   1e7a8:	0001e9e4 	.word	0x0001e9e4
   1e7ac:	0001f2e4 	.word	0x0001f2e4
   1e7b0:	0001e9bc 	.word	0x0001e9bc
   1e7b4:	0001f2e4 	.word	0x0001f2e4
   1e7b8:	0001eb3c 	.word	0x0001eb3c
   1e7bc:	0001ec10 	.word	0x0001ec10
   1e7c0:	0001ecf0 	.word	0x0001ecf0
   1e7c4:	0001e9dc 	.word	0x0001e9dc
   1e7c8:	0001f2e4 	.word	0x0001f2e4
   1e7cc:	0001ed3c 	.word	0x0001ed3c
   1e7d0:	0001e660 	.word	0x0001e660
   1e7d4:	0001ee00 	.word	0x0001ee00
   1e7d8:	0001f2e4 	.word	0x0001f2e4
   1e7dc:	0001f2e4 	.word	0x0001f2e4
   1e7e0:	0001eee8 	.word	0x0001eee8
   1e7e4:	0001f2e4 	.word	0x0001f2e4
   1e7e8:	0001e660 	.word	0x0001e660
#ifdef _WANT_IO_C99_FORMATS
		case '\'':
			thousands_sep = _localeconv_r (data)->thousands_sep;
   1e7ec:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1e7f0:	ebfff047 	bl	1a914 <_localeconv_r>
   1e7f4:	e1a03000 	mov	r3, r0
   1e7f8:	e5933004 	ldr	r3, [r3, #4]
   1e7fc:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
			thsnd_len = strlen (thousands_sep);
   1e800:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
   1e804:	ebffc878 	bl	109ec <strlen>
   1e808:	e50b0030 	str	r0, [fp, #-48]	; 0x30
			grouping = _localeconv_r (data)->grouping;
   1e80c:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1e810:	ebfff03f 	bl	1a914 <_localeconv_r>
   1e814:	e1a03000 	mov	r3, r0
   1e818:	e5933008 	ldr	r3, [r3, #8]
   1e81c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
			if (thsnd_len > 0 && grouping && *grouping)
   1e820:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1e824:	e3530000 	cmp	r3, #0
   1e828:	0a000007 	beq	1e84c <_svfiprintf_r+0x3bc>
   1e82c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e830:	e3530000 	cmp	r3, #0
   1e834:	0a000004 	beq	1e84c <_svfiprintf_r+0x3bc>
   1e838:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1e83c:	e5d33000 	ldrb	r3, [r3]
   1e840:	e3530000 	cmp	r3, #0
   1e844:	0a000000 	beq	1e84c <_svfiprintf_r+0x3bc>
			  flags |= GROUPING;
   1e848:	e3844b01 	orr	r4, r4, #1024	; 0x400
			goto rflag;
   1e84c:	eaffff83 	b	1e660 <_svfiprintf_r+0x1d0>
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
   1e850:	e55b3065 	ldrb	r3, [fp, #-101]	; 0x65
   1e854:	e3530000 	cmp	r3, #0
   1e858:	1a000001 	bne	1e864 <_svfiprintf_r+0x3d4>
				sign = ' ';
   1e85c:	e3a03020 	mov	r3, #32
   1e860:	e54b3065 	strb	r3, [fp, #-101]	; 0x65
			goto rflag;
   1e864:	eaffff7d 	b	1e660 <_svfiprintf_r+0x1d0>
		case '#':
			flags |= ALT;
   1e868:	e3844001 	orr	r4, r4, #1
			goto rflag;
   1e86c:	eaffff7b 	b	1e660 <_svfiprintf_r+0x1d0>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   1e870:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1e874:	e2832004 	add	r2, r3, #4
   1e878:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1e87c:	e5933000 	ldr	r3, [r3]
   1e880:	e50b3024 	str	r3, [fp, #-36]	; 0x24
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
   1e884:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1e888:	e3530000 	cmp	r3, #0
   1e88c:	ba000000 	blt	1e894 <_svfiprintf_r+0x404>
				goto rflag;
   1e890:	eaffff72 	b	1e660 <_svfiprintf_r+0x1d0>
			width = -width;
   1e894:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1e898:	e2633000 	rsb	r3, r3, #0
   1e89c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
   1e8a0:	e3844004 	orr	r4, r4, #4
			goto rflag;
   1e8a4:	eaffff6d 	b	1e660 <_svfiprintf_r+0x1d0>
		case '+':
			sign = '+';
   1e8a8:	e3a0302b 	mov	r3, #43	; 0x2b
   1e8ac:	e54b3065 	strb	r3, [fp, #-101]	; 0x65
			goto rflag;
   1e8b0:	eaffff6a 	b	1e660 <_svfiprintf_r+0x1d0>
		case '.':
			if ((ch = *fmt++) == '*') {
   1e8b4:	e1a03008 	mov	r3, r8
   1e8b8:	e2838001 	add	r8, r3, #1
   1e8bc:	e5d33000 	ldrb	r3, [r3]
   1e8c0:	e1a09003 	mov	r9, r3
   1e8c4:	e359002a 	cmp	r9, #42	; 0x2a
   1e8c8:	1a00000a 	bne	1e8f8 <_svfiprintf_r+0x468>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   1e8cc:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1e8d0:	e2832004 	add	r2, r3, #4
   1e8d4:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1e8d8:	e5933000 	ldr	r3, [r3]
   1e8dc:	e50b3028 	str	r3, [fp, #-40]	; 0x28
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   1e8e0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1e8e4:	e3530000 	cmp	r3, #0
   1e8e8:	aa000001 	bge	1e8f4 <_svfiprintf_r+0x464>
					prec = -1;
   1e8ec:	e3e03000 	mvn	r3, #0
   1e8f0:	e50b3028 	str	r3, [fp, #-40]	; 0x28
				goto rflag;
   1e8f4:	eaffff59 	b	1e660 <_svfiprintf_r+0x1d0>
			}
			n = 0;
   1e8f8:	e3a07000 	mov	r7, #0
			while (is_digit (ch)) {
   1e8fc:	ea00000a 	b	1e92c <_svfiprintf_r+0x49c>
				n = 10 * n + to_digit (ch);
   1e900:	e1a03007 	mov	r3, r7
   1e904:	e1a03103 	lsl	r3, r3, #2
   1e908:	e0833007 	add	r3, r3, r7
   1e90c:	e1a03083 	lsl	r3, r3, #1
   1e910:	e1a02003 	mov	r2, r3
   1e914:	e2493030 	sub	r3, r9, #48	; 0x30
   1e918:	e0827003 	add	r7, r2, r3
				ch = *fmt++;
   1e91c:	e1a03008 	mov	r3, r8
   1e920:	e2838001 	add	r8, r3, #1
   1e924:	e5d33000 	ldrb	r3, [r3]
   1e928:	e1a09003 	mov	r9, r3
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   1e92c:	e2493030 	sub	r3, r9, #48	; 0x30
   1e930:	e3530009 	cmp	r3, #9
   1e934:	9afffff1 	bls	1e900 <_svfiprintf_r+0x470>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
   1e938:	e3e03000 	mvn	r3, #0
   1e93c:	e1570003 	cmp	r7, r3
   1e940:	a1a03007 	movge	r3, r7
   1e944:	b1a03003 	movlt	r3, r3
   1e948:	e50b3028 	str	r3, [fp, #-40]	; 0x28
			goto reswitch;
   1e94c:	eaffff47 	b	1e670 <_svfiprintf_r+0x1e0>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
   1e950:	e3844080 	orr	r4, r4, #128	; 0x80
			goto rflag;
   1e954:	eaffff41 	b	1e660 <_svfiprintf_r+0x1d0>
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
   1e958:	e3a07000 	mov	r7, #0
			do {
				n = 10 * n + to_digit (ch);
   1e95c:	e1a03007 	mov	r3, r7
   1e960:	e1a03103 	lsl	r3, r3, #2
   1e964:	e0833007 	add	r3, r3, r7
   1e968:	e1a03083 	lsl	r3, r3, #1
   1e96c:	e1a02003 	mov	r2, r3
   1e970:	e2493030 	sub	r3, r9, #48	; 0x30
   1e974:	e0827003 	add	r7, r2, r3
				ch = *fmt++;
   1e978:	e1a03008 	mov	r3, r8
   1e97c:	e2838001 	add	r8, r3, #1
   1e980:	e5d33000 	ldrb	r3, [r3]
   1e984:	e1a09003 	mov	r9, r3
			} while (is_digit (ch));
   1e988:	e2493030 	sub	r3, r9, #48	; 0x30
   1e98c:	e3530009 	cmp	r3, #9
   1e990:	9afffff1 	bls	1e95c <_svfiprintf_r+0x4cc>
				}
				else
					goto error;
			}
#endif /* !_NO_POS_ARGS */
			width = n;
   1e994:	e50b7024 	str	r7, [fp, #-36]	; 0x24
			goto reswitch;
   1e998:	eaffff34 	b	1e670 <_svfiprintf_r+0x1e0>
			flags |= LONGDBL;
			goto rflag;
#endif
		case 'h':
#ifdef _WANT_IO_C99_FORMATS
			if (*fmt == 'h') {
   1e99c:	e5d83000 	ldrb	r3, [r8]
   1e9a0:	e3530068 	cmp	r3, #104	; 0x68
   1e9a4:	1a000002 	bne	1e9b4 <_svfiprintf_r+0x524>
				fmt++;
   1e9a8:	e2888001 	add	r8, r8, #1
				flags |= CHARINT;
   1e9ac:	e3844c02 	orr	r4, r4, #512	; 0x200
   1e9b0:	ea000000 	b	1e9b8 <_svfiprintf_r+0x528>
			} else
#endif
				flags |= SHORTINT;
   1e9b4:	e3844040 	orr	r4, r4, #64	; 0x40
			goto rflag;
   1e9b8:	eaffff28 	b	1e660 <_svfiprintf_r+0x1d0>
		case 'l':
#if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
			if (*fmt == 'l') {
   1e9bc:	e5d83000 	ldrb	r3, [r8]
   1e9c0:	e353006c 	cmp	r3, #108	; 0x6c
   1e9c4:	1a000002 	bne	1e9d4 <_svfiprintf_r+0x544>
				fmt++;
   1e9c8:	e2888001 	add	r8, r8, #1
				flags |= QUADINT;
   1e9cc:	e3844020 	orr	r4, r4, #32
   1e9d0:	ea000000 	b	1e9d8 <_svfiprintf_r+0x548>
			} else
#endif
				flags |= LONGINT;
   1e9d4:	e3844010 	orr	r4, r4, #16
			goto rflag;
   1e9d8:	eaffff20 	b	1e660 <_svfiprintf_r+0x1d0>
		case 'q': /* extension */
			flags |= QUADINT;
   1e9dc:	e3844020 	orr	r4, r4, #32
			goto rflag;
   1e9e0:	eaffff1e 	b	1e660 <_svfiprintf_r+0x1d0>
#ifdef _WANT_IO_C99_FORMATS
		case 'j':
		  if (sizeof (intmax_t) == sizeof (long))
		    flags |= LONGINT;
		  else
		    flags |= QUADINT;
   1e9e4:	e3844020 	orr	r4, r4, #32
		  goto rflag;
   1e9e8:	eaffff1c 	b	1e660 <_svfiprintf_r+0x1d0>
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
   1e9ec:	e24b6f46 	sub	r6, fp, #280	; 0x118
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   1e9f0:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1e9f4:	e2832004 	add	r2, r3, #4
   1e9f8:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1e9fc:	e5933000 	ldr	r3, [r3]
   1ea00:	e20330ff 	and	r3, r3, #255	; 0xff
   1ea04:	e5c63000 	strb	r3, [r6]
				size = 1;
   1ea08:	e3a03001 	mov	r3, #1
   1ea0c:	e50b3054 	str	r3, [fp, #-84]	; 0x54
			}
			sign = '\0';
   1ea10:	e3a03000 	mov	r3, #0
   1ea14:	e54b3065 	strb	r3, [fp, #-101]	; 0x65
			break;
   1ea18:	ea00023c 	b	1f310 <_svfiprintf_r+0xe80>
		case 'D':  /* extension */
			flags |= LONGINT;
   1ea1c:	e3844010 	orr	r4, r4, #16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   1ea20:	e2043020 	and	r3, r4, #32
   1ea24:	e3530000 	cmp	r3, #0
   1ea28:	0a000006 	beq	1ea48 <_svfiprintf_r+0x5b8>
   1ea2c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ea30:	e2833007 	add	r3, r3, #7
   1ea34:	e3c33007 	bic	r3, r3, #7
   1ea38:	e2832008 	add	r2, r3, #8
   1ea3c:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ea40:	e893000c 	ldm	r3, {r2, r3}
   1ea44:	ea00002a 	b	1eaf4 <_svfiprintf_r+0x664>
   1ea48:	e2043010 	and	r3, r4, #16
   1ea4c:	e3530000 	cmp	r3, #0
   1ea50:	0a000006 	beq	1ea70 <_svfiprintf_r+0x5e0>
   1ea54:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ea58:	e2832004 	add	r2, r3, #4
   1ea5c:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ea60:	e5933000 	ldr	r3, [r3]
   1ea64:	e1a02003 	mov	r2, r3
   1ea68:	e1a03fc2 	asr	r3, r2, #31
   1ea6c:	ea000020 	b	1eaf4 <_svfiprintf_r+0x664>
   1ea70:	e2043040 	and	r3, r4, #64	; 0x40
   1ea74:	e3530000 	cmp	r3, #0
   1ea78:	0a00000a 	beq	1eaa8 <_svfiprintf_r+0x618>
   1ea7c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ea80:	e2832004 	add	r2, r3, #4
   1ea84:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ea88:	e5933000 	ldr	r3, [r3]
   1ea8c:	e1a03803 	lsl	r3, r3, #16
   1ea90:	e1a01823 	lsr	r1, r3, #16
   1ea94:	e1a03801 	lsl	r3, r1, #16
   1ea98:	e1a03843 	asr	r3, r3, #16
   1ea9c:	e1a02003 	mov	r2, r3
   1eaa0:	e1a03fc2 	asr	r3, r2, #31
   1eaa4:	ea000012 	b	1eaf4 <_svfiprintf_r+0x664>
   1eaa8:	e2043c02 	and	r3, r4, #512	; 0x200
   1eaac:	e3530000 	cmp	r3, #0
   1eab0:	0a000009 	beq	1eadc <_svfiprintf_r+0x64c>
   1eab4:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1eab8:	e2832004 	add	r2, r3, #4
   1eabc:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1eac0:	e5933000 	ldr	r3, [r3]
   1eac4:	e20310ff 	and	r1, r3, #255	; 0xff
   1eac8:	e1a03c01 	lsl	r3, r1, #24
   1eacc:	e1a03c43 	asr	r3, r3, #24
   1ead0:	e1a02003 	mov	r2, r3
   1ead4:	e1a03fc2 	asr	r3, r2, #31
   1ead8:	ea000005 	b	1eaf4 <_svfiprintf_r+0x664>
   1eadc:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1eae0:	e2832004 	add	r2, r3, #4
   1eae4:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1eae8:	e5933000 	ldr	r3, [r3]
   1eaec:	e1a02003 	mov	r2, r3
   1eaf0:	e1a03fc2 	asr	r3, r2, #31
   1eaf4:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   1eaf8:	e50b3040 	str	r3, [fp, #-64]	; 0x40
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
   1eafc:	e24b3044 	sub	r3, fp, #68	; 0x44
   1eb00:	e893000c 	ldm	r3, {r2, r3}
   1eb04:	e3520000 	cmp	r2, #0
   1eb08:	e2d31000 	sbcs	r1, r3, #0
   1eb0c:	aa000007 	bge	1eb30 <_svfiprintf_r+0x6a0>
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
   1eb10:	e24b3044 	sub	r3, fp, #68	; 0x44
   1eb14:	e893000c 	ldm	r3, {r2, r3}
   1eb18:	e2722000 	rsbs	r2, r2, #0
   1eb1c:	e2e33000 	rsc	r3, r3, #0
   1eb20:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   1eb24:	e50b3040 	str	r3, [fp, #-64]	; 0x40
				sign = '-';
   1eb28:	e3a0302d 	mov	r3, #45	; 0x2d
   1eb2c:	e54b3065 	strb	r3, [fp, #-101]	; 0x65
			}
			base = DEC;
   1eb30:	e3a03001 	mov	r3, #1
   1eb34:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
			goto number;
   1eb38:	ea000131 	b	1f004 <_svfiprintf_r+0xb74>
			flags &= ~LONGINT;
			goto string;
#endif
		case 'n':
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
   1eb3c:	e2043020 	and	r3, r4, #32
   1eb40:	e3530000 	cmp	r3, #0
   1eb44:	0a000007 	beq	1eb68 <_svfiprintf_r+0x6d8>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
   1eb48:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1eb4c:	e2832004 	add	r2, r3, #4
   1eb50:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1eb54:	e5932000 	ldr	r2, [r3]
   1eb58:	e51b3020 	ldr	r3, [fp, #-32]
   1eb5c:	e1a04fc3 	asr	r4, r3, #31
   1eb60:	e8820018 	stm	r2, {r3, r4}
   1eb64:	ea000027 	b	1ec08 <_svfiprintf_r+0x778>
			else
#endif
			if (flags & LONGINT)
   1eb68:	e2043010 	and	r3, r4, #16
   1eb6c:	e3530000 	cmp	r3, #0
   1eb70:	0a000006 	beq	1eb90 <_svfiprintf_r+0x700>
				*GET_ARG (N, ap, long_ptr_t) = ret;
   1eb74:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1eb78:	e2832004 	add	r2, r3, #4
   1eb7c:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1eb80:	e5933000 	ldr	r3, [r3]
   1eb84:	e51b2020 	ldr	r2, [fp, #-32]
   1eb88:	e5832000 	str	r2, [r3]
   1eb8c:	ea00001d 	b	1ec08 <_svfiprintf_r+0x778>
			else if (flags & SHORTINT)
   1eb90:	e2043040 	and	r3, r4, #64	; 0x40
   1eb94:	e3530000 	cmp	r3, #0
   1eb98:	0a000008 	beq	1ebc0 <_svfiprintf_r+0x730>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   1eb9c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1eba0:	e2832004 	add	r2, r3, #4
   1eba4:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1eba8:	e5933000 	ldr	r3, [r3]
   1ebac:	e51b2020 	ldr	r2, [fp, #-32]
   1ebb0:	e1a02802 	lsl	r2, r2, #16
   1ebb4:	e1a02822 	lsr	r2, r2, #16
   1ebb8:	e1c320b0 	strh	r2, [r3]
   1ebbc:	ea000011 	b	1ec08 <_svfiprintf_r+0x778>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
   1ebc0:	e2043c02 	and	r3, r4, #512	; 0x200
   1ebc4:	e3530000 	cmp	r3, #0
   1ebc8:	0a000007 	beq	1ebec <_svfiprintf_r+0x75c>
				*GET_ARG (N, ap, char_ptr_t) = ret;
   1ebcc:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ebd0:	e2832004 	add	r2, r3, #4
   1ebd4:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ebd8:	e5933000 	ldr	r3, [r3]
   1ebdc:	e51b2020 	ldr	r2, [fp, #-32]
   1ebe0:	e20220ff 	and	r2, r2, #255	; 0xff
   1ebe4:	e5c32000 	strb	r2, [r3]
   1ebe8:	ea000006 	b	1ec08 <_svfiprintf_r+0x778>
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
   1ebec:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ebf0:	e2832004 	add	r2, r3, #4
   1ebf4:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ebf8:	e5933000 	ldr	r3, [r3]
   1ebfc:	e51b2020 	ldr	r2, [fp, #-32]
   1ec00:	e5832000 	str	r2, [r3]
			continue;	/* no output */
   1ec04:	ea00032d 	b	1f8c0 <_svfiprintf_r+0x1430>
   1ec08:	ea00032c 	b	1f8c0 <_svfiprintf_r+0x1430>
		case 'O': /* extension */
			flags |= LONGINT;
   1ec0c:	e3844010 	orr	r4, r4, #16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   1ec10:	e2043020 	and	r3, r4, #32
   1ec14:	e3530000 	cmp	r3, #0
   1ec18:	0a000006 	beq	1ec38 <_svfiprintf_r+0x7a8>
   1ec1c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ec20:	e2833007 	add	r3, r3, #7
   1ec24:	e3c33007 	bic	r3, r3, #7
   1ec28:	e2832008 	add	r2, r3, #8
   1ec2c:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ec30:	e893000c 	ldm	r3, {r2, r3}
   1ec34:	ea000027 	b	1ecd8 <_svfiprintf_r+0x848>
   1ec38:	e2043010 	and	r3, r4, #16
   1ec3c:	e3530000 	cmp	r3, #0
   1ec40:	0a000006 	beq	1ec60 <_svfiprintf_r+0x7d0>
   1ec44:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ec48:	e2832004 	add	r2, r3, #4
   1ec4c:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ec50:	e5933000 	ldr	r3, [r3]
   1ec54:	e1a02003 	mov	r2, r3
   1ec58:	e3a03000 	mov	r3, #0
   1ec5c:	ea00001d 	b	1ecd8 <_svfiprintf_r+0x848>
   1ec60:	e2043040 	and	r3, r4, #64	; 0x40
   1ec64:	e3530000 	cmp	r3, #0
   1ec68:	0a000009 	beq	1ec94 <_svfiprintf_r+0x804>
   1ec6c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ec70:	e2832004 	add	r2, r3, #4
   1ec74:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ec78:	e5933000 	ldr	r3, [r3]
   1ec7c:	e1a03803 	lsl	r3, r3, #16
   1ec80:	e1a01823 	lsr	r1, r3, #16
   1ec84:	e1a03001 	mov	r3, r1
   1ec88:	e1a02003 	mov	r2, r3
   1ec8c:	e3a03000 	mov	r3, #0
   1ec90:	ea000010 	b	1ecd8 <_svfiprintf_r+0x848>
   1ec94:	e2043c02 	and	r3, r4, #512	; 0x200
   1ec98:	e3530000 	cmp	r3, #0
   1ec9c:	0a000007 	beq	1ecc0 <_svfiprintf_r+0x830>
   1eca0:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1eca4:	e2832004 	add	r2, r3, #4
   1eca8:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ecac:	e5933000 	ldr	r3, [r3]
   1ecb0:	e20330ff 	and	r3, r3, #255	; 0xff
   1ecb4:	e20320ff 	and	r2, r3, #255	; 0xff
   1ecb8:	e3a03000 	mov	r3, #0
   1ecbc:	ea000005 	b	1ecd8 <_svfiprintf_r+0x848>
   1ecc0:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ecc4:	e2832004 	add	r2, r3, #4
   1ecc8:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1eccc:	e5933000 	ldr	r3, [r3]
   1ecd0:	e1a02003 	mov	r2, r3
   1ecd4:	e3a03000 	mov	r3, #0
   1ecd8:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   1ecdc:	e50b3040 	str	r3, [fp, #-64]	; 0x40
			base = OCT;
   1ece0:	e3a03000 	mov	r3, #0
   1ece4:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
   1ece8:	e3c44b01 	bic	r4, r4, #1024	; 0x400
#endif
			goto nosign;
   1ecec:	ea0000c2 	b	1effc <_svfiprintf_r+0xb6c>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   1ecf0:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ecf4:	e2832004 	add	r2, r3, #4
   1ecf8:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ecfc:	e5933000 	ldr	r3, [r3]
   1ed00:	e1a02003 	mov	r2, r3
   1ed04:	e3a03000 	mov	r3, #0
   1ed08:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   1ed0c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
			base = HEX;
   1ed10:	e3a03002 	mov	r3, #2
   1ed14:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
			xdigs = "0123456789abcdef";
   1ed18:	e59f3c34 	ldr	r3, [pc, #3124]	; 1f954 <_svfiprintf_r+0x14c4>
   1ed1c:	e50b3058 	str	r3, [fp, #-88]	; 0x58
			flags |= HEXPREFIX;
   1ed20:	e3844002 	orr	r4, r4, #2
			ox[0] = '0';
   1ed24:	e3a03030 	mov	r3, #48	; 0x30
   1ed28:	e54b311c 	strb	r3, [fp, #-284]	; 0x11c
			ox[1] = ch = 'x';
   1ed2c:	e3a09078 	mov	r9, #120	; 0x78
   1ed30:	e3a03078 	mov	r3, #120	; 0x78
   1ed34:	e54b311b 	strb	r3, [fp, #-283]	; 0x11b
			goto nosign;
   1ed38:	ea0000af 	b	1effc <_svfiprintf_r+0xb6c>
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   1ed3c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ed40:	e2832004 	add	r2, r3, #4
   1ed44:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ed48:	e5936000 	ldr	r6, [r3]
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
   1ed4c:	e3a03000 	mov	r3, #0
   1ed50:	e54b3065 	strb	r3, [fp, #-101]	; 0x65
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
   1ed54:	e3560000 	cmp	r6, #0
   1ed58:	1a000006 	bne	1ed78 <_svfiprintf_r+0x8e8>
				cp = "(null)";
   1ed5c:	e59f6bf4 	ldr	r6, [pc, #3060]	; 1f958 <_svfiprintf_r+0x14c8>
				size = ((unsigned) prec > 6U) ? 6 : prec;
   1ed60:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1ed64:	e3530006 	cmp	r3, #6
   1ed68:	31a03003 	movcc	r3, r3
   1ed6c:	23a03006 	movcs	r3, #6
   1ed70:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   1ed74:	ea00001f 	b	1edf8 <_svfiprintf_r+0x968>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
   1ed78:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1ed7c:	e3530000 	cmp	r3, #0
   1ed80:	ba000017 	blt	1ede4 <_svfiprintf_r+0x954>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
   1ed84:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1ed88:	e1a00006 	mov	r0, r6
   1ed8c:	e3a01000 	mov	r1, #0
   1ed90:	e1a02003 	mov	r2, r3
   1ed94:	ebffef8e 	bl	1abd4 <memchr>
   1ed98:	e50b0064 	str	r0, [fp, #-100]	; 0x64

				if (p != NULL) {
   1ed9c:	e51b3064 	ldr	r3, [fp, #-100]	; 0x64
   1eda0:	e3530000 	cmp	r3, #0
   1eda4:	0a00000a 	beq	1edd4 <_svfiprintf_r+0x944>
					size = p - cp;
   1eda8:	e51b2064 	ldr	r2, [fp, #-100]	; 0x64
   1edac:	e1a03006 	mov	r3, r6
   1edb0:	e0633002 	rsb	r3, r3, r2
   1edb4:	e50b3054 	str	r3, [fp, #-84]	; 0x54
					if (size > prec)
   1edb8:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   1edbc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1edc0:	e1520003 	cmp	r2, r3
   1edc4:	da000005 	ble	1ede0 <_svfiprintf_r+0x950>
						size = prec;
   1edc8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1edcc:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   1edd0:	ea000008 	b	1edf8 <_svfiprintf_r+0x968>
				} else
					size = prec;
   1edd4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1edd8:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   1eddc:	ea000005 	b	1edf8 <_svfiprintf_r+0x968>
   1ede0:	ea000004 	b	1edf8 <_svfiprintf_r+0x968>
			} else
				size = strlen (cp);
   1ede4:	e1a00006 	mov	r0, r6
   1ede8:	ebffc6ff 	bl	109ec <strlen>
   1edec:	e1a03000 	mov	r3, r0
   1edf0:	e50b3054 	str	r3, [fp, #-84]	; 0x54

			break;
   1edf4:	ea000145 	b	1f310 <_svfiprintf_r+0xe80>
   1edf8:	ea000144 	b	1f310 <_svfiprintf_r+0xe80>
		case 'U': /* extension */
			flags |= LONGINT;
   1edfc:	e3844010 	orr	r4, r4, #16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   1ee00:	e2043020 	and	r3, r4, #32
   1ee04:	e3530000 	cmp	r3, #0
   1ee08:	0a000006 	beq	1ee28 <_svfiprintf_r+0x998>
   1ee0c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ee10:	e2833007 	add	r3, r3, #7
   1ee14:	e3c33007 	bic	r3, r3, #7
   1ee18:	e2832008 	add	r2, r3, #8
   1ee1c:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ee20:	e893000c 	ldm	r3, {r2, r3}
   1ee24:	ea000027 	b	1eec8 <_svfiprintf_r+0xa38>
   1ee28:	e2043010 	and	r3, r4, #16
   1ee2c:	e3530000 	cmp	r3, #0
   1ee30:	0a000006 	beq	1ee50 <_svfiprintf_r+0x9c0>
   1ee34:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ee38:	e2832004 	add	r2, r3, #4
   1ee3c:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ee40:	e5933000 	ldr	r3, [r3]
   1ee44:	e1a02003 	mov	r2, r3
   1ee48:	e3a03000 	mov	r3, #0
   1ee4c:	ea00001d 	b	1eec8 <_svfiprintf_r+0xa38>
   1ee50:	e2043040 	and	r3, r4, #64	; 0x40
   1ee54:	e3530000 	cmp	r3, #0
   1ee58:	0a000009 	beq	1ee84 <_svfiprintf_r+0x9f4>
   1ee5c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ee60:	e2832004 	add	r2, r3, #4
   1ee64:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ee68:	e5933000 	ldr	r3, [r3]
   1ee6c:	e1a03803 	lsl	r3, r3, #16
   1ee70:	e1a01823 	lsr	r1, r3, #16
   1ee74:	e1a03001 	mov	r3, r1
   1ee78:	e1a02003 	mov	r2, r3
   1ee7c:	e3a03000 	mov	r3, #0
   1ee80:	ea000010 	b	1eec8 <_svfiprintf_r+0xa38>
   1ee84:	e2043c02 	and	r3, r4, #512	; 0x200
   1ee88:	e3530000 	cmp	r3, #0
   1ee8c:	0a000007 	beq	1eeb0 <_svfiprintf_r+0xa20>
   1ee90:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ee94:	e2832004 	add	r2, r3, #4
   1ee98:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ee9c:	e5933000 	ldr	r3, [r3]
   1eea0:	e20330ff 	and	r3, r3, #255	; 0xff
   1eea4:	e20320ff 	and	r2, r3, #255	; 0xff
   1eea8:	e3a03000 	mov	r3, #0
   1eeac:	ea000005 	b	1eec8 <_svfiprintf_r+0xa38>
   1eeb0:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1eeb4:	e2832004 	add	r2, r3, #4
   1eeb8:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1eebc:	e5933000 	ldr	r3, [r3]
   1eec0:	e1a02003 	mov	r2, r3
   1eec4:	e3a03000 	mov	r3, #0
   1eec8:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   1eecc:	e50b3040 	str	r3, [fp, #-64]	; 0x40
			base = DEC;
   1eed0:	e3a03001 	mov	r3, #1
   1eed4:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
			goto nosign;
   1eed8:	ea000047 	b	1effc <_svfiprintf_r+0xb6c>
		case 'X':
			xdigs = "0123456789ABCDEF";
   1eedc:	e59f3a78 	ldr	r3, [pc, #2680]	; 1f95c <_svfiprintf_r+0x14cc>
   1eee0:	e50b3058 	str	r3, [fp, #-88]	; 0x58
			goto hex;
   1eee4:	ea000001 	b	1eef0 <_svfiprintf_r+0xa60>
		case 'x':
			xdigs = "0123456789abcdef";
   1eee8:	e59f3a64 	ldr	r3, [pc, #2660]	; 1f954 <_svfiprintf_r+0x14c4>
   1eeec:	e50b3058 	str	r3, [fp, #-88]	; 0x58
hex:			_uquad = UARG ();
   1eef0:	e2043020 	and	r3, r4, #32
   1eef4:	e3530000 	cmp	r3, #0
   1eef8:	0a000006 	beq	1ef18 <_svfiprintf_r+0xa88>
   1eefc:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ef00:	e2833007 	add	r3, r3, #7
   1ef04:	e3c33007 	bic	r3, r3, #7
   1ef08:	e2832008 	add	r2, r3, #8
   1ef0c:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ef10:	e893000c 	ldm	r3, {r2, r3}
   1ef14:	ea000027 	b	1efb8 <_svfiprintf_r+0xb28>
   1ef18:	e2043010 	and	r3, r4, #16
   1ef1c:	e3530000 	cmp	r3, #0
   1ef20:	0a000006 	beq	1ef40 <_svfiprintf_r+0xab0>
   1ef24:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ef28:	e2832004 	add	r2, r3, #4
   1ef2c:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ef30:	e5933000 	ldr	r3, [r3]
   1ef34:	e1a02003 	mov	r2, r3
   1ef38:	e3a03000 	mov	r3, #0
   1ef3c:	ea00001d 	b	1efb8 <_svfiprintf_r+0xb28>
   1ef40:	e2043040 	and	r3, r4, #64	; 0x40
   1ef44:	e3530000 	cmp	r3, #0
   1ef48:	0a000009 	beq	1ef74 <_svfiprintf_r+0xae4>
   1ef4c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ef50:	e2832004 	add	r2, r3, #4
   1ef54:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ef58:	e5933000 	ldr	r3, [r3]
   1ef5c:	e1a03803 	lsl	r3, r3, #16
   1ef60:	e1a01823 	lsr	r1, r3, #16
   1ef64:	e1a03001 	mov	r3, r1
   1ef68:	e1a02003 	mov	r2, r3
   1ef6c:	e3a03000 	mov	r3, #0
   1ef70:	ea000010 	b	1efb8 <_svfiprintf_r+0xb28>
   1ef74:	e2043c02 	and	r3, r4, #512	; 0x200
   1ef78:	e3530000 	cmp	r3, #0
   1ef7c:	0a000007 	beq	1efa0 <_svfiprintf_r+0xb10>
   1ef80:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1ef84:	e2832004 	add	r2, r3, #4
   1ef88:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1ef8c:	e5933000 	ldr	r3, [r3]
   1ef90:	e20330ff 	and	r3, r3, #255	; 0xff
   1ef94:	e20320ff 	and	r2, r3, #255	; 0xff
   1ef98:	e3a03000 	mov	r3, #0
   1ef9c:	ea000005 	b	1efb8 <_svfiprintf_r+0xb28>
   1efa0:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1efa4:	e2832004 	add	r2, r3, #4
   1efa8:	e50b212c 	str	r2, [fp, #-300]	; 0x12c
   1efac:	e5933000 	ldr	r3, [r3]
   1efb0:	e1a02003 	mov	r2, r3
   1efb4:	e3a03000 	mov	r3, #0
   1efb8:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   1efbc:	e50b3040 	str	r3, [fp, #-64]	; 0x40
			base = HEX;
   1efc0:	e3a03002 	mov	r3, #2
   1efc4:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
   1efc8:	e2043001 	and	r3, r4, #1
   1efcc:	e3530000 	cmp	r3, #0
   1efd0:	0a000008 	beq	1eff8 <_svfiprintf_r+0xb68>
   1efd4:	e24b3044 	sub	r3, fp, #68	; 0x44
   1efd8:	e893000c 	ldm	r3, {r2, r3}
   1efdc:	e1921003 	orrs	r1, r2, r3
   1efe0:	0a000004 	beq	1eff8 <_svfiprintf_r+0xb68>
				ox[0] = '0';
   1efe4:	e3a03030 	mov	r3, #48	; 0x30
   1efe8:	e54b311c 	strb	r3, [fp, #-284]	; 0x11c
				ox[1] = ch;
   1efec:	e20930ff 	and	r3, r9, #255	; 0xff
   1eff0:	e54b311b 	strb	r3, [fp, #-283]	; 0x11b
				flags |= HEXPREFIX;
   1eff4:	e3844002 	orr	r4, r4, #2
			}

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
   1eff8:	e3c44b01 	bic	r4, r4, #1024	; 0x400
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   1effc:	e3a03000 	mov	r3, #0
   1f000:	e54b3065 	strb	r3, [fp, #-101]	; 0x65
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   1f004:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1f008:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   1f00c:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1f010:	e3530000 	cmp	r3, #0
   1f014:	ba000000 	blt	1f01c <_svfiprintf_r+0xb8c>
				flags &= ~ZEROPAD;
   1f018:	e3c44080 	bic	r4, r4, #128	; 0x80
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   1f01c:	e24b6f46 	sub	r6, fp, #280	; 0x118
   1f020:	e2866064 	add	r6, r6, #100	; 0x64
			if (_uquad != 0 || prec != 0) {
   1f024:	e24b3044 	sub	r3, fp, #68	; 0x44
   1f028:	e893000c 	ldm	r3, {r2, r3}
   1f02c:	e1921003 	orrs	r1, r2, r3
   1f030:	1a000002 	bne	1f040 <_svfiprintf_r+0xbb0>
   1f034:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   1f038:	e3530000 	cmp	r3, #0
   1f03c:	0a000099 	beq	1f2a8 <_svfiprintf_r+0xe18>
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   1f040:	e55b3045 	ldrb	r3, [fp, #-69]	; 0x45
   1f044:	e3530001 	cmp	r3, #1
   1f048:	0a000026 	beq	1f0e8 <_svfiprintf_r+0xc58>
   1f04c:	e3530002 	cmp	r3, #2
   1f050:	0a000073 	beq	1f224 <_svfiprintf_r+0xd94>
   1f054:	e3530000 	cmp	r3, #0
   1f058:	1a00008a 	bne	1f288 <_svfiprintf_r+0xdf8>
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   1f05c:	e2466001 	sub	r6, r6, #1
   1f060:	e55b3044 	ldrb	r3, [fp, #-68]	; 0x44
   1f064:	e2033007 	and	r3, r3, #7
   1f068:	e20330ff 	and	r3, r3, #255	; 0xff
   1f06c:	e2833030 	add	r3, r3, #48	; 0x30
   1f070:	e20330ff 	and	r3, r3, #255	; 0xff
   1f074:	e5c63000 	strb	r3, [r6]
						_uquad >>= 3;
   1f078:	e24b3044 	sub	r3, fp, #68	; 0x44
   1f07c:	e893000c 	ldm	r3, {r2, r3}
   1f080:	e1a011a2 	lsr	r1, r2, #3
   1f084:	e50b1134 	str	r1, [fp, #-308]	; 0x134
   1f088:	e51b1134 	ldr	r1, [fp, #-308]	; 0x134
   1f08c:	e1811e83 	orr	r1, r1, r3, lsl #29
   1f090:	e50b1134 	str	r1, [fp, #-308]	; 0x134
   1f094:	e1a011a3 	lsr	r1, r3, #3
   1f098:	e50b1130 	str	r1, [fp, #-304]	; 0x130
   1f09c:	e24b3f4d 	sub	r3, fp, #308	; 0x134
   1f0a0:	e893000c 	ldm	r3, {r2, r3}
   1f0a4:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   1f0a8:	e50b3040 	str	r3, [fp, #-64]	; 0x40
					} while (_uquad);
   1f0ac:	e24b3044 	sub	r3, fp, #68	; 0x44
   1f0b0:	e893000c 	ldm	r3, {r2, r3}
   1f0b4:	e1921003 	orrs	r1, r2, r3
   1f0b8:	1affffe7 	bne	1f05c <_svfiprintf_r+0xbcc>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
   1f0bc:	e2043001 	and	r3, r4, #1
   1f0c0:	e3530000 	cmp	r3, #0
   1f0c4:	0a000006 	beq	1f0e4 <_svfiprintf_r+0xc54>
   1f0c8:	e5d63000 	ldrb	r3, [r6]
   1f0cc:	e3530030 	cmp	r3, #48	; 0x30
   1f0d0:	0a000003 	beq	1f0e4 <_svfiprintf_r+0xc54>
						*--cp = '0';
   1f0d4:	e2466001 	sub	r6, r6, #1
   1f0d8:	e3a03030 	mov	r3, #48	; 0x30
   1f0dc:	e5c63000 	strb	r3, [r6]
					break;
   1f0e0:	ea00006f 	b	1f2a4 <_svfiprintf_r+0xe14>
   1f0e4:	ea00006e 	b	1f2a4 <_svfiprintf_r+0xe14>

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   1f0e8:	e24b3044 	sub	r3, fp, #68	; 0x44
   1f0ec:	e893000c 	ldm	r3, {r2, r3}
   1f0f0:	e3530000 	cmp	r3, #0
   1f0f4:	03520009 	cmpeq	r2, #9
   1f0f8:	8a000005 	bhi	1f114 <_svfiprintf_r+0xc84>
						*--cp = to_char(_uquad);
   1f0fc:	e2466001 	sub	r6, r6, #1
   1f100:	e55b3044 	ldrb	r3, [fp, #-68]	; 0x44
   1f104:	e2833030 	add	r3, r3, #48	; 0x30
   1f108:	e20330ff 	and	r3, r3, #255	; 0xff
   1f10c:	e5c63000 	strb	r3, [r6]
						break;
   1f110:	ea000063 	b	1f2a4 <_svfiprintf_r+0xe14>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
   1f114:	e3a03000 	mov	r3, #0
   1f118:	e50b3038 	str	r3, [fp, #-56]	; 0x38
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   1f11c:	e2466001 	sub	r6, r6, #1
   1f120:	e24b3044 	sub	r3, fp, #68	; 0x44
   1f124:	e893000c 	ldm	r3, {r2, r3}
   1f128:	e1a00002 	mov	r0, r2
   1f12c:	e1a01003 	mov	r1, r3
   1f130:	e3a0200a 	mov	r2, #10
   1f134:	e3a03000 	mov	r3, #0
   1f138:	ebffbb13 	bl	dd8c <__aeabi_uldivmod>
   1f13c:	e20230ff 	and	r3, r2, #255	; 0xff
   1f140:	e2833030 	add	r3, r3, #48	; 0x30
   1f144:	e20330ff 	and	r3, r3, #255	; 0xff
   1f148:	e5c63000 	strb	r3, [r6]
#ifdef _WANT_IO_C99_FORMATS
					  ndig++;
   1f14c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1f150:	e2833001 	add	r3, r3, #1
   1f154:	e50b3038 	str	r3, [fp, #-56]	; 0x38
					  /* If (*grouping == CHAR_MAX) then no
					     more grouping */
					  if ((flags & GROUPING)
   1f158:	e2043b01 	and	r3, r4, #1024	; 0x400
   1f15c:	e3530000 	cmp	r3, #0
   1f160:	0a00001f 	beq	1f1e4 <_svfiprintf_r+0xd54>
					      && ndig == *grouping
   1f164:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1f168:	e5d33000 	ldrb	r3, [r3]
   1f16c:	e1a02003 	mov	r2, r3
   1f170:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   1f174:	e1520003 	cmp	r2, r3
   1f178:	1a000019 	bne	1f1e4 <_svfiprintf_r+0xd54>
					      && *grouping != CHAR_MAX
   1f17c:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1f180:	e5d33000 	ldrb	r3, [r3]
   1f184:	e35300ff 	cmp	r3, #255	; 0xff
   1f188:	0a000015 	beq	1f1e4 <_svfiprintf_r+0xd54>
					      && _uquad > 9) {
   1f18c:	e24b3044 	sub	r3, fp, #68	; 0x44
   1f190:	e893000c 	ldm	r3, {r2, r3}
   1f194:	e3530000 	cmp	r3, #0
   1f198:	03520009 	cmpeq	r2, #9
   1f19c:	9a000010 	bls	1f1e4 <_svfiprintf_r+0xd54>
					    cp -= thsnd_len;
   1f1a0:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   1f1a4:	e2633000 	rsb	r3, r3, #0
   1f1a8:	e0866003 	add	r6, r6, r3
					    strncpy (cp, thousands_sep,
   1f1ac:	e1a00006 	mov	r0, r6
   1f1b0:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
   1f1b4:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   1f1b8:	ebfffb9b 	bl	1e02c <strncpy>
						     thsnd_len);
					    ndig = 0;
   1f1bc:	e3a03000 	mov	r3, #0
   1f1c0:	e50b3038 	str	r3, [fp, #-56]	; 0x38
					    /* If (grouping[1] == '\0') then we
					       have to use *grouping character
					       (last grouping rule) for all
					       next cases. */
					    if (grouping[1] != '\0')
   1f1c4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1f1c8:	e2833001 	add	r3, r3, #1
   1f1cc:	e5d33000 	ldrb	r3, [r3]
   1f1d0:	e3530000 	cmp	r3, #0
   1f1d4:	0a000002 	beq	1f1e4 <_svfiprintf_r+0xd54>
					      grouping++;
   1f1d8:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   1f1dc:	e2833001 	add	r3, r3, #1
   1f1e0:	e50b3034 	str	r3, [fp, #-52]	; 0x34
					  }
#endif
					  _uquad /= 10;
   1f1e4:	e24b3044 	sub	r3, fp, #68	; 0x44
   1f1e8:	e893000c 	ldm	r3, {r2, r3}
   1f1ec:	e1a00002 	mov	r0, r2
   1f1f0:	e1a01003 	mov	r1, r3
   1f1f4:	e3a0200a 	mov	r2, #10
   1f1f8:	e3a03000 	mov	r3, #0
   1f1fc:	ebffbae2 	bl	dd8c <__aeabi_uldivmod>
   1f200:	e1a02000 	mov	r2, r0
   1f204:	e1a03001 	mov	r3, r1
   1f208:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   1f20c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
					} while (_uquad != 0);
   1f210:	e24b3044 	sub	r3, fp, #68	; 0x44
   1f214:	e893000c 	ldm	r3, {r2, r3}
   1f218:	e1921003 	orrs	r1, r2, r3
   1f21c:	1affffbe 	bne	1f11c <_svfiprintf_r+0xc8c>
					break;
   1f220:	ea00001f 	b	1f2a4 <_svfiprintf_r+0xe14>

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   1f224:	e2466001 	sub	r6, r6, #1
   1f228:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   1f22c:	e203300f 	and	r3, r3, #15
   1f230:	e51b2058 	ldr	r2, [fp, #-88]	; 0x58
   1f234:	e0823003 	add	r3, r2, r3
   1f238:	e5d33000 	ldrb	r3, [r3]
   1f23c:	e5c63000 	strb	r3, [r6]
						_uquad >>= 4;
   1f240:	e24b3044 	sub	r3, fp, #68	; 0x44
   1f244:	e893000c 	ldm	r3, {r2, r3}
   1f248:	e1a01222 	lsr	r1, r2, #4
   1f24c:	e50b113c 	str	r1, [fp, #-316]	; 0x13c
   1f250:	e51b113c 	ldr	r1, [fp, #-316]	; 0x13c
   1f254:	e1811e03 	orr	r1, r1, r3, lsl #28
   1f258:	e50b113c 	str	r1, [fp, #-316]	; 0x13c
   1f25c:	e1a01223 	lsr	r1, r3, #4
   1f260:	e50b1138 	str	r1, [fp, #-312]	; 0x138
   1f264:	e24b3f4f 	sub	r3, fp, #316	; 0x13c
   1f268:	e893000c 	ldm	r3, {r2, r3}
   1f26c:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   1f270:	e50b3040 	str	r3, [fp, #-64]	; 0x40
					} while (_uquad);
   1f274:	e24b3044 	sub	r3, fp, #68	; 0x44
   1f278:	e893000c 	ldm	r3, {r2, r3}
   1f27c:	e1921003 	orrs	r1, r2, r3
   1f280:	1affffe7 	bne	1f224 <_svfiprintf_r+0xd94>
					break;
   1f284:	ea000006 	b	1f2a4 <_svfiprintf_r+0xe14>

				default:
					cp = "bug in vfprintf: bad base";
   1f288:	e59f66d0 	ldr	r6, [pc, #1744]	; 1f960 <_svfiprintf_r+0x14d0>
					size = strlen (cp);
   1f28c:	e1a00006 	mov	r0, r6
   1f290:	ebffc5d5 	bl	109ec <strlen>
   1f294:	e1a03000 	mov	r3, r0
   1f298:	e50b3054 	str	r3, [fp, #-84]	; 0x54
					goto skipsize;
   1f29c:	e1a00000 	nop			; (mov r0, r0)
                       else if (base == OCT && (flags & ALT))
                         *--cp = '0';

			size = buf + BUF - cp;
		skipsize:
			break;
   1f2a0:	ea00001a 	b	1f310 <_svfiprintf_r+0xe80>
				default:
					cp = "bug in vfprintf: bad base";
					size = strlen (cp);
					goto skipsize;
				}
			}
   1f2a4:	ea000008 	b	1f2cc <_svfiprintf_r+0xe3c>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   1f2a8:	e55b3045 	ldrb	r3, [fp, #-69]	; 0x45
   1f2ac:	e3530000 	cmp	r3, #0
   1f2b0:	1a000005 	bne	1f2cc <_svfiprintf_r+0xe3c>
   1f2b4:	e2043001 	and	r3, r4, #1
   1f2b8:	e3530000 	cmp	r3, #0
   1f2bc:	0a000002 	beq	1f2cc <_svfiprintf_r+0xe3c>
                         *--cp = '0';
   1f2c0:	e2466001 	sub	r6, r6, #1
   1f2c4:	e3a03030 	mov	r3, #48	; 0x30
   1f2c8:	e5c63000 	strb	r3, [r6]

			size = buf + BUF - cp;
   1f2cc:	e24b3f46 	sub	r3, fp, #280	; 0x118
   1f2d0:	e2833064 	add	r3, r3, #100	; 0x64
   1f2d4:	e1a02006 	mov	r2, r6
   1f2d8:	e0623003 	rsb	r3, r2, r3
   1f2dc:	e50b3054 	str	r3, [fp, #-84]	; 0x54
		skipsize:
			break;
   1f2e0:	ea00000a 	b	1f310 <_svfiprintf_r+0xe80>
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
   1f2e4:	e3590000 	cmp	r9, #0
   1f2e8:	1a000000 	bne	1f2f0 <_svfiprintf_r+0xe60>
				goto done;
   1f2ec:	ea000174 	b	1f8c4 <_svfiprintf_r+0x1434>
			/* pretend it was %c with argument ch */
			cp = buf;
   1f2f0:	e24b6f46 	sub	r6, fp, #280	; 0x118
			*cp = ch;
   1f2f4:	e20930ff 	and	r3, r9, #255	; 0xff
   1f2f8:	e5c63000 	strb	r3, [r6]
			size = 1;
   1f2fc:	e3a03001 	mov	r3, #1
   1f300:	e50b3054 	str	r3, [fp, #-84]	; 0x54
			sign = '\0';
   1f304:	e3a03000 	mov	r3, #0
   1f308:	e54b3065 	strb	r3, [fp, #-101]	; 0x65
			break;
   1f30c:	e1a00000 	nop			; (mov r0, r0)
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
   1f310:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   1f314:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   1f318:	e1520003 	cmp	r2, r3
   1f31c:	a1a03002 	movge	r3, r2
   1f320:	b1a03003 	movlt	r3, r3
   1f324:	e50b3050 	str	r3, [fp, #-80]	; 0x50
		if (sign)
   1f328:	e55b3065 	ldrb	r3, [fp, #-101]	; 0x65
   1f32c:	e3530000 	cmp	r3, #0
   1f330:	0a000002 	beq	1f340 <_svfiprintf_r+0xeb0>
			realsz++;
   1f334:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   1f338:	e2833001 	add	r3, r3, #1
   1f33c:	e50b3050 	str	r3, [fp, #-80]	; 0x50
		if (flags & HEXPREFIX)
   1f340:	e2043002 	and	r3, r4, #2
   1f344:	e3530000 	cmp	r3, #0
   1f348:	0a000002 	beq	1f358 <_svfiprintf_r+0xec8>
			realsz+= 2;
   1f34c:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   1f350:	e2833002 	add	r3, r3, #2
   1f354:	e50b3050 	str	r3, [fp, #-80]	; 0x50

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   1f358:	e2043084 	and	r3, r4, #132	; 0x84
   1f35c:	e3530000 	cmp	r3, #0
   1f360:	1a000038 	bne	1f448 <_svfiprintf_r+0xfb8>
			PAD (width - realsz, blanks);
   1f364:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1f368:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   1f36c:	e0637002 	rsb	r7, r3, r2
   1f370:	e3570000 	cmp	r7, #0
   1f374:	da000033 	ble	1f448 <_svfiprintf_r+0xfb8>
   1f378:	ea000018 	b	1f3e0 <_svfiprintf_r+0xf50>
   1f37c:	e59f35e0 	ldr	r3, [pc, #1504]	; 1f964 <_svfiprintf_r+0x14d4>
   1f380:	e5853000 	str	r3, [r5]
   1f384:	e3a03010 	mov	r3, #16
   1f388:	e5853004 	str	r3, [r5, #4]
   1f38c:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1f390:	e2833010 	add	r3, r3, #16
   1f394:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1f398:	e2855008 	add	r5, r5, #8
   1f39c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f3a0:	e2833001 	add	r3, r3, #1
   1f3a4:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1f3a8:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f3ac:	e3530007 	cmp	r3, #7
   1f3b0:	da000009 	ble	1f3dc <_svfiprintf_r+0xf4c>
   1f3b4:	e24b3074 	sub	r3, fp, #116	; 0x74
   1f3b8:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1f3bc:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   1f3c0:	e1a02003 	mov	r2, r3
   1f3c4:	ebfffb74 	bl	1e19c <__ssprint_r>
   1f3c8:	e1a03000 	mov	r3, r0
   1f3cc:	e3530000 	cmp	r3, #0
   1f3d0:	0a000000 	beq	1f3d8 <_svfiprintf_r+0xf48>
   1f3d4:	ea000149 	b	1f900 <_svfiprintf_r+0x1470>
   1f3d8:	e24b50b4 	sub	r5, fp, #180	; 0xb4
   1f3dc:	e2477010 	sub	r7, r7, #16
   1f3e0:	e3570010 	cmp	r7, #16
   1f3e4:	caffffe4 	bgt	1f37c <_svfiprintf_r+0xeec>
   1f3e8:	e59f3574 	ldr	r3, [pc, #1396]	; 1f964 <_svfiprintf_r+0x14d4>
   1f3ec:	e5853000 	str	r3, [r5]
   1f3f0:	e1a03007 	mov	r3, r7
   1f3f4:	e5853004 	str	r3, [r5, #4]
   1f3f8:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1f3fc:	e0833007 	add	r3, r3, r7
   1f400:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1f404:	e2855008 	add	r5, r5, #8
   1f408:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f40c:	e2833001 	add	r3, r3, #1
   1f410:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1f414:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f418:	e3530007 	cmp	r3, #7
   1f41c:	da000009 	ble	1f448 <_svfiprintf_r+0xfb8>
   1f420:	e24b3074 	sub	r3, fp, #116	; 0x74
   1f424:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1f428:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   1f42c:	e1a02003 	mov	r2, r3
   1f430:	ebfffb59 	bl	1e19c <__ssprint_r>
   1f434:	e1a03000 	mov	r3, r0
   1f438:	e3530000 	cmp	r3, #0
   1f43c:	0a000000 	beq	1f444 <_svfiprintf_r+0xfb4>
   1f440:	ea00012e 	b	1f900 <_svfiprintf_r+0x1470>
   1f444:	e24b50b4 	sub	r5, fp, #180	; 0xb4

		/* prefix */
		if (sign)
   1f448:	e55b3065 	ldrb	r3, [fp, #-101]	; 0x65
   1f44c:	e3530000 	cmp	r3, #0
   1f450:	0a000017 	beq	1f4b4 <_svfiprintf_r+0x1024>
			PRINT (&sign, 1);
   1f454:	e24b3065 	sub	r3, fp, #101	; 0x65
   1f458:	e5853000 	str	r3, [r5]
   1f45c:	e3a03001 	mov	r3, #1
   1f460:	e5853004 	str	r3, [r5, #4]
   1f464:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1f468:	e2833001 	add	r3, r3, #1
   1f46c:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1f470:	e2855008 	add	r5, r5, #8
   1f474:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f478:	e2833001 	add	r3, r3, #1
   1f47c:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1f480:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f484:	e3530007 	cmp	r3, #7
   1f488:	da000009 	ble	1f4b4 <_svfiprintf_r+0x1024>
   1f48c:	e24b3074 	sub	r3, fp, #116	; 0x74
   1f490:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1f494:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   1f498:	e1a02003 	mov	r2, r3
   1f49c:	ebfffb3e 	bl	1e19c <__ssprint_r>
   1f4a0:	e1a03000 	mov	r3, r0
   1f4a4:	e3530000 	cmp	r3, #0
   1f4a8:	0a000000 	beq	1f4b0 <_svfiprintf_r+0x1020>
   1f4ac:	ea000113 	b	1f900 <_svfiprintf_r+0x1470>
   1f4b0:	e24b50b4 	sub	r5, fp, #180	; 0xb4
		if (flags & HEXPREFIX)
   1f4b4:	e2043002 	and	r3, r4, #2
   1f4b8:	e3530000 	cmp	r3, #0
   1f4bc:	0a000017 	beq	1f520 <_svfiprintf_r+0x1090>
			PRINT (ox, 2);
   1f4c0:	e24b3f47 	sub	r3, fp, #284	; 0x11c
   1f4c4:	e5853000 	str	r3, [r5]
   1f4c8:	e3a03002 	mov	r3, #2
   1f4cc:	e5853004 	str	r3, [r5, #4]
   1f4d0:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1f4d4:	e2833002 	add	r3, r3, #2
   1f4d8:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1f4dc:	e2855008 	add	r5, r5, #8
   1f4e0:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f4e4:	e2833001 	add	r3, r3, #1
   1f4e8:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1f4ec:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f4f0:	e3530007 	cmp	r3, #7
   1f4f4:	da000009 	ble	1f520 <_svfiprintf_r+0x1090>
   1f4f8:	e24b3074 	sub	r3, fp, #116	; 0x74
   1f4fc:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1f500:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   1f504:	e1a02003 	mov	r2, r3
   1f508:	ebfffb23 	bl	1e19c <__ssprint_r>
   1f50c:	e1a03000 	mov	r3, r0
   1f510:	e3530000 	cmp	r3, #0
   1f514:	0a000000 	beq	1f51c <_svfiprintf_r+0x108c>
   1f518:	ea0000f8 	b	1f900 <_svfiprintf_r+0x1470>
   1f51c:	e24b50b4 	sub	r5, fp, #180	; 0xb4

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   1f520:	e2043084 	and	r3, r4, #132	; 0x84
   1f524:	e3530080 	cmp	r3, #128	; 0x80
   1f528:	1a000038 	bne	1f610 <_svfiprintf_r+0x1180>
			PAD (width - realsz, zeroes);
   1f52c:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1f530:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   1f534:	e0637002 	rsb	r7, r3, r2
   1f538:	e3570000 	cmp	r7, #0
   1f53c:	da000033 	ble	1f610 <_svfiprintf_r+0x1180>
   1f540:	ea000018 	b	1f5a8 <_svfiprintf_r+0x1118>
   1f544:	e59f341c 	ldr	r3, [pc, #1052]	; 1f968 <_svfiprintf_r+0x14d8>
   1f548:	e5853000 	str	r3, [r5]
   1f54c:	e3a03010 	mov	r3, #16
   1f550:	e5853004 	str	r3, [r5, #4]
   1f554:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1f558:	e2833010 	add	r3, r3, #16
   1f55c:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1f560:	e2855008 	add	r5, r5, #8
   1f564:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f568:	e2833001 	add	r3, r3, #1
   1f56c:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1f570:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f574:	e3530007 	cmp	r3, #7
   1f578:	da000009 	ble	1f5a4 <_svfiprintf_r+0x1114>
   1f57c:	e24b3074 	sub	r3, fp, #116	; 0x74
   1f580:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1f584:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   1f588:	e1a02003 	mov	r2, r3
   1f58c:	ebfffb02 	bl	1e19c <__ssprint_r>
   1f590:	e1a03000 	mov	r3, r0
   1f594:	e3530000 	cmp	r3, #0
   1f598:	0a000000 	beq	1f5a0 <_svfiprintf_r+0x1110>
   1f59c:	ea0000d7 	b	1f900 <_svfiprintf_r+0x1470>
   1f5a0:	e24b50b4 	sub	r5, fp, #180	; 0xb4
   1f5a4:	e2477010 	sub	r7, r7, #16
   1f5a8:	e3570010 	cmp	r7, #16
   1f5ac:	caffffe4 	bgt	1f544 <_svfiprintf_r+0x10b4>
   1f5b0:	e59f33b0 	ldr	r3, [pc, #944]	; 1f968 <_svfiprintf_r+0x14d8>
   1f5b4:	e5853000 	str	r3, [r5]
   1f5b8:	e1a03007 	mov	r3, r7
   1f5bc:	e5853004 	str	r3, [r5, #4]
   1f5c0:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1f5c4:	e0833007 	add	r3, r3, r7
   1f5c8:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1f5cc:	e2855008 	add	r5, r5, #8
   1f5d0:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f5d4:	e2833001 	add	r3, r3, #1
   1f5d8:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1f5dc:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f5e0:	e3530007 	cmp	r3, #7
   1f5e4:	da000009 	ble	1f610 <_svfiprintf_r+0x1180>
   1f5e8:	e24b3074 	sub	r3, fp, #116	; 0x74
   1f5ec:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1f5f0:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   1f5f4:	e1a02003 	mov	r2, r3
   1f5f8:	ebfffae7 	bl	1e19c <__ssprint_r>
   1f5fc:	e1a03000 	mov	r3, r0
   1f600:	e3530000 	cmp	r3, #0
   1f604:	0a000000 	beq	1f60c <_svfiprintf_r+0x117c>
   1f608:	ea0000bc 	b	1f900 <_svfiprintf_r+0x1470>
   1f60c:	e24b50b4 	sub	r5, fp, #180	; 0xb4

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   1f610:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   1f614:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   1f618:	e0637002 	rsb	r7, r3, r2
   1f61c:	e3570000 	cmp	r7, #0
   1f620:	da000033 	ble	1f6f4 <_svfiprintf_r+0x1264>
   1f624:	ea000018 	b	1f68c <_svfiprintf_r+0x11fc>
   1f628:	e59f3338 	ldr	r3, [pc, #824]	; 1f968 <_svfiprintf_r+0x14d8>
   1f62c:	e5853000 	str	r3, [r5]
   1f630:	e3a03010 	mov	r3, #16
   1f634:	e5853004 	str	r3, [r5, #4]
   1f638:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1f63c:	e2833010 	add	r3, r3, #16
   1f640:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1f644:	e2855008 	add	r5, r5, #8
   1f648:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f64c:	e2833001 	add	r3, r3, #1
   1f650:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1f654:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f658:	e3530007 	cmp	r3, #7
   1f65c:	da000009 	ble	1f688 <_svfiprintf_r+0x11f8>
   1f660:	e24b3074 	sub	r3, fp, #116	; 0x74
   1f664:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1f668:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   1f66c:	e1a02003 	mov	r2, r3
   1f670:	ebfffac9 	bl	1e19c <__ssprint_r>
   1f674:	e1a03000 	mov	r3, r0
   1f678:	e3530000 	cmp	r3, #0
   1f67c:	0a000000 	beq	1f684 <_svfiprintf_r+0x11f4>
   1f680:	ea00009e 	b	1f900 <_svfiprintf_r+0x1470>
   1f684:	e24b50b4 	sub	r5, fp, #180	; 0xb4
   1f688:	e2477010 	sub	r7, r7, #16
   1f68c:	e3570010 	cmp	r7, #16
   1f690:	caffffe4 	bgt	1f628 <_svfiprintf_r+0x1198>
   1f694:	e59f32cc 	ldr	r3, [pc, #716]	; 1f968 <_svfiprintf_r+0x14d8>
   1f698:	e5853000 	str	r3, [r5]
   1f69c:	e1a03007 	mov	r3, r7
   1f6a0:	e5853004 	str	r3, [r5, #4]
   1f6a4:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1f6a8:	e0833007 	add	r3, r3, r7
   1f6ac:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1f6b0:	e2855008 	add	r5, r5, #8
   1f6b4:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f6b8:	e2833001 	add	r3, r3, #1
   1f6bc:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1f6c0:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f6c4:	e3530007 	cmp	r3, #7
   1f6c8:	da000009 	ble	1f6f4 <_svfiprintf_r+0x1264>
   1f6cc:	e24b3074 	sub	r3, fp, #116	; 0x74
   1f6d0:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1f6d4:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   1f6d8:	e1a02003 	mov	r2, r3
   1f6dc:	ebfffaae 	bl	1e19c <__ssprint_r>
   1f6e0:	e1a03000 	mov	r3, r0
   1f6e4:	e3530000 	cmp	r3, #0
   1f6e8:	0a000000 	beq	1f6f0 <_svfiprintf_r+0x1260>
   1f6ec:	ea000083 	b	1f900 <_svfiprintf_r+0x1470>
   1f6f0:	e24b50b4 	sub	r5, fp, #180	; 0xb4
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   1f6f4:	e5856000 	str	r6, [r5]
   1f6f8:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   1f6fc:	e5853004 	str	r3, [r5, #4]
   1f700:	e51b206c 	ldr	r2, [fp, #-108]	; 0x6c
   1f704:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   1f708:	e0823003 	add	r3, r2, r3
   1f70c:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1f710:	e2855008 	add	r5, r5, #8
   1f714:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f718:	e2833001 	add	r3, r3, #1
   1f71c:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1f720:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f724:	e3530007 	cmp	r3, #7
   1f728:	da000009 	ble	1f754 <_svfiprintf_r+0x12c4>
   1f72c:	e24b3074 	sub	r3, fp, #116	; 0x74
   1f730:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1f734:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   1f738:	e1a02003 	mov	r2, r3
   1f73c:	ebfffa96 	bl	1e19c <__ssprint_r>
   1f740:	e1a03000 	mov	r3, r0
   1f744:	e3530000 	cmp	r3, #0
   1f748:	0a000000 	beq	1f750 <_svfiprintf_r+0x12c0>
   1f74c:	ea00006b 	b	1f900 <_svfiprintf_r+0x1470>
   1f750:	e24b50b4 	sub	r5, fp, #180	; 0xb4
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   1f754:	e2043004 	and	r3, r4, #4
   1f758:	e3530000 	cmp	r3, #0
   1f75c:	0a000038 	beq	1f844 <_svfiprintf_r+0x13b4>
			PAD (width - realsz, blanks);
   1f760:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1f764:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   1f768:	e0637002 	rsb	r7, r3, r2
   1f76c:	e3570000 	cmp	r7, #0
   1f770:	da000033 	ble	1f844 <_svfiprintf_r+0x13b4>
   1f774:	ea000018 	b	1f7dc <_svfiprintf_r+0x134c>
   1f778:	e59f31e4 	ldr	r3, [pc, #484]	; 1f964 <_svfiprintf_r+0x14d4>
   1f77c:	e5853000 	str	r3, [r5]
   1f780:	e3a03010 	mov	r3, #16
   1f784:	e5853004 	str	r3, [r5, #4]
   1f788:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1f78c:	e2833010 	add	r3, r3, #16
   1f790:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1f794:	e2855008 	add	r5, r5, #8
   1f798:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f79c:	e2833001 	add	r3, r3, #1
   1f7a0:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1f7a4:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f7a8:	e3530007 	cmp	r3, #7
   1f7ac:	da000009 	ble	1f7d8 <_svfiprintf_r+0x1348>
   1f7b0:	e24b3074 	sub	r3, fp, #116	; 0x74
   1f7b4:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1f7b8:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   1f7bc:	e1a02003 	mov	r2, r3
   1f7c0:	ebfffa75 	bl	1e19c <__ssprint_r>
   1f7c4:	e1a03000 	mov	r3, r0
   1f7c8:	e3530000 	cmp	r3, #0
   1f7cc:	0a000000 	beq	1f7d4 <_svfiprintf_r+0x1344>
   1f7d0:	ea00004a 	b	1f900 <_svfiprintf_r+0x1470>
   1f7d4:	e24b50b4 	sub	r5, fp, #180	; 0xb4
   1f7d8:	e2477010 	sub	r7, r7, #16
   1f7dc:	e3570010 	cmp	r7, #16
   1f7e0:	caffffe4 	bgt	1f778 <_svfiprintf_r+0x12e8>
   1f7e4:	e59f3178 	ldr	r3, [pc, #376]	; 1f964 <_svfiprintf_r+0x14d4>
   1f7e8:	e5853000 	str	r3, [r5]
   1f7ec:	e1a03007 	mov	r3, r7
   1f7f0:	e5853004 	str	r3, [r5, #4]
   1f7f4:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1f7f8:	e0833007 	add	r3, r3, r7
   1f7fc:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
   1f800:	e2855008 	add	r5, r5, #8
   1f804:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f808:	e2833001 	add	r3, r3, #1
   1f80c:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1f810:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1f814:	e3530007 	cmp	r3, #7
   1f818:	da000009 	ble	1f844 <_svfiprintf_r+0x13b4>
   1f81c:	e24b3074 	sub	r3, fp, #116	; 0x74
   1f820:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1f824:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   1f828:	e1a02003 	mov	r2, r3
   1f82c:	ebfffa5a 	bl	1e19c <__ssprint_r>
   1f830:	e1a03000 	mov	r3, r0
   1f834:	e3530000 	cmp	r3, #0
   1f838:	0a000000 	beq	1f840 <_svfiprintf_r+0x13b0>
   1f83c:	ea00002f 	b	1f900 <_svfiprintf_r+0x1470>
   1f840:	e24b50b4 	sub	r5, fp, #180	; 0xb4

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   1f844:	e51b2050 	ldr	r2, [fp, #-80]	; 0x50
   1f848:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1f84c:	e1520003 	cmp	r2, r3
   1f850:	a1a03002 	movge	r3, r2
   1f854:	b1a03003 	movlt	r3, r3
   1f858:	e51b2020 	ldr	r2, [fp, #-32]
   1f85c:	e0823003 	add	r3, r2, r3
   1f860:	e50b3020 	str	r3, [fp, #-32]

		FLUSH ();	/* copy out the I/O vectors */
   1f864:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1f868:	e3530000 	cmp	r3, #0
   1f86c:	0a000008 	beq	1f894 <_svfiprintf_r+0x1404>
   1f870:	e24b3074 	sub	r3, fp, #116	; 0x74
   1f874:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1f878:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   1f87c:	e1a02003 	mov	r2, r3
   1f880:	ebfffa45 	bl	1e19c <__ssprint_r>
   1f884:	e1a03000 	mov	r3, r0
   1f888:	e3530000 	cmp	r3, #0
   1f88c:	0a000000 	beq	1f894 <_svfiprintf_r+0x1404>
   1f890:	ea00001a 	b	1f900 <_svfiprintf_r+0x1470>
   1f894:	e3a03000 	mov	r3, #0
   1f898:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1f89c:	e24b50b4 	sub	r5, fp, #180	; 0xb4

                if (malloc_buf != NULL) {
   1f8a0:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1f8a4:	e3530000 	cmp	r3, #0
   1f8a8:	0a000004 	beq	1f8c0 <_svfiprintf_r+0x1430>
			_free_r (data, malloc_buf);
   1f8ac:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1f8b0:	e51b105c 	ldr	r1, [fp, #-92]	; 0x5c
   1f8b4:	ebffe7f8 	bl	1989c <_free_r>
			malloc_buf = NULL;
   1f8b8:	e3a03000 	mov	r3, #0
   1f8bc:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
		}
	}
   1f8c0:	eafffb2f 	b	1e584 <_svfiprintf_r+0xf4>
done:
	FLUSH ();
   1f8c4:	e51b306c 	ldr	r3, [fp, #-108]	; 0x6c
   1f8c8:	e3530000 	cmp	r3, #0
   1f8cc:	0a000008 	beq	1f8f4 <_svfiprintf_r+0x1464>
   1f8d0:	e24b3074 	sub	r3, fp, #116	; 0x74
   1f8d4:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1f8d8:	e51b1124 	ldr	r1, [fp, #-292]	; 0x124
   1f8dc:	e1a02003 	mov	r2, r3
   1f8e0:	ebfffa2d 	bl	1e19c <__ssprint_r>
   1f8e4:	e1a03000 	mov	r3, r0
   1f8e8:	e3530000 	cmp	r3, #0
   1f8ec:	0a000000 	beq	1f8f4 <_svfiprintf_r+0x1464>
   1f8f0:	ea000002 	b	1f900 <_svfiprintf_r+0x1470>
   1f8f4:	e3a03000 	mov	r3, #0
   1f8f8:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1f8fc:	e24b50b4 	sub	r5, fp, #180	; 0xb4
error:
	if (malloc_buf != NULL)
   1f900:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   1f904:	e3530000 	cmp	r3, #0
   1f908:	0a000002 	beq	1f918 <_svfiprintf_r+0x1488>
		_free_r (data, malloc_buf);
   1f90c:	e51b0120 	ldr	r0, [fp, #-288]	; 0x120
   1f910:	e51b105c 	ldr	r1, [fp, #-92]	; 0x5c
   1f914:	ebffe7e0 	bl	1989c <_free_r>
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
#endif
	return (__sferror (fp) ? EOF : ret);
   1f918:	e51b3124 	ldr	r3, [fp, #-292]	; 0x124
   1f91c:	e1d330bc 	ldrh	r3, [r3, #12]
   1f920:	e1a03803 	lsl	r3, r3, #16
   1f924:	e1a03823 	lsr	r3, r3, #16
   1f928:	e2033040 	and	r3, r3, #64	; 0x40
   1f92c:	e3530000 	cmp	r3, #0
   1f930:	1a000001 	bne	1f93c <_svfiprintf_r+0x14ac>
   1f934:	e51b3020 	ldr	r3, [fp, #-32]
   1f938:	ea000000 	b	1f940 <_svfiprintf_r+0x14b0>
   1f93c:	e3e03000 	mvn	r3, #0
   1f940:	e1a00000 	nop			; (mov r0, r0)
	/* NOTREACHED */
}
   1f944:	e1a00003 	mov	r0, r3
   1f948:	e24bd01c 	sub	sp, fp, #28
   1f94c:	e8bd4bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, lr}
   1f950:	e12fff1e 	bx	lr
   1f954:	00024958 	.word	0x00024958
   1f958:	0002496c 	.word	0x0002496c
   1f95c:	00024974 	.word	0x00024974
   1f960:	00024988 	.word	0x00024988
   1f964:	000249a4 	.word	0x000249a4
   1f968:	000249b4 	.word	0x000249b4

0001f96c <__sprint_r>:
int
_DEFUN(__sprint_r, (ptr, fp, uio),
       struct _reent *ptr _AND
       FILE *fp _AND
       register struct __suio *uio)
{
   1f96c:	e92d4830 	push	{r4, r5, fp, lr}
   1f970:	e28db00c 	add	fp, sp, #12
   1f974:	e24dd018 	sub	sp, sp, #24
   1f978:	e50b0020 	str	r0, [fp, #-32]
   1f97c:	e50b1024 	str	r1, [fp, #-36]	; 0x24
   1f980:	e1a04002 	mov	r4, r2
	register int err = 0;
   1f984:	e3a05000 	mov	r5, #0

	if (uio->uio_resid == 0) {
   1f988:	e5943008 	ldr	r3, [r4, #8]
   1f98c:	e3530000 	cmp	r3, #0
   1f990:	1a000003 	bne	1f9a4 <__sprint_r+0x38>
		uio->uio_iovcnt = 0;
   1f994:	e3a03000 	mov	r3, #0
   1f998:	e5843004 	str	r3, [r4, #4]
		return (0);
   1f99c:	e3a03000 	mov	r3, #0
   1f9a0:	ea00003d 	b	1fa9c <__sprint_r+0x130>
	}
#ifdef _WIDE_ORIENT
	if (fp->_flags2 & __SWID) {
   1f9a4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   1f9a8:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
   1f9ac:	e2033a02 	and	r3, r3, #8192	; 0x2000
   1f9b0:	e3530000 	cmp	r3, #0
   1f9b4:	0a00002e 	beq	1fa74 <__sprint_r+0x108>
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
   1f9b8:	e5943000 	ldr	r3, [r4]
   1f9bc:	e50b3010 	str	r3, [fp, #-16]
		for (; uio->uio_resid != 0;
   1f9c0:	ea000027 	b	1fa64 <__sprint_r+0xf8>
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
   1f9c4:	e51b3010 	ldr	r3, [fp, #-16]
   1f9c8:	e5933000 	ldr	r3, [r3]
   1f9cc:	e50b3018 	str	r3, [fp, #-24]
			len = iov->iov_len / sizeof (wchar_t);
   1f9d0:	e51b3010 	ldr	r3, [fp, #-16]
   1f9d4:	e5933004 	ldr	r3, [r3, #4]
   1f9d8:	e1a03123 	lsr	r3, r3, #2
   1f9dc:	e50b301c 	str	r3, [fp, #-28]
			for (i = 0; i < len; i++) {
   1f9e0:	e3a03000 	mov	r3, #0
   1f9e4:	e50b3014 	str	r3, [fp, #-20]
   1f9e8:	ea000010 	b	1fa30 <__sprint_r+0xc4>
				if (_fputwc_r (ptr, p[i], fp) == WEOF) {
   1f9ec:	e51b3014 	ldr	r3, [fp, #-20]
   1f9f0:	e1a03103 	lsl	r3, r3, #2
   1f9f4:	e51b2018 	ldr	r2, [fp, #-24]
   1f9f8:	e0823003 	add	r3, r2, r3
   1f9fc:	e5933000 	ldr	r3, [r3]
   1fa00:	e51b0020 	ldr	r0, [fp, #-32]
   1fa04:	e1a01003 	mov	r1, r3
   1fa08:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   1fa0c:	eb0007eb 	bl	219c0 <_fputwc_r>
   1fa10:	e1a03000 	mov	r3, r0
   1fa14:	e3730001 	cmn	r3, #1
   1fa18:	1a000001 	bne	1fa24 <__sprint_r+0xb8>
					err = -1;
   1fa1c:	e3e05000 	mvn	r5, #0
					goto out;
   1fa20:	ea000018 	b	1fa88 <__sprint_r+0x11c>
		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
			p = (wchar_t *) iov->iov_base;
			len = iov->iov_len / sizeof (wchar_t);
			for (i = 0; i < len; i++) {
   1fa24:	e51b3014 	ldr	r3, [fp, #-20]
   1fa28:	e2833001 	add	r3, r3, #1
   1fa2c:	e50b3014 	str	r3, [fp, #-20]
   1fa30:	e51b2014 	ldr	r2, [fp, #-20]
   1fa34:	e51b301c 	ldr	r3, [fp, #-28]
   1fa38:	e1520003 	cmp	r2, r3
   1fa3c:	baffffea 	blt	1f9ec <__sprint_r+0x80>
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
		     uio->uio_resid -= len * sizeof (wchar_t), iov++) {
   1fa40:	e5943008 	ldr	r3, [r4, #8]
   1fa44:	e1a02003 	mov	r2, r3
   1fa48:	e51b301c 	ldr	r3, [fp, #-28]
   1fa4c:	e1a03103 	lsl	r3, r3, #2
   1fa50:	e0633002 	rsb	r3, r3, r2
   1fa54:	e5843008 	str	r3, [r4, #8]
   1fa58:	e51b3010 	ldr	r3, [fp, #-16]
   1fa5c:	e2833008 	add	r3, r3, #8
   1fa60:	e50b3010 	str	r3, [fp, #-16]
		struct __siov *iov;
		wchar_t *p;
		int i, len;

		iov = uio->uio_iov;
		for (; uio->uio_resid != 0;
   1fa64:	e5943008 	ldr	r3, [r4, #8]
   1fa68:	e3530000 	cmp	r3, #0
   1fa6c:	1affffd4 	bne	1f9c4 <__sprint_r+0x58>
   1fa70:	ea000004 	b	1fa88 <__sprint_r+0x11c>
				}
			}
		}
	} else
#endif
		err = __sfvwrite_r(ptr, fp, uio);
   1fa74:	e51b0020 	ldr	r0, [fp, #-32]
   1fa78:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
   1fa7c:	e1a02004 	mov	r2, r4
   1fa80:	ebffe94b 	bl	19fb4 <__sfvwrite_r>
   1fa84:	e1a05000 	mov	r5, r0
out:
	uio->uio_resid = 0;
   1fa88:	e3a03000 	mov	r3, #0
   1fa8c:	e5843008 	str	r3, [r4, #8]
	uio->uio_iovcnt = 0;
   1fa90:	e3a03000 	mov	r3, #0
   1fa94:	e5843004 	str	r3, [r4, #4]
	return (err);
   1fa98:	e1a03005 	mov	r3, r5
}
   1fa9c:	e1a00003 	mov	r0, r3
   1faa0:	e24bd00c 	sub	sp, fp, #12
   1faa4:	e8bd4830 	pop	{r4, r5, fp, lr}
   1faa8:	e12fff1e 	bx	lr

0001faac <__sbprintf>:
_DEFUN(__sbprintf, (rptr, fp, fmt, ap),
       struct _reent *rptr _AND
       register FILE *fp   _AND
       _CONST char *fmt  _AND
       va_list ap)
{
   1faac:	e92d4810 	push	{r4, fp, lr}
   1fab0:	e28db008 	add	fp, sp, #8
   1fab4:	e24ddd12 	sub	sp, sp, #1152	; 0x480
   1fab8:	e24dd00c 	sub	sp, sp, #12
   1fabc:	e50b0488 	str	r0, [fp, #-1160]	; 0x488
   1fac0:	e1a04001 	mov	r4, r1
   1fac4:	e50b248c 	str	r2, [fp, #-1164]	; 0x48c
   1fac8:	e50b3490 	str	r3, [fp, #-1168]	; 0x490
	int ret;
	FILE fake;
	unsigned char buf[BUFSIZ];

	/* copy the important variables */
	fake._flags = fp->_flags & ~__SNBF;
   1facc:	e1d430bc 	ldrh	r3, [r4, #12]
   1fad0:	e3c33002 	bic	r3, r3, #2
   1fad4:	e1a03803 	lsl	r3, r3, #16
   1fad8:	e1a03823 	lsr	r3, r3, #16
   1fadc:	e14b37b8 	strh	r3, [fp, #-120]	; 0xffffff88
	fake._flags2 = fp->_flags2;
   1fae0:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
   1fae4:	e50b3018 	str	r3, [fp, #-24]
	fake._file = fp->_file;
   1fae8:	e1d430be 	ldrh	r3, [r4, #14]
   1faec:	e14b37b6 	strh	r3, [fp, #-118]	; 0xffffff8a
	fake._cookie = fp->_cookie;
   1faf0:	e594301c 	ldr	r3, [r4, #28]
   1faf4:	e50b3068 	str	r3, [fp, #-104]	; 0x68
	fake._write = fp->_write;
   1faf8:	e5943024 	ldr	r3, [r4, #36]	; 0x24
   1fafc:	e50b3060 	str	r3, [fp, #-96]	; 0x60

	/* set up the buffer */
	fake._bf._base = fake._p = buf;
   1fb00:	e24b3e47 	sub	r3, fp, #1136	; 0x470
   1fb04:	e243300c 	sub	r3, r3, #12
   1fb08:	e2433008 	sub	r3, r3, #8
   1fb0c:	e50b3084 	str	r3, [fp, #-132]	; 0x84
   1fb10:	e51b3084 	ldr	r3, [fp, #-132]	; 0x84
   1fb14:	e50b3074 	str	r3, [fp, #-116]	; 0x74
	fake._bf._size = fake._w = sizeof (buf);
   1fb18:	e3a03b01 	mov	r3, #1024	; 0x400
   1fb1c:	e50b307c 	str	r3, [fp, #-124]	; 0x7c
   1fb20:	e51b307c 	ldr	r3, [fp, #-124]	; 0x7c
   1fb24:	e50b3070 	str	r3, [fp, #-112]	; 0x70
	fake._lbfsize = 0;	/* not actually used, but Just In Case */
   1fb28:	e3a03000 	mov	r3, #0
   1fb2c:	e50b306c 	str	r3, [fp, #-108]	; 0x6c
#ifndef __SINGLE_THREAD__
	__lock_init_recursive (fake._lock);
   1fb30:	e24b3084 	sub	r3, fp, #132	; 0x84
   1fb34:	e283305c 	add	r3, r3, #92	; 0x5c
   1fb38:	e1a00003 	mov	r0, r3
   1fb3c:	ebffbb5e 	bl	e8bc <_dna_lock_init>
#endif

	/* do the work, then copy any error status */
	ret = _VFPRINTF_R (rptr, &fake, fmt, ap);
   1fb40:	e24b3084 	sub	r3, fp, #132	; 0x84
   1fb44:	e51b0488 	ldr	r0, [fp, #-1160]	; 0x488
   1fb48:	e1a01003 	mov	r1, r3
   1fb4c:	e51b248c 	ldr	r2, [fp, #-1164]	; 0x48c
   1fb50:	e51b3490 	ldr	r3, [fp, #-1168]	; 0x490
   1fb54:	eb000034 	bl	1fc2c <_vfiprintf_r>
   1fb58:	e50b0010 	str	r0, [fp, #-16]
	if (ret >= 0 && _fflush_r (rptr, &fake))
   1fb5c:	e51b3010 	ldr	r3, [fp, #-16]
   1fb60:	e3530000 	cmp	r3, #0
   1fb64:	ba000008 	blt	1fb8c <__sbprintf+0xe0>
   1fb68:	e24b3084 	sub	r3, fp, #132	; 0x84
   1fb6c:	e51b0488 	ldr	r0, [fp, #-1160]	; 0x488
   1fb70:	e1a01003 	mov	r1, r3
   1fb74:	ebffe566 	bl	19114 <_fflush_r>
   1fb78:	e1a03000 	mov	r3, r0
   1fb7c:	e3530000 	cmp	r3, #0
   1fb80:	0a000001 	beq	1fb8c <__sbprintf+0xe0>
		ret = EOF;
   1fb84:	e3e03000 	mvn	r3, #0
   1fb88:	e50b3010 	str	r3, [fp, #-16]
	if (fake._flags & __SERR)
   1fb8c:	e15b37b8 	ldrh	r3, [fp, #-120]	; 0xffffff88
   1fb90:	e1a03803 	lsl	r3, r3, #16
   1fb94:	e1a03823 	lsr	r3, r3, #16
   1fb98:	e2033040 	and	r3, r3, #64	; 0x40
   1fb9c:	e3530000 	cmp	r3, #0
   1fba0:	0a000004 	beq	1fbb8 <__sbprintf+0x10c>
		fp->_flags |= __SERR;
   1fba4:	e1d430bc 	ldrh	r3, [r4, #12]
   1fba8:	e3833040 	orr	r3, r3, #64	; 0x40
   1fbac:	e1a03803 	lsl	r3, r3, #16
   1fbb0:	e1a03823 	lsr	r3, r3, #16
   1fbb4:	e1c430bc 	strh	r3, [r4, #12]

#ifndef __SINGLE_THREAD__
	__lock_close_recursive (fake._lock);
   1fbb8:	e24b3084 	sub	r3, fp, #132	; 0x84
   1fbbc:	e283305c 	add	r3, r3, #92	; 0x5c
   1fbc0:	e1a00003 	mov	r0, r3
   1fbc4:	ebffbb68 	bl	e96c <_dna_lock_close>
#endif
	return (ret);
   1fbc8:	e51b3010 	ldr	r3, [fp, #-16]
}
   1fbcc:	e1a00003 	mov	r0, r3
   1fbd0:	e24bd008 	sub	sp, fp, #8
   1fbd4:	e8bd4810 	pop	{r4, fp, lr}
   1fbd8:	e12fff1e 	bx	lr

0001fbdc <vfiprintf>:
int
_DEFUN(VFPRINTF, (fp, fmt0, ap),
       FILE * fp         _AND
       _CONST char *fmt0 _AND
       va_list ap)
{
   1fbdc:	e92d4800 	push	{fp, lr}
   1fbe0:	e28db004 	add	fp, sp, #4
   1fbe4:	e24dd018 	sub	sp, sp, #24
   1fbe8:	e50b0010 	str	r0, [fp, #-16]
   1fbec:	e50b1014 	str	r1, [fp, #-20]
   1fbf0:	e50b2018 	str	r2, [fp, #-24]
  int result;
  result = _VFPRINTF_R (_REENT, fp, fmt0, ap);
   1fbf4:	e59f302c 	ldr	r3, [pc, #44]	; 1fc28 <vfiprintf+0x4c>
   1fbf8:	e5933000 	ldr	r3, [r3]
   1fbfc:	e1a00003 	mov	r0, r3
   1fc00:	e51b1010 	ldr	r1, [fp, #-16]
   1fc04:	e51b2014 	ldr	r2, [fp, #-20]
   1fc08:	e51b3018 	ldr	r3, [fp, #-24]
   1fc0c:	eb000006 	bl	1fc2c <_vfiprintf_r>
   1fc10:	e50b0008 	str	r0, [fp, #-8]
  return result;
   1fc14:	e51b3008 	ldr	r3, [fp, #-8]
}
   1fc18:	e1a00003 	mov	r0, r3
   1fc1c:	e24bd004 	sub	sp, fp, #4
   1fc20:	e8bd4800 	pop	{fp, lr}
   1fc24:	e12fff1e 	bx	lr
   1fc28:	00025440 	.word	0x00025440

0001fc2c <_vfiprintf_r>:
_DEFUN(_VFPRINTF_R, (data, fp, fmt0, ap),
       struct _reent *data _AND
       FILE * fp           _AND
       _CONST char *fmt0   _AND
       va_list ap)
{
   1fc2c:	e92d4bf0 	push	{r4, r5, r6, r7, r8, r9, fp, lr}
   1fc30:	e28db01c 	add	fp, sp, #28
   1fc34:	e24ddf4a 	sub	sp, sp, #296	; 0x128
   1fc38:	e50b0128 	str	r0, [fp, #-296]	; 0x128
   1fc3c:	e50b112c 	str	r1, [fp, #-300]	; 0x12c
   1fc40:	e50b2130 	str	r2, [fp, #-304]	; 0x130
   1fc44:	e50b3134 	str	r3, [fp, #-308]	; 0x134
	int width;		/* width from format (%8d), or 0 */
	int prec;		/* precision from format (%.3d), or -1 */
	char sign;		/* sign prefix (' ', '+', '-', or \0) */
#ifdef _WANT_IO_C99_FORMATS
				/* locale specific numeric grouping */
	char *thousands_sep = NULL;
   1fc48:	e3a03000 	mov	r3, #0
   1fc4c:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
	size_t thsnd_len = 0;
   1fc50:	e3a03000 	mov	r3, #0
   1fc54:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	const char *grouping = NULL;
   1fc58:	e3a03000 	mov	r3, #0
   1fc5c:	e50b3034 	str	r3, [fp, #-52]	; 0x34
	int expsize = 0;	/* character count for expstr */
	char expstr[MAXEXPLEN];	/* buffer for exponent string */
	int lead;		/* sig figs before decimal or group sep */
#endif /* FLOATING_POINT */
#if defined (FLOATING_POINT) || defined (_WANT_IO_C99_FORMATS)
	int ndig = 0;		/* actual number of digits returned by cvt */
   1fc60:	e3a03000 	mov	r3, #0
   1fc64:	e50b3038 	str	r3, [fp, #-56]	; 0x38
	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
   1fc68:	e3a03000 	mov	r3, #0
   1fc6c:	e50b3058 	str	r3, [fp, #-88]	; 0x58
	char ox[2];		/* space for 0x hex-prefix */
#ifdef _MB_CAPABLE
	wchar_t wc;
	mbstate_t state;        /* mbtowc calls from library must not change state */
#endif
	char *malloc_buf = NULL;/* handy pointer for malloced buffers */
   1fc70:	e3a03000 	mov	r3, #0
   1fc74:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
	    (u_long)GET_ARG (N, ap, u_int))
#endif

#ifndef STRING_ONLY
	/* Initialize std streams if not dealing with sprintf family.  */
    CHECK_INIT (data, fp);
   1fc78:	e51b3128 	ldr	r3, [fp, #-296]	; 0x128
   1fc7c:	e50b3060 	str	r3, [fp, #-96]	; 0x60
   1fc80:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   1fc84:	e3530000 	cmp	r3, #0
   1fc88:	0a000005 	beq	1fca4 <_vfiprintf_r+0x78>
   1fc8c:	e51b3060 	ldr	r3, [fp, #-96]	; 0x60
   1fc90:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   1fc94:	e3530000 	cmp	r3, #0
   1fc98:	1a000001 	bne	1fca4 <_vfiprintf_r+0x78>
   1fc9c:	e51b0060 	ldr	r0, [fp, #-96]	; 0x60
   1fca0:	ebffe666 	bl	19640 <__sinit>
    cpu_dcache_invalidate((void*)&(fp->_flags), sizeof(short));
   1fca4:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fca8:	e283300c 	add	r3, r3, #12
   1fcac:	e1a00003 	mov	r0, r3
   1fcb0:	e3a01002 	mov	r1, #2
   1fcb4:	ebffa7fd 	bl	9cb0 <cpu_dcache_invalidate>
    cpu_dcache_invalidate((void*)&(fp->_lock) , sizeof(_flock_t));
   1fcb8:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fcbc:	e283305c 	add	r3, r3, #92	; 0x5c
   1fcc0:	e1a00003 	mov	r0, r3
   1fcc4:	e3a01008 	mov	r1, #8
   1fcc8:	ebffa7f8 	bl	9cb0 <cpu_dcache_invalidate>
	_newlib_flockfile_start (fp);
   1fccc:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fcd0:	e1d330bc 	ldrh	r3, [r3, #12]
   1fcd4:	e1a03803 	lsl	r3, r3, #16
   1fcd8:	e1a03823 	lsr	r3, r3, #16
   1fcdc:	e2033c02 	and	r3, r3, #512	; 0x200
   1fce0:	e3530000 	cmp	r3, #0
   1fce4:	1a000003 	bne	1fcf8 <_vfiprintf_r+0xcc>
   1fce8:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fcec:	e283305c 	add	r3, r3, #92	; 0x5c
   1fcf0:	e1a00003 	mov	r0, r3
   1fcf4:	ebffbb41 	bl	ea00 <_dna_lock_acquire>

    cpu_dcache_invalidate((void*)&(fp), sizeof(struct __sFILE));
   1fcf8:	e24b3f4b 	sub	r3, fp, #300	; 0x12c
   1fcfc:	e1a00003 	mov	r0, r3
   1fd00:	e3a01070 	mov	r1, #112	; 0x70
   1fd04:	ebffa7e9 	bl	9cb0 <cpu_dcache_invalidate>
    cpu_dcache_invalidate((void*)&(fp->_flags) ,sizeof(short));
   1fd08:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fd0c:	e283300c 	add	r3, r3, #12
   1fd10:	e1a00003 	mov	r0, r3
   1fd14:	e3a01002 	mov	r1, #2
   1fd18:	ebffa7e4 	bl	9cb0 <cpu_dcache_invalidate>
    cpu_dcache_invalidate((void*)&(fp->_flags2), sizeof(int));
   1fd1c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fd20:	e283306c 	add	r3, r3, #108	; 0x6c
   1fd24:	e1a00003 	mov	r0, r3
   1fd28:	e3a01004 	mov	r1, #4
   1fd2c:	ebffa7df 	bl	9cb0 <cpu_dcache_invalidate>
    ORIENT(fp, -1);
   1fd30:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fd34:	e1d330bc 	ldrh	r3, [r3, #12]
   1fd38:	e1a03803 	lsl	r3, r3, #16
   1fd3c:	e1a03823 	lsr	r3, r3, #16
   1fd40:	e2033a02 	and	r3, r3, #8192	; 0x2000
   1fd44:	e3530000 	cmp	r3, #0
   1fd48:	1a00000b 	bne	1fd7c <_vfiprintf_r+0x150>
   1fd4c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fd50:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   1fd54:	e1d220bc 	ldrh	r2, [r2, #12]
   1fd58:	e3822a02 	orr	r2, r2, #8192	; 0x2000
   1fd5c:	e1a02802 	lsl	r2, r2, #16
   1fd60:	e1a02822 	lsr	r2, r2, #16
   1fd64:	e1c320bc 	strh	r2, [r3, #12]
   1fd68:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fd6c:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   1fd70:	e592206c 	ldr	r2, [r2, #108]	; 0x6c
   1fd74:	e3c22a02 	bic	r2, r2, #8192	; 0x2000
   1fd78:	e583206c 	str	r2, [r3, #108]	; 0x6c

	/* sorry, fprintf(read_only_file, "") returns EOF, not 0 */
	if (cantwrite (data, fp)) {
   1fd7c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fd80:	e1d330bc 	ldrh	r3, [r3, #12]
   1fd84:	e1a03803 	lsl	r3, r3, #16
   1fd88:	e1a03823 	lsr	r3, r3, #16
   1fd8c:	e2033008 	and	r3, r3, #8
   1fd90:	e3530000 	cmp	r3, #0
   1fd94:	0a000003 	beq	1fda8 <_vfiprintf_r+0x17c>
   1fd98:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fd9c:	e5933010 	ldr	r3, [r3, #16]
   1fda0:	e3530000 	cmp	r3, #0
   1fda4:	1a000013 	bne	1fdf8 <_vfiprintf_r+0x1cc>
   1fda8:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fdac:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   1fdb0:	e1a01003 	mov	r1, r3
   1fdb4:	ebffdb57 	bl	16b18 <__swsetup_r>
   1fdb8:	e1a03000 	mov	r3, r0
   1fdbc:	e3530000 	cmp	r3, #0
   1fdc0:	0a00000c 	beq	1fdf8 <_vfiprintf_r+0x1cc>
		_newlib_flockfile_exit (fp);
   1fdc4:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fdc8:	e1d330bc 	ldrh	r3, [r3, #12]
   1fdcc:	e1a03803 	lsl	r3, r3, #16
   1fdd0:	e1a03823 	lsr	r3, r3, #16
   1fdd4:	e2033c02 	and	r3, r3, #512	; 0x200
   1fdd8:	e3530000 	cmp	r3, #0
   1fddc:	1a000003 	bne	1fdf0 <_vfiprintf_r+0x1c4>
   1fde0:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fde4:	e283305c 	add	r3, r3, #92	; 0x5c
   1fde8:	e1a00003 	mov	r0, r3
   1fdec:	ebffbb6a 	bl	eb9c <_dna_lock_release>
		return (EOF);
   1fdf0:	e3e03000 	mvn	r3, #0
   1fdf4:	ea000531 	b	212c0 <_vfiprintf_r+0x1694>
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   1fdf8:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fdfc:	e1d330bc 	ldrh	r3, [r3, #12]
   1fe00:	e1a03803 	lsl	r3, r3, #16
   1fe04:	e1a03823 	lsr	r3, r3, #16
   1fe08:	e203301a 	and	r3, r3, #26
   1fe0c:	e353000a 	cmp	r3, #10
   1fe10:	1a000018 	bne	1fe78 <_vfiprintf_r+0x24c>
	    fp->_file >= 0) {
   1fe14:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fe18:	e1d330be 	ldrh	r3, [r3, #14]
		return (EOF);
	}

#ifdef _UNBUF_STREAM_OPT
	/* optimise fprintf(stderr) (and other unbuffered Unix files) */
	if ((fp->_flags & (__SNBF|__SWR|__SRW)) == (__SNBF|__SWR) &&
   1fe1c:	e1a03803 	lsl	r3, r3, #16
   1fe20:	e1a03843 	asr	r3, r3, #16
   1fe24:	e3530000 	cmp	r3, #0
   1fe28:	ba000012 	blt	1fe78 <_vfiprintf_r+0x24c>
	    fp->_file >= 0) {
		_newlib_flockfile_exit (fp);
   1fe2c:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fe30:	e1d330bc 	ldrh	r3, [r3, #12]
   1fe34:	e1a03803 	lsl	r3, r3, #16
   1fe38:	e1a03823 	lsr	r3, r3, #16
   1fe3c:	e2033c02 	and	r3, r3, #512	; 0x200
   1fe40:	e3530000 	cmp	r3, #0
   1fe44:	1a000003 	bne	1fe58 <_vfiprintf_r+0x22c>
   1fe48:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fe4c:	e283305c 	add	r3, r3, #92	; 0x5c
   1fe50:	e1a00003 	mov	r0, r3
   1fe54:	ebffbb50 	bl	eb9c <_dna_lock_release>
		return (__sbprintf (data, fp, fmt0, ap));
   1fe58:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   1fe5c:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   1fe60:	e1a01003 	mov	r1, r3
   1fe64:	e51b2130 	ldr	r2, [fp, #-304]	; 0x130
   1fe68:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   1fe6c:	ebffff0e 	bl	1faac <__sbprintf>
   1fe70:	e1a03000 	mov	r3, r0
   1fe74:	ea000511 	b	212c0 <_vfiprintf_r+0x1694>
		}
		fp->_bf._size = 64;
        }
#endif /* STRING_ONLY */

	fmt = (char *)fmt0;
   1fe78:	e51b8130 	ldr	r8, [fp, #-304]	; 0x130
#ifdef _FVWRITE_IN_STREAMIO
	uio.uio_iov = iovp = iov;
   1fe7c:	e24b50b8 	sub	r5, fp, #184	; 0xb8
   1fe80:	e50b5078 	str	r5, [fp, #-120]	; 0x78
	uio.uio_resid = 0;
   1fe84:	e3a03000 	mov	r3, #0
   1fe88:	e50b3070 	str	r3, [fp, #-112]	; 0x70
	uio.uio_iovcnt = 0;
   1fe8c:	e3a03000 	mov	r3, #0
   1fe90:	e50b3074 	str	r3, [fp, #-116]	; 0x74
#endif
	ret = 0;
   1fe94:	e3a03000 	mov	r3, #0
   1fe98:	e50b3020 	str	r3, [fp, #-32]

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
	        cp = fmt;
   1fe9c:	e1a06008 	mov	r6, r8
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   1fea0:	ea000000 	b	1fea8 <_vfiprintf_r+0x27c>
                    fmt += 1;
   1fea4:	e2888001 	add	r8, r8, #1
                    else if (wc == '%')
                        break;
                    fmt += n;
		}
#else
                while (*fmt != '\0' && *fmt != '%')
   1fea8:	e5d83000 	ldrb	r3, [r8]
   1feac:	e3530000 	cmp	r3, #0
   1feb0:	0a000002 	beq	1fec0 <_vfiprintf_r+0x294>
   1feb4:	e5d83000 	ldrb	r3, [r8]
   1feb8:	e3530025 	cmp	r3, #37	; 0x25
   1febc:	1afffff8 	bne	1fea4 <_vfiprintf_r+0x278>
                    fmt += 1;
#endif
		if ((m = fmt - cp) != 0) {
   1fec0:	e1a02008 	mov	r2, r8
   1fec4:	e1a03006 	mov	r3, r6
   1fec8:	e0634002 	rsb	r4, r3, r2
   1fecc:	e3540000 	cmp	r4, #0
   1fed0:	0a00001a 	beq	1ff40 <_vfiprintf_r+0x314>
			PRINT (cp, m);
   1fed4:	e5856000 	str	r6, [r5]
   1fed8:	e1a03004 	mov	r3, r4
   1fedc:	e5853004 	str	r3, [r5, #4]
   1fee0:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   1fee4:	e0833004 	add	r3, r3, r4
   1fee8:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   1feec:	e2855008 	add	r5, r5, #8
   1fef0:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1fef4:	e2833001 	add	r3, r3, #1
   1fef8:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   1fefc:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   1ff00:	e3530007 	cmp	r3, #7
   1ff04:	da00000a 	ble	1ff34 <_vfiprintf_r+0x308>
   1ff08:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   1ff0c:	e24b3078 	sub	r3, fp, #120	; 0x78
   1ff10:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   1ff14:	e1a01002 	mov	r1, r2
   1ff18:	e1a02003 	mov	r2, r3
   1ff1c:	ebfffe92 	bl	1f96c <__sprint_r>
   1ff20:	e1a03000 	mov	r3, r0
   1ff24:	e3530000 	cmp	r3, #0
   1ff28:	0a000000 	beq	1ff30 <_vfiprintf_r+0x304>
   1ff2c:	ea0004c7 	b	21250 <_vfiprintf_r+0x1624>
   1ff30:	e24b50b8 	sub	r5, fp, #184	; 0xb8
			ret += m;
   1ff34:	e51b3020 	ldr	r3, [fp, #-32]
   1ff38:	e0833004 	add	r3, r3, r4
   1ff3c:	e50b3020 	str	r3, [fp, #-32]
		}
#ifdef _MB_CAPABLE
		if (n <= 0)
                    goto done;
#else
                if (*fmt == '\0')
   1ff40:	e5d83000 	ldrb	r3, [r8]
   1ff44:	e3530000 	cmp	r3, #0
   1ff48:	1a000000 	bne	1ff50 <_vfiprintf_r+0x324>
                    goto done;
   1ff4c:	ea0004af 	b	21210 <_vfiprintf_r+0x15e4>
#endif
		fmt_anchor = fmt;
   1ff50:	e50b8064 	str	r8, [fp, #-100]	; 0x64
		fmt++;		/* skip over '%' */
   1ff54:	e2888001 	add	r8, r8, #1

		flags = 0;
   1ff58:	e3a04000 	mov	r4, #0
		dprec = 0;
   1ff5c:	e3a03000 	mov	r3, #0
   1ff60:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
		width = 0;
   1ff64:	e3a03000 	mov	r3, #0
   1ff68:	e50b3024 	str	r3, [fp, #-36]	; 0x24
		prec = -1;
   1ff6c:	e3e03000 	mvn	r3, #0
   1ff70:	e50b3028 	str	r3, [fp, #-40]	; 0x28
		sign = '\0';
   1ff74:	e3a03000 	mov	r3, #0
   1ff78:	e54b3069 	strb	r3, [fp, #-105]	; 0x69
#ifndef _NO_POS_ARGS
		N = arg_index;
		is_pos_arg = 0;
#endif

rflag:		ch = *fmt++;
   1ff7c:	e1a03008 	mov	r3, r8
   1ff80:	e2838001 	add	r8, r3, #1
   1ff84:	e5d33000 	ldrb	r3, [r3]
   1ff88:	e1a09003 	mov	r9, r3
reswitch:	switch (ch) {
   1ff8c:	e2493020 	sub	r3, r9, #32
   1ff90:	e353005a 	cmp	r3, #90	; 0x5a
   1ff94:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
   1ff98:	ea000318 	b	20c00 <_vfiprintf_r+0xfd4>
   1ff9c:	0002016c 	.word	0x0002016c
   1ffa0:	00020c00 	.word	0x00020c00
   1ffa4:	00020c00 	.word	0x00020c00
   1ffa8:	00020184 	.word	0x00020184
   1ffac:	00020c00 	.word	0x00020c00
   1ffb0:	00020c00 	.word	0x00020c00
   1ffb4:	00020c00 	.word	0x00020c00
   1ffb8:	00020108 	.word	0x00020108
   1ffbc:	00020c00 	.word	0x00020c00
   1ffc0:	00020c00 	.word	0x00020c00
   1ffc4:	0002018c 	.word	0x0002018c
   1ffc8:	000201c4 	.word	0x000201c4
   1ffcc:	00020c00 	.word	0x00020c00
   1ffd0:	000201bc 	.word	0x000201bc
   1ffd4:	000201d0 	.word	0x000201d0
   1ffd8:	00020c00 	.word	0x00020c00
   1ffdc:	0002026c 	.word	0x0002026c
   1ffe0:	00020274 	.word	0x00020274
   1ffe4:	00020274 	.word	0x00020274
   1ffe8:	00020274 	.word	0x00020274
   1ffec:	00020274 	.word	0x00020274
   1fff0:	00020274 	.word	0x00020274
   1fff4:	00020274 	.word	0x00020274
   1fff8:	00020274 	.word	0x00020274
   1fffc:	00020274 	.word	0x00020274
   20000:	00020274 	.word	0x00020274
   20004:	00020c00 	.word	0x00020c00
   20008:	00020c00 	.word	0x00020c00
   2000c:	00020c00 	.word	0x00020c00
   20010:	00020c00 	.word	0x00020c00
   20014:	00020c00 	.word	0x00020c00
   20018:	00020c00 	.word	0x00020c00
   2001c:	00020c00 	.word	0x00020c00
   20020:	00020c00 	.word	0x00020c00
   20024:	00020c00 	.word	0x00020c00
   20028:	00020308 	.word	0x00020308
   2002c:	00020338 	.word	0x00020338
   20030:	00020c00 	.word	0x00020c00
   20034:	00020c00 	.word	0x00020c00
   20038:	00020c00 	.word	0x00020c00
   2003c:	00020c00 	.word	0x00020c00
   20040:	00020c00 	.word	0x00020c00
   20044:	00020c00 	.word	0x00020c00
   20048:	00020c00 	.word	0x00020c00
   2004c:	00020c00 	.word	0x00020c00
   20050:	00020c00 	.word	0x00020c00
   20054:	00020c00 	.word	0x00020c00
   20058:	00020528 	.word	0x00020528
   2005c:	00020c00 	.word	0x00020c00
   20060:	00020c00 	.word	0x00020c00
   20064:	00020c00 	.word	0x00020c00
   20068:	00020658 	.word	0x00020658
   2006c:	00020c00 	.word	0x00020c00
   20070:	00020718 	.word	0x00020718
   20074:	00020c00 	.word	0x00020c00
   20078:	00020c00 	.word	0x00020c00
   2007c:	000207f8 	.word	0x000207f8
   20080:	00020c00 	.word	0x00020c00
   20084:	00020c00 	.word	0x00020c00
   20088:	00020c00 	.word	0x00020c00
   2008c:	00020c00 	.word	0x00020c00
   20090:	00020c00 	.word	0x00020c00
   20094:	00020c00 	.word	0x00020c00
   20098:	00020c00 	.word	0x00020c00
   2009c:	00020c00 	.word	0x00020c00
   200a0:	00020c00 	.word	0x00020c00
   200a4:	00020c00 	.word	0x00020c00
   200a8:	00020308 	.word	0x00020308
   200ac:	0002033c 	.word	0x0002033c
   200b0:	00020c00 	.word	0x00020c00
   200b4:	00020c00 	.word	0x00020c00
   200b8:	00020c00 	.word	0x00020c00
   200bc:	000202b8 	.word	0x000202b8
   200c0:	0002033c 	.word	0x0002033c
   200c4:	00020300 	.word	0x00020300
   200c8:	00020c00 	.word	0x00020c00
   200cc:	000202d8 	.word	0x000202d8
   200d0:	00020c00 	.word	0x00020c00
   200d4:	00020458 	.word	0x00020458
   200d8:	0002052c 	.word	0x0002052c
   200dc:	0002060c 	.word	0x0002060c
   200e0:	000202f8 	.word	0x000202f8
   200e4:	00020c00 	.word	0x00020c00
   200e8:	00020658 	.word	0x00020658
   200ec:	0001ff7c 	.word	0x0001ff7c
   200f0:	0002071c 	.word	0x0002071c
   200f4:	00020c00 	.word	0x00020c00
   200f8:	00020c00 	.word	0x00020c00
   200fc:	00020804 	.word	0x00020804
   20100:	00020c00 	.word	0x00020c00
   20104:	0001ff7c 	.word	0x0001ff7c
#ifdef _WANT_IO_C99_FORMATS
		case '\'':
			thousands_sep = _localeconv_r (data)->thousands_sep;
   20108:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   2010c:	ebffea00 	bl	1a914 <_localeconv_r>
   20110:	e1a03000 	mov	r3, r0
   20114:	e5933004 	ldr	r3, [r3, #4]
   20118:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
			thsnd_len = strlen (thousands_sep);
   2011c:	e51b002c 	ldr	r0, [fp, #-44]	; 0x2c
   20120:	ebffc231 	bl	109ec <strlen>
   20124:	e50b0030 	str	r0, [fp, #-48]	; 0x30
			grouping = _localeconv_r (data)->grouping;
   20128:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   2012c:	ebffe9f8 	bl	1a914 <_localeconv_r>
   20130:	e1a03000 	mov	r3, r0
   20134:	e5933008 	ldr	r3, [r3, #8]
   20138:	e50b3034 	str	r3, [fp, #-52]	; 0x34
			if (thsnd_len > 0 && grouping && *grouping)
   2013c:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   20140:	e3530000 	cmp	r3, #0
   20144:	0a000007 	beq	20168 <_vfiprintf_r+0x53c>
   20148:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   2014c:	e3530000 	cmp	r3, #0
   20150:	0a000004 	beq	20168 <_vfiprintf_r+0x53c>
   20154:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   20158:	e5d33000 	ldrb	r3, [r3]
   2015c:	e3530000 	cmp	r3, #0
   20160:	0a000000 	beq	20168 <_vfiprintf_r+0x53c>
			  flags |= GROUPING;
   20164:	e3844b01 	orr	r4, r4, #1024	; 0x400
			goto rflag;
   20168:	eaffff83 	b	1ff7c <_vfiprintf_r+0x350>
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
   2016c:	e55b3069 	ldrb	r3, [fp, #-105]	; 0x69
   20170:	e3530000 	cmp	r3, #0
   20174:	1a000001 	bne	20180 <_vfiprintf_r+0x554>
				sign = ' ';
   20178:	e3a03020 	mov	r3, #32
   2017c:	e54b3069 	strb	r3, [fp, #-105]	; 0x69
			goto rflag;
   20180:	eaffff7d 	b	1ff7c <_vfiprintf_r+0x350>
		case '#':
			flags |= ALT;
   20184:	e3844001 	orr	r4, r4, #1
			goto rflag;
   20188:	eaffff7b 	b	1ff7c <_vfiprintf_r+0x350>
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			width = GET_ARG (n, ap, int);
   2018c:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   20190:	e2832004 	add	r2, r3, #4
   20194:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   20198:	e5933000 	ldr	r3, [r3]
   2019c:	e50b3024 	str	r3, [fp, #-36]	; 0x24
#ifndef _NO_POS_ARGS
			is_pos_arg = old_is_pos_arg;
#endif
			if (width >= 0)
   201a0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   201a4:	e3530000 	cmp	r3, #0
   201a8:	ba000000 	blt	201b0 <_vfiprintf_r+0x584>
				goto rflag;
   201ac:	eaffff72 	b	1ff7c <_vfiprintf_r+0x350>
			width = -width;
   201b0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   201b4:	e2633000 	rsb	r3, r3, #0
   201b8:	e50b3024 	str	r3, [fp, #-36]	; 0x24
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
   201bc:	e3844004 	orr	r4, r4, #4
			goto rflag;
   201c0:	eaffff6d 	b	1ff7c <_vfiprintf_r+0x350>
		case '+':
			sign = '+';
   201c4:	e3a0302b 	mov	r3, #43	; 0x2b
   201c8:	e54b3069 	strb	r3, [fp, #-105]	; 0x69
			goto rflag;
   201cc:	eaffff6a 	b	1ff7c <_vfiprintf_r+0x350>
		case '.':
			if ((ch = *fmt++) == '*') {
   201d0:	e1a03008 	mov	r3, r8
   201d4:	e2838001 	add	r8, r3, #1
   201d8:	e5d33000 	ldrb	r3, [r3]
   201dc:	e1a09003 	mov	r9, r3
   201e0:	e359002a 	cmp	r9, #42	; 0x2a
   201e4:	1a00000a 	bne	20214 <_vfiprintf_r+0x5e8>
						fmt = old_fmt;
						goto rflag;
					}
				}
#endif /* !_NO_POS_ARGS */
				prec = GET_ARG (n, ap, int);
   201e8:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   201ec:	e2832004 	add	r2, r3, #4
   201f0:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   201f4:	e5933000 	ldr	r3, [r3]
   201f8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
#ifndef _NO_POS_ARGS
				is_pos_arg = old_is_pos_arg;
#endif
				if (prec < 0)
   201fc:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   20200:	e3530000 	cmp	r3, #0
   20204:	aa000001 	bge	20210 <_vfiprintf_r+0x5e4>
					prec = -1;
   20208:	e3e03000 	mvn	r3, #0
   2020c:	e50b3028 	str	r3, [fp, #-40]	; 0x28
				goto rflag;
   20210:	eaffff59 	b	1ff7c <_vfiprintf_r+0x350>
			}
			n = 0;
   20214:	e3a07000 	mov	r7, #0
			while (is_digit (ch)) {
   20218:	ea00000a 	b	20248 <_vfiprintf_r+0x61c>
				n = 10 * n + to_digit (ch);
   2021c:	e1a03007 	mov	r3, r7
   20220:	e1a03103 	lsl	r3, r3, #2
   20224:	e0833007 	add	r3, r3, r7
   20228:	e1a03083 	lsl	r3, r3, #1
   2022c:	e1a02003 	mov	r2, r3
   20230:	e2493030 	sub	r3, r9, #48	; 0x30
   20234:	e0827003 	add	r7, r2, r3
				ch = *fmt++;
   20238:	e1a03008 	mov	r3, r8
   2023c:	e2838001 	add	r8, r3, #1
   20240:	e5d33000 	ldrb	r3, [r3]
   20244:	e1a09003 	mov	r9, r3
				if (prec < 0)
					prec = -1;
				goto rflag;
			}
			n = 0;
			while (is_digit (ch)) {
   20248:	e2493030 	sub	r3, r9, #48	; 0x30
   2024c:	e3530009 	cmp	r3, #9
   20250:	9afffff1 	bls	2021c <_vfiprintf_r+0x5f0>
				n = 10 * n + to_digit (ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
   20254:	e3e03000 	mvn	r3, #0
   20258:	e1570003 	cmp	r7, r3
   2025c:	a1a03007 	movge	r3, r7
   20260:	b1a03003 	movlt	r3, r3
   20264:	e50b3028 	str	r3, [fp, #-40]	; 0x28
			goto reswitch;
   20268:	eaffff47 	b	1ff8c <_vfiprintf_r+0x360>
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
   2026c:	e3844080 	orr	r4, r4, #128	; 0x80
			goto rflag;
   20270:	eaffff41 	b	1ff7c <_vfiprintf_r+0x350>
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
   20274:	e3a07000 	mov	r7, #0
			do {
				n = 10 * n + to_digit (ch);
   20278:	e1a03007 	mov	r3, r7
   2027c:	e1a03103 	lsl	r3, r3, #2
   20280:	e0833007 	add	r3, r3, r7
   20284:	e1a03083 	lsl	r3, r3, #1
   20288:	e1a02003 	mov	r2, r3
   2028c:	e2493030 	sub	r3, r9, #48	; 0x30
   20290:	e0827003 	add	r7, r2, r3
				ch = *fmt++;
   20294:	e1a03008 	mov	r3, r8
   20298:	e2838001 	add	r8, r3, #1
   2029c:	e5d33000 	ldrb	r3, [r3]
   202a0:	e1a09003 	mov	r9, r3
			} while (is_digit (ch));
   202a4:	e2493030 	sub	r3, r9, #48	; 0x30
   202a8:	e3530009 	cmp	r3, #9
   202ac:	9afffff1 	bls	20278 <_vfiprintf_r+0x64c>
				}
				else
					goto error;
			}
#endif /* !_NO_POS_ARGS */
			width = n;
   202b0:	e50b7024 	str	r7, [fp, #-36]	; 0x24
			goto reswitch;
   202b4:	eaffff34 	b	1ff8c <_vfiprintf_r+0x360>
			flags |= LONGDBL;
			goto rflag;
#endif
		case 'h':
#ifdef _WANT_IO_C99_FORMATS
			if (*fmt == 'h') {
   202b8:	e5d83000 	ldrb	r3, [r8]
   202bc:	e3530068 	cmp	r3, #104	; 0x68
   202c0:	1a000002 	bne	202d0 <_vfiprintf_r+0x6a4>
				fmt++;
   202c4:	e2888001 	add	r8, r8, #1
				flags |= CHARINT;
   202c8:	e3844c02 	orr	r4, r4, #512	; 0x200
   202cc:	ea000000 	b	202d4 <_vfiprintf_r+0x6a8>
			} else
#endif
				flags |= SHORTINT;
   202d0:	e3844040 	orr	r4, r4, #64	; 0x40
			goto rflag;
   202d4:	eaffff28 	b	1ff7c <_vfiprintf_r+0x350>
		case 'l':
#if defined _WANT_IO_C99_FORMATS || !defined _NO_LONGLONG
			if (*fmt == 'l') {
   202d8:	e5d83000 	ldrb	r3, [r8]
   202dc:	e353006c 	cmp	r3, #108	; 0x6c
   202e0:	1a000002 	bne	202f0 <_vfiprintf_r+0x6c4>
				fmt++;
   202e4:	e2888001 	add	r8, r8, #1
				flags |= QUADINT;
   202e8:	e3844020 	orr	r4, r4, #32
   202ec:	ea000000 	b	202f4 <_vfiprintf_r+0x6c8>
			} else
#endif
				flags |= LONGINT;
   202f0:	e3844010 	orr	r4, r4, #16
			goto rflag;
   202f4:	eaffff20 	b	1ff7c <_vfiprintf_r+0x350>
		case 'q': /* extension */
			flags |= QUADINT;
   202f8:	e3844020 	orr	r4, r4, #32
			goto rflag;
   202fc:	eaffff1e 	b	1ff7c <_vfiprintf_r+0x350>
#ifdef _WANT_IO_C99_FORMATS
		case 'j':
		  if (sizeof (intmax_t) == sizeof (long))
		    flags |= LONGINT;
		  else
		    flags |= QUADINT;
   20300:	e3844020 	orr	r4, r4, #32
		  goto rflag;
   20304:	eaffff1c 	b	1ff7c <_vfiprintf_r+0x350>
		    flags |= QUADINT;
		  goto rflag;
		case 'C':
#endif /* _WANT_IO_C99_FORMATS */
		case 'c':
			cp = buf;
   20308:	e24b6f47 	sub	r6, fp, #284	; 0x11c
				}
			}
			else
#endif /* _MB_CAPABLE */
			{
				*cp = GET_ARG (N, ap, int);
   2030c:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   20310:	e2832004 	add	r2, r3, #4
   20314:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   20318:	e5933000 	ldr	r3, [r3]
   2031c:	e20330ff 	and	r3, r3, #255	; 0xff
   20320:	e5c63000 	strb	r3, [r6]
				size = 1;
   20324:	e3a03001 	mov	r3, #1
   20328:	e50b3054 	str	r3, [fp, #-84]	; 0x54
			}
			sign = '\0';
   2032c:	e3a03000 	mov	r3, #0
   20330:	e54b3069 	strb	r3, [fp, #-105]	; 0x69
			break;
   20334:	ea00023c 	b	20c2c <_vfiprintf_r+0x1000>
		case 'D':  /* extension */
			flags |= LONGINT;
   20338:	e3844010 	orr	r4, r4, #16
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG ();
   2033c:	e2043020 	and	r3, r4, #32
   20340:	e3530000 	cmp	r3, #0
   20344:	0a000006 	beq	20364 <_vfiprintf_r+0x738>
   20348:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   2034c:	e2833007 	add	r3, r3, #7
   20350:	e3c33007 	bic	r3, r3, #7
   20354:	e2832008 	add	r2, r3, #8
   20358:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   2035c:	e893000c 	ldm	r3, {r2, r3}
   20360:	ea00002a 	b	20410 <_vfiprintf_r+0x7e4>
   20364:	e2043010 	and	r3, r4, #16
   20368:	e3530000 	cmp	r3, #0
   2036c:	0a000006 	beq	2038c <_vfiprintf_r+0x760>
   20370:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   20374:	e2832004 	add	r2, r3, #4
   20378:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   2037c:	e5933000 	ldr	r3, [r3]
   20380:	e1a02003 	mov	r2, r3
   20384:	e1a03fc2 	asr	r3, r2, #31
   20388:	ea000020 	b	20410 <_vfiprintf_r+0x7e4>
   2038c:	e2043040 	and	r3, r4, #64	; 0x40
   20390:	e3530000 	cmp	r3, #0
   20394:	0a00000a 	beq	203c4 <_vfiprintf_r+0x798>
   20398:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   2039c:	e2832004 	add	r2, r3, #4
   203a0:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   203a4:	e5933000 	ldr	r3, [r3]
   203a8:	e1a03803 	lsl	r3, r3, #16
   203ac:	e1a01823 	lsr	r1, r3, #16
   203b0:	e1a03801 	lsl	r3, r1, #16
   203b4:	e1a03843 	asr	r3, r3, #16
   203b8:	e1a02003 	mov	r2, r3
   203bc:	e1a03fc2 	asr	r3, r2, #31
   203c0:	ea000012 	b	20410 <_vfiprintf_r+0x7e4>
   203c4:	e2043c02 	and	r3, r4, #512	; 0x200
   203c8:	e3530000 	cmp	r3, #0
   203cc:	0a000009 	beq	203f8 <_vfiprintf_r+0x7cc>
   203d0:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   203d4:	e2832004 	add	r2, r3, #4
   203d8:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   203dc:	e5933000 	ldr	r3, [r3]
   203e0:	e20310ff 	and	r1, r3, #255	; 0xff
   203e4:	e1a03c01 	lsl	r3, r1, #24
   203e8:	e1a03c43 	asr	r3, r3, #24
   203ec:	e1a02003 	mov	r2, r3
   203f0:	e1a03fc2 	asr	r3, r2, #31
   203f4:	ea000005 	b	20410 <_vfiprintf_r+0x7e4>
   203f8:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   203fc:	e2832004 	add	r2, r3, #4
   20400:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   20404:	e5933000 	ldr	r3, [r3]
   20408:	e1a02003 	mov	r2, r3
   2040c:	e1a03fc2 	asr	r3, r2, #31
   20410:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   20414:	e50b3040 	str	r3, [fp, #-64]	; 0x40
#ifndef _NO_LONGLONG
			if ((quad_t)_uquad < 0)
   20418:	e24b3044 	sub	r3, fp, #68	; 0x44
   2041c:	e893000c 	ldm	r3, {r2, r3}
   20420:	e3520000 	cmp	r2, #0
   20424:	e2d31000 	sbcs	r1, r3, #0
   20428:	aa000007 	bge	2044c <_vfiprintf_r+0x820>
#else
			if ((long) _uquad < 0)
#endif
			{

				_uquad = -_uquad;
   2042c:	e24b3044 	sub	r3, fp, #68	; 0x44
   20430:	e893000c 	ldm	r3, {r2, r3}
   20434:	e2722000 	rsbs	r2, r2, #0
   20438:	e2e33000 	rsc	r3, r3, #0
   2043c:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   20440:	e50b3040 	str	r3, [fp, #-64]	; 0x40
				sign = '-';
   20444:	e3a0302d 	mov	r3, #45	; 0x2d
   20448:	e54b3069 	strb	r3, [fp, #-105]	; 0x69
			}
			base = DEC;
   2044c:	e3a03001 	mov	r3, #1
   20450:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
			goto number;
   20454:	ea000131 	b	20920 <_vfiprintf_r+0xcf4>
			flags &= ~LONGINT;
			goto string;
#endif
		case 'n':
#ifndef _NO_LONGLONG
			if (flags & QUADINT)
   20458:	e2043020 	and	r3, r4, #32
   2045c:	e3530000 	cmp	r3, #0
   20460:	0a000007 	beq	20484 <_vfiprintf_r+0x858>
				*GET_ARG (N, ap, quad_ptr_t) = ret;
   20464:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   20468:	e2832004 	add	r2, r3, #4
   2046c:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   20470:	e5932000 	ldr	r2, [r3]
   20474:	e51b3020 	ldr	r3, [fp, #-32]
   20478:	e1a04fc3 	asr	r4, r3, #31
   2047c:	e8820018 	stm	r2, {r3, r4}
   20480:	ea000027 	b	20524 <_vfiprintf_r+0x8f8>
			else
#endif
			if (flags & LONGINT)
   20484:	e2043010 	and	r3, r4, #16
   20488:	e3530000 	cmp	r3, #0
   2048c:	0a000006 	beq	204ac <_vfiprintf_r+0x880>
				*GET_ARG (N, ap, long_ptr_t) = ret;
   20490:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   20494:	e2832004 	add	r2, r3, #4
   20498:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   2049c:	e5933000 	ldr	r3, [r3]
   204a0:	e51b2020 	ldr	r2, [fp, #-32]
   204a4:	e5832000 	str	r2, [r3]
   204a8:	ea00001d 	b	20524 <_vfiprintf_r+0x8f8>
			else if (flags & SHORTINT)
   204ac:	e2043040 	and	r3, r4, #64	; 0x40
   204b0:	e3530000 	cmp	r3, #0
   204b4:	0a000008 	beq	204dc <_vfiprintf_r+0x8b0>
				*GET_ARG (N, ap, short_ptr_t) = ret;
   204b8:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   204bc:	e2832004 	add	r2, r3, #4
   204c0:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   204c4:	e5933000 	ldr	r3, [r3]
   204c8:	e51b2020 	ldr	r2, [fp, #-32]
   204cc:	e1a02802 	lsl	r2, r2, #16
   204d0:	e1a02822 	lsr	r2, r2, #16
   204d4:	e1c320b0 	strh	r2, [r3]
   204d8:	ea000011 	b	20524 <_vfiprintf_r+0x8f8>
#ifdef _WANT_IO_C99_FORMATS
			else if (flags & CHARINT)
   204dc:	e2043c02 	and	r3, r4, #512	; 0x200
   204e0:	e3530000 	cmp	r3, #0
   204e4:	0a000007 	beq	20508 <_vfiprintf_r+0x8dc>
				*GET_ARG (N, ap, char_ptr_t) = ret;
   204e8:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   204ec:	e2832004 	add	r2, r3, #4
   204f0:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   204f4:	e5933000 	ldr	r3, [r3]
   204f8:	e51b2020 	ldr	r2, [fp, #-32]
   204fc:	e20220ff 	and	r2, r2, #255	; 0xff
   20500:	e5c32000 	strb	r2, [r3]
   20504:	ea000006 	b	20524 <_vfiprintf_r+0x8f8>
#endif
			else
				*GET_ARG (N, ap, int_ptr_t) = ret;
   20508:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   2050c:	e2832004 	add	r2, r3, #4
   20510:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   20514:	e5933000 	ldr	r3, [r3]
   20518:	e51b2020 	ldr	r2, [fp, #-32]
   2051c:	e5832000 	str	r2, [r3]
			continue;	/* no output */
   20520:	ea000339 	b	2120c <_vfiprintf_r+0x15e0>
   20524:	ea000338 	b	2120c <_vfiprintf_r+0x15e0>
		case 'O': /* extension */
			flags |= LONGINT;
   20528:	e3844010 	orr	r4, r4, #16
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG ();
   2052c:	e2043020 	and	r3, r4, #32
   20530:	e3530000 	cmp	r3, #0
   20534:	0a000006 	beq	20554 <_vfiprintf_r+0x928>
   20538:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   2053c:	e2833007 	add	r3, r3, #7
   20540:	e3c33007 	bic	r3, r3, #7
   20544:	e2832008 	add	r2, r3, #8
   20548:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   2054c:	e893000c 	ldm	r3, {r2, r3}
   20550:	ea000027 	b	205f4 <_vfiprintf_r+0x9c8>
   20554:	e2043010 	and	r3, r4, #16
   20558:	e3530000 	cmp	r3, #0
   2055c:	0a000006 	beq	2057c <_vfiprintf_r+0x950>
   20560:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   20564:	e2832004 	add	r2, r3, #4
   20568:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   2056c:	e5933000 	ldr	r3, [r3]
   20570:	e1a02003 	mov	r2, r3
   20574:	e3a03000 	mov	r3, #0
   20578:	ea00001d 	b	205f4 <_vfiprintf_r+0x9c8>
   2057c:	e2043040 	and	r3, r4, #64	; 0x40
   20580:	e3530000 	cmp	r3, #0
   20584:	0a000009 	beq	205b0 <_vfiprintf_r+0x984>
   20588:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   2058c:	e2832004 	add	r2, r3, #4
   20590:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   20594:	e5933000 	ldr	r3, [r3]
   20598:	e1a03803 	lsl	r3, r3, #16
   2059c:	e1a01823 	lsr	r1, r3, #16
   205a0:	e1a03001 	mov	r3, r1
   205a4:	e1a02003 	mov	r2, r3
   205a8:	e3a03000 	mov	r3, #0
   205ac:	ea000010 	b	205f4 <_vfiprintf_r+0x9c8>
   205b0:	e2043c02 	and	r3, r4, #512	; 0x200
   205b4:	e3530000 	cmp	r3, #0
   205b8:	0a000007 	beq	205dc <_vfiprintf_r+0x9b0>
   205bc:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   205c0:	e2832004 	add	r2, r3, #4
   205c4:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   205c8:	e5933000 	ldr	r3, [r3]
   205cc:	e20330ff 	and	r3, r3, #255	; 0xff
   205d0:	e20320ff 	and	r2, r3, #255	; 0xff
   205d4:	e3a03000 	mov	r3, #0
   205d8:	ea000005 	b	205f4 <_vfiprintf_r+0x9c8>
   205dc:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   205e0:	e2832004 	add	r2, r3, #4
   205e4:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   205e8:	e5933000 	ldr	r3, [r3]
   205ec:	e1a02003 	mov	r2, r3
   205f0:	e3a03000 	mov	r3, #0
   205f4:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   205f8:	e50b3040 	str	r3, [fp, #-64]	; 0x40
			base = OCT;
   205fc:	e3a03000 	mov	r3, #0
   20600:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
   20604:	e3c44b01 	bic	r4, r4, #1024	; 0x400
#endif
			goto nosign;
   20608:	ea0000c2 	b	20918 <_vfiprintf_r+0xcec>
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			/* NOSTRICT */
			_uquad = (uintptr_t) GET_ARG (N, ap, void_ptr_t);
   2060c:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   20610:	e2832004 	add	r2, r3, #4
   20614:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   20618:	e5933000 	ldr	r3, [r3]
   2061c:	e1a02003 	mov	r2, r3
   20620:	e3a03000 	mov	r3, #0
   20624:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   20628:	e50b3040 	str	r3, [fp, #-64]	; 0x40
			base = HEX;
   2062c:	e3a03002 	mov	r3, #2
   20630:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
			xdigs = "0123456789abcdef";
   20634:	e59f3c94 	ldr	r3, [pc, #3220]	; 212d0 <_vfiprintf_r+0x16a4>
   20638:	e50b3058 	str	r3, [fp, #-88]	; 0x58
			flags |= HEXPREFIX;
   2063c:	e3844002 	orr	r4, r4, #2
			ox[0] = '0';
   20640:	e3a03030 	mov	r3, #48	; 0x30
   20644:	e54b3120 	strb	r3, [fp, #-288]	; 0x120
			ox[1] = ch = 'x';
   20648:	e3a09078 	mov	r9, #120	; 0x78
   2064c:	e3a03078 	mov	r3, #120	; 0x78
   20650:	e54b311f 	strb	r3, [fp, #-287]	; 0x11f
			goto nosign;
   20654:	ea0000af 	b	20918 <_vfiprintf_r+0xcec>
		case 's':
#ifdef _WANT_IO_C99_FORMATS
		case 'S':
#endif
			cp = GET_ARG (N, ap, char_ptr_t);
   20658:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   2065c:	e2832004 	add	r2, r3, #4
   20660:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   20664:	e5936000 	ldr	r6, [r3]
#ifdef _GLIBC_EXTENSION
string:
#endif
			sign = '\0';
   20668:	e3a03000 	mov	r3, #0
   2066c:	e54b3069 	strb	r3, [fp, #-105]	; 0x69
#ifndef __OPTIMIZE_SIZE__
			/* Behavior is undefined if the user passed a
			   NULL string when precision is not 0.
			   However, if we are not optimizing for size,
			   we might as well mirror glibc behavior.  */
			if (cp == NULL) {
   20670:	e3560000 	cmp	r6, #0
   20674:	1a000006 	bne	20694 <_vfiprintf_r+0xa68>
				cp = "(null)";
   20678:	e59f6c54 	ldr	r6, [pc, #3156]	; 212d4 <_vfiprintf_r+0x16a8>
				size = ((unsigned) prec > 6U) ? 6 : prec;
   2067c:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   20680:	e3530006 	cmp	r3, #6
   20684:	31a03003 	movcc	r3, r3
   20688:	23a03006 	movcs	r3, #6
   2068c:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   20690:	ea00001f 	b	20714 <_vfiprintf_r+0xae8>
				}
				cp[size] = '\0';
			}
			else
#endif /* _MB_CAPABLE */
			if (prec >= 0) {
   20694:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   20698:	e3530000 	cmp	r3, #0
   2069c:	ba000017 	blt	20700 <_vfiprintf_r+0xad4>
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen () will go further.
				 */
				char *p = memchr (cp, 0, prec);
   206a0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   206a4:	e1a00006 	mov	r0, r6
   206a8:	e3a01000 	mov	r1, #0
   206ac:	e1a02003 	mov	r2, r3
   206b0:	ebffe947 	bl	1abd4 <memchr>
   206b4:	e50b0068 	str	r0, [fp, #-104]	; 0x68

				if (p != NULL) {
   206b8:	e51b3068 	ldr	r3, [fp, #-104]	; 0x68
   206bc:	e3530000 	cmp	r3, #0
   206c0:	0a00000a 	beq	206f0 <_vfiprintf_r+0xac4>
					size = p - cp;
   206c4:	e51b2068 	ldr	r2, [fp, #-104]	; 0x68
   206c8:	e1a03006 	mov	r3, r6
   206cc:	e0633002 	rsb	r3, r3, r2
   206d0:	e50b3054 	str	r3, [fp, #-84]	; 0x54
					if (size > prec)
   206d4:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   206d8:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   206dc:	e1520003 	cmp	r2, r3
   206e0:	da000005 	ble	206fc <_vfiprintf_r+0xad0>
						size = prec;
   206e4:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   206e8:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   206ec:	ea000008 	b	20714 <_vfiprintf_r+0xae8>
				} else
					size = prec;
   206f0:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   206f4:	e50b3054 	str	r3, [fp, #-84]	; 0x54
   206f8:	ea000005 	b	20714 <_vfiprintf_r+0xae8>
   206fc:	ea000004 	b	20714 <_vfiprintf_r+0xae8>
			} else
				size = strlen (cp);
   20700:	e1a00006 	mov	r0, r6
   20704:	ebffc0b8 	bl	109ec <strlen>
   20708:	e1a03000 	mov	r3, r0
   2070c:	e50b3054 	str	r3, [fp, #-84]	; 0x54

			break;
   20710:	ea000145 	b	20c2c <_vfiprintf_r+0x1000>
   20714:	ea000144 	b	20c2c <_vfiprintf_r+0x1000>
		case 'U': /* extension */
			flags |= LONGINT;
   20718:	e3844010 	orr	r4, r4, #16
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG ();
   2071c:	e2043020 	and	r3, r4, #32
   20720:	e3530000 	cmp	r3, #0
   20724:	0a000006 	beq	20744 <_vfiprintf_r+0xb18>
   20728:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   2072c:	e2833007 	add	r3, r3, #7
   20730:	e3c33007 	bic	r3, r3, #7
   20734:	e2832008 	add	r2, r3, #8
   20738:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   2073c:	e893000c 	ldm	r3, {r2, r3}
   20740:	ea000027 	b	207e4 <_vfiprintf_r+0xbb8>
   20744:	e2043010 	and	r3, r4, #16
   20748:	e3530000 	cmp	r3, #0
   2074c:	0a000006 	beq	2076c <_vfiprintf_r+0xb40>
   20750:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   20754:	e2832004 	add	r2, r3, #4
   20758:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   2075c:	e5933000 	ldr	r3, [r3]
   20760:	e1a02003 	mov	r2, r3
   20764:	e3a03000 	mov	r3, #0
   20768:	ea00001d 	b	207e4 <_vfiprintf_r+0xbb8>
   2076c:	e2043040 	and	r3, r4, #64	; 0x40
   20770:	e3530000 	cmp	r3, #0
   20774:	0a000009 	beq	207a0 <_vfiprintf_r+0xb74>
   20778:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   2077c:	e2832004 	add	r2, r3, #4
   20780:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   20784:	e5933000 	ldr	r3, [r3]
   20788:	e1a03803 	lsl	r3, r3, #16
   2078c:	e1a01823 	lsr	r1, r3, #16
   20790:	e1a03001 	mov	r3, r1
   20794:	e1a02003 	mov	r2, r3
   20798:	e3a03000 	mov	r3, #0
   2079c:	ea000010 	b	207e4 <_vfiprintf_r+0xbb8>
   207a0:	e2043c02 	and	r3, r4, #512	; 0x200
   207a4:	e3530000 	cmp	r3, #0
   207a8:	0a000007 	beq	207cc <_vfiprintf_r+0xba0>
   207ac:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   207b0:	e2832004 	add	r2, r3, #4
   207b4:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   207b8:	e5933000 	ldr	r3, [r3]
   207bc:	e20330ff 	and	r3, r3, #255	; 0xff
   207c0:	e20320ff 	and	r2, r3, #255	; 0xff
   207c4:	e3a03000 	mov	r3, #0
   207c8:	ea000005 	b	207e4 <_vfiprintf_r+0xbb8>
   207cc:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   207d0:	e2832004 	add	r2, r3, #4
   207d4:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   207d8:	e5933000 	ldr	r3, [r3]
   207dc:	e1a02003 	mov	r2, r3
   207e0:	e3a03000 	mov	r3, #0
   207e4:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   207e8:	e50b3040 	str	r3, [fp, #-64]	; 0x40
			base = DEC;
   207ec:	e3a03001 	mov	r3, #1
   207f0:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
			goto nosign;
   207f4:	ea000047 	b	20918 <_vfiprintf_r+0xcec>
		case 'X':
			xdigs = "0123456789ABCDEF";
   207f8:	e59f3ad8 	ldr	r3, [pc, #2776]	; 212d8 <_vfiprintf_r+0x16ac>
   207fc:	e50b3058 	str	r3, [fp, #-88]	; 0x58
			goto hex;
   20800:	ea000001 	b	2080c <_vfiprintf_r+0xbe0>
		case 'x':
			xdigs = "0123456789abcdef";
   20804:	e59f3ac4 	ldr	r3, [pc, #2756]	; 212d0 <_vfiprintf_r+0x16a4>
   20808:	e50b3058 	str	r3, [fp, #-88]	; 0x58
hex:			_uquad = UARG ();
   2080c:	e2043020 	and	r3, r4, #32
   20810:	e3530000 	cmp	r3, #0
   20814:	0a000006 	beq	20834 <_vfiprintf_r+0xc08>
   20818:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   2081c:	e2833007 	add	r3, r3, #7
   20820:	e3c33007 	bic	r3, r3, #7
   20824:	e2832008 	add	r2, r3, #8
   20828:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   2082c:	e893000c 	ldm	r3, {r2, r3}
   20830:	ea000027 	b	208d4 <_vfiprintf_r+0xca8>
   20834:	e2043010 	and	r3, r4, #16
   20838:	e3530000 	cmp	r3, #0
   2083c:	0a000006 	beq	2085c <_vfiprintf_r+0xc30>
   20840:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   20844:	e2832004 	add	r2, r3, #4
   20848:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   2084c:	e5933000 	ldr	r3, [r3]
   20850:	e1a02003 	mov	r2, r3
   20854:	e3a03000 	mov	r3, #0
   20858:	ea00001d 	b	208d4 <_vfiprintf_r+0xca8>
   2085c:	e2043040 	and	r3, r4, #64	; 0x40
   20860:	e3530000 	cmp	r3, #0
   20864:	0a000009 	beq	20890 <_vfiprintf_r+0xc64>
   20868:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   2086c:	e2832004 	add	r2, r3, #4
   20870:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   20874:	e5933000 	ldr	r3, [r3]
   20878:	e1a03803 	lsl	r3, r3, #16
   2087c:	e1a01823 	lsr	r1, r3, #16
   20880:	e1a03001 	mov	r3, r1
   20884:	e1a02003 	mov	r2, r3
   20888:	e3a03000 	mov	r3, #0
   2088c:	ea000010 	b	208d4 <_vfiprintf_r+0xca8>
   20890:	e2043c02 	and	r3, r4, #512	; 0x200
   20894:	e3530000 	cmp	r3, #0
   20898:	0a000007 	beq	208bc <_vfiprintf_r+0xc90>
   2089c:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   208a0:	e2832004 	add	r2, r3, #4
   208a4:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   208a8:	e5933000 	ldr	r3, [r3]
   208ac:	e20330ff 	and	r3, r3, #255	; 0xff
   208b0:	e20320ff 	and	r2, r3, #255	; 0xff
   208b4:	e3a03000 	mov	r3, #0
   208b8:	ea000005 	b	208d4 <_vfiprintf_r+0xca8>
   208bc:	e51b3134 	ldr	r3, [fp, #-308]	; 0x134
   208c0:	e2832004 	add	r2, r3, #4
   208c4:	e50b2134 	str	r2, [fp, #-308]	; 0x134
   208c8:	e5933000 	ldr	r3, [r3]
   208cc:	e1a02003 	mov	r2, r3
   208d0:	e3a03000 	mov	r3, #0
   208d4:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   208d8:	e50b3040 	str	r3, [fp, #-64]	; 0x40
			base = HEX;
   208dc:	e3a03002 	mov	r3, #2
   208e0:	e54b3045 	strb	r3, [fp, #-69]	; 0x45
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0) {
   208e4:	e2043001 	and	r3, r4, #1
   208e8:	e3530000 	cmp	r3, #0
   208ec:	0a000008 	beq	20914 <_vfiprintf_r+0xce8>
   208f0:	e24b3044 	sub	r3, fp, #68	; 0x44
   208f4:	e893000c 	ldm	r3, {r2, r3}
   208f8:	e1921003 	orrs	r1, r2, r3
   208fc:	0a000004 	beq	20914 <_vfiprintf_r+0xce8>
				ox[0] = '0';
   20900:	e3a03030 	mov	r3, #48	; 0x30
   20904:	e54b3120 	strb	r3, [fp, #-288]	; 0x120
				ox[1] = ch;
   20908:	e20930ff 	and	r3, r9, #255	; 0xff
   2090c:	e54b311f 	strb	r3, [fp, #-287]	; 0x11f
				flags |= HEXPREFIX;
   20910:	e3844002 	orr	r4, r4, #2
			}

#ifdef _WANT_IO_C99_FORMATS
			flags &= ~GROUPING;
   20914:	e3c44b01 	bic	r4, r4, #1024	; 0x400
#endif
			/* unsigned conversions */
nosign:			sign = '\0';
   20918:	e3a03000 	mov	r3, #0
   2091c:	e54b3069 	strb	r3, [fp, #-105]	; 0x69
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
   20920:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   20924:	e50b304c 	str	r3, [fp, #-76]	; 0x4c
   20928:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   2092c:	e3530000 	cmp	r3, #0
   20930:	ba000000 	blt	20938 <_vfiprintf_r+0xd0c>
				flags &= ~ZEROPAD;
   20934:	e3c44080 	bic	r4, r4, #128	; 0x80
			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + BUF;
   20938:	e24b6f47 	sub	r6, fp, #284	; 0x11c
   2093c:	e2866064 	add	r6, r6, #100	; 0x64
			if (_uquad != 0 || prec != 0) {
   20940:	e24b3044 	sub	r3, fp, #68	; 0x44
   20944:	e893000c 	ldm	r3, {r2, r3}
   20948:	e1921003 	orrs	r1, r2, r3
   2094c:	1a000002 	bne	2095c <_vfiprintf_r+0xd30>
   20950:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   20954:	e3530000 	cmp	r3, #0
   20958:	0a000099 	beq	20bc4 <_vfiprintf_r+0xf98>
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
   2095c:	e55b3045 	ldrb	r3, [fp, #-69]	; 0x45
   20960:	e3530001 	cmp	r3, #1
   20964:	0a000026 	beq	20a04 <_vfiprintf_r+0xdd8>
   20968:	e3530002 	cmp	r3, #2
   2096c:	0a000073 	beq	20b40 <_vfiprintf_r+0xf14>
   20970:	e3530000 	cmp	r3, #0
   20974:	1a00008a 	bne	20ba4 <_vfiprintf_r+0xf78>
				case OCT:
					do {
						*--cp = to_char (_uquad & 7);
   20978:	e2466001 	sub	r6, r6, #1
   2097c:	e55b3044 	ldrb	r3, [fp, #-68]	; 0x44
   20980:	e2033007 	and	r3, r3, #7
   20984:	e20330ff 	and	r3, r3, #255	; 0xff
   20988:	e2833030 	add	r3, r3, #48	; 0x30
   2098c:	e20330ff 	and	r3, r3, #255	; 0xff
   20990:	e5c63000 	strb	r3, [r6]
						_uquad >>= 3;
   20994:	e24b3044 	sub	r3, fp, #68	; 0x44
   20998:	e893000c 	ldm	r3, {r2, r3}
   2099c:	e1a011a2 	lsr	r1, r2, #3
   209a0:	e50b113c 	str	r1, [fp, #-316]	; 0x13c
   209a4:	e51b113c 	ldr	r1, [fp, #-316]	; 0x13c
   209a8:	e1811e83 	orr	r1, r1, r3, lsl #29
   209ac:	e50b113c 	str	r1, [fp, #-316]	; 0x13c
   209b0:	e1a011a3 	lsr	r1, r3, #3
   209b4:	e50b1138 	str	r1, [fp, #-312]	; 0x138
   209b8:	e24b3f4f 	sub	r3, fp, #316	; 0x13c
   209bc:	e893000c 	ldm	r3, {r2, r3}
   209c0:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   209c4:	e50b3040 	str	r3, [fp, #-64]	; 0x40
					} while (_uquad);
   209c8:	e24b3044 	sub	r3, fp, #68	; 0x44
   209cc:	e893000c 	ldm	r3, {r2, r3}
   209d0:	e1921003 	orrs	r1, r2, r3
   209d4:	1affffe7 	bne	20978 <_vfiprintf_r+0xd4c>
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
   209d8:	e2043001 	and	r3, r4, #1
   209dc:	e3530000 	cmp	r3, #0
   209e0:	0a000006 	beq	20a00 <_vfiprintf_r+0xdd4>
   209e4:	e5d63000 	ldrb	r3, [r6]
   209e8:	e3530030 	cmp	r3, #48	; 0x30
   209ec:	0a000003 	beq	20a00 <_vfiprintf_r+0xdd4>
						*--cp = '0';
   209f0:	e2466001 	sub	r6, r6, #1
   209f4:	e3a03030 	mov	r3, #48	; 0x30
   209f8:	e5c63000 	strb	r3, [r6]
					break;
   209fc:	ea00006f 	b	20bc0 <_vfiprintf_r+0xf94>
   20a00:	ea00006e 	b	20bc0 <_vfiprintf_r+0xf94>

				case DEC:
					/* many numbers are 1 digit */
					if (_uquad < 10) {
   20a04:	e24b3044 	sub	r3, fp, #68	; 0x44
   20a08:	e893000c 	ldm	r3, {r2, r3}
   20a0c:	e3530000 	cmp	r3, #0
   20a10:	03520009 	cmpeq	r2, #9
   20a14:	8a000005 	bhi	20a30 <_vfiprintf_r+0xe04>
						*--cp = to_char(_uquad);
   20a18:	e2466001 	sub	r6, r6, #1
   20a1c:	e55b3044 	ldrb	r3, [fp, #-68]	; 0x44
   20a20:	e2833030 	add	r3, r3, #48	; 0x30
   20a24:	e20330ff 	and	r3, r3, #255	; 0xff
   20a28:	e5c63000 	strb	r3, [r6]
						break;
   20a2c:	ea000063 	b	20bc0 <_vfiprintf_r+0xf94>
					}
#ifdef _WANT_IO_C99_FORMATS
					ndig = 0;
   20a30:	e3a03000 	mov	r3, #0
   20a34:	e50b3038 	str	r3, [fp, #-56]	; 0x38
#endif
					do {
					  *--cp = to_char (_uquad % 10);
   20a38:	e2466001 	sub	r6, r6, #1
   20a3c:	e24b3044 	sub	r3, fp, #68	; 0x44
   20a40:	e893000c 	ldm	r3, {r2, r3}
   20a44:	e1a00002 	mov	r0, r2
   20a48:	e1a01003 	mov	r1, r3
   20a4c:	e3a0200a 	mov	r2, #10
   20a50:	e3a03000 	mov	r3, #0
   20a54:	ebffb4cc 	bl	dd8c <__aeabi_uldivmod>
   20a58:	e20230ff 	and	r3, r2, #255	; 0xff
   20a5c:	e2833030 	add	r3, r3, #48	; 0x30
   20a60:	e20330ff 	and	r3, r3, #255	; 0xff
   20a64:	e5c63000 	strb	r3, [r6]
#ifdef _WANT_IO_C99_FORMATS
					  ndig++;
   20a68:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   20a6c:	e2833001 	add	r3, r3, #1
   20a70:	e50b3038 	str	r3, [fp, #-56]	; 0x38
					  /* If (*grouping == CHAR_MAX) then no
					     more grouping */
					  if ((flags & GROUPING)
   20a74:	e2043b01 	and	r3, r4, #1024	; 0x400
   20a78:	e3530000 	cmp	r3, #0
   20a7c:	0a00001f 	beq	20b00 <_vfiprintf_r+0xed4>
					      && ndig == *grouping
   20a80:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   20a84:	e5d33000 	ldrb	r3, [r3]
   20a88:	e1a02003 	mov	r2, r3
   20a8c:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
   20a90:	e1520003 	cmp	r2, r3
   20a94:	1a000019 	bne	20b00 <_vfiprintf_r+0xed4>
					      && *grouping != CHAR_MAX
   20a98:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   20a9c:	e5d33000 	ldrb	r3, [r3]
   20aa0:	e35300ff 	cmp	r3, #255	; 0xff
   20aa4:	0a000015 	beq	20b00 <_vfiprintf_r+0xed4>
					      && _uquad > 9) {
   20aa8:	e24b3044 	sub	r3, fp, #68	; 0x44
   20aac:	e893000c 	ldm	r3, {r2, r3}
   20ab0:	e3530000 	cmp	r3, #0
   20ab4:	03520009 	cmpeq	r2, #9
   20ab8:	9a000010 	bls	20b00 <_vfiprintf_r+0xed4>
					    cp -= thsnd_len;
   20abc:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   20ac0:	e2633000 	rsb	r3, r3, #0
   20ac4:	e0866003 	add	r6, r6, r3
					    strncpy (cp, thousands_sep,
   20ac8:	e1a00006 	mov	r0, r6
   20acc:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
   20ad0:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   20ad4:	ebfff554 	bl	1e02c <strncpy>
						     thsnd_len);
					    ndig = 0;
   20ad8:	e3a03000 	mov	r3, #0
   20adc:	e50b3038 	str	r3, [fp, #-56]	; 0x38
					    /* If (grouping[1] == '\0') then we
					       have to use *grouping character
					       (last grouping rule) for all
					       next cases. */
					    if (grouping[1] != '\0')
   20ae0:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   20ae4:	e2833001 	add	r3, r3, #1
   20ae8:	e5d33000 	ldrb	r3, [r3]
   20aec:	e3530000 	cmp	r3, #0
   20af0:	0a000002 	beq	20b00 <_vfiprintf_r+0xed4>
					      grouping++;
   20af4:	e51b3034 	ldr	r3, [fp, #-52]	; 0x34
   20af8:	e2833001 	add	r3, r3, #1
   20afc:	e50b3034 	str	r3, [fp, #-52]	; 0x34
					  }
#endif
					  _uquad /= 10;
   20b00:	e24b3044 	sub	r3, fp, #68	; 0x44
   20b04:	e893000c 	ldm	r3, {r2, r3}
   20b08:	e1a00002 	mov	r0, r2
   20b0c:	e1a01003 	mov	r1, r3
   20b10:	e3a0200a 	mov	r2, #10
   20b14:	e3a03000 	mov	r3, #0
   20b18:	ebffb49b 	bl	dd8c <__aeabi_uldivmod>
   20b1c:	e1a02000 	mov	r2, r0
   20b20:	e1a03001 	mov	r3, r1
   20b24:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   20b28:	e50b3040 	str	r3, [fp, #-64]	; 0x40
					} while (_uquad != 0);
   20b2c:	e24b3044 	sub	r3, fp, #68	; 0x44
   20b30:	e893000c 	ldm	r3, {r2, r3}
   20b34:	e1921003 	orrs	r1, r2, r3
   20b38:	1affffbe 	bne	20a38 <_vfiprintf_r+0xe0c>
					break;
   20b3c:	ea00001f 	b	20bc0 <_vfiprintf_r+0xf94>

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
   20b40:	e2466001 	sub	r6, r6, #1
   20b44:	e51b3044 	ldr	r3, [fp, #-68]	; 0x44
   20b48:	e203300f 	and	r3, r3, #15
   20b4c:	e51b2058 	ldr	r2, [fp, #-88]	; 0x58
   20b50:	e0823003 	add	r3, r2, r3
   20b54:	e5d33000 	ldrb	r3, [r3]
   20b58:	e5c63000 	strb	r3, [r6]
						_uquad >>= 4;
   20b5c:	e24b3044 	sub	r3, fp, #68	; 0x44
   20b60:	e893000c 	ldm	r3, {r2, r3}
   20b64:	e1a01222 	lsr	r1, r2, #4
   20b68:	e50b1144 	str	r1, [fp, #-324]	; 0x144
   20b6c:	e51b1144 	ldr	r1, [fp, #-324]	; 0x144
   20b70:	e1811e03 	orr	r1, r1, r3, lsl #28
   20b74:	e50b1144 	str	r1, [fp, #-324]	; 0x144
   20b78:	e1a01223 	lsr	r1, r3, #4
   20b7c:	e50b1140 	str	r1, [fp, #-320]	; 0x140
   20b80:	e24b3f51 	sub	r3, fp, #324	; 0x144
   20b84:	e893000c 	ldm	r3, {r2, r3}
   20b88:	e50b2044 	str	r2, [fp, #-68]	; 0x44
   20b8c:	e50b3040 	str	r3, [fp, #-64]	; 0x40
					} while (_uquad);
   20b90:	e24b3044 	sub	r3, fp, #68	; 0x44
   20b94:	e893000c 	ldm	r3, {r2, r3}
   20b98:	e1921003 	orrs	r1, r2, r3
   20b9c:	1affffe7 	bne	20b40 <_vfiprintf_r+0xf14>
					break;
   20ba0:	ea000006 	b	20bc0 <_vfiprintf_r+0xf94>

				default:
					cp = "bug in vfprintf: bad base";
   20ba4:	e59f6730 	ldr	r6, [pc, #1840]	; 212dc <_vfiprintf_r+0x16b0>
					size = strlen (cp);
   20ba8:	e1a00006 	mov	r0, r6
   20bac:	ebffbf8e 	bl	109ec <strlen>
   20bb0:	e1a03000 	mov	r3, r0
   20bb4:	e50b3054 	str	r3, [fp, #-84]	; 0x54
					goto skipsize;
   20bb8:	e1a00000 	nop			; (mov r0, r0)
                       else if (base == OCT && (flags & ALT))
                         *--cp = '0';

			size = buf + BUF - cp;
		skipsize:
			break;
   20bbc:	ea00001a 	b	20c2c <_vfiprintf_r+0x1000>
				default:
					cp = "bug in vfprintf: bad base";
					size = strlen (cp);
					goto skipsize;
				}
			}
   20bc0:	ea000008 	b	20be8 <_vfiprintf_r+0xfbc>
			*     -- ANSI X3J11
			*
			* To demonstrate this case, compile and run:
                        *    printf ("%#.0o",0);
			*/
                       else if (base == OCT && (flags & ALT))
   20bc4:	e55b3045 	ldrb	r3, [fp, #-69]	; 0x45
   20bc8:	e3530000 	cmp	r3, #0
   20bcc:	1a000005 	bne	20be8 <_vfiprintf_r+0xfbc>
   20bd0:	e2043001 	and	r3, r4, #1
   20bd4:	e3530000 	cmp	r3, #0
   20bd8:	0a000002 	beq	20be8 <_vfiprintf_r+0xfbc>
                         *--cp = '0';
   20bdc:	e2466001 	sub	r6, r6, #1
   20be0:	e3a03030 	mov	r3, #48	; 0x30
   20be4:	e5c63000 	strb	r3, [r6]

			size = buf + BUF - cp;
   20be8:	e24b3f47 	sub	r3, fp, #284	; 0x11c
   20bec:	e2833064 	add	r3, r3, #100	; 0x64
   20bf0:	e1a02006 	mov	r2, r6
   20bf4:	e0623003 	rsb	r3, r2, r3
   20bf8:	e50b3054 	str	r3, [fp, #-84]	; 0x54
		skipsize:
			break;
   20bfc:	ea00000a 	b	20c2c <_vfiprintf_r+0x1000>
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
   20c00:	e3590000 	cmp	r9, #0
   20c04:	1a000000 	bne	20c0c <_vfiprintf_r+0xfe0>
				goto done;
   20c08:	ea000180 	b	21210 <_vfiprintf_r+0x15e4>
			/* pretend it was %c with argument ch */
			cp = buf;
   20c0c:	e24b6f47 	sub	r6, fp, #284	; 0x11c
			*cp = ch;
   20c10:	e20930ff 	and	r3, r9, #255	; 0xff
   20c14:	e5c63000 	strb	r3, [r6]
			size = 1;
   20c18:	e3a03001 	mov	r3, #1
   20c1c:	e50b3054 	str	r3, [fp, #-84]	; 0x54
			sign = '\0';
   20c20:	e3a03000 	mov	r3, #0
   20c24:	e54b3069 	strb	r3, [fp, #-105]	; 0x69
			break;
   20c28:	e1a00000 	nop			; (mov r0, r0)
		 * If flags&FPT, ch must be in [aAeEfg].
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
   20c2c:	e51b2054 	ldr	r2, [fp, #-84]	; 0x54
   20c30:	e51b304c 	ldr	r3, [fp, #-76]	; 0x4c
   20c34:	e1520003 	cmp	r2, r3
   20c38:	a1a03002 	movge	r3, r2
   20c3c:	b1a03003 	movlt	r3, r3
   20c40:	e50b3050 	str	r3, [fp, #-80]	; 0x50
		if (sign)
   20c44:	e55b3069 	ldrb	r3, [fp, #-105]	; 0x69
   20c48:	e3530000 	cmp	r3, #0
   20c4c:	0a000002 	beq	20c5c <_vfiprintf_r+0x1030>
			realsz++;
   20c50:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   20c54:	e2833001 	add	r3, r3, #1
   20c58:	e50b3050 	str	r3, [fp, #-80]	; 0x50
		if (flags & HEXPREFIX)
   20c5c:	e2043002 	and	r3, r4, #2
   20c60:	e3530000 	cmp	r3, #0
   20c64:	0a000002 	beq	20c74 <_vfiprintf_r+0x1048>
			realsz+= 2;
   20c68:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   20c6c:	e2833002 	add	r3, r3, #2
   20c70:	e50b3050 	str	r3, [fp, #-80]	; 0x50

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0)
   20c74:	e2043084 	and	r3, r4, #132	; 0x84
   20c78:	e3530000 	cmp	r3, #0
   20c7c:	1a00003a 	bne	20d6c <_vfiprintf_r+0x1140>
			PAD (width - realsz, blanks);
   20c80:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   20c84:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   20c88:	e0637002 	rsb	r7, r3, r2
   20c8c:	e3570000 	cmp	r7, #0
   20c90:	da000035 	ble	20d6c <_vfiprintf_r+0x1140>
   20c94:	ea000019 	b	20d00 <_vfiprintf_r+0x10d4>
   20c98:	e59f3640 	ldr	r3, [pc, #1600]	; 212e0 <_vfiprintf_r+0x16b4>
   20c9c:	e5853000 	str	r3, [r5]
   20ca0:	e3a03010 	mov	r3, #16
   20ca4:	e5853004 	str	r3, [r5, #4]
   20ca8:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   20cac:	e2833010 	add	r3, r3, #16
   20cb0:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   20cb4:	e2855008 	add	r5, r5, #8
   20cb8:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   20cbc:	e2833001 	add	r3, r3, #1
   20cc0:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   20cc4:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   20cc8:	e3530007 	cmp	r3, #7
   20ccc:	da00000a 	ble	20cfc <_vfiprintf_r+0x10d0>
   20cd0:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   20cd4:	e24b3078 	sub	r3, fp, #120	; 0x78
   20cd8:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   20cdc:	e1a01002 	mov	r1, r2
   20ce0:	e1a02003 	mov	r2, r3
   20ce4:	ebfffb20 	bl	1f96c <__sprint_r>
   20ce8:	e1a03000 	mov	r3, r0
   20cec:	e3530000 	cmp	r3, #0
   20cf0:	0a000000 	beq	20cf8 <_vfiprintf_r+0x10cc>
   20cf4:	ea000155 	b	21250 <_vfiprintf_r+0x1624>
   20cf8:	e24b50b8 	sub	r5, fp, #184	; 0xb8
   20cfc:	e2477010 	sub	r7, r7, #16
   20d00:	e3570010 	cmp	r7, #16
   20d04:	caffffe3 	bgt	20c98 <_vfiprintf_r+0x106c>
   20d08:	e59f35d0 	ldr	r3, [pc, #1488]	; 212e0 <_vfiprintf_r+0x16b4>
   20d0c:	e5853000 	str	r3, [r5]
   20d10:	e1a03007 	mov	r3, r7
   20d14:	e5853004 	str	r3, [r5, #4]
   20d18:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   20d1c:	e0833007 	add	r3, r3, r7
   20d20:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   20d24:	e2855008 	add	r5, r5, #8
   20d28:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   20d2c:	e2833001 	add	r3, r3, #1
   20d30:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   20d34:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   20d38:	e3530007 	cmp	r3, #7
   20d3c:	da00000a 	ble	20d6c <_vfiprintf_r+0x1140>
   20d40:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   20d44:	e24b3078 	sub	r3, fp, #120	; 0x78
   20d48:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   20d4c:	e1a01002 	mov	r1, r2
   20d50:	e1a02003 	mov	r2, r3
   20d54:	ebfffb04 	bl	1f96c <__sprint_r>
   20d58:	e1a03000 	mov	r3, r0
   20d5c:	e3530000 	cmp	r3, #0
   20d60:	0a000000 	beq	20d68 <_vfiprintf_r+0x113c>
   20d64:	ea000139 	b	21250 <_vfiprintf_r+0x1624>
   20d68:	e24b50b8 	sub	r5, fp, #184	; 0xb8

		/* prefix */
		if (sign)
   20d6c:	e55b3069 	ldrb	r3, [fp, #-105]	; 0x69
   20d70:	e3530000 	cmp	r3, #0
   20d74:	0a000018 	beq	20ddc <_vfiprintf_r+0x11b0>
			PRINT (&sign, 1);
   20d78:	e24b3069 	sub	r3, fp, #105	; 0x69
   20d7c:	e5853000 	str	r3, [r5]
   20d80:	e3a03001 	mov	r3, #1
   20d84:	e5853004 	str	r3, [r5, #4]
   20d88:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   20d8c:	e2833001 	add	r3, r3, #1
   20d90:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   20d94:	e2855008 	add	r5, r5, #8
   20d98:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   20d9c:	e2833001 	add	r3, r3, #1
   20da0:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   20da4:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   20da8:	e3530007 	cmp	r3, #7
   20dac:	da00000a 	ble	20ddc <_vfiprintf_r+0x11b0>
   20db0:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   20db4:	e24b3078 	sub	r3, fp, #120	; 0x78
   20db8:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   20dbc:	e1a01002 	mov	r1, r2
   20dc0:	e1a02003 	mov	r2, r3
   20dc4:	ebfffae8 	bl	1f96c <__sprint_r>
   20dc8:	e1a03000 	mov	r3, r0
   20dcc:	e3530000 	cmp	r3, #0
   20dd0:	0a000000 	beq	20dd8 <_vfiprintf_r+0x11ac>
   20dd4:	ea00011d 	b	21250 <_vfiprintf_r+0x1624>
   20dd8:	e24b50b8 	sub	r5, fp, #184	; 0xb8
		if (flags & HEXPREFIX)
   20ddc:	e2043002 	and	r3, r4, #2
   20de0:	e3530000 	cmp	r3, #0
   20de4:	0a000018 	beq	20e4c <_vfiprintf_r+0x1220>
			PRINT (ox, 2);
   20de8:	e24b3e12 	sub	r3, fp, #288	; 0x120
   20dec:	e5853000 	str	r3, [r5]
   20df0:	e3a03002 	mov	r3, #2
   20df4:	e5853004 	str	r3, [r5, #4]
   20df8:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   20dfc:	e2833002 	add	r3, r3, #2
   20e00:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   20e04:	e2855008 	add	r5, r5, #8
   20e08:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   20e0c:	e2833001 	add	r3, r3, #1
   20e10:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   20e14:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   20e18:	e3530007 	cmp	r3, #7
   20e1c:	da00000a 	ble	20e4c <_vfiprintf_r+0x1220>
   20e20:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   20e24:	e24b3078 	sub	r3, fp, #120	; 0x78
   20e28:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   20e2c:	e1a01002 	mov	r1, r2
   20e30:	e1a02003 	mov	r2, r3
   20e34:	ebfffacc 	bl	1f96c <__sprint_r>
   20e38:	e1a03000 	mov	r3, r0
   20e3c:	e3530000 	cmp	r3, #0
   20e40:	0a000000 	beq	20e48 <_vfiprintf_r+0x121c>
   20e44:	ea000101 	b	21250 <_vfiprintf_r+0x1624>
   20e48:	e24b50b8 	sub	r5, fp, #184	; 0xb8

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD)
   20e4c:	e2043084 	and	r3, r4, #132	; 0x84
   20e50:	e3530080 	cmp	r3, #128	; 0x80
   20e54:	1a00003a 	bne	20f44 <_vfiprintf_r+0x1318>
			PAD (width - realsz, zeroes);
   20e58:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   20e5c:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   20e60:	e0637002 	rsb	r7, r3, r2
   20e64:	e3570000 	cmp	r7, #0
   20e68:	da000035 	ble	20f44 <_vfiprintf_r+0x1318>
   20e6c:	ea000019 	b	20ed8 <_vfiprintf_r+0x12ac>
   20e70:	e59f346c 	ldr	r3, [pc, #1132]	; 212e4 <_vfiprintf_r+0x16b8>
   20e74:	e5853000 	str	r3, [r5]
   20e78:	e3a03010 	mov	r3, #16
   20e7c:	e5853004 	str	r3, [r5, #4]
   20e80:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   20e84:	e2833010 	add	r3, r3, #16
   20e88:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   20e8c:	e2855008 	add	r5, r5, #8
   20e90:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   20e94:	e2833001 	add	r3, r3, #1
   20e98:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   20e9c:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   20ea0:	e3530007 	cmp	r3, #7
   20ea4:	da00000a 	ble	20ed4 <_vfiprintf_r+0x12a8>
   20ea8:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   20eac:	e24b3078 	sub	r3, fp, #120	; 0x78
   20eb0:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   20eb4:	e1a01002 	mov	r1, r2
   20eb8:	e1a02003 	mov	r2, r3
   20ebc:	ebfffaaa 	bl	1f96c <__sprint_r>
   20ec0:	e1a03000 	mov	r3, r0
   20ec4:	e3530000 	cmp	r3, #0
   20ec8:	0a000000 	beq	20ed0 <_vfiprintf_r+0x12a4>
   20ecc:	ea0000df 	b	21250 <_vfiprintf_r+0x1624>
   20ed0:	e24b50b8 	sub	r5, fp, #184	; 0xb8
   20ed4:	e2477010 	sub	r7, r7, #16
   20ed8:	e3570010 	cmp	r7, #16
   20edc:	caffffe3 	bgt	20e70 <_vfiprintf_r+0x1244>
   20ee0:	e59f33fc 	ldr	r3, [pc, #1020]	; 212e4 <_vfiprintf_r+0x16b8>
   20ee4:	e5853000 	str	r3, [r5]
   20ee8:	e1a03007 	mov	r3, r7
   20eec:	e5853004 	str	r3, [r5, #4]
   20ef0:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   20ef4:	e0833007 	add	r3, r3, r7
   20ef8:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   20efc:	e2855008 	add	r5, r5, #8
   20f00:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   20f04:	e2833001 	add	r3, r3, #1
   20f08:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   20f0c:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   20f10:	e3530007 	cmp	r3, #7
   20f14:	da00000a 	ble	20f44 <_vfiprintf_r+0x1318>
   20f18:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   20f1c:	e24b3078 	sub	r3, fp, #120	; 0x78
   20f20:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   20f24:	e1a01002 	mov	r1, r2
   20f28:	e1a02003 	mov	r2, r3
   20f2c:	ebfffa8e 	bl	1f96c <__sprint_r>
   20f30:	e1a03000 	mov	r3, r0
   20f34:	e3530000 	cmp	r3, #0
   20f38:	0a000000 	beq	20f40 <_vfiprintf_r+0x1314>
   20f3c:	ea0000c3 	b	21250 <_vfiprintf_r+0x1624>
   20f40:	e24b50b8 	sub	r5, fp, #184	; 0xb8

		/* leading zeroes from decimal precision */
		PAD (dprec - size, zeroes);
   20f44:	e51b204c 	ldr	r2, [fp, #-76]	; 0x4c
   20f48:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   20f4c:	e0637002 	rsb	r7, r3, r2
   20f50:	e3570000 	cmp	r7, #0
   20f54:	da000035 	ble	21030 <_vfiprintf_r+0x1404>
   20f58:	ea000019 	b	20fc4 <_vfiprintf_r+0x1398>
   20f5c:	e59f3380 	ldr	r3, [pc, #896]	; 212e4 <_vfiprintf_r+0x16b8>
   20f60:	e5853000 	str	r3, [r5]
   20f64:	e3a03010 	mov	r3, #16
   20f68:	e5853004 	str	r3, [r5, #4]
   20f6c:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   20f70:	e2833010 	add	r3, r3, #16
   20f74:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   20f78:	e2855008 	add	r5, r5, #8
   20f7c:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   20f80:	e2833001 	add	r3, r3, #1
   20f84:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   20f88:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   20f8c:	e3530007 	cmp	r3, #7
   20f90:	da00000a 	ble	20fc0 <_vfiprintf_r+0x1394>
   20f94:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   20f98:	e24b3078 	sub	r3, fp, #120	; 0x78
   20f9c:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   20fa0:	e1a01002 	mov	r1, r2
   20fa4:	e1a02003 	mov	r2, r3
   20fa8:	ebfffa6f 	bl	1f96c <__sprint_r>
   20fac:	e1a03000 	mov	r3, r0
   20fb0:	e3530000 	cmp	r3, #0
   20fb4:	0a000000 	beq	20fbc <_vfiprintf_r+0x1390>
   20fb8:	ea0000a4 	b	21250 <_vfiprintf_r+0x1624>
   20fbc:	e24b50b8 	sub	r5, fp, #184	; 0xb8
   20fc0:	e2477010 	sub	r7, r7, #16
   20fc4:	e3570010 	cmp	r7, #16
   20fc8:	caffffe3 	bgt	20f5c <_vfiprintf_r+0x1330>
   20fcc:	e59f3310 	ldr	r3, [pc, #784]	; 212e4 <_vfiprintf_r+0x16b8>
   20fd0:	e5853000 	str	r3, [r5]
   20fd4:	e1a03007 	mov	r3, r7
   20fd8:	e5853004 	str	r3, [r5, #4]
   20fdc:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   20fe0:	e0833007 	add	r3, r3, r7
   20fe4:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   20fe8:	e2855008 	add	r5, r5, #8
   20fec:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   20ff0:	e2833001 	add	r3, r3, #1
   20ff4:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   20ff8:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   20ffc:	e3530007 	cmp	r3, #7
   21000:	da00000a 	ble	21030 <_vfiprintf_r+0x1404>
   21004:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   21008:	e24b3078 	sub	r3, fp, #120	; 0x78
   2100c:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   21010:	e1a01002 	mov	r1, r2
   21014:	e1a02003 	mov	r2, r3
   21018:	ebfffa53 	bl	1f96c <__sprint_r>
   2101c:	e1a03000 	mov	r3, r0
   21020:	e3530000 	cmp	r3, #0
   21024:	0a000000 	beq	2102c <_vfiprintf_r+0x1400>
   21028:	ea000088 	b	21250 <_vfiprintf_r+0x1624>
   2102c:	e24b50b8 	sub	r5, fp, #184	; 0xb8
					PRINT (cp, 1);
				PRINT (expstr, expsize);
			}
		}
#else /* !FLOATING_POINT */
		PRINT (cp, size);
   21030:	e5856000 	str	r6, [r5]
   21034:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   21038:	e5853004 	str	r3, [r5, #4]
   2103c:	e51b2070 	ldr	r2, [fp, #-112]	; 0x70
   21040:	e51b3054 	ldr	r3, [fp, #-84]	; 0x54
   21044:	e0823003 	add	r3, r2, r3
   21048:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   2104c:	e2855008 	add	r5, r5, #8
   21050:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   21054:	e2833001 	add	r3, r3, #1
   21058:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   2105c:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   21060:	e3530007 	cmp	r3, #7
   21064:	da00000a 	ble	21094 <_vfiprintf_r+0x1468>
   21068:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   2106c:	e24b3078 	sub	r3, fp, #120	; 0x78
   21070:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   21074:	e1a01002 	mov	r1, r2
   21078:	e1a02003 	mov	r2, r3
   2107c:	ebfffa3a 	bl	1f96c <__sprint_r>
   21080:	e1a03000 	mov	r3, r0
   21084:	e3530000 	cmp	r3, #0
   21088:	0a000000 	beq	21090 <_vfiprintf_r+0x1464>
   2108c:	ea00006f 	b	21250 <_vfiprintf_r+0x1624>
   21090:	e24b50b8 	sub	r5, fp, #184	; 0xb8
#endif
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST)
   21094:	e2043004 	and	r3, r4, #4
   21098:	e3530000 	cmp	r3, #0
   2109c:	0a00003a 	beq	2118c <_vfiprintf_r+0x1560>
			PAD (width - realsz, blanks);
   210a0:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
   210a4:	e51b3050 	ldr	r3, [fp, #-80]	; 0x50
   210a8:	e0637002 	rsb	r7, r3, r2
   210ac:	e3570000 	cmp	r7, #0
   210b0:	da000035 	ble	2118c <_vfiprintf_r+0x1560>
   210b4:	ea000019 	b	21120 <_vfiprintf_r+0x14f4>
   210b8:	e59f3220 	ldr	r3, [pc, #544]	; 212e0 <_vfiprintf_r+0x16b4>
   210bc:	e5853000 	str	r3, [r5]
   210c0:	e3a03010 	mov	r3, #16
   210c4:	e5853004 	str	r3, [r5, #4]
   210c8:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   210cc:	e2833010 	add	r3, r3, #16
   210d0:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   210d4:	e2855008 	add	r5, r5, #8
   210d8:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   210dc:	e2833001 	add	r3, r3, #1
   210e0:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   210e4:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   210e8:	e3530007 	cmp	r3, #7
   210ec:	da00000a 	ble	2111c <_vfiprintf_r+0x14f0>
   210f0:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   210f4:	e24b3078 	sub	r3, fp, #120	; 0x78
   210f8:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   210fc:	e1a01002 	mov	r1, r2
   21100:	e1a02003 	mov	r2, r3
   21104:	ebfffa18 	bl	1f96c <__sprint_r>
   21108:	e1a03000 	mov	r3, r0
   2110c:	e3530000 	cmp	r3, #0
   21110:	0a000000 	beq	21118 <_vfiprintf_r+0x14ec>
   21114:	ea00004d 	b	21250 <_vfiprintf_r+0x1624>
   21118:	e24b50b8 	sub	r5, fp, #184	; 0xb8
   2111c:	e2477010 	sub	r7, r7, #16
   21120:	e3570010 	cmp	r7, #16
   21124:	caffffe3 	bgt	210b8 <_vfiprintf_r+0x148c>
   21128:	e59f31b0 	ldr	r3, [pc, #432]	; 212e0 <_vfiprintf_r+0x16b4>
   2112c:	e5853000 	str	r3, [r5]
   21130:	e1a03007 	mov	r3, r7
   21134:	e5853004 	str	r3, [r5, #4]
   21138:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   2113c:	e0833007 	add	r3, r3, r7
   21140:	e50b3070 	str	r3, [fp, #-112]	; 0x70
   21144:	e2855008 	add	r5, r5, #8
   21148:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   2114c:	e2833001 	add	r3, r3, #1
   21150:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   21154:	e51b3074 	ldr	r3, [fp, #-116]	; 0x74
   21158:	e3530007 	cmp	r3, #7
   2115c:	da00000a 	ble	2118c <_vfiprintf_r+0x1560>
   21160:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   21164:	e24b3078 	sub	r3, fp, #120	; 0x78
   21168:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   2116c:	e1a01002 	mov	r1, r2
   21170:	e1a02003 	mov	r2, r3
   21174:	ebfff9fc 	bl	1f96c <__sprint_r>
   21178:	e1a03000 	mov	r3, r0
   2117c:	e3530000 	cmp	r3, #0
   21180:	0a000000 	beq	21188 <_vfiprintf_r+0x155c>
   21184:	ea000031 	b	21250 <_vfiprintf_r+0x1624>
   21188:	e24b50b8 	sub	r5, fp, #184	; 0xb8

		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;
   2118c:	e51b2050 	ldr	r2, [fp, #-80]	; 0x50
   21190:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   21194:	e1520003 	cmp	r2, r3
   21198:	a1a03002 	movge	r3, r2
   2119c:	b1a03003 	movlt	r3, r3
   211a0:	e51b2020 	ldr	r2, [fp, #-32]
   211a4:	e0823003 	add	r3, r2, r3
   211a8:	e50b3020 	str	r3, [fp, #-32]

		FLUSH ();	/* copy out the I/O vectors */
   211ac:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   211b0:	e3530000 	cmp	r3, #0
   211b4:	0a000009 	beq	211e0 <_vfiprintf_r+0x15b4>
   211b8:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   211bc:	e24b3078 	sub	r3, fp, #120	; 0x78
   211c0:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   211c4:	e1a01002 	mov	r1, r2
   211c8:	e1a02003 	mov	r2, r3
   211cc:	ebfff9e6 	bl	1f96c <__sprint_r>
   211d0:	e1a03000 	mov	r3, r0
   211d4:	e3530000 	cmp	r3, #0
   211d8:	0a000000 	beq	211e0 <_vfiprintf_r+0x15b4>
   211dc:	ea00001b 	b	21250 <_vfiprintf_r+0x1624>
   211e0:	e3a03000 	mov	r3, #0
   211e4:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   211e8:	e24b50b8 	sub	r5, fp, #184	; 0xb8

                if (malloc_buf != NULL) {
   211ec:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   211f0:	e3530000 	cmp	r3, #0
   211f4:	0a000004 	beq	2120c <_vfiprintf_r+0x15e0>
			_free_r (data, malloc_buf);
   211f8:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   211fc:	e51b105c 	ldr	r1, [fp, #-92]	; 0x5c
   21200:	ebffe1a5 	bl	1989c <_free_r>
			malloc_buf = NULL;
   21204:	e3a03000 	mov	r3, #0
   21208:	e50b305c 	str	r3, [fp, #-92]	; 0x5c
		}
	}
   2120c:	eafffb22 	b	1fe9c <_vfiprintf_r+0x270>
done:
	FLUSH ();
   21210:	e51b3070 	ldr	r3, [fp, #-112]	; 0x70
   21214:	e3530000 	cmp	r3, #0
   21218:	0a000009 	beq	21244 <_vfiprintf_r+0x1618>
   2121c:	e51b212c 	ldr	r2, [fp, #-300]	; 0x12c
   21220:	e24b3078 	sub	r3, fp, #120	; 0x78
   21224:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   21228:	e1a01002 	mov	r1, r2
   2122c:	e1a02003 	mov	r2, r3
   21230:	ebfff9cd 	bl	1f96c <__sprint_r>
   21234:	e1a03000 	mov	r3, r0
   21238:	e3530000 	cmp	r3, #0
   2123c:	0a000000 	beq	21244 <_vfiprintf_r+0x1618>
   21240:	ea000002 	b	21250 <_vfiprintf_r+0x1624>
   21244:	e3a03000 	mov	r3, #0
   21248:	e50b3074 	str	r3, [fp, #-116]	; 0x74
   2124c:	e24b50b8 	sub	r5, fp, #184	; 0xb8
error:
	if (malloc_buf != NULL)
   21250:	e51b305c 	ldr	r3, [fp, #-92]	; 0x5c
   21254:	e3530000 	cmp	r3, #0
   21258:	0a000002 	beq	21268 <_vfiprintf_r+0x163c>
		_free_r (data, malloc_buf);
   2125c:	e51b0128 	ldr	r0, [fp, #-296]	; 0x128
   21260:	e51b105c 	ldr	r1, [fp, #-92]	; 0x5c
   21264:	ebffe18c 	bl	1989c <_free_r>
#ifndef STRING_ONLY
	_newlib_flockfile_end (fp);
   21268:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   2126c:	e1d330bc 	ldrh	r3, [r3, #12]
   21270:	e1a03803 	lsl	r3, r3, #16
   21274:	e1a03823 	lsr	r3, r3, #16
   21278:	e2033c02 	and	r3, r3, #512	; 0x200
   2127c:	e3530000 	cmp	r3, #0
   21280:	1a000003 	bne	21294 <_vfiprintf_r+0x1668>
   21284:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   21288:	e283305c 	add	r3, r3, #92	; 0x5c
   2128c:	e1a00003 	mov	r0, r3
   21290:	ebffb641 	bl	eb9c <_dna_lock_release>
#endif
	return (__sferror (fp) ? EOF : ret);
   21294:	e51b312c 	ldr	r3, [fp, #-300]	; 0x12c
   21298:	e1d330bc 	ldrh	r3, [r3, #12]
   2129c:	e1a03803 	lsl	r3, r3, #16
   212a0:	e1a03823 	lsr	r3, r3, #16
   212a4:	e2033040 	and	r3, r3, #64	; 0x40
   212a8:	e3530000 	cmp	r3, #0
   212ac:	1a000001 	bne	212b8 <_vfiprintf_r+0x168c>
   212b0:	e51b3020 	ldr	r3, [fp, #-32]
   212b4:	ea000000 	b	212bc <_vfiprintf_r+0x1690>
   212b8:	e3e03000 	mvn	r3, #0
   212bc:	e1a00000 	nop			; (mov r0, r0)
	/* NOTREACHED */
}
   212c0:	e1a00003 	mov	r0, r3
   212c4:	e24bd01c 	sub	sp, fp, #28
   212c8:	e8bd4bf0 	pop	{r4, r5, r6, r7, r8, r9, fp, lr}
   212cc:	e12fff1e 	bx	lr
   212d0:	000249c4 	.word	0x000249c4
   212d4:	000249d8 	.word	0x000249d8
   212d8:	000249e0 	.word	0x000249e0
   212dc:	000249f4 	.word	0x000249f4
   212e0:	00024a10 	.word	0x00024a10
   212e4:	00024a20 	.word	0x00024a20

000212e8 <_write_r>:
_DEFUN (_write_r, (ptr, fd, buf, cnt),
     struct _reent *ptr _AND
     int fd _AND
     _CONST _PTR buf _AND
     size_t cnt)
{
   212e8:	e92d4800 	push	{fp, lr}
   212ec:	e28db004 	add	fp, sp, #4
   212f0:	e24dd018 	sub	sp, sp, #24
   212f4:	e50b0010 	str	r0, [fp, #-16]
   212f8:	e50b1014 	str	r1, [fp, #-20]
   212fc:	e50b2018 	str	r2, [fp, #-24]
   21300:	e50b301c 	str	r3, [fp, #-28]
  _ssize_t ret;

  errno = 0;
   21304:	e59f3058 	ldr	r3, [pc, #88]	; 21364 <_write_r+0x7c>
   21308:	e3a02000 	mov	r2, #0
   2130c:	e5832000 	str	r2, [r3]
  if ((ret = (_ssize_t)_write (fd, buf, cnt)) == -1 && errno != 0)
   21310:	e51b0014 	ldr	r0, [fp, #-20]
   21314:	e51b1018 	ldr	r1, [fp, #-24]
   21318:	e51b201c 	ldr	r2, [fp, #-28]
   2131c:	ebffd5e2 	bl	16aac <write>
   21320:	e50b0008 	str	r0, [fp, #-8]
   21324:	e51b3008 	ldr	r3, [fp, #-8]
   21328:	e3730001 	cmn	r3, #1
   2132c:	1a000007 	bne	21350 <_write_r+0x68>
   21330:	e59f302c 	ldr	r3, [pc, #44]	; 21364 <_write_r+0x7c>
   21334:	e5933000 	ldr	r3, [r3]
   21338:	e3530000 	cmp	r3, #0
   2133c:	0a000003 	beq	21350 <_write_r+0x68>
    ptr->_errno = errno;
   21340:	e59f301c 	ldr	r3, [pc, #28]	; 21364 <_write_r+0x7c>
   21344:	e5932000 	ldr	r2, [r3]
   21348:	e51b3010 	ldr	r3, [fp, #-16]
   2134c:	e5832000 	str	r2, [r3]
  return ret;
   21350:	e51b3008 	ldr	r3, [fp, #-8]
}
   21354:	e1a00003 	mov	r0, r3
   21358:	e24bd004 	sub	sp, fp, #4
   2135c:	e8bd4800 	pop	{fp, lr}
   21360:	e12fff1e 	bx	lr
   21364:	000819b0 	.word	0x000819b0

00021368 <_calloc_r>:
#if __STD_C
Void_t* cALLOc(RARG size_t n, size_t elem_size)
#else
Void_t* cALLOc(RARG n, elem_size) RDECL size_t n; size_t elem_size;
#endif
{
   21368:	e92d4800 	push	{fp, lr}
   2136c:	e28db004 	add	fp, sp, #4
   21370:	e24dd028 	sub	sp, sp, #40	; 0x28
   21374:	e50b0020 	str	r0, [fp, #-32]
   21378:	e50b1024 	str	r1, [fp, #-36]	; 0x24
   2137c:	e50b2028 	str	r2, [fp, #-40]	; 0x28
  mchunkptr p;
  INTERNAL_SIZE_T csz;

  INTERNAL_SIZE_T sz = n * elem_size;
   21380:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   21384:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   21388:	e0030392 	mul	r3, r2, r3
   2138c:	e50b300c 	str	r3, [fp, #-12]
  MALLOC_LOCK;
  oldtop = top;
  oldtopsize = chunksize(top);
#endif

  mem = mALLOc (RCALL sz);
   21390:	e51b0020 	ldr	r0, [fp, #-32]
   21394:	e51b100c 	ldr	r1, [fp, #-12]
   21398:	ebffb725 	bl	f034 <_malloc_r>
   2139c:	e50b0010 	str	r0, [fp, #-16]

  if (mem == 0) 
   213a0:	e51b3010 	ldr	r3, [fp, #-16]
   213a4:	e3530000 	cmp	r3, #0
   213a8:	1a000001 	bne	213b4 <_calloc_r+0x4c>
  {
#if MORECORE_CLEARS
    MALLOC_UNLOCK;
#endif
    return 0;
   213ac:	e3a03000 	mov	r3, #0
   213b0:	ea000048 	b	214d8 <_calloc_r+0x170>
  }
  else
  {
    p = mem2chunk(mem);
   213b4:	e51b3010 	ldr	r3, [fp, #-16]
   213b8:	e2433008 	sub	r3, r3, #8
   213bc:	e50b3014 	str	r3, [fp, #-20]
#endif
      return mem;
    }
#endif

    csz = chunksize(p);
   213c0:	e51b3014 	ldr	r3, [fp, #-20]
   213c4:	e5933004 	ldr	r3, [r3, #4]
   213c8:	e3c33003 	bic	r3, r3, #3
   213cc:	e50b3018 	str	r3, [fp, #-24]
      csz = oldtopsize;
    }
    MALLOC_UNLOCK;
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
   213d0:	e51b3018 	ldr	r3, [fp, #-24]
   213d4:	e2433004 	sub	r3, r3, #4
   213d8:	e50b301c 	str	r3, [fp, #-28]
   213dc:	e51b301c 	ldr	r3, [fp, #-28]
   213e0:	e3530024 	cmp	r3, #36	; 0x24
   213e4:	8a000036 	bhi	214c4 <_calloc_r+0x15c>
   213e8:	e51b3010 	ldr	r3, [fp, #-16]
   213ec:	e50b3008 	str	r3, [fp, #-8]
   213f0:	e51b301c 	ldr	r3, [fp, #-28]
   213f4:	e3530013 	cmp	r3, #19
   213f8:	9a000023 	bls	2148c <_calloc_r+0x124>
   213fc:	e51b3008 	ldr	r3, [fp, #-8]
   21400:	e2832004 	add	r2, r3, #4
   21404:	e50b2008 	str	r2, [fp, #-8]
   21408:	e3a02000 	mov	r2, #0
   2140c:	e5832000 	str	r2, [r3]
   21410:	e51b3008 	ldr	r3, [fp, #-8]
   21414:	e2832004 	add	r2, r3, #4
   21418:	e50b2008 	str	r2, [fp, #-8]
   2141c:	e3a02000 	mov	r2, #0
   21420:	e5832000 	str	r2, [r3]
   21424:	e51b301c 	ldr	r3, [fp, #-28]
   21428:	e353001b 	cmp	r3, #27
   2142c:	9a000016 	bls	2148c <_calloc_r+0x124>
   21430:	e51b3008 	ldr	r3, [fp, #-8]
   21434:	e2832004 	add	r2, r3, #4
   21438:	e50b2008 	str	r2, [fp, #-8]
   2143c:	e3a02000 	mov	r2, #0
   21440:	e5832000 	str	r2, [r3]
   21444:	e51b3008 	ldr	r3, [fp, #-8]
   21448:	e2832004 	add	r2, r3, #4
   2144c:	e50b2008 	str	r2, [fp, #-8]
   21450:	e3a02000 	mov	r2, #0
   21454:	e5832000 	str	r2, [r3]
   21458:	e51b301c 	ldr	r3, [fp, #-28]
   2145c:	e3530023 	cmp	r3, #35	; 0x23
   21460:	9a000009 	bls	2148c <_calloc_r+0x124>
   21464:	e51b3008 	ldr	r3, [fp, #-8]
   21468:	e2832004 	add	r2, r3, #4
   2146c:	e50b2008 	str	r2, [fp, #-8]
   21470:	e3a02000 	mov	r2, #0
   21474:	e5832000 	str	r2, [r3]
   21478:	e51b3008 	ldr	r3, [fp, #-8]
   2147c:	e2832004 	add	r2, r3, #4
   21480:	e50b2008 	str	r2, [fp, #-8]
   21484:	e3a02000 	mov	r2, #0
   21488:	e5832000 	str	r2, [r3]
   2148c:	e51b3008 	ldr	r3, [fp, #-8]
   21490:	e2832004 	add	r2, r3, #4
   21494:	e50b2008 	str	r2, [fp, #-8]
   21498:	e3a02000 	mov	r2, #0
   2149c:	e5832000 	str	r2, [r3]
   214a0:	e51b3008 	ldr	r3, [fp, #-8]
   214a4:	e2832004 	add	r2, r3, #4
   214a8:	e50b2008 	str	r2, [fp, #-8]
   214ac:	e3a02000 	mov	r2, #0
   214b0:	e5832000 	str	r2, [r3]
   214b4:	e51b3008 	ldr	r3, [fp, #-8]
   214b8:	e3a02000 	mov	r2, #0
   214bc:	e5832000 	str	r2, [r3]
   214c0:	ea000003 	b	214d4 <_calloc_r+0x16c>
   214c4:	e51b0010 	ldr	r0, [fp, #-16]
   214c8:	e3a01000 	mov	r1, #0
   214cc:	e51b201c 	ldr	r2, [fp, #-28]
   214d0:	ebffba08 	bl	fcf8 <memset>
    return mem;
   214d4:	e51b3010 	ldr	r3, [fp, #-16]
  }
}
   214d8:	e1a00003 	mov	r0, r3
   214dc:	e24bd004 	sub	sp, fp, #4
   214e0:	e8bd4800 	pop	{fp, lr}
   214e4:	e12fff1e 	bx	lr

000214e8 <_close_r>:

int
_close_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
   214e8:	e92d4800 	push	{fp, lr}
   214ec:	e28db004 	add	fp, sp, #4
   214f0:	e24dd010 	sub	sp, sp, #16
   214f4:	e50b0010 	str	r0, [fp, #-16]
   214f8:	e50b1014 	str	r1, [fp, #-20]
  int ret;

  errno = 0;
   214fc:	e59f3050 	ldr	r3, [pc, #80]	; 21554 <_close_r+0x6c>
   21500:	e3a02000 	mov	r2, #0
   21504:	e5832000 	str	r2, [r3]
  if ((ret = _close (fd)) == -1 && errno != 0)
   21508:	e51b0014 	ldr	r0, [fp, #-20]
   2150c:	ebffb4b3 	bl	e7e0 <close>
   21510:	e50b0008 	str	r0, [fp, #-8]
   21514:	e51b3008 	ldr	r3, [fp, #-8]
   21518:	e3730001 	cmn	r3, #1
   2151c:	1a000007 	bne	21540 <_close_r+0x58>
   21520:	e59f302c 	ldr	r3, [pc, #44]	; 21554 <_close_r+0x6c>
   21524:	e5933000 	ldr	r3, [r3]
   21528:	e3530000 	cmp	r3, #0
   2152c:	0a000003 	beq	21540 <_close_r+0x58>
    ptr->_errno = errno;
   21530:	e59f301c 	ldr	r3, [pc, #28]	; 21554 <_close_r+0x6c>
   21534:	e5932000 	ldr	r2, [r3]
   21538:	e51b3010 	ldr	r3, [fp, #-16]
   2153c:	e5832000 	str	r2, [r3]
  return ret;
   21540:	e51b3008 	ldr	r3, [fp, #-8]
}
   21544:	e1a00003 	mov	r0, r3
   21548:	e24bd004 	sub	sp, fp, #4
   2154c:	e8bd4800 	pop	{fp, lr}
   21550:	e12fff1e 	bx	lr
   21554:	000819b0 	.word	0x000819b0

00021558 <__errno>:

extern int * __libthread__errno (void);

int *
__errno ()
{
   21558:	e92d4800 	push	{fp, lr}
   2155c:	e28db004 	add	fp, sp, #4
  return __libthread_errno ();
   21560:	ebff8054 	bl	16b8 <__libthread_errno>
   21564:	e1a03000 	mov	r3, r0
}
   21568:	e1a00003 	mov	r0, r3
   2156c:	e24bd004 	sub	sp, fp, #4
   21570:	e8bd4800 	pop	{fp, lr}
   21574:	e12fff1e 	bx	lr

00021578 <_fclose_r>:

int
_DEFUN(_fclose_r, (rptr, fp),
      struct _reent *rptr _AND
      register FILE * fp)
{
   21578:	e92d4810 	push	{r4, fp, lr}
   2157c:	e28db008 	add	fp, sp, #8
   21580:	e24dd014 	sub	sp, sp, #20
   21584:	e50b0018 	str	r0, [fp, #-24]
   21588:	e1a04001 	mov	r4, r1
  int r;

  if (fp == NULL)
   2158c:	e3540000 	cmp	r4, #0
   21590:	1a000001 	bne	2159c <_fclose_r+0x24>
    return (0);			/* on NULL */
   21594:	e3a03000 	mov	r3, #0
   21598:	ea000064 	b	21730 <_fclose_r+0x1b8>

  CHECK_INIT (rptr, fp);
   2159c:	e51b3018 	ldr	r3, [fp, #-24]
   215a0:	e50b3014 	str	r3, [fp, #-20]
   215a4:	e51b3014 	ldr	r3, [fp, #-20]
   215a8:	e3530000 	cmp	r3, #0
   215ac:	0a000005 	beq	215c8 <_fclose_r+0x50>
   215b0:	e51b3014 	ldr	r3, [fp, #-20]
   215b4:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   215b8:	e3530000 	cmp	r3, #0
   215bc:	1a000001 	bne	215c8 <_fclose_r+0x50>
   215c0:	e51b0014 	ldr	r0, [fp, #-20]
   215c4:	ebffe01d 	bl	19640 <__sinit>
     interlocked locking with the sfp_lock. */
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  int __oldcancel;
  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &__oldcancel);
#endif
  _flockfile (fp);
   215c8:	e1d430bc 	ldrh	r3, [r4, #12]
   215cc:	e1a03803 	lsl	r3, r3, #16
   215d0:	e1a03823 	lsr	r3, r3, #16
   215d4:	e2033c02 	and	r3, r3, #512	; 0x200
   215d8:	e3530000 	cmp	r3, #0
   215dc:	1a000002 	bne	215ec <_fclose_r+0x74>
   215e0:	e284305c 	add	r3, r4, #92	; 0x5c
   215e4:	e1a00003 	mov	r0, r3
   215e8:	ebffb504 	bl	ea00 <_dna_lock_acquire>

  if (fp->_flags == 0)		/* not open! */
   215ec:	e1d430bc 	ldrh	r3, [r4, #12]
   215f0:	e3530000 	cmp	r3, #0
   215f4:	1a00000a 	bne	21624 <_fclose_r+0xac>
    {
      _funlockfile (fp);
   215f8:	e1d430bc 	ldrh	r3, [r4, #12]
   215fc:	e1a03803 	lsl	r3, r3, #16
   21600:	e1a03823 	lsr	r3, r3, #16
   21604:	e2033c02 	and	r3, r3, #512	; 0x200
   21608:	e3530000 	cmp	r3, #0
   2160c:	1a000002 	bne	2161c <_fclose_r+0xa4>
   21610:	e284305c 	add	r3, r4, #92	; 0x5c
   21614:	e1a00003 	mov	r0, r3
   21618:	ebffb55f 	bl	eb9c <_dna_lock_release>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
      pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif
      return (0);
   2161c:	e3a03000 	mov	r3, #0
   21620:	ea000042 	b	21730 <_fclose_r+0x1b8>
    }
  /* Unconditionally flush to allow special handling for seekable read
     files to reposition file to last byte processed as opposed to
     last byte read ahead into the buffer.  */
  r = _fflush_r (rptr, fp);
   21624:	e51b0018 	ldr	r0, [fp, #-24]
   21628:	e1a01004 	mov	r1, r4
   2162c:	ebffdeb8 	bl	19114 <_fflush_r>
   21630:	e50b0010 	str	r0, [fp, #-16]
  if (fp->_close != NULL && fp->_close (rptr, fp->_cookie) < 0)
   21634:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
   21638:	e3530000 	cmp	r3, #0
   2163c:	0a00000a 	beq	2166c <_fclose_r+0xf4>
   21640:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
   21644:	e594201c 	ldr	r2, [r4, #28]
   21648:	e51b0018 	ldr	r0, [fp, #-24]
   2164c:	e1a01002 	mov	r1, r2
   21650:	e1a0e00f 	mov	lr, pc
   21654:	e12fff13 	bx	r3
   21658:	e1a03000 	mov	r3, r0
   2165c:	e3530000 	cmp	r3, #0
   21660:	aa000001 	bge	2166c <_fclose_r+0xf4>
    r = EOF;
   21664:	e3e03000 	mvn	r3, #0
   21668:	e50b3010 	str	r3, [fp, #-16]
  if (fp->_flags & __SMBF)
   2166c:	e1d430bc 	ldrh	r3, [r4, #12]
   21670:	e1a03803 	lsl	r3, r3, #16
   21674:	e1a03823 	lsr	r3, r3, #16
   21678:	e2033080 	and	r3, r3, #128	; 0x80
   2167c:	e3530000 	cmp	r3, #0
   21680:	0a000003 	beq	21694 <_fclose_r+0x11c>
    _free_r (rptr, (char *) fp->_bf._base);
   21684:	e5943010 	ldr	r3, [r4, #16]
   21688:	e51b0018 	ldr	r0, [fp, #-24]
   2168c:	e1a01003 	mov	r1, r3
   21690:	ebffe081 	bl	1989c <_free_r>
  if (HASUB (fp))
   21694:	e5943030 	ldr	r3, [r4, #48]	; 0x30
   21698:	e3530000 	cmp	r3, #0
   2169c:	0a000009 	beq	216c8 <_fclose_r+0x150>
    FREEUB (rptr, fp);
   216a0:	e5942030 	ldr	r2, [r4, #48]	; 0x30
   216a4:	e2843040 	add	r3, r4, #64	; 0x40
   216a8:	e1520003 	cmp	r2, r3
   216ac:	0a000003 	beq	216c0 <_fclose_r+0x148>
   216b0:	e5943030 	ldr	r3, [r4, #48]	; 0x30
   216b4:	e51b0018 	ldr	r0, [fp, #-24]
   216b8:	e1a01003 	mov	r1, r3
   216bc:	ebffe076 	bl	1989c <_free_r>
   216c0:	e3a03000 	mov	r3, #0
   216c4:	e5843030 	str	r3, [r4, #48]	; 0x30
  if (HASLB (fp))
   216c8:	e5943044 	ldr	r3, [r4, #68]	; 0x44
   216cc:	e3530000 	cmp	r3, #0
   216d0:	0a000005 	beq	216ec <_fclose_r+0x174>
    FREELB (rptr, fp);
   216d4:	e5943044 	ldr	r3, [r4, #68]	; 0x44
   216d8:	e51b0018 	ldr	r0, [fp, #-24]
   216dc:	e1a01003 	mov	r1, r3
   216e0:	ebffe06d 	bl	1989c <_free_r>
   216e4:	e3a03000 	mov	r3, #0
   216e8:	e5843044 	str	r3, [r4, #68]	; 0x44
  __sfp_lock_acquire ();
   216ec:	ebffe008 	bl	19714 <__sfp_lock_acquire>
  fp->_flags = 0;		/* release this FILE for reuse */
   216f0:	e3a03000 	mov	r3, #0
   216f4:	e1c430bc 	strh	r3, [r4, #12]
  _funlockfile (fp);
   216f8:	e1d430bc 	ldrh	r3, [r4, #12]
   216fc:	e1a03803 	lsl	r3, r3, #16
   21700:	e1a03823 	lsr	r3, r3, #16
   21704:	e2033c02 	and	r3, r3, #512	; 0x200
   21708:	e3530000 	cmp	r3, #0
   2170c:	1a000002 	bne	2171c <_fclose_r+0x1a4>
   21710:	e284305c 	add	r3, r4, #92	; 0x5c
   21714:	e1a00003 	mov	r0, r3
   21718:	ebffb51f 	bl	eb9c <_dna_lock_release>
#ifndef __SINGLE_THREAD__
  __lock_close_recursive (fp->_lock);
   2171c:	e284305c 	add	r3, r4, #92	; 0x5c
   21720:	e1a00003 	mov	r0, r3
   21724:	ebffb490 	bl	e96c <_dna_lock_close>
#endif

  __sfp_lock_release ();
   21728:	ebffe001 	bl	19734 <__sfp_lock_release>
#ifdef _STDIO_WITH_THREAD_CANCELLATION_SUPPORT
  pthread_setcancelstate (__oldcancel, &__oldcancel);
#endif

  return (r);
   2172c:	e51b3010 	ldr	r3, [fp, #-16]
}
   21730:	e1a00003 	mov	r0, r3
   21734:	e24bd008 	sub	sp, fp, #8
   21738:	e8bd4810 	pop	{r4, fp, lr}
   2173c:	e12fff1e 	bx	lr

00021740 <fclose>:
#ifndef _REENT_ONLY

int
_DEFUN(fclose, (fp),
       register FILE * fp)
{
   21740:	e92d4800 	push	{fp, lr}
   21744:	e28db004 	add	fp, sp, #4
   21748:	e1a03000 	mov	r3, r0
  return _fclose_r(_REENT, fp);
   2174c:	e59f2020 	ldr	r2, [pc, #32]	; 21774 <fclose+0x34>
   21750:	e5922000 	ldr	r2, [r2]
   21754:	e1a00002 	mov	r0, r2
   21758:	e1a01003 	mov	r1, r3
   2175c:	ebffff85 	bl	21578 <_fclose_r>
   21760:	e1a03000 	mov	r3, r0
}
   21764:	e1a00003 	mov	r0, r3
   21768:	e24bd004 	sub	sp, fp, #4
   2176c:	e8bd4800 	pop	{fp, lr}
   21770:	e12fff1e 	bx	lr
   21774:	00025440 	.word	0x00025440

00021778 <__fputwc>:
static wint_t
_DEFUN(__fputwc, (ptr, wc, fp),
	struct _reent *ptr _AND
	wchar_t wc _AND
	FILE *fp)
{
   21778:	e92d4800 	push	{fp, lr}
   2177c:	e28db004 	add	fp, sp, #4
   21780:	e24dd020 	sub	sp, sp, #32
   21784:	e50b0018 	str	r0, [fp, #-24]
   21788:	e50b101c 	str	r1, [fp, #-28]
   2178c:	e50b2020 	str	r2, [fp, #-32]
  char buf[MB_LEN_MAX];
  size_t i, len;

  if (MB_CUR_MAX == 1 && wc > 0 && wc <= UCHAR_MAX)
   21790:	ebffe445 	bl	1a8ac <__locale_mb_cur_max>
   21794:	e1a03000 	mov	r3, r0
   21798:	e3530001 	cmp	r3, #1
   2179c:	1a00000b 	bne	217d0 <__fputwc+0x58>
   217a0:	e51b301c 	ldr	r3, [fp, #-28]
   217a4:	e3530000 	cmp	r3, #0
   217a8:	0a000008 	beq	217d0 <__fputwc+0x58>
   217ac:	e51b301c 	ldr	r3, [fp, #-28]
   217b0:	e35300ff 	cmp	r3, #255	; 0xff
   217b4:	8a000005 	bhi	217d0 <__fputwc+0x58>
      /*
       * Assume single-byte locale with no special encoding.
       * A more careful test would be to check
       * _CurrentRuneLocale->encoding.
       */
      *buf = (unsigned char)wc;
   217b8:	e51b301c 	ldr	r3, [fp, #-28]
   217bc:	e20330ff 	and	r3, r3, #255	; 0xff
   217c0:	e54b3010 	strb	r3, [fp, #-16]
      len = 1;
   217c4:	e3a03001 	mov	r3, #1
   217c8:	e50b300c 	str	r3, [fp, #-12]
   217cc:	ea000013 	b	21820 <__fputwc+0xa8>
    }
  else
    {
      if ((len = _wcrtomb_r (ptr, buf, wc, &fp->_mbstate)) == (size_t) -1)
   217d0:	e51b3020 	ldr	r3, [fp, #-32]
   217d4:	e2833064 	add	r3, r3, #100	; 0x64
   217d8:	e24b2010 	sub	r2, fp, #16
   217dc:	e51b0018 	ldr	r0, [fp, #-24]
   217e0:	e1a01002 	mov	r1, r2
   217e4:	e51b201c 	ldr	r2, [fp, #-28]
   217e8:	eb0001c2 	bl	21ef8 <_wcrtomb_r>
   217ec:	e50b000c 	str	r0, [fp, #-12]
   217f0:	e51b300c 	ldr	r3, [fp, #-12]
   217f4:	e3730001 	cmn	r3, #1
   217f8:	1a000008 	bne	21820 <__fputwc+0xa8>
	{
	  fp->_flags |= __SERR;
   217fc:	e51b3020 	ldr	r3, [fp, #-32]
   21800:	e1d330bc 	ldrh	r3, [r3, #12]
   21804:	e3833040 	orr	r3, r3, #64	; 0x40
   21808:	e1a03803 	lsl	r3, r3, #16
   2180c:	e1a02823 	lsr	r2, r3, #16
   21810:	e51b3020 	ldr	r3, [fp, #-32]
   21814:	e1c320bc 	strh	r2, [r3, #12]
	  return WEOF;
   21818:	e3e03000 	mvn	r3, #0
   2181c:	ea000063 	b	219b0 <__fputwc+0x238>
	}
    }

  for (i = 0; i < len; i++)
   21820:	e3a03000 	mov	r3, #0
   21824:	e50b3008 	str	r3, [fp, #-8]
   21828:	ea00005b 	b	2199c <__fputwc+0x224>
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
   2182c:	e51b3020 	ldr	r3, [fp, #-32]
   21830:	e5933008 	ldr	r3, [r3, #8]
   21834:	e2432001 	sub	r2, r3, #1
   21838:	e51b3020 	ldr	r3, [fp, #-32]
   2183c:	e5832008 	str	r2, [r3, #8]
   21840:	e51b3020 	ldr	r3, [fp, #-32]
   21844:	e5933008 	ldr	r3, [r3, #8]
   21848:	e3530000 	cmp	r3, #0
   2184c:	aa000038 	bge	21934 <__fputwc+0x1bc>
   21850:	e51b3020 	ldr	r3, [fp, #-32]
   21854:	e5932008 	ldr	r2, [r3, #8]
   21858:	e51b3020 	ldr	r3, [fp, #-32]
   2185c:	e5933018 	ldr	r3, [r3, #24]
   21860:	e1520003 	cmp	r2, r3
   21864:	ba000022 	blt	218f4 <__fputwc+0x17c>
   21868:	e51b3020 	ldr	r3, [fp, #-32]
   2186c:	e5933000 	ldr	r3, [r3]
   21870:	e3e0200b 	mvn	r2, #11
   21874:	e51b1008 	ldr	r1, [fp, #-8]
   21878:	e24b0004 	sub	r0, fp, #4
   2187c:	e0801001 	add	r1, r0, r1
   21880:	e0812002 	add	r2, r1, r2
   21884:	e5d22000 	ldrb	r2, [r2]
   21888:	e5c32000 	strb	r2, [r3]
   2188c:	e51b3020 	ldr	r3, [fp, #-32]
   21890:	e5933000 	ldr	r3, [r3]
   21894:	e5d33000 	ldrb	r3, [r3]
   21898:	e353000a 	cmp	r3, #10
   2189c:	0a00000a 	beq	218cc <__fputwc+0x154>
   218a0:	e51b3020 	ldr	r3, [fp, #-32]
   218a4:	e5933000 	ldr	r3, [r3]
   218a8:	e2831001 	add	r1, r3, #1
   218ac:	e51b2020 	ldr	r2, [fp, #-32]
   218b0:	e5821000 	str	r1, [r2]
   218b4:	e5d33000 	ldrb	r3, [r3]
   218b8:	e3730001 	cmn	r3, #1
   218bc:	03a03001 	moveq	r3, #1
   218c0:	13a03000 	movne	r3, #0
   218c4:	e20330ff 	and	r3, r3, #255	; 0xff
   218c8:	ea00002c 	b	21980 <__fputwc+0x208>
   218cc:	e51b0018 	ldr	r0, [fp, #-24]
   218d0:	e3a0100a 	mov	r1, #10
   218d4:	e51b2020 	ldr	r2, [fp, #-32]
   218d8:	eb000111 	bl	21d24 <__swbuf_r>
   218dc:	e1a03000 	mov	r3, r0
   218e0:	e3730001 	cmn	r3, #1
   218e4:	03a03001 	moveq	r3, #1
   218e8:	13a03000 	movne	r3, #0
   218ec:	e20330ff 	and	r3, r3, #255	; 0xff
   218f0:	ea000022 	b	21980 <__fputwc+0x208>
   218f4:	e3e0300b 	mvn	r3, #11
   218f8:	e51b2008 	ldr	r2, [fp, #-8]
   218fc:	e24b1004 	sub	r1, fp, #4
   21900:	e0812002 	add	r2, r1, r2
   21904:	e0823003 	add	r3, r2, r3
   21908:	e5d33000 	ldrb	r3, [r3]
   2190c:	e51b0018 	ldr	r0, [fp, #-24]
   21910:	e1a01003 	mov	r1, r3
   21914:	e51b2020 	ldr	r2, [fp, #-32]
   21918:	eb000101 	bl	21d24 <__swbuf_r>
   2191c:	e1a03000 	mov	r3, r0
   21920:	e3730001 	cmn	r3, #1
   21924:	03a03001 	moveq	r3, #1
   21928:	13a03000 	movne	r3, #0
   2192c:	e20330ff 	and	r3, r3, #255	; 0xff
   21930:	ea000012 	b	21980 <__fputwc+0x208>
   21934:	e51b3020 	ldr	r3, [fp, #-32]
   21938:	e5933000 	ldr	r3, [r3]
   2193c:	e3e0200b 	mvn	r2, #11
   21940:	e51b1008 	ldr	r1, [fp, #-8]
   21944:	e24b0004 	sub	r0, fp, #4
   21948:	e0801001 	add	r1, r0, r1
   2194c:	e0812002 	add	r2, r1, r2
   21950:	e5d22000 	ldrb	r2, [r2]
   21954:	e5c32000 	strb	r2, [r3]
   21958:	e51b3020 	ldr	r3, [fp, #-32]
   2195c:	e5933000 	ldr	r3, [r3]
   21960:	e2831001 	add	r1, r3, #1
   21964:	e51b2020 	ldr	r2, [fp, #-32]
   21968:	e5821000 	str	r1, [r2]
   2196c:	e5d33000 	ldrb	r3, [r3]
   21970:	e3730001 	cmn	r3, #1
   21974:	03a03001 	moveq	r3, #1
   21978:	13a03000 	movne	r3, #0
   2197c:	e20330ff 	and	r3, r3, #255	; 0xff
   21980:	e3530000 	cmp	r3, #0
   21984:	0a000001 	beq	21990 <__fputwc+0x218>
      return WEOF;
   21988:	e3e03000 	mvn	r3, #0
   2198c:	ea000007 	b	219b0 <__fputwc+0x238>
	  fp->_flags |= __SERR;
	  return WEOF;
	}
    }

  for (i = 0; i < len; i++)
   21990:	e51b3008 	ldr	r3, [fp, #-8]
   21994:	e2833001 	add	r3, r3, #1
   21998:	e50b3008 	str	r3, [fp, #-8]
   2199c:	e51b2008 	ldr	r2, [fp, #-8]
   219a0:	e51b300c 	ldr	r3, [fp, #-12]
   219a4:	e1520003 	cmp	r2, r3
   219a8:	3affff9f 	bcc	2182c <__fputwc+0xb4>
    if (__sputc_r (ptr, (unsigned char) buf[i], fp) == EOF)
      return WEOF;

  return (wint_t) wc;
   219ac:	e51b301c 	ldr	r3, [fp, #-28]
}
   219b0:	e1a00003 	mov	r0, r3
   219b4:	e24bd004 	sub	sp, fp, #4
   219b8:	e8bd4800 	pop	{fp, lr}
   219bc:	e12fff1e 	bx	lr

000219c0 <_fputwc_r>:
wint_t
_DEFUN(_fputwc_r, (ptr, wc, fp),
	struct _reent *ptr _AND
	wchar_t wc _AND
	FILE *fp)
{
   219c0:	e92d4800 	push	{fp, lr}
   219c4:	e28db004 	add	fp, sp, #4
   219c8:	e24dd018 	sub	sp, sp, #24
   219cc:	e50b0010 	str	r0, [fp, #-16]
   219d0:	e50b1014 	str	r1, [fp, #-20]
   219d4:	e50b2018 	str	r2, [fp, #-24]
  wint_t r;

  _newlib_flockfile_start (fp);
   219d8:	e51b3018 	ldr	r3, [fp, #-24]
   219dc:	e1d330bc 	ldrh	r3, [r3, #12]
   219e0:	e1a03803 	lsl	r3, r3, #16
   219e4:	e1a03823 	lsr	r3, r3, #16
   219e8:	e2033c02 	and	r3, r3, #512	; 0x200
   219ec:	e3530000 	cmp	r3, #0
   219f0:	1a000003 	bne	21a04 <_fputwc_r+0x44>
   219f4:	e51b3018 	ldr	r3, [fp, #-24]
   219f8:	e283305c 	add	r3, r3, #92	; 0x5c
   219fc:	e1a00003 	mov	r0, r3
   21a00:	ebffb3fe 	bl	ea00 <_dna_lock_acquire>
  ORIENT(fp, 1);
   21a04:	e51b3018 	ldr	r3, [fp, #-24]
   21a08:	e1d330bc 	ldrh	r3, [r3, #12]
   21a0c:	e1a03803 	lsl	r3, r3, #16
   21a10:	e1a03823 	lsr	r3, r3, #16
   21a14:	e2033a02 	and	r3, r3, #8192	; 0x2000
   21a18:	e3530000 	cmp	r3, #0
   21a1c:	1a00000b 	bne	21a50 <_fputwc_r+0x90>
   21a20:	e51b3018 	ldr	r3, [fp, #-24]
   21a24:	e1d330bc 	ldrh	r3, [r3, #12]
   21a28:	e3833a02 	orr	r3, r3, #8192	; 0x2000
   21a2c:	e1a03803 	lsl	r3, r3, #16
   21a30:	e1a02823 	lsr	r2, r3, #16
   21a34:	e51b3018 	ldr	r3, [fp, #-24]
   21a38:	e1c320bc 	strh	r2, [r3, #12]
   21a3c:	e51b3018 	ldr	r3, [fp, #-24]
   21a40:	e593306c 	ldr	r3, [r3, #108]	; 0x6c
   21a44:	e3832a02 	orr	r2, r3, #8192	; 0x2000
   21a48:	e51b3018 	ldr	r3, [fp, #-24]
   21a4c:	e583206c 	str	r2, [r3, #108]	; 0x6c
  r = __fputwc(ptr, wc, fp);
   21a50:	e51b0010 	ldr	r0, [fp, #-16]
   21a54:	e51b1014 	ldr	r1, [fp, #-20]
   21a58:	e51b2018 	ldr	r2, [fp, #-24]
   21a5c:	ebffff45 	bl	21778 <__fputwc>
   21a60:	e50b0008 	str	r0, [fp, #-8]
  _newlib_flockfile_end (fp);
   21a64:	e51b3018 	ldr	r3, [fp, #-24]
   21a68:	e1d330bc 	ldrh	r3, [r3, #12]
   21a6c:	e1a03803 	lsl	r3, r3, #16
   21a70:	e1a03823 	lsr	r3, r3, #16
   21a74:	e2033c02 	and	r3, r3, #512	; 0x200
   21a78:	e3530000 	cmp	r3, #0
   21a7c:	1a000003 	bne	21a90 <_fputwc_r+0xd0>
   21a80:	e51b3018 	ldr	r3, [fp, #-24]
   21a84:	e283305c 	add	r3, r3, #92	; 0x5c
   21a88:	e1a00003 	mov	r0, r3
   21a8c:	ebffb442 	bl	eb9c <_dna_lock_release>
  return r;
   21a90:	e51b3008 	ldr	r3, [fp, #-8]
}
   21a94:	e1a00003 	mov	r0, r3
   21a98:	e24bd004 	sub	sp, fp, #4
   21a9c:	e8bd4800 	pop	{fp, lr}
   21aa0:	e12fff1e 	bx	lr

00021aa4 <fputwc>:

wint_t
_DEFUN(fputwc, (wc, fp),
	wchar_t wc _AND
	FILE *fp)
{
   21aa4:	e92d4800 	push	{fp, lr}
   21aa8:	e28db004 	add	fp, sp, #4
   21aac:	e24dd010 	sub	sp, sp, #16
   21ab0:	e50b0010 	str	r0, [fp, #-16]
   21ab4:	e50b1014 	str	r1, [fp, #-20]
  struct _reent *reent = _REENT;
   21ab8:	e59f3054 	ldr	r3, [pc, #84]	; 21b14 <fputwc+0x70>
   21abc:	e5933000 	ldr	r3, [r3]
   21ac0:	e50b3008 	str	r3, [fp, #-8]

  CHECK_INIT(reent, fp);
   21ac4:	e51b3008 	ldr	r3, [fp, #-8]
   21ac8:	e50b300c 	str	r3, [fp, #-12]
   21acc:	e51b300c 	ldr	r3, [fp, #-12]
   21ad0:	e3530000 	cmp	r3, #0
   21ad4:	0a000005 	beq	21af0 <fputwc+0x4c>
   21ad8:	e51b300c 	ldr	r3, [fp, #-12]
   21adc:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   21ae0:	e3530000 	cmp	r3, #0
   21ae4:	1a000001 	bne	21af0 <fputwc+0x4c>
   21ae8:	e51b000c 	ldr	r0, [fp, #-12]
   21aec:	ebffded3 	bl	19640 <__sinit>
  return _fputwc_r (reent, wc, fp);
   21af0:	e51b0008 	ldr	r0, [fp, #-8]
   21af4:	e51b1010 	ldr	r1, [fp, #-16]
   21af8:	e51b2014 	ldr	r2, [fp, #-20]
   21afc:	ebffffaf 	bl	219c0 <_fputwc_r>
   21b00:	e1a03000 	mov	r3, r0
}
   21b04:	e1a00003 	mov	r0, r3
   21b08:	e24bd004 	sub	sp, fp, #4
   21b0c:	e8bd4800 	pop	{fp, lr}
   21b10:	e12fff1e 	bx	lr
   21b14:	00025440 	.word	0x00025440

00021b18 <_fstat_r>:
int
_fstat_r (ptr, fd, pstat)
     struct _reent *ptr;
     int fd;
     struct stat *pstat;
{
   21b18:	e92d4800 	push	{fp, lr}
   21b1c:	e28db004 	add	fp, sp, #4
   21b20:	e24dd018 	sub	sp, sp, #24
   21b24:	e50b0010 	str	r0, [fp, #-16]
   21b28:	e50b1014 	str	r1, [fp, #-20]
   21b2c:	e50b2018 	str	r2, [fp, #-24]
  int ret;

  errno = 0;
   21b30:	e59f3054 	ldr	r3, [pc, #84]	; 21b8c <_fstat_r+0x74>
   21b34:	e3a02000 	mov	r2, #0
   21b38:	e5832000 	str	r2, [r3]
  if ((ret = _fstat (fd, pstat)) == -1 && errno != 0)
   21b3c:	e51b0014 	ldr	r0, [fp, #-20]
   21b40:	e51b1018 	ldr	r1, [fp, #-24]
   21b44:	eb000193 	bl	22198 <fstat>
   21b48:	e50b0008 	str	r0, [fp, #-8]
   21b4c:	e51b3008 	ldr	r3, [fp, #-8]
   21b50:	e3730001 	cmn	r3, #1
   21b54:	1a000007 	bne	21b78 <_fstat_r+0x60>
   21b58:	e59f302c 	ldr	r3, [pc, #44]	; 21b8c <_fstat_r+0x74>
   21b5c:	e5933000 	ldr	r3, [r3]
   21b60:	e3530000 	cmp	r3, #0
   21b64:	0a000003 	beq	21b78 <_fstat_r+0x60>
    ptr->_errno = errno;
   21b68:	e59f301c 	ldr	r3, [pc, #28]	; 21b8c <_fstat_r+0x74>
   21b6c:	e5932000 	ldr	r2, [r3]
   21b70:	e51b3010 	ldr	r3, [fp, #-16]
   21b74:	e5832000 	str	r2, [r3]
  return ret;
   21b78:	e51b3008 	ldr	r3, [fp, #-8]
}
   21b7c:	e1a00003 	mov	r0, r3
   21b80:	e24bd004 	sub	sp, fp, #4
   21b84:	e8bd4800 	pop	{fp, lr}
   21b88:	e12fff1e 	bx	lr
   21b8c:	000819b0 	.word	0x000819b0

00021b90 <_isatty_r>:

int
_isatty_r (ptr, fd)
     struct _reent *ptr;
     int fd;
{
   21b90:	e92d4800 	push	{fp, lr}
   21b94:	e28db004 	add	fp, sp, #4
   21b98:	e24dd010 	sub	sp, sp, #16
   21b9c:	e50b0010 	str	r0, [fp, #-16]
   21ba0:	e50b1014 	str	r1, [fp, #-20]
  int ret;

  errno = 0;
   21ba4:	e59f3050 	ldr	r3, [pc, #80]	; 21bfc <_isatty_r+0x6c>
   21ba8:	e3a02000 	mov	r2, #0
   21bac:	e5832000 	str	r2, [r3]
  if ((ret = _isatty (fd)) == -1 && errno != 0)
   21bb0:	e51b0014 	ldr	r0, [fp, #-20]
   21bb4:	eb000181 	bl	221c0 <isatty>
   21bb8:	e50b0008 	str	r0, [fp, #-8]
   21bbc:	e51b3008 	ldr	r3, [fp, #-8]
   21bc0:	e3730001 	cmn	r3, #1
   21bc4:	1a000007 	bne	21be8 <_isatty_r+0x58>
   21bc8:	e59f302c 	ldr	r3, [pc, #44]	; 21bfc <_isatty_r+0x6c>
   21bcc:	e5933000 	ldr	r3, [r3]
   21bd0:	e3530000 	cmp	r3, #0
   21bd4:	0a000003 	beq	21be8 <_isatty_r+0x58>
    ptr->_errno = errno;
   21bd8:	e59f301c 	ldr	r3, [pc, #28]	; 21bfc <_isatty_r+0x6c>
   21bdc:	e5932000 	ldr	r2, [r3]
   21be0:	e51b3010 	ldr	r3, [fp, #-16]
   21be4:	e5832000 	str	r2, [r3]
  return ret;
   21be8:	e51b3008 	ldr	r3, [fp, #-8]
}
   21bec:	e1a00003 	mov	r0, r3
   21bf0:	e24bd004 	sub	sp, fp, #4
   21bf4:	e8bd4800 	pop	{fp, lr}
   21bf8:	e12fff1e 	bx	lr
   21bfc:	000819b0 	.word	0x000819b0

00021c00 <_lseek_r>:
_DEFUN (_lseek_r, (ptr, fd, pos, whence),
     struct _reent *ptr _AND
     int fd _AND
     _off_t pos _AND
     int whence)
{
   21c00:	e92d4810 	push	{r4, fp, lr}
   21c04:	e28db008 	add	fp, sp, #8
   21c08:	e24dd024 	sub	sp, sp, #36	; 0x24
   21c0c:	e50b0018 	str	r0, [fp, #-24]
   21c10:	e50b101c 	str	r1, [fp, #-28]
   21c14:	e50b2024 	str	r2, [fp, #-36]	; 0x24
   21c18:	e50b3020 	str	r3, [fp, #-32]
  _off_t ret;

  errno = 0;
   21c1c:	e59f307c 	ldr	r3, [pc, #124]	; 21ca0 <_lseek_r+0xa0>
   21c20:	e3a02000 	mov	r2, #0
   21c24:	e5832000 	str	r2, [r3]
  if ((ret = _lseek (fd, pos, whence)) == (_off_t) -1 && errno != 0)
   21c28:	e59b3004 	ldr	r3, [fp, #4]
   21c2c:	e58d3000 	str	r3, [sp]
   21c30:	e51b001c 	ldr	r0, [fp, #-28]
   21c34:	e24b3024 	sub	r3, fp, #36	; 0x24
   21c38:	e893000c 	ldm	r3, {r2, r3}
   21c3c:	eb000168 	bl	221e4 <lseek>
   21c40:	e50b0014 	str	r0, [fp, #-20]
   21c44:	e50b1010 	str	r1, [fp, #-16]
   21c48:	e24b2014 	sub	r2, fp, #20
   21c4c:	e8920006 	ldm	r2, {r1, r2}
   21c50:	e3e03000 	mvn	r3, #0
   21c54:	e3e04000 	mvn	r4, #0
   21c58:	e1520004 	cmp	r2, r4
   21c5c:	01510003 	cmpeq	r1, r3
   21c60:	1a000007 	bne	21c84 <_lseek_r+0x84>
   21c64:	e59f3034 	ldr	r3, [pc, #52]	; 21ca0 <_lseek_r+0xa0>
   21c68:	e5933000 	ldr	r3, [r3]
   21c6c:	e3530000 	cmp	r3, #0
   21c70:	0a000003 	beq	21c84 <_lseek_r+0x84>
    ptr->_errno = errno;
   21c74:	e59f3024 	ldr	r3, [pc, #36]	; 21ca0 <_lseek_r+0xa0>
   21c78:	e5932000 	ldr	r2, [r3]
   21c7c:	e51b3018 	ldr	r3, [fp, #-24]
   21c80:	e5832000 	str	r2, [r3]
  return ret;
   21c84:	e24b4014 	sub	r4, fp, #20
   21c88:	e8940018 	ldm	r4, {r3, r4}
}
   21c8c:	e1a00003 	mov	r0, r3
   21c90:	e1a01004 	mov	r1, r4
   21c94:	e24bd008 	sub	sp, fp, #8
   21c98:	e8bd4810 	pop	{r4, fp, lr}
   21c9c:	e12fff1e 	bx	lr
   21ca0:	000819b0 	.word	0x000819b0

00021ca4 <_read_r>:
_DEFUN (_read_r, (ptr, fd, buf, cnt),
     struct _reent *ptr _AND
     int fd _AND
     _PTR buf _AND
     size_t cnt)
{
   21ca4:	e92d4800 	push	{fp, lr}
   21ca8:	e28db004 	add	fp, sp, #4
   21cac:	e24dd018 	sub	sp, sp, #24
   21cb0:	e50b0010 	str	r0, [fp, #-16]
   21cb4:	e50b1014 	str	r1, [fp, #-20]
   21cb8:	e50b2018 	str	r2, [fp, #-24]
   21cbc:	e50b301c 	str	r3, [fp, #-28]
  _ssize_t ret;

  errno = 0;
   21cc0:	e59f3058 	ldr	r3, [pc, #88]	; 21d20 <_read_r+0x7c>
   21cc4:	e3a02000 	mov	r2, #0
   21cc8:	e5832000 	str	r2, [r3]
  if ((ret = (_ssize_t)_read (fd, buf, cnt)) == -1 && errno != 0)
   21ccc:	e51b0014 	ldr	r0, [fp, #-20]
   21cd0:	e51b1018 	ldr	r1, [fp, #-24]
   21cd4:	e51b201c 	ldr	r2, [fp, #-28]
   21cd8:	ebffb944 	bl	101f0 <read>
   21cdc:	e50b0008 	str	r0, [fp, #-8]
   21ce0:	e51b3008 	ldr	r3, [fp, #-8]
   21ce4:	e3730001 	cmn	r3, #1
   21ce8:	1a000007 	bne	21d0c <_read_r+0x68>
   21cec:	e59f302c 	ldr	r3, [pc, #44]	; 21d20 <_read_r+0x7c>
   21cf0:	e5933000 	ldr	r3, [r3]
   21cf4:	e3530000 	cmp	r3, #0
   21cf8:	0a000003 	beq	21d0c <_read_r+0x68>
    ptr->_errno = errno;
   21cfc:	e59f301c 	ldr	r3, [pc, #28]	; 21d20 <_read_r+0x7c>
   21d00:	e5932000 	ldr	r2, [r3]
   21d04:	e51b3010 	ldr	r3, [fp, #-16]
   21d08:	e5832000 	str	r2, [r3]
  return ret;
   21d0c:	e51b3008 	ldr	r3, [fp, #-8]
}
   21d10:	e1a00003 	mov	r0, r3
   21d14:	e24bd004 	sub	sp, fp, #4
   21d18:	e8bd4800 	pop	{fp, lr}
   21d1c:	e12fff1e 	bx	lr
   21d20:	000819b0 	.word	0x000819b0

00021d24 <__swbuf_r>:
int
_DEFUN(__swbuf_r, (ptr, c, fp),
       struct _reent *ptr _AND
       register int c _AND
       register FILE *fp)
{
   21d24:	e92d4870 	push	{r4, r5, r6, fp, lr}
   21d28:	e28db010 	add	fp, sp, #16
   21d2c:	e24dd014 	sub	sp, sp, #20
   21d30:	e50b0020 	str	r0, [fp, #-32]
   21d34:	e1a05001 	mov	r5, r1
   21d38:	e1a04002 	mov	r4, r2
  register int n;

  /* Ensure stdio has been initialized.  */

  CHECK_INIT (ptr, fp);
   21d3c:	e51b3020 	ldr	r3, [fp, #-32]
   21d40:	e50b3018 	str	r3, [fp, #-24]
   21d44:	e51b3018 	ldr	r3, [fp, #-24]
   21d48:	e3530000 	cmp	r3, #0
   21d4c:	0a000005 	beq	21d68 <__swbuf_r+0x44>
   21d50:	e51b3018 	ldr	r3, [fp, #-24]
   21d54:	e5933038 	ldr	r3, [r3, #56]	; 0x38
   21d58:	e3530000 	cmp	r3, #0
   21d5c:	1a000001 	bne	21d68 <__swbuf_r+0x44>
   21d60:	e51b0018 	ldr	r0, [fp, #-24]
   21d64:	ebffde35 	bl	19640 <__sinit>
   * (if line buffered) so that we will get called again.
   * If we did not do this, a sufficient number of putc()
   * calls might wrap _w from negative to positive.
   */

  fp->_w = fp->_lbfsize;
   21d68:	e5943018 	ldr	r3, [r4, #24]
   21d6c:	e5843008 	str	r3, [r4, #8]
  if (cantwrite (ptr, fp))
   21d70:	e1d430bc 	ldrh	r3, [r4, #12]
   21d74:	e1a03803 	lsl	r3, r3, #16
   21d78:	e1a03823 	lsr	r3, r3, #16
   21d7c:	e2033008 	and	r3, r3, #8
   21d80:	e3530000 	cmp	r3, #0
   21d84:	0a000002 	beq	21d94 <__swbuf_r+0x70>
   21d88:	e5943010 	ldr	r3, [r4, #16]
   21d8c:	e3530000 	cmp	r3, #0
   21d90:	1a000007 	bne	21db4 <__swbuf_r+0x90>
   21d94:	e51b0020 	ldr	r0, [fp, #-32]
   21d98:	e1a01004 	mov	r1, r4
   21d9c:	ebffd35d 	bl	16b18 <__swsetup_r>
   21da0:	e1a03000 	mov	r3, r0
   21da4:	e3530000 	cmp	r3, #0
   21da8:	0a000001 	beq	21db4 <__swbuf_r+0x90>
    return EOF;
   21dac:	e3e03000 	mvn	r3, #0
   21db0:	ea00003c 	b	21ea8 <__swbuf_r+0x184>
  c = (unsigned char) c;
   21db4:	e20530ff 	and	r3, r5, #255	; 0xff
   21db8:	e1a05003 	mov	r5, r3

  ORIENT (fp, -1);
   21dbc:	e1d430bc 	ldrh	r3, [r4, #12]
   21dc0:	e1a03803 	lsl	r3, r3, #16
   21dc4:	e1a03823 	lsr	r3, r3, #16
   21dc8:	e2033a02 	and	r3, r3, #8192	; 0x2000
   21dcc:	e3530000 	cmp	r3, #0
   21dd0:	1a000007 	bne	21df4 <__swbuf_r+0xd0>
   21dd4:	e1d430bc 	ldrh	r3, [r4, #12]
   21dd8:	e3833a02 	orr	r3, r3, #8192	; 0x2000
   21ddc:	e1a03803 	lsl	r3, r3, #16
   21de0:	e1a03823 	lsr	r3, r3, #16
   21de4:	e1c430bc 	strh	r3, [r4, #12]
   21de8:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
   21dec:	e3c33a02 	bic	r3, r3, #8192	; 0x2000
   21df0:	e584306c 	str	r3, [r4, #108]	; 0x6c
   * happen on unbuffered streams, where _bf._size==1; fflush()
   * guarantees that putc() will always call wbuf() by setting _w
   * to 0, so we need not do anything else.
   */

  n = fp->_p - fp->_bf._base;
   21df4:	e5943000 	ldr	r3, [r4]
   21df8:	e1a02003 	mov	r2, r3
   21dfc:	e5943010 	ldr	r3, [r4, #16]
   21e00:	e0636002 	rsb	r6, r3, r2
  if (n >= fp->_bf._size)
   21e04:	e5943014 	ldr	r3, [r4, #20]
   21e08:	e1530006 	cmp	r3, r6
   21e0c:	ca000008 	bgt	21e34 <__swbuf_r+0x110>
    {
      if (_fflush_r (ptr, fp))
   21e10:	e51b0020 	ldr	r0, [fp, #-32]
   21e14:	e1a01004 	mov	r1, r4
   21e18:	ebffdcbd 	bl	19114 <_fflush_r>
   21e1c:	e1a03000 	mov	r3, r0
   21e20:	e3530000 	cmp	r3, #0
   21e24:	0a000001 	beq	21e30 <__swbuf_r+0x10c>
	return EOF;
   21e28:	e3e03000 	mvn	r3, #0
   21e2c:	ea00001d 	b	21ea8 <__swbuf_r+0x184>
      n = 0;
   21e30:	e3a06000 	mov	r6, #0
    }
  fp->_w--;
   21e34:	e5943008 	ldr	r3, [r4, #8]
   21e38:	e2433001 	sub	r3, r3, #1
   21e3c:	e5843008 	str	r3, [r4, #8]
  *fp->_p++ = c;
   21e40:	e5943000 	ldr	r3, [r4]
   21e44:	e2832001 	add	r2, r3, #1
   21e48:	e5842000 	str	r2, [r4]
   21e4c:	e20520ff 	and	r2, r5, #255	; 0xff
   21e50:	e5c32000 	strb	r2, [r3]
  if (++n == fp->_bf._size || (fp->_flags & __SLBF && c == '\n'))
   21e54:	e2866001 	add	r6, r6, #1
   21e58:	e5943014 	ldr	r3, [r4, #20]
   21e5c:	e1560003 	cmp	r6, r3
   21e60:	0a000007 	beq	21e84 <__swbuf_r+0x160>
   21e64:	e1d430bc 	ldrh	r3, [r4, #12]
   21e68:	e1a03803 	lsl	r3, r3, #16
   21e6c:	e1a03823 	lsr	r3, r3, #16
   21e70:	e2033001 	and	r3, r3, #1
   21e74:	e3530000 	cmp	r3, #0
   21e78:	0a000009 	beq	21ea4 <__swbuf_r+0x180>
   21e7c:	e355000a 	cmp	r5, #10
   21e80:	1a000007 	bne	21ea4 <__swbuf_r+0x180>
    if (_fflush_r (ptr, fp))
   21e84:	e51b0020 	ldr	r0, [fp, #-32]
   21e88:	e1a01004 	mov	r1, r4
   21e8c:	ebffdca0 	bl	19114 <_fflush_r>
   21e90:	e1a03000 	mov	r3, r0
   21e94:	e3530000 	cmp	r3, #0
   21e98:	0a000001 	beq	21ea4 <__swbuf_r+0x180>
      return EOF;
   21e9c:	e3e03000 	mvn	r3, #0
   21ea0:	ea000000 	b	21ea8 <__swbuf_r+0x184>
  return c;
   21ea4:	e1a03005 	mov	r3, r5
}
   21ea8:	e1a00003 	mov	r0, r3
   21eac:	e24bd010 	sub	sp, fp, #16
   21eb0:	e8bd4870 	pop	{r4, r5, r6, fp, lr}
   21eb4:	e12fff1e 	bx	lr

00021eb8 <__swbuf>:
   earlier dynamically built newlib libraries. */
int
_DEFUN(__swbuf, (c, fp),
       register int c _AND
       register FILE *fp)
{
   21eb8:	e92d4800 	push	{fp, lr}
   21ebc:	e28db004 	add	fp, sp, #4
   21ec0:	e1a02000 	mov	r2, r0
   21ec4:	e1a03001 	mov	r3, r1
  return __swbuf_r (_REENT, c, fp);
   21ec8:	e59f1024 	ldr	r1, [pc, #36]	; 21ef4 <__swbuf+0x3c>
   21ecc:	e5911000 	ldr	r1, [r1]
   21ed0:	e1a00001 	mov	r0, r1
   21ed4:	e1a01002 	mov	r1, r2
   21ed8:	e1a02003 	mov	r2, r3
   21edc:	ebffff90 	bl	21d24 <__swbuf_r>
   21ee0:	e1a03000 	mov	r3, r0
}
   21ee4:	e1a00003 	mov	r0, r3
   21ee8:	e24bd004 	sub	sp, fp, #4
   21eec:	e8bd4800 	pop	{fp, lr}
   21ef0:	e12fff1e 	bx	lr
   21ef4:	00025440 	.word	0x00025440

00021ef8 <_wcrtomb_r>:
_DEFUN (_wcrtomb_r, (ptr, s, wc, ps),
	struct _reent *ptr _AND
	char *s _AND
	wchar_t wc _AND
	mbstate_t *ps)
{
   21ef8:	e92d4810 	push	{r4, fp, lr}
   21efc:	e28db008 	add	fp, sp, #8
   21f00:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   21f04:	e50b0020 	str	r0, [fp, #-32]
   21f08:	e50b1024 	str	r1, [fp, #-36]	; 0x24
   21f0c:	e50b2028 	str	r2, [fp, #-40]	; 0x28
   21f10:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
  int retval = 0;
   21f14:	e3a03000 	mov	r3, #0
   21f18:	e50b3010 	str	r3, [fp, #-16]
      _REENT_CHECK_MISC(ptr);
      ps = &(_REENT_WCRTOMB_STATE(ptr));
    }
#endif

  if (s == NULL)
   21f1c:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
   21f20:	e3530000 	cmp	r3, #0
   21f24:	1a00000d 	bne	21f60 <_wcrtomb_r+0x68>
    retval = __wctomb (ptr, buf, L'\0', __locale_charset (), ps);
   21f28:	e59f30a0 	ldr	r3, [pc, #160]	; 21fd0 <_wcrtomb_r+0xd8>
   21f2c:	e5934000 	ldr	r4, [r3]
   21f30:	ebffe255 	bl	1a88c <__locale_charset>
   21f34:	e1a03000 	mov	r3, r0
   21f38:	e24b201c 	sub	r2, fp, #28
   21f3c:	e51b102c 	ldr	r1, [fp, #-44]	; 0x2c
   21f40:	e58d1000 	str	r1, [sp]
   21f44:	e51b0020 	ldr	r0, [fp, #-32]
   21f48:	e1a01002 	mov	r1, r2
   21f4c:	e3a02000 	mov	r2, #0
   21f50:	e1a0e00f 	mov	lr, pc
   21f54:	e12fff14 	bx	r4
   21f58:	e50b0010 	str	r0, [fp, #-16]
   21f5c:	ea00000b 	b	21f90 <_wcrtomb_r+0x98>
  else
    retval = __wctomb (ptr, s, wc, __locale_charset (), ps);
   21f60:	e59f3068 	ldr	r3, [pc, #104]	; 21fd0 <_wcrtomb_r+0xd8>
   21f64:	e5934000 	ldr	r4, [r3]
   21f68:	ebffe247 	bl	1a88c <__locale_charset>
   21f6c:	e1a03000 	mov	r3, r0
   21f70:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
   21f74:	e58d2000 	str	r2, [sp]
   21f78:	e51b0020 	ldr	r0, [fp, #-32]
   21f7c:	e51b1024 	ldr	r1, [fp, #-36]	; 0x24
   21f80:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
   21f84:	e1a0e00f 	mov	lr, pc
   21f88:	e12fff14 	bx	r4
   21f8c:	e50b0010 	str	r0, [fp, #-16]

  if (retval == -1)
   21f90:	e51b3010 	ldr	r3, [fp, #-16]
   21f94:	e3730001 	cmn	r3, #1
   21f98:	1a000007 	bne	21fbc <_wcrtomb_r+0xc4>
    {
      ps->__count = 0;
   21f9c:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
   21fa0:	e3a02000 	mov	r2, #0
   21fa4:	e5832000 	str	r2, [r3]
      ptr->_errno = EILSEQ;
   21fa8:	e51b3020 	ldr	r3, [fp, #-32]
   21fac:	e3a0208a 	mov	r2, #138	; 0x8a
   21fb0:	e5832000 	str	r2, [r3]
      return (size_t)(-1);
   21fb4:	e3e03000 	mvn	r3, #0
   21fb8:	ea000000 	b	21fc0 <_wcrtomb_r+0xc8>
    }
  else
    return (size_t)retval;
   21fbc:	e51b3010 	ldr	r3, [fp, #-16]
}
   21fc0:	e1a00003 	mov	r0, r3
   21fc4:	e24bd008 	sub	sp, fp, #8
   21fc8:	e8bd4810 	pop	{r4, fp, lr}
   21fcc:	e12fff1e 	bx	lr
   21fd0:	000254c0 	.word	0x000254c0

00021fd4 <wcrtomb>:
size_t
_DEFUN (wcrtomb, (s, wc, ps),
	char *s _AND
	wchar_t wc _AND
	mbstate_t *ps)
{
   21fd4:	e92d4810 	push	{r4, fp, lr}
   21fd8:	e28db008 	add	fp, sp, #8
   21fdc:	e24dd034 	sub	sp, sp, #52	; 0x34
   21fe0:	e50b0028 	str	r0, [fp, #-40]	; 0x28
   21fe4:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
   21fe8:	e50b2030 	str	r2, [fp, #-48]	; 0x30
#if defined(PREFER_SIZE_OVER_SPEED) || defined(__OPTIMIZE_SIZE__)
  return _wcrtomb_r (_REENT, s, wc, ps);
#else
  int retval = 0;
   21fec:	e3a03000 	mov	r3, #0
   21ff0:	e50b3010 	str	r3, [fp, #-16]
  struct _reent *reent = _REENT;
   21ff4:	e59f30b8 	ldr	r3, [pc, #184]	; 220b4 <wcrtomb+0xe0>
   21ff8:	e5933000 	ldr	r3, [r3]
   21ffc:	e50b3014 	str	r3, [fp, #-20]
      _REENT_CHECK_MISC(reent);
      ps = &(_REENT_WCRTOMB_STATE(reent));
    }
#endif

  if (s == NULL)
   22000:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
   22004:	e3530000 	cmp	r3, #0
   22008:	1a00000d 	bne	22044 <wcrtomb+0x70>
    retval = __wctomb (reent, buf, L'\0', __locale_charset (), ps);
   2200c:	e59f30a4 	ldr	r3, [pc, #164]	; 220b8 <wcrtomb+0xe4>
   22010:	e5934000 	ldr	r4, [r3]
   22014:	ebffe21c 	bl	1a88c <__locale_charset>
   22018:	e1a03000 	mov	r3, r0
   2201c:	e24b2020 	sub	r2, fp, #32
   22020:	e51b1030 	ldr	r1, [fp, #-48]	; 0x30
   22024:	e58d1000 	str	r1, [sp]
   22028:	e51b0014 	ldr	r0, [fp, #-20]
   2202c:	e1a01002 	mov	r1, r2
   22030:	e3a02000 	mov	r2, #0
   22034:	e1a0e00f 	mov	lr, pc
   22038:	e12fff14 	bx	r4
   2203c:	e50b0010 	str	r0, [fp, #-16]
   22040:	ea00000b 	b	22074 <wcrtomb+0xa0>
  else
    retval = __wctomb (reent, s, wc, __locale_charset (), ps);
   22044:	e59f306c 	ldr	r3, [pc, #108]	; 220b8 <wcrtomb+0xe4>
   22048:	e5934000 	ldr	r4, [r3]
   2204c:	ebffe20e 	bl	1a88c <__locale_charset>
   22050:	e1a03000 	mov	r3, r0
   22054:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
   22058:	e58d2000 	str	r2, [sp]
   2205c:	e51b0014 	ldr	r0, [fp, #-20]
   22060:	e51b1028 	ldr	r1, [fp, #-40]	; 0x28
   22064:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
   22068:	e1a0e00f 	mov	lr, pc
   2206c:	e12fff14 	bx	r4
   22070:	e50b0010 	str	r0, [fp, #-16]

  if (retval == -1)
   22074:	e51b3010 	ldr	r3, [fp, #-16]
   22078:	e3730001 	cmn	r3, #1
   2207c:	1a000007 	bne	220a0 <wcrtomb+0xcc>
    {
      ps->__count = 0;
   22080:	e51b3030 	ldr	r3, [fp, #-48]	; 0x30
   22084:	e3a02000 	mov	r2, #0
   22088:	e5832000 	str	r2, [r3]
      reent->_errno = EILSEQ;
   2208c:	e51b3014 	ldr	r3, [fp, #-20]
   22090:	e3a0208a 	mov	r2, #138	; 0x8a
   22094:	e5832000 	str	r2, [r3]
      return (size_t)(-1);
   22098:	e3e03000 	mvn	r3, #0
   2209c:	ea000000 	b	220a4 <wcrtomb+0xd0>
    }
  else
    return (size_t)retval;
   220a0:	e51b3010 	ldr	r3, [fp, #-16]
#endif /* not PREFER_SIZE_OVER_SPEED */
}
   220a4:	e1a00003 	mov	r0, r3
   220a8:	e24bd008 	sub	sp, fp, #8
   220ac:	e8bd4810 	pop	{r4, fp, lr}
   220b0:	e12fff1e 	bx	lr
   220b4:	00025440 	.word	0x00025440
   220b8:	000254c0 	.word	0x000254c0

000220bc <_wctomb_r>:
_DEFUN (_wctomb_r, (r, s, wchar, state),
        struct _reent *r     _AND 
        char          *s     _AND
        wchar_t        _wchar _AND
        mbstate_t     *state)
{
   220bc:	e92d4810 	push	{r4, fp, lr}
   220c0:	e28db008 	add	fp, sp, #8
   220c4:	e24dd01c 	sub	sp, sp, #28
   220c8:	e50b0010 	str	r0, [fp, #-16]
   220cc:	e50b1014 	str	r1, [fp, #-20]
   220d0:	e50b2018 	str	r2, [fp, #-24]
   220d4:	e50b301c 	str	r3, [fp, #-28]
  return __wctomb (r, s, _wchar, __locale_charset (), state);
   220d8:	e59f3038 	ldr	r3, [pc, #56]	; 22118 <_wctomb_r+0x5c>
   220dc:	e5934000 	ldr	r4, [r3]
   220e0:	ebffe1e9 	bl	1a88c <__locale_charset>
   220e4:	e1a03000 	mov	r3, r0
   220e8:	e51b201c 	ldr	r2, [fp, #-28]
   220ec:	e58d2000 	str	r2, [sp]
   220f0:	e51b0010 	ldr	r0, [fp, #-16]
   220f4:	e51b1014 	ldr	r1, [fp, #-20]
   220f8:	e51b2018 	ldr	r2, [fp, #-24]
   220fc:	e1a0e00f 	mov	lr, pc
   22100:	e12fff14 	bx	r4
   22104:	e1a03000 	mov	r3, r0
}
   22108:	e1a00003 	mov	r0, r3
   2210c:	e24bd008 	sub	sp, fp, #8
   22110:	e8bd4810 	pop	{r4, fp, lr}
   22114:	e12fff1e 	bx	lr
   22118:	000254c0 	.word	0x000254c0

0002211c <__ascii_wctomb>:
        struct _reent *r       _AND 
        char          *s       _AND
        wchar_t        _wchar  _AND
	const char    *charset _AND
        mbstate_t     *state)
{
   2211c:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   22120:	e28db000 	add	fp, sp, #0
   22124:	e24dd01c 	sub	sp, sp, #28
   22128:	e50b0010 	str	r0, [fp, #-16]
   2212c:	e50b1014 	str	r1, [fp, #-20]
   22130:	e50b2018 	str	r2, [fp, #-24]
   22134:	e50b301c 	str	r3, [fp, #-28]
  /* Avoids compiler warnings about comparisons that are always false
     due to limited range when sizeof(wchar_t) is 2 but sizeof(wint_t)
     is 4, as is the case on cygwin.  */
  wint_t wchar = _wchar;
   22138:	e51b3018 	ldr	r3, [fp, #-24]
   2213c:	e50b3008 	str	r3, [fp, #-8]

  if (s == NULL)
   22140:	e51b3014 	ldr	r3, [fp, #-20]
   22144:	e3530000 	cmp	r3, #0
   22148:	1a000001 	bne	22154 <__ascii_wctomb+0x38>
    return 0;
   2214c:	e3a03000 	mov	r3, #0
   22150:	ea00000c 	b	22188 <__ascii_wctomb+0x6c>
 
#ifdef __CYGWIN__
  if ((size_t)wchar >= 0x80)
#else
  if ((size_t)wchar >= 0x100)
   22154:	e51b3008 	ldr	r3, [fp, #-8]
   22158:	e35300ff 	cmp	r3, #255	; 0xff
   2215c:	9a000004 	bls	22174 <__ascii_wctomb+0x58>
#endif
    {
      r->_errno = EILSEQ;
   22160:	e51b3010 	ldr	r3, [fp, #-16]
   22164:	e3a0208a 	mov	r2, #138	; 0x8a
   22168:	e5832000 	str	r2, [r3]
      return -1;
   2216c:	e3e03000 	mvn	r3, #0
   22170:	ea000004 	b	22188 <__ascii_wctomb+0x6c>
    }

  *s = (char) wchar;
   22174:	e51b3008 	ldr	r3, [fp, #-8]
   22178:	e20320ff 	and	r2, r3, #255	; 0xff
   2217c:	e51b3014 	ldr	r3, [fp, #-20]
   22180:	e5c32000 	strb	r2, [r3]
  return 1;
   22184:	e3a03001 	mov	r3, #1
}
   22188:	e1a00003 	mov	r0, r3
   2218c:	e24bd000 	sub	sp, fp, #0
   22190:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   22194:	e12fff1e 	bx	lr

00022198 <fstat>:

int
_DEFUN (_fstat, (fildes, st),
        int          fildes _AND
        struct stat *st)
{
   22198:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   2219c:	e28db000 	add	fp, sp, #0
   221a0:	e24dd00c 	sub	sp, sp, #12
   221a4:	e50b0008 	str	r0, [fp, #-8]
   221a8:	e50b100c 	str	r1, [fp, #-12]



	return 0;
   221ac:	e3a03000 	mov	r3, #0
}
   221b0:	e1a00003 	mov	r0, r3
   221b4:	e24bd000 	sub	sp, fp, #0
   221b8:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   221bc:	e12fff1e 	bx	lr

000221c0 <isatty>:
#include <_syslist.h>

int
_DEFUN (_isatty, (file),
        int file)
{
   221c0:	e52db004 	push	{fp}		; (str fp, [sp, #-4]!)
   221c4:	e28db000 	add	fp, sp, #0
   221c8:	e24dd00c 	sub	sp, sp, #12
   221cc:	e50b0008 	str	r0, [fp, #-8]
  return 1;
   221d0:	e3a03001 	mov	r3, #1
}
   221d4:	e1a00003 	mov	r0, r3
   221d8:	e24bd000 	sub	sp, fp, #0
   221dc:	e49db004 	pop	{fp}		; (ldr fp, [sp], #4)
   221e0:	e12fff1e 	bx	lr

000221e4 <lseek>:
off_t
_DEFUN (lseek, (file, off, dir),
        int   file  _AND
        off_t   off   _AND
        int   dir)
{
   221e4:	e92d4810 	push	{r4, fp, lr}
   221e8:	e28db008 	add	fp, sp, #8
   221ec:	e24dd02c 	sub	sp, sp, #44	; 0x2c
   221f0:	e50b0020 	str	r0, [fp, #-32]
   221f4:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
   221f8:	e50b3028 	str	r3, [fp, #-40]	; 0x28
	off_t res = -1;
   221fc:	e3e03000 	mvn	r3, #0
   22200:	e3e04000 	mvn	r4, #0
   22204:	e50b301c 	str	r3, [fp, #-28]
   22208:	e50b4018 	str	r4, [fp, #-24]
	status_t status = DNA_OK;
   2220c:	e3a03000 	mov	r3, #0
   22210:	e14b30be 	strh	r3, [fp, #-14]

	status = vfs_lseek (file, off, dir, & res);
   22214:	e51b3020 	ldr	r3, [fp, #-32]
   22218:	e1a03803 	lsl	r3, r3, #16
   2221c:	e1a03823 	lsr	r3, r3, #16
   22220:	e1a03803 	lsl	r3, r3, #16
   22224:	e1a03843 	asr	r3, r3, #16
   22228:	e59b2004 	ldr	r2, [fp, #4]
   2222c:	e58d2000 	str	r2, [sp]
   22230:	e24b201c 	sub	r2, fp, #28
   22234:	e58d2004 	str	r2, [sp, #4]
   22238:	e1a00003 	mov	r0, r3
   2223c:	e24b302c 	sub	r3, fp, #44	; 0x2c
   22240:	e893000c 	ldm	r3, {r2, r3}
   22244:	ebff9431 	bl	7310 <vfs_lseek>
   22248:	e1a03000 	mov	r3, r0
   2224c:	e14b30be 	strh	r3, [fp, #-14]
  return res;
   22250:	e24b401c 	sub	r4, fp, #28
   22254:	e8940018 	ldm	r4, {r3, r4}
}
   22258:	e1a00003 	mov	r0, r3
   2225c:	e1a01004 	mov	r1, r4
   22260:	e24bd008 	sub	sp, fp, #8
   22264:	e8bd4810 	pop	{r4, fp, lr}
   22268:	e12fff1e 	bx	lr

0002226c <__aeabi_drsub>:

#ifdef L_arm_addsubdf3

ARM_FUNC_START aeabi_drsub

	eor	xh, xh, #0x80000000	@ flip sign bit of first arg
   2226c:	e2211102 	eor	r1, r1, #-2147483648	; 0x80000000
	b	1f	
   22270:	ea000000 	b	22278 <__adddf3>

00022274 <__aeabi_dsub>:

ARM_FUNC_START subdf3
ARM_FUNC_ALIAS aeabi_dsub subdf3

	eor	yh, yh, #0x80000000	@ flip sign bit of second arg
   22274:	e2233102 	eor	r3, r3, #-2147483648	; 0x80000000

00022278 <__adddf3>:
#endif

ARM_FUNC_START adddf3
ARM_FUNC_ALIAS aeabi_dadd adddf3

1:	do_push	{r4, r5, lr}
   22278:	e92d4030 	push	{r4, r5, lr}

	@ Look for zeroes, equal values, INF, or NAN.
	shift1	lsl, r4, xh, #1
   2227c:	e1a04081 	lsl	r4, r1, #1
	shift1	lsl, r5, yh, #1
   22280:	e1a05083 	lsl	r5, r3, #1
	teq	r4, r5
   22284:	e1340005 	teq	r4, r5
	do_it	eq
	teqeq	xl, yl
   22288:	01300002 	teqeq	r0, r2
	do_it	ne, ttt
	COND(orr,s,ne)	ip, r4, xl
   2228c:	1194c000 	orrsne	ip, r4, r0
	COND(orr,s,ne)	ip, r5, yl
   22290:	1195c002 	orrsne	ip, r5, r2
	COND(mvn,s,ne)	ip, r4, asr #21
   22294:	11f0cac4 	mvnsne	ip, r4, asr #21
	COND(mvn,s,ne)	ip, r5, asr #21
   22298:	11f0cac5 	mvnsne	ip, r5, asr #21
	beq	LSYM(Lad_s)
   2229c:	0a00008c 	beq	224d4 <__adddf3+0x25c>

	@ Compute exponent difference.  Make largest exponent in r4,
	@ corresponding arg in xh-xl, and positive exponent difference in r5.
	shift1	lsr, r4, r4, #21
   222a0:	e1a04aa4 	lsr	r4, r4, #21
	rsbs	r5, r4, r5, lsr #21
   222a4:	e0745aa5 	rsbs	r5, r4, r5, lsr #21
	do_it	lt
	rsblt	r5, r5, #0
   222a8:	b2655000 	rsblt	r5, r5, #0
	ble	1f
   222ac:	da000006 	ble	222cc <__adddf3+0x54>
	add	r4, r4, r5
   222b0:	e0844005 	add	r4, r4, r5
	eor	yl, xl, yl
   222b4:	e0202002 	eor	r2, r0, r2
	eor	yh, xh, yh
   222b8:	e0213003 	eor	r3, r1, r3
	eor	xl, yl, xl
   222bc:	e0220000 	eor	r0, r2, r0
	eor	xh, yh, xh
   222c0:	e0231001 	eor	r1, r3, r1
	eor	yl, xl, yl
   222c4:	e0202002 	eor	r2, r0, r2
	eor	yh, xh, yh
   222c8:	e0213003 	eor	r3, r1, r3
1:
	@ If exponent difference is too large, return largest argument
	@ already in xh-xl.  We need up to 54 bit to handle proper rounding
	@ of 0x1p54 - 1.1.
	cmp	r5, #54
   222cc:	e3550036 	cmp	r5, #54	; 0x36
	do_it	hi
	RETLDM	"r4, r5" hi
   222d0:	88bd4030 	pophi	{r4, r5, lr}
   222d4:	812fff1e 	bxhi	lr

	@ Convert mantissa to signed integer.
	tst	xh, #0x80000000
   222d8:	e3110102 	tst	r1, #-2147483648	; 0x80000000
	mov	xh, xh, lsl #12
   222dc:	e1a01601 	lsl	r1, r1, #12
	mov	ip, #0x00100000
   222e0:	e3a0c601 	mov	ip, #1048576	; 0x100000
	orr	xh, ip, xh, lsr #12
   222e4:	e18c1621 	orr	r1, ip, r1, lsr #12
	beq	1f
   222e8:	0a000001 	beq	222f4 <__adddf3+0x7c>
#if defined(__thumb2__)
	negs	xl, xl
	sbc	xh, xh, xh, lsl #1
#else
	rsbs	xl, xl, #0
   222ec:	e2700000 	rsbs	r0, r0, #0
	rsc	xh, xh, #0
   222f0:	e2e11000 	rsc	r1, r1, #0
#endif
1:
	tst	yh, #0x80000000
   222f4:	e3130102 	tst	r3, #-2147483648	; 0x80000000
	mov	yh, yh, lsl #12
   222f8:	e1a03603 	lsl	r3, r3, #12
	orr	yh, ip, yh, lsr #12
   222fc:	e18c3623 	orr	r3, ip, r3, lsr #12
	beq	1f
   22300:	0a000001 	beq	2230c <__adddf3+0x94>
#if defined(__thumb2__)
	negs	yl, yl
	sbc	yh, yh, yh, lsl #1
#else
	rsbs	yl, yl, #0
   22304:	e2722000 	rsbs	r2, r2, #0
	rsc	yh, yh, #0
   22308:	e2e33000 	rsc	r3, r3, #0
#endif
1:
	@ If exponent == difference, one or both args were denormalized.
	@ Since this is not common case, rescale them off line.
	teq	r4, r5
   2230c:	e1340005 	teq	r4, r5
	beq	LSYM(Lad_d)
   22310:	0a000069 	beq	224bc <__adddf3+0x244>
LSYM(Lad_x):

	@ Compensate for the exponent overlapping the mantissa MSB added later
	sub	r4, r4, #1
   22314:	e2444001 	sub	r4, r4, #1

	@ Shift yh-yl right per r5, add to xh-xl, keep leftover bits into ip.
	rsbs	lr, r5, #32
   22318:	e275e020 	rsbs	lr, r5, #32
	blt	1f
   2231c:	ba000005 	blt	22338 <__adddf3+0xc0>
	shift1	lsl, ip, yl, lr
   22320:	e1a0ce12 	lsl	ip, r2, lr
	shiftop adds xl xl yl lsr r5 yl
   22324:	e0900532 	adds	r0, r0, r2, lsr r5
	adc	xh, xh, #0
   22328:	e2a11000 	adc	r1, r1, #0
	shiftop adds xl xl yh lsl lr yl
   2232c:	e0900e13 	adds	r0, r0, r3, lsl lr
	shiftop adcs xh xh yh asr r5 yh
   22330:	e0b11553 	adcs	r1, r1, r3, asr r5
	b	2f
   22334:	ea000006 	b	22354 <__adddf3+0xdc>
1:	sub	r5, r5, #32
   22338:	e2455020 	sub	r5, r5, #32
	add	lr, lr, #32
   2233c:	e28ee020 	add	lr, lr, #32
	cmp	yl, #1
   22340:	e3520001 	cmp	r2, #1
	shift1	lsl,ip, yh, lr
   22344:	e1a0ce13 	lsl	ip, r3, lr
	do_it	cs
	orrcs	ip, ip, #2		@ 2 not 1, to allow lsr #1 later
   22348:	238cc002 	orrcs	ip, ip, #2
	shiftop adds xl xl yh asr r5 yh
   2234c:	e0900553 	adds	r0, r0, r3, asr r5
	adcs	xh, xh, yh, asr #31
   22350:	e0b11fc3 	adcs	r1, r1, r3, asr #31
2:
	@ We now have a result in xh-xl-ip.
	@ Keep absolute value in xh-xl-ip, sign in r5 (the n bit was set above)
	and	r5, xh, #0x80000000
   22354:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
	bpl	LSYM(Lad_p)
   22358:	5a000002 	bpl	22368 <__adddf3+0xf0>
	mov	lr, #0
	negs	ip, ip
	sbcs	xl, lr, xl
	sbc	xh, lr, xh
#else
	rsbs	ip, ip, #0
   2235c:	e27cc000 	rsbs	ip, ip, #0
	rscs	xl, xl, #0
   22360:	e2f00000 	rscs	r0, r0, #0
	rsc	xh, xh, #0
   22364:	e2e11000 	rsc	r1, r1, #0
#endif

	@ Determine how to normalize the result.
LSYM(Lad_p):
	cmp	xh, #0x00100000
   22368:	e3510601 	cmp	r1, #1048576	; 0x100000
	bcc	LSYM(Lad_a)
   2236c:	3a00000f 	bcc	223b0 <__adddf3+0x138>
	cmp	xh, #0x00200000
   22370:	e3510602 	cmp	r1, #2097152	; 0x200000
	bcc	LSYM(Lad_e)
   22374:	3a000006 	bcc	22394 <__adddf3+0x11c>

	@ Result needs to be shifted right.
	movs	xh, xh, lsr #1
   22378:	e1b010a1 	lsrs	r1, r1, #1
	movs	xl, xl, rrx
   2237c:	e1b00060 	rrxs	r0, r0
	mov	ip, ip, rrx
   22380:	e1a0c06c 	rrx	ip, ip
	add	r4, r4, #1
   22384:	e2844001 	add	r4, r4, #1

	@ Make sure we did not bust our exponent.
	mov	r2, r4, lsl #21
   22388:	e1a02a84 	lsl	r2, r4, #21
	cmn	r2, #(2 << 21)
   2238c:	e3720501 	cmn	r2, #4194304	; 0x400000
	bcs	LSYM(Lad_o)
   22390:	2a00006b 	bcs	22544 <__adddf3+0x2cc>
	@ Our result is now properly aligned into xh-xl, remaining bits in ip.
	@ Round with MSB of ip. If halfway between two numbers, round towards
	@ LSB of xl = 0.
	@ Pack final result together.
LSYM(Lad_e):
	cmp	ip, #0x80000000
   22394:	e35c0102 	cmp	ip, #-2147483648	; 0x80000000
	do_it	eq
	COND(mov,s,eq)	ip, xl, lsr #1
   22398:	01b0c0a0 	lsrseq	ip, r0, #1
	adcs	xl, xl, #0
   2239c:	e2b00000 	adcs	r0, r0, #0
	adc	xh, xh, r4, lsl #20
   223a0:	e0a11a04 	adc	r1, r1, r4, lsl #20
	orr	xh, xh, r5
   223a4:	e1811005 	orr	r1, r1, r5
	RETLDM	"r4, r5"
   223a8:	e8bd4030 	pop	{r4, r5, lr}
   223ac:	e12fff1e 	bx	lr

	@ Result must be shifted left and exponent adjusted.
LSYM(Lad_a):
	movs	ip, ip, lsl #1
   223b0:	e1b0c08c 	lsls	ip, ip, #1
	adcs	xl, xl, xl
   223b4:	e0b00000 	adcs	r0, r0, r0
	adc	xh, xh, xh
   223b8:	e0a11001 	adc	r1, r1, r1
	tst	xh, #0x00100000
   223bc:	e3110601 	tst	r1, #1048576	; 0x100000
	sub	r4, r4, #1
   223c0:	e2444001 	sub	r4, r4, #1
	bne	LSYM(Lad_e)
   223c4:	1afffff2 	bne	22394 <__adddf3+0x11c>
	@ No rounding necessary since ip will always be 0 at this point.
LSYM(Lad_l):

#if __ARM_ARCH__ < 5

	teq	xh, #0
   223c8:	e3310000 	teq	r1, #0
	movne	r3, #20
   223cc:	13a03014 	movne	r3, #20
	moveq	r3, #52
   223d0:	03a03034 	moveq	r3, #52	; 0x34
	moveq	xh, xl
   223d4:	01a01000 	moveq	r1, r0
	moveq	xl, #0
   223d8:	03a00000 	moveq	r0, #0
	mov	r2, xh
   223dc:	e1a02001 	mov	r2, r1
	cmp	r2, #(1 << 16)
   223e0:	e3520801 	cmp	r2, #65536	; 0x10000
	movhs	r2, r2, lsr #16
   223e4:	21a02822 	lsrcs	r2, r2, #16
	subhs	r3, r3, #16
   223e8:	22433010 	subcs	r3, r3, #16
	cmp	r2, #(1 << 8)
   223ec:	e3520c01 	cmp	r2, #256	; 0x100
	movhs	r2, r2, lsr #8
   223f0:	21a02422 	lsrcs	r2, r2, #8
	subhs	r3, r3, #8
   223f4:	22433008 	subcs	r3, r3, #8
	cmp	r2, #(1 << 4)
   223f8:	e3520010 	cmp	r2, #16
	movhs	r2, r2, lsr #4
   223fc:	21a02222 	lsrcs	r2, r2, #4
	subhs	r3, r3, #4
   22400:	22433004 	subcs	r3, r3, #4
	cmp	r2, #(1 << 2)
   22404:	e3520004 	cmp	r2, #4
	subhs	r3, r3, #2
   22408:	22433002 	subcs	r3, r3, #2
	sublo	r3, r3, r2, lsr #1
   2240c:	304330a2 	subcc	r3, r3, r2, lsr #1
	sub	r3, r3, r2, lsr #3
   22410:	e04331a2 	sub	r3, r3, r2, lsr #3
	sub	r3, r3, #11

#endif

	@ determine how to shift the value.
	subs	r2, r3, #32
   22414:	e2532020 	subs	r2, r3, #32
	bge	2f
   22418:	aa000007 	bge	2243c <__adddf3+0x1c4>
	adds	r2, r2, #12
   2241c:	e292200c 	adds	r2, r2, #12
	ble	1f
   22420:	da000004 	ble	22438 <__adddf3+0x1c0>

	@ shift value left 21 to 31 bits, or actually right 11 to 1 bits
	@ since a register switch happened above.
	add	ip, r2, #20
   22424:	e282c014 	add	ip, r2, #20
	rsb	r2, r2, #12
   22428:	e262200c 	rsb	r2, r2, #12
	shift1	lsl, xl, xh, ip
   2242c:	e1a00c11 	lsl	r0, r1, ip
	shift1	lsr, xh, xh, r2
   22430:	e1a01231 	lsr	r1, r1, r2
	b	3f
   22434:	ea000004 	b	2244c <__adddf3+0x1d4>

	@ actually shift value left 1 to 20 bits, which might also represent
	@ 32 to 52 bits if counting the register switch that happened earlier.
1:	add	r2, r2, #20
   22438:	e2822014 	add	r2, r2, #20
2:	do_it	le
	rsble	ip, r2, #32
   2243c:	d262c020 	rsble	ip, r2, #32
	shift1	lsl, xh, xh, r2
   22440:	e1a01211 	lsl	r1, r1, r2
	lsr	ip, xl, ip
	itt	le
	orrle	xh, xh, ip
	lslle	xl, xl, r2
#else
	orrle	xh, xh, xl, lsr ip
   22444:	d1811c30 	orrle	r1, r1, r0, lsr ip
	movle	xl, xl, lsl r2
   22448:	d1a00210 	lslle	r0, r0, r2
#endif

	@ adjust exponent accordingly.
3:	subs	r4, r4, r3
   2244c:	e0544003 	subs	r4, r4, r3
	do_it	ge, tt
	addge	xh, xh, r4, lsl #20
   22450:	a0811a04 	addge	r1, r1, r4, lsl #20
	orrge	xh, xh, r5
   22454:	a1811005 	orrge	r1, r1, r5
	RETLDM	"r4, r5" ge
   22458:	a8bd4030 	popge	{r4, r5, lr}
   2245c:	a12fff1e 	bxge	lr

	@ Exponent too small, denormalize result.
	@ Find out proper shift value.
	mvn	r4, r4
   22460:	e1e04004 	mvn	r4, r4
	subs	r4, r4, #31
   22464:	e254401f 	subs	r4, r4, #31
	bge	2f
   22468:	aa00000f 	bge	224ac <__adddf3+0x234>
	adds	r4, r4, #12
   2246c:	e294400c 	adds	r4, r4, #12
	bgt	1f
   22470:	ca000006 	bgt	22490 <__adddf3+0x218>

	@ shift result right of 1 to 20 bits, sign is in r5.
	add	r4, r4, #20
   22474:	e2844014 	add	r4, r4, #20
	rsb	r2, r4, #32
   22478:	e2642020 	rsb	r2, r4, #32
	shift1	lsr, xl, xl, r4
   2247c:	e1a00430 	lsr	r0, r0, r4
	shiftop orr xl xl xh lsl r2 yh
   22480:	e1800211 	orr	r0, r0, r1, lsl r2
	shiftop orr xh r5 xh lsr r4 yh
   22484:	e1851431 	orr	r1, r5, r1, lsr r4
	RETLDM	"r4, r5"
   22488:	e8bd4030 	pop	{r4, r5, lr}
   2248c:	e12fff1e 	bx	lr

	@ shift result right of 21 to 31 bits, or left 11 to 1 bits after
	@ a register switch from xh to xl.
1:	rsb	r4, r4, #12
   22490:	e264400c 	rsb	r4, r4, #12
	rsb	r2, r4, #32
   22494:	e2642020 	rsb	r2, r4, #32
	shift1	lsr, xl, xl, r2
   22498:	e1a00230 	lsr	r0, r0, r2
	shiftop orr xl xl xh lsl r4 yh
   2249c:	e1800411 	orr	r0, r0, r1, lsl r4
	mov	xh, r5
   224a0:	e1a01005 	mov	r1, r5
	RETLDM	"r4, r5"
   224a4:	e8bd4030 	pop	{r4, r5, lr}
   224a8:	e12fff1e 	bx	lr

	@ Shift value right of 32 to 64 bits, or 0 to 32 bits after a switch
	@ from xh to xl.
2:	shift1	lsr, xl, xh, r4
   224ac:	e1a00431 	lsr	r0, r1, r4
	mov	xh, r5
   224b0:	e1a01005 	mov	r1, r5
	RETLDM	"r4, r5"
   224b4:	e8bd4030 	pop	{r4, r5, lr}
   224b8:	e12fff1e 	bx	lr

	@ Adjust exponents for denormalized arguments.
	@ Note that r4 must not remain equal to 0.
LSYM(Lad_d):
	teq	r4, #0
   224bc:	e3340000 	teq	r4, #0
	eor	yh, yh, #0x00100000
   224c0:	e2233601 	eor	r3, r3, #1048576	; 0x100000
	do_it	eq, te
	eoreq	xh, xh, #0x00100000
   224c4:	02211601 	eoreq	r1, r1, #1048576	; 0x100000
	addeq	r4, r4, #1
   224c8:	02844001 	addeq	r4, r4, #1
	subne	r5, r5, #1
   224cc:	12455001 	subne	r5, r5, #1
	b	LSYM(Lad_x)
   224d0:	eaffff8f 	b	22314 <__adddf3+0x9c>


LSYM(Lad_s):
	mvns	ip, r4, asr #21
   224d4:	e1f0cac4 	mvns	ip, r4, asr #21
	do_it	ne
	COND(mvn,s,ne)	ip, r5, asr #21
   224d8:	11f0cac5 	mvnsne	ip, r5, asr #21
	beq	LSYM(Lad_i)
   224dc:	0a00001d 	beq	22558 <__adddf3+0x2e0>

	teq	r4, r5
   224e0:	e1340005 	teq	r4, r5
	do_it	eq
	teqeq	xl, yl
   224e4:	01300002 	teqeq	r0, r2
	beq	1f
   224e8:	0a000004 	beq	22500 <__adddf3+0x288>

	@ Result is x + 0.0 = x or 0.0 + y = y.
	orrs	ip, r4, xl
   224ec:	e194c000 	orrs	ip, r4, r0
	do_it	eq, t
	moveq	xh, yh
   224f0:	01a01003 	moveq	r1, r3
	moveq	xl, yl
   224f4:	01a00002 	moveq	r0, r2
	RETLDM	"r4, r5"
   224f8:	e8bd4030 	pop	{r4, r5, lr}
   224fc:	e12fff1e 	bx	lr

1:	teq	xh, yh
   22500:	e1310003 	teq	r1, r3

	@ Result is x - x = 0.
	do_it	ne, tt
	movne	xh, #0
   22504:	13a01000 	movne	r1, #0
	movne	xl, #0
   22508:	13a00000 	movne	r0, #0
	RETLDM	"r4, r5" ne
   2250c:	18bd4030 	popne	{r4, r5, lr}
   22510:	112fff1e 	bxne	lr

	@ Result is x + x = 2x.
	movs	ip, r4, lsr #21
   22514:	e1b0caa4 	lsrs	ip, r4, #21
	bne	2f
   22518:	1a000004 	bne	22530 <__adddf3+0x2b8>
	movs	xl, xl, lsl #1
   2251c:	e1b00080 	lsls	r0, r0, #1
	adcs	xh, xh, xh
   22520:	e0b11001 	adcs	r1, r1, r1
	do_it	cs
	orrcs	xh, xh, #0x80000000
   22524:	23811102 	orrcs	r1, r1, #-2147483648	; 0x80000000
	RETLDM	"r4, r5"
   22528:	e8bd4030 	pop	{r4, r5, lr}
   2252c:	e12fff1e 	bx	lr
2:	adds	r4, r4, #(2 << 21)
   22530:	e2944501 	adds	r4, r4, #4194304	; 0x400000
	do_it	cc, t
	addcc	xh, xh, #(1 << 20)
   22534:	32811601 	addcc	r1, r1, #1048576	; 0x100000
	RETLDM	"r4, r5" cc
   22538:	38bd4030 	popcc	{r4, r5, lr}
   2253c:	312fff1e 	bxcc	lr
	and	r5, xh, #0x80000000
   22540:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000

	@ Overflow: return INF.
LSYM(Lad_o):
	orr	xh, r5, #0x7f000000
   22544:	e385147f 	orr	r1, r5, #2130706432	; 0x7f000000
	orr	xh, xh, #0x00f00000
   22548:	e381160f 	orr	r1, r1, #15728640	; 0xf00000
	mov	xl, #0
   2254c:	e3a00000 	mov	r0, #0
	RETLDM	"r4, r5"
   22550:	e8bd4030 	pop	{r4, r5, lr}
   22554:	e12fff1e 	bx	lr
	@   if yh-yl != INF/NAN: return xh-xl (which is INF/NAN)
	@   if either is NAN: return NAN
	@   if opposite sign: return NAN
	@   otherwise return xh-xl (which is INF or -INF)
LSYM(Lad_i):
	mvns	ip, r4, asr #21
   22558:	e1f0cac4 	mvns	ip, r4, asr #21
	do_it	ne, te
	movne	xh, yh
   2255c:	11a01003 	movne	r1, r3
	movne	xl, yl
   22560:	11a00002 	movne	r0, r2
	COND(mvn,s,eq)	ip, r5, asr #21
   22564:	01f0cac5 	mvnseq	ip, r5, asr #21
	do_it	ne, t
	movne	yh, xh
   22568:	11a03001 	movne	r3, r1
	movne	yl, xl
   2256c:	11a02000 	movne	r2, r0
	orrs	r4, xl, xh, lsl #12
   22570:	e1904601 	orrs	r4, r0, r1, lsl #12
	do_it	eq, te
	COND(orr,s,eq)	r5, yl, yh, lsl #12
   22574:	01925603 	orrseq	r5, r2, r3, lsl #12
	teqeq	xh, yh
   22578:	01310003 	teqeq	r1, r3
	orrne	xh, xh, #0x00080000	@ quiet NAN
   2257c:	13811702 	orrne	r1, r1, #524288	; 0x80000
	RETLDM	"r4, r5"
   22580:	e8bd4030 	pop	{r4, r5, lr}
   22584:	e12fff1e 	bx	lr

00022588 <__aeabi_ui2d>:
	FUNC_END adddf3

ARM_FUNC_START floatunsidf
ARM_FUNC_ALIAS aeabi_ui2d floatunsidf

	teq	r0, #0
   22588:	e3300000 	teq	r0, #0
	do_it	eq, t
	moveq	r1, #0
   2258c:	03a01000 	moveq	r1, #0
	RETc(eq)
   22590:	012fff1e 	bxeq	lr
	do_push	{r4, r5, lr}
   22594:	e92d4030 	push	{r4, r5, lr}
	mov	r4, #0x400		@ initial exponent
   22598:	e3a04b01 	mov	r4, #1024	; 0x400
	add	r4, r4, #(52-1 - 1)
   2259c:	e2844032 	add	r4, r4, #50	; 0x32
	mov	r5, #0			@ sign bit is 0
   225a0:	e3a05000 	mov	r5, #0
	.ifnc	xl, r0
	mov	xl, r0
	.endif
	mov	xh, #0
   225a4:	e3a01000 	mov	r1, #0
	b	LSYM(Lad_l)
   225a8:	eaffff86 	b	223c8 <__adddf3+0x150>

000225ac <__aeabi_i2d>:
	FUNC_END floatunsidf

ARM_FUNC_START floatsidf
ARM_FUNC_ALIAS aeabi_i2d floatsidf

	teq	r0, #0
   225ac:	e3300000 	teq	r0, #0
	do_it	eq, t
	moveq	r1, #0
   225b0:	03a01000 	moveq	r1, #0
	RETc(eq)
   225b4:	012fff1e 	bxeq	lr
	do_push	{r4, r5, lr}
   225b8:	e92d4030 	push	{r4, r5, lr}
	mov	r4, #0x400		@ initial exponent
   225bc:	e3a04b01 	mov	r4, #1024	; 0x400
	add	r4, r4, #(52-1 - 1)
   225c0:	e2844032 	add	r4, r4, #50	; 0x32
	ands	r5, r0, #0x80000000	@ sign bit in r5
   225c4:	e2105102 	ands	r5, r0, #-2147483648	; 0x80000000
	do_it	mi
	rsbmi	r0, r0, #0		@ absolute value
   225c8:	42600000 	rsbmi	r0, r0, #0
	.ifnc	xl, r0
	mov	xl, r0
	.endif
	mov	xh, #0
   225cc:	e3a01000 	mov	r1, #0
	b	LSYM(Lad_l)
   225d0:	eaffff7c 	b	223c8 <__adddf3+0x150>

000225d4 <__aeabi_f2d>:
	FUNC_END floatsidf

ARM_FUNC_START extendsfdf2
ARM_FUNC_ALIAS aeabi_f2d extendsfdf2

	movs	r2, r0, lsl #1		@ toss sign bit
   225d4:	e1b02080 	lsls	r2, r0, #1
	mov	xh, r2, asr #3		@ stretch exponent
   225d8:	e1a011c2 	asr	r1, r2, #3
	mov	xh, xh, rrx		@ retrieve sign bit
   225dc:	e1a01061 	rrx	r1, r1
	mov	xl, r2, lsl #28		@ retrieve remaining bits
   225e0:	e1a00e02 	lsl	r0, r2, #28
	do_it	ne, ttt
	COND(and,s,ne)	r3, r2, #0xff000000	@ isolate exponent
   225e4:	121234ff 	andsne	r3, r2, #-16777216	; 0xff000000
	teqne	r3, #0xff000000		@ if not 0, check if INF or NAN
   225e8:	133304ff 	teqne	r3, #-16777216	; 0xff000000
	eorne	xh, xh, #0x38000000	@ fixup exponent otherwise.
   225ec:	1221130e 	eorne	r1, r1, #939524096	; 0x38000000
	RETc(ne)			@ and return it.
   225f0:	112fff1e 	bxne	lr

	teq	r2, #0			@ if actually 0
   225f4:	e3320000 	teq	r2, #0
	do_it	ne, e
	teqne	r3, #0xff000000		@ or INF or NAN
   225f8:	133304ff 	teqne	r3, #-16777216	; 0xff000000
	RETc(eq)			@ we are done already.
   225fc:	012fff1e 	bxeq	lr

	@ value was denormalized.  We can normalize it now.
	do_push	{r4, r5, lr}
   22600:	e92d4030 	push	{r4, r5, lr}
	mov	r4, #0x380		@ setup corresponding exponent
   22604:	e3a04d0e 	mov	r4, #896	; 0x380
	and	r5, xh, #0x80000000	@ move sign bit in r5
   22608:	e2015102 	and	r5, r1, #-2147483648	; 0x80000000
	bic	xh, xh, #0x80000000
   2260c:	e3c11102 	bic	r1, r1, #-2147483648	; 0x80000000
	b	LSYM(Lad_l)
   22610:	eaffff6c 	b	223c8 <__adddf3+0x150>

00022614 <__aeabi_ul2d>:
	FUNC_END extendsfdf2

ARM_FUNC_START floatundidf
ARM_FUNC_ALIAS aeabi_ul2d floatundidf

	orrs	r2, r0, r1
   22614:	e1902001 	orrs	r2, r0, r1
	do_it	eq
	RETc(eq)
   22618:	012fff1e 	bxeq	lr

	do_push	{r4, r5, lr}
   2261c:	e92d4030 	push	{r4, r5, lr}

	mov	r5, #0
   22620:	e3a05000 	mov	r5, #0
	b	2f
   22624:	ea000006 	b	22644 <__aeabi_l2d+0x1c>

00022628 <__aeabi_l2d>:

ARM_FUNC_START floatdidf
ARM_FUNC_ALIAS aeabi_l2d floatdidf

	orrs	r2, r0, r1
   22628:	e1902001 	orrs	r2, r0, r1
	do_it	eq
	RETc(eq)
   2262c:	012fff1e 	bxeq	lr

	do_push	{r4, r5, lr}
   22630:	e92d4030 	push	{r4, r5, lr}

	ands	r5, ah, #0x80000000	@ sign bit in r5
   22634:	e2115102 	ands	r5, r1, #-2147483648	; 0x80000000
	bpl	2f
   22638:	5a000001 	bpl	22644 <__aeabi_l2d+0x1c>
#if defined(__thumb2__)
	negs	al, al
	sbc	ah, ah, ah, lsl #1
#else
	rsbs	al, al, #0
   2263c:	e2700000 	rsbs	r0, r0, #0
	rsc	ah, ah, #0
   22640:	e2e11000 	rsc	r1, r1, #0
#endif
2:
	mov	r4, #0x400		@ initial exponent
   22644:	e3a04b01 	mov	r4, #1024	; 0x400
	add	r4, r4, #(52-1 - 1)
   22648:	e2844032 	add	r4, r4, #50	; 0x32
	mov	ip, al
	mov	xh, ah
	mov	xl, ip
	.endif

	movs	ip, xh, lsr #22
   2264c:	e1b0cb21 	lsrs	ip, r1, #22
	beq	LSYM(Lad_p)
   22650:	0affff44 	beq	22368 <__adddf3+0xf0>

	@ The value is too big.  Scale it down a bit...
	mov	r2, #3
   22654:	e3a02003 	mov	r2, #3
	movs	ip, ip, lsr #3
   22658:	e1b0c1ac 	lsrs	ip, ip, #3
	do_it	ne
	addne	r2, r2, #3
   2265c:	12822003 	addne	r2, r2, #3
	movs	ip, ip, lsr #3
   22660:	e1b0c1ac 	lsrs	ip, ip, #3
	do_it	ne
	addne	r2, r2, #3
   22664:	12822003 	addne	r2, r2, #3
	add	r2, r2, ip, lsr #3
   22668:	e08221ac 	add	r2, r2, ip, lsr #3

	rsb	r3, r2, #32
   2266c:	e2623020 	rsb	r3, r2, #32
	shift1	lsl, ip, xl, r3
   22670:	e1a0c310 	lsl	ip, r0, r3
	shift1	lsr, xl, xl, r2
   22674:	e1a00230 	lsr	r0, r0, r2
	shiftop orr xl xl xh lsl r3 lr
   22678:	e1800311 	orr	r0, r0, r1, lsl r3
	shift1	lsr, xh, xh, r2
   2267c:	e1a01231 	lsr	r1, r1, r2
	add	r4, r4, r2
   22680:	e0844002 	add	r4, r4, r2
	b	LSYM(Lad_p)
   22684:	eaffff37 	b	22368 <__adddf3+0xf0>

00022688 <__aeabi_dmul>:

#ifdef L_arm_muldivdf3

ARM_FUNC_START muldf3
ARM_FUNC_ALIAS aeabi_dmul muldf3
	do_push	{r4, r5, r6, lr}
   22688:	e92d4070 	push	{r4, r5, r6, lr}

	@ Mask out exponents, trap any zero/denormal/INF/NAN.
	mov	ip, #0xff
   2268c:	e3a0c0ff 	mov	ip, #255	; 0xff
	orr	ip, ip, #0x700
   22690:	e38ccc07 	orr	ip, ip, #1792	; 0x700
	ands	r4, ip, xh, lsr #20
   22694:	e01c4a21 	ands	r4, ip, r1, lsr #20
	do_it	ne, tte
	COND(and,s,ne)	r5, ip, yh, lsr #20
   22698:	101c5a23 	andsne	r5, ip, r3, lsr #20
	teqne	r4, ip
   2269c:	1134000c 	teqne	r4, ip
	teqne	r5, ip
   226a0:	1135000c 	teqne	r5, ip
	bleq	LSYM(Lml_s)
   226a4:	0b000075 	bleq	22880 <__aeabi_dmul+0x1f8>

	@ Add exponents together
	add	r4, r4, r5
   226a8:	e0844005 	add	r4, r4, r5

	@ Determine final sign.
	eor	r6, xh, yh
   226ac:	e0216003 	eor	r6, r1, r3

	@ Convert mantissa to unsigned integer.
	@ If power of two, branch to a separate path.
	bic	xh, xh, ip, lsl #21
   226b0:	e1c11a8c 	bic	r1, r1, ip, lsl #21
	bic	yh, yh, ip, lsl #21
   226b4:	e1c33a8c 	bic	r3, r3, ip, lsl #21
	orrs	r5, xl, xh, lsl #12
   226b8:	e1905601 	orrs	r5, r0, r1, lsl #12
	do_it	ne
	COND(orr,s,ne)	r5, yl, yh, lsl #12
   226bc:	11925603 	orrsne	r5, r2, r3, lsl #12
	orr	xh, xh, #0x00100000
   226c0:	e3811601 	orr	r1, r1, #1048576	; 0x100000
	orr	yh, yh, #0x00100000
   226c4:	e3833601 	orr	r3, r3, #1048576	; 0x100000
	beq	LSYM(Lml_1)
   226c8:	0a00001d 	beq	22744 <__aeabi_dmul+0xbc>
	ldmfd	sp!, {yl, r7, r8, r9, sl, fp}

#else

	@ Here is the actual multiplication.
	umull	ip, lr, xl, yl
   226cc:	e08ec290 	umull	ip, lr, r0, r2
	mov	r5, #0
   226d0:	e3a05000 	mov	r5, #0
	umlal	lr, r5, xh, yl
   226d4:	e0a5e291 	umlal	lr, r5, r1, r2
	and	yl, r6, #0x80000000
   226d8:	e2062102 	and	r2, r6, #-2147483648	; 0x80000000
	umlal	lr, r5, xl, yh
   226dc:	e0a5e390 	umlal	lr, r5, r0, r3
	mov	r6, #0
   226e0:	e3a06000 	mov	r6, #0
	umlal	r5, r6, xh, yh
   226e4:	e0a65391 	umlal	r5, r6, r1, r3

#endif

	@ The LSBs in ip are only significant for the final rounding.
	@ Fold them into lr.
	teq	ip, #0
   226e8:	e33c0000 	teq	ip, #0
	do_it	ne
	orrne	lr, lr, #1
   226ec:	138ee001 	orrne	lr, lr, #1

	@ Adjust result upon the MSB position.
	sub	r4, r4, #0xff
   226f0:	e24440ff 	sub	r4, r4, #255	; 0xff
	cmp	r6, #(1 << (20-11))
   226f4:	e3560c02 	cmp	r6, #512	; 0x200
	sbc	r4, r4, #0x300
   226f8:	e2c44c03 	sbc	r4, r4, #768	; 0x300
	bcs	1f
   226fc:	2a000002 	bcs	2270c <__aeabi_dmul+0x84>
	movs	lr, lr, lsl #1
   22700:	e1b0e08e 	lsls	lr, lr, #1
	adcs	r5, r5, r5
   22704:	e0b55005 	adcs	r5, r5, r5
	adc	r6, r6, r6
   22708:	e0a66006 	adc	r6, r6, r6
1:
	@ Shift to final position, add sign to result.
	orr	xh, yl, r6, lsl #11
   2270c:	e1821586 	orr	r1, r2, r6, lsl #11
	orr	xh, xh, r5, lsr #21
   22710:	e1811aa5 	orr	r1, r1, r5, lsr #21
	mov	xl, r5, lsl #11
   22714:	e1a00585 	lsl	r0, r5, #11
	orr	xl, xl, lr, lsr #21
   22718:	e1800aae 	orr	r0, r0, lr, lsr #21
	mov	lr, lr, lsl #11
   2271c:	e1a0e58e 	lsl	lr, lr, #11

	@ Check exponent range for under/overflow.
	subs	ip, r4, #(254 - 1)
   22720:	e254c0fd 	subs	ip, r4, #253	; 0xfd
	do_it	hi
	cmphi	ip, #0x700
   22724:	835c0c07 	cmphi	ip, #1792	; 0x700
	bhi	LSYM(Lml_u)
   22728:	8a000011 	bhi	22774 <__aeabi_dmul+0xec>

	@ Round the result, merge final exponent.
	cmp	lr, #0x80000000
   2272c:	e35e0102 	cmp	lr, #-2147483648	; 0x80000000
	do_it	eq
	COND(mov,s,eq)	lr, xl, lsr #1
   22730:	01b0e0a0 	lsrseq	lr, r0, #1
	adcs	xl, xl, #0
   22734:	e2b00000 	adcs	r0, r0, #0
	adc	xh, xh, r4, lsl #20
   22738:	e0a11a04 	adc	r1, r1, r4, lsl #20
	RETLDM	"r4, r5, r6"
   2273c:	e8bd4070 	pop	{r4, r5, r6, lr}
   22740:	e12fff1e 	bx	lr

	@ Multiplication by 0x1p*: let''s shortcut a lot of code.
LSYM(Lml_1):
	and	r6, r6, #0x80000000
   22744:	e2066102 	and	r6, r6, #-2147483648	; 0x80000000
	orr	xh, r6, xh
   22748:	e1861001 	orr	r1, r6, r1
	orr	xl, xl, yl
   2274c:	e1800002 	orr	r0, r0, r2
	eor	xh, xh, yh
   22750:	e0211003 	eor	r1, r1, r3
	subs	r4, r4, ip, lsr #1
   22754:	e05440ac 	subs	r4, r4, ip, lsr #1
	do_it	gt, tt
	COND(rsb,s,gt)	r5, r4, ip
   22758:	c074500c 	rsbsgt	r5, r4, ip
	orrgt	xh, xh, r4, lsl #20
   2275c:	c1811a04 	orrgt	r1, r1, r4, lsl #20
	RETLDM	"r4, r5, r6" gt
   22760:	c8bd4070 	popgt	{r4, r5, r6, lr}
   22764:	c12fff1e 	bxgt	lr

	@ Under/overflow: fix things up for the code below.
	orr	xh, xh, #0x00100000
   22768:	e3811601 	orr	r1, r1, #1048576	; 0x100000
	mov	lr, #0
   2276c:	e3a0e000 	mov	lr, #0
	subs	r4, r4, #1
   22770:	e2544001 	subs	r4, r4, #1

LSYM(Lml_u):
	@ Overflow?
	bgt	LSYM(Lml_o)
   22774:	ca00005d 	bgt	228f0 <__aeabi_dmul+0x268>

	@ Check if denormalized result is possible, otherwise return signed 0.
	cmn	r4, #(53 + 1)
   22778:	e3740036 	cmn	r4, #54	; 0x36
	do_it	le, tt
	movle	xl, #0
   2277c:	d3a00000 	movle	r0, #0
	bicle	xh, xh, #0x7fffffff
   22780:	d2011102 	andle	r1, r1, #-2147483648	; 0x80000000
	RETLDM	"r4, r5, r6" le
   22784:	d8bd4070 	pople	{r4, r5, r6, lr}
   22788:	d12fff1e 	bxle	lr

	@ Find out proper shift value.
	rsb	r4, r4, #0
   2278c:	e2644000 	rsb	r4, r4, #0
	subs	r4, r4, #32
   22790:	e2544020 	subs	r4, r4, #32
	bge	2f
   22794:	aa00001a 	bge	22804 <__aeabi_dmul+0x17c>
	adds	r4, r4, #12
   22798:	e294400c 	adds	r4, r4, #12
	bgt	1f
   2279c:	ca00000c 	bgt	227d4 <__aeabi_dmul+0x14c>

	@ shift result right of 1 to 20 bits, preserve sign bit, round, etc.
	add	r4, r4, #20
   227a0:	e2844014 	add	r4, r4, #20
	rsb	r5, r4, #32
   227a4:	e2645020 	rsb	r5, r4, #32
	shift1	lsl, r3, xl, r5
   227a8:	e1a03510 	lsl	r3, r0, r5
	shift1	lsr, xl, xl, r4
   227ac:	e1a00430 	lsr	r0, r0, r4
	shiftop orr xl xl xh lsl r5 r2
   227b0:	e1800511 	orr	r0, r0, r1, lsl r5
	and	r2, xh, #0x80000000
   227b4:	e2012102 	and	r2, r1, #-2147483648	; 0x80000000
	bic	xh, xh, #0x80000000
   227b8:	e3c11102 	bic	r1, r1, #-2147483648	; 0x80000000
	adds	xl, xl, r3, lsr #31
   227bc:	e0900fa3 	adds	r0, r0, r3, lsr #31
	shiftop adc xh r2 xh lsr r4 r6
   227c0:	e0a21431 	adc	r1, r2, r1, lsr r4
	orrs	lr, lr, r3, lsl #1
   227c4:	e19ee083 	orrs	lr, lr, r3, lsl #1
	do_it	eq
	biceq	xl, xl, r3, lsr #31
   227c8:	01c00fa3 	biceq	r0, r0, r3, lsr #31
	RETLDM	"r4, r5, r6"
   227cc:	e8bd4070 	pop	{r4, r5, r6, lr}
   227d0:	e12fff1e 	bx	lr

	@ shift result right of 21 to 31 bits, or left 11 to 1 bits after
	@ a register switch from xh to xl. Then round.
1:	rsb	r4, r4, #12
   227d4:	e264400c 	rsb	r4, r4, #12
	rsb	r5, r4, #32
   227d8:	e2645020 	rsb	r5, r4, #32
	shift1	lsl, r3, xl, r4
   227dc:	e1a03410 	lsl	r3, r0, r4
	shift1	lsr, xl, xl, r5
   227e0:	e1a00530 	lsr	r0, r0, r5
	shiftop orr xl xl xh lsl r4 r2
   227e4:	e1800411 	orr	r0, r0, r1, lsl r4
	bic	xh, xh, #0x7fffffff
   227e8:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
	adds	xl, xl, r3, lsr #31
   227ec:	e0900fa3 	adds	r0, r0, r3, lsr #31
	adc	xh, xh, #0
   227f0:	e2a11000 	adc	r1, r1, #0
	orrs	lr, lr, r3, lsl #1
   227f4:	e19ee083 	orrs	lr, lr, r3, lsl #1
	do_it	eq
	biceq	xl, xl, r3, lsr #31
   227f8:	01c00fa3 	biceq	r0, r0, r3, lsr #31
	RETLDM	"r4, r5, r6"
   227fc:	e8bd4070 	pop	{r4, r5, r6, lr}
   22800:	e12fff1e 	bx	lr

	@ Shift value right of 32 to 64 bits, or 0 to 32 bits after a switch
	@ from xh to xl.  Leftover bits are in r3-r6-lr for rounding.
2:	rsb	r5, r4, #32
   22804:	e2645020 	rsb	r5, r4, #32
	shiftop orr lr lr xl lsl r5 r2
   22808:	e18ee510 	orr	lr, lr, r0, lsl r5
	shift1	lsr, r3, xl, r4
   2280c:	e1a03430 	lsr	r3, r0, r4
	shiftop orr r3 r3 xh lsl r5 r2
   22810:	e1833511 	orr	r3, r3, r1, lsl r5
	shift1	lsr, xl, xh, r4
   22814:	e1a00431 	lsr	r0, r1, r4
	bic	xh, xh, #0x7fffffff
   22818:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
	shiftop bic xl xl xh lsr r4 r2
   2281c:	e1c00431 	bic	r0, r0, r1, lsr r4
	add	xl, xl, r3, lsr #31
   22820:	e0800fa3 	add	r0, r0, r3, lsr #31
	orrs	lr, lr, r3, lsl #1
   22824:	e19ee083 	orrs	lr, lr, r3, lsl #1
	do_it	eq
	biceq	xl, xl, r3, lsr #31
   22828:	01c00fa3 	biceq	r0, r0, r3, lsr #31
	RETLDM	"r4, r5, r6"
   2282c:	e8bd4070 	pop	{r4, r5, r6, lr}
   22830:	e12fff1e 	bx	lr

	@ One or both arguments are denormalized.
	@ Scale them leftwards and preserve sign bit.
LSYM(Lml_d):
	teq	r4, #0
   22834:	e3340000 	teq	r4, #0
	bne	2f
   22838:	1a000008 	bne	22860 <__aeabi_dmul+0x1d8>
	and	r6, xh, #0x80000000
   2283c:	e2016102 	and	r6, r1, #-2147483648	; 0x80000000
1:	movs	xl, xl, lsl #1
   22840:	e1b00080 	lsls	r0, r0, #1
	adc	xh, xh, xh
   22844:	e0a11001 	adc	r1, r1, r1
	tst	xh, #0x00100000
   22848:	e3110601 	tst	r1, #1048576	; 0x100000
	do_it	eq
	subeq	r4, r4, #1
   2284c:	02444001 	subeq	r4, r4, #1
	beq	1b
   22850:	0afffffa 	beq	22840 <__aeabi_dmul+0x1b8>
	orr	xh, xh, r6
   22854:	e1811006 	orr	r1, r1, r6
	teq	r5, #0
   22858:	e3350000 	teq	r5, #0
	do_it	ne
	RETc(ne)
   2285c:	112fff1e 	bxne	lr
2:	and	r6, yh, #0x80000000
   22860:	e2036102 	and	r6, r3, #-2147483648	; 0x80000000
3:	movs	yl, yl, lsl #1
   22864:	e1b02082 	lsls	r2, r2, #1
	adc	yh, yh, yh
   22868:	e0a33003 	adc	r3, r3, r3
	tst	yh, #0x00100000
   2286c:	e3130601 	tst	r3, #1048576	; 0x100000
	do_it	eq
	subeq	r5, r5, #1
   22870:	02455001 	subeq	r5, r5, #1
	beq	3b
   22874:	0afffffa 	beq	22864 <__aeabi_dmul+0x1dc>
	orr	yh, yh, r6
   22878:	e1833006 	orr	r3, r3, r6
	RET
   2287c:	e12fff1e 	bx	lr

LSYM(Lml_s):
	@ Isolate the INF and NAN cases away
	teq	r4, ip
   22880:	e134000c 	teq	r4, ip
	and	r5, ip, yh, lsr #20
   22884:	e00c5a23 	and	r5, ip, r3, lsr #20
	do_it	ne
	teqne	r5, ip
   22888:	1135000c 	teqne	r5, ip
	beq	1f
   2288c:	0a000007 	beq	228b0 <__aeabi_dmul+0x228>

	@ Here, one or more arguments are either denormalized or zero.
	orrs	r6, xl, xh, lsl #1
   22890:	e1906081 	orrs	r6, r0, r1, lsl #1
	do_it	ne
	COND(orr,s,ne)	r6, yl, yh, lsl #1
   22894:	11926083 	orrsne	r6, r2, r3, lsl #1
	bne	LSYM(Lml_d)
   22898:	1affffe5 	bne	22834 <__aeabi_dmul+0x1ac>

	@ Result is 0, but determine sign anyway.
LSYM(Lml_z):
	eor	xh, xh, yh
   2289c:	e0211003 	eor	r1, r1, r3
	and	xh, xh, #0x80000000
   228a0:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
	mov	xl, #0
   228a4:	e3a00000 	mov	r0, #0
	RETLDM	"r4, r5, r6"
   228a8:	e8bd4070 	pop	{r4, r5, r6, lr}
   228ac:	e12fff1e 	bx	lr

1:	@ One or both args are INF or NAN.
	orrs	r6, xl, xh, lsl #1
   228b0:	e1906081 	orrs	r6, r0, r1, lsl #1
	do_it	eq, te
	moveq	xl, yl
   228b4:	01a00002 	moveq	r0, r2
	moveq	xh, yh
   228b8:	01a01003 	moveq	r1, r3
	COND(orr,s,ne)	r6, yl, yh, lsl #1
   228bc:	11926083 	orrsne	r6, r2, r3, lsl #1
	beq	LSYM(Lml_n)		@ 0 * INF or INF * 0 -> NAN
   228c0:	0a000010 	beq	22908 <__aeabi_dmul+0x280>
	teq	r4, ip
   228c4:	e134000c 	teq	r4, ip
	bne	1f
   228c8:	1a000001 	bne	228d4 <__aeabi_dmul+0x24c>
	orrs	r6, xl, xh, lsl #12
   228cc:	e1906601 	orrs	r6, r0, r1, lsl #12
	bne	LSYM(Lml_n)		@ NAN * <anything> -> NAN
   228d0:	1a00000c 	bne	22908 <__aeabi_dmul+0x280>
1:	teq	r5, ip
   228d4:	e135000c 	teq	r5, ip
	bne	LSYM(Lml_i)
   228d8:	1a000003 	bne	228ec <__aeabi_dmul+0x264>
	orrs	r6, yl, yh, lsl #12
   228dc:	e1926603 	orrs	r6, r2, r3, lsl #12
	do_it	ne, t
	movne	xl, yl
   228e0:	11a00002 	movne	r0, r2
	movne	xh, yh
   228e4:	11a01003 	movne	r1, r3
	bne	LSYM(Lml_n)		@ <anything> * NAN -> NAN
   228e8:	1a000006 	bne	22908 <__aeabi_dmul+0x280>

	@ Result is INF, but we need to determine its sign.
LSYM(Lml_i):
	eor	xh, xh, yh
   228ec:	e0211003 	eor	r1, r1, r3

	@ Overflow: return INF (sign already in xh).
LSYM(Lml_o):
	and	xh, xh, #0x80000000
   228f0:	e2011102 	and	r1, r1, #-2147483648	; 0x80000000
	orr	xh, xh, #0x7f000000
   228f4:	e381147f 	orr	r1, r1, #2130706432	; 0x7f000000
	orr	xh, xh, #0x00f00000
   228f8:	e381160f 	orr	r1, r1, #15728640	; 0xf00000
	mov	xl, #0
   228fc:	e3a00000 	mov	r0, #0
	RETLDM	"r4, r5, r6"
   22900:	e8bd4070 	pop	{r4, r5, r6, lr}
   22904:	e12fff1e 	bx	lr

	@ Return a quiet NAN.
LSYM(Lml_n):
	orr	xh, xh, #0x7f000000
   22908:	e381147f 	orr	r1, r1, #2130706432	; 0x7f000000
	orr	xh, xh, #0x00f80000
   2290c:	e381173e 	orr	r1, r1, #16252928	; 0xf80000
	RETLDM	"r4, r5, r6"
   22910:	e8bd4070 	pop	{r4, r5, r6, lr}
   22914:	e12fff1e 	bx	lr

00022918 <__aeabi_ddiv>:
	FUNC_END muldf3

ARM_FUNC_START divdf3
ARM_FUNC_ALIAS aeabi_ddiv divdf3
	
	do_push	{r4, r5, r6, lr}
   22918:	e92d4070 	push	{r4, r5, r6, lr}

	@ Mask out exponents, trap any zero/denormal/INF/NAN.
	mov	ip, #0xff
   2291c:	e3a0c0ff 	mov	ip, #255	; 0xff
	orr	ip, ip, #0x700
   22920:	e38ccc07 	orr	ip, ip, #1792	; 0x700
	ands	r4, ip, xh, lsr #20
   22924:	e01c4a21 	ands	r4, ip, r1, lsr #20
	do_it	ne, tte
	COND(and,s,ne)	r5, ip, yh, lsr #20
   22928:	101c5a23 	andsne	r5, ip, r3, lsr #20
	teqne	r4, ip
   2292c:	1134000c 	teqne	r4, ip
	teqne	r5, ip
   22930:	1135000c 	teqne	r5, ip
	bleq	LSYM(Ldv_s)
   22934:	0b00005e 	bleq	22ab4 <__aeabi_ddiv+0x19c>

	@ Subtract divisor exponent from dividend''s.
	sub	r4, r4, r5
   22938:	e0444005 	sub	r4, r4, r5

	@ Preserve final sign into lr.
	eor	lr, xh, yh
   2293c:	e021e003 	eor	lr, r1, r3

	@ Convert mantissa to unsigned integer.
	@ Dividend -> r5-r6, divisor -> yh-yl.
	orrs	r5, yl, yh, lsl #12
   22940:	e1925603 	orrs	r5, r2, r3, lsl #12
	mov	xh, xh, lsl #12
   22944:	e1a01601 	lsl	r1, r1, #12
	beq	LSYM(Ldv_1)
   22948:	0a00004c 	beq	22a80 <__aeabi_ddiv+0x168>
	mov	yh, yh, lsl #12
   2294c:	e1a03603 	lsl	r3, r3, #12
	mov	r5, #0x10000000
   22950:	e3a05201 	mov	r5, #268435456	; 0x10000000
	orr	yh, r5, yh, lsr #4
   22954:	e1853223 	orr	r3, r5, r3, lsr #4
	orr	yh, yh, yl, lsr #24
   22958:	e1833c22 	orr	r3, r3, r2, lsr #24
	mov	yl, yl, lsl #8
   2295c:	e1a02402 	lsl	r2, r2, #8
	orr	r5, r5, xh, lsr #4
   22960:	e1855221 	orr	r5, r5, r1, lsr #4
	orr	r5, r5, xl, lsr #24
   22964:	e1855c20 	orr	r5, r5, r0, lsr #24
	mov	r6, xl, lsl #8
   22968:	e1a06400 	lsl	r6, r0, #8

	@ Initialize xh with final sign bit.
	and	xh, lr, #0x80000000
   2296c:	e20e1102 	and	r1, lr, #-2147483648	; 0x80000000

	@ Ensure result will land to known bit position.
	@ Apply exponent bias accordingly.
	cmp	r5, yh
   22970:	e1550003 	cmp	r5, r3
	do_it	eq
	cmpeq	r6, yl
   22974:	01560002 	cmpeq	r6, r2
	adc	r4, r4, #(255 - 2)
   22978:	e2a440fd 	adc	r4, r4, #253	; 0xfd
	add	r4, r4, #0x300
   2297c:	e2844c03 	add	r4, r4, #768	; 0x300
	bcs	1f
   22980:	2a000001 	bcs	2298c <__aeabi_ddiv+0x74>
	movs	yh, yh, lsr #1
   22984:	e1b030a3 	lsrs	r3, r3, #1
	mov	yl, yl, rrx
   22988:	e1a02062 	rrx	r2, r2
1:
	@ Perform first subtraction to align result to a nibble.
	subs	r6, r6, yl
   2298c:	e0566002 	subs	r6, r6, r2
	sbc	r5, r5, yh
   22990:	e0c55003 	sbc	r5, r5, r3
	movs	yh, yh, lsr #1
   22994:	e1b030a3 	lsrs	r3, r3, #1
	mov	yl, yl, rrx
   22998:	e1a02062 	rrx	r2, r2
	mov	xl, #0x00100000
   2299c:	e3a00601 	mov	r0, #1048576	; 0x100000
	mov	ip, #0x00080000
   229a0:	e3a0c702 	mov	ip, #524288	; 0x80000

	@ The actual division loop.
1:	subs	lr, r6, yl
   229a4:	e056e002 	subs	lr, r6, r2
	sbcs	lr, r5, yh
   229a8:	e0d5e003 	sbcs	lr, r5, r3
	do_it	cs, tt
	subcs	r6, r6, yl
   229ac:	20466002 	subcs	r6, r6, r2
	movcs	r5, lr
   229b0:	21a0500e 	movcs	r5, lr
	orrcs	xl, xl, ip
   229b4:	2180000c 	orrcs	r0, r0, ip
	movs	yh, yh, lsr #1
   229b8:	e1b030a3 	lsrs	r3, r3, #1
	mov	yl, yl, rrx
   229bc:	e1a02062 	rrx	r2, r2
	subs	lr, r6, yl
   229c0:	e056e002 	subs	lr, r6, r2
	sbcs	lr, r5, yh
   229c4:	e0d5e003 	sbcs	lr, r5, r3
	do_it	cs, tt
	subcs	r6, r6, yl
   229c8:	20466002 	subcs	r6, r6, r2
	movcs	r5, lr
   229cc:	21a0500e 	movcs	r5, lr
	orrcs	xl, xl, ip, lsr #1
   229d0:	218000ac 	orrcs	r0, r0, ip, lsr #1
	movs	yh, yh, lsr #1
   229d4:	e1b030a3 	lsrs	r3, r3, #1
	mov	yl, yl, rrx
   229d8:	e1a02062 	rrx	r2, r2
	subs	lr, r6, yl
   229dc:	e056e002 	subs	lr, r6, r2
	sbcs	lr, r5, yh
   229e0:	e0d5e003 	sbcs	lr, r5, r3
	do_it	cs, tt
	subcs	r6, r6, yl
   229e4:	20466002 	subcs	r6, r6, r2
	movcs	r5, lr
   229e8:	21a0500e 	movcs	r5, lr
	orrcs	xl, xl, ip, lsr #2
   229ec:	2180012c 	orrcs	r0, r0, ip, lsr #2
	movs	yh, yh, lsr #1
   229f0:	e1b030a3 	lsrs	r3, r3, #1
	mov	yl, yl, rrx
   229f4:	e1a02062 	rrx	r2, r2
	subs	lr, r6, yl
   229f8:	e056e002 	subs	lr, r6, r2
	sbcs	lr, r5, yh
   229fc:	e0d5e003 	sbcs	lr, r5, r3
	do_it	cs, tt
	subcs	r6, r6, yl
   22a00:	20466002 	subcs	r6, r6, r2
	movcs	r5, lr
   22a04:	21a0500e 	movcs	r5, lr
	orrcs	xl, xl, ip, lsr #3
   22a08:	218001ac 	orrcs	r0, r0, ip, lsr #3

	orrs	lr, r5, r6
   22a0c:	e195e006 	orrs	lr, r5, r6
	beq	2f
   22a10:	0a00000d 	beq	22a4c <__aeabi_ddiv+0x134>
	mov	r5, r5, lsl #4
   22a14:	e1a05205 	lsl	r5, r5, #4
	orr	r5, r5, r6, lsr #28
   22a18:	e1855e26 	orr	r5, r5, r6, lsr #28
	mov	r6, r6, lsl #4
   22a1c:	e1a06206 	lsl	r6, r6, #4
	mov	yh, yh, lsl #3
   22a20:	e1a03183 	lsl	r3, r3, #3
	orr	yh, yh, yl, lsr #29
   22a24:	e1833ea2 	orr	r3, r3, r2, lsr #29
	mov	yl, yl, lsl #3
   22a28:	e1a02182 	lsl	r2, r2, #3
	movs	ip, ip, lsr #4
   22a2c:	e1b0c22c 	lsrs	ip, ip, #4
	bne	1b
   22a30:	1affffdb 	bne	229a4 <__aeabi_ddiv+0x8c>

	@ We are done with a word of the result.
	@ Loop again for the low word if this pass was for the high word.
	tst	xh, #0x00100000
   22a34:	e3110601 	tst	r1, #1048576	; 0x100000
	bne	3f
   22a38:	1a000006 	bne	22a58 <__aeabi_ddiv+0x140>
	orr	xh, xh, xl
   22a3c:	e1811000 	orr	r1, r1, r0
	mov	xl, #0
   22a40:	e3a00000 	mov	r0, #0
	mov	ip, #0x80000000
   22a44:	e3a0c102 	mov	ip, #-2147483648	; 0x80000000
	b	1b
   22a48:	eaffffd5 	b	229a4 <__aeabi_ddiv+0x8c>
2:
	@ Be sure result starts in the high word.
	tst	xh, #0x00100000
   22a4c:	e3110601 	tst	r1, #1048576	; 0x100000
	do_it	eq, t
	orreq	xh, xh, xl
   22a50:	01811000 	orreq	r1, r1, r0
	moveq	xl, #0
   22a54:	03a00000 	moveq	r0, #0
3:
	@ Check exponent range for under/overflow.
	subs	ip, r4, #(254 - 1)
   22a58:	e254c0fd 	subs	ip, r4, #253	; 0xfd
	do_it	hi
	cmphi	ip, #0x700
   22a5c:	835c0c07 	cmphi	ip, #1792	; 0x700
	bhi	LSYM(Lml_u)
   22a60:	8affff43 	bhi	22774 <__aeabi_dmul+0xec>

	@ Round the result, merge final exponent.
	subs	ip, r5, yh
   22a64:	e055c003 	subs	ip, r5, r3
	do_it	eq, t
	COND(sub,s,eq)	ip, r6, yl
   22a68:	0056c002 	subseq	ip, r6, r2
	COND(mov,s,eq)	ip, xl, lsr #1
   22a6c:	01b0c0a0 	lsrseq	ip, r0, #1
	adcs	xl, xl, #0
   22a70:	e2b00000 	adcs	r0, r0, #0
	adc	xh, xh, r4, lsl #20
   22a74:	e0a11a04 	adc	r1, r1, r4, lsl #20
	RETLDM	"r4, r5, r6"
   22a78:	e8bd4070 	pop	{r4, r5, r6, lr}
   22a7c:	e12fff1e 	bx	lr

	@ Division by 0x1p*: shortcut a lot of code.
LSYM(Ldv_1):
	and	lr, lr, #0x80000000
   22a80:	e20ee102 	and	lr, lr, #-2147483648	; 0x80000000
	orr	xh, lr, xh, lsr #12
   22a84:	e18e1621 	orr	r1, lr, r1, lsr #12
	adds	r4, r4, ip, lsr #1
   22a88:	e09440ac 	adds	r4, r4, ip, lsr #1
	do_it	gt, tt
	COND(rsb,s,gt)	r5, r4, ip
   22a8c:	c074500c 	rsbsgt	r5, r4, ip
	orrgt	xh, xh, r4, lsl #20
   22a90:	c1811a04 	orrgt	r1, r1, r4, lsl #20
	RETLDM	"r4, r5, r6" gt
   22a94:	c8bd4070 	popgt	{r4, r5, r6, lr}
   22a98:	c12fff1e 	bxgt	lr

	orr	xh, xh, #0x00100000
   22a9c:	e3811601 	orr	r1, r1, #1048576	; 0x100000
	mov	lr, #0
   22aa0:	e3a0e000 	mov	lr, #0
	subs	r4, r4, #1
   22aa4:	e2544001 	subs	r4, r4, #1
	b	LSYM(Lml_u)
   22aa8:	eaffff31 	b	22774 <__aeabi_dmul+0xec>

	@ Result mightt need to be denormalized: put remainder bits
	@ in lr for rounding considerations.
LSYM(Ldv_u):
	orr	lr, r5, r6
   22aac:	e185e006 	orr	lr, r5, r6
	b	LSYM(Lml_u)
   22ab0:	eaffff2f 	b	22774 <__aeabi_dmul+0xec>

	@ One or both arguments is either INF, NAN or zero.
LSYM(Ldv_s):
	and	r5, ip, yh, lsr #20
   22ab4:	e00c5a23 	and	r5, ip, r3, lsr #20
	teq	r4, ip
   22ab8:	e134000c 	teq	r4, ip
	do_it	eq
	teqeq	r5, ip
   22abc:	0135000c 	teqeq	r5, ip
	beq	LSYM(Lml_n)		@ INF/NAN / INF/NAN -> NAN
   22ac0:	0affff90 	beq	22908 <__aeabi_dmul+0x280>
	teq	r4, ip
   22ac4:	e134000c 	teq	r4, ip
	bne	1f
   22ac8:	1a000006 	bne	22ae8 <__aeabi_ddiv+0x1d0>
	orrs	r4, xl, xh, lsl #12
   22acc:	e1904601 	orrs	r4, r0, r1, lsl #12
	bne	LSYM(Lml_n)		@ NAN / <anything> -> NAN
   22ad0:	1affff8c 	bne	22908 <__aeabi_dmul+0x280>
	teq	r5, ip
   22ad4:	e135000c 	teq	r5, ip
	bne	LSYM(Lml_i)		@ INF / <anything> -> INF
   22ad8:	1affff83 	bne	228ec <__aeabi_dmul+0x264>
	mov	xl, yl
   22adc:	e1a00002 	mov	r0, r2
	mov	xh, yh
   22ae0:	e1a01003 	mov	r1, r3
	b	LSYM(Lml_n)		@ INF / (INF or NAN) -> NAN
   22ae4:	eaffff87 	b	22908 <__aeabi_dmul+0x280>
1:	teq	r5, ip
   22ae8:	e135000c 	teq	r5, ip
	bne	2f
   22aec:	1a000004 	bne	22b04 <__aeabi_ddiv+0x1ec>
	orrs	r5, yl, yh, lsl #12
   22af0:	e1925603 	orrs	r5, r2, r3, lsl #12
	beq	LSYM(Lml_z)		@ <anything> / INF -> 0
   22af4:	0affff68 	beq	2289c <__aeabi_dmul+0x214>
	mov	xl, yl
   22af8:	e1a00002 	mov	r0, r2
	mov	xh, yh
   22afc:	e1a01003 	mov	r1, r3
	b	LSYM(Lml_n)		@ <anything> / NAN -> NAN
   22b00:	eaffff80 	b	22908 <__aeabi_dmul+0x280>
2:	@ If both are nonzero, we need to normalize and resume above.
	orrs	r6, xl, xh, lsl #1
   22b04:	e1906081 	orrs	r6, r0, r1, lsl #1
	do_it	ne
	COND(orr,s,ne)	r6, yl, yh, lsl #1
   22b08:	11926083 	orrsne	r6, r2, r3, lsl #1
	bne	LSYM(Lml_d)
   22b0c:	1affff48 	bne	22834 <__aeabi_dmul+0x1ac>
	@ One or both arguments are 0.
	orrs	r4, xl, xh, lsl #1
   22b10:	e1904081 	orrs	r4, r0, r1, lsl #1
	bne	LSYM(Lml_i)		@ <non_zero> / 0 -> INF
   22b14:	1affff74 	bne	228ec <__aeabi_dmul+0x264>
	orrs	r5, yl, yh, lsl #1
   22b18:	e1925083 	orrs	r5, r2, r3, lsl #1
	bne	LSYM(Lml_z)		@ 0 / <non_zero> -> 0
   22b1c:	1affff5e 	bne	2289c <__aeabi_dmul+0x214>
	b	LSYM(Lml_n)		@ 0 / 0 -> NAN
   22b20:	eaffff78 	b	22908 <__aeabi_dmul+0x280>

00022b24 <__gedf2>:

@ Note: only r0 (return value) and ip are clobbered here.

ARM_FUNC_START gtdf2
ARM_FUNC_ALIAS gedf2 gtdf2
	mov	ip, #-1
   22b24:	e3e0c000 	mvn	ip, #0
	b	1f
   22b28:	ea000002 	b	22b38 <__cmpdf2+0x4>

00022b2c <__ledf2>:

ARM_FUNC_START ltdf2
ARM_FUNC_ALIAS ledf2 ltdf2
	mov	ip, #1
   22b2c:	e3a0c001 	mov	ip, #1
	b	1f
   22b30:	ea000000 	b	22b38 <__cmpdf2+0x4>

00022b34 <__cmpdf2>:

ARM_FUNC_START cmpdf2
ARM_FUNC_ALIAS nedf2 cmpdf2
ARM_FUNC_ALIAS eqdf2 cmpdf2
	mov	ip, #1			@ how should we specify unordered here?
   22b34:	e3a0c001 	mov	ip, #1

1:	str	ip, [sp, #-4]!
   22b38:	e52dc004 	push	{ip}		; (str ip, [sp, #-4]!)

	@ Trap any INF/NAN first.
	mov	ip, xh, lsl #1
   22b3c:	e1a0c081 	lsl	ip, r1, #1
	mvns	ip, ip, asr #21
   22b40:	e1f0cacc 	mvns	ip, ip, asr #21
	mov	ip, yh, lsl #1
   22b44:	e1a0c083 	lsl	ip, r3, #1
	do_it	ne
	COND(mvn,s,ne)	ip, ip, asr #21
   22b48:	11f0cacc 	mvnsne	ip, ip, asr #21
	beq	3f
   22b4c:	0a00000e 	beq	22b8c <__cmpdf2+0x58>

	@ Test for equality.
	@ Note that 0.0 is equal to -0.0.
2:	add	sp, sp, #4
   22b50:	e28dd004 	add	sp, sp, #4
	orrs	ip, xl, xh, lsl #1	@ if x == 0.0 or -0.0
   22b54:	e190c081 	orrs	ip, r0, r1, lsl #1
	do_it	eq, e
	COND(orr,s,eq)	ip, yl, yh, lsl #1	@ and y == 0.0 or -0.0
   22b58:	0192c083 	orrseq	ip, r2, r3, lsl #1
	teqne	xh, yh			@ or xh == yh
   22b5c:	11310003 	teqne	r1, r3
	do_it	eq, tt
	teqeq	xl, yl			@ and xl == yl
   22b60:	01300002 	teqeq	r0, r2
	moveq	r0, #0			@ then equal.
   22b64:	03a00000 	moveq	r0, #0
	RETc(eq)
   22b68:	012fff1e 	bxeq	lr

	@ Clear C flag
	cmn	r0, #0
   22b6c:	e3700000 	cmn	r0, #0

	@ Compare sign, 
	teq	xh, yh
   22b70:	e1310003 	teq	r1, r3

	@ Compare values if same sign
	do_it	pl
	cmppl	xh, yh
   22b74:	51510003 	cmppl	r1, r3
	do_it	eq
	cmpeq	xl, yl
   22b78:	01500002 	cmpeq	r0, r2

	@ Result:
	do_it	cs, e
	movcs	r0, yh, asr #31
   22b7c:	21a00fc3 	asrcs	r0, r3, #31
	mvncc	r0, yh, asr #31
   22b80:	31e00fc3 	mvncc	r0, r3, asr #31
	orr	r0, r0, #1
   22b84:	e3800001 	orr	r0, r0, #1
	RET
   22b88:	e12fff1e 	bx	lr

	@ Look for a NAN.
3:	mov	ip, xh, lsl #1
   22b8c:	e1a0c081 	lsl	ip, r1, #1
	mvns	ip, ip, asr #21
   22b90:	e1f0cacc 	mvns	ip, ip, asr #21
	bne	4f
   22b94:	1a000001 	bne	22ba0 <__cmpdf2+0x6c>
	orrs	ip, xl, xh, lsl #12
   22b98:	e190c601 	orrs	ip, r0, r1, lsl #12
	bne	5f			@ x is NAN
   22b9c:	1a000004 	bne	22bb4 <__cmpdf2+0x80>
4:	mov	ip, yh, lsl #1
   22ba0:	e1a0c083 	lsl	ip, r3, #1
	mvns	ip, ip, asr #21
   22ba4:	e1f0cacc 	mvns	ip, ip, asr #21
	bne	2b
   22ba8:	1affffe8 	bne	22b50 <__cmpdf2+0x1c>
	orrs	ip, yl, yh, lsl #12
   22bac:	e192c603 	orrs	ip, r2, r3, lsl #12
	beq	2b			@ y is not NAN
   22bb0:	0affffe6 	beq	22b50 <__cmpdf2+0x1c>
5:	ldr	r0, [sp], #4		@ unordered return code
   22bb4:	e49d0004 	pop	{r0}		; (ldr r0, [sp], #4)
	RET
   22bb8:	e12fff1e 	bx	lr

00022bbc <__aeabi_cdrcmple>:
	FUNC_END eqdf2
	FUNC_END cmpdf2

ARM_FUNC_START aeabi_cdrcmple

	mov	ip, r0
   22bbc:	e1a0c000 	mov	ip, r0
	mov	r0, r2
   22bc0:	e1a00002 	mov	r0, r2
	mov	r2, ip
   22bc4:	e1a0200c 	mov	r2, ip
	mov	ip, r1
   22bc8:	e1a0c001 	mov	ip, r1
	mov	r1, r3
   22bcc:	e1a01003 	mov	r1, r3
	mov	r3, ip
   22bd0:	e1a0300c 	mov	r3, ip
	b	6f
   22bd4:	eaffffff 	b	22bd8 <__aeabi_cdcmpeq>

00022bd8 <__aeabi_cdcmpeq>:
ARM_FUNC_START aeabi_cdcmpeq
ARM_FUNC_ALIAS aeabi_cdcmple aeabi_cdcmpeq

	@ The status-returning routines are required to preserve all
	@ registers except ip, lr, and cpsr.
6:	do_push	{r0, lr}
   22bd8:	e92d4001 	push	{r0, lr}
	ARM_CALL cmpdf2
   22bdc:	ebffffd4 	bl	22b34 <__cmpdf2>
	@ Set the Z flag correctly, and the C flag unconditionally.
	cmp	r0, #0
   22be0:	e3500000 	cmp	r0, #0
	@ Clear the C flag if the return value was -1, indicating
	@ that the first operand was smaller than the second.
	do_it	mi
	cmnmi	r0, #0
   22be4:	43700000 	cmnmi	r0, #0
	RETLDM	"r0"
   22be8:	e8bd4001 	pop	{r0, lr}
   22bec:	e12fff1e 	bx	lr

00022bf0 <__aeabi_dcmpeq>:
	FUNC_END aeabi_cdcmpeq
	FUNC_END aeabi_cdrcmple
	
ARM_FUNC_START	aeabi_dcmpeq

	str	lr, [sp, #-8]!
   22bf0:	e52de008 	str	lr, [sp, #-8]!
	ARM_CALL aeabi_cdcmple
   22bf4:	ebfffff7 	bl	22bd8 <__aeabi_cdcmpeq>
	do_it	eq, e
	moveq	r0, #1	@ Equal to.
   22bf8:	03a00001 	moveq	r0, #1
	movne	r0, #0	@ Less than, greater than, or unordered.
   22bfc:	13a00000 	movne	r0, #0
	RETLDM
   22c00:	e49de008 	ldr	lr, [sp], #8
   22c04:	e12fff1e 	bx	lr

00022c08 <__aeabi_dcmplt>:

	FUNC_END aeabi_dcmpeq

ARM_FUNC_START	aeabi_dcmplt

	str	lr, [sp, #-8]!
   22c08:	e52de008 	str	lr, [sp, #-8]!
	ARM_CALL aeabi_cdcmple
   22c0c:	ebfffff1 	bl	22bd8 <__aeabi_cdcmpeq>
	do_it	cc, e
	movcc	r0, #1	@ Less than.
   22c10:	33a00001 	movcc	r0, #1
	movcs	r0, #0	@ Equal to, greater than, or unordered.
   22c14:	23a00000 	movcs	r0, #0
	RETLDM
   22c18:	e49de008 	ldr	lr, [sp], #8
   22c1c:	e12fff1e 	bx	lr

00022c20 <__aeabi_dcmple>:

	FUNC_END aeabi_dcmplt

ARM_FUNC_START	aeabi_dcmple

	str	lr, [sp, #-8]!
   22c20:	e52de008 	str	lr, [sp, #-8]!
	ARM_CALL aeabi_cdcmple
   22c24:	ebffffeb 	bl	22bd8 <__aeabi_cdcmpeq>
	do_it	ls, e
	movls	r0, #1  @ Less than or equal to.
   22c28:	93a00001 	movls	r0, #1
	movhi	r0, #0	@ Greater than or unordered.
   22c2c:	83a00000 	movhi	r0, #0
	RETLDM
   22c30:	e49de008 	ldr	lr, [sp], #8
   22c34:	e12fff1e 	bx	lr

00022c38 <__aeabi_dcmpge>:

	FUNC_END aeabi_dcmple

ARM_FUNC_START	aeabi_dcmpge

	str	lr, [sp, #-8]!
   22c38:	e52de008 	str	lr, [sp, #-8]!
	ARM_CALL aeabi_cdrcmple
   22c3c:	ebffffde 	bl	22bbc <__aeabi_cdrcmple>
	do_it	ls, e
	movls	r0, #1	@ Operand 2 is less than or equal to operand 1.
   22c40:	93a00001 	movls	r0, #1
	movhi	r0, #0	@ Operand 2 greater than operand 1, or unordered.
   22c44:	83a00000 	movhi	r0, #0
	RETLDM
   22c48:	e49de008 	ldr	lr, [sp], #8
   22c4c:	e12fff1e 	bx	lr

00022c50 <__aeabi_dcmpgt>:

	FUNC_END aeabi_dcmpge

ARM_FUNC_START	aeabi_dcmpgt

	str	lr, [sp, #-8]!
   22c50:	e52de008 	str	lr, [sp, #-8]!
	ARM_CALL aeabi_cdrcmple
   22c54:	ebffffd8 	bl	22bbc <__aeabi_cdrcmple>
	do_it	cc, e
	movcc	r0, #1	@ Operand 2 is less than operand 1.
   22c58:	33a00001 	movcc	r0, #1
	movcs	r0, #0  @ Operand 2 is greater than or equal to operand 1,
   22c5c:	23a00000 	movcs	r0, #0
			@ or they are unordered.
	RETLDM
   22c60:	e49de008 	ldr	lr, [sp], #8
   22c64:	e12fff1e 	bx	lr

00022c68 <__aeabi_d2iz>:

ARM_FUNC_START fixdfsi
ARM_FUNC_ALIAS aeabi_d2iz fixdfsi

	@ check exponent range.
	mov	r2, xh, lsl #1
   22c68:	e1a02081 	lsl	r2, r1, #1
	adds	r2, r2, #(1 << 21)
   22c6c:	e2922602 	adds	r2, r2, #2097152	; 0x200000
	bcs	2f			@ value is INF or NAN
   22c70:	2a00000c 	bcs	22ca8 <__aeabi_d2iz+0x40>
	bpl	1f			@ value is too small
   22c74:	5a000009 	bpl	22ca0 <__aeabi_d2iz+0x38>
	mov	r3, #(0xfffffc00 + 31)
   22c78:	e3e03e3e 	mvn	r3, #992	; 0x3e0
	subs	r2, r3, r2, asr #21
   22c7c:	e0532ac2 	subs	r2, r3, r2, asr #21
	bls	3f			@ value is too large
   22c80:	9a00000a 	bls	22cb0 <__aeabi_d2iz+0x48>

	@ scale value
	mov	r3, xh, lsl #11
   22c84:	e1a03581 	lsl	r3, r1, #11
	orr	r3, r3, #0x80000000
   22c88:	e3833102 	orr	r3, r3, #-2147483648	; 0x80000000
	orr	r3, r3, xl, lsr #21
   22c8c:	e1833aa0 	orr	r3, r3, r0, lsr #21
	tst	xh, #0x80000000		@ the sign bit
   22c90:	e3110102 	tst	r1, #-2147483648	; 0x80000000
	shift1	lsr, r0, r3, r2
   22c94:	e1a00233 	lsr	r0, r3, r2
	do_it	ne
	rsbne	r0, r0, #0
   22c98:	12600000 	rsbne	r0, r0, #0
	RET
   22c9c:	e12fff1e 	bx	lr

1:	mov	r0, #0
   22ca0:	e3a00000 	mov	r0, #0
	RET
   22ca4:	e12fff1e 	bx	lr

2:	orrs	xl, xl, xh, lsl #12
   22ca8:	e1900601 	orrs	r0, r0, r1, lsl #12
	bne	4f			@ x is NAN.
   22cac:	1a000002 	bne	22cbc <__aeabi_d2iz+0x54>
3:	ands	r0, xh, #0x80000000	@ the sign bit
   22cb0:	e2110102 	ands	r0, r1, #-2147483648	; 0x80000000
	do_it	eq
	moveq	r0, #0x7fffffff		@ maximum signed positive si
   22cb4:	03e00102 	mvneq	r0, #-2147483648	; 0x80000000
	RET
   22cb8:	e12fff1e 	bx	lr

4:	mov	r0, #0			@ How should we convert NAN?
   22cbc:	e3a00000 	mov	r0, #0
	RET
   22cc0:	e12fff1e 	bx	lr
